{"sha": "af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "node_id": "C_kwDOAAsO6NoAKGFmNDg5YWZlYjdiNmNhNmYzMTg0OGM0MTQxNjUyZjRkY2IyYTdmYTY", "commit": {"author": {"name": "pat-nel87", "email": "71235856+pat-nel87@users.noreply.github.com", "date": "2023-03-26T15:20:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-26T15:20:56Z"}, "message": "Merge branch 'master' into Issue-107957-black_box_docs", "tree": {"sha": "f28bc68704d4bc0dc9a4490258b569f77e47d629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f28bc68704d4bc0dc9a4490258b569f77e47d629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkIGLYCRBK7hj4Ov3rIwAACUsIAHgmlAlF7Oh+R49JUn/cJIAn\niwrCzJF1uHIx44z0x5KEOgpwvngYwZLsPgpWvPxWvZdhuoFPeeP4Jgz5RlZcL+dn\nRA7xOg0Mf6yg/3VS//+fNWr6x+GqzguC9vC7AcumEyqxQyoQkWMNDZAaNZHS8281\nyoytB6rdcq2tecHmNdyUk6ECkquHZW5Mxs/lf6xR9HMGodZr2jZDZlTJgKvF/dHP\nVkx4pdA0xbgmZU1LKy34aCBj/m3qRH74Vo2f7fU9zlBSyh5o0RRkQhjS+Z9c/feP\nXA9YVGfF0Fd2OZsDhyg0j71BTlcs5mxxblbz+x/+PQjMZDG4OzA3rhnOua2vFTg=\n=jGoa\n-----END PGP SIGNATURE-----\n", "payload": "tree f28bc68704d4bc0dc9a4490258b569f77e47d629\nparent 21549dac539dc220f052d038ec643645cedbbd6d\nparent 89c2e3d3d75486e52473de3ae38f0ca6efeffef2\nauthor pat-nel87 <71235856+pat-nel87@users.noreply.github.com> 1679844056 -0400\ncommitter GitHub <noreply@github.com> 1679844056 -0400\n\nMerge branch 'master' into Issue-107957-black_box_docs"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "html_url": "https://github.com/rust-lang/rust/commit/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/comments", "author": {"login": "pat-nel87", "id": 71235856, "node_id": "MDQ6VXNlcjcxMjM1ODU2", "avatar_url": "https://avatars.githubusercontent.com/u/71235856?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pat-nel87", "html_url": "https://github.com/pat-nel87", "followers_url": "https://api.github.com/users/pat-nel87/followers", "following_url": "https://api.github.com/users/pat-nel87/following{/other_user}", "gists_url": "https://api.github.com/users/pat-nel87/gists{/gist_id}", "starred_url": "https://api.github.com/users/pat-nel87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pat-nel87/subscriptions", "organizations_url": "https://api.github.com/users/pat-nel87/orgs", "repos_url": "https://api.github.com/users/pat-nel87/repos", "events_url": "https://api.github.com/users/pat-nel87/events{/privacy}", "received_events_url": "https://api.github.com/users/pat-nel87/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21549dac539dc220f052d038ec643645cedbbd6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/21549dac539dc220f052d038ec643645cedbbd6d", "html_url": "https://github.com/rust-lang/rust/commit/21549dac539dc220f052d038ec643645cedbbd6d"}, {"sha": "89c2e3d3d75486e52473de3ae38f0ca6efeffef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/89c2e3d3d75486e52473de3ae38f0ca6efeffef2", "html_url": "https://github.com/rust-lang/rust/commit/89c2e3d3d75486e52473de3ae38f0ca6efeffef2"}], "stats": {"total": 123543, "additions": 86120, "deletions": 37423}, "files": [{"sha": "d29c15fe712f301a375385e3ad9d624937721371", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -9,7 +9,6 @@\n src/etc/installer/gfx/* binary\n src/vendor/** -text\n Cargo.lock linguist-generated=false\n-config.toml.example linguist-language=TOML\n \n # Older git versions try to fix line endings on images and fonts, this prevents it.\n *.png binary"}, {"sha": "b45246eb4ead81fde9f90d6857f73617d7395b97", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -48,19 +48,19 @@ jobs:\n         include:\n           - name: mingw-check\n             tidy: false\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: mingw-check-tidy\n             tidy: true\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-llvm-14\n             tidy: false\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-tools\n             tidy: false\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n@@ -181,136 +181,136 @@ jobs:\n               - ARM64\n               - linux\n           - name: arm-android\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: armhf-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-aarch64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-android\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-arm-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-armhf-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-armv7-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-i586-gnu-i586-i686-musl\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-i686-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mips-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mips64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mips64el-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-mipsel-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-powerpc-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-powerpc64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-powerpc64le-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-riscv64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-s390x-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-various-1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-various-2\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-freebsd\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-illumos\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-linux-alt\n             env:\n               IMAGE: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: dist-x86_64-musl\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: dist-x86_64-netbsd\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: i686-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: i686-gnu-nopt\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: mingw-check\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: test-various\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: wasm32\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-stable\n             env:\n               IMAGE: x86_64-gnu\n               RUST_CI_OVERRIDE_RELEASE_CHANNEL: stable\n               CI_ONLY_WHEN_CHANNEL: nightly\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-aux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-debug\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-distcheck\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-llvm-15\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-llvm-14\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-llvm-14-stage1\n             env:\n               RUST_BACKTRACE: 1\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: x86_64-gnu-nopt\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n           - name: x86_64-gnu-tools\n             env:\n               DEPLOY_TOOLSTATES_JSON: toolstates-linux.json\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n@@ -322,7 +322,7 @@ jobs:\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-apple-various\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n@@ -333,7 +333,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-x86_64-apple-alt\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n@@ -344,7 +344,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-1\n             env:\n               SCRIPT: \"./x.py --stage 2 test --exclude tests/ui --exclude tests/rustdoc --exclude tests/run-make-fulldeps\"\n@@ -355,7 +355,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-apple-2\n             env:\n               SCRIPT: \"./x.py --stage 2 test tests/ui tests/rustdoc tests/run-make-fulldeps\"\n@@ -366,7 +366,7 @@ jobs:\n               NO_LLVM_ASSERTIONS: 1\n               NO_DEBUG_ASSERTIONS: 1\n               NO_OVERFLOW_CHECKS: 1\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: dist-aarch64-apple\n             env:\n               SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n@@ -381,106 +381,106 @@ jobs:\n               NO_OVERFLOW_CHECKS: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n               JEMALLOC_SYS_WITH_LG_PAGE: 14\n-            os: macos-latest\n+            os: macos-12-xl\n           - name: x86_64-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n               SCRIPT: make ci-subset-1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-profiler\"\n               SCRIPT: make ci-subset-2\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-msvc-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n               SCRIPT: make ci-subset-1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-msvc-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc\"\n               SCRIPT: make ci-subset-2\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-cargo\n             env:\n               SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-msvc-tools\n             env:\n               SCRIPT: src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstate/toolstates.json windows\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstate/toolstates.json\"\n               DEPLOY_TOOLSTATES_JSON: toolstates-windows.json\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-mingw-1\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-1\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: i686-mingw-2\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu\"\n               SCRIPT: make ci-mingw-subset-2\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-mingw-1\n             env:\n               SCRIPT: make ci-mingw-subset-1\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: x86_64-mingw-2\n             env:\n               SCRIPT: make ci-mingw-subset-2\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-msvc\n             env:\n-              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler --set rust.lto=thin\"\n+              RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: PGO_HOST=x86_64-pc-windows-msvc python src/ci/stage-build.py python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-i686-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --host=i686-pc-windows-msvc --target=i686-pc-windows-msvc,i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-aarch64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n               WINDOWS_SDK_20348_HACK: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-mingw\n             env:\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n           - name: dist-x86_64-msvc-alt\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n               SCRIPT: python x.py dist bootstrap --include-default-paths\n-            os: windows-latest-xl\n+            os: windows-2019-8core-32gb\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\"\n     steps:\n@@ -595,7 +595,7 @@ jobs:\n       matrix:\n         include:\n           - name: dist-x86_64-linux\n-            os: ubuntu-20.04-xl\n+            os: ubuntu-20.04-16core-64gb\n             env: {}\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\""}, {"sha": "485968d9c56ff5a3a37c74b331704914da82011c", "filename": ".gitignore", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -21,6 +21,7 @@ Session.vim\n .project\n .favorites.json\n .settings/\n+.vs/\n \n ## Tool\n .valgrindrc\n@@ -41,7 +42,8 @@ no_llvm_build\n /inst/\n /llvm/\n /mingw-build/\n-/build/\n+build/\n+!/compiler/rustc_mir_build/src/build/\n /build-rust-analyzer/\n /dist/\n /unicode-downloads"}, {"sha": "0bbccb57130225dda1105ac59dcb250094dc97a3", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,3 @@\n-[submodule \"src/rust-installer\"]\n-\tpath = src/tools/rust-installer\n-\turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/doc/nomicon\"]\n \tpath = src/doc/nomicon\n \turl = https://github.com/rust-lang/nomicon.git\n@@ -28,7 +25,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/15.0-2022-12-07\n+\tbranch = rustc/16.0-2023-03-06\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "9148b79e98016352998379523954214a8f065269", "filename": ".mailmap", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -15,7 +15,7 @@ Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n Ahmed Charles <ahmedcharles@gmail.com> <acharles@outlook.com>\n Alan Egerton <eggyal@gmail.com>\n Alan Stoate <alan.stoate@gmail.com>\n-Albert Larsan <albert.larsan@gmail.com> Albert Larsan <74931857+albertlarsan68@users.noreply.github.com>\n+Albert Larsan <albert.larsan@gmail.com> <74931857+albertlarsan68@users.noreply.github.com>\n Alessandro Decina <alessandro.d@gmail.com>\n Alex Burka <durka42+github@gmail.com> Alex Burka <aburka@seas.upenn.edu>\n Alex Hansen <ahansen2@trinity.edu>\n@@ -29,6 +29,8 @@ Alexander Ronald Altman <alexanderaltman@me.com>\n Alexandre Martin <martin.alex32@hotmail.fr>\n Alexis Beingessner <a.beingessner@gmail.com>\n Alfie John <alfie@alfie.wtf> Alfie John <alfiej@fastmail.fm>\n+Alona Enraght-Moony <code@alona.page> <nixon.emoony@gmail.com>\n+Alona Enraght-Moony <code@alona.page> <nixon@caminus.local>\n Amos Onn <amosonn@gmail.com>\n Ana-Maria Mihalache <mihalacheana.maria@yahoo.com>\n Anatoly Ikorsky <aikorsky@gmail.com>\n@@ -415,7 +417,6 @@ Nicolas Abram <abramlujan@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Nika Layzell <nika@thelayzells.com> <michael@thelayzells.com>\n-Nixon Enraght-Moony <nixon.emoony@gmail.com>\n NODA Kai <nodakai@gmail.com>\n oliver <16816606+o752d@users.noreply.github.com>\n Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>"}, {"sha": "9a59f455fe9afdf4156bb99f3f54bf07d2df6b59", "filename": ".reuse/dep5", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.reuse%2Fdep5", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/.reuse%2Fdep5", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.reuse%2Fdep5?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,23 +1,99 @@\n+# WARNING: this metadata is currently incomplete, do not rely on it yet.\n+\n Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/\n Files-Excluded:\n  src/llvm-project\n \n-Files: *\n+# Note that we're explicitly listing the individual files at the root of the\n+# repository rather than just having `Files: *`. This is explicitly done to\n+# help downstream forks of the Rust compiler: this way, the files they add\n+# won't be automatically marked as authored by the Rust project.\n+Files: compiler/*\n+       library/*\n+       tests/*\n+       src/*\n+       .github/*\n+       Cargo.lock\n+       Cargo.toml\n+       CODE_OF_CONDUCT.md\n+       config.example.toml\n+       configure\n+       CONTRIBUTING.md\n+       COPYRIGHT\n+       LICENSE-APACHE\n+       LICENSE-MIT\n+       README.md\n+       RELEASES.md\n+       rustfmt.toml\n+       triagebot.toml\n+       x\n+       x.ps1\n+       x.py\n+       .editorconfig\n+       .git-blame-ignore-revs\n+       .gitattributes\n+       .gitignore\n+       .gitmodules\n+       .mailmap\n Copyright: The Rust Project Developers (see https://thanks.rust-lang.org)\n License: MIT or Apache-2.0\n \n+Files: compiler/rustc_apfloat/*\n+Copyright: LLVM APFloat authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: NCSA AND (MIT OR Apache-2.0)\n+\n+Files: compiler/rustc_codegen_cranelift/src/cranelift_native.rs\n+Copyright: The Cranelift Project Developers\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: Apache-2.0 WITH LLVM-exception AND (Apache-2.0 OR MIT)\n+\n+Files: compiler/rustc_llvm/llvm-wrapper/SymbolWrapper.cpp\n+Copyright: LLVM authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: Apache-2.0 WITH LLVM-exception AND (Apache-2.0 OR MIT)\n+\n+Files: library/core/src/unicode/unicode_data.rs\n+Copyright: 1991-2022 Unicode, Inc. All rights reserved.\n+License: Unicode-DFS-2016\n+\n+Files: library/std/src/sync/mpmc/*\n+Copyright: 2019 The Crossbeam Project Developers\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT OR Apache-2.0\n+\n+Files: library/std/src/sys/unix/locks/fuchsia_mutex.rs\n+Copyright: 2016 The Fuchsia Authors\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: BSD-2-Clause AND (MIT OR Apache-2.0)\n+\n+Files: src/test/rustdoc/auxiliary/enum-primitive.rs\n+Copyright: 2015 Anders Kaseorg <andersk@mit.edu>\n+License: MIT\n+\n Files: src/librustdoc/html/static/fonts/FiraSans*\n-Copyright: 2014, Mozilla Foundation, 2014, Telefonica S.A.\n+Copyright: 2014, Mozilla Foundation\n+           2014, Telefonica S.A.\n License: OFL-1.1\n \n Files: src/librustdoc/html/static/fonts/NanumBarun*\n Copyright: 2010 NAVER Corporation\n License: OFL-1.1\n \n Files: src/librustdoc/html/static/fonts/SourceCodePro*\n-Copyright: 2010, 2012 Adobe Systems Incorporated\n+       src/librustdoc/html/static/fonts/SourceSerif4*\n+Copyright: 2010, 2012, 2014-2023, Adobe Systems Incorporated\n License: OFL-1.1\n \n-Files: src/librustdoc/html/static/fonts/SourceSerif4*\n-Copyright: 2014-2021 Adobe Systems Incorporated\n-License: OFL-1.1\n+Files: src/librustdoc/html/static/css/normalize.css\n+Copyright: Nicolas Gallagher and Jonathan Neal\n+License: MIT\n+\n+Files: src/librustdoc/html/static/css/themes/ayu.css\n+Copyright: Ike Ku, Jessica Stokes, Leon Guan\n+           The Rust Project Developers (see https://thanks.rust-lang.org)\n+License: MIT OR Apache-2.0\n+\n+Files: src/doc/rustc-dev-guide/mermaid.min.js\n+Copyright: Knut Sveidqvist\n+License: MIT"}, {"sha": "449f0c73588eb83a52de26215e0b16b5720dc753", "filename": "Cargo.lock", "status": "modified", "additions": 903, "deletions": 213, "changes": 1116, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -42,6 +42,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bf6ccdb167abbf410dcb915cabd428929d7f6a04980b54a11f26a39f1c7f7107\"\n dependencies = [\n  \"cfg-if\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n ]\n@@ -112,6 +113,12 @@ dependencies = [\n  \"object 0.29.0\",\n ]\n \n+[[package]]\n+name = \"arc-swap\"\n+version = \"1.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bddcadddf5e9015d310179a59bb28c4d4b9920ad0f11e8e14dbadf654890c9a6\"\n+\n [[package]]\n name = \"array_tool\"\n version = \"1.0.3\"\n@@ -132,47 +139,36 @@ checksum = \"5a2f58b0bb10c380af2b26e57212856b8c9a59e0925b4c20f4a174a49734eaf7\"\n \n [[package]]\n name = \"askama\"\n-version = \"0.11.0\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4d8f355701c672c2ba3d718acbd213f740beea577cc4eae66accdffe15be1882\"\n+checksum = \"47cbc3cf73fa8d9833727bbee4835ba5c421a0d65b72daf9a7b5d0e0f9cfb57e\"\n dependencies = [\n  \"askama_derive\",\n  \"askama_escape\",\n- \"askama_shared\",\n ]\n \n [[package]]\n name = \"askama_derive\"\n-version = \"0.11.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"84704cab5b7ae0fd3a9f78ee5eb7b27f3749df445f04623db6633459ae283267\"\n-dependencies = [\n- \"askama_shared\",\n- \"proc-macro2\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"askama_escape\"\n-version = \"0.10.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9a1bb320f97e6edf9f756bf015900038e43c7700e059688e5724a928c8f3b8d5\"\n-\n-[[package]]\n-name = \"askama_shared\"\n version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dae03eebba55a2697a376e58b573a29fe36893157173ac8df312ad85f3c0e012\"\n+checksum = \"e80b5ad1afe82872b7aa3e9de9b206ecb85584aa324f0f60fa4c903ce935936b\"\n dependencies = [\n- \"askama_escape\",\n+ \"basic-toml\",\n+ \"mime\",\n+ \"mime_guess\",\n  \"nom\",\n  \"proc-macro2\",\n  \"quote\",\n  \"serde\",\n  \"syn\",\n- \"toml 0.5.7\",\n ]\n \n+[[package]]\n+name = \"askama_escape\"\n+version = \"0.10.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"619743e34b5ba4e9703bba34deac3427c72507c7159f5fd030aea8cac0cfe341\"\n+\n [[package]]\n name = \"atty\"\n version = \"0.2.14\"\n@@ -213,16 +209,25 @@ checksum = \"349a06037c7bf932dd7e7d1f653678b2038b9ad46a74102f1fc7bd7872678cce\"\n \n [[package]]\n name = \"base64\"\n-version = \"0.13.1\"\n+version = \"0.21.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e1b586273c5702936fe7b7d6896644d8be71e6314cfe09d3167c95f712589e8\"\n+checksum = \"a4a4ddaa51a5bc52a6948f74c06d20aaaddb71924eab79b8c97a8c556e942d6a\"\n \n [[package]]\n name = \"base64ct\"\n version = \"1.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b645a089122eccb6111b4f81cbc1a49f5900ac4666bb93ac027feaecf15607bf\"\n \n+[[package]]\n+name = \"basic-toml\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c0de75129aa8d0cceaf750b89013f0e08804d6ec61416da787b35ad0d7cddf1\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -260,23 +265,32 @@ dependencies = [\n \n [[package]]\n name = \"bstr\"\n-version = \"1.0.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fca0852af221f458706eb0725c03e4ed6c46af9ac98e6a689d5e634215d594dd\"\n+checksum = \"5ffdb39cb703212f3c11973452c2861b972f757b021158f3516ba10f2fa8b2c1\"\n dependencies = [\n  \"memchr\",\n  \"once_cell\",\n  \"regex-automata 0.1.10\",\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"btoi\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9dd6407f73a9b8b6162d8a2ef999fe6afd7cc15902ebf42c5cd296addf17e0ad\"\n+dependencies = [\n+ \"num-traits\",\n+]\n+\n [[package]]\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"flate2\",\n- \"hex 0.4.2\",\n+ \"hex\",\n  \"rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -339,7 +353,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.70.0\"\n+version = \"0.71.0\"\n dependencies = [\n  \"anyhow\",\n  \"base64\",\n@@ -358,8 +372,10 @@ dependencies = [\n  \"fwdansi\",\n  \"git2\",\n  \"git2-curl\",\n+ \"gix\",\n+ \"gix-features\",\n  \"glob\",\n- \"hex 0.4.2\",\n+ \"hex\",\n  \"hmac\",\n  \"home\",\n  \"http-auth\",\n@@ -444,7 +460,7 @@ dependencies = [\n  \"directories\",\n  \"rustc-build-sysroot\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.1\",\n+ \"rustc_tools_util\",\n  \"rustc_version\",\n  \"serde\",\n  \"serde_json\",\n@@ -498,18 +514,18 @@ dependencies = [\n \n [[package]]\n name = \"cargo-util\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n dependencies = [\n  \"anyhow\",\n  \"core-foundation\",\n- \"crypto-hash\",\n  \"filetime\",\n- \"hex 0.4.2\",\n+ \"hex\",\n  \"jobserver\",\n  \"libc\",\n  \"log\",\n  \"miow 0.5.0\",\n  \"same-file\",\n+ \"sha2\",\n  \"shell-escape\",\n  \"tempfile\",\n  \"walkdir\",\n@@ -722,7 +738,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"clap 4.1.4\",\n  \"clippy_lints\",\n@@ -738,7 +754,7 @@ dependencies = [\n  \"regex\",\n  \"rustc-semver\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.3.0\",\n+ \"rustc_tools_util\",\n  \"semver\",\n  \"serde\",\n  \"syn\",\n@@ -765,7 +781,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"cargo_metadata 0.15.3\",\n  \"clippy_utils\",\n@@ -788,14 +804,20 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"arrayvec 0.7.0\",\n  \"if_chain\",\n  \"itertools\",\n  \"rustc-semver\",\n ]\n \n+[[package]]\n+name = \"clru\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b8191fa7302e03607ff0e237d4246cc043ff5b3cb9409d995172ba3bea16b807\"\n+\n [[package]]\n name = \"collect-license-metadata\"\n version = \"0.1.0\"\n@@ -844,24 +866,6 @@ dependencies = [\n  \"winapi\",\n ]\n \n-[[package]]\n-name = \"commoncrypto\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d056a8586ba25a1e4d61cb090900e495952c7886786fc55f909ab2f819b69007\"\n-dependencies = [\n- \"commoncrypto-sys\",\n-]\n-\n-[[package]]\n-name = \"commoncrypto-sys\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1fed34f46747aa73dfaa578069fd8279d2818ade2b55f38f22a9401c7f4083e2\"\n-dependencies = [\n- \"libc\",\n-]\n-\n [[package]]\n name = \"compiler_builtins\"\n version = \"0.1.87\"\n@@ -894,7 +898,7 @@ dependencies = [\n  \"tracing-subscriber\",\n  \"unified-diff\",\n  \"walkdir\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -997,7 +1001,7 @@ dependencies = [\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.35.1\"\n+version = \"0.36.0\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n@@ -1081,18 +1085,6 @@ dependencies = [\n  \"typenum\",\n ]\n \n-[[package]]\n-name = \"crypto-hash\"\n-version = \"0.3.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8a77162240fd97248d19a564a565eb563a3f592b386e4136fb300909e67dddca\"\n-dependencies = [\n- \"commoncrypto\",\n- \"hex 0.3.2\",\n- \"openssl\",\n- \"winapi\",\n-]\n-\n [[package]]\n name = \"cstr\"\n version = \"0.2.8\"\n@@ -1136,9 +1128,9 @@ dependencies = [\n \n [[package]]\n name = \"curl-sys\"\n-version = \"0.4.59+curl-7.86.0\"\n+version = \"0.4.61+curl-8.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6cfce34829f448b08f55b7db6d0009e23e2e86a34e8c2b366269bf5799b4a407\"\n+checksum = \"14d05c10f541ae6f3bc5b3d923c20001f47db7d5f0b2bc6ad16490133842db79\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1158,7 +1150,7 @@ checksum = \"a0afaad2b26fa326569eb264b1363e8ae3357618c43982b3f285f0774ce76b69\"\n \n [[package]]\n name = \"declare_clippy_lint\"\n-version = \"0.1.69\"\n+version = \"0.1.70\"\n dependencies = [\n  \"itertools\",\n  \"quote\",\n@@ -1297,9 +1289,9 @@ dependencies = [\n \n [[package]]\n name = \"dunce\"\n-version = \"1.0.2\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"453440c271cf5577fd2a40e4942540cb7d0d2f85e27c8d07dd0023c925a67541\"\n+checksum = \"0bd4b30a6560bbd9b4620f4de34c3f14f60848e58a9b7216801afcb4c7b31c3c\"\n \n [[package]]\n name = \"ecdsa\"\n@@ -1373,9 +1365,9 @@ dependencies = [\n \n [[package]]\n name = \"ena\"\n-version = \"0.14.0\"\n+version = \"0.14.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d7402b94a93c24e742487327a7cd839dc9d36fec9de9fb25b09f2dae459f36c3\"\n+checksum = \"c533630cf40e9caa44bd91aadc88a75d75a4c3a12b4cfde353cbed41daa1e1f1\"\n dependencies = [\n  \"log\",\n ]\n@@ -1445,6 +1437,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"mdbook\",\n+ \"rustc_error_codes\",\n ]\n \n [[package]]\n@@ -1508,14 +1501,14 @@ checksum = \"a214f5bb88731d436478f3ae1f8a277b62124089ba9fb67f4f93fb100ef73c90\"\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.14\"\n+version = \"0.2.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d34cfa13a63ae058bfa601fe9e313bbdb3746427c1459185464ce0fcf62e1e8\"\n+checksum = \"8a3de6e8d11b22ff9edc6d916f890800597d60f8b2da1caf2955c274638d6412\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n  \"redox_syscall\",\n- \"winapi\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -1706,115 +1699,668 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6ee7c6485c30167ce4dfb83ac568a849fe53274c831081476ee13e0dce1aad72\"\n \n [[package]]\n-name = \"futures-util\"\n-version = \"0.3.19\"\n+name = \"futures-util\"\n+version = \"0.3.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b5cf40b47a271f77a8b1bec03ca09044d99d2372c0de244e66430761127164\"\n+dependencies = [\n+ \"futures-channel\",\n+ \"futures-core\",\n+ \"futures-io\",\n+ \"futures-macro\",\n+ \"futures-sink\",\n+ \"futures-task\",\n+ \"memchr\",\n+ \"pin-project-lite\",\n+ \"pin-utils\",\n+ \"slab\",\n+]\n+\n+[[package]]\n+name = \"fwdansi\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"08c1f5787fe85505d1f7777268db5103d80a7a374d2316a7ce262e57baf8f208\"\n+dependencies = [\n+ \"memchr\",\n+ \"termcolor\",\n+]\n+\n+[[package]]\n+name = \"generate-copyright\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"generic-array\"\n+version = \"0.14.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"501466ecc8a30d1d3b7fc9229b122b2ce8ed6e9d9223f1138d4babb253e51817\"\n+dependencies = [\n+ \"typenum\",\n+ \"version_check\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n+dependencies = [\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"js-sys\",\n+ \"libc\",\n+ \"wasi\",\n+ \"wasm-bindgen\",\n+]\n+\n+[[package]]\n+name = \"gimli\"\n+version = \"0.26.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"fallible-iterator\",\n+ \"indexmap\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+ \"stable_deref_trait\",\n+]\n+\n+[[package]]\n+name = \"git2\"\n+version = \"0.16.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"be36bc9e0546df253c0cc41fd0af34f5e92845ad8509462ec76672fac6997f5b\"\n+dependencies = [\n+ \"bitflags\",\n+ \"libc\",\n+ \"libgit2-sys\",\n+ \"log\",\n+ \"openssl-probe\",\n+ \"openssl-sys\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"git2-curl\"\n+version = \"0.17.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7577f4e6341ba7c90d883511130a45b956c274ba5f4d205d9f9da990f654cd33\"\n+dependencies = [\n+ \"curl\",\n+ \"git2\",\n+ \"log\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"gix\"\n+version = \"0.39.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dabfac58aecb4a38cdd2568de66eb1f0d968fd6726f5a80cb8bea7944ef10cc0\"\n+dependencies = [\n+ \"gix-actor\",\n+ \"gix-attributes\",\n+ \"gix-config\",\n+ \"gix-credentials\",\n+ \"gix-date\",\n+ \"gix-diff\",\n+ \"gix-discover\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-index\",\n+ \"gix-lock\",\n+ \"gix-mailmap\",\n+ \"gix-object\",\n+ \"gix-odb\",\n+ \"gix-pack\",\n+ \"gix-path\",\n+ \"gix-prompt\",\n+ \"gix-protocol\",\n+ \"gix-ref\",\n+ \"gix-refspec\",\n+ \"gix-revision\",\n+ \"gix-sec\",\n+ \"gix-tempfile\",\n+ \"gix-transport\",\n+ \"gix-traverse\",\n+ \"gix-url\",\n+ \"gix-validate\",\n+ \"gix-worktree\",\n+ \"log\",\n+ \"once_cell\",\n+ \"prodash\",\n+ \"signal-hook\",\n+ \"smallvec\",\n+ \"thiserror\",\n+ \"unicode-normalization\",\n+]\n+\n+[[package]]\n+name = \"gix-actor\"\n+version = \"0.19.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dc22b0cdc52237667c301dd7cdc6ead8f8f73c9f824e9942c8ebd6b764f6c0bf\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"gix-date\",\n+ \"itoa\",\n+ \"nom\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-attributes\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2231a25934a240d0a4b6f4478401c73ee81d8be52de0293eedbc172334abf3e1\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-path\",\n+ \"gix-quote\",\n+ \"thiserror\",\n+ \"unicode-bom\",\n+]\n+\n+[[package]]\n+name = \"gix-bitmap\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"024bca0c7187517bda5ea24ab148c9ca8208dd0c3e2bea88cdb2008f91791a6d\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-chunk\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b0d39583cab06464b8bf73b3f1707458270f0e7383cb24c3c9c1a16e6f792978\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-command\"\n+version = \"0.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b2c6f75c1e0f924de39e750880a6e21307194bb1ab773efe3c7d2d787277f8ab\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+]\n+\n+[[package]]\n+name = \"gix-config\"\n+version = \"0.18.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"52c62e26ce11f607712e4f49a0a192ed87675d30187fd61be070abbd607d12f1\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-config-value\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-path\",\n+ \"gix-ref\",\n+ \"gix-sec\",\n+ \"memchr\",\n+ \"nom\",\n+ \"once_cell\",\n+ \"smallvec\",\n+ \"thiserror\",\n+ \"unicode-bom\",\n+]\n+\n+[[package]]\n+name = \"gix-config-value\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"693d4a4ba0531e46fe558459557a5b29fb86c3e4b2666c1c0861d93c7c678331\"\n+dependencies = [\n+ \"bitflags\",\n+ \"bstr 1.3.0\",\n+ \"gix-path\",\n+ \"libc\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-credentials\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5be32b5fe339a31b8e53fa854081dc914c45020dcb64637f3c21baf69c96fc1b\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-command\",\n+ \"gix-config-value\",\n+ \"gix-path\",\n+ \"gix-prompt\",\n+ \"gix-sec\",\n+ \"gix-url\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-date\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b96271912ce39822501616f177dea7218784e6c63be90d5f36322ff3a722aae2\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"itoa\",\n+ \"thiserror\",\n+ \"time 0.3.17\",\n+]\n+\n+[[package]]\n+name = \"gix-diff\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"585b0834d4b6791a848637c4e109545fda9b0f29b591ba55edb33ceda6e7856b\"\n+dependencies = [\n+ \"gix-hash\",\n+ \"gix-object\",\n+ \"imara-diff\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-discover\"\n+version = \"0.15.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"91c204adba5ebd211c74735cbb65817d277e154486bac0dffa3701f163b80350\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"dunce\",\n+ \"gix-hash\",\n+ \"gix-path\",\n+ \"gix-ref\",\n+ \"gix-sec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-features\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5e6a9dfa7b3c1a99315203e8b97f8f99f3bd95731590607abeaa5ca31bc41fe3\"\n+dependencies = [\n+ \"bytes\",\n+ \"crc32fast\",\n+ \"crossbeam-channel\",\n+ \"flate2\",\n+ \"gix-hash\",\n+ \"libc\",\n+ \"once_cell\",\n+ \"parking_lot 0.12.1\",\n+ \"prodash\",\n+ \"sha1_smol\",\n+ \"thiserror\",\n+ \"walkdir\",\n+]\n+\n+[[package]]\n+name = \"gix-glob\"\n+version = \"0.5.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"93e43efd776bc543f46f0fd0ca3d920c37af71a764a16f2aebd89765e9ff2993\"\n+dependencies = [\n+ \"bitflags\",\n+ \"bstr 1.3.0\",\n+]\n+\n+[[package]]\n+name = \"gix-hash\"\n+version = \"0.10.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0c0c5a9f4d621d4f4ea046bb331df5c746ca735b8cae5b234cc2be70ee4dbef0\"\n+dependencies = [\n+ \"hex\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-hashtable\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9609c1b8f36f12968e6a6098f7cdb52004f7d42d570f47a2d6d7c16612f19acb\"\n+dependencies = [\n+ \"gix-hash\",\n+ \"hashbrown 0.13.1\",\n+ \"parking_lot 0.12.1\",\n+]\n+\n+[[package]]\n+name = \"gix-index\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c12caf7886c7ba06f2b28835cdc2be1dca86bd047d00299d2d49e707ce1c2616\"\n+dependencies = [\n+ \"bitflags\",\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"filetime\",\n+ \"gix-bitmap\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-lock\",\n+ \"gix-object\",\n+ \"gix-traverse\",\n+ \"itoa\",\n+ \"memmap2 0.5.10\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-lock\"\n+version = \"4.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66119ff8a4a395d0ea033fef718bc85f8b4f0855874f4ce1e005fc16cfe1f66e\"\n+dependencies = [\n+ \"fastrand\",\n+ \"gix-tempfile\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-mailmap\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2b66aea5e52875cd4915f4957a6f4b75831a36981e2ec3f5fad9e370e444fe1a\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-actor\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-object\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8df068db9180ee935fbb70504848369e270bdcb576b05c0faa8b9fd3b86fc017\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"gix-actor\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-validate\",\n+ \"hex\",\n+ \"itoa\",\n+ \"nom\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-odb\"\n+version = \"0.42.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e9a5f9e1afbd509761977a2ea02869cedaaba500b4e783deb2e4de5179a55a80\"\n+dependencies = [\n+ \"arc-swap\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-object\",\n+ \"gix-pack\",\n+ \"gix-path\",\n+ \"gix-quote\",\n+ \"parking_lot 0.12.1\",\n+ \"tempfile\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-pack\"\n+version = \"0.32.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e51db84e1459a8022e518d40a8778028d793dbb28e4d35c9a5eaf92658fb0775\"\n+dependencies = [\n+ \"clru\",\n+ \"gix-chunk\",\n+ \"gix-diff\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-object\",\n+ \"gix-path\",\n+ \"gix-tempfile\",\n+ \"gix-traverse\",\n+ \"memmap2 0.5.10\",\n+ \"parking_lot 0.12.1\",\n+ \"smallvec\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-packetline\"\n+version = \"0.14.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d63e5e5a9a92d4fc6b63ff9d94954d25c779ce25c98d5bbe2e4399aa42f7073c\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"hex\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-path\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f6c104a66dec149cb8f7aaafc6ab797654cf82d67f050fd0cb7e7294e328354b\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-prompt\"\n+version = \"0.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a20cebf73229debaa82574c4fd20dcaf00fa8d4bfce823a862c4e990d7a0b5b4\"\n+dependencies = [\n+ \"gix-command\",\n+ \"gix-config-value\",\n+ \"nix\",\n+ \"parking_lot 0.12.1\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-protocol\"\n+version = \"0.28.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d372ab11d5d28ac21800e3f1a6603a67c1ead57f6f5fab07e1e73e960f331c1\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"gix-credentials\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-transport\",\n+ \"maybe-async\",\n+ \"nom\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-quote\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a282f5a8d9ee0b09ec47390ac727350c48f2f5c76d803cd8da6b3e7ad56e0bcb\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"btoi\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-ref\"\n+version = \"0.26.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"90a0ed29e581f04b904ecd0c32b11f33b8209b5a0af9c43f415249a4f2fba632\"\n+dependencies = [\n+ \"gix-actor\",\n+ \"gix-features\",\n+ \"gix-hash\",\n+ \"gix-lock\",\n+ \"gix-object\",\n+ \"gix-path\",\n+ \"gix-tempfile\",\n+ \"gix-validate\",\n+ \"memmap2 0.5.10\",\n+ \"nom\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"gix-refspec\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d9b5cf40b47a271f77a8b1bec03ca09044d99d2372c0de244e66430761127164\"\n+checksum = \"aba332462bda2e8efeae4302b39a6ed01ad56ef772fd5b7ef197cf2798294d65\"\n dependencies = [\n- \"futures-channel\",\n- \"futures-core\",\n- \"futures-io\",\n- \"futures-macro\",\n- \"futures-sink\",\n- \"futures-task\",\n- \"memchr\",\n- \"pin-project-lite\",\n- \"pin-utils\",\n- \"slab\",\n+ \"bstr 1.3.0\",\n+ \"gix-hash\",\n+ \"gix-revision\",\n+ \"gix-validate\",\n+ \"smallvec\",\n+ \"thiserror\",\n ]\n \n [[package]]\n-name = \"fwdansi\"\n-version = \"1.1.0\"\n+name = \"gix-revision\"\n+version = \"0.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08c1f5787fe85505d1f7777268db5103d80a7a374d2316a7ce262e57baf8f208\"\n+checksum = \"ed98e4a0254953c64bc913bd23146a1de662067d5cf974cbdde396958b39e5b0\"\n dependencies = [\n- \"memchr\",\n- \"termcolor\",\n+ \"bstr 1.3.0\",\n+ \"gix-date\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-object\",\n+ \"thiserror\",\n ]\n \n [[package]]\n-name = \"generate-copyright\"\n-version = \"0.1.0\"\n+name = \"gix-sec\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e8ffa5bf0772f9b01de501c035b6b084cf9b8bb07dec41e3afc6a17336a65f47\"\n dependencies = [\n- \"anyhow\",\n- \"serde\",\n- \"serde_json\",\n+ \"bitflags\",\n+ \"dirs\",\n+ \"gix-path\",\n+ \"libc\",\n+ \"windows 0.43.0\",\n ]\n \n [[package]]\n-name = \"generic-array\"\n-version = \"0.14.4\"\n+name = \"gix-tempfile\"\n+version = \"4.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"501466ecc8a30d1d3b7fc9229b122b2ce8ed6e9d9223f1138d4babb253e51817\"\n+checksum = \"88751f247234b1f73c8e8056fd835a0999b04e596e052302cb71186005dc4b27\"\n dependencies = [\n- \"typenum\",\n- \"version_check\",\n+ \"libc\",\n+ \"once_cell\",\n+ \"parking_lot 0.12.1\",\n+ \"signal-hook\",\n+ \"signal-hook-registry\",\n+ \"tempfile\",\n ]\n \n [[package]]\n-name = \"getopts\"\n-version = \"0.2.21\"\n+name = \"gix-transport\"\n+version = \"0.27.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n+checksum = \"d633947b36a2fbbc089195bdc71621158f1660c2ff2a6b12b0279c16e2f764bc\"\n dependencies = [\n- \"rustc-std-workspace-core\",\n- \"rustc-std-workspace-std\",\n- \"unicode-width\",\n+ \"base64\",\n+ \"bstr 1.3.0\",\n+ \"curl\",\n+ \"gix-command\",\n+ \"gix-credentials\",\n+ \"gix-features\",\n+ \"gix-packetline\",\n+ \"gix-quote\",\n+ \"gix-sec\",\n+ \"gix-url\",\n+ \"thiserror\",\n ]\n \n [[package]]\n-name = \"getrandom\"\n-version = \"0.2.8\"\n+name = \"gix-traverse\"\n+version = \"0.24.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c05aeb6a22b8f62540c194aac980f2115af067bfe15a0734d7277a768d396b31\"\n+checksum = \"dd9a4a07bb22168dc79c60e1a6a41919d198187ca83d8a5940ad8d7122a45df3\"\n dependencies = [\n- \"cfg-if\",\n- \"js-sys\",\n- \"libc\",\n- \"wasi\",\n- \"wasm-bindgen\",\n+ \"gix-hash\",\n+ \"gix-hashtable\",\n+ \"gix-object\",\n+ \"thiserror\",\n ]\n \n [[package]]\n-name = \"gimli\"\n-version = \"0.26.2\"\n+name = \"gix-url\"\n+version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22030e2c5a68ec659fde1e949a745124b48e6fa8b045b7ed5bd1fe4ccc5c4e5d\"\n+checksum = \"044072b7ce8601b62dcec841b92129f5cc677072823324121b395d766ac5f528\"\n dependencies = [\n- \"compiler_builtins\",\n- \"fallible-iterator\",\n- \"indexmap\",\n- \"rustc-std-workspace-alloc\",\n- \"rustc-std-workspace-core\",\n- \"stable_deref_trait\",\n+ \"bstr 1.3.0\",\n+ \"gix-features\",\n+ \"gix-path\",\n+ \"home\",\n+ \"thiserror\",\n+ \"url\",\n ]\n \n [[package]]\n-name = \"git2\"\n-version = \"0.16.0\"\n+name = \"gix-validate\"\n+version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be36bc9e0546df253c0cc41fd0af34f5e92845ad8509462ec76672fac6997f5b\"\n+checksum = \"b69ddb780ea1465255e66818d75b7098371c58dbc9560da4488a44b9f5c7e443\"\n dependencies = [\n- \"bitflags\",\n- \"libc\",\n- \"libgit2-sys\",\n- \"log\",\n- \"openssl-probe\",\n- \"openssl-sys\",\n- \"url\",\n+ \"bstr 1.3.0\",\n+ \"thiserror\",\n ]\n \n [[package]]\n-name = \"git2-curl\"\n-version = \"0.17.0\"\n+name = \"gix-worktree\"\n+version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7577f4e6341ba7c90d883511130a45b956c274ba5f4d205d9f9da990f654cd33\"\n-dependencies = [\n- \"curl\",\n- \"git2\",\n- \"log\",\n- \"url\",\n+checksum = \"b7cb9af6e56152953d8fe113c4f9d7cf60cf7a982362711e9200a255579b49cb\"\n+dependencies = [\n+ \"bstr 1.3.0\",\n+ \"gix-attributes\",\n+ \"gix-features\",\n+ \"gix-glob\",\n+ \"gix-hash\",\n+ \"gix-index\",\n+ \"gix-object\",\n+ \"gix-path\",\n+ \"io-close\",\n+ \"thiserror\",\n ]\n \n [[package]]\n@@ -1923,22 +2469,15 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.6\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n+checksum = \"856b5cb0902c2b6d65d5fd97dfa30f9b70c7538e770b98eab5ed52d8db923e01\"\n dependencies = [\n  \"compiler_builtins\",\n- \"libc\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n-[[package]]\n-name = \"hex\"\n-version = \"0.3.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n-\n [[package]]\n name = \"hex\"\n version = \"0.4.2\"\n@@ -2132,6 +2671,16 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"imara-diff\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98c1d0ad70fc91b8b9654b1f33db55e59579d3b3de2bffdced0fdb810570cb8\"\n+dependencies = [\n+ \"ahash 0.8.2\",\n+ \"hashbrown 0.12.3\",\n+]\n+\n [[package]]\n name = \"indenter\"\n version = \"0.3.3\"\n@@ -2201,6 +2750,16 @@ dependencies = [\n  \"unic-langid\",\n ]\n \n+[[package]]\n+name = \"io-close\"\n+version = \"0.3.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9cadcf447f06744f8ce713d2d6239bb5bde2c357a452397a9ed90c625da390bc\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n [[package]]\n name = \"io-lifetimes\"\n version = \"1.0.3\"\n@@ -2213,14 +2772,14 @@ dependencies = [\n \n [[package]]\n name = \"is-terminal\"\n-version = \"0.4.2\"\n+version = \"0.4.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28dfb6c8100ccc63462345b67d1bbc3679177c75ee4bf59bf29c8b1d110b8189\"\n+checksum = \"21b6b32576413a8e69b90e952e4a026476040d81017b80445deda5f2d3921857\"\n dependencies = [\n- \"hermit-abi 0.2.6\",\n+ \"hermit-abi 0.3.0\",\n  \"io-lifetimes\",\n  \"rustix\",\n- \"windows-sys 0.42.0\",\n+ \"windows-sys 0.45.0\",\n ]\n \n [[package]]\n@@ -2234,9 +2793,9 @@ dependencies = [\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.2\"\n+version = \"1.0.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+checksum = \"453ad9f582a441959e5f0d088b02ce04cfe8d51a8eaf077f12ac6d3e94164ca6\"\n \n [[package]]\n name = \"jemalloc-sys\"\n@@ -2251,9 +2810,9 @@ dependencies = [\n \n [[package]]\n name = \"jobserver\"\n-version = \"0.1.24\"\n+version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"af25a77299a7f711a01975c35a6a424eb6862092cc2d6c72c4ed6cbc56dfc1fa\"\n+checksum = \"936cfd212a0155903bcbc060e316fb6cc7cbf2e1907329391ebadc1fe0ce77c2\"\n dependencies = [\n  \"libc\",\n ]\n@@ -2287,6 +2846,7 @@ dependencies = [\n  \"anyhow\",\n  \"clap 4.1.4\",\n  \"fs-err\",\n+ \"rustc-hash\",\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n@@ -2319,9 +2879,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.138\"\n+version = \"0.2.139\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n+checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -2521,6 +3081,17 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \n+[[package]]\n+name = \"maybe-async\"\n+version = \"0.2.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0f1b8c13cb1f814b634a96b2c725449fe7ed464a7b8781de8688be5ffbd3f305\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"md-5\"\n version = \"0.10.0\"\n@@ -2532,9 +3103,9 @@ dependencies = [\n \n [[package]]\n name = \"mdbook\"\n-version = \"0.4.25\"\n+version = \"0.4.28\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d1ed28d5903dde77bd5182645078a37ee57014cac6ccb2d54e1d6496386648e4\"\n+checksum = \"764dcbfc2e5f868bc1b566eb179dff1a06458fd0cff846aae2579392dd3f01a0\"\n dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n@@ -2578,7 +3149,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cbdc226fa10994e8f66a4d2f6f000148bc563a1c671b6dcd2135737018033d8a\"\n dependencies = [\n  \"log\",\n- \"memmap2\",\n+ \"memmap2 0.2.1\",\n  \"parking_lot 0.11.2\",\n  \"perf-event-open-sys\",\n  \"rustc-hash\",\n@@ -2604,6 +3175,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"memmap2\"\n+version = \"0.5.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"83faa42c0a078c393f6b29d5db232d8be22776a891f8f56e5284faee4a20b327\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"memoffset\"\n version = \"0.7.1\"\n@@ -2613,6 +3193,22 @@ dependencies = [\n  \"autocfg\",\n ]\n \n+[[package]]\n+name = \"mime\"\n+version = \"0.3.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2a60c7ce501c71e03a9c9c0d35b861413ae925bd979cc7a4e30d060069aaac8d\"\n+\n+[[package]]\n+name = \"mime_guess\"\n+version = \"2.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4192263c238a5f0d0c6bfd21f336a313a4ce1c450542449ca191bb657b4642ef\"\n+dependencies = [\n+ \"mime\",\n+ \"unicase\",\n+]\n+\n [[package]]\n name = \"minifier\"\n version = \"0.2.2\"\n@@ -2689,6 +3285,18 @@ version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e4a24736216ec316047a1fc4252e27dabb04218aa4a3f37c6e7ddbf1f9782b54\"\n \n+[[package]]\n+name = \"nix\"\n+version = \"0.26.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bfdda3d196821d6af13126e40375cdf7da646a96114af134d5f417a9a1dc8e1a\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"static_assertions\",\n+]\n+\n [[package]]\n name = \"nom\"\n version = \"7.1.0\"\n@@ -2744,6 +3352,15 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"num_threads\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2819ce041d2ee131036f4fc9d6ae7ae125a3a40e97ba64d04fe799ad9dabbb44\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"object\"\n version = \"0.29.0\"\n@@ -3244,6 +3861,15 @@ dependencies = [\n  \"std\",\n ]\n \n+[[package]]\n+name = \"prodash\"\n+version = \"23.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d73c6b64cb5b99eb63ca97d378685712617ec0172ff5c04cd47a489d3e2c51f8\"\n+dependencies = [\n+ \"parking_lot 0.12.1\",\n+]\n+\n [[package]]\n name = \"profiler_builtins\"\n version = \"0.0.0\"\n@@ -3590,11 +4216,14 @@ dependencies = [\n  \"bstr 0.2.17\",\n  \"clap 3.2.20\",\n  \"getrandom\",\n+ \"hashbrown 0.12.3\",\n  \"libc\",\n  \"libz-sys\",\n+ \"once_cell\",\n  \"rand\",\n  \"regex\",\n  \"serde_json\",\n+ \"smallvec\",\n  \"syn\",\n  \"url\",\n  \"winapi\",\n@@ -3801,6 +4430,8 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n+ \"serde\",\n+ \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n  \"tracing\",\n@@ -3883,7 +4514,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"measureme\",\n- \"memmap2\",\n+ \"memmap2 0.2.1\",\n  \"parking_lot 0.11.2\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n@@ -3892,13 +4523,14 @@ dependencies = [\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"serde_json\",\n  \"smallvec\",\n  \"stable_deref_trait\",\n  \"stacker\",\n  \"tempfile\",\n  \"thin-vec\",\n  \"tracing\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -3957,7 +4589,7 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"serde_json\",\n  \"tracing\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -4005,7 +4637,7 @@ dependencies = [\n  \"termize\",\n  \"tracing\",\n  \"unicode-width\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n@@ -4195,6 +4827,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_expand\",\n+ \"rustc_fs_util\",\n  \"rustc_hir\",\n  \"rustc_hir_analysis\",\n  \"rustc_hir_typeck\",\n@@ -4319,6 +4952,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_feature\",\n+ \"rustc_fs_util\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n  \"rustc_index\",\n@@ -4508,6 +5142,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"tracing\",\n ]\n \n@@ -4645,29 +5280,24 @@ dependencies = [\n  \"smallvec\",\n  \"termize\",\n  \"tracing\",\n- \"winapi\",\n+ \"windows 0.46.0\",\n ]\n \n [[package]]\n name = \"rustc_smir\"\n version = \"0.0.0\"\n dependencies = [\n- \"rustc_borrowck\",\n- \"rustc_driver\",\n- \"rustc_hir\",\n- \"rustc_interface\",\n  \"rustc_middle\",\n- \"rustc_mir_dataflow\",\n- \"rustc_mir_transform\",\n- \"rustc_serialize\",\n- \"rustc_trait_selection\",\n+ \"rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if\",\n+ \"indexmap\",\n  \"md-5\",\n  \"rustc_arena\",\n  \"rustc_data_structures\",\n@@ -4708,6 +5338,7 @@ dependencies = [\n  \"rustc_abi\",\n  \"rustc_data_structures\",\n  \"rustc_feature\",\n+ \"rustc_fs_util\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n@@ -4716,12 +5347,6 @@ dependencies = [\n  \"tracing\",\n ]\n \n-[[package]]\n-name = \"rustc_tools_util\"\n-version = \"0.2.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"598f48ce2a421542b3e64828aa742b687cc1b91d2f96591cfdb7ac5988cd6366\"\n-\n [[package]]\n name = \"rustc_tools_util\"\n version = \"0.3.0\"\n@@ -4838,13 +5463,13 @@ dependencies = [\n  \"itertools\",\n  \"minifier\",\n  \"once_cell\",\n- \"rayon\",\n  \"regex\",\n  \"rustdoc-json-types\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n  \"tempfile\",\n+ \"threadpool\",\n  \"tracing\",\n  \"tracing-subscriber\",\n  \"tracing-tree\",\n@@ -4854,6 +5479,7 @@ dependencies = [\n name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n dependencies = [\n+ \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n ]\n@@ -5102,6 +5728,12 @@ dependencies = [\n  \"digest\",\n ]\n \n+[[package]]\n+name = \"sha1_smol\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ae1a47186c03a32177042e55dbc5fd5aee900b8e0069a8d70fba96a9375cd012\"\n+\n [[package]]\n name = \"sha2\"\n version = \"0.10.6\"\n@@ -5134,6 +5766,25 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"42a568c8f2cd051a4d283bd6eb0343ac214c1b0f1ac19f93e1175b2dee38c73d\"\n \n+[[package]]\n+name = \"signal-hook\"\n+version = \"0.3.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"732768f1176d21d09e076c23a93123d40bba92d50c4058da34d45c8de8e682b9\"\n+dependencies = [\n+ \"libc\",\n+ \"signal-hook-registry\",\n+]\n+\n+[[package]]\n+name = \"signal-hook-registry\"\n+version = \"1.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d8229b473baa5980ac72ef434c4415e70c4b5e71b423043adb4ba059f89c99a1\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"signature\"\n version = \"1.6.4\"\n@@ -5174,9 +5825,9 @@ checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.8.1\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc88c725d61fc6c3132893370cac4a0200e3fedf5da8331c570664b1987f5ca2\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"snap\"\n@@ -5294,7 +5945,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown 0.12.3\",\n- \"hermit-abi 0.2.6\",\n+ \"hermit-abi 0.3.0\",\n  \"libc\",\n  \"miniz_oxide\",\n  \"object 0.29.0\",\n@@ -5489,10 +6140,8 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n  \"core\",\n  \"getopts\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"proc_macro\",\n@@ -5565,6 +6214,15 @@ dependencies = [\n  \"once_cell\",\n ]\n \n+[[package]]\n+name = \"threadpool\"\n+version = \"1.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d050e60b33d41c19108b32cea32164033a9013fe3b46cbd4457559bfbf77afaa\"\n+dependencies = [\n+ \"num_cpus\",\n+]\n+\n [[package]]\n name = \"tidy\"\n version = \"0.1.0\"\n@@ -5601,6 +6259,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a561bf4617eebd33bca6434b988f39ed798e527f51a1e797d0ee4f61c0a38376\"\n dependencies = [\n  \"itoa\",\n+ \"libc\",\n+ \"num_threads\",\n  \"serde\",\n  \"time-core\",\n  \"time-macros\",\n@@ -5841,7 +6501,7 @@ version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"54ddb6f31025943e2f9d59237f433711c461a43d9415974c3eb3a4902edc1c1f\"\n dependencies = [\n- \"bstr 1.0.1\",\n+ \"bstr 1.3.0\",\n  \"cargo_metadata 0.15.3\",\n  \"color-eyre\",\n  \"colored\",\n@@ -5964,6 +6624,12 @@ dependencies = [\n  \"matches\",\n ]\n \n+[[package]]\n+name = \"unicode-bom\"\n+version = \"1.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"63ec69f541d875b783ca40184d655f2927c95f0bffd486faa83cd3ac3529ec32\"\n+\n [[package]]\n name = \"unicode-ident\"\n version = \"1.0.5\"\n@@ -6232,6 +6898,30 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n+[[package]]\n+name = \"windows\"\n+version = \"0.43.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"04662ed0e3e5630dfa9b26e4cb823b817f1a9addda855d973a9458c236556244\"\n+dependencies = [\n+ \"windows_aarch64_gnullvm\",\n+ \"windows_aarch64_msvc\",\n+ \"windows_i686_gnu\",\n+ \"windows_i686_msvc\",\n+ \"windows_x86_64_gnu\",\n+ \"windows_x86_64_gnullvm\",\n+ \"windows_x86_64_msvc\",\n+]\n+\n+[[package]]\n+name = \"windows\"\n+version = \"0.46.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cdacb41e6a96a052c6cb63a144f24900236121c6f63f4f8219fef5977ecb0c25\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.42.0\"\n@@ -6258,9 +6948,9 @@ dependencies = [\n \n [[package]]\n name = \"windows-targets\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e2522491fbfcd58cc84d47aeb2958948c4b8982e9a2d8a2a35bbaed431390e7\"\n+checksum = \"8e5180c00cd44c9b1c88adb3693291f1cd93605ded80c250a75d472756b4d071\"\n dependencies = [\n  \"windows_aarch64_gnullvm\",\n  \"windows_aarch64_msvc\",\n@@ -6273,45 +6963,45 @@ dependencies = [\n \n [[package]]\n name = \"windows_aarch64_gnullvm\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8c9864e83243fdec7fc9c5444389dcbbfd258f745e7853198f365e3c4968a608\"\n+checksum = \"597a5118570b68bc08d8d59125332c54f1ba9d9adeedeef5b99b02ba2b0698f8\"\n \n [[package]]\n name = \"windows_aarch64_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c8b1b673ffc16c47a9ff48570a9d85e25d265735c503681332589af6253c6c7\"\n+checksum = \"e08e8864a60f06ef0d0ff4ba04124db8b0fb3be5776a5cd47641e942e58c4d43\"\n \n [[package]]\n name = \"windows_i686_gnu\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"de3887528ad530ba7bdbb1faa8275ec7a1155a45ffa57c37993960277145d640\"\n+checksum = \"c61d927d8da41da96a81f029489353e68739737d3beca43145c8afec9a31a84f\"\n \n [[package]]\n name = \"windows_i686_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bf4d1122317eddd6ff351aa852118a2418ad4214e6613a50e0191f7004372605\"\n+checksum = \"44d840b6ec649f480a41c8d80f9c65108b92d89345dd94027bfe06ac444d1060\"\n \n [[package]]\n name = \"windows_x86_64_gnu\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1040f221285e17ebccbc2591ffdc2d44ee1f9186324dd3e84e99ac68d699c45\"\n+checksum = \"8de912b8b8feb55c064867cf047dda097f92d51efad5b491dfb98f6bbb70cb36\"\n \n [[package]]\n name = \"windows_x86_64_gnullvm\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"628bfdf232daa22b0d64fdb62b09fcc36bb01f05a3939e20ab73aaf9470d0463\"\n+checksum = \"26d41b46a36d453748aedef1486d5c7a85db22e56aff34643984ea85514e94a3\"\n \n [[package]]\n name = \"windows_x86_64_msvc\"\n-version = \"0.42.1\"\n+version = \"0.42.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"447660ad36a13288b1db4d4248e857b510e8c3a225c822ba4fb748c0aafecffd\"\n+checksum = \"9aec5da331524158c6d1a4ac0ab1541149c0b9505fde06423b02f5ef0106b9f0\"\n \n [[package]]\n name = \"writeable\""}, {"sha": "5f662b354cd40cd5339d5aa05d74b15405138230", "filename": "LICENSES/BSD-2-Clause.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/LICENSES%2FBSD-2-Clause.txt", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/LICENSES%2FBSD-2-Clause.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FBSD-2-Clause.txt?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,9 @@\n+Copyright (c) <year> <owner> \n+\n+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n+\n+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n+\n+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n+\n+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."}, {"sha": "cf5413effa25a89cae2ef0de21ade82e3672cb3b", "filename": "LICENSES/NCSA.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/LICENSES%2FNCSA.txt", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/LICENSES%2FNCSA.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FNCSA.txt?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,15 @@\n+University of Illinois/NCSA Open Source License\n+\n+Copyright (c) <Year> <Owner Organization Name>. All rights reserved.\n+\n+Developed by: <Name of Development Group> <Name of Institution> <URL for Development Group/Institution>\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal with the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n+\n+     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimers.\n+\n+     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimers in the documentation and/or other materials provided with the distribution.\n+\n+     * Neither the names of <Name of Development Group, Name of Institution>, nor the names of its contributors may be used to endorse or promote products derived from this Software without specific prior written permission.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE SOFTWARE."}, {"sha": "71fd6ac5e12e1703f2d2445393326649d30a49f5", "filename": "LICENSES/Unicode-DFS-2016.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/LICENSES%2FUnicode-DFS-2016.txt", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/LICENSES%2FUnicode-DFS-2016.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSES%2FUnicode-DFS-2016.txt?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,22 @@\n+UNICODE, INC. LICENSE AGREEMENT - DATA FILES AND SOFTWARE\n+\n+Unicode Data Files include all data files under the directories http://www.unicode.org/Public/, http://www.unicode.org/reports/, http://www.unicode.org/cldr/data/, http://source.icu-project.org/repos/icu/, and http://www.unicode.org/utility/trac/browser/.\n+\n+Unicode Data Files do not include PDF online code charts under the directory http://www.unicode.org/Public/.\n+\n+Software includes any source code published in the Unicode Standard or under the directories http://www.unicode.org/Public/, http://www.unicode.org/reports/, http://www.unicode.org/cldr/data/, http://source.icu-project.org/repos/icu/, and http://www.unicode.org/utility/trac/browser/.\n+\n+NOTICE TO USER: Carefully read the following legal agreement. BY DOWNLOADING, INSTALLING, COPYING OR OTHERWISE USING UNICODE INC.'S DATA FILES (\"DATA FILES\"), AND/OR SOFTWARE (\"SOFTWARE\"), YOU UNEQUIVOCALLY ACCEPT, AND AGREE TO BE BOUND BY, ALL OF THE TERMS AND CONDITIONS OF THIS AGREEMENT. IF YOU DO NOT AGREE, DO NOT DOWNLOAD, INSTALL, COPY, DISTRIBUTE OR USE THE DATA FILES OR SOFTWARE.\n+\n+COPYRIGHT AND PERMISSION NOTICE\n+\n+Copyright \u00a9 1991-2016 Unicode, Inc. All rights reserved. Distributed under the Terms of Use in http://www.unicode.org/copyright.html.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy of the Unicode data files and any associated documentation (the \"Data Files\") or Unicode software and any associated documentation (the \"Software\") to deal in the Data Files or Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, and/or sell copies of the Data Files or Software, and to permit persons to whom the Data Files or Software are furnished to do so, provided that either\n+\n+     (a) this copyright and permission notice appear with all copies of the Data Files or Software, or\n+     (b) this copyright and permission notice appear in associated Documentation.\n+\n+THE DATA FILES AND SOFTWARE ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THE DATA FILES OR SOFTWARE.\n+\n+Except as contained in this notice, the name of a copyright holder shall not be used in advertising or otherwise to promote the sale, use or other dealings in these Data Files or Software without prior written authorization of the copyright holder."}, {"sha": "c19e129a9207aaefa4226af6d1f4fc1a11e1fb1f", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,5 +1,7 @@\n # The Rust Programming Language\n \n+[![Rust Community](https://img.shields.io/badge/Rust_Community%20-Join_us-brightgreen?style=plastic&logo=rust)](https://www.rust-lang.org/community)\n+\n This is the main source code repository for [Rust]. It contains the compiler,\n standard library, and documentation.\n \n@@ -97,7 +99,7 @@ See [the rustc-dev-guide for more info][sysllvm].\n    The Rust build system uses a file named `config.toml` in the root of the\n    source tree to determine various configuration settings for the build.\n    Set up the defaults intended for distros to get started. You can see a full\n-   list of options in `config.toml.example`.\n+   list of options in `config.example.toml`.\n \n    ```sh\n    printf 'profile = \"user\" \\nchangelog-seen = 2 \\n' > config.toml"}, {"sha": "a26dbbfa4f5ec98c1844c97edfb2c695b50df46e", "filename": "RELEASES.md", "status": "modified", "additions": 101, "deletions": 2, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,3 +1,99 @@\n+Version 1.68.0 (2023-03-09)\n+==========================\n+\n+<a id=\"1.68.0-Language\"></a>\n+\n+Language\n+--------\n+\n+- [Stabilize default_alloc_error_handler](https://github.com/rust-lang/rust/pull/102318/)\n+  This allows usage of `alloc` on stable without requiring the \n+  definition of a handler for allocation failure. Defining custom handlers is still unstable.\n+- [Stabilize `efiapi` calling convention.](https://github.com/rust-lang/rust/pull/105795/)\n+- [Remove implicit promotion for types with drop glue](https://github.com/rust-lang/rust/pull/105085/)\n+\n+<a id=\"1.68.0-Compiler\"></a>\n+\n+Compiler\n+--------\n+\n+- [Change `bindings_with_variant_name` to deny-by-default](https://github.com/rust-lang/rust/pull/104154/)\n+- [Allow .. to be parsed as let initializer](https://github.com/rust-lang/rust/pull/105701/)\n+- [Add `armv7-sony-vita-newlibeabihf` as a tier 3 target](https://github.com/rust-lang/rust/pull/105712/)\n+- [Always check alignment during compile-time const evaluation](https://github.com/rust-lang/rust/pull/104616/)\n+- [Disable \"split dwarf inlining\" by default.](https://github.com/rust-lang/rust/pull/106709/)\n+- [Add vendor to Fuchsia's target triple](https://github.com/rust-lang/rust/pull/106429/)\n+- [Enable sanitizers for s390x-linux](https://github.com/rust-lang/rust/pull/107127/)\n+\n+<a id=\"1.68.0-Libraries\"></a>\n+\n+Libraries\n+---------\n+\n+- [Loosen the bound on the Debug implementation of Weak.](https://github.com/rust-lang/rust/pull/90291/)\n+- [Make `std::task::Context` !Send and !Sync](https://github.com/rust-lang/rust/pull/95985/)\n+- [PhantomData layout guarantees](https://github.com/rust-lang/rust/pull/104081/)\n+- [Don't derive Debug for `OnceWith` & `RepeatWith`](https://github.com/rust-lang/rust/pull/104163/)\n+- [Implement DerefMut for PathBuf](https://github.com/rust-lang/rust/pull/105018/)\n+- [Add O(1) `Vec -> VecDeque` conversion guarantee](https://github.com/rust-lang/rust/pull/105128/)\n+- [Leak amplification for peek_mut() to ensure BinaryHeap's invariant is always met](https://github.com/rust-lang/rust/pull/105851/)\n+\n+<a id=\"1.68.0-Stabilized-APIs\"></a>\n+\n+Stabilized APIs\n+---------------\n+\n+- [`{core,std}::pin::pin!`](https://doc.rust-lang.org/stable/std/pin/macro.pin.html)\n+- [`impl From<bool> for {f32,f64}`](https://doc.rust-lang.org/stable/std/primitive.f32.html#impl-From%3Cbool%3E-for-f32)\n+- [`std::path::MAIN_SEPARATOR_STR`](https://doc.rust-lang.org/stable/std/path/constant.MAIN_SEPARATOR_STR.html)\n+- [`impl DerefMut for PathBuf`](https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#impl-DerefMut-for-PathBuf)\n+\n+These APIs are now stable in const contexts:\n+\n+- [`VecDeque::new`](https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.new)\n+\n+<a id=\"1.68.0-Cargo\"></a>\n+\n+Cargo\n+-----\n+\n+- [Stabilize sparse registry support for crates.io](https://github.com/rust-lang/cargo/pull/11224/)\n+- [`cargo build --verbose` tells you more about why it recompiles.](https://github.com/rust-lang/cargo/pull/11407/)\n+- [Show progress of crates.io index update even `net.git-fetch-with-cli` option enabled](https://github.com/rust-lang/cargo/pull/11579/)\n+\n+<a id=\"1.68.0-Misc\"></a>\n+\n+Misc\n+----\n+\n+<a id=\"1.68.0-Compatibility-Notes\"></a>\n+\n+Compatibility Notes\n+-------------------\n+\n+- [Add `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` to future-incompat report](https://github.com/rust-lang/rust/pull/103418/)\n+- [Only specify `--target` by default for `-Zgcc-ld=lld` on wasm](https://github.com/rust-lang/rust/pull/101792/)\n+- [Bump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow](https://github.com/rust-lang/rust/pull/106465/)\n+- [`std::task::Context` no longer implements Send and Sync](https://github.com/rust-lang/rust/pull/95985)\n+\n+<a id=\"1.68.0-Internal-Changes\"></a>\n+\n+Internal Changes\n+----------------\n+\n+These changes do not affect any public interfaces of Rust, but they represent\n+significant improvements to the performance or internals of rustc and related\n+tools.\n+\n+- [Encode spans relative to the enclosing item](https://github.com/rust-lang/rust/pull/84762/)\n+- [Don't normalize in AstConv](https://github.com/rust-lang/rust/pull/101947/)\n+- [Find the right lower bound region in the scenario of partial order relations](https://github.com/rust-lang/rust/pull/104765/)\n+- [Fix impl block in const expr](https://github.com/rust-lang/rust/pull/104889/)\n+- [Check ADT fields for copy implementations considering regions](https://github.com/rust-lang/rust/pull/105102/)\n+- [rustdoc: simplify JS search routine by not messing with lev distance](https://github.com/rust-lang/rust/pull/105796/)\n+- [Enable ThinLTO for rustc on `x86_64-pc-windows-msvc`](https://github.com/rust-lang/rust/pull/103591/)\n+- [Enable ThinLTO for rustc on `x86_64-apple-darwin`](https://github.com/rust-lang/rust/pull/103647/)\n+\n Version 1.67.1 (2023-02-09)\n ===========================\n \n@@ -29,12 +125,13 @@ Compiler\n - [Optimize field ordering by grouping m\\*2^n-sized fields with equivalently aligned ones.](https://github.com/rust-lang/rust/pull/102750/)\n - [Stabilize native library modifier `verbatim`.](https://github.com/rust-lang/rust/pull/104360/)\n \n-Added and removed targets:\n+Added, updated, and removed targets:\n \n - [Add a tier 3 target for PowerPC on AIX](https://github.com/rust-lang/rust/pull/102293/), `powerpc64-ibm-aix`.\n - [Add a tier 3 target for the Sony PlayStation 1](https://github.com/rust-lang/rust/pull/102689/), `mipsel-sony-psx`.\n - [Add tier 3 `no_std` targets for the QNX Neutrino RTOS](https://github.com/rust-lang/rust/pull/102701/),\n   `aarch64-unknown-nto-qnx710` and `x86_64-pc-nto-qnx710`.\n+- [Promote UEFI targets to tier 2](https://github.com/rust-lang/rust/pull/103933/), `aarch64-unknown-uefi`, `i686-unknown-uefi`, and `x86_64-unknown-uefi`.\n - [Remove tier 3 `linuxkernel` targets](https://github.com/rust-lang/rust/pull/104015/) (not used by the actual kernel).\n \n Refer to Rust's [platform support page][platform-support-doc]\n@@ -3765,6 +3862,8 @@ Version 1.41.1 (2020-02-27)\n * [Always check types of static items][69145]\n * [Always check lifetime bounds of `Copy` impls][69145]\n * [Fix miscompilation in callers of `Layout::repeat`][69225]\n+* [Rust 1.41.0 was announced as the last Rust release with tier 1 or tier 2 support for 32-bit Apple targets][apple-32bit-drop].\n+  That announcement did not expect a patch release. 1.41.1 also includes release binaries for these targets.\n \n [69225]: https://github.com/rust-lang/rust/issues/69225\n [69145]: https://github.com/rust-lang/rust/pull/69145\n@@ -3857,7 +3956,7 @@ Misc\n Compatibility Notes\n -------------------\n \n-- [As previously announced 1.41.0 will be the last tier 1 release for 32-bit\n+- [As previously announced 1.41 will be the last tier 1 release for 32-bit\n   Apple targets.][apple-32bit-drop] This means that the source code is still\n   available to build, but the targets are no longer being tested and release\n   binaries for those platforms will no longer be distributed by the Rust project."}, {"sha": "434b978ae3151caa16781f2cddca9c9f5b8e5b46", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -24,6 +24,15 @@\n // The two crates we link to here, `std` and `rustc_driver`, are both dynamic\n // libraries. So we must reference jemalloc symbols one way or another, because\n // this file is the only object code in the rustc executable.\n+//\n+// NOTE: if you are reading this comment because you want to set a custom `global_allocator` for\n+// benchmarking, consider using the benchmarks in the `rustc-perf` collector suite instead:\n+// https://github.com/rust-lang/rustc-perf/blob/master/collector/README.md#profiling\n+//\n+// NOTE: if you are reading this comment because you want to replace jemalloc with another allocator\n+// to compare their performance, see\n+// https://github.com/rust-lang/rust/commit/b90cfc887c31c3e7a9e6d462e2464db1fe506175#diff-43914724af6e464c1da2171e4a9b6c7e607d5bc1203fa95c0ab85be4122605ef\n+// for an example of how to do so.\n \n #[unix_sigpipe = \"sig_dfl\"]\n fn main() {"}, {"sha": "343f27326ad60f52118e643b325012f6d32dd236", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -43,7 +43,7 @@ pub trait LayoutCalculator {\n             .max_by_key(|niche| niche.available(dl));\n \n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1],\n@@ -264,7 +264,7 @@ pub trait LayoutCalculator {\n             abi = Abi::Uninhabited;\n         }\n         Some(LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n             largest_niche,\n@@ -277,7 +277,7 @@ pub trait LayoutCalculator {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Uninhabited,\n             largest_niche: None,\n@@ -331,7 +331,7 @@ pub trait LayoutCalculator {\n             }\n             // If it's a struct, still compute a layout so that we can still compute the\n             // field offsets.\n-            None => VariantIdx::new(0),\n+            None => FIRST_VARIANT,\n         };\n \n         let is_struct = !is_enum ||\n@@ -467,7 +467,7 @@ pub trait LayoutCalculator {\n                 .max_by_key(|(_i, layout)| layout.size.bytes())\n                 .map(|(i, _layout)| i)?;\n \n-            let all_indices = (0..=variants.len() - 1).map(VariantIdx::new);\n+            let all_indices = variants.indices();\n             let needs_disc =\n                 |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n             let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n@@ -896,8 +896,8 @@ pub trait LayoutCalculator {\n         let optimize = !repr.inhibit_union_abi_opt();\n         let mut size = Size::ZERO;\n         let mut abi = Abi::Aggregate { sized: true };\n-        let index = VariantIdx::new(0);\n-        for field in &variants[index] {\n+        let only_variant = &variants[FIRST_VARIANT];\n+        for field in only_variant {\n             assert!(field.0.is_sized());\n             align = align.max(field.align());\n \n@@ -930,8 +930,8 @@ pub trait LayoutCalculator {\n         }\n \n         Some(LayoutS {\n-            variants: Variants::Single { index },\n-            fields: FieldsShape::Union(NonZeroUsize::new(variants[index].len())?),\n+            variants: Variants::Single { index: FIRST_VARIANT },\n+            fields: FieldsShape::Union(NonZeroUsize::new(only_variant.len())?),\n             abi,\n             largest_niche: None,\n             align,"}, {"sha": "6740001c38be1699c9949d69b5086237abf4e854", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1380,8 +1380,21 @@ impl Niche {\n }\n \n rustc_index::newtype_index! {\n+    /// The *source-order* index of a variant in a type.\n+    ///\n+    /// For enums, these are always `0..variant_count`, regardless of any\n+    /// custom discriminants that may have been defined, and including any\n+    /// variants that may end up uninhabited due to field types.  (Some of the\n+    /// variants may not be present in a monomorphized ABI [`Variants`], but\n+    /// those skipped variants are always counted when determining the *index*.)\n+    ///\n+    /// `struct`s, `tuples`, and `unions`s are considered to have a single variant\n+    /// with variant index zero, aka [`FIRST_VARIANT`].\n     #[derive(HashStable_Generic)]\n-    pub struct VariantIdx {}\n+    pub struct VariantIdx {\n+        /// Equivalent to `VariantIdx(0)`.\n+        const FIRST_VARIANT = 0;\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Clone)]\n@@ -1422,7 +1435,7 @@ impl LayoutS {\n         let size = scalar.size(cx);\n         let align = scalar.align(cx);\n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Scalar(scalar),\n             largest_niche,\n@@ -1505,14 +1518,6 @@ pub struct PointeeInfo {\n     pub safe: Option<PointerKind>,\n }\n \n-/// Used in `might_permit_raw_init` to indicate the kind of initialisation\n-/// that is checked to be valid\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum InitKind {\n-    Zero,\n-    UninitMitigated0x01Fill,\n-}\n-\n impl LayoutS {\n     /// Returns `true` if the layout corresponds to an unsized type.\n     pub fn is_unsized(&self) -> bool {"}, {"sha": "5d164bc4b3cf5052603e0c3ee8b5fc9103a19744", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1184,6 +1184,15 @@ impl Expr {\n         expr\n     }\n \n+    pub fn peel_parens_and_refs(&self) -> &Expr {\n+        let mut expr = self;\n+        while let ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) = &expr.kind\n+        {\n+            expr = inner;\n+        }\n+        expr\n+    }\n+\n     /// Attempts to reparse as `Ty` (for diagnostic purposes).\n     pub fn to_ty(&self) -> Option<P<Ty>> {\n         let kind = match &self.kind {\n@@ -1230,7 +1239,6 @@ impl Expr {\n \n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n-            ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::ConstBlock(_) => ExprPrecedence::ConstBlock,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n@@ -1291,8 +1299,7 @@ impl Expr {\n     /// To a first-order approximation, is this a pattern?\n     pub fn is_approximately_pattern(&self) -> bool {\n         match &self.peel_parens().kind {\n-            ExprKind::Box(_)\n-            | ExprKind::Array(_)\n+            ExprKind::Array(_)\n             | ExprKind::Call(_, _)\n             | ExprKind::Tup(_)\n             | ExprKind::Lit(_)\n@@ -1363,8 +1370,6 @@ pub struct StructExpr {\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n-    /// A `box x` expression.\n-    Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n     Array(ThinVec<P<Expr>>),\n     /// Allow anonymous constants from an inline `const` block"}, {"sha": "c4771115cacf2b868a584e42a31873ea346dc432", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -180,6 +180,12 @@ impl Attribute {\n         self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n     }\n \n+    pub fn is_proc_macro_attr(&self) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.has_name(*kind))\n+    }\n+\n     /// Extracts the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> Option<MetaItem> {\n         match &self.kind {\n@@ -627,6 +633,22 @@ pub fn mk_attr_name_value_str(\n     mk_attr(g, style, path, args, span)\n }\n \n+pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n+    attrs.iter().filter(move |attr| attr.has_name(name))\n+}\n+\n+pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n+    filter_by_name(attrs, name).next()\n+}\n+\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n+    find_by_name(attrs, name).and_then(|attr| attr.value_str())\n+}\n+\n+pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n+    find_by_name(attrs, name).is_some()\n+}\n+\n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| item.has_name(name))\n }"}, {"sha": "356b9bb6371e22b3227c09fa3caf43aa40b036d2", "filename": "compiler/rustc_ast/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fformat.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -131,8 +131,8 @@ impl FormatArguments {\n         &self.arguments[..]\n     }\n \n-    pub fn all_args_mut(&mut self) -> &mut [FormatArgument] {\n-        &mut self.arguments[..]\n+    pub fn all_args_mut(&mut self) -> &mut Vec<FormatArgument> {\n+        &mut self.arguments\n     }\n }\n "}, {"sha": "45a5a3ecb53f0624a852808d0d154ba1ef16ac86", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -12,7 +12,7 @@ use crate::ptr::P;\n use crate::token::{self, Token};\n use crate::tokenstream::*;\n \n-use rustc_data_structures::map_in_place::MapInPlace;\n+use rustc_data_structures::flat_map_in_place::FlatMapInPlace;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::Ident;\n@@ -1316,7 +1316,6 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     vis: &mut T,\n ) {\n     match kind {\n-        ExprKind::Box(expr) => vis.visit_expr(expr),\n         ExprKind::Array(exprs) => visit_thin_exprs(exprs, vis),\n         ExprKind::ConstBlock(anon_const) => {\n             vis.visit_anon_const(anon_const);"}, {"sha": "607b77705cf83987acf0038e8d1683c48148e117", "filename": "compiler/rustc_ast/src/util/classify.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fclassify.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -35,7 +35,6 @@ pub fn expr_trailing_brace(mut expr: &ast::Expr) -> Option<&ast::Expr> {\n             | Assign(_, e, _)\n             | AssignOp(_, _, e)\n             | Binary(_, _, e)\n-            | Box(e)\n             | Break(_, Some(e))\n             | Let(_, e, _)\n             | Range(_, Some(e), _)"}, {"sha": "3893875e9a405a111650ac70ef4d3cead30c2458", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -225,7 +225,7 @@ impl AssocOp {\n             AssignOp(_) | // `{ 42 } +=`\n             As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n-            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            // NotEqual | // `{ 42 } != { 42 }` struct literals parser recovery.\n             Colon, // `{ 42 }: usize`\n         )\n     }\n@@ -259,7 +259,6 @@ pub enum ExprPrecedence {\n     Assign,\n     AssignOp,\n \n-    Box,\n     AddrOf,\n     Let,\n     Unary,\n@@ -319,8 +318,7 @@ impl ExprPrecedence {\n             ExprPrecedence::AssignOp => AssocOp::Assign.precedence() as i8,\n \n             // Unary, prefix\n-            ExprPrecedence::Box\n-            | ExprPrecedence::AddrOf\n+            ExprPrecedence::AddrOf\n             // Here `let pats = expr` has `let pats =` as a \"unary\" prefix of `expr`.\n             // However, this is not exactly right. When `let _ = a` is the LHS of a binop we\n             // need parens sometimes. E.g. we can print `(let _ = a) && b` as `let _ = a && b`"}, {"sha": "9a4da6d439600f955f39198b3acd5fd9e56edac7", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -772,7 +772,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n     walk_list!(visitor, visit_attribute, expression.attrs.iter());\n \n     match &expression.kind {\n-        ExprKind::Box(subexpression) => visitor.visit_expr(subexpression),\n         ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }"}, {"sha": "3ccd84398ec2720b45a71eb71dcbb1cae73f3a10", "filename": "compiler/rustc_ast_lowering/messages.ftl", "status": "renamed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -22,9 +22,6 @@ ast_lowering_misplaced_impl_trait =\n ast_lowering_misplaced_assoc_ty_binding =\n     associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n \n-ast_lowering_rustc_box_attribute_error =\n-    #[rustc_box] requires precisely one argument and no other attributes are allowed\n-\n ast_lowering_underscore_expr_lhs_assign =\n     in expressions, `_` can only be used on the left-hand side of an assignment\n     .label = `_` not allowed here", "previous_filename": "compiler/rustc_ast_lowering/locales/en-US.ftl"}, {"sha": "5e6b6050bc0eaeaa8ba1c96c41be008607745b20", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -87,13 +87,6 @@ pub struct MisplacedAssocTyBinding<'a> {\n     pub position: DiagnosticArgFromDisplay<'a>,\n }\n \n-#[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering_rustc_box_attribute_error)]\n-pub struct RustcBoxAttributeError {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic, Clone, Copy)]\n #[diag(ast_lowering_underscore_expr_lhs_assign)]\n pub struct UnderscoreExprLhsAssign {"}, {"sha": "181f94ab74f93320110f2532557f6f80d721051d", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 38, "deletions": 54, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -2,7 +2,7 @@ use super::errors::{\n     AsyncGeneratorsNotSupported, AsyncNonMoveClosureNotSupported, AwaitOnlyInAsyncFnAndBlocks,\n     BaseExpressionDoubleDot, ClosureCannotBeStatic, FunctionalRecordUpdateDestructuringAssignemnt,\n     GeneratorTooManyParameters, InclusiveRangeWithNoEnd, NotSupportedForLifetimeBinderAsyncClosure,\n-    RustcBoxAttributeError, UnderscoreExprLhsAssign,\n+    UnderscoreExprLhsAssign,\n };\n use super::ResolverAstLoweringExt;\n use super::{ImplTraitContext, LoweringContext, ParamMode, ParenthesizedGenericArgs};\n@@ -32,7 +32,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n             match &e.kind {\n-                // Paranthesis expression does not have a HirId and is handled specially.\n+                // Parenthesis expression does not have a HirId and is handled specially.\n                 ExprKind::Paren(ex) => {\n                     let mut ex = self.lower_expr_mut(ex);\n                     // Include parens in span, but only if it is a super-span.\n@@ -63,14 +63,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ExprKind::ForLoop(pat, head, body, opt_label) => {\n                     return self.lower_expr_for(e, pat, head, body, *opt_label);\n                 }\n+                // Similarly, async blocks do not use `e.id` but rather `closure_node_id`.\n+                ExprKind::Async(capture_clause, closure_node_id, block) => {\n+                    let hir_id = self.lower_node_id(*closure_node_id);\n+                    self.lower_attrs(hir_id, &e.attrs);\n+                    return self.make_async_expr(\n+                        *capture_clause,\n+                        hir_id,\n+                        *closure_node_id,\n+                        None,\n+                        e.span,\n+                        hir::AsyncGeneratorKind::Block,\n+                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                    );\n+                }\n                 _ => (),\n             }\n \n             let hir_id = self.lower_node_id(e.id);\n             self.lower_attrs(hir_id, &e.attrs);\n \n             let kind = match &e.kind {\n-                ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n                 ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n                 ExprKind::ConstBlock(anon_const) => {\n                     let anon_const = self.lower_anon_const(anon_const);\n@@ -83,15 +96,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::Tup(elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n                 ExprKind::Call(f, args) => {\n-                    if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n-                        if let [inner] = &args[..] && e.attrs.len() == 1 {\n-                            let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n-                            return hir::Expr { hir_id, kind, span: self.lower_span(e.span) };\n-                        } else {\n-                            self.tcx.sess.emit_err(RustcBoxAttributeError { span: e.span });\n-                            hir::ExprKind::Err\n-                        }\n-                    } else if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n+                    if let Some(legacy_args) = self.resolver.legacy_const_generic_args(f) {\n                         self.lower_legacy_const_generics((**f).clone(), args.clone(), &legacy_args)\n                     } else {\n                         let f = self.lower_expr(f);\n@@ -182,15 +187,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                     hir::MatchSource::Normal,\n                 ),\n-                ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n-                    *capture_clause,\n-                    hir_id,\n-                    *closure_node_id,\n-                    None,\n-                    e.span,\n-                    hir::AsyncGeneratorKind::Block,\n-                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-                ),\n                 ExprKind::Await(expr) => {\n                     let dot_await_span = if expr.span.hi() < e.span.hi() {\n                         let span_with_whitespace = self\n@@ -266,8 +262,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n-                    self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n-                    hir::ExprKind::Err\n+                    let guar = self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n+                    hir::ExprKind::Err(guar)\n                 }\n                 ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n@@ -299,8 +295,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n-                            self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n-                            Some(&*self.arena.alloc(self.expr_err(*sp)))\n+                            let guar =\n+                                self.tcx.sess.emit_err(BaseExpressionDoubleDot { span: *sp });\n+                            Some(&*self.arena.alloc(self.expr_err(*sp, guar)))\n                         }\n                         StructRest::None => None,\n                     };\n@@ -318,10 +315,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     )\n                 }\n                 ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n-                ExprKind::Err => hir::ExprKind::Err,\n+                ExprKind::Err => hir::ExprKind::Err(\n+                    self.tcx.sess.delay_span_bug(e.span, \"lowered ExprKind::Err\"),\n+                ),\n                 ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n \n-                ExprKind::Paren(_) | ExprKind::ForLoop(..) => unreachable!(\"already handled\"),\n+                ExprKind::Paren(_) | ExprKind::ForLoop(..) | ExprKind::Async(..) => {\n+                    unreachable!(\"already handled\")\n+                }\n \n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n@@ -583,9 +584,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// This results in:\n     ///\n     /// ```text\n-    /// std::future::identity_future(static move? |_task_context| -> <ret_ty> {\n+    /// static move? |_task_context| -> <ret_ty> {\n     ///     <body>\n-    /// })\n+    /// }\n     /// ```\n     pub(super) fn make_async_expr(\n         &mut self,\n@@ -596,7 +597,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         span: Span,\n         async_gen_kind: hir::AsyncGeneratorKind,\n         body: impl FnOnce(&mut Self) -> hir::Expr<'hir>,\n-    ) -> hir::ExprKind<'hir> {\n+    ) -> hir::Expr<'hir> {\n         let output = ret_ty.unwrap_or_else(|| hir::FnRetTy::DefaultReturn(self.lower_span(span)));\n \n         // Resume argument type: `ResumeTy`\n@@ -661,13 +662,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         };\n \n         let hir_id = self.lower_node_id(closure_node_id);\n-        let unstable_span =\n-            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n-\n         if self.tcx.features().closure_track_caller\n             && let Some(attrs) = self.attrs.get(&outer_hir_id.local_id)\n             && attrs.into_iter().any(|attr| attr.has_name(sym::track_caller))\n         {\n+            let unstable_span =\n+                self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n             self.lower_attrs(\n                 hir_id,\n                 &[Attribute {\n@@ -686,22 +686,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             );\n         }\n \n-        let generator = hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) };\n-\n-        // FIXME(swatinem):\n-        // For some reason, the async block needs to flow through *any*\n-        // call (like the identity function), as otherwise type and lifetime\n-        // inference have a hard time figuring things out.\n-        // Without this, we would get:\n-        // E0720 in tests/ui/impl-trait/in-trait/default-body-with-rpit.rs\n-        // E0700 in tests/ui/self/self_lifetime-async.rs\n-\n-        // `future::identity_future`:\n-        let identity_future =\n-            self.expr_lang_item_path(unstable_span, hir::LangItem::IdentityFuture, None);\n-\n-        // `future::identity_future(generator)`:\n-        hir::ExprKind::Call(self.arena.alloc(identity_future), arena_vec![self; generator])\n+        hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) }\n     }\n \n     /// Desugar `<expr>.await` into:\n@@ -761,7 +746,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.expr_ident_mut(span, task_context_ident, task_context_hid)\n             } else {\n                 // Use of `await` outside of an async context, we cannot use `task_context` here.\n-                self.expr_err(span)\n+                self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no task_context hir id\"))\n             };\n             let new_unchecked = self.expr_call_lang_item_fn_mut(\n                 span,\n@@ -1007,7 +992,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n \n             // Transform `async |x: u8| -> X { ... }` into\n-            // `|x: u8| identity_future(|| -> X { ... })`.\n+            // `|x: u8| || -> X { ... }`.\n             let body_id = this.lower_fn_body(&outer_decl, |this| {\n                 let async_ret_ty = if let FnRetTy::Ty(ty) = &decl.output {\n                     let itctx = ImplTraitContext::Disallowed(ImplTraitPosition::AsyncBlock);\n@@ -1016,16 +1001,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     None\n                 };\n \n-                let async_body = this.make_async_expr(\n+                this.make_async_expr(\n                     capture_clause,\n                     closure_hir_id,\n                     inner_closure_id,\n                     async_ret_ty,\n                     body.span,\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n-                );\n-                this.expr(fn_decl_span, async_body)\n+                )\n             });\n             body_id\n         });"}, {"sha": "72352b138cbf47117cf738e78e4ce8bc95193bda", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 226, "deletions": 19, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -7,13 +7,172 @@ use rustc_hir as hir;\n use rustc_span::{\n     sym,\n     symbol::{kw, Ident},\n-    Span,\n+    Span, Symbol,\n };\n+use std::borrow::Cow;\n \n impl<'hir> LoweringContext<'_, 'hir> {\n     pub(crate) fn lower_format_args(&mut self, sp: Span, fmt: &FormatArgs) -> hir::ExprKind<'hir> {\n-        expand_format_args(self, sp, fmt)\n+        // Never call the const constructor of `fmt::Arguments` if the\n+        // format_args!() had any arguments _before_ flattening/inlining.\n+        let allow_const = fmt.arguments.all_args().is_empty();\n+        let mut fmt = Cow::Borrowed(fmt);\n+        if self.tcx.sess.opts.unstable_opts.flatten_format_args {\n+            fmt = flatten_format_args(fmt);\n+            fmt = inline_literals(fmt);\n+        }\n+        expand_format_args(self, sp, &fmt, allow_const)\n+    }\n+}\n+\n+/// Flattens nested `format_args!()` into one.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"a {} {} {}.\", 1, format_args!(\"b{}!\", 2), 3)`\n+///\n+/// into\n+///\n+/// `format_args!(\"a {} b{}! {}.\", 1, 2, 3)`.\n+fn flatten_format_args(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut i = 0;\n+    while i < fmt.template.len() {\n+        if let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i]\n+            && let FormatTrait::Display | FormatTrait::Debug = &placeholder.format_trait\n+            && let Ok(arg_index) = placeholder.argument.index\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::FormatArgs(_) = &arg.kind\n+            // Check that this argument is not used by any other placeholders.\n+            && fmt.template.iter().enumerate().all(|(j, p)|\n+                i == j ||\n+                !matches!(p, FormatArgsPiece::Placeholder(placeholder)\n+                    if placeholder.argument.index == Ok(arg_index))\n+            )\n+        {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+\n+            // Take the inner FormatArgs out of the outer arguments, and\n+            // replace it by the inner arguments. (We can't just put those at\n+            // the end, because we need to preserve the order of evaluation.)\n+\n+            let args = fmt.arguments.all_args_mut();\n+            let remaining_args = args.split_off(arg_index + 1);\n+            let old_arg_offset = args.len();\n+            let mut fmt2 = &mut args.pop().unwrap().expr; // The inner FormatArgs.\n+            let fmt2 = loop { // Unwrap the Expr to get to the FormatArgs.\n+                match &mut fmt2.kind {\n+                    ExprKind::Paren(inner) | ExprKind::AddrOf(BorrowKind::Ref, _, inner) => fmt2 = inner,\n+                    ExprKind::FormatArgs(fmt2) => break fmt2,\n+                    _ => unreachable!(),\n+                }\n+            };\n+\n+            args.append(fmt2.arguments.all_args_mut());\n+            let new_arg_offset = args.len();\n+            args.extend(remaining_args);\n+\n+            // Correct the indexes that refer to the arguments after the newly inserted arguments.\n+            for_all_argument_indexes(&mut fmt.template, |index| {\n+                if *index >= old_arg_offset {\n+                    *index -= old_arg_offset;\n+                    *index += new_arg_offset;\n+                }\n+            });\n+\n+            // Now merge the placeholders:\n+\n+            let rest = fmt.template.split_off(i + 1);\n+            fmt.template.pop(); // remove the placeholder for the nested fmt args.\n+            // Insert the pieces from the nested format args, but correct any\n+            // placeholders to point to the correct argument index.\n+            for_all_argument_indexes(&mut fmt2.template, |index| *index += arg_index);\n+            fmt.template.append(&mut fmt2.template);\n+            fmt.template.extend(rest);\n+\n+            // Don't increment `i` here, so we recurse into the newly added pieces.\n+        } else {\n+            i += 1;\n+        }\n     }\n+    fmt\n+}\n+\n+/// Inline literals into the format string.\n+///\n+/// Turns\n+///\n+/// `format_args!(\"Hello, {}! {} {}\", \"World\", 123, x)`\n+///\n+/// into\n+///\n+/// `format_args!(\"Hello, World! 123 {}\", x)`.\n+fn inline_literals(mut fmt: Cow<'_, FormatArgs>) -> Cow<'_, FormatArgs> {\n+    let mut was_inlined = vec![false; fmt.arguments.all_args().len()];\n+    let mut inlined_anything = false;\n+\n+    for i in 0..fmt.template.len() {\n+        let FormatArgsPiece::Placeholder(placeholder) = &fmt.template[i] else { continue };\n+        let Ok(arg_index) = placeholder.argument.index else { continue };\n+\n+        let mut literal = None;\n+\n+        if let FormatTrait::Display = placeholder.format_trait\n+            && placeholder.format_options == Default::default()\n+            && let arg = fmt.arguments.all_args()[arg_index].expr.peel_parens_and_refs()\n+            && let ExprKind::Lit(lit) = arg.kind\n+        {\n+            if let token::LitKind::Str | token::LitKind::StrRaw(_) = lit.kind\n+                && let Ok(LitKind::Str(s, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(s);\n+            } else if let token::LitKind::Integer = lit.kind\n+                && let Ok(LitKind::Int(n, _)) = LitKind::from_token_lit(lit)\n+            {\n+                literal = Some(Symbol::intern(&n.to_string()));\n+            }\n+        }\n+\n+        if let Some(literal) = literal {\n+            // Now we need to mutate the outer FormatArgs.\n+            // If this is the first time, this clones the outer FormatArgs.\n+            let fmt = fmt.to_mut();\n+            // Replace the placeholder with the literal.\n+            fmt.template[i] = FormatArgsPiece::Literal(literal);\n+            was_inlined[arg_index] = true;\n+            inlined_anything = true;\n+        }\n+    }\n+\n+    // Remove the arguments that were inlined.\n+    if inlined_anything {\n+        let fmt = fmt.to_mut();\n+\n+        let mut remove = was_inlined;\n+\n+        // Don't remove anything that's still used.\n+        for_all_argument_indexes(&mut fmt.template, |index| remove[*index] = false);\n+\n+        // Drop all the arguments that are marked for removal.\n+        let mut remove_it = remove.iter();\n+        fmt.arguments.all_args_mut().retain(|_| remove_it.next() != Some(&true));\n+\n+        // Calculate the mapping of old to new indexes for the remaining arguments.\n+        let index_map: Vec<usize> = remove\n+            .into_iter()\n+            .scan(0, |i, remove| {\n+                let mapped = *i;\n+                *i += !remove as usize;\n+                Some(mapped)\n+            })\n+            .collect();\n+\n+        // Correct the indexes that refer to arguments that have shifted position.\n+        for_all_argument_indexes(&mut fmt.template, |index| *index = index_map[*index]);\n+    }\n+\n+    fmt\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -102,7 +261,12 @@ fn make_count<'hir>(\n                 let value = ctx.arena.alloc_from_iter([ctx.expr_usize(sp, i)]);\n                 ctx.expr_call_mut(sp, count_param, value)\n             } else {\n-                ctx.expr(sp, hir::ExprKind::Err)\n+                ctx.expr(\n+                    sp,\n+                    hir::ExprKind::Err(\n+                        ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\"),\n+                    ),\n+                )\n             }\n         }\n         None => ctx.expr_lang_item_type_relative(sp, hir::LangItem::FormatCount, sym::Implied),\n@@ -135,7 +299,10 @@ fn make_format_spec<'hir>(\n                 argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n             ctx.expr_usize(sp, i)\n         }\n-        Err(_) => ctx.expr(sp, hir::ExprKind::Err),\n+        Err(_) => ctx.expr(\n+            sp,\n+            hir::ExprKind::Err(ctx.tcx.sess.delay_span_bug(sp, \"lowered bad format_args count\")),\n+        ),\n     };\n     let &FormatOptions {\n         ref width,\n@@ -181,11 +348,26 @@ fn expand_format_args<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     macsp: Span,\n     fmt: &FormatArgs,\n+    allow_const: bool,\n ) -> hir::ExprKind<'hir> {\n+    let mut incomplete_lit = String::new();\n     let lit_pieces =\n         ctx.arena.alloc_from_iter(fmt.template.iter().enumerate().filter_map(|(i, piece)| {\n             match piece {\n-                &FormatArgsPiece::Literal(s) => Some(ctx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Literal(s) => {\n+                    // Coalesce adjacent literal pieces.\n+                    if let Some(FormatArgsPiece::Literal(_)) = fmt.template.get(i + 1) {\n+                        incomplete_lit.push_str(s.as_str());\n+                        None\n+                    } else if !incomplete_lit.is_empty() {\n+                        incomplete_lit.push_str(s.as_str());\n+                        let s = Symbol::intern(&incomplete_lit);\n+                        incomplete_lit.clear();\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    } else {\n+                        Some(ctx.expr_str(fmt.span, s))\n+                    }\n+                }\n                 &FormatArgsPiece::Placeholder(_) => {\n                     // Inject empty string before placeholders when not already preceded by a literal piece.\n                     if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n@@ -236,6 +418,18 @@ fn expand_format_args<'hir>(\n \n     let arguments = fmt.arguments.all_args();\n \n+    if allow_const && arguments.is_empty() && argmap.is_empty() {\n+        // Generate:\n+        //     <core::fmt::Arguments>::new_const(lit_pieces)\n+        let new = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n+            macsp,\n+            hir::LangItem::FormatArguments,\n+            sym::new_const,\n+        ));\n+        let new_args = ctx.arena.alloc_from_iter([lit_pieces]);\n+        return hir::ExprKind::Call(new, new_args);\n+    }\n+\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n@@ -282,20 +476,14 @@ fn expand_format_args<'hir>(\n         let args_ident = Ident::new(sym::args, macsp);\n         let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n         let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n-            if let Some(arg) = arguments.get(arg_index) {\n-                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n-                let arg = ctx.arena.alloc(ctx.expr(\n-                    sp,\n-                    hir::ExprKind::Field(\n-                        args_ident_expr,\n-                        Ident::new(sym::integer(arg_index), macsp),\n-                    ),\n-                ));\n-                make_argument(ctx, sp, arg, ty)\n-            } else {\n-                ctx.expr(macsp, hir::ExprKind::Err)\n-            }\n+            let arg = &arguments[arg_index];\n+            let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+            let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+            let arg = ctx.arena.alloc(ctx.expr(\n+                sp,\n+                hir::ExprKind::Field(args_ident_expr, Ident::new(sym::integer(arg_index), macsp)),\n+            ));\n+            make_argument(ctx, sp, arg, ty)\n         }));\n         let elements: Vec<_> = arguments\n             .iter()\n@@ -396,3 +584,22 @@ fn may_contain_yield_point(e: &ast::Expr) -> bool {\n     visitor.visit_expr(e);\n     visitor.0\n }\n+\n+fn for_all_argument_indexes(template: &mut [FormatArgsPiece], mut f: impl FnMut(&mut usize)) {\n+    for piece in template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if let Ok(index) = &mut placeholder.argument.index {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.width\n+        {\n+            f(index);\n+        }\n+        if let Some(FormatCount::Argument(FormatArgPosition { index: Ok(index), .. })) =\n+            &mut placeholder.format_options.precision\n+        {\n+            f(index);\n+        }\n+    }\n+}"}, {"sha": "9a117ac9a3cf7c1fcef0d314859bccbbe5b15225", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -7,12 +7,13 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::AssocCtxt;\n use rustc_ast::*;\n use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n+use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -284,7 +285,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n             ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n-            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: Some(ty), .. }) => {\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -299,18 +300,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &generics,\n                     id,\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n-                );\n-                hir::ItemKind::TyAlias(ty, generics)\n-            }\n-            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: None, .. }) => {\n-                let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n-                let (generics, ty) = self.lower_generics(\n-                    &generics,\n-                    id,\n-                    &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    |this| this.arena.alloc(this.ty(span, hir::TyKind::Err)),\n+                    |this| match ty {\n+                        None => {\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                span,\n+                                \"expected to lower type alias type, but it was missing\",\n+                            );\n+                            this.arena.alloc(this.ty(span, hir::TyKind::Err(guar)))\n+                        }\n+                        Some(ty) => this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy),\n+                    },\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n@@ -798,8 +797,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Construct `ExprKind::Err` for the given `span`.\n-    pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Err)\n+    pub(crate) fn expr_err(&mut self, span: Span, guar: ErrorGuaranteed) -> hir::Expr<'hir> {\n+        self.expr(span, hir::ExprKind::Err(guar))\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n@@ -847,7 +846,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     &ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n                     |this| match ty {\n                         None => {\n-                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n+                            let guar = this.tcx.sess.delay_span_bug(\n+                                i.span,\n+                                \"expected to lower associated type, but it was missing\",\n+                            );\n+                            let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err(guar)));\n                             hir::ImplItemKind::Type(ty)\n                         }\n                         Some(ty) => {\n@@ -973,7 +976,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_block_expr_opt(&mut self, span: Span, block: Option<&Block>) -> hir::Expr<'hir> {\n         match block {\n             Some(block) => self.lower_block_expr(block),\n-            None => self.expr_err(span),\n+            None => self.expr_err(span, self.tcx.sess.delay_span_bug(span, \"no block\")),\n         }\n     }\n \n@@ -983,7 +986,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 &[],\n                 match expr {\n                     Some(expr) => this.lower_expr_mut(expr),\n-                    None => this.expr_err(span),\n+                    None => this.expr_err(span, this.tcx.sess.delay_span_bug(span, \"no block\")),\n                 },\n             )\n         })\n@@ -1177,7 +1180,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 },\n             );\n \n-            (this.arena.alloc_from_iter(parameters), this.expr(body.span, async_expr))\n+            (this.arena.alloc_from_iter(parameters), async_expr)\n         })\n     }\n \n@@ -1336,13 +1339,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 .map(|predicate| self.lower_where_predicate(predicate)),\n         );\n \n-        let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> =\n-            self.lower_generic_params_mut(&generics.params).collect();\n+        let mut params: SmallVec<[hir::GenericParam<'hir>; 4]> = self\n+            .lower_generic_params_mut(&generics.params, hir::GenericParamSource::Generics)\n+            .collect();\n \n         // Introduce extra lifetimes if late resolution tells us to.\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n+            self.lifetime_res_to_generic_param(\n+                ident,\n+                node_id,\n+                res,\n+                hir::GenericParamSource::Generics,\n+            )\n         }));\n \n         let has_where_clause_predicates = !generics.where_clause.predicates.is_empty();\n@@ -1446,7 +1455,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 hir_id: self.next_id(),\n-                bound_generic_params: self.lower_generic_params(bound_generic_params),\n+                bound_generic_params: self\n+                    .lower_generic_params(bound_generic_params, hir::GenericParamSource::Binder),\n                 bounded_ty: self\n                     .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Bound)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {"}, {"sha": "0b6b02ba00fb59f6e5f3c7fc2839e4eed983d3be", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 73, "deletions": 53, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -92,7 +92,7 @@ mod lifetime_collector;\n mod pat;\n mod path;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n struct LoweringContext<'a, 'hir> {\n     tcx: TyCtxt<'hir>,\n@@ -435,7 +435,9 @@ fn compute_hir_hash(\n \n pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n     let sess = tcx.sess;\n-    tcx.ensure().output_filenames(());\n+    // Queries that borrow `resolver_for_lowering`.\n+    tcx.ensure_with_value().output_filenames(());\n+    tcx.ensure_with_value().early_lint_checks(());\n     let (mut resolver, krate) = tcx.resolver_for_lowering(()).steal();\n \n     let ast_index = index_crate(&resolver.node_id_to_def_id, &krate);\n@@ -463,8 +465,10 @@ pub fn lower_to_hir(tcx: TyCtxt<'_>, (): ()) -> hir::Crate<'_> {\n         rustc_span::hygiene::clear_syntax_context_map();\n     }\n \n-    let hir_hash = compute_hir_hash(tcx, &owners);\n-    hir::Crate { owners, hir_hash }\n+    // Don't hash unless necessary, because it's expensive.\n+    let opt_hir_hash =\n+        if tcx.sess.needs_crate_hash() { Some(compute_hir_hash(tcx, &owners)) } else { None };\n+    hir::Crate { owners, opt_hir_hash }\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -657,42 +661,33 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         bodies.sort_by_key(|(k, _)| *k);\n         let bodies = SortedMap::from_presorted_elements(bodies);\n-        let (hash_including_bodies, hash_without_bodies) = self.hash_owner(node, &bodies);\n-        let (nodes, parenting) =\n-            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n-        let nodes = hir::OwnerNodes { hash_including_bodies, hash_without_bodies, nodes, bodies };\n-        let attrs = {\n-            let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n+\n+        // Don't hash unless necessary, because it's expensive.\n+        let (opt_hash_including_bodies, attrs_hash) = if self.tcx.sess.needs_crate_hash() {\n+            self.tcx.with_stable_hashing_context(|mut hcx| {\n+                let mut stable_hasher = StableHasher::new();\n+                hcx.with_hir_bodies(node.def_id(), &bodies, |hcx| {\n+                    node.hash_stable(hcx, &mut stable_hasher)\n+                });\n+                let h1 = stable_hasher.finish();\n+\n                 let mut stable_hasher = StableHasher::new();\n                 attrs.hash_stable(&mut hcx, &mut stable_hasher);\n-                stable_hasher.finish()\n-            });\n-            hir::AttributeMap { map: attrs, hash }\n+                let h2 = stable_hasher.finish();\n+\n+                (Some(h1), Some(h2))\n+            })\n+        } else {\n+            (None, None)\n         };\n+        let (nodes, parenting) =\n+            index::index_hir(self.tcx.sess, &*self.tcx.definitions_untracked(), node, &bodies);\n+        let nodes = hir::OwnerNodes { opt_hash_including_bodies, nodes, bodies };\n+        let attrs = hir::AttributeMap { map: attrs, opt_hash: attrs_hash };\n \n         self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n-    /// Hash the HIR node twice, one deep and one shallow hash. This allows to differentiate\n-    /// queries which depend on the full HIR tree and those which only depend on the item signature.\n-    fn hash_owner(\n-        &mut self,\n-        node: hir::OwnerNode<'hir>,\n-        bodies: &SortedMap<hir::ItemLocalId, &'hir hir::Body<'hir>>,\n-    ) -> (Fingerprint, Fingerprint) {\n-        self.tcx.with_stable_hashing_context(|mut hcx| {\n-            let mut stable_hasher = StableHasher::new();\n-            hcx.with_hir_bodies(node.def_id(), bodies, |hcx| {\n-                node.hash_stable(hcx, &mut stable_hasher)\n-            });\n-            let hash_including_bodies = stable_hasher.finish();\n-            let mut stable_hasher = StableHasher::new();\n-            hcx.without_hir_bodies(|hcx| node.hash_stable(hcx, &mut stable_hasher));\n-            let hash_without_bodies = stable_hasher.finish();\n-            (hash_including_bodies, hash_without_bodies)\n-        })\n-    }\n-\n     /// This method allocates a new `HirId` for the given `NodeId` and stores it in\n     /// the `LoweringContext`'s `NodeId => HirId` map.\n     /// Take care not to call this method if the resulting `HirId` is then not\n@@ -804,6 +799,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ident: Ident,\n         node_id: NodeId,\n         res: LifetimeRes,\n+        source: hir::GenericParamSource,\n     ) -> Option<hir::GenericParam<'hir>> {\n         let (name, kind) = match res {\n             LifetimeRes::Param { .. } => {\n@@ -837,6 +833,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             pure_wrt_drop: false,\n             kind: hir::GenericParamKind::Lifetime { kind },\n             colon_span: None,\n+            source,\n         })\n     }\n \n@@ -852,11 +849,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         binder: NodeId,\n         generic_params: &[GenericParam],\n     ) -> &'hir [hir::GenericParam<'hir>] {\n-        let mut generic_params: Vec<_> = self.lower_generic_params_mut(generic_params).collect();\n+        let mut generic_params: Vec<_> = self\n+            .lower_generic_params_mut(generic_params, hir::GenericParamSource::Binder)\n+            .collect();\n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(binder);\n         debug!(?extra_lifetimes);\n         generic_params.extend(extra_lifetimes.into_iter().filter_map(|(ident, node_id, res)| {\n-            self.lifetime_res_to_generic_param(ident, node_id, res)\n+            self.lifetime_res_to_generic_param(ident, node_id, res, hir::GenericParamSource::Binder)\n         }));\n         let generic_params = self.arena.alloc_from_iter(generic_params);\n         debug!(?generic_params);\n@@ -1082,11 +1081,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         hir::TypeBindingKind::Constraint { bounds }\n                     }\n                     DesugarKind::Error(position) => {\n-                        self.tcx.sess.emit_err(errors::MisplacedAssocTyBinding {\n+                        let guar = self.tcx.sess.emit_err(errors::MisplacedAssocTyBinding {\n                             span: constraint.span,\n                             position: DiagnosticArgFromDisplay(position),\n                         });\n-                        let err_ty = &*self.arena.alloc(self.ty(constraint.span, hir::TyKind::Err));\n+                        let err_ty =\n+                            &*self.arena.alloc(self.ty(constraint.span, hir::TyKind::Err(guar)));\n                         hir::TypeBindingKind::Equality { term: err_ty.into() }\n                     }\n                 }\n@@ -1255,7 +1255,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n         let kind = match &t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n-            TyKind::Err => hir::TyKind::Err,\n+            TyKind::Err => {\n+                hir::TyKind::Err(self.tcx.sess.delay_span_bug(t.span, \"TyKind::Err lowered\"))\n+            }\n             TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Ref(region, mt) => {\n@@ -1372,16 +1374,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             span,\n                         );\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n-                        let (param, bounds, path) =\n-                            self.lower_generic_and_bounds(*def_node_id, span, ident, bounds);\n+                        let (param, bounds, path) = self.lower_universal_param_and_bounds(\n+                            *def_node_id,\n+                            span,\n+                            ident,\n+                            bounds,\n+                        );\n                         self.impl_trait_defs.push(param);\n                         if let Some(bounds) = bounds {\n                             self.impl_trait_bounds.push(bounds);\n                         }\n                         path\n                     }\n                     ImplTraitContext::FeatureGated(position, feature) => {\n-                        self.tcx\n+                        let guar = self\n+                            .tcx\n                             .sess\n                             .create_feature_err(\n                                 MisplacedImplTrait {\n@@ -1391,24 +1398,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 *feature,\n                             )\n                             .emit();\n-                        hir::TyKind::Err\n+                        hir::TyKind::Err(guar)\n                     }\n                     ImplTraitContext::Disallowed(position) => {\n-                        self.tcx.sess.emit_err(MisplacedImplTrait {\n+                        let guar = self.tcx.sess.emit_err(MisplacedImplTrait {\n                             span: t.span,\n                             position: DiagnosticArgFromDisplay(position),\n                         });\n-                        hir::TyKind::Err\n+                        hir::TyKind::Err(guar)\n                     }\n                 }\n             }\n             TyKind::MacCall(_) => panic!(\"`TyKind::MacCall` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n-                self.tcx.sess.delay_span_bug(\n+                let guar = self.tcx.sess.delay_span_bug(\n                     t.span,\n                     \"`TyKind::CVarArgs` should have been handled elsewhere\",\n                 );\n-                hir::TyKind::Err\n+                hir::TyKind::Err(guar)\n             }\n         };\n \n@@ -1526,6 +1533,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             pure_wrt_drop: false,\n                             kind: hir::GenericParamKind::Lifetime { kind },\n                             colon_span: None,\n+                            source: hir::GenericParamSource::Generics,\n                         }\n                     },\n                 ));\n@@ -1594,7 +1602,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n-    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds and a `remapping` hash to be\n+    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds` and a `remapping` hash to be\n     /// filled, this function creates new definitions for `Param` and `Fresh` lifetimes, inserts the\n     /// new definition, adds it to the remapping with the definition of the given lifetime and\n     /// returns a list of lifetimes to be lowered afterwards.\n@@ -1983,6 +1991,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             pure_wrt_drop: false,\n                             kind: hir::GenericParamKind::Lifetime { kind },\n                             colon_span: None,\n+                            source: hir::GenericParamSource::Generics,\n                         }\n                     },\n                 ));\n@@ -2148,16 +2157,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_params_mut<'s>(\n         &'s mut self,\n         params: &'s [GenericParam],\n+        source: hir::GenericParamSource,\n     ) -> impl Iterator<Item = hir::GenericParam<'hir>> + Captures<'a> + Captures<'s> {\n-        params.iter().map(move |param| self.lower_generic_param(param))\n+        params.iter().map(move |param| self.lower_generic_param(param, source))\n     }\n \n-    fn lower_generic_params(&mut self, params: &[GenericParam]) -> &'hir [hir::GenericParam<'hir>] {\n-        self.arena.alloc_from_iter(self.lower_generic_params_mut(params))\n+    fn lower_generic_params(\n+        &mut self,\n+        params: &[GenericParam],\n+        source: hir::GenericParamSource,\n+    ) -> &'hir [hir::GenericParam<'hir>] {\n+        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, source))\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn lower_generic_param(&mut self, param: &GenericParam) -> hir::GenericParam<'hir> {\n+    fn lower_generic_param(\n+        &mut self,\n+        param: &GenericParam,\n+        source: hir::GenericParamSource,\n+    ) -> hir::GenericParam<'hir> {\n         let (name, kind) = self.lower_generic_param_kind(param);\n \n         let hir_id = self.lower_node_id(param.id);\n@@ -2167,9 +2185,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             def_id: self.local_def_id(param.id),\n             name,\n             span: self.lower_span(param.span()),\n-            pure_wrt_drop: self.tcx.sess.contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n             kind,\n             colon_span: param.colon_span.map(|s| self.lower_span(s)),\n+            source,\n         }\n     }\n \n@@ -2262,7 +2281,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n-    fn lower_generic_and_bounds(\n+    fn lower_universal_param_and_bounds(\n         &mut self,\n         node_id: NodeId,\n         span: Span,\n@@ -2282,6 +2301,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             span,\n             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n             colon_span: None,\n+            source: hir::GenericParamSource::Generics,\n         };\n \n         let preds = self.lower_generic_bound_predicate("}, {"sha": "2509b70563956758860d1f855675d71d5e2c68f7", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -330,8 +330,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n-                self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n-                return self.arena.alloc(self.expr_err(expr.span));\n+                let guar = self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n+                return self.arena.alloc(self.expr_err(expr.span, guar));\n             }\n         }\n         self.lower_expr(expr)"}, {"sha": "128e7255c61e4dfd1fedf43b149918b5e236b18c", "filename": "compiler/rustc_ast_passes/locales/en-US.ftl", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Flocales%2Fen-US.ftl?ref=21549dac539dc220f052d038ec643645cedbbd6d", "patch": "@@ -1,89 +0,0 @@\n-ast_passes_forbidden_let =\n-    `let` expressions are not supported here\n-    .note = only supported directly in conditions of `if` and `while` expressions\n-    .not_supported_or = `||` operators are not supported in let chain expressions\n-    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n-\n-ast_passes_forbidden_let_stable =\n-    expected expression, found statement (`let`)\n-    .note = variable declaration using `let` is a statement\n-\n-ast_passes_deprecated_where_clause_location =\n-    where clause not allowed here\n-\n-ast_passes_keyword_lifetime =\n-    lifetimes cannot use keyword names\n-\n-ast_passes_invalid_label =\n-    invalid label name `{$name}`\n-\n-ast_passes_invalid_visibility =\n-    unnecessary visibility qualifier\n-    .implied = `pub` not permitted here because it's implied\n-    .individual_impl_items = place qualifiers on individual impl items instead\n-    .individual_foreign_items = place qualifiers on individual foreign items instead\n-\n-ast_passes_trait_fn_const =\n-    functions in traits cannot be declared const\n-    .label = functions in traits cannot be const\n-\n-ast_passes_forbidden_lifetime_bound =\n-    lifetime bounds cannot be used in this context\n-\n-ast_passes_forbidden_non_lifetime_param =\n-    only lifetime parameters can be used in this context\n-\n-ast_passes_fn_param_too_many =\n-    function can not have more than {$max_num_args} arguments\n-\n-ast_passes_fn_param_c_var_args_only =\n-    C-variadic function must be declared with at least one named argument\n-\n-ast_passes_fn_param_c_var_args_not_last =\n-    `...` must be the last argument of a C-variadic function\n-\n-ast_passes_fn_param_doc_comment =\n-    documentation comments cannot be applied to function parameters\n-    .label = doc comments are not allowed here\n-\n-ast_passes_fn_param_forbidden_attr =\n-    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n-\n-ast_passes_fn_param_forbidden_self =\n-    `self` parameter is only allowed in associated functions\n-    .label = not semantically valid as function parameter\n-    .note = associated functions are those in `impl` or `trait` definitions\n-\n-ast_passes_forbidden_default =\n-    `default` is only allowed on items in trait impls\n-    .label = `default` because of this\n-\n-ast_passes_assoc_const_without_body =\n-    associated constant in `impl` without body\n-    .suggestion = provide a definition for the constant\n-\n-ast_passes_assoc_fn_without_body =\n-    associated function in `impl` without body\n-    .suggestion = provide a definition for the function\n-\n-ast_passes_assoc_type_without_body =\n-    associated type in `impl` without body\n-    .suggestion = provide a definition for the type\n-\n-ast_passes_const_without_body =\n-    free constant item without body\n-    .suggestion = provide a definition for the constant\n-\n-ast_passes_static_without_body =\n-    free static item without body\n-    .suggestion = provide a definition for the static\n-\n-ast_passes_ty_alias_without_body =\n-    free type alias without body\n-    .suggestion = provide a definition for the type\n-\n-ast_passes_fn_without_body =\n-    free function without a body\n-    .suggestion = provide a definition for the function\n-\n-ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block"}, {"sha": "747bd52b22c7d6b14fe9ffdb88d5a4bdd4877113", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,236 @@\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_forbidden_let_stable =\n+    expected expression, found statement (`let`)\n+    .note = variable declaration using `let` is a statement\n+\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_invalid_visibility =\n+    unnecessary visibility qualifier\n+    .implied = `pub` not permitted here because it's implied\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n+\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n+\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n+\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n+\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n+\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n+\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n+\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n+\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n+\n+ast_passes_assoc_const_without_body =\n+    associated constant in `impl` without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_assoc_fn_without_body =\n+    associated function in `impl` without body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_assoc_type_without_body =\n+    associated type in `impl` without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_const_without_body =\n+    free constant item without body\n+    .suggestion = provide a definition for the constant\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n+\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n+\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n+\n+ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n+\n+ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+\n+ast_passes_extern_types_cannot = `type`s inside `extern` blocks cannot have {$descr}\n+    .suggestion = remove the {$remove_descr}\n+    .label = `extern` block begins here\n+\n+ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n+    .cannot_have = cannot have a body\n+    .invalid = the invalid body\n+    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+\n+ast_passes_fn_body_extern = incorrect function inside `extern` block\n+    .cannot_have = cannot have a body\n+    .suggestion = remove the invalid body\n+    .help = you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n+    .label = `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n+\n+ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n+    .label = in this `extern` block\n+    .suggestion = remove the qualifiers\n+\n+ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n+    .label = in this `extern` block\n+    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+\n+ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+\n+ast_passes_item_underscore = `{$kind}` items in this context need a name\n+    .label = `_` is not a valid name for this `{$kind}` item\n+\n+ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n+\n+ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n+    .help = consider using the `#[path]` attribute to specify filesystem path\n+\n+ast_passes_auto_generic = auto traits cannot have generic parameters\n+    .label = auto trait cannot have generic parameters\n+    .suggestion = remove the parameters\n+\n+ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n+    .label = {ast_passes_auto_super_lifetime}\n+    .suggestion = remove the super traits or lifetime bounds\n+\n+ast_passes_auto_items = auto traits cannot have associated items\n+    .label = {ast_passes_auto_items}\n+    .suggestion = remove these associated items\n+\n+ast_passes_generic_before_constraints = generic arguments must come before the first constraint\n+    .constraints = {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    }\n+    .args = generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+    .empty_string = {\"\"},\n+    .suggestion = move the {$constraint_len ->\n+    [one] constraint\n+    *[other] constraints\n+    } after the generic {$args_len ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n+\n+ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n+\n+ast_passes_impl_trait_path = `impl Trait` is not allowed in path parameters\n+\n+ast_passes_nested_impl_trait = nested `impl Trait` is not allowed\n+    .outer = outer `impl Trait`\n+    .inner = nested `impl Trait` here\n+\n+ast_passes_at_least_one_trait = at least one trait must be specified\n+\n+ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n+\n+ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n+    .suggestion = reorder the parameters: lifetimes, then consts and types\n+\n+ast_passes_obsolete_auto = `impl Trait for .. {\"{}\"}` is an obsolete syntax\n+    .help = use `auto trait Trait {\"{}\"}` instead\n+\n+ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n+    .negative = negative because of this\n+    .unsafe = unsafe because of this\n+\n+ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n+    .because = {$annotation} because of this\n+    .type = inherent impl for this type\n+    .only_trait = only trait implementations may be annotated with {$annotation}\n+\n+ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n+\n+ast_passes_fieldless_union = unions cannot have zero fields\n+\n+ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n+    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n+\n+ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n+\n+ast_passes_nested_lifetimes = nested quantification of lifetimes\n+\n+ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n+    .note = traits are `?{$path_str}` by default\n+\n+ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n+\n+ast_passes_tilde_const_disallowed = `~const` is not allowed here\n+    .trait = trait objects cannot have `~const` trait bounds\n+    .closure = closures cannot have `~const` trait bounds\n+    .function = this function is not `const`, so it cannot have `~const` trait bounds\n+\n+ast_passes_optional_const_exclusive = `~const` and `?` are mutually exclusive\n+\n+ast_passes_const_and_async = functions cannot be both `const` and `async`\n+    .const = `const` because of this\n+    .async = `async` because of this\n+    .label = {\"\"}\n+\n+ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n+    .label = pattern not allowed in foreign function\n+\n+ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n+    .label = pattern not allowed in function without body\n+\n+ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n+    .label = not supported\n+    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n+    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n+    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+\n+ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+\n+ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n+    .suggestion = remove the attribute\n+    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+\n+ast_passes_incompatbile_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+    .help = remove one of these features\n+\n+ast_passes_show_span = {$msg}"}, {"sha": "93c854cc8094286560acfbfc133c4171e7220188", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 183, "deletions": 389, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -12,8 +12,7 @@ use rustc_ast::visit::{self, AssocCtxt, BoundKind, FnCtxt, FnKind, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, pluralize, struct_span_err, Applicability};\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n@@ -29,12 +28,9 @@ use std::mem;\n use std::ops::{Deref, DerefMut};\n use thin_vec::thin_vec;\n \n-use crate::errors::*;\n+use crate::errors;\n use crate::fluent_generated as fluent;\n \n-const MORE_EXTERN: &str =\n-    \"for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\";\n-\n /// Is `self` allowed semantically as the first parameter in an `FnDecl`?\n enum SelfSemantic {\n     Yes,\n@@ -134,9 +130,9 @@ impl<'a> AstValidator<'a> {\n     fn ban_let_expr(&self, expr: &'a Expr, forbidden_let_reason: ForbiddenLetReason) {\n         let sess = &self.session;\n         if sess.opts.unstable_features.is_nightly_build() {\n-            sess.emit_err(ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n+            sess.emit_err(errors::ForbiddenLet { span: expr.span, reason: forbidden_let_reason });\n         } else {\n-            sess.emit_err(ForbiddenLetStable { span: expr.span });\n+            sess.emit_err(errors::ForbiddenLetStable { span: expr.span });\n         }\n     }\n \n@@ -196,7 +192,7 @@ impl<'a> AstValidator<'a> {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n-                //  - `option::Option<T>::Foo<impl Trait>\n+                //  - `option::Option<T>::Foo<impl Trait>`\n                 //\n                 // But not these:\n                 //  - `<impl Trait>::Foo`\n@@ -234,22 +230,22 @@ impl<'a> AstValidator<'a> {\n     fn check_lifetime(&self, ident: Ident) {\n         let valid_names = [kw::UnderscoreLifetime, kw::StaticLifetime, kw::Empty];\n         if !valid_names.contains(&ident.name) && ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(KeywordLifetime { span: ident.span });\n+            self.session.emit_err(errors::KeywordLifetime { span: ident.span });\n         }\n     }\n \n     fn check_label(&self, ident: Ident) {\n         if ident.without_first_quote().is_reserved() {\n-            self.session.emit_err(InvalidLabel { span: ident.span, name: ident.name });\n+            self.session.emit_err(errors::InvalidLabel { span: ident.span, name: ident.name });\n         }\n     }\n \n-    fn invalid_visibility(&self, vis: &Visibility, note: Option<InvalidVisibilityNote>) {\n+    fn invalid_visibility(&self, vis: &Visibility, note: Option<errors::InvalidVisibilityNote>) {\n         if let VisibilityKind::Inherited = vis.kind {\n             return;\n         }\n \n-        self.session.emit_err(InvalidVisibility {\n+        self.session.emit_err(errors::InvalidVisibility {\n             span: vis.span,\n             implied: vis.kind.is_pub().then_some(vis.span),\n             note,\n@@ -270,7 +266,7 @@ impl<'a> AstValidator<'a> {\n \n     fn check_trait_fn_not_const(&self, constness: Const) {\n         if let Const::Yes(span) = constness {\n-            self.session.emit_err(TraitFnConst { span });\n+            self.session.emit_err(errors::TraitFnConst { span });\n         }\n     }\n \n@@ -287,21 +283,21 @@ impl<'a> AstValidator<'a> {\n         let max_num_args: usize = u16::MAX.into();\n         if fn_decl.inputs.len() > max_num_args {\n             let Param { span, .. } = fn_decl.inputs[0];\n-            self.session.emit_fatal(FnParamTooMany { span, max_num_args });\n+            self.session.emit_fatal(errors::FnParamTooMany { span, max_num_args });\n         }\n     }\n \n     fn check_decl_cvaradic_pos(&self, fn_decl: &FnDecl) {\n         match &*fn_decl.inputs {\n             [Param { ty, span, .. }] => {\n                 if let TyKind::CVarArgs = ty.kind {\n-                    self.session.emit_err(FnParamCVarArgsOnly { span: *span });\n+                    self.session.emit_err(errors::FnParamCVarArgsOnly { span: *span });\n                 }\n             }\n             [ps @ .., _] => {\n                 for Param { ty, span, .. } in ps {\n                     if let TyKind::CVarArgs = ty.kind {\n-                        self.session.emit_err(FnParamCVarArgsNotLast { span: *span });\n+                        self.session.emit_err(errors::FnParamCVarArgsNotLast { span: *span });\n                     }\n                 }\n             }\n@@ -328,25 +324,25 @@ impl<'a> AstValidator<'a> {\n             })\n             .for_each(|attr| {\n                 if attr.is_doc_comment() {\n-                    self.session.emit_err(FnParamDocComment { span: attr.span });\n+                    self.session.emit_err(errors::FnParamDocComment { span: attr.span });\n                 } else {\n-                    self.session.emit_err(FnParamForbiddenAttr { span: attr.span });\n+                    self.session.emit_err(errors::FnParamForbiddenAttr { span: attr.span });\n                 }\n             });\n     }\n \n     fn check_decl_self_param(&self, fn_decl: &FnDecl, self_semantic: SelfSemantic) {\n         if let (SelfSemantic::No, [param, ..]) = (self_semantic, &*fn_decl.inputs) {\n             if param.is_self() {\n-                self.session.emit_err(FnParamForbiddenSelf { span: param.span });\n+                self.session.emit_err(errors::FnParamForbiddenSelf { span: param.span });\n             }\n         }\n     }\n \n     fn check_defaultness(&self, span: Span, defaultness: Defaultness) {\n         if let Defaultness::Default(def_span) = defaultness {\n             let span = self.session.source_map().guess_head_span(span);\n-            self.session.emit_err(ForbiddenDefault { span, def_span });\n+            self.session.emit_err(errors::ForbiddenDefault { span, def_span });\n         }\n     }\n \n@@ -369,27 +365,17 @@ impl<'a> AstValidator<'a> {\n             [b0] => b0.span(),\n             [b0, .., bl] => b0.span().to(bl.span()),\n         };\n-        self.err_handler()\n-            .struct_span_err(span, &format!(\"bounds on `type`s in {} have no effect\", ctx))\n-            .emit();\n+        self.err_handler().emit_err(errors::BoundInContext { span, ctx });\n     }\n \n     fn check_foreign_ty_genericless(&self, generics: &Generics, where_span: Span) {\n         let cannot_have = |span, descr, remove_descr| {\n-            self.err_handler()\n-                .struct_span_err(\n-                    span,\n-                    &format!(\"`type`s inside `extern` blocks cannot have {}\", descr),\n-                )\n-                .span_suggestion(\n-                    span,\n-                    &format!(\"remove the {}\", remove_descr),\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .span_label(self.current_extern_span(), \"`extern` block begins here\")\n-                .note(MORE_EXTERN)\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternTypesCannotHave {\n+                span,\n+                descr,\n+                remove_descr,\n+                block_span: self.current_extern_span(),\n+            });\n         };\n \n         if !generics.params.is_empty() {\n@@ -405,47 +391,24 @@ impl<'a> AstValidator<'a> {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"incorrect `{}` inside `extern` block\", kind))\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_label(body, \"the invalid body\")\n-            .span_label(\n-                self.current_extern_span(),\n-                format!(\n-                    \"`extern` blocks define existing foreign {0}s and {0}s \\\n-                    inside of them cannot have a body\",\n-                    kind\n-                ),\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::BodyInExtern {\n+            span: ident.span,\n+            body,\n+            block: self.current_extern_span(),\n+            kind,\n+        });\n     }\n \n     /// An `fn` in `extern { ... }` cannot have a body `{ ... }`.\n     fn check_foreign_fn_bodyless(&self, ident: Ident, body: Option<&Block>) {\n         let Some(body) = body else {\n             return;\n         };\n-        self.err_handler()\n-            .struct_span_err(ident.span, \"incorrect function inside `extern` block\")\n-            .span_label(ident.span, \"cannot have a body\")\n-            .span_suggestion(\n-                body.span,\n-                \"remove the invalid body\",\n-                \";\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .help(\n-                \"you might have meant to write a function accessible through FFI, \\\n-                which can be done by writing `extern fn` outside of the `extern` block\",\n-            )\n-            .span_label(\n-                self.current_extern_span(),\n-                \"`extern` blocks define existing foreign functions and functions \\\n-                inside of them cannot have a body\",\n-            )\n-            .note(MORE_EXTERN)\n-            .emit();\n+        self.err_handler().emit_err(errors::FnBodyInExtern {\n+            span: ident.span,\n+            body: body.span,\n+            block: self.current_extern_span(),\n+        });\n     }\n \n     fn current_extern_span(&self) -> Span {\n@@ -455,34 +418,21 @@ impl<'a> AstValidator<'a> {\n     /// An `fn` in `extern { ... }` cannot have qualifiers, e.g. `async fn`.\n     fn check_foreign_fn_headerless(&self, ident: Ident, span: Span, header: FnHeader) {\n         if header.has_qualifiers() {\n-            self.err_handler()\n-                .struct_span_err(ident.span, \"functions in `extern` blocks cannot have qualifiers\")\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .span_suggestion_verbose(\n-                    span.until(ident.span.shrink_to_lo()),\n-                    \"remove the qualifiers\",\n-                    \"fn \",\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+            self.err_handler().emit_err(errors::FnQualifierInExtern {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+                sugg_span: span.until(ident.span.shrink_to_lo()),\n+            });\n         }\n     }\n \n     /// An item in `extern { ... }` cannot use non-ascii identifier.\n     fn check_foreign_item_ascii_only(&self, ident: Ident) {\n         if !ident.as_str().is_ascii() {\n-            let n = 83942;\n-            self.err_handler()\n-                .struct_span_err(\n-                    ident.span,\n-                    \"items in `extern` blocks cannot use non-ascii identifiers\",\n-                )\n-                .span_label(self.current_extern_span(), \"in this `extern` block\")\n-                .note(&format!(\n-                    \"this limitation may be lifted in the future; see issue #{} <https://github.com/rust-lang/rust/issues/{}> for more information\",\n-                    n, n,\n-                ))\n-                .emit();\n+            self.err_handler().emit_err(errors::ExternItemAscii {\n+                span: ident.span,\n+                block: self.current_extern_span(),\n+            });\n         }\n     }\n \n@@ -505,12 +455,7 @@ impl<'a> AstValidator<'a> {\n \n         for Param { ty, span, .. } in &fk.decl().inputs {\n             if let TyKind::CVarArgs = ty.kind {\n-                self.err_handler()\n-                    .struct_span_err(\n-                        *span,\n-                        \"only foreign or `unsafe extern \\\"C\\\"` functions may be C-variadic\",\n-                    )\n-                    .emit();\n+                self.err_handler().emit_err(errors::BadCVariadic { span: *span });\n             }\n         }\n     }\n@@ -519,75 +464,32 @@ impl<'a> AstValidator<'a> {\n         if ident.name != kw::Underscore {\n             return;\n         }\n-        self.err_handler()\n-            .struct_span_err(ident.span, &format!(\"`{}` items in this context need a name\", kind))\n-            .span_label(ident.span, format!(\"`_` is not a valid name for this `{}` item\", kind))\n-            .emit();\n+        self.err_handler().emit_err(errors::ItemUnderscore { span: ident.span, kind });\n     }\n \n     fn check_nomangle_item_asciionly(&self, ident: Ident, item_span: Span) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        let head_span = self.session.source_map().guess_head_span(item_span);\n-        struct_span_err!(\n-            self.session,\n-            head_span,\n-            E0754,\n-            \"`#[no_mangle]` requires ASCII identifier\"\n-        )\n-        .emit();\n+        let span = self.session.source_map().guess_head_span(item_span);\n+        self.session.emit_err(errors::NoMangleAscii { span });\n     }\n \n     fn check_mod_file_item_asciionly(&self, ident: Ident) {\n         if ident.name.as_str().is_ascii() {\n             return;\n         }\n-        struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0754,\n-            \"trying to load file for module `{}` with non-ascii identifier name\",\n-            ident.name\n-        )\n-        .help(\"consider using `#[path]` attribute to specify filesystem path\")\n-        .emit();\n+        self.session.emit_err(errors::ModuleNonAscii { span: ident.span, name: ident.name });\n     }\n \n-    fn deny_generic_params(&self, generics: &Generics, ident_span: Span) {\n+    fn deny_generic_params(&self, generics: &Generics, ident: Span) {\n         if !generics.params.is_empty() {\n-            struct_span_err!(\n-                self.session,\n-                generics.span,\n-                E0567,\n-                \"auto traits cannot have generic parameters\"\n-            )\n-            .span_label(ident_span, \"auto trait cannot have generic parameters\")\n-            .span_suggestion(\n-                generics.span,\n-                \"remove the parameters\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.session.emit_err(errors::AutoTraitGeneric { span: generics.span, ident });\n         }\n     }\n \n-    fn emit_e0568(&self, span: Span, ident_span: Span) {\n-        struct_span_err!(\n-            self.session,\n-            span,\n-            E0568,\n-            \"auto traits cannot have super traits or lifetime bounds\"\n-        )\n-        .span_label(ident_span, \"auto trait cannot have super traits or lifetime bounds\")\n-        .span_suggestion(\n-            span,\n-            \"remove the super traits or lifetime bounds\",\n-            \"\",\n-            Applicability::MachineApplicable,\n-        )\n-        .emit();\n+    fn emit_e0568(&self, span: Span, ident: Span) {\n+        self.session.emit_err(errors::AutoTraitBounds { span, ident });\n     }\n \n     fn deny_super_traits(&self, bounds: &GenericBounds, ident_span: Span) {\n@@ -603,24 +505,11 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn deny_items(&self, trait_items: &[P<AssocItem>], ident_span: Span) {\n+    fn deny_items(&self, trait_items: &[P<AssocItem>], ident: Span) {\n         if !trait_items.is_empty() {\n             let spans: Vec<_> = trait_items.iter().map(|i| i.ident.span).collect();\n-            let total_span = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n-            struct_span_err!(\n-                self.session,\n-                spans,\n-                E0380,\n-                \"auto traits cannot have associated items\"\n-            )\n-            .span_suggestion(\n-                total_span,\n-                \"remove these associated items\",\n-                \"\",\n-                Applicability::MachineApplicable,\n-            )\n-            .span_label(ident_span, \"auto trait cannot have associated items\")\n-            .emit();\n+            let total = trait_items.first().unwrap().span.to(trait_items.last().unwrap().span);\n+            self.session.emit_err(errors::AutoTraitItems { spans, total, ident });\n         }\n     }\n \n@@ -666,43 +555,25 @@ impl<'a> AstValidator<'a> {\n         let args_len = arg_spans.len();\n         let constraint_len = constraint_spans.len();\n         // ...and then error:\n-        self.err_handler()\n-            .struct_span_err(\n-                arg_spans.clone(),\n-                \"generic arguments must come before the first constraint\",\n-            )\n-            .span_label(constraint_spans[0], &format!(\"constraint{}\", pluralize!(constraint_len)))\n-            .span_label(\n-                *arg_spans.iter().last().unwrap(),\n-                &format!(\"generic argument{}\", pluralize!(args_len)),\n-            )\n-            .span_labels(constraint_spans, \"\")\n-            .span_labels(arg_spans, \"\")\n-            .span_suggestion_verbose(\n-                data.span,\n-                &format!(\n-                    \"move the constraint{} after the generic argument{}\",\n-                    pluralize!(constraint_len),\n-                    pluralize!(args_len)\n-                ),\n-                self.correct_generic_order_suggestion(&data),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+        self.err_handler().emit_err(errors::ArgsBeforeConstraint {\n+            arg_spans: arg_spans.clone(),\n+            constraints: constraint_spans[0],\n+            args: *arg_spans.iter().last().unwrap(),\n+            data: data.span,\n+            constraint_spans: errors::EmptyLabelManySpans(constraint_spans),\n+            arg_spans2: errors::EmptyLabelManySpans(arg_spans),\n+            suggestion: self.correct_generic_order_suggestion(&data),\n+            constraint_len,\n+            args_len,\n+        });\n     }\n \n     fn visit_ty_common(&mut self, ty: &'a Ty) {\n         match &ty.kind {\n             TyKind::BareFn(bfty) => {\n                 self.check_fn_decl(&bfty.decl, SelfSemantic::No);\n                 Self::check_decl_no_pat(&bfty.decl, |span, _, _| {\n-                    struct_span_err!(\n-                        self.session,\n-                        span,\n-                        E0561,\n-                        \"patterns aren't allowed in function pointer types\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::PatternFnPointer { span });\n                 });\n                 if let Extern::Implicit(_) = bfty.ext {\n                     let sig_span = self.session.source_map().next_point(ty.span.shrink_to_lo());\n@@ -714,13 +585,8 @@ impl<'a> AstValidator<'a> {\n                 for bound in bounds {\n                     if let GenericBound::Outlives(lifetime) = bound {\n                         if any_lifetime_bounds {\n-                            struct_span_err!(\n-                                self.session,\n-                                lifetime.ident.span,\n-                                E0226,\n-                                \"only a single explicit lifetime bound is permitted\"\n-                            )\n-                            .emit();\n+                            self.session\n+                                .emit_err(errors::TraitObjectBound { span: lifetime.ident.span });\n                             break;\n                         }\n                         any_lifetime_bounds = true;\n@@ -729,29 +595,19 @@ impl<'a> AstValidator<'a> {\n             }\n             TyKind::ImplTrait(_, bounds) => {\n                 if self.is_impl_trait_banned {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0667,\n-                        \"`impl Trait` is not allowed in path parameters\"\n-                    )\n-                    .emit();\n+                    self.session.emit_err(errors::ImplTraitPath { span: ty.span });\n                 }\n \n                 if let Some(outer_impl_trait_sp) = self.outer_impl_trait {\n-                    struct_span_err!(\n-                        self.session,\n-                        ty.span,\n-                        E0666,\n-                        \"nested `impl Trait` is not allowed\"\n-                    )\n-                    .span_label(outer_impl_trait_sp, \"outer `impl Trait`\")\n-                    .span_label(ty.span, \"nested `impl Trait` here\")\n-                    .emit();\n+                    self.session.emit_err(errors::NestedImplTrait {\n+                        span: ty.span,\n+                        outer: outer_impl_trait_sp,\n+                        inner: ty.span,\n+                    });\n                 }\n \n                 if !bounds.iter().any(|b| matches!(b, GenericBound::Trait(..))) {\n-                    self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n+                    self.err_handler().emit_err(errors::AtLeastOneTrait { span: ty.span });\n                 }\n             }\n             _ => {}\n@@ -772,7 +628,7 @@ impl<'a> AstValidator<'a> {\n                 MISSING_ABI,\n                 id,\n                 span,\n-                \"extern declarations without an explicit ABI are deprecated\",\n+                fluent::ast_passes_extern_without_abi,\n                 BuiltinLintDiagnostics::MissingAbi(span, abi::Abi::FALLBACK),\n             )\n         }\n@@ -787,7 +643,7 @@ fn validate_generic_param_order(\n     span: Span,\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n-    let mut out_of_order = FxHashMap::default();\n+    let mut out_of_order = FxIndexMap::default();\n     let mut param_idents = Vec::with_capacity(generics.len());\n \n     for (idx, param) in generics.iter().enumerate() {\n@@ -845,20 +701,13 @@ fn validate_generic_param_order(\n         ordered_params += \">\";\n \n         for (param_ord, (max_param, spans)) in &out_of_order {\n-            let mut err = handler.struct_span_err(\n-                spans.clone(),\n-                &format!(\n-                    \"{} parameters must be declared prior to {} parameters\",\n-                    param_ord, max_param,\n-                ),\n-            );\n-            err.span_suggestion(\n-                span,\n-                \"reorder the parameters: lifetimes, then consts and types\",\n-                &ordered_params,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            handler.emit_err(errors::OutOfOrderParams {\n+                spans: spans.clone(),\n+                sugg_span: span,\n+                param_ord,\n+                max_param,\n+                ordered_params: &ordered_params,\n+            });\n         }\n     }\n }\n@@ -950,11 +799,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| attr.is_proc_macro_attr()) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -972,25 +821,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.with_in_trait_impl(true, Some(*constness), |this| {\n                     this.invalid_visibility(&item.vis, None);\n                     if let TyKind::Err = self_ty.kind {\n-                        this.err_handler()\n-                            .struct_span_err(\n-                                item.span,\n-                                \"`impl Trait for .. {}` is an obsolete syntax\",\n-                            )\n-                            .help(\"use `auto trait Trait {}` instead\")\n-                            .emit();\n+                        this.err_handler().emit_err(errors::ObsoleteAuto { span: item.span });\n                     }\n                     if let (&Unsafe::Yes(span), &ImplPolarity::Negative(sp)) = (unsafety, polarity)\n                     {\n-                        struct_span_err!(\n-                            this.session,\n-                            sp.to(t.path.span),\n-                            E0198,\n-                            \"negative impls cannot be unsafe\"\n-                        )\n-                        .span_label(sp, \"negative because of this\")\n-                        .span_label(span, \"unsafe because of this\")\n-                        .emit();\n+                        this.session.emit_err(errors::UnsafeNegativeImpl {\n+                            span: sp.to(t.path.span),\n+                            negative: sp,\n+                            r#unsafe: span,\n+                        });\n                     }\n \n                     this.visit_vis(&item.vis);\n@@ -1018,52 +857,54 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self_ty,\n                 items: _,\n             }) => {\n-                let error = |annotation_span, annotation| {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        self_ty.span,\n-                        &format!(\"inherent impls cannot be {}\", annotation),\n-                    );\n-                    err.span_label(annotation_span, &format!(\"{} because of this\", annotation));\n-                    err.span_label(self_ty.span, \"inherent impl for this type\");\n-                    err\n-                };\n+                let error =\n+                    |annotation_span, annotation, only_trait: bool| errors::InherentImplCannot {\n+                        span: self_ty.span,\n+                        annotation_span,\n+                        annotation,\n+                        self_ty: self_ty.span,\n+                        only_trait: only_trait.then_some(()),\n+                    };\n \n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualImplItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualImplItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    error(span, \"unsafe\").code(error_code!(E0197)).emit();\n+                    self.err_handler().emit_err(errors::InherentImplCannotUnsafe {\n+                        span: self_ty.span,\n+                        annotation_span: span,\n+                        annotation: \"unsafe\",\n+                        self_ty: self_ty.span,\n+                    });\n                 }\n                 if let &ImplPolarity::Negative(span) = polarity {\n-                    error(span, \"negative\").emit();\n+                    self.err_handler().emit_err(error(span, \"negative\", false));\n                 }\n                 if let &Defaultness::Default(def_span) = defaultness {\n-                    error(def_span, \"`default`\")\n-                        .note(\"only trait implementations may be annotated with `default`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(def_span, \"`default`\", true));\n                 }\n                 if let &Const::Yes(span) = constness {\n-                    error(span, \"`const`\")\n-                        .note(\"only trait implementations may be annotated with `const`\")\n-                        .emit();\n+                    self.err_handler().emit_err(error(span, \"`const`\", true));\n                 }\n             }\n             ItemKind::Fn(box Fn { defaultness, sig, generics, body }) => {\n                 self.check_defaultness(item.span, *defaultness);\n \n                 if body.is_none() {\n-                    self.session.emit_err(FnWithoutBody {\n+                    self.session.emit_err(errors::FnWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                         extern_block_suggestion: match sig.header.ext {\n                             Extern::None => None,\n-                            Extern::Implicit(start_span) => Some(ExternBlockSuggestion::Implicit {\n-                                start_span,\n-                                end_span: item.span.shrink_to_hi(),\n-                            }),\n+                            Extern::Implicit(start_span) => {\n+                                Some(errors::ExternBlockSuggestion::Implicit {\n+                                    start_span,\n+                                    end_span: item.span.shrink_to_hi(),\n+                                })\n+                            }\n                             Extern::Explicit(abi, start_span) => {\n-                                Some(ExternBlockSuggestion::Explicit {\n+                                Some(errors::ExternBlockSuggestion::Explicit {\n                                     start_span,\n                                     end_span: item.span.shrink_to_hi(),\n                                     abi: abi.symbol_unescaped,\n@@ -1085,10 +926,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 let old_item = mem::replace(&mut self.extern_mod, Some(item));\n                 self.invalid_visibility(\n                     &item.vis,\n-                    Some(InvalidVisibilityNote::IndividualForeignItems),\n+                    Some(errors::InvalidVisibilityNote::IndividualForeignItems),\n                 );\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"extern block cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"extern block\" });\n                 }\n                 if abi.is_none() {\n                     self.maybe_lint_missing_abi(item.span, item.id);\n@@ -1128,51 +969,45 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(unsafety, mod_kind) => {\n                 if let &Unsafe::Yes(span) = unsafety {\n-                    self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n+                    self.err_handler().emit_err(errors::UnsafeItem { span, kind: \"module\" });\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n                 if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n-                    && !self.session.contains_name(&item.attrs, sym::path)\n+                    && !attr::contains_name(&item.attrs, sym::path)\n                 {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n             ItemKind::Union(vdata, ..) => {\n                 if vdata.fields().is_empty() {\n-                    self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n+                    self.err_handler().emit_err(errors::FieldlessUnion { span: item.span });\n                 }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, *def);\n-                self.session.emit_err(ConstWithoutBody {\n+                self.session.emit_err(errors::ConstWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::Static(.., None) => {\n-                self.session.emit_err(StaticWithoutBody {\n+                self.session.emit_err(errors::StaticWithoutBody {\n                     span: item.span,\n                     replace_span: self.ending_semi_or_hi(item.span),\n                 });\n             }\n             ItemKind::TyAlias(box TyAlias { defaultness, where_clauses, bounds, ty, .. }) => {\n                 self.check_defaultness(item.span, *defaultness);\n                 if ty.is_none() {\n-                    self.session.emit_err(TyAliasWithoutBody {\n+                    self.session.emit_err(errors::TyAliasWithoutBody {\n                         span: item.span,\n                         replace_span: self.ending_semi_or_hi(item.span),\n                     });\n                 }\n                 self.check_type_no_bounds(bounds, \"this context\");\n                 if where_clauses.1.0 {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        where_clauses.1.1,\n-                        \"where clauses are not allowed after the type for type aliases\",\n-                    );\n-                    err.note(\n-                        \"see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\",\n-                    );\n-                    err.emit();\n+                    self.err_handler()\n+                        .emit_err(errors::WhereAfterTypeAlias { span: where_clauses.1.1 });\n                 }\n             }\n             _ => {}\n@@ -1254,11 +1089,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                     if let Some(span) = prev_param_default {\n-                        let mut err = self.err_handler().struct_span_err(\n-                            span,\n-                            \"generic parameters with a default must be trailing\",\n-                        );\n-                        err.emit();\n+                        self.err_handler().emit_err(errors::GenericDefaultTrailing { span });\n                         break;\n                     }\n                 }\n@@ -1286,13 +1117,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                             match bound {\n                                 GenericBound::Trait(t, _) => {\n                                     if !t.bound_generic_params.is_empty() {\n-                                        struct_span_err!(\n-                                            self.err_handler(),\n-                                            t.span,\n-                                            E0316,\n-                                            \"nested quantification of lifetimes\"\n-                                        )\n-                                        .emit();\n+                                        self.err_handler()\n+                                            .emit_err(errors::NestedLifetimes { span: t.span });\n                                     }\n                                 }\n                                 GenericBound::Outlives(_) => {}\n@@ -1317,32 +1143,27 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         if let GenericBound::Trait(poly, modify) = bound {\n             match (ctxt, modify) {\n                 (BoundKind::SuperTraits, TraitBoundModifier::Maybe) => {\n-                    let mut err = self\n-                        .err_handler()\n-                        .struct_span_err(poly.span, \"`?Trait` is not permitted in supertraits\");\n-                    let path_str = pprust::path_to_string(&poly.trait_ref.path);\n-                    err.note(&format!(\"traits are `?{}` by default\", path_str));\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitSupertrait {\n+                        span: poly.span,\n+                        path_str: pprust::path_to_string(&poly.trait_ref.path)\n+                    });\n                 }\n                 (BoundKind::TraitObject, TraitBoundModifier::Maybe) => {\n-                    let mut err = self.err_handler().struct_span_err(\n-                        poly.span,\n-                        \"`?Trait` is not permitted in trait object types\",\n-                    );\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::OptionalTraitObject {span: poly.span});\n                 }\n                 (_, TraitBoundModifier::MaybeConst) if let Some(reason) = &self.disallow_tilde_const => {\n-                    let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n-                    match reason {\n-                        DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n-                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n+                    let reason = match reason {\n+                        DisallowTildeConstContext::TraitObject => errors::TildeConstReason::TraitObject,\n+                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => errors::TildeConstReason::Closure,\n+                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => errors::TildeConstReason::Function { ident: ident.span },\n                     };\n-                    err.emit();\n+                    self.err_handler().emit_err(errors::TildeConstDisallowed {\n+                        span: bound.span(),\n+                        reason\n+                    });\n                 }\n                 (_, TraitBoundModifier::MaybeConstMaybe) => {\n-                    self.err_handler()\n-                        .span_err(bound.span(), \"`~const` and `?` are mutually exclusive\");\n+                    self.err_handler().emit_err(errors::OptionalConstExclusive {span: bound.span()});\n                 }\n                 _ => {}\n             }\n@@ -1362,21 +1183,18 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         self.check_c_variadic_type(fk);\n \n         // Functions cannot both be `const async`\n-        if let Some(FnHeader {\n+        if let Some(&FnHeader {\n             constness: Const::Yes(cspan),\n             asyncness: Async::Yes { span: aspan, .. },\n             ..\n         }) = fk.header()\n         {\n-            self.err_handler()\n-                .struct_span_err(\n-                    vec![*cspan, *aspan],\n-                    \"functions cannot be both `const` and `async`\",\n-                )\n-                .span_label(*cspan, \"`const` because of this\")\n-                .span_label(*aspan, \"`async` because of this\")\n-                .span_label(span, \"\") // Point at the fn header.\n-                .emit();\n+            self.err_handler().emit_err(errors::ConstAndAsync {\n+                spans: vec![cspan, aspan],\n+                cspan,\n+                aspan,\n+                span,\n+            });\n         }\n \n         if let FnKind::Fn(\n@@ -1394,20 +1212,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         // Functions without bodies cannot have patterns.\n         if let FnKind::Fn(ctxt, _, sig, _, _, None) = fk {\n             Self::check_decl_no_pat(&sig.decl, |span, ident, mut_ident| {\n-                let (code, msg, label) = match ctxt {\n-                    FnCtxt::Foreign => (\n-                        error_code!(E0130),\n-                        \"patterns aren't allowed in foreign function declarations\",\n-                        \"pattern not allowed in foreign function\",\n-                    ),\n-                    _ => (\n-                        error_code!(E0642),\n-                        \"patterns aren't allowed in functions without bodies\",\n-                        \"pattern not allowed in function without body\",\n-                    ),\n-                };\n                 if mut_ident && matches!(ctxt, FnCtxt::Assoc(_)) {\n                     if let Some(ident) = ident {\n+                        let msg = match ctxt {\n+                            FnCtxt::Foreign => fluent::ast_passes_pattern_in_foreign,\n+                            _ => fluent::ast_passes_pattern_in_bodiless,\n+                        };\n                         let diag = BuiltinLintDiagnostics::PatternsInFnsWithoutBody(span, ident);\n                         self.lint_buffer.buffer_lint_with_diagnostic(\n                             PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -1418,11 +1228,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         )\n                     }\n                 } else {\n-                    self.err_handler()\n-                        .struct_span_err(span, msg)\n-                        .span_label(span, label)\n-                        .code(code)\n-                        .emit();\n+                    match ctxt {\n+                        FnCtxt::Foreign => {\n+                            self.err_handler().emit_err(errors::PatternInForeign { span })\n+                        }\n+                        _ => self.err_handler().emit_err(errors::PatternInBodiless { span }),\n+                    };\n                 }\n             });\n         }\n@@ -1437,7 +1248,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n-        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n+        if attr::contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -1449,15 +1260,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             match &item.kind {\n                 AssocItemKind::Const(_, _, body) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocConstWithoutBody {\n+                        self.session.emit_err(errors::AssocConstWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n                     }\n                 }\n                 AssocItemKind::Fn(box Fn { body, .. }) => {\n                     if body.is_none() {\n-                        self.session.emit_err(AssocFnWithoutBody {\n+                        self.session.emit_err(errors::AssocFnWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1472,7 +1283,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     ..\n                 }) => {\n                     if ty.is_none() {\n-                        self.session.emit_err(AssocTypeWithoutBody {\n+                        self.session.emit_err(errors::AssocTypeWithoutBody {\n                             span: item.span,\n                             replace_span: self.ending_semi_or_hi(item.span),\n                         });\n@@ -1544,11 +1355,7 @@ fn deny_equality_constraints(\n     predicate: &WhereEqPredicate,\n     generics: &Generics,\n ) {\n-    let mut err = this.err_handler().struct_span_err(\n-        predicate.span,\n-        \"equality constraints are not yet supported in `where` clauses\",\n-    );\n-    err.span_label(predicate.span, \"not supported\");\n+    let mut err = errors::EqualityInWhere { span: predicate.span, assoc: None, assoc2: None };\n \n     // Given `<A as Foo>::Bar = RhsTy`, suggest `A: Foo<Bar = RhsTy>`.\n     if let TyKind::Path(Some(qself), full_path) = &predicate.lhs_ty.kind {\n@@ -1592,20 +1399,12 @@ fn deny_equality_constraints(\n                                             .into();\n                                         }\n                                     }\n-                                    err.span_suggestion_verbose(\n-                                        predicate.span,\n-                                        &format!(\n-                                            \"if `{}` is an associated type you're trying to set, \\\n-                                            use the associated type binding syntax\",\n-                                            ident\n-                                        ),\n-                                        format!(\n-                                            \"{}: {}\",\n-                                            param,\n-                                            pprust::path_to_string(&assoc_path)\n-                                        ),\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n+                                    err.assoc = Some(errors::AssociatedSuggestion {\n+                                        span: predicate.span,\n+                                        ident: *ident,\n+                                        param: *param,\n+                                        path: pprust::path_to_string(&assoc_path),\n+                                    })\n                                 }\n                                 _ => {}\n                             };\n@@ -1647,26 +1446,21 @@ fn deny_equality_constraints(\n                                         trait_segment.span().shrink_to_hi(),\n                                     ),\n                                 };\n-                                err.multipart_suggestion(\n-                                    &format!(\n-                                        \"if `{}::{}` is an associated type you're trying to set, \\\n-                                        use the associated type binding syntax\",\n-                                        trait_segment.ident, potential_assoc.ident,\n-                                    ),\n-                                    vec![(span, args), (predicate.span, String::new())],\n-                                    Applicability::MaybeIncorrect,\n-                                );\n+                                err.assoc2 = Some(errors::AssociatedSuggestion2 {\n+                                    span,\n+                                    args,\n+                                    predicate: predicate.span,\n+                                    trait_segment: trait_segment.ident,\n+                                    potential_assoc: potential_assoc.ident,\n+                                });\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n     }\n-    err.note(\n-        \"see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\",\n-    );\n-    err.emit();\n+    this.err_handler().emit_err(err);\n }\n \n pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) -> bool {"}, {"sha": "d007097d91818b6c705b7ad3d34ddbf60139be52", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 475, "deletions": 1, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,9 +1,12 @@\n //! Errors emitted by ast_passes.\n \n+use rustc_ast::ParamKindOrd;\n+use rustc_errors::AddToDiagnostic;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{symbol::Ident, Span, Symbol};\n \n use crate::ast_validation::ForbiddenLetReason;\n+use crate::fluent_generated as fluent;\n \n #[derive(Diagnostic)]\n #[diag(ast_passes_forbidden_let)]\n@@ -217,3 +220,474 @@ pub enum ExternBlockSuggestion {\n         abi: Symbol,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bound_in_context)]\n+pub struct BoundInContext<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ctx: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_types_cannot)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct ExternTypesCannotHave<'a> {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    pub descr: &'a str,\n+    pub remove_descr: &'a str,\n+    #[label]\n+    pub block_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_body_in_extern)]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct BodyInExtern<'a> {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[label(ast_passes_invalid)]\n+    pub body: Span,\n+    #[label(ast_passes_existing)]\n+    pub block: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fn_body_extern)]\n+#[help]\n+#[note(ast_passes_extern_keyword_link)]\n+pub struct FnBodyInExtern {\n+    #[primary_span]\n+    #[label(ast_passes_cannot_have)]\n+    pub span: Span,\n+    #[suggestion(code = \";\", applicability = \"maybe-incorrect\")]\n+    pub body: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_fn_qualifiers)]\n+pub struct FnQualifierInExtern {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+    #[suggestion(code = \"fn \", applicability = \"maybe-incorrect\", style = \"verbose\")]\n+    pub sugg_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_extern_item_ascii)]\n+#[note]\n+pub struct ExternItemAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub block: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_bad_c_variadic)]\n+pub struct BadCVariadic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_item_underscore)]\n+pub struct ItemUnderscore<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub kind: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nomangle_ascii, code = \"E0754\")]\n+pub struct NoMangleAscii {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_module_nonascii, code = \"E0754\")]\n+#[help]\n+pub struct ModuleNonAscii {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_generic, code = \"E0567\")]\n+pub struct AutoTraitGeneric {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_super_lifetime, code = \"E0568\")]\n+pub struct AutoTraitBounds {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_auto_items, code = \"E0380\")]\n+pub struct AutoTraitItems {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub total: Span,\n+    #[label]\n+    pub ident: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_before_constraints)]\n+pub struct ArgsBeforeConstraint {\n+    #[primary_span]\n+    pub arg_spans: Vec<Span>,\n+    #[label(ast_passes_constraints)]\n+    pub constraints: Span,\n+    #[label(ast_passes_args)]\n+    pub args: Span,\n+    #[suggestion(code = \"{suggestion}\", applicability = \"machine-applicable\", style = \"verbose\")]\n+    pub data: Span,\n+    pub suggestion: String,\n+    pub constraint_len: usize,\n+    pub args_len: usize,\n+    #[subdiagnostic]\n+    pub constraint_spans: EmptyLabelManySpans,\n+    #[subdiagnostic]\n+    pub arg_spans2: EmptyLabelManySpans,\n+}\n+\n+pub struct EmptyLabelManySpans(pub Vec<Span>);\n+\n+// The derive for `Vec<Span>` does multiple calls to `span_label`, adding commas between each\n+impl AddToDiagnostic for EmptyLabelManySpans {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.span_labels(self.0, \"\");\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_fn_pointer, code = \"E0561\")]\n+pub struct PatternFnPointer {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_trait_object_single_bound, code = \"E0226\")]\n+pub struct TraitObjectBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_impl_trait_path, code = \"E0667\")]\n+pub struct ImplTraitPath {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_impl_trait, code = \"E0666\")]\n+pub struct NestedImplTrait {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_outer)]\n+    pub outer: Span,\n+    #[label(ast_passes_inner)]\n+    pub inner: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_at_least_one_trait)]\n+pub struct AtLeastOneTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_out_of_order_params)]\n+pub struct OutOfOrderParams<'a> {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[suggestion(code = \"{ordered_params}\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Span,\n+    pub param_ord: &'a ParamKindOrd,\n+    pub max_param: &'a ParamKindOrd,\n+    pub ordered_params: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_obsolete_auto)]\n+#[help]\n+pub struct ObsoleteAuto {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_negative_impl, code = \"E0198\")]\n+pub struct UnsafeNegativeImpl {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_negative)]\n+    pub negative: Span,\n+    #[label(ast_passes_unsafe)]\n+    pub r#unsafe: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be)]\n+pub struct InherentImplCannot<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+    #[note(ast_passes_only_trait)]\n+    pub only_trait: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_inherent_cannot_be, code = \"E0197\")]\n+pub struct InherentImplCannotUnsafe<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(ast_passes_because)]\n+    pub annotation_span: Span,\n+    pub annotation: &'a str,\n+    #[label(ast_passes_type)]\n+    pub self_ty: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_unsafe_item)]\n+pub struct UnsafeItem {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_fieldless_union)]\n+pub struct FieldlessUnion {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_where_after_type_alias)]\n+#[note]\n+pub struct WhereAfterTypeAlias {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_generic_default_trailing)]\n+pub struct GenericDefaultTrailing {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_nested_lifetimes, code = \"E0316\")]\n+pub struct NestedLifetimes {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_supertrait)]\n+#[note]\n+pub struct OptionalTraitSupertrait {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path_str: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_trait_object)]\n+pub struct OptionalTraitObject {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_tilde_const_disallowed)]\n+pub struct TildeConstDisallowed {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: TildeConstReason,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum TildeConstReason {\n+    #[note(ast_passes_trait)]\n+    TraitObject,\n+    #[note(ast_passes_closure)]\n+    Closure,\n+    #[note(ast_passes_function)]\n+    Function {\n+        #[primary_span]\n+        ident: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_optional_const_exclusive)]\n+pub struct OptionalConstExclusive {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_const_and_async)]\n+pub struct ConstAndAsync {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label(ast_passes_const)]\n+    pub cspan: Span,\n+    #[label(ast_passes_async)]\n+    pub aspan: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_foreign, code = \"E0130\")]\n+pub struct PatternInForeign {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_pattern_in_bodiless, code = \"E0642\")]\n+pub struct PatternInBodiless {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_equality_in_where)]\n+#[note]\n+pub struct EqualityInWhere {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub assoc: Option<AssociatedSuggestion>,\n+    #[subdiagnostic]\n+    pub assoc2: Option<AssociatedSuggestion2>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_passes_suggestion,\n+    code = \"{param}: {path}\",\n+    style = \"verbose\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct AssociatedSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub param: Ident,\n+    pub path: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(ast_passes_suggestion_path, applicability = \"maybe-incorrect\")]\n+pub struct AssociatedSuggestion2 {\n+    #[suggestion_part(code = \"{args}\")]\n+    pub span: Span,\n+    pub args: String,\n+    #[suggestion_part(code = \"\")]\n+    pub predicate: Span,\n+    pub trait_segment: Ident,\n+    pub potential_assoc: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_stability_outside_std, code = \"E0734\")]\n+pub struct StabilityOutsideStd {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_feature_on_non_nightly, code = \"E0554\")]\n+pub struct FeatureOnNonNightly {\n+    #[primary_span]\n+    pub span: Span,\n+    pub channel: &'static str,\n+    #[subdiagnostic]\n+    pub stable_features: Vec<StableFeature>,\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub sugg: Option<Span>,\n+}\n+\n+pub struct StableFeature {\n+    pub name: Symbol,\n+    pub since: Symbol,\n+}\n+\n+impl AddToDiagnostic for StableFeature {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.set_arg(\"name\", self.name);\n+        diag.set_arg(\"since\", self.since);\n+        diag.help(fluent::ast_passes_stable_since);\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_incompatbile_features)]\n+#[help]\n+pub struct IncompatibleFeatures {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    pub f1: Symbol,\n+    pub f2: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(ast_passes_show_span)]\n+pub struct ShowSpan {\n+    #[primary_span]\n+    pub span: Span,\n+    pub msg: &'static str,\n+}"}, {"sha": "344a1e7f5e795d2bd8078421f4f62f103780ac32", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 64, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,8 +1,8 @@\n use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n+use rustc_ast::{attr, AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd};\n-use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_errors::{Applicability, StashKey};\n use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n use rustc_session::Session;\n@@ -13,7 +13,7 @@ use rustc_target::spec::abi;\n use thin_vec::ThinVec;\n use tracing::debug;\n \n-use crate::errors::ForbiddenLifetimeBound;\n+use crate::errors;\n \n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n@@ -164,7 +164,7 @@ impl<'a> PostExpansionVisitor<'a> {\n         for param in params {\n             if !param.bounds.is_empty() {\n                 let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-                self.sess.emit_err(ForbiddenLifetimeBound { spans });\n+                self.sess.emit_err(errors::ForbiddenLifetimeBound { spans });\n             }\n         }\n     }\n@@ -218,13 +218,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 || attr.has_name(sym::rustc_const_stable)\n                 || attr.has_name(sym::rustc_default_body_unstable)\n             {\n-                struct_span_err!(\n-                    self.sess,\n-                    attr.span,\n-                    E0734,\n-                    \"stability attributes may not be used outside of the standard library\",\n-                )\n-                .emit();\n+                self.sess.emit_err(errors::StabilityOutsideStd { span: attr.span });\n             }\n         }\n     }\n@@ -238,7 +232,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if self.sess.contains_name(&i.attrs, sym::start) {\n+                if attr::contains_name(&i.attrs, sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -251,7 +245,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in self.sess.filter_by_name(&i.attrs, sym::repr) {\n+                for attr in attr::filter_by_name(&i.attrs, sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(ThinVec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n@@ -312,7 +306,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm =\n                     link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {\n@@ -343,9 +337,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::TyKind::Never => {\n                 gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n             }\n-            ast::TyKind::TraitObject(_, ast::TraitObjectSyntax::DynStar, ..) => {\n-                gate_feature_post!(&self, dyn_star, ty.span, \"dyn* trait objects are unstable\");\n-            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty)\n@@ -392,7 +383,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ).span_suggestion_verbose(\n                 lhs.span.shrink_to_lo(),\n                 \"you might have meant to introduce a new binding\",\n-                \"let \".to_string(),\n+                \"let \",\n                 Applicability::MachineApplicable,\n             ).emit();\n         }\n@@ -401,14 +392,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         match e.kind {\n-            ast::ExprKind::Box(_) => {\n-                gate_feature_post!(\n-                    &self,\n-                    box_syntax,\n-                    e.span,\n-                    \"box expression syntax is experimental; you can call `Box::new` instead\"\n-                );\n-            }\n             ast::ExprKind::Type(..) => {\n                 if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n                     // To avoid noise about type ascription in common syntax errors,\n@@ -431,14 +414,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::TryBlock(_) => {\n                 gate_feature_post!(&self, try_blocks, e.span, \"`try` expression is experimental\");\n             }\n-            ast::ExprKind::Closure(box ast::Closure { constness: ast::Const::Yes(_), .. }) => {\n-                gate_feature_post!(\n-                    &self,\n-                    const_closures,\n-                    e.span,\n-                    \"const closures are experimental\"\n-                );\n-            }\n             _ => {}\n         }\n         visit::walk_expr(self, e)\n@@ -600,6 +575,8 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(inline_const_pat, \"inline-const in pattern position is experimental\");\n     gate_all!(associated_const_equality, \"associated const equality is incomplete\");\n     gate_all!(yeet_expr, \"`do yeet` expression is experimental\");\n+    gate_all!(dyn_star, \"`dyn*` trait objects are experimental\");\n+    gate_all!(const_closures, \"const closures are experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded).\n@@ -619,7 +596,6 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(box_patterns, \"box pattern syntax is experimental\");\n     gate_all!(exclusive_range_pattern, \"exclusive range pattern syntax is experimental\");\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n-    gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n     gate_all!(type_ascription, \"type ascription is experimental\");\n \n     visit::walk_crate(&mut visitor, krate);\n@@ -635,13 +611,13 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n             return;\n         }\n         for attr in krate.attrs.iter().filter(|attr| attr.has_name(sym::feature)) {\n-            let mut err = struct_span_err!(\n-                sess.parse_sess.span_diagnostic,\n-                attr.span,\n-                E0554,\n-                \"`#![feature]` may not be used on the {} release channel\",\n-                option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\")\n-            );\n+            let mut err = errors::FeatureOnNonNightly {\n+                span: attr.span,\n+                channel: option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\"),\n+                stable_features: vec![],\n+                sugg: None,\n+            };\n+\n             let mut all_stable = true;\n             for ident in\n                 attr.meta_item_list().into_iter().flatten().flat_map(|nested| nested.ident())\n@@ -652,24 +628,15 @@ fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n                     .flat_map(|&(feature, _, since)| if feature == name { since } else { None })\n                     .next();\n                 if let Some(since) = stable_since {\n-                    err.help(&format!(\n-                        \"the feature `{}` has been stable since {} and no longer requires \\\n-                                  an attribute to enable\",\n-                        name, since\n-                    ));\n+                    err.stable_features.push(errors::StableFeature { name, since });\n                 } else {\n                     all_stable = false;\n                 }\n             }\n             if all_stable {\n-                err.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                err.sugg = Some(attr.span);\n             }\n-            err.emit();\n+            sess.parse_sess.span_diagnostic.emit_err(err);\n         }\n     }\n }\n@@ -692,16 +659,7 @@ fn check_incompatible_features(sess: &Session) {\n             if let Some((f2_name, f2_span)) = declared_features.clone().find(|(name, _)| name == f2)\n             {\n                 let spans = vec![f1_span, f2_span];\n-                sess.struct_span_err(\n-                    spans,\n-                    &format!(\n-                        \"features `{}` and `{}` are incompatible, using them at the same time \\\n-                        is not allowed\",\n-                        f1_name, f2_name\n-                    ),\n-                )\n-                .help(\"remove one of these features\")\n-                .emit();\n+                sess.emit_err(errors::IncompatibleFeatures { spans, f1: f1_name, f2: f2_name });\n             }\n         }\n     }"}, {"sha": "e2c666604b3c36058772e8949c25cb7e5b6688ce", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -4,12 +4,13 @@\n //!\n //! The crate also contains other misc AST visitors, e.g. `node_count` and `show_span`.\n \n-#![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(if_let_guard)]\n #![feature(iter_is_partitioned)]\n #![feature(let_chains)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_macros::fluent_messages;\n@@ -20,4 +21,4 @@ pub mod feature_gate;\n pub mod node_count;\n pub mod show_span;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "280cf3284c38ccd4940902c8c6346a7059ba7603", "filename": "compiler/rustc_ast_passes/src/show_span.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fshow_span.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -9,6 +9,8 @@ use rustc_ast as ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n \n+use crate::errors;\n+\n enum Mode {\n     Expression,\n     Pattern,\n@@ -36,21 +38,21 @@ struct ShowSpanVisitor<'a> {\n impl<'a> Visitor<'a> for ShowSpanVisitor<'a> {\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         if let Mode::Expression = self.mode {\n-            self.span_diagnostic.span_warn(e.span, \"expression\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: e.span, msg: \"expression\" });\n         }\n         visit::walk_expr(self, e);\n     }\n \n     fn visit_pat(&mut self, p: &'a ast::Pat) {\n         if let Mode::Pattern = self.mode {\n-            self.span_diagnostic.span_warn(p.span, \"pattern\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: p.span, msg: \"pattern\" });\n         }\n         visit::walk_pat(self, p);\n     }\n \n     fn visit_ty(&mut self, t: &'a ast::Ty) {\n         if let Mode::Type = self.mode {\n-            self.span_diagnostic.span_warn(t.span, \"type\");\n+            self.span_diagnostic.emit_warning(errors::ShowSpan { span: t.span, msg: \"type\" });\n         }\n         visit::walk_ty(self, t);\n     }"}, {"sha": "e2f63641ffa53b74a5b9eea4656b2690f48756d3", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -244,6 +244,10 @@ impl<'a> State<'a> {\n             (&ast::ExprKind::Let { .. }, _) if !parser::needs_par_as_let_scrutinee(prec) => {\n                 parser::PREC_FORCE_PAREN\n             }\n+            // For a binary expression like `(match () { _ => a }) OP b`, the parens are required\n+            // otherwise the parser would interpret `match () { _ => a }` as a statement,\n+            // with the remaining `OP b` not making sense. So we force parens.\n+            (&ast::ExprKind::Match(..), _) => parser::PREC_FORCE_PAREN,\n             _ => left_prec,\n         };\n \n@@ -292,10 +296,6 @@ impl<'a> State<'a> {\n         self.ibox(INDENT_UNIT);\n         self.ann.pre(self, AnnNode::Expr(expr));\n         match &expr.kind {\n-            ast::ExprKind::Box(expr) => {\n-                self.word_space(\"box\");\n-                self.print_expr_maybe_paren(expr, parser::PREC_PREFIX);\n-            }\n             ast::ExprKind::Array(exprs) => {\n                 self.print_expr_vec(exprs);\n             }"}, {"sha": "a7f8c993d4225316129e515ef4e2a84bbe872137", "filename": "compiler/rustc_attr/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_attr%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_attr%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_attr/locales/en-US.ftl"}, {"sha": "a29e389953eb35aaa470ff87e4d35c87a81e3193", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 301, "deletions": 298, "changes": 599, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedMetaItem, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n@@ -226,307 +226,95 @@ impl UnstableReason {\n     }\n }\n \n-/// Collects stability info from all stability attributes in `attrs`.\n-/// Returns `None` if no stability attributes are found.\n+/// Collects stability info from `stable`/`unstable`/`rustc_allowed_through_unstable_modules`\n+/// attributes in `attrs`.  Returns `None` if no stability attributes are found.\n pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-{\n-    find_stability_generic(sess, attrs.iter(), item_sp)\n-}\n-\n-fn find_stability_generic<'a, I>(\n-    sess: &Session,\n-    attrs_iter: I,\n-    item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-where\n-    I: Iterator<Item = &'a Attribute>,\n-{\n-    use StabilityLevel::*;\n-\n+) -> Option<(Stability, Span)> {\n     let mut stab: Option<(Stability, Span)> = None;\n-    let mut const_stab: Option<(ConstStability, Span)> = None;\n-    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n-    let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    'outer: for attr in attrs_iter {\n-        if ![\n-            sym::rustc_const_unstable,\n-            sym::rustc_const_stable,\n-            sym::unstable,\n-            sym::stable,\n-            sym::rustc_promotable,\n-            sym::rustc_allowed_through_unstable_modules,\n-            sym::rustc_default_body_unstable,\n-        ]\n-        .iter()\n-        .any(|&s| attr.has_name(s))\n-        {\n-            continue; // not a stability level\n-        }\n-\n-        let meta = attr.meta();\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_allowed_through_unstable_modules => allowed_through_unstable_modules = true,\n+            sym::unstable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n \n-        if attr.has_name(sym::rustc_promotable) {\n-            promotable = true;\n-        } else if attr.has_name(sym::rustc_allowed_through_unstable_modules) {\n-            allowed_through_unstable_modules = true;\n-        }\n-        // attributes with data\n-        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        meta.span,\n-                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n-                    );\n-                    return false;\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n                 }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n-                    false\n+            }\n+            sym::stable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-            };\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n \n-            let meta_name = meta.name_or_empty();\n-            match meta_name {\n-                sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n-                    if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_default_body_unstable && body_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n+    if allowed_through_unstable_modules {\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n+        }\n+    }\n \n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    let mut issue_num = None;\n-                    let mut is_soft = false;\n-                    let mut implied_by = None;\n-                    for meta in metas {\n-                        let Some(mi) = meta.meta_item() else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n-                            );\n-                            continue 'outer;\n-                        };\n-                        match mi.name_or_empty() {\n-                            sym::feature => {\n-                                if !get(mi, &mut feature) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::reason => {\n-                                if !get(mi, &mut reason) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::issue => {\n-                                if !get(mi, &mut issue) {\n-                                    continue 'outer;\n-                                }\n+    stab\n+}\n \n-                                // These unwraps are safe because `get` ensures the meta item\n-                                // is a name/value pair string literal.\n-                                issue_num = match issue.unwrap().as_str() {\n-                                    \"none\" => None,\n-                                    issue => match issue.parse::<NonZeroU32>() {\n-                                        Ok(num) => Some(num),\n-                                        Err(err) => {\n-                                            sess.emit_err(\n-                                                session_diagnostics::InvalidIssueString {\n-                                                    span: mi.span,\n-                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n-                                                        mi.name_value_literal_span().unwrap(),\n-                                                        err.kind(),\n-                                                    ),\n-                                                },\n-                                            );\n-                                            continue 'outer;\n-                                        }\n-                                    },\n-                                };\n-                            }\n-                            sym::soft => {\n-                                if !mi.is_word() {\n-                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n-                                        span: mi.span,\n-                                    });\n-                                }\n-                                is_soft = true;\n-                            }\n-                            sym::implied_by => {\n-                                if !get(mi, &mut implied_by) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            _ => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    meta.span(),\n-                                    AttrError::UnknownMetaItem(\n-                                        pprust::path_to_string(&mi.path),\n-                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n+/// Collects stability info from `rustc_const_stable`/`rustc_const_unstable`/`rustc_promotable`\n+/// attributes in `attrs`.  Returns `None` if no stability attributes are found.\n+pub fn find_const_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    item_sp: Span,\n+) -> Option<(ConstStability, Span)> {\n+    let mut const_stab: Option<(ConstStability, Span)> = None;\n+    let mut promotable = false;\n \n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(_)) => {\n-                            if !rustc_lexer::is_ident(feature.as_str()) {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    attr.span,\n-                                    AttrError::NonIdentFeature,\n-                                );\n-                                continue;\n-                            }\n-                            let level = Unstable {\n-                                reason: UnstableReason::from_opt_reason(reason),\n-                                issue: issue_num,\n-                                is_soft,\n-                                implied_by,\n-                            };\n-                            if sym::unstable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else if sym::rustc_const_unstable == meta_name {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            } else if sym::rustc_default_body_unstable == meta_name {\n-                                body_stab =\n-                                    Some((DefaultBodyStability { level, feature }, attr.span));\n-                            } else {\n-                                unreachable!(\"Unknown stability attribute {meta_name}\");\n-                            }\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n-                            continue;\n-                        }\n-                    }\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_promotable => promotable = true,\n+            sym::rustc_const_unstable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-                sym::rustc_const_stable | sym::stable => {\n-                    if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        match meta {\n-                            NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                sym::since => {\n-                                    if !get(mi, &mut since) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"since\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n-                                }\n-                            },\n-                            NestedMetaItem::Lit(lit) => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    lit.span,\n-                                    AttrError::UnsupportedLiteral(\n-                                        UnsupportedLiteralReason::Generic,\n-                                        false,\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                        since = Some(rust_version_symbol());\n-                    }\n \n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            let level = Stable { since, allowed_through_unstable_modules: false };\n-                            if sym::stable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            }\n-                        }\n-                        (None, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n-                            continue;\n-                        }\n-                    }\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n+                }\n+            }\n+            sym::rustc_const_stable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n                 }\n-                _ => unreachable!(),\n             }\n+            _ => {}\n         }\n     }\n \n@@ -538,26 +326,241 @@ where\n         }\n     }\n \n-    if allowed_through_unstable_modules {\n-        match &mut stab {\n-            Some((\n-                Stability {\n-                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n-                    ..\n-                },\n-                _,\n-            )) => *allowed_through_unstable_modules = true,\n+    const_stab\n+}\n+\n+/// Collects stability info from `rustc_default_body_unstable` attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_body_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+) -> Option<(DefaultBodyStability, Span)> {\n+    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n+\n+    for attr in attrs {\n+        if attr.has_name(sym::rustc_default_body_unstable) {\n+            if body_stab.is_some() {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                break;\n+            }\n+\n+            if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n+            }\n+        }\n+    }\n+\n+    body_stab\n+}\n+\n+/// Read the content of a `stable`/`rustc_const_stable` attribute, and return the feature name and\n+/// its stability information.\n+fn parse_stability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut since = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::since => {\n+                if !insert_or_error(mi, &mut since) {\n+                    return None;\n+                }\n+            }\n             _ => {\n-                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"since\"],\n+                    ),\n+                );\n+                return None;\n             }\n         }\n     }\n \n-    (stab, const_stab, body_stab)\n+    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n+        since = Some(rust_version_symbol());\n+    }\n+\n+    match (feature, since) {\n+        (Some(feature), Some(since)) => {\n+            let level = StabilityLevel::Stable { since, allowed_through_unstable_modules: false };\n+            Some((feature, level))\n+        }\n+        (None, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            None\n+        }\n+        _ => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+            None\n+        }\n+    }\n+}\n+\n+/// Read the content of a `unstable`/`rustc_const_unstable`/`rustc_default_body_unstable`\n+/// attribute, and return the feature name and its stability information.\n+fn parse_unstability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut reason = None;\n+    let mut issue = None;\n+    let mut issue_num = None;\n+    let mut is_soft = false;\n+    let mut implied_by = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::reason => {\n+                if !insert_or_error(mi, &mut reason) {\n+                    return None;\n+                }\n+            }\n+            sym::issue => {\n+                if !insert_or_error(mi, &mut issue) {\n+                    return None;\n+                }\n+\n+                // These unwraps are safe because `insert_or_error` ensures the meta item\n+                // is a name/value pair string literal.\n+                issue_num = match issue.unwrap().as_str() {\n+                    \"none\" => None,\n+                    issue => match issue.parse::<NonZeroU32>() {\n+                        Ok(num) => Some(num),\n+                        Err(err) => {\n+                            sess.emit_err(\n+                                session_diagnostics::InvalidIssueString {\n+                                    span: mi.span,\n+                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                        mi.name_value_literal_span().unwrap(),\n+                                        err.kind(),\n+                                    ),\n+                                },\n+                            );\n+                            return None;\n+                        }\n+                    },\n+                };\n+            }\n+            sym::soft => {\n+                if !mi.is_word() {\n+                    sess.emit_err(session_diagnostics::SoftNoArgs { span: mi.span });\n+                }\n+                is_soft = true;\n+            }\n+            sym::implied_by => {\n+                if !insert_or_error(mi, &mut implied_by) {\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"reason\", \"issue\", \"soft\", \"implied_by\"],\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+    }\n+\n+    match (feature, reason, issue) {\n+        (Some(feature), reason, Some(_)) => {\n+            if !rustc_lexer::is_ident(feature.as_str()) {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::NonIdentFeature);\n+                return None;\n+            }\n+            let level = StabilityLevel::Unstable {\n+                reason: UnstableReason::from_opt_reason(reason),\n+                issue: issue_num,\n+                is_soft,\n+                implied_by,\n+            };\n+            Some((feature, level))\n+        }\n+        (None, _, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            return None;\n+        }\n+        _ => {\n+            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n+            return None;\n+        }\n+    }\n }\n \n-pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n #[derive(Clone, Debug)]\n@@ -1177,7 +1180,7 @@ fn allow_unstable<'a>(\n     attrs: &'a [Attribute],\n     symbol: Symbol,\n ) -> impl Iterator<Item = Symbol> + 'a {\n-    let attrs = sess.filter_by_name(attrs, symbol);\n+    let attrs = attr::filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {"}, {"sha": "49818c14f275b2284759289072caf2fc95a70c27", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -26,4 +26,4 @@ pub use rustc_ast::attr::*;\n \n pub(crate) use rustc_ast::HashStableContext;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }"}, {"sha": "a3b6b5e8138b68ed2e84b37abad09be4ef2577ac", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_borrowck/locales/en-US.ftl"}, {"sha": "fa0552e012de1f430a87c060a13a0136ca217f79", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -4,7 +4,7 @@ use crate::nll::ToRegionVid;\n use crate::path_utils::allow_two_phase_borrow;\n use crate::place_ext::PlaceExt;\n use crate::BorrowIndex;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonUseContext, PlaceContext, Visitor};\n@@ -26,10 +26,10 @@ pub struct BorrowSet<'tcx> {\n     /// NOTE: a given location may activate more than one borrow in the future\n     /// when more general two-phase borrow support is introduced, but for now we\n     /// only need to store one borrow index.\n-    pub activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n+    pub activation_map: FxIndexMap<Location, Vec<BorrowIndex>>,\n \n     /// Map from local to all the borrows on that local.\n-    pub local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+    pub local_map: FxIndexMap<mir::Local, FxIndexSet<BorrowIndex>>,\n \n     pub(crate) locals_state_at_exit: LocalsStateAtExit,\n }\n@@ -175,8 +175,8 @@ struct GatherBorrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n     location_map: FxIndexMap<Location, BorrowData<'tcx>>,\n-    activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n-    local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n+    activation_map: FxIndexMap<Location, Vec<BorrowIndex>>,\n+    local_map: FxIndexMap<mir::Local, FxIndexSet<BorrowIndex>>,\n \n     /// When we encounter a 2-phase borrow statement, it will always\n     /// be assigning into a temporary TEMP:\n@@ -186,7 +186,7 @@ struct GatherBorrows<'a, 'tcx> {\n     /// We add TEMP into this map with `b`, where `b` is the index of\n     /// the borrow. When we find a later use of this activation, we\n     /// remove from the map (and add to the \"tombstone\" set below).\n-    pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n+    pending_activations: FxIndexMap<mir::Local, BorrowIndex>,\n \n     locals_state_at_exit: LocalsStateAtExit,\n }"}, {"sha": "2cbd2e3bc0d86547ba9834ffcc1a439c9f424cdd", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::{self, BasicBlock, Body, Location, Place};\n use rustc_middle::ty::RegionVid;\n@@ -124,7 +124,7 @@ pub struct Borrows<'a, 'tcx> {\n     body: &'a Body<'tcx>,\n \n     borrow_set: &'a BorrowSet<'tcx>,\n-    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n+    borrows_out_of_scope_at_location: FxIndexMap<Location, Vec<BorrowIndex>>,\n }\n \n struct StackEntry {\n@@ -138,7 +138,7 @@ struct OutOfScopePrecomputer<'a, 'tcx> {\n     visit_stack: Vec<StackEntry>,\n     body: &'a Body<'tcx>,\n     regioncx: &'a RegionInferenceContext<'tcx>,\n-    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n+    borrows_out_of_scope_at_location: FxIndexMap<Location, Vec<BorrowIndex>>,\n }\n \n impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n             visit_stack: vec![],\n             body,\n             regioncx,\n-            borrows_out_of_scope_at_location: FxHashMap::default(),\n+            borrows_out_of_scope_at_location: FxIndexMap::default(),\n         }\n     }\n }\n@@ -306,7 +306,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         }\n \n         // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n-        // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+        // pair of array indices are not equal, so that when `places_conflict` returns true, we\n         // will be assured that two places being compared definitely denotes the same sets of\n         // locations.\n         let definitely_conflicting_borrows = other_borrows_of_local.filter(|&i| {\n@@ -390,6 +390,7 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n             | mir::StatementKind::Deinit(..)\n             | mir::StatementKind::StorageLive(..)\n             | mir::StatementKind::Retag { .. }\n+            | mir::StatementKind::PlaceMention(..)\n             | mir::StatementKind::AscribeUserType(..)\n             | mir::StatementKind::Coverage(..)\n             | mir::StatementKind::Intrinsic(..)"}, {"sha": "9e9f0b4b4ad0aa1e7181f5c6dd530c02a0e8d542", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -72,6 +72,8 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         PlaceContext::MutatingUse(MutatingUseContext::Drop) =>\n             Some(DefUse::Drop),\n \n+        // This statement exists to help unsafeck. It does not require the place to be live.\n+        PlaceContext::NonUse(NonUseContext::PlaceMention) => None,\n         // Debug info is neither def nor use.\n         PlaceContext::NonUse(NonUseContext::VarDebugInfo) => None,\n "}, {"sha": "75a3dd0c0f3d6f953b157b8a0fceabe1deb8ab7c", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,12 +1,12 @@\n use either::Either;\n use rustc_const_eval::util::CallKind;\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n@@ -24,6 +24,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -173,7 +174,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             let mut is_loop_move = false;\n             let mut in_pattern = false;\n-            let mut seen_spans = FxHashSet::default();\n+            let mut seen_spans = FxIndexSet::default();\n \n             for move_site in &move_site_vec {\n                 let move_out = self.move_data.moves[(*move_site).moi];\n@@ -236,10 +237,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let ty = used_place.ty(self.body, self.infcx.tcx).ty;\n             let needs_note = match ty.kind() {\n                 ty::Closure(id, _) => {\n-                    let tables = self.infcx.tcx.typeck(id.expect_local());\n-                    let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(id.expect_local());\n-\n-                    tables.closure_kind_origins().get(hir_id).is_none()\n+                    self.infcx.tcx.closure_kind_origin(id.expect_local()).is_none()\n                 }\n                 _ => true,\n             };\n@@ -763,20 +761,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let copy_did = infcx.tcx.require_lang_item(LangItem::Copy, Some(span));\n-        let cause = ObligationCause::new(\n-            span,\n-            self.mir_def_id(),\n-            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-        );\n-        let errors = rustc_trait_selection::traits::fully_solve_bound(\n-            &infcx,\n-            cause,\n-            self.param_env,\n-            // Erase any region vids from the type, which may not be resolved\n-            infcx.tcx.erase_regions(ty),\n-            copy_did,\n-        );\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let copy_did = tcx.require_lang_item(LangItem::Copy, Some(span));\n+        let cause = ObligationCause::misc(span, self.mir_def_id());\n+\n+        ocx.register_bound(cause, self.param_env, infcx.tcx.erase_regions(ty), copy_did);\n+        let errors = ocx.select_all_or_error();\n \n         // Only emit suggestion if all required predicates are on generic\n         let predicates: Result<Vec<_>, _> = errors\n@@ -1470,6 +1460,32 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Reports StorageDeadOrDrop of `place` conflicts with `borrow`.\n     ///\n+    /// Depending on the origin of the StorageDeadOrDrop, this may be\n+    /// reported as either a drop or an illegal mutation of a borrowed value.\n+    /// The latter is preferred when the this is a drop triggered by a\n+    /// reassignment, as it's more user friendly to report a problem with the\n+    /// explicit assignment than the implicit drop.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(crate) fn report_storage_dead_or_drop_of_borrowed(\n+        &mut self,\n+        location: Location,\n+        place_span: (Place<'tcx>, Span),\n+        borrow: &BorrowData<'tcx>,\n+    ) {\n+        // It's sufficient to check the last desugaring as Replace is the last\n+        // one to be applied.\n+        if let Some(DesugaringKind::Replace) = place_span.1.desugaring_kind() {\n+            self.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n+        } else {\n+            self.report_borrowed_value_does_not_live_long_enough(\n+                location,\n+                borrow,\n+                place_span,\n+                Some(WriteKind::StorageDeadOrDrop),\n+            )\n+        }\n+    }\n+\n     /// This means that some data referenced by `borrow` needs to live\n     /// past the point where the StorageDeadOrDrop of `place` occurs.\n     /// This is usually interpreted as meaning that `place` has too\n@@ -1494,7 +1510,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assert!(root_place.projection.is_empty());\n         let proper_span = self.body.local_decls[root_place.local].source_info.span;\n \n-        let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n+        let root_place_projection = self.infcx.tcx.mk_place_elems(root_place.projection);\n \n         if self.access_place_error_reported.contains(&(\n             Place { local: root_place.local, projection: root_place_projection },\n@@ -1670,27 +1686,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            let fn_hir_id = self.mir_hir_id();\n             err.span_label(\n                 drop_span,\n                 format!(\n                     \"...but `{}` will be dropped here, when the {} returns\",\n                     name,\n                     self.infcx\n                         .tcx\n-                        .hir()\n-                        .opt_name(fn_hir_id)\n+                        .opt_item_name(self.mir_def_id().to_def_id())\n                         .map(|name| format!(\"function `{}`\", name))\n                         .unwrap_or_else(|| {\n-                            match &self\n-                                .infcx\n-                                .tcx\n-                                .typeck(self.mir_def_id())\n-                                .node_type(fn_hir_id)\n-                                .kind()\n-                            {\n-                                ty::Closure(..) => \"enclosing closure\",\n-                                ty::Generator(..) => \"enclosing generator\",\n+                            match &self.infcx.tcx.def_kind(self.mir_def_id()) {\n+                                DefKind::Closure => \"enclosing closure\",\n+                                DefKind::Generator => \"enclosing generator\",\n                                 kind => bug!(\"expected closure or generator, found {:?}\", kind),\n                             }\n                             .to_string()\n@@ -1970,16 +1978,18 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n                 match self.body.local_kind(local) {\n-                    LocalKind::ReturnPointer | LocalKind::Temp => {\n-                        bug!(\"temporary or return pointer with a name\")\n+                    LocalKind::Temp if self.body.local_decls[local].is_user_variable() => {\n+                        \"local variable \"\n                     }\n-                    LocalKind::Var => \"local variable \",\n                     LocalKind::Arg\n                         if !self.upvars.is_empty() && local == ty::CAPTURE_STRUCT_LOCAL =>\n                     {\n                         \"variable captured by `move` \"\n                     }\n                     LocalKind::Arg => \"function parameter \",\n+                    LocalKind::ReturnPointer | LocalKind::Temp => {\n+                        bug!(\"temporary or return pointer with a name\")\n+                    }\n                 }\n             } else {\n                 \"local data \"\n@@ -1993,16 +2003,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 self.prefixes(borrow.borrowed_place.as_ref(), PrefixSet::All).last().unwrap();\n             let local = root_place.local;\n             match self.body.local_kind(local) {\n-                LocalKind::ReturnPointer | LocalKind::Temp => {\n-                    (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n-                }\n                 LocalKind::Arg => (\n                     \"function parameter\".to_string(),\n                     \"function parameter borrowed here\".to_string(),\n                 ),\n-                LocalKind::Var => {\n+                LocalKind::Temp if self.body.local_decls[local].is_user_variable() => {\n                     (\"local binding\".to_string(), \"local binding introduced here\".to_string())\n                 }\n+                LocalKind::ReturnPointer | LocalKind::Temp => {\n+                    (\"temporary value\".to_string(), \"temporary value created here\".to_string())\n+                }\n             }\n         };\n \n@@ -2208,8 +2218,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n         }\n \n-        let mut visited = FxHashSet::default();\n-        let mut move_locations = FxHashSet::default();\n+        let mut visited = FxIndexSet::default();\n+        let mut move_locations = FxIndexSet::default();\n         let mut reinits = vec![];\n         let mut result = vec![];\n \n@@ -2336,7 +2346,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let reinits_reachable = reinits\n             .into_iter()\n             .filter(|reinit| {\n-                let mut visited = FxHashSet::default();\n+                let mut visited = FxIndexSet::default();\n                 let mut stack = vec![*reinit];\n                 while let Some(location) = stack.pop() {\n                     if !visited.insert(location) {\n@@ -2467,15 +2477,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let (place_description, assigned_span) = match local_decl {\n             Some(LocalDecl {\n                 local_info:\n-                    Some(box LocalInfo::User(\n-                        ClearCrossCrate::Clear\n-                        | ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    ClearCrossCrate::Set(\n+                        box LocalInfo::User(BindingForm::Var(VarBindingForm {\n                             opt_match_place: None,\n                             ..\n-                        })),\n-                    ))\n-                    | Some(box LocalInfo::StaticRef { .. })\n-                    | None,\n+                        }))\n+                        | box LocalInfo::StaticRef { .. }\n+                        | box LocalInfo::Boring,\n+                    ),\n                 ..\n             })\n             | None => (self.describe_any_place(place.as_ref()), assigned_span),"}, {"sha": "62b3f3ecfc32f21cbee976fac14a6e5eedd71fb4", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -6,8 +6,8 @@ use rustc_hir::intravisit::Visitor;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n-    Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n-    Statement, StatementKind, TerminatorKind,\n+    Body, CastKind, ConstraintCategory, FakeReadCause, Local, LocalInfo, Location, Operand, Place,\n+    Rvalue, Statement, StatementKind, TerminatorKind,\n };\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n@@ -220,7 +220,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                         );\n                         err.span_label(body.source_info(drop_loc).span, message);\n \n-                        if let Some(info) = &local_decl.is_block_tail {\n+                        if let LocalInfo::BlockTailTemp(info) = local_decl.local_info() {\n                             if info.tail_result_is_ignored {\n                                 // #85581: If the first mutable borrow's scope contains\n                                 // the second borrow, this suggestion isn't helpful."}, {"sha": "fd1fda2ee4bd2deb3236c373e584083bf053aed2", "filename": "compiler/rustc_borrowck/src/diagnostics/find_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Ffind_use.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -9,7 +9,7 @@ use crate::{\n     nll::ToRegionVid,\n     region_infer::{Cause, RegionInferenceContext},\n };\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::mir::visit::{MirVisitable, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n@@ -37,7 +37,7 @@ struct UseFinder<'cx, 'tcx> {\n impl<'cx, 'tcx> UseFinder<'cx, 'tcx> {\n     fn find(&mut self) -> Option<Cause> {\n         let mut queue = VecDeque::new();\n-        let mut visited = FxHashSet::default();\n+        let mut visited = FxIndexSet::default();\n \n         queue.push_back(self.start_point);\n         while let Some(p) = queue.pop_front() {"}, {"sha": "9f543b71c5fa4098c406e3b1fcfc3832e70d3524", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n     Place, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n-use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n@@ -115,11 +115,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                     if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind() {\n                         let did = did.expect_local();\n-                        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n-\n-                        if let Some((span, hir_place)) =\n-                            self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                        {\n+                        if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n                             diag.span_note(\n                                 *span,\n                                 &format!(\n@@ -139,11 +135,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind() {\n                 let did = did.expect_local();\n-                let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n-\n-                if let Some((span, hir_place)) =\n-                    self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n-                {\n+                if let Some((span, hir_place)) = self.infcx.tcx.closure_kind_origin(did) {\n                     diag.span_note(\n                         *span,\n                         &format!(\n@@ -204,10 +196,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         if self.body.local_decls[local].is_ref_for_guard() {\n                             continue;\n                         }\n-                        if let Some(box LocalInfo::StaticRef { def_id, .. }) =\n-                            &self.body.local_decls[local].local_info\n+                        if let LocalInfo::StaticRef { def_id, .. } =\n+                            *self.body.local_decls[local].local_info()\n                         {\n-                            buf.push_str(self.infcx.tcx.item_name(*def_id).as_str());\n+                            buf.push_str(self.infcx.tcx.item_name(def_id).as_str());\n                             ok = Ok(());\n                             continue;\n                         }\n@@ -373,14 +365,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     //\n                     // We know the field exists so it's safe to call operator[] and `unwrap` here.\n                     let def_id = def_id.expect_local();\n-                    let var_id = self\n-                        .infcx\n-                        .tcx\n-                        .typeck(def_id)\n-                        .closure_min_captures_flattened(def_id)\n-                        .nth(field.index())\n-                        .unwrap()\n-                        .get_root_variable();\n+                    let var_id =\n+                        self.infcx.tcx.closure_captures(def_id)[field.index()].get_root_variable();\n \n                     Some(self.infcx.tcx.hir().name(var_id).to_string())\n                 }\n@@ -939,7 +925,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             return OtherUse(use_span);\n         }\n \n-        for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n+        // drop and replace might have moved the assignment to the next block\n+        let maybe_additional_statement =\n+            if let TerminatorKind::Drop { target: drop_target, .. } =\n+                self.body[location.block].terminator().kind\n+            {\n+                self.body[drop_target].statements.first()\n+            } else {\n+                None\n+            };\n+\n+        let statements =\n+            self.body[location.block].statements[location.statement_index + 1..].iter();\n+\n+        for stmt in statements.chain(maybe_additional_statement) {\n             if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind {\n                 let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n@@ -987,7 +986,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(&hir::Closure { body, fn_decl_span, .. }) = expr {\n             for (captured_place, place) in\n-                self.infcx.tcx.typeck(def_id).closure_min_captures_flattened(def_id).zip(places)\n+                self.infcx.tcx.closure_captures(def_id).iter().zip(places)\n             {\n                 match place {\n                     Operand::Copy(place) | Operand::Move(place)\n@@ -1079,7 +1078,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     self.param_env,\n                                     tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.erase_regions(ty)),\n                                     def_id,\n-                                    DUMMY_SP,\n                                 )\n                             }\n                             _ => false,"}, {"sha": "3662bec0c76360cc9be71fb33f5f0e34f4c4d97c", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -102,14 +102,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         //\n                         // opt_match_place is None for let [mut] x = ... statements,\n                         // whether or not the right-hand side is a place expression\n-                        if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                            VarBindingForm {\n-                                opt_match_place: Some((opt_match_place, match_span)),\n-                                binding_mode: _,\n-                                opt_ty_info: _,\n-                                pat_span: _,\n-                            },\n-                        )))) = local_decl.local_info\n+                        if let LocalInfo::User(BindingForm::Var(VarBindingForm {\n+                            opt_match_place: Some((opt_match_place, match_span)),\n+                            binding_mode: _,\n+                            opt_ty_info: _,\n+                            pat_span: _,\n+                        })) = *local_decl.local_info()\n                         {\n                             let stmt_source_info = self.body.source_info(location);\n                             self.append_binding_error(\n@@ -467,7 +465,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_suggestion_verbose(\n                     span.shrink_to_lo(),\n                     \"consider borrowing here\",\n-                    \"&\".to_string(),\n+                    '&',\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n@@ -478,9 +476,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut suggestions: Vec<(Span, String, String)> = Vec::new();\n         for local in binds_to {\n             let bind_to = &self.body.local_decls[*local];\n-            if let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                VarBindingForm { pat_span, .. },\n-            )))) = bind_to.local_info\n+            if let LocalInfo::User(BindingForm::Var(VarBindingForm { pat_span, .. })) =\n+                *bind_to.local_info()\n             {\n                 let Ok(pat_snippet) =\n                     self.infcx.tcx.sess.source_map().span_to_snippet(pat_span) else { continue; };"}, {"sha": "a8c216407f931c01169d2b4204d386afd42c3d92", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 51, "deletions": 69, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::{\n     hir::place::PlaceBase,\n-    mir::{self, BindingForm, ClearCrossCrate, Local, LocalDecl, LocalInfo, LocalKind, Location},\n+    mir::{self, BindingForm, Local, LocalDecl, LocalInfo, LocalKind, Location},\n };\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n@@ -105,8 +105,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     reason = String::new();\n                 } else {\n                     item_msg = access_place_desc;\n-                    let local_info = &self.body.local_decls[local].local_info;\n-                    if let Some(box LocalInfo::StaticRef { def_id, .. }) = *local_info {\n+                    let local_info = self.body.local_decls[local].local_info();\n+                    if let LocalInfo::StaticRef { def_id, .. } = *local_info {\n                         let static_name = &self.infcx.tcx.item_name(def_id);\n                         reason = format!(\", as `{static_name}` is an immutable static item\");\n                     } else {\n@@ -120,9 +120,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     && !self.upvars.is_empty()\n                 {\n                     item_msg = access_place_desc;\n-                    debug_assert!(\n-                        self.body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty.is_region_ptr()\n-                    );\n+                    debug_assert!(self.body.local_decls[ty::CAPTURE_STRUCT_LOCAL].ty.is_ref());\n                     debug_assert!(is_closure_or_generator(\n                         Place::ty_from(\n                             the_place_err.local,\n@@ -305,15 +303,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     ..\n                 }) = &self.body[location.block].statements.get(location.statement_index)\n                 {\n-                    match decl.local_info {\n-                        Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                            mir::VarBindingForm {\n-                                binding_mode: ty::BindingMode::BindByValue(Mutability::Not),\n-                                opt_ty_info: Some(sp),\n-                                opt_match_place: _,\n-                                pat_span: _,\n-                            },\n-                        )))) => {\n+                    match *decl.local_info() {\n+                        LocalInfo::User(BindingForm::Var(mir::VarBindingForm {\n+                            binding_mode: ty::BindingMode::BindByValue(Mutability::Not),\n+                            opt_ty_info: Some(sp),\n+                            opt_match_place: _,\n+                            pat_span: _,\n+                        })) => {\n                             if suggest {\n                                 err.span_note(sp, \"the binding is already a mutable borrow\");\n                             }\n@@ -346,10 +342,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 } else if decl.mutability.is_not() {\n                     if matches!(\n-                        decl.local_info,\n-                        Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf(\n-                            hir::ImplicitSelfKind::MutRef\n-                        ),)))\n+                        decl.local_info(),\n+                        LocalInfo::User(BindingForm::ImplicitSelf(hir::ImplicitSelfKind::MutRef))\n                     ) {\n                         err.note(\n                             \"as `Self` may be unsized, this call attempts to take `&mut &mut self`\",\n@@ -385,7 +379,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     err.span_suggestion_verbose(\n                         local_decl.source_info.span.shrink_to_lo(),\n                         \"consider changing this to be mutable\",\n-                        \"mut \".to_string(),\n+                        \"mut \",\n                         Applicability::MachineApplicable,\n                     );\n                     let tcx = self.infcx.tcx;\n@@ -474,30 +468,23 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 let local_decl = &self.body.local_decls[local];\n \n-                let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {\n-                    (\"&\", \"reference\")\n-                } else {\n-                    (\"*const\", \"pointer\")\n-                };\n+                let (pointer_sigil, pointer_desc) =\n+                    if local_decl.ty.is_ref() { (\"&\", \"reference\") } else { (\"*const\", \"pointer\") };\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let label = match local_decl.local_info.as_deref().unwrap() {\n-                            LocalInfo::User(ClearCrossCrate::Set(\n-                                mir::BindingForm::ImplicitSelf(_),\n-                            )) => {\n+                        let label = match *local_decl.local_info() {\n+                            LocalInfo::User(mir::BindingForm::ImplicitSelf(_)) => {\n                                 let (span, suggestion) =\n                                     suggest_ampmut_self(self.infcx.tcx, local_decl);\n                                 Some((true, span, suggestion))\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n-                                mir::VarBindingForm {\n-                                    binding_mode: ty::BindingMode::BindByValue(_),\n-                                    opt_ty_info,\n-                                    ..\n-                                },\n-                            ))) => {\n+                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                binding_mode: ty::BindingMode::BindByValue(_),\n+                                opt_ty_info,\n+                                ..\n+                            })) => {\n                                 // check if the RHS is from desugaring\n                                 let opt_assignment_rhs_span =\n                                     self.body.find_assignments(local).first().map(|&location| {\n@@ -534,16 +521,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                 self.infcx.tcx,\n                                                 local_decl,\n                                                 opt_assignment_rhs_span,\n-                                                *opt_ty_info,\n+                                                opt_ty_info,\n                                             )\n                                         } else {\n-                                            match local_decl.local_info.as_deref() {\n-                                                Some(LocalInfo::User(ClearCrossCrate::Set(\n-                                                    mir::BindingForm::Var(mir::VarBindingForm {\n-                                                        opt_ty_info: None,\n-                                                        ..\n-                                                    }),\n-                                                ))) => {\n+                                            match local_decl.local_info() {\n+                                                LocalInfo::User(mir::BindingForm::Var(\n+                                                    mir::VarBindingForm {\n+                                                        opt_ty_info: None, ..\n+                                                    },\n+                                                )) => {\n                                                     let (span, sugg) = suggest_ampmut_self(\n                                                         self.infcx.tcx,\n                                                         local_decl,\n@@ -555,7 +541,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                                     self.infcx.tcx,\n                                                     local_decl,\n                                                     opt_assignment_rhs_span,\n-                                                    *opt_ty_info,\n+                                                    opt_ty_info,\n                                                 ),\n                                             }\n                                         };\n@@ -564,21 +550,15 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 }\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n-                                mir::VarBindingForm {\n-                                    binding_mode: ty::BindingMode::BindByReference(_),\n-                                    ..\n-                                },\n-                            ))) => {\n+                            LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+                                binding_mode: ty::BindingMode::BindByReference(_),\n+                                ..\n+                            })) => {\n                                 let pattern_span = local_decl.source_info.span;\n                                 suggest_ref_mut(self.infcx.tcx, pattern_span)\n                                     .map(|replacement| (true, pattern_span, replacement))\n                             }\n \n-                            LocalInfo::User(ClearCrossCrate::Clear) => {\n-                                bug!(\"saw cleared local state\")\n-                            }\n-\n                             _ => unreachable!(),\n                         };\n \n@@ -828,7 +808,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let Some(hir::Node::Item(item)) = node else { return; };\n             let hir::ItemKind::Fn(.., body_id) = item.kind else { return; };\n             let body = self.infcx.tcx.hir().body(body_id);\n-            let mut v = V { assign_span: span, err, ty, suggested: false };\n+            let mut assign_span = span;\n+            // Drop desugaring is done at MIR build so it's not in the HIR\n+            if let Some(DesugaringKind::Replace) = span.desugaring_kind() {\n+                assign_span.remove_mark();\n+            }\n+\n+            let mut v = V { assign_span, err, ty, suggested: false };\n             v.visit_body(body);\n             if !v.suggested {\n                 err.help(&format!(\n@@ -901,10 +887,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n     ) {\n         let tables = tcx.typeck(closure_local_def_id);\n-        let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_local_def_id);\n-        if let Some((span, closure_kind_origin)) =\n-            &tables.closure_kind_origins().get(closure_hir_id)\n-        {\n+        if let Some((span, closure_kind_origin)) = tcx.closure_kind_origin(closure_local_def_id) {\n             let reason = if let PlaceBase::Upvar(upvar_id) = closure_kind_origin.base {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;\n@@ -1148,20 +1131,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n pub fn mut_borrow_of_mutable_ref(local_decl: &LocalDecl<'_>, local_name: Option<Symbol>) -> bool {\n     debug!(\"local_info: {:?}, ty.kind(): {:?}\", local_decl.local_info, local_decl.ty.kind());\n \n-    match local_decl.local_info.as_deref() {\n+    match *local_decl.local_info() {\n         // Check if mutably borrowing a mutable reference.\n-        Some(LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n-            mir::VarBindingForm {\n-                binding_mode: ty::BindingMode::BindByValue(Mutability::Not), ..\n-            },\n-        )))) => matches!(local_decl.ty.kind(), ty::Ref(_, _, hir::Mutability::Mut)),\n-        Some(LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf(kind)))) => {\n+        LocalInfo::User(mir::BindingForm::Var(mir::VarBindingForm {\n+            binding_mode: ty::BindingMode::BindByValue(Mutability::Not),\n+            ..\n+        })) => matches!(local_decl.ty.kind(), ty::Ref(_, _, hir::Mutability::Mut)),\n+        LocalInfo::User(mir::BindingForm::ImplicitSelf(kind)) => {\n             // Check if the user variable is a `&mut self` and we can therefore\n             // suggest removing the `&mut`.\n             //\n             // Deliberately fall into this case for all implicit self types,\n             // so that we don't fall in to the next case with them.\n-            *kind == hir::ImplicitSelfKind::MutRef\n+            kind == hir::ImplicitSelfKind::MutRef\n         }\n         _ if Some(kw::SelfLower) == local_name => {\n             // Otherwise, check if the name is the `self` keyword - in which case\n@@ -1271,7 +1253,7 @@ fn suggest_ampmut<'tcx>(\n     (\n         suggestability,\n         highlight_span,\n-        if local_decl.ty.is_region_ptr() {\n+        if local_decl.ty.is_ref() {\n             format!(\"&mut {}\", ty_mut.ty)\n         } else {\n             format!(\"*mut {}\", ty_mut.ty)"}, {"sha": "d5ece57437e0b7cde8eaf4f7e4c8dfd57dcc9c68", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,7 +1,7 @@\n //! Contains utilities for generating suggestions for borrowck errors related to unsatisfied\n //! outlives constraints.\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_middle::ty::RegionVid;\n use smallvec::SmallVec;\n@@ -87,7 +87,7 @@ impl OutlivesSuggestionBuilder {\n \n         // Keep track of variables that we have already suggested unifying so that we don't print\n         // out silly duplicate messages.\n-        let mut unified_already = FxHashSet::default();\n+        let mut unified_already = FxIndexSet::default();\n \n         for (fr, outlived) in &self.constraints_to_add {\n             let Some(fr_name) = self.region_vid_to_name(mbcx, *fr) else {"}, {"sha": "ffe82b46cfd678ae4fa1921b821a180f135d54d1", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -415,7 +415,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     ///\n-    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = 'b`.\n     pub(crate) fn report_region_error(\n         &mut self,\n         fr: RegionVid,\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n                 multi_span.push_span_label(\n                     ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n+                    \"calling this method introduces the `impl`'s `'static` requirement\",\n                 );\n                 err.subdiagnostic(RequireStaticErr::UsedImpl { multi_span });\n                 err.span_suggestion_verbose("}, {"sha": "cc5a1f5ab122d4af2e21699e1cdec868ca7ba5b7", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -6,7 +6,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_middle::ty::print::RegionHighlightMode;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, DefIdTree, RegionVid, Ty};\n+use rustc_middle::ty::{self, RegionVid, Ty};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n "}, {"sha": "a71c416328611be7def787a2ea980adabde31e3b", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -79,6 +79,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             // Only relevant for mir typeck\n             StatementKind::AscribeUserType(..)\n+            // Only relevant for unsafeck\n+            | StatementKind::PlaceMention(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n             // Does not actually affect borrowck\n@@ -118,15 +120,6 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                     LocalMutationIsAllowed::Yes,\n                 );\n             }\n-            TerminatorKind::DropAndReplace {\n-                place: drop_place,\n-                value: new_value,\n-                target: _,\n-                unwind: _,\n-            } => {\n-                self.mutate_place(location, *drop_place, Deep);\n-                self.consume_operand(location, new_value);\n-            }\n             TerminatorKind::Call {\n                 func,\n                 args,"}, {"sha": "b7ce3afce7bb2712b3689db1152e07aa8b0aff00", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 24, "deletions": 49, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,5 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-#![allow(rustc::potential_query_instability)]\n #![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n@@ -18,9 +17,8 @@ extern crate rustc_middle;\n #[macro_use]\n extern crate tracing;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_data_structures::vec_map::VecMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -101,7 +99,7 @@ use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n use renumber::RegionCtxt;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n@@ -142,7 +140,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n         debug!(\"Skipping borrowck because of injected body\");\n         // Let's make up a borrowck result! Fun times!\n         let result = BorrowCheckResult {\n-            concrete_opaque_types: VecMap::new(),\n+            concrete_opaque_types: FxIndexMap::default(),\n             closure_requirements: None,\n             used_mut_upvars: SmallVec::new(),\n             tainted_by_errors: None,\n@@ -202,14 +200,14 @@ fn do_mir_borrowck<'tcx>(\n     let mut errors = error::BorrowckErrors::new(infcx.tcx);\n \n     // Gather the upvars of a closure, if any.\n-    let tables = tcx.typeck_opt_const_arg(def);\n-    if let Some(e) = tables.tainted_by_errors {\n+    if let Some(e) = input_body.tainted_by_errors {\n         infcx.set_tainted_by_errors(e);\n         errors.set_tainted_by_errors(e);\n     }\n-    let upvars: Vec<_> = tables\n-        .closure_min_captures_flattened(def.did)\n-        .map(|captured_place| {\n+    let upvars: Vec<_> = tcx\n+        .closure_captures(def.did)\n+        .iter()\n+        .map(|&captured_place| {\n             let capture = captured_place.info.capture_kind;\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -404,7 +402,7 @@ fn do_mir_borrowck<'tcx>(\n     // Note that this set is expected to be small - only upvars from closures\n     // would have a chance of erroneously adding non-user-defined mutable vars\n     // to the set.\n-    let temporary_used_locals: FxHashSet<Local> = mbcx\n+    let temporary_used_locals: FxIndexSet<Local> = mbcx\n         .used_mut\n         .iter()\n         .filter(|&local| !mbcx.body.local_decls[*local].is_user_variable())\n@@ -491,7 +489,7 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n \n pub struct BorrowckInferCtxt<'cx, 'tcx> {\n     pub(crate) infcx: &'cx InferCtxt<'tcx>,\n-    pub(crate) reg_var_to_origin: RefCell<FxHashMap<ty::RegionVid, RegionCtxt>>,\n+    pub(crate) reg_var_to_origin: RefCell<FxIndexMap<ty::RegionVid, RegionCtxt>>,\n }\n \n impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n@@ -512,16 +510,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n             .as_var()\n             .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(vid, ctxt);\n-\n-            // This only makes sense if not called in a canonicalization context. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(vid, ctxt);\n         }\n \n         next_region\n@@ -541,16 +534,11 @@ impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n             .as_var()\n             .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.inside_canonicalization_ctxt() {\n             debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n             let ctxt = get_ctxt_fn();\n             let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(vid, ctxt);\n-\n-            // This only makes sense if not called in a canonicalization context. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(vid, ctxt);\n         }\n \n         next_region\n@@ -588,25 +576,25 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// borrow errors that is handled by the `reservation_error_reported` field as the inclusion\n     /// of the `Span` type (while required to mute some errors) stops the muting of the reservation\n     /// errors.\n-    access_place_error_reported: FxHashSet<(Place<'tcx>, Span)>,\n+    access_place_error_reported: FxIndexSet<(Place<'tcx>, Span)>,\n     /// This field keeps track of when borrow conflict errors are reported\n     /// for reservations, so that we don't report seemingly duplicate\n     /// errors for corresponding activations.\n     //\n     // FIXME: ideally this would be a set of `BorrowIndex`, not `Place`s,\n     // but it is currently inconvenient to track down the `BorrowIndex`\n     // at the time we detect and report a reservation error.\n-    reservation_error_reported: FxHashSet<Place<'tcx>>,\n+    reservation_error_reported: FxIndexSet<Place<'tcx>>,\n     /// This fields keeps track of the `Span`s that we have\n     /// used to report extra information for `FnSelfUse`, to avoid\n     /// unnecessarily verbose errors.\n-    fn_self_span_reported: FxHashSet<Span>,\n+    fn_self_span_reported: FxIndexSet<Span>,\n     /// This field keeps track of errors reported in the checking of uninitialized variables,\n     /// so that we don't report seemingly duplicate errors.\n-    uninitialized_error_reported: FxHashSet<PlaceRef<'tcx>>,\n+    uninitialized_error_reported: FxIndexSet<PlaceRef<'tcx>>,\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n     /// Used for the warning issued by an unused mutable local variable.\n-    used_mut: FxHashSet<Local>,\n+    used_mut: FxIndexSet<Local>,\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n     used_mut_upvars: SmallVec<[Field; 8]>,\n@@ -628,7 +616,7 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Record the region names generated for each region in the given\n     /// MIR def so that we can reuse them later in help/error messages.\n-    region_names: RefCell<FxHashMap<RegionVid, RegionName>>,\n+    region_names: RefCell<FxIndexMap<RegionVid, RegionName>>,\n \n     /// The counter for generating new region names.\n     next_region_name: RefCell<usize>,\n@@ -691,6 +679,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             }\n             // Only relevant for mir typeck\n             StatementKind::AscribeUserType(..)\n+            // Only relevant for unsafeck\n+            | StatementKind::PlaceMention(..)\n             // Doesn't have any language semantics\n             | StatementKind::Coverage(..)\n             // These do not actually affect borrowck\n@@ -744,15 +734,6 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            TerminatorKind::DropAndReplace {\n-                place: drop_place,\n-                value: new_value,\n-                target: _,\n-                unwind: _,\n-            } => {\n-                self.mutate_place(loc, (*drop_place, span), Deep, flow_state);\n-                self.consume_operand(loc, (new_value, span), flow_state);\n-            }\n             TerminatorKind::Call {\n                 func,\n                 args,\n@@ -867,7 +848,6 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n             | TerminatorKind::Assert { .. }\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::Drop { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::FalseEdge { real_target: _, imaginary_target: _ }\n             | TerminatorKind::FalseUnwind { real_target: _, unwind: _ }\n             | TerminatorKind::Goto { .. }\n@@ -1185,12 +1165,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             this.buffer_error(err);\n                         }\n                         WriteKind::StorageDeadOrDrop => this\n-                            .report_borrowed_value_does_not_live_long_enough(\n-                                location,\n-                                borrow,\n-                                place_span,\n-                                Some(kind),\n-                            ),\n+                            .report_storage_dead_or_drop_of_borrowed(location, place_span, borrow),\n                         WriteKind::Mutate => {\n                             this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n                         }\n@@ -2334,7 +2309,7 @@ mod error {\n         /// same primary span come out in a consistent order.\n         buffered_move_errors:\n             BTreeMap<Vec<MoveOutIndex>, (PlaceRef<'tcx>, DiagnosticBuilder<'tcx, ErrorGuaranteed>)>,\n-        buffered_mut_errors: FxHashMap<Span, (DiagnosticBuilder<'tcx, ErrorGuaranteed>, usize)>,\n+        buffered_mut_errors: FxIndexMap<Span, (DiagnosticBuilder<'tcx, ErrorGuaranteed>, usize)>,\n         /// Diagnostics to be reported buffer.\n         buffered: Vec<Diagnostic>,\n         /// Set to Some if we emit an error during borrowck"}, {"sha": "b6c5d4245d7b48933b855aea9970310c293e8c88", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,7 +1,7 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_index::vec::IndexVec;\n use rustc_middle::infer::MemberConstraint;\n use rustc_middle::ty::{self, Ty};\n@@ -18,7 +18,7 @@ where\n {\n     /// Stores the first \"member\" constraint for a given `R0`. This is an\n     /// index into the `constraints` vector below.\n-    first_constraints: FxHashMap<R, NllMemberConstraintIndex>,\n+    first_constraints: FxIndexMap<R, NllMemberConstraintIndex>,\n \n     /// Stores the data about each `R0 member of [R1..Rn]` constraint.\n     /// These are organized into a linked list, so each constraint\n@@ -132,7 +132,7 @@ where\n \n         let MemberConstraintSet { first_constraints, mut constraints, choice_regions } = self;\n \n-        let mut first_constraints2 = FxHashMap::default();\n+        let mut first_constraints2 = FxIndexMap::default();\n         first_constraints2.reserve(first_constraints.len());\n \n         for (r1, start1) in first_constraints {"}, {"sha": "f0068fc9226be0282d84eeeb25c020145ba7e33a", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -2,18 +2,17 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! The entry point of the NLL borrow checker.\n \n-use rustc_data_structures::vec_map::VecMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n     Promoted,\n };\n-use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid};\n+use rustc_middle::ty::{self, OpaqueHiddenType, Region, RegionVid, TyCtxt};\n use rustc_span::symbol::sym;\n use std::env;\n-use std::fmt::Debug;\n use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -45,7 +44,7 @@ pub type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n pub(crate) struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n-    pub opaque_type_values: VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    pub opaque_type_values: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     pub polonius_input: Option<Box<AllFacts>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n@@ -325,7 +324,7 @@ pub(super) fn dump_mir_results<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n-    closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n+    closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     if !dump_enabled(infcx.tcx, \"nll\", body.source.def_id()) {\n         return;\n@@ -340,9 +339,11 @@ pub(super) fn dump_mir_results<'tcx>(\n \n                 if let Some(closure_region_requirements) = closure_region_requirements {\n                     writeln!(out, \"| Free Region Constraints\")?;\n-                    for_each_region_constraint(closure_region_requirements, &mut |msg| {\n-                        writeln!(out, \"| {}\", msg)\n-                    })?;\n+                    for_each_region_constraint(\n+                        infcx.tcx,\n+                        closure_region_requirements,\n+                        &mut |msg| writeln!(out, \"| {}\", msg),\n+                    )?;\n                     writeln!(out, \"|\")?;\n                 }\n             }\n@@ -375,8 +376,8 @@ pub(super) fn dump_annotation<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n-    closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n-    opaque_type_values: &VecMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n+    closure_region_requirements: &Option<ClosureRegionRequirements<'tcx>>,\n+    opaque_type_values: &FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     errors: &mut crate::error::BorrowckErrors<'tcx>,\n ) {\n     let tcx = infcx.tcx;\n@@ -405,7 +406,7 @@ pub(super) fn dump_annotation<'tcx>(\n \n         // Dump the region constraints we are imposing *between* those\n         // newly created variables.\n-        for_each_region_constraint(closure_region_requirements, &mut |msg| {\n+        for_each_region_constraint(tcx, closure_region_requirements, &mut |msg| {\n             err.note(msg);\n             Ok(())\n         })\n@@ -426,16 +427,19 @@ pub(super) fn dump_annotation<'tcx>(\n     errors.buffer_non_error_diag(err);\n }\n \n-fn for_each_region_constraint(\n-    closure_region_requirements: &ClosureRegionRequirements<'_>,\n+fn for_each_region_constraint<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    closure_region_requirements: &ClosureRegionRequirements<'tcx>,\n     with_msg: &mut dyn FnMut(&str) -> io::Result<()>,\n ) -> io::Result<()> {\n     for req in &closure_region_requirements.outlives_requirements {\n-        let subject: &dyn Debug = match &req.subject {\n-            ClosureOutlivesSubject::Region(subject) => subject,\n-            ClosureOutlivesSubject::Ty(ty) => ty,\n+        let subject = match req.subject {\n+            ClosureOutlivesSubject::Region(subject) => format!(\"{:?}\", subject),\n+            ClosureOutlivesSubject::Ty(ty) => {\n+                format!(\"{:?}\", ty.instantiate(tcx, |vid| tcx.mk_re_var(vid)))\n+            }\n         };\n-        with_msg(&format!(\"where {:?}: {:?}\", subject, req.outlived_free_region,))?;\n+        with_msg(&format!(\"where {}: {:?}\", subject, req.outlived_free_region,))?;\n     }\n     Ok(())\n }"}, {"sha": "03f175daca9e8d26e4237d778df738453a0e0348", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 70, "deletions": 101, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -3,7 +3,7 @@ use std::rc::Rc;\n \n use rustc_data_structures::binary_search_util;\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::CRATE_DEF_ID;\n@@ -12,8 +12,9 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, ReturnConstraint, TerminatorKind,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n+    TerminatorKind,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n@@ -87,7 +88,7 @@ pub struct RegionInferenceContext<'tcx> {\n     member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n     /// Map universe indexes to information on why we created it.\n-    universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+    universe_causes: FxIndexMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n@@ -254,15 +255,16 @@ fn sccs_info<'cx, 'tcx>(\n     let var_to_origin = infcx.reg_var_to_origin.borrow();\n \n     let mut var_to_origin_sorted = var_to_origin.clone().into_iter().collect::<Vec<_>>();\n-    var_to_origin_sorted.sort_by(|a, b| a.0.cmp(&b.0));\n-    let mut debug_str = \"region variables to origins:\\n\".to_string();\n+    var_to_origin_sorted.sort_by_key(|vto| vto.0);\n+\n+    let mut reg_vars_to_origins_str = \"region variables to origins:\\n\".to_string();\n     for (reg_var, origin) in var_to_origin_sorted.into_iter() {\n-        debug_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n+        reg_vars_to_origins_str.push_str(&format!(\"{:?}: {:?}\\n\", reg_var, origin));\n     }\n-    debug!(debug_str);\n+    debug!(\"{}\", reg_vars_to_origins_str);\n \n     let num_components = sccs.scc_data().ranges().len();\n-    let mut components = vec![FxHashSet::default(); num_components];\n+    let mut components = vec![FxIndexSet::default(); num_components];\n \n     for (reg_var_idx, scc_idx) in sccs.scc_indices().iter().enumerate() {\n         let reg_var = ty::RegionVid::from_usize(reg_var_idx);\n@@ -274,12 +276,12 @@ fn sccs_info<'cx, 'tcx>(\n     for (scc_idx, reg_vars_origins) in components.iter().enumerate() {\n         let regions_info = reg_vars_origins.clone().into_iter().collect::<Vec<_>>();\n         components_str.push_str(&format!(\n-            \"{:?}: {:?})\",\n+            \"{:?}: {:?},\\n)\",\n             ConstraintSccIndex::from_usize(scc_idx),\n             regions_info,\n         ))\n     }\n-    debug!(components_str);\n+    debug!(\"{}\", components_str);\n \n     // calculate the best representative for each component\n     let components_representatives = components\n@@ -294,9 +296,9 @@ fn sccs_info<'cx, 'tcx>(\n \n             (ConstraintSccIndex::from_usize(scc_idx), repr)\n         })\n-        .collect::<FxHashMap<_, _>>();\n+        .collect::<FxIndexMap<_, _>>();\n \n-    let mut scc_node_to_edges = FxHashMap::default();\n+    let mut scc_node_to_edges = FxIndexMap::default();\n     for (scc_idx, repr) in components_representatives.iter() {\n         let edges_range = sccs.scc_data().ranges()[*scc_idx].clone();\n         let edges = &sccs.scc_data().all_successors()[edges_range];\n@@ -324,7 +326,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n         outlives_constraints: OutlivesConstraintSet<'tcx>,\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n-        universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+        universe_causes: FxIndexMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n         liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n@@ -521,6 +523,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// outlives `'a` and hence contains R0 and R1.\n     fn init_free_and_bound_regions(&mut self) {\n         // Update the names (if any)\n+        // This iterator has unstable order but we collect it all into an IndexVec\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n             debug!(\n                 \"init_universal_regions: region {:?} has external name {:?}\",\n@@ -889,7 +892,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// from a universe it can't name; at present, the only way for\n     /// this to be true is if `scc` outlives `'static`. This is\n     /// actually stricter than necessary: ideally, we'd support bounds\n-    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// like `for<'a: 'b>` that might then allow us to approximate\n     /// `'a` with `'b` and not `'static`. But it will have to do for\n     /// now.\n     fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {\n@@ -917,7 +920,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Sometimes we register equivalent type-tests that would\n         // result in basically the exact same error being reported to\n         // the user. Avoid that.\n-        let mut deduplicate_errors = FxHashSet::default();\n+        let mut deduplicate_errors = FxIndexSet::default();\n \n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n@@ -1084,18 +1087,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         true\n     }\n \n-    /// When we promote a type test `T: 'r`, we have to convert the\n-    /// type `T` into something we can store in a query result (so\n-    /// something allocated for `'tcx`). This is problematic if `ty`\n-    /// contains regions. During the course of NLL region checking, we\n-    /// will have replaced all of those regions with fresh inference\n-    /// variables. To create a test subject, we want to replace those\n-    /// inference variables with some region from the closure\n-    /// signature -- this is not always possible, so this is a\n-    /// fallible process. Presuming we do find a suitable region, we\n-    /// will use it's *external name*, which will be a `RegionKind`\n-    /// variant that can be used in query responses such as\n-    /// `ReEarlyBound`.\n+    /// When we promote a type test `T: 'r`, we have to replace all region\n+    /// variables in the type `T` with an equal universal region from the\n+    /// closure signature.\n+    /// This is not always possible, so this is a fallible process.\n     #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n@@ -1104,91 +1099,63 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n \n+        // Opaque types' substs may include useless lifetimes.\n+        // We will replace them with ReStatic.\n+        struct OpaqueFolder<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+        impl<'tcx> ty::TypeFolder<TyCtxt<'tcx>> for OpaqueFolder<'tcx> {\n+            fn interner(&self) -> TyCtxt<'tcx> {\n+                self.tcx\n+            }\n+            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+                use ty::TypeSuperFoldable as _;\n+                let tcx = self.tcx;\n+                let &ty::Alias(ty::Opaque, ty::AliasTy { substs, def_id, .. }) = t.kind() else {\n+                    return t.super_fold_with(self);\n+                };\n+                let substs =\n+                    std::iter::zip(substs, tcx.variances_of(def_id)).map(|(arg, v)| {\n+                        match (arg.unpack(), v) {\n+                            (ty::GenericArgKind::Lifetime(_), ty::Bivariant) => {\n+                                tcx.lifetimes.re_static.into()\n+                            }\n+                            _ => arg.fold_with(self),\n+                        }\n+                    });\n+                tcx.mk_opaque(def_id, tcx.mk_substs_from_iter(substs))\n+            }\n+        }\n+\n+        let ty = ty.fold_with(&mut OpaqueFolder { tcx });\n+\n         let ty = tcx.fold_regions(ty, |r, _depth| {\n-            let region_vid = self.to_region_vid(r);\n+            let r_vid = self.to_region_vid(r);\n+            let r_scc = self.constraint_sccs.scc(r_vid);\n \n             // The challenge if this. We have some region variable `r`\n             // whose value is a set of CFG points and universal\n             // regions. We want to find if that set is *equivalent* to\n             // any of the named regions found in the closure.\n-            //\n-            // To do so, we compute the\n-            // `non_local_universal_upper_bound`. This will be a\n-            // non-local, universal region that is greater than `r`.\n-            // However, it might not be *contained* within `r`, so\n-            // then we further check whether this bound is contained\n-            // in `r`. If so, we can say that `r` is equivalent to the\n-            // bound.\n-            //\n-            // Let's work through a few examples. For these, imagine\n-            // that we have 3 non-local regions (I'll denote them as\n-            // `'static`, `'a`, and `'b`, though of course in the code\n-            // they would be represented with indices) where:\n-            //\n-            // - `'static: 'a`\n-            // - `'static: 'b`\n-            //\n-            // First, let's assume that `r` is some existential\n-            // variable with an inferred value `{'a, 'static}` (plus\n-            // some CFG nodes). In this case, the non-local upper\n-            // bound is `'static`, since that outlives `'a`. `'static`\n-            // is also a member of `r` and hence we consider `r`\n-            // equivalent to `'static` (and replace it with\n-            // `'static`).\n-            //\n-            // Now let's consider the inferred value `{'a, 'b}`. This\n-            // means `r` is effectively `'a | 'b`. I'm not sure if\n-            // this can come about, actually, but assuming it did, we\n-            // would get a non-local upper bound of `'static`. Since\n-            // `'static` is not contained in `r`, we would fail to\n-            // find an equivalent.\n-            let upper_bound = self.non_local_universal_upper_bound(region_vid);\n-            if self.region_contains(region_vid, upper_bound) {\n-                self.definitions[upper_bound].external_name.unwrap_or(r)\n-            } else {\n-                // In the case of a failure, use a `ReVar` result. This will\n-                // cause the `needs_infer` later on to return `None`.\n-                r\n-            }\n+            // To do so, we simply check every candidate `u_r` for equality.\n+            self.scc_values\n+                .universal_regions_outlived_by(r_scc)\n+                .filter(|&u_r| !self.universal_regions.is_local_free_region(u_r))\n+                .find(|&u_r| self.eval_equal(u_r, r_vid))\n+                .map(|u_r| tcx.mk_re_var(u_r))\n+                // In the case of a failure, use `ReErased`. We will eventually\n+                // return `None` in this case.\n+                .unwrap_or(tcx.lifetimes.re_erased)\n         });\n \n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `needs_infer` will only be true if we failed to promote some region.\n-        if ty.needs_infer() {\n+        // This will be true if we failed to promote some region.\n+        if ty.has_erased_regions() {\n             return None;\n         }\n \n-        Some(ClosureOutlivesSubject::Ty(ty))\n-    }\n-\n-    /// Given some universal or existential region `r`, finds a\n-    /// non-local, universal region `r+` that outlives `r` at entry to (and\n-    /// exit from) the closure. In the worst case, this will be\n-    /// `'static`.\n-    ///\n-    /// This is used for two purposes. First, if we are propagated\n-    /// some requirement `T: r`, we can use this method to enlarge `r`\n-    /// to something we can encode for our creator (which only knows\n-    /// about non-local, universal regions). It is also used when\n-    /// encoding `T` as part of `try_promote_type_test_subject` (see\n-    /// that fn for details).\n-    ///\n-    /// This is based on the result `'y` of `universal_upper_bound`,\n-    /// except that it converts further takes the non-local upper\n-    /// bound of `'y`, so that the final result is non-local.\n-    fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n-\n-        let lub = self.universal_upper_bound(r);\n-\n-        // Grow further to get smallest universal region known to\n-        // creator.\n-        let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n-\n-        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n-\n-        non_local_lub\n+        Some(ClosureOutlivesSubject::Ty(ClosureOutlivesSubjectTy::bind(tcx, ty)))\n     }\n \n     /// Returns a universally quantified region that outlives the\n@@ -1539,6 +1506,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // the outlives suggestions or the debug output from `#[rustc_regions]` would be\n         // duplicated. The polonius subset errors are deduplicated here, while keeping the\n         // CFG-location ordering.\n+        // We can iterate the HashMap here because the result is sorted afterwards.\n+        #[allow(rustc::potential_query_instability)]\n         let mut subset_errors: Vec<_> = polonius_output\n             .subset_errors\n             .iter()\n@@ -2248,7 +2217,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // is in the same SCC or something. In that case, find what\n         // appears to be the most interesting point to report to the\n         // user via an even more ad-hoc guess.\n-        categorized_path.sort_by(|p0, p1| p0.category.cmp(&p1.category));\n+        categorized_path.sort_by_key(|p| p.category);\n         debug!(\"sorted_path={:#?}\", categorized_path);\n \n         (categorized_path.remove(0), extra_info)"}, {"sha": "2b16655cf7d5a91a0ff85d14142654bc43e827af", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,5 +1,4 @@\n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_data_structures::vec_map::VecMap;\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n@@ -61,11 +60,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n-    ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n-        let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n+        opaque_ty_decls: FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+    ) -> FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n+        let mut result: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>> = FxIndexMap::default();\n \n-        let member_constraints: FxHashMap<_, _> = self\n+        let member_constraints: FxIndexMap<_, _> = self\n             .member_constraints\n             .all_indices()\n             .map(|ci| (self.member_constraints[ci].key, ci))\n@@ -284,7 +283,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // hidden type is well formed even without those bounds.\n         let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n \n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n@@ -325,7 +324,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if errors.is_empty() {\n             definition_ty\n         } else {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n             self.tcx.ty_error(reported)\n         }\n     }\n@@ -364,7 +363,7 @@ fn check_opaque_type_parameter_valid(\n         OpaqueTyOrigin::TyAlias => {}\n     }\n     let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n-    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    let mut seen_params: FxIndexMap<_, Vec<_>> = FxIndexMap::default();\n     for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n         let arg_is_param = match arg.unpack() {\n             GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),"}, {"sha": "23a59c12865b141ca6e1b4486366059d2f748b11", "filename": "compiler/rustc_borrowck/src/region_infer/reverse_sccs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Freverse_sccs.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -3,7 +3,7 @@\n use crate::constraints::ConstraintSccIndex;\n use crate::RegionInferenceContext;\n use itertools::Itertools;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::vec_graph::VecGraph;\n use rustc_data_structures::graph::WithSuccessors;\n use rustc_middle::ty::RegionVid;\n@@ -14,7 +14,7 @@ pub(crate) struct ReverseSccGraph {\n     graph: VecGraph<ConstraintSccIndex>,\n     /// For each SCC, the range of `universal_regions` that use that SCC as\n     /// their value.\n-    scc_regions: FxHashMap<ConstraintSccIndex, Range<usize>>,\n+    scc_regions: FxIndexMap<ConstraintSccIndex, Range<usize>>,\n     /// All of the universal regions, in grouped so that `scc_regions` can\n     /// index into here.\n     universal_regions: Vec<RegionVid>,\n@@ -26,7 +26,7 @@ impl ReverseSccGraph {\n         &'a self,\n         scc0: ConstraintSccIndex,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n-        let mut duplicates = FxHashSet::default();\n+        let mut duplicates = FxIndexSet::default();\n         self.graph\n             .depth_first_search(scc0)\n             .flat_map(move |scc1| {\n@@ -55,7 +55,7 @@ impl RegionInferenceContext<'_> {\n         paired_scc_regions.sort();\n         let universal_regions = paired_scc_regions.iter().map(|&(_, region)| region).collect();\n \n-        let mut scc_regions = FxHashMap::default();\n+        let mut scc_regions = FxIndexMap::default();\n         let mut start = 0;\n         for (scc, group) in &paired_scc_regions.into_iter().group_by(|(scc, _)| *scc) {\n             let group_size = group.count();"}, {"sha": "8132800f107a7b385680235bb0622a267e558776", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -235,7 +235,7 @@ pub(crate) struct RegionValues<N: Idx> {\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n     /// Placeholders represent bound regions -- so something like `'a`\n-    /// in for<'a> fn(&'a u32)`.\n+    /// in `for<'a> fn(&'a u32)`.\n     placeholders: SparseBitMatrix<N, PlaceholderIndex>,\n }\n "}, {"sha": "a93561350062c630b4ed52587175fbada2ad26bf", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -116,7 +116,9 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n             let outlived_region = closure_mapping[outlives_requirement.outlived_free_region];\n             let subject = match outlives_requirement.subject {\n                 ClosureOutlivesSubject::Region(re) => closure_mapping[re].into(),\n-                ClosureOutlivesSubject::Ty(ty) => ty.into(),\n+                ClosureOutlivesSubject::Ty(subject_ty) => {\n+                    subject_ty.instantiate(self.tcx, |vid| closure_mapping[vid]).into()\n+                }\n             };\n \n             self.category = outlives_requirement.category;"}, {"sha": "4004966c40a77bc9d561432427b0b25ab7fe5eed", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -93,31 +93,6 @@ impl UniversalRegionRelations<'_> {\n         res\n     }\n \n-    /// Returns the \"postdominating\" bound of the set of\n-    /// `non_local_upper_bounds` for the given region.\n-    pub(crate) fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        let upper_bounds = self.non_local_upper_bounds(fr);\n-\n-        // In case we find more than one, reduce to one for\n-        // convenience. This is to prevent us from generating more\n-        // complex constraints, but it will cause spurious errors.\n-        let post_dom = self.inverse_outlives.mutual_immediate_postdominator(upper_bounds);\n-\n-        debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n-\n-        post_dom\n-            .and_then(|post_dom| {\n-                // If the mutual immediate postdom is not local, then\n-                // there is no non-local result we can return.\n-                if !self.universal_regions.is_local_free_region(post_dom) {\n-                    Some(post_dom)\n-                } else {\n-                    None\n-                }\n-            })\n-            .unwrap_or(self.universal_regions.fr_static)\n-    }\n-\n     /// Finds a \"lower bound\" for `fr` that is not local. In other\n     /// words, returns the largest (*) known region `fr1` that (a) is\n     /// outlived by `fr` and (b) is not local."}, {"sha": "17e702eb8c5282ba78e8cbde781334bb68aa030d", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -19,18 +19,14 @@ use super::{Locations, TypeChecker};\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     /// Check explicit closure signature annotation,\n-    /// e.g., `|x: FxHashMap<_, &'static u32>| ...`.\n+    /// e.g., `|x: FxIndexMap<_, &'static u32>| ...`.\n     #[instrument(skip(self, body), level = \"debug\")]\n     pub(super) fn check_signature_annotation(&mut self, body: &Body<'tcx>) {\n         let mir_def_id = body.source.def_id().expect_local();\n         if !self.tcx().is_closure(mir_def_id.to_def_id()) {\n             return;\n         }\n-        let Some(user_provided_poly_sig) =\n-            self.tcx().typeck(mir_def_id).user_provided_sigs.get(&mir_def_id)\n-        else {\n-            return;\n-        };\n+        let user_provided_poly_sig = self.tcx().closure_user_provided_sig(mir_def_id);\n \n         // Instantiate the canonicalized variables from user-provided signature\n         // (e.g., the `_` in the code above) with fresh variables."}, {"sha": "9731b10aa99d9f931edcff1488a4b1e126bd4085", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_index::bit_set::HybridBitSet;\n use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n@@ -56,7 +56,7 @@ pub(super) fn trace<'mir, 'tcx>(\n         elements,\n         local_use_map,\n         move_data,\n-        drop_data: FxHashMap::default(),\n+        drop_data: FxIndexMap::default(),\n     };\n \n     let mut results = LivenessResults::new(cx);\n@@ -85,7 +85,7 @@ struct LivenessContext<'me, 'typeck, 'flow, 'tcx> {\n     move_data: &'me MoveData<'tcx>,\n \n     /// Cache for the results of `dropck_outlives` query.\n-    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+    drop_data: FxIndexMap<Ty<'tcx>, DropData<'tcx>>,\n \n     /// Results of dataflow tracking which variables (and paths) have been\n     /// initialized.\n@@ -185,7 +185,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n     fn add_extra_drop_facts(\n         &mut self,\n         drop_used: Vec<(Local, Location)>,\n-        relevant_live_locals: FxHashSet<Local>,\n+        relevant_live_locals: FxIndexSet<Local>,\n     ) {\n         let locations = IntervalSet::new(self.cx.elements.num_points());\n \n@@ -435,8 +435,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         //\n         // What we *actually* generate is a store to a temporary\n         // for the call (`TMP = call()...`) and then a\n-        // `DropAndReplace` to swap that with `X`\n-        // (`DropAndReplace` has very particular semantics).\n+        // `Drop(X)` followed by `X = TMP`  to swap that with `X`.\n     }\n }\n "}, {"sha": "4b27d240985177c6d850e06479cabd5477d972fd", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 22, "deletions": 35, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -9,13 +9,12 @@ use either::Either;\n \n use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::vec_map::VecMap;\n+use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n@@ -37,7 +36,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::FIRST_VARIANT;\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -145,7 +144,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         outlives_constraints: OutlivesConstraintSet::default(),\n         member_constraints: MemberConstraintSet::default(),\n         type_tests: Vec::default(),\n-        universe_causes: FxHashMap::default(),\n+        universe_causes: FxIndexMap::default(),\n     };\n \n     let CreateResult {\n@@ -772,7 +771,9 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         match context {\n             PlaceContext::MutatingUse(_) => ty::Invariant,\n-            PlaceContext::NonUse(StorageDead | StorageLive | VarDebugInfo) => ty::Invariant,\n+            PlaceContext::NonUse(StorageDead | StorageLive | PlaceMention | VarDebugInfo) => {\n+                ty::Invariant\n+            }\n             PlaceContext::NonMutatingUse(\n                 Inspect | Copy | Move | SharedBorrow | ShallowBorrow | UniqueBorrow | AddressOf\n                 | Projection,\n@@ -811,7 +812,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             },\n             PlaceTy { ty, variant_index: None } => match *ty.kind() {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() => {\n-                    (adt_def.variant(VariantIdx::new(0)), substs)\n+                    (adt_def.variant(FIRST_VARIANT), substs)\n                 }\n                 ty::Closure(_, substs) => {\n                     return match substs\n@@ -875,7 +876,7 @@ struct TypeChecker<'a, 'tcx> {\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n-    reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n+    reported_errors: FxIndexSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n }\n \n@@ -892,7 +893,7 @@ pub(crate) struct MirTypeckResults<'tcx> {\n     pub(crate) constraints: MirTypeckRegionConstraints<'tcx>,\n     pub(crate) universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n     pub(crate) opaque_type_values:\n-        VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n+        FxIndexMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -925,7 +926,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n \n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n-    pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n+    pub(crate) universe_causes: FxIndexMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n     pub(crate) type_tests: Vec<TypeTest<'tcx>>,\n }\n@@ -1178,10 +1179,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         }\n                     }\n                     Some(l)\n-                        if matches!(\n-                            body.local_decls[l].local_info,\n-                            Some(box LocalInfo::AggregateTemp)\n-                        ) =>\n+                        if matches!(body.local_decls[l].local_info(), LocalInfo::AggregateTemp) =>\n                     {\n                         ConstraintCategory::Usage\n                     }\n@@ -1282,6 +1280,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             | StatementKind::Retag { .. }\n             | StatementKind::Coverage(..)\n             | StatementKind::ConstEvalCounter\n+            | StatementKind::PlaceMention(..)\n             | StatementKind::Nop => {}\n             StatementKind::Deinit(..) | StatementKind::SetDiscriminant { .. } => {\n                 bug!(\"Statement not allowed in this MIR phase\")\n@@ -1312,24 +1311,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { place, value, target: _, unwind: _ } => {\n-                let place_ty = place.ty(body, tcx).ty;\n-                let rv_ty = value.ty(body, tcx);\n-\n-                let locations = term_location.to_locations();\n-                if let Err(terr) =\n-                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n-                {\n-                    span_mirbug!(\n-                        self,\n-                        term,\n-                        \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n-                        place_ty,\n-                        rv_ty,\n-                        terr\n-                    );\n-                }\n-            }\n             TerminatorKind::SwitchInt { discr, .. } => {\n                 self.check_operand(discr, term_location);\n \n@@ -1629,7 +1610,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n             TerminatorKind::Unreachable => {}\n             TerminatorKind::Drop { target, unwind, .. }\n-            | TerminatorKind::DropAndReplace { target, unwind, .. }\n             | TerminatorKind::Assert { target, cleanup: unwind, .. } => {\n                 self.assert_iscleanup(body, block_data, target, is_cleanup);\n                 if let Some(unwind) = unwind {\n@@ -1700,7 +1680,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // - maybe we should make that a warning.\n                 return;\n             }\n-            LocalKind::Var | LocalKind::Temp => {}\n+            LocalKind::Temp => {}\n         }\n \n         // When `unsized_fn_params` or `unsized_locals` is enabled, only function calls\n@@ -2242,6 +2222,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         }\n                     }\n+                    CastKind::Transmute => {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"Unexpected CastKind::Transmute, which is not permitted in Analysis MIR\",\n+                        );\n+                    }\n                 }\n             }\n \n@@ -2633,7 +2620,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             DefKind::InlineConst => substs.as_inline_const().parent_substs(),\n             other => bug!(\"unexpected item {:?}\", other),\n         };\n-        let parent_substs = tcx.intern_substs(parent_substs);\n+        let parent_substs = tcx.mk_substs(parent_substs);\n \n         assert_eq!(typeck_root_substs.len(), parent_substs.len());\n         if let Err(_) = self.eq_substs("}, {"sha": "305e2c8fe8ebbcc539e7d24a00cc7ab414bda503", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -132,9 +132,12 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n \n         let reg_var =\n             reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n-        let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-        let prev = var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n-        assert!(matches!(prev, None));\n+\n+        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n+            let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n+            debug!(?reg_var);\n+            var_to_origin.insert(reg_var, RegionCtxt::Placeholder(reg_info));\n+        }\n \n         reg\n     }\n@@ -149,14 +152,9 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         let reg_var =\n             reg.as_var().unwrap_or_else(|| bug!(\"expected region {:?} to be of kind ReVar\", reg));\n \n-        if cfg!(debug_assertions) {\n+        if cfg!(debug_assertions) && !self.type_checker.infcx.inside_canonicalization_ctxt() {\n             let mut var_to_origin = self.type_checker.infcx.reg_var_to_origin.borrow_mut();\n-            let prev = var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n-\n-            // It only makes sense to track region vars in non-canonicalization contexts. If this\n-            // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n-            // or modify how we track nll region vars for that map.\n-            assert!(matches!(prev, None));\n+            var_to_origin.insert(reg_var, RegionCtxt::Existential(None));\n         }\n \n         reg"}, {"sha": "68c86051364ed815f29cb98894156a9df9c7bf38", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -18,13 +18,11 @@ use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{BodyOwnerKind, HirId};\n+use rustc_hir::BodyOwnerKind;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{\n-    self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n-};\n+use rustc_middle::ty::{self, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_span::Symbol;\n use std::iter;\n@@ -231,9 +229,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n-        let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(mir_def.did);\n-        UniversalRegionsBuilder { infcx, mir_def, mir_hir_id, param_env }.build()\n+        UniversalRegionsBuilder { infcx, mir_def, param_env }.build()\n     }\n \n     /// Given a reference to a closure type, extracts all the values\n@@ -316,6 +312,9 @@ impl<'tcx> UniversalRegions<'tcx> {\n     }\n \n     /// Gets an iterator over all the early-bound regions that have names.\n+    /// Iteration order may be unstable, so this should only be used when\n+    /// iteration order doesn't affect anything\n+    #[allow(rustc::potential_query_instability)]\n     pub fn named_universal_regions<'s>(\n         &'s self,\n     ) -> impl Iterator<Item = (ty::Region<'tcx>, ty::RegionVid)> + 's {\n@@ -390,7 +389,6 @@ impl<'tcx> UniversalRegions<'tcx> {\n struct UniversalRegionsBuilder<'cx, 'tcx> {\n     infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n-    mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n@@ -516,7 +514,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let va_list_ty =\n                     self.infcx.tcx.type_of(va_list_did).subst(self.infcx.tcx, &[region.into()]);\n \n-                unnormalized_input_tys = self.infcx.tcx.mk_type_list(\n+                unnormalized_input_tys = self.infcx.tcx.mk_type_list_from_iter(\n                     unnormalized_input_tys.iter().copied().chain(iter::once(va_list_ty)),\n                 );\n             }\n@@ -560,12 +558,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         match tcx.hir().body_owner_kind(self.mir_def.did) {\n             BodyOwnerKind::Closure | BodyOwnerKind::Fn => {\n-                let defining_ty = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n-                    tcx.type_of(typeck_root_def_id).subst_identity()\n-                } else {\n-                    let tables = tcx.typeck(self.mir_def.did);\n-                    tables.node_type(self.mir_hir_id)\n-                };\n+                let defining_ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n \n                 debug!(\"defining_ty (pre-replacement): {:?}\", defining_ty);\n \n@@ -594,7 +587,18 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                         self.infcx.replace_free_regions_with_nll_infer_vars(FR, identity_substs);\n                     DefiningTy::Const(self.mir_def.did.to_def_id(), substs)\n                 } else {\n-                    let ty = tcx.typeck(self.mir_def.did).node_type(self.mir_hir_id);\n+                    // FIXME this line creates a dependency between borrowck and typeck.\n+                    //\n+                    // This is required for `AscribeUserType` canonical query, which will call\n+                    // `type_of(inline_const_def_id)`. That `type_of` would inject erased lifetimes\n+                    // into borrowck, which is ICE #78174.\n+                    //\n+                    // As a workaround, inline consts have an additional generic param (`ty`\n+                    // below), so that `type_of(inline_const_def_id).substs(substs)` uses the\n+                    // proper type with NLL infer vars.\n+                    let ty = tcx\n+                        .typeck(self.mir_def.did)\n+                        .node_type(tcx.local_def_id_to_hir_id(self.mir_def.did));\n                     let substs = InlineConstSubsts::new(\n                         tcx,\n                         InlineConstSubstsParts { parent_substs: identity_substs, ty },\n@@ -656,7 +660,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n-                let bound_vars = tcx.mk_bound_variable_kinds(\n+                let bound_vars = tcx.mk_bound_variable_kinds_from_iter(\n                     inputs_and_output\n                         .bound_vars()\n                         .iter()\n@@ -680,7 +684,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 };\n \n                 ty::Binder::bind_with_vars(\n-                    tcx.mk_type_list(\n+                    tcx.mk_type_list_from_iter(\n                         iter::once(closure_ty).chain(inputs).chain(iter::once(output)),\n                     ),\n                     bound_vars,\n@@ -693,7 +697,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let output = substs.as_generator().return_ty();\n                 let generator_ty = tcx.mk_generator(def_id, substs, movability);\n                 let inputs_and_output =\n-                    self.infcx.tcx.intern_type_list(&[generator_ty, resume_ty, output]);\n+                    self.infcx.tcx.mk_type_list(&[generator_ty, resume_ty, output]);\n                 ty::Binder::dummy(inputs_and_output)\n             }\n \n@@ -709,13 +713,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let ty = tcx.type_of(self.mir_def.def_id_for_type_of()).subst_identity();\n                 let ty = indices.fold_to_region_vids(tcx, ty);\n-                ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n+                ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }\n \n             DefiningTy::InlineConst(def_id, substs) => {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let ty = substs.as_inline_const().ty();\n-                ty::Binder::dummy(tcx.intern_type_list(&[ty]))\n+                ty::Binder::dummy(tcx.mk_type_list(&[ty]))\n             }\n         }\n     }"}, {"sha": "c5991e0bc254e302714cdedee048b3f641f508e8", "filename": "compiler/rustc_borrowck/src/used_muts.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fused_muts.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,6 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::{\n     Local, Location, Place, Statement, StatementKind, Terminator, TerminatorKind,\n@@ -26,8 +26,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ///  See #55344 for context.\n     pub(crate) fn gather_used_muts(\n         &mut self,\n-        temporary_used_locals: FxHashSet<Local>,\n-        mut never_initialized_mut_locals: FxHashSet<Local>,\n+        temporary_used_locals: FxIndexSet<Local>,\n+        mut never_initialized_mut_locals: FxIndexSet<Local>,\n     ) {\n         {\n             let mut visitor = GatherUsedMutsVisitor {\n@@ -48,8 +48,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n /// MIR visitor for collecting used mutable variables.\n /// The 'visit lifetime represents the duration of the MIR walk.\n struct GatherUsedMutsVisitor<'visit, 'cx, 'tcx> {\n-    temporary_used_locals: FxHashSet<Local>,\n-    never_initialized_mut_locals: &'visit mut FxHashSet<Local>,\n+    temporary_used_locals: FxIndexSet<Local>,\n+    never_initialized_mut_locals: &'visit mut FxIndexSet<Local>,\n     mbcx: &'visit mut MirBorrowckCtxt<'cx, 'tcx>,\n }\n \n@@ -71,9 +71,6 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n             TerminatorKind::Call { destination, .. } => {\n                 self.remove_never_initialized_mut_locals(*destination);\n             }\n-            TerminatorKind::DropAndReplace { place, .. } => {\n-                self.remove_never_initialized_mut_locals(*place);\n-            }\n             _ => {}\n         }\n "}, {"sha": "4d088e27b364ae36762db7512961333e7a34849f", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_builtin_macros/locales/en-US.ftl"}, {"sha": "8c1579baacb08775c9126449c1dd7274d9a2e6d3", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -152,7 +152,7 @@ pub fn parse_asm_args<'a>(\n                 ast::InlineAsmOperand::InOut { reg, expr, late: true }\n             }\n         } else if p.eat_keyword(kw::Const) {\n-            let anon_const = p.parse_anon_const_expr()?;\n+            let anon_const = p.parse_expr_anon_const()?;\n             ast::InlineAsmOperand::Const { anon_const }\n         } else if p.eat_keyword(sym::sym) {\n             let expr = p.parse_expr()?;\n@@ -203,17 +203,6 @@ pub fn parse_asm_args<'a>(\n         // Validate the order of named, positional & explicit register operands and\n         // clobber_abi/options. We do this at the end once we have the full span\n         // of the argument available.\n-        if !args.options_spans.is_empty() {\n-            diag.struct_span_err(span, \"arguments are not allowed after options\")\n-                .span_labels(args.options_spans.clone(), \"previous options\")\n-                .span_label(span, \"argument\")\n-                .emit();\n-        } else if let Some((_, abi_span)) = args.clobber_abis.last() {\n-            diag.struct_span_err(span, \"arguments are not allowed after clobber_abi\")\n-                .span_label(*abi_span, \"clobber_abi\")\n-                .span_label(span, \"argument\")\n-                .emit();\n-        }\n         if explicit_reg {\n             if name.is_some() {\n                 diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n@@ -227,17 +216,6 @@ pub fn parse_asm_args<'a>(\n                     .emit();\n                 continue;\n             }\n-            if !args.reg_args.is_empty() {\n-                let mut err = diag.struct_span_err(\n-                    span,\n-                    \"named arguments cannot follow explicit register arguments\",\n-                );\n-                err.span_label(span, \"named argument\");\n-                for pos in &args.reg_args {\n-                    err.span_label(args.operands[*pos].1, \"explicit register argument\");\n-                }\n-                err.emit();\n-            }\n             args.named_args.insert(name, slot);\n         } else {\n             if !args.named_args.is_empty() || !args.reg_args.is_empty() {\n@@ -478,15 +456,6 @@ fn parse_clobber_abi<'a>(p: &mut Parser<'a>, args: &mut AsmArgs) -> PResult<'a,\n \n     let full_span = span_start.to(p.prev_token.span);\n \n-    if !args.options_spans.is_empty() {\n-        let mut err = p\n-            .sess\n-            .span_diagnostic\n-            .struct_span_err(full_span, \"clobber_abi is not allowed after options\");\n-        err.span_labels(args.options_spans.clone(), \"options\");\n-        return Err(err);\n-    }\n-\n     match &new_abis[..] {\n         // should have errored above during parsing\n         [] => unreachable!(),\n@@ -699,6 +668,10 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                                         args.operands[idx].1,\n                                         \"explicit register arguments cannot be used in the asm template\",\n                                     );\n+                                    err.span_help(\n+                                        args.operands[idx].1,\n+                                        \"use the register name directly in the assembly code\",\n+                                    );\n                                 }\n                                 err.emit();\n                                 None"}, {"sha": "5d8f4db76f9b17ef7f780f8e5efc7d5c7052a481", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -290,7 +290,6 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             | ExprKind::Async(_, _, _)\n             | ExprKind::Await(_)\n             | ExprKind::Block(_, _)\n-            | ExprKind::Box(_)\n             | ExprKind::Break(_, _)\n             | ExprKind::Closure(_)\n             | ExprKind::ConstBlock(_)"}, {"sha": "2b6fcc169be067ee2a92555de44aaae52bf654bf", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::{self as ast, AttrItem, AttrStyle};\n use rustc_session::parse::ParseSess;\n use rustc_span::FileName;\n \n-pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {\n+pub fn inject(krate: &mut ast::Crate, parse_sess: &ParseSess, attrs: &[String]) {\n     for raw_attr in attrs {\n         let mut parser = rustc_parse::new_parser_from_source_str(\n             parse_sess,\n@@ -36,6 +36,4 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n             start_span.to(end_span),\n         ));\n     }\n-\n-    krate\n }"}, {"sha": "36682bbe0708f88babcb29aee81c064ce452f7c3", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -42,6 +42,18 @@ pub fn expand_concat(\n                     has_errors = true;\n                 }\n             },\n+            // We also want to allow negative numeric literals.\n+            ast::ExprKind::Unary(ast::UnOp::Neg, ref expr) if let ast::ExprKind::Lit(token_lit) = expr.kind => {\n+                match ast::LitKind::from_token_lit(token_lit) {\n+                    Ok(ast::LitKind::Int(i, _)) => accumulator.push_str(&format!(\"-{i}\")),\n+                    Ok(ast::LitKind::Float(f, _)) => accumulator.push_str(&format!(\"-{f}\")),\n+                    Err(err) => {\n+                        report_lit_error(&cx.sess.parse_sess, err, token_lit, e.span);\n+                        has_errors = true;\n+                    }\n+                    _ => missing_literal.push(e.span),\n+                }\n+            }\n             ast::ExprKind::IncludedBytes(..) => {\n                 cx.span_err(e.span, \"cannot concatenate a byte string literal\")\n             }\n@@ -53,9 +65,10 @@ pub fn expand_concat(\n             }\n         }\n     }\n+\n     if !missing_literal.is_empty() {\n         let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n-        err.note(\"only literals (like `\\\"foo\\\"`, `42` and `3.14`) can be passed to `concat!()`\");\n+        err.note(\"only literals (like `\\\"foo\\\"`, `-42` and `3.14`) can be passed to `concat!()`\");\n         err.emit();\n         return DummyResult::any(sp);\n     } else if has_errors {"}, {"sha": "cc32739d083c729f09dc6fe1b1b678a8093f02af", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,7 +1,7 @@\n use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use rustc_ast as ast;\n-use rustc_ast::{walk_list, EnumDef, VariantData};\n+use rustc_ast::{attr, walk_list, EnumDef, VariantData};\n use rustc_errors::Applicability;\n use rustc_expand::base::{Annotatable, DummyResult, ExtCtxt};\n use rustc_span::symbol::Ident;\n@@ -106,7 +106,7 @@ fn extract_default_variant<'a>(\n     let default_variants: SmallVec<[_; 1]> = enum_def\n         .variants\n         .iter()\n-        .filter(|variant| cx.sess.contains_name(&variant.attrs, kw::Default))\n+        .filter(|variant| attr::contains_name(&variant.attrs, kw::Default))\n         .collect();\n \n     let variant = match default_variants.as_slice() {\n@@ -116,7 +116,7 @@ fn extract_default_variant<'a>(\n                 .variants\n                 .iter()\n                 .filter(|variant| matches!(variant.data, VariantData::Unit(..)))\n-                .filter(|variant| !cx.sess.contains_name(&variant.attrs, sym::non_exhaustive));\n+                .filter(|variant| !attr::contains_name(&variant.attrs, sym::non_exhaustive));\n \n             let mut diag = cx.struct_span_err(trait_span, \"no default declared\");\n             diag.help(\"make a unit variant default by placing `#[default]` above it\");\n@@ -146,7 +146,7 @@ fn extract_default_variant<'a>(\n                         if v.span == variant.span {\n                             None\n                         } else {\n-                            Some((cx.sess.find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n+                            Some((attr::find_by_name(&v.attrs, kw::Default)?.span, String::new()))\n                         }\n                     })\n                     .collect();\n@@ -174,7 +174,7 @@ fn extract_default_variant<'a>(\n         return Err(());\n     }\n \n-    if let Some(non_exhaustive_attr) = cx.sess.find_by_name(&variant.attrs, sym::non_exhaustive) {\n+    if let Some(non_exhaustive_attr) = attr::find_by_name(&variant.attrs, sym::non_exhaustive) {\n         cx.struct_span_err(variant.ident.span, \"default variant must be exhaustive\")\n             .span_label(non_exhaustive_attr.span, \"declared `#[non_exhaustive]` here\")\n             .help(\"consider a manual implementation of `Default`\")\n@@ -191,7 +191,7 @@ fn validate_default_attribute(\n     default_variant: &rustc_ast::Variant,\n ) -> Result<(), ()> {\n     let attrs: SmallVec<[_; 1]> =\n-        cx.sess.filter_by_name(&default_variant.attrs, kw::Default).collect();\n+        attr::filter_by_name(&default_variant.attrs, kw::Default).collect();\n \n     let attr = match attrs.as_slice() {\n         [attr] => attr,"}, {"sha": "6b3053fdfac7e81ca8f5efc57cf9b9f61b5aef7a", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1052,6 +1052,7 @@ impl<'a> MethodDef<'a> {\n     ///         ::core::hash::Hash::hash(&{ self.y }, state)\n     ///     }\n     /// }\n+    /// ```\n     fn expand_struct_method_body<'b>(\n         &self,\n         cx: &mut ExtCtxt<'_>,"}, {"sha": "f011cb754cb4a7f93ea0d5d9944410d7318f77d0", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, tts) {\n-        Some(exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() || exprs.len() > 2 => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }\n@@ -64,28 +64,48 @@ pub fn expand_env<'cx>(\n     let Some((var, _style)) = expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") else {\n         return DummyResult::any(sp);\n     };\n-    let msg = match exprs.next() {\n-        None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n+\n+    let custom_msg = match exprs.next() {\n+        None => None,\n         Some(second) => match expr_to_string(cx, second, \"expected string literal\") {\n             None => return DummyResult::any(sp),\n-            Some((s, _style)) => s,\n+            Some((s, _style)) => Some(s),\n         },\n     };\n \n-    if exprs.next().is_some() {\n-        cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-        return DummyResult::any(sp);\n-    }\n-\n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(var.as_str()).ok().as_deref().map(Symbol::intern);\n     cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n-            cx.span_err(sp, msg.as_str());\n+            let (msg, help) = match custom_msg {\n+                None => (\n+                    format!(\"environment variable `{var}` not defined at compile time\"),\n+                    Some(help_for_missing_env_var(var.as_str())),\n+                ),\n+                Some(s) => (s.to_string(), None),\n+            };\n+            let mut diag = cx.struct_span_err(sp, &msg);\n+            if let Some(help) = help {\n+                diag.help(help);\n+            }\n+            diag.emit();\n             return DummyResult::any(sp);\n         }\n         Some(value) => cx.expr_str(sp, value),\n     };\n     MacEager::expr(e)\n }\n+\n+fn help_for_missing_env_var(var: &str) -> String {\n+    if var.starts_with(\"CARGO_\")\n+        || var.starts_with(\"DEP_\")\n+        || matches!(var, \"OUT_DIR\" | \"OPT_LEVEL\" | \"PROFILE\" | \"HOST\" | \"TARGET\")\n+    {\n+        format!(\n+            \"Cargo sets build script variables at run time. Use `std::env::var(\\\"{var}\\\")` instead\"\n+        )\n+    } else {\n+        format!(\"Use `std::env::var(\\\"{var}\\\")` to read the variable at run time\")\n+    }\n+}"}, {"sha": "db2ef7fba4b8ea2baeec25f3d04103d4eeee14af", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -36,6 +36,21 @@ enum PositionUsedAs {\n }\n use PositionUsedAs::*;\n \n+struct MacroInput {\n+    fmtstr: P<Expr>,\n+    args: FormatArguments,\n+    /// Whether the first argument was a string literal or a result from eager macro expansion.\n+    /// If it's not a string literal, we disallow implicit arugment capturing.\n+    ///\n+    /// This does not correspond to whether we can treat spans to the literal normally, as the whole\n+    /// invocation might be the result of another macro expansion, in which case this flag may still be true.\n+    ///\n+    /// See [RFC 2795] for more information.\n+    ///\n+    /// [RFC 2795]: https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html#macro-hygiene\n+    is_direct_literal: bool,\n+}\n+\n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n@@ -45,11 +60,7 @@ use PositionUsedAs::*;\n /// ```text\n /// Ok((fmtstr, parsed arguments))\n /// ```\n-fn parse_args<'a>(\n-    ecx: &mut ExtCtxt<'a>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> PResult<'a, (P<Expr>, FormatArguments)> {\n+fn parse_args<'a>(ecx: &mut ExtCtxt<'a>, sp: Span, tts: TokenStream) -> PResult<'a, MacroInput> {\n     let mut args = FormatArguments::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -59,25 +70,21 @@ fn parse_args<'a>(\n     }\n \n     let first_token = &p.token;\n-    let fmtstr = match first_token.kind {\n-        token::TokenKind::Literal(token::Lit {\n-            kind: token::LitKind::Str | token::LitKind::StrRaw(_),\n-            ..\n-        }) => {\n-            // If the first token is a string literal, then a format expression\n-            // is constructed from it.\n-            //\n-            // This allows us to properly handle cases when the first comma\n-            // after the format string is mistakenly replaced with any operator,\n-            // which cause the expression parser to eat too much tokens.\n-            p.parse_literal_maybe_minus()?\n-        }\n-        _ => {\n-            // Otherwise, we fall back to the expression parser.\n-            p.parse_expr()?\n-        }\n+\n+    let fmtstr = if let token::Literal(lit) = first_token.kind && matches!(lit.kind, token::Str | token::StrRaw(_)) {\n+        // This allows us to properly handle cases when the first comma\n+        // after the format string is mistakenly replaced with any operator,\n+        // which cause the expression parser to eat too much tokens.\n+        p.parse_literal_maybe_minus()?\n+    } else {\n+        // Otherwise, we fall back to the expression parser.\n+        p.parse_expr()?\n     };\n \n+    // Only allow implicit captures to be used when the argument is a direct literal\n+    // instead of a macro expanding to one.\n+    let is_direct_literal = matches!(fmtstr.kind, ExprKind::Lit(_));\n+\n     let mut first = true;\n \n     while p.token != token::Eof {\n@@ -147,17 +154,19 @@ fn parse_args<'a>(\n             }\n         }\n     }\n-    Ok((fmtstr, args))\n+    Ok(MacroInput { fmtstr, args, is_direct_literal })\n }\n \n-pub fn make_format_args(\n+fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n-    efmt: P<Expr>,\n-    mut args: FormatArguments,\n+    input: MacroInput,\n     append_newline: bool,\n ) -> Result<FormatArgs, ()> {\n     let msg = \"format argument must be a string literal\";\n-    let unexpanded_fmt_span = efmt.span;\n+    let unexpanded_fmt_span = input.fmtstr.span;\n+\n+    let MacroInput { fmtstr: efmt, mut args, is_direct_literal } = input;\n+\n     let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n         Ok(mut fmt) if append_newline => {\n             fmt.0 = Symbol::intern(&format!(\"{}\\n\", fmt.0));\n@@ -208,11 +217,11 @@ pub fn make_format_args(\n         }\n     }\n \n-    let is_literal = parser.is_literal;\n+    let is_source_literal = parser.is_source_literal;\n \n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = if is_literal {\n+        let sp = if is_source_literal {\n             fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end))\n         } else {\n             // The format string could be another macro invocation, e.g.:\n@@ -230,7 +239,7 @@ pub fn make_format_args(\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, span)) = err.secondary_label && is_literal {\n+        if let Some((label, span)) = err.secondary_label && is_source_literal {\n             e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n         }\n         if err.should_be_replaced_with_positional_argument {\n@@ -256,7 +265,7 @@ pub fn make_format_args(\n     }\n \n     let to_span = |inner_span: rustc_parse_format::InnerSpan| {\n-        is_literal.then(|| {\n+        is_source_literal.then(|| {\n             fmt_span.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end })\n         })\n     };\n@@ -304,7 +313,7 @@ pub fn make_format_args(\n                     // Name not found in `args`, so we add it as an implicitly captured argument.\n                     let span = span.unwrap_or(fmt_span);\n                     let ident = Ident::new(name, span);\n-                    let expr = if is_literal {\n+                    let expr = if is_direct_literal {\n                         ecx.expr_ident(span, ident)\n                     } else {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -814,7 +823,7 @@ fn report_invalid_references(\n         // for `println!(\"{7:7$}\", 1);`\n         indexes.sort();\n         indexes.dedup();\n-        let span: MultiSpan = if !parser.is_literal || parser.arg_places.is_empty() {\n+        let span: MultiSpan = if !parser.is_source_literal || parser.arg_places.is_empty() {\n             MultiSpan::from_span(fmt_span)\n         } else {\n             MultiSpan::from_spans(invalid_refs.iter().filter_map(|&(_, span, _, _)| span).collect())\n@@ -855,8 +864,8 @@ fn expand_format_args_impl<'cx>(\n ) -> Box<dyn base::MacResult + 'cx> {\n     sp = ecx.with_def_site_ctxt(sp);\n     match parse_args(ecx, sp, tts) {\n-        Ok((efmt, args)) => {\n-            if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n+        Ok(input) => {\n+            if let Ok(format_args) = make_format_args(ecx, input, nl) {\n                 MacEager::expr(ecx.expr(sp, ExprKind::FormatArgs(P(format_args))))\n             } else {\n                 MacEager::expr(DummyResult::raw_expr(sp, true))"}, {"sha": "71177b8789baf2fea89080cbc8f1f9428dd9ac0a", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -56,7 +56,7 @@ pub mod proc_macro_harness;\n pub mod standard_library_imports;\n pub mod test_harness;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub fn register_builtin_macros(resolver: &mut dyn ResolverExpand) {\n     let mut register = |name, kind| resolver.register_builtin_macro(name, kind);"}, {"sha": "378d5f39f4ab2ecd32f266afdcc602b49be58d24", "filename": "compiler/rustc_builtin_macros/src/proc_macro_harness.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fproc_macro_harness.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{self as ast, NodeId};\n+use rustc_ast::{self as ast, attr, NodeId};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{parse_macro_name_and_helper_attrs, ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n@@ -34,7 +34,6 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n-    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -44,19 +43,18 @@ struct CollectProcMacros<'a> {\n }\n \n pub fn inject(\n+    krate: &mut ast::Crate,\n     sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n-    mut krate: ast::Crate,\n     is_proc_macro_crate: bool,\n     has_proc_macro_decls: bool,\n     is_test_crate: bool,\n     handler: &rustc_errors::Handler,\n-) -> ast::Crate {\n+) {\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n-        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -66,22 +64,20 @@ pub fn inject(\n     };\n \n     if has_proc_macro_decls || is_proc_macro_crate {\n-        visit::walk_crate(&mut collect, &krate);\n+        visit::walk_crate(&mut collect, krate);\n     }\n     let macros = collect.macros;\n \n     if !is_proc_macro_crate {\n-        return krate;\n+        return;\n     }\n \n     if is_test_crate {\n-        return krate;\n+        return;\n     }\n \n     let decls = mk_decls(&mut cx, &macros);\n     krate.items.push(decls);\n-\n-    krate\n }\n \n impl<'a> CollectProcMacros<'a> {\n@@ -160,7 +156,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -176,7 +172,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if self.sess.is_proc_macro_attr(&attr) {\n+            if attr.is_proc_macro_attr() {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();"}, {"sha": "6493c6f13d54138ff2dc51830fdd210d4267eacd", "filename": "compiler/rustc_builtin_macros/src/standard_library_imports.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fstandard_library_imports.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast as ast;\n+use rustc_ast::{self as ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n use rustc_session::Session;\n@@ -9,17 +9,19 @@ use rustc_span::DUMMY_SP;\n use thin_vec::thin_vec;\n \n pub fn inject(\n-    mut krate: ast::Crate,\n+    krate: &mut ast::Crate,\n+    pre_configured_attrs: &[ast::Attribute],\n     resolver: &mut dyn ResolverExpand,\n     sess: &Session,\n-) -> ast::Crate {\n+) -> usize {\n+    let orig_num_items = krate.items.len();\n     let edition = sess.parse_sess.edition;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n-        return krate;\n-    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n-        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n+    let names: &[Symbol] = if attr::contains_name(pre_configured_attrs, sym::no_core) {\n+        return 0;\n+    } else if attr::contains_name(pre_configured_attrs, sym::no_std) {\n+        if attr::contains_name(pre_configured_attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]\n@@ -88,6 +90,5 @@ pub fn inject(\n     );\n \n     krate.items.insert(0, use_item);\n-\n-    krate\n+    krate.items.len() - orig_num_items\n }"}, {"sha": "44b9c4718a75feec636591e387204d5afb3b36c3", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,14 +1,13 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n-use rustc_ast as ast;\n use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, attr};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_expand::base::*;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident, Symbol};\n-use rustc_span::Span;\n+use rustc_span::{FileNameDisplayPreference, Span};\n use std::iter;\n use thin_vec::{thin_vec, ThinVec};\n \n@@ -33,7 +32,23 @@ pub fn expand_test_case(\n     }\n \n     let sp = ecx.with_def_site_ctxt(attr_sp);\n-    let mut item = anno_item.expect_item();\n+    let (mut item, is_stmt) = match anno_item {\n+        Annotatable::Item(item) => (item, false),\n+        Annotatable::Stmt(stmt) if let ast::StmtKind::Item(_) = stmt.kind => if let ast::StmtKind::Item(i) = stmt.into_inner().kind {\n+            (i, true)\n+        } else {\n+            unreachable!()\n+        },\n+        _ => {\n+            ecx.struct_span_err(\n+                anno_item.span(),\n+                \"`#[test_case]` attribute is only allowed on items\",\n+            )\n+            .emit();\n+\n+            return vec![];\n+        }\n+    };\n     item = item.map(|mut item| {\n         let test_path_symbol = Symbol::intern(&item_path(\n             // skip the name of the root module\n@@ -50,7 +65,13 @@ pub fn expand_test_case(\n         item\n     });\n \n-    return vec![Annotatable::Item(item)];\n+    let ret = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(item.span, item)))\n+    } else {\n+        Annotatable::Item(item)\n+    };\n+\n+    vec![ret]\n }\n \n pub fn expand_test(\n@@ -231,6 +252,8 @@ pub fn expand_test_or_bench(\n         &item.ident,\n     ));\n \n+    let location_info = get_location_info(cx, &item);\n+\n     let mut test_const = cx.item(\n         sp,\n         Ident::new(item.ident.name, sp),\n@@ -267,19 +290,26 @@ pub fn expand_test_or_bench(\n                                         ),\n                                     ),\n                                     // ignore: true | false\n-                                    field(\n-                                        \"ignore\",\n-                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n-                                    ),\n+                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item)),),\n                                     // ignore_message: Some(\"...\") | None\n                                     field(\n                                         \"ignore_message\",\n-                                        if let Some(msg) = should_ignore_message(cx, &item) {\n+                                        if let Some(msg) = should_ignore_message(&item) {\n                                             cx.expr_some(sp, cx.expr_str(sp, msg))\n                                         } else {\n                                             cx.expr_none(sp)\n                                         },\n                                     ),\n+                                    // source_file: <relative_path_of_source_file>\n+                                    field(\"source_file\", cx.expr_str(sp, location_info.0)),\n+                                    // start_line: start line of the test fn identifier.\n+                                    field(\"start_line\", cx.expr_usize(sp, location_info.1)),\n+                                    // start_col: start column of the test fn identifier.\n+                                    field(\"start_col\", cx.expr_usize(sp, location_info.2)),\n+                                    // end_line: end line of the test fn identifier.\n+                                    field(\"end_line\", cx.expr_usize(sp, location_info.3)),\n+                                    // end_col: end column of the test fn identifier.\n+                                    field(\"end_col\", cx.expr_usize(sp, location_info.4)),\n                                     // compile_fail: true | false\n                                     field(\"compile_fail\", cx.expr_bool(sp, false)),\n                                     // no_run: true | false\n@@ -364,6 +394,19 @@ pub fn expand_test_or_bench(\n     }\n }\n \n+fn get_location_info(cx: &ExtCtxt<'_>, item: &ast::Item) -> (Symbol, usize, usize, usize, usize) {\n+    let span = item.ident.span;\n+    let (source_file, lo_line, lo_col, hi_line, hi_col) =\n+        cx.sess.source_map().span_to_location_info(span);\n+\n+    let file_name = match source_file {\n+        Some(sf) => sf.name.display(FileNameDisplayPreference::Remapped).to_string(),\n+        None => \"no-location\".to_string(),\n+    };\n+\n+    (Symbol::intern(&file_name), lo_line, lo_col, hi_line, hi_col)\n+}\n+\n fn item_path(mod_path: &[Ident], item_ident: &Ident) -> String {\n     mod_path\n         .iter()\n@@ -378,12 +421,12 @@ enum ShouldPanic {\n     Yes(Option<Symbol>),\n }\n \n-fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n-    sess.contains_name(&i.attrs, sym::ignore)\n+fn should_ignore(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, sym::ignore)\n }\n \n-fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n-    match cx.sess.find_by_name(&i.attrs, sym::ignore) {\n+fn should_ignore_message(i: &ast::Item) -> Option<Symbol> {\n+    match attr::find_by_name(&i.attrs, sym::ignore) {\n         Some(attr) => {\n             match attr.meta_item_list() {\n                 // Handle #[ignore(bar = \"foo\")]\n@@ -397,7 +440,7 @@ fn should_ignore_message(cx: &ExtCtxt<'_>, i: &ast::Item) -> Option<Symbol> {\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n+    match attr::find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n             let sd = &cx.sess.parse_sess.span_diagnostic;\n \n@@ -463,7 +506,7 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {"}, {"sha": "43ab6c0442833d253b88ddc21be42d11051fcca6", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -37,7 +37,7 @@ struct TestCtxt<'a> {\n \n /// Traverse the crate, collecting all the test functions, eliding any\n /// existing main functions, and synthesizing a main test harness\n-pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n+pub fn inject(krate: &mut ast::Crate, sess: &Session, resolver: &mut dyn ResolverExpand) {\n     let span_diagnostic = sess.diagnostic();\n     let panic_strategy = sess.panic_strategy();\n     let platform_panic_strategy = sess.target.panic_strategy;\n@@ -47,11 +47,11 @@ pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n+    let test_runner = get_test_runner(span_diagnostic, &krate);\n \n     if sess.opts.test {\n         let panic_strategy = match (panic_strategy, sess.opts.unstable_opts.panic_abort_tests) {\n@@ -123,7 +123,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if let Some(name) = get_test_name(&self.cx.ext_cx.sess, &item) {\n+        if let Some(name) = get_test_name(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident, name };\n@@ -145,12 +145,12 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n // Beware, this is duplicated in librustc_passes/entry.rs (with\n // `rustc_hir::Item`), so make sure to keep them in sync.\n-fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+fn entry_point_type(item: &ast::Item, depth: usize) -> EntryPointType {\n     match item.kind {\n         ast::ItemKind::Fn(..) => {\n-            if sess.contains_name(&item.attrs, sym::start) {\n+            if attr::contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n+            } else if attr::contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::RustcMainAttr\n             } else if item.ident.name == sym::main {\n                 if depth == 0 {\n@@ -184,7 +184,7 @@ impl<'a> MutVisitor for EntryPointCleaner<'a> {\n         // Remove any #[rustc_main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry_point_type(self.sess, &item, self.depth) {\n+        let item = match entry_point_type(&item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::RustcMainAttr | EntryPointType::Start => {\n                 item.map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_dead_code = attr::mk_attr_nested_word(\n@@ -373,16 +373,12 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn get_test_name(sess: &Session, i: &ast::Item) -> Option<Symbol> {\n-    sess.first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n+fn get_test_name(i: &ast::Item) -> Option<Symbol> {\n+    attr::first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(\n-    sess: &Session,\n-    sd: &rustc_errors::Handler,\n-    krate: &ast::Crate,\n-) -> Option<ast::Path> {\n-    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n+    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {"}, {"sha": "9463a1418ce31bc5242c3288155c51a2d8a482c7", "filename": "compiler/rustc_builtin_macros/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Futil.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::{AttrStyle, Attribute, MetaItem};\n+use rustc_ast::{attr, AttrStyle, Attribute, MetaItem};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_feature::AttributeTemplate;\n use rustc_lint_defs::builtin::DUPLICATE_MACRO_ATTRIBUTES;\n@@ -36,7 +36,7 @@ pub fn warn_on_duplicate_attribute(ecx: &ExtCtxt<'_>, item: &Annotatable, name:\n         _ => None,\n     };\n     if let Some(attrs) = attrs {\n-        if let Some(attr) = ecx.sess.find_by_name(attrs, name) {\n+        if let Some(attr) = attr::find_by_name(attrs, name) {\n             ecx.parse_sess().buffer_lint(\n                 DUPLICATE_MACRO_ATTRIBUTES,\n                 attr.span,"}, {"sha": "5f5510a579654afa30a0260b128800fd0018ad61", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/abi-cafe.yml", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fabi-cafe.yml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,64 @@\n+name: Abi-cafe\n+\n+on:\n+  - push\n+\n+jobs:\n+  abi_cafe:\n+    runs-on: ${{ matrix.os }}\n+    timeout-minutes: 60\n+    concurrency:\n+      group: ${{ github.workflow }}-${{ github.ref }}-${{ matrix.os }}-${{ matrix.env.TARGET_TRIPLE }}\n+      cancel-in-progress: true\n+\n+    defaults:\n+      run:\n+        shell: bash\n+\n+    strategy:\n+      fail-fast: true\n+      matrix:\n+        include:\n+          - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n+          - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: build/cg_clif\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n+\n+    - name: Use sparse cargo registry\n+      run: |\n+        cat >> ~/.cargo/config.toml <<EOF\n+        [unstable]\n+        sparse-registry = true\n+        EOF\n+\n+    - name: Prepare dependencies\n+      run: ./y.rs prepare\n+\n+    - name: Build\n+      run: ./y.rs build --sysroot none\n+\n+    - name: Test abi-cafe\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      run: ./y.rs abi-cafe"}, {"sha": "98b34c65dea591284f9d30e7fb7c541891578fd3", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -22,7 +22,7 @@ jobs:\n         rustfmt --check build_system/mod.rs\n \n \n-  build:\n+  test:\n     runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n@@ -114,63 +114,6 @@ jobs:\n       run: ./y.rs test\n \n \n-  abi_cafe:\n-    runs-on: ${{ matrix.os }}\n-    timeout-minutes: 60\n-\n-    defaults:\n-      run:\n-        shell: bash\n-\n-    strategy:\n-      fail-fast: true\n-      matrix:\n-        include:\n-          - os: ubuntu-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n-          - os: macos-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-apple-darwin\n-          - os: windows-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-pc-windows-msvc\n-          - os: windows-latest\n-            env:\n-              TARGET_TRIPLE: x86_64-pc-windows-gnu\n-\n-    steps:\n-    - uses: actions/checkout@v3\n-\n-    - name: Cache cargo target dir\n-      uses: actions/cache@v3\n-      with:\n-        path: build/cg_clif\n-        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n-\n-    - name: Set MinGW as the default toolchain\n-      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n-      run: rustup set default-host x86_64-pc-windows-gnu\n-\n-    - name: Use sparse cargo registry\n-      run: |\n-        cat >> ~/.cargo/config.toml <<EOF\n-        [unstable]\n-        sparse-registry = true\n-        EOF\n-\n-    - name: Prepare dependencies\n-      run: ./y.rs prepare\n-\n-    - name: Build\n-      run: ./y.rs build --sysroot none\n-\n-    - name: Test abi-cafe\n-      env:\n-        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n-      run: ./y.rs abi-cafe\n-\n-\n   bench:\n     runs-on: ubuntu-latest\n     timeout-minutes: 60"}, {"sha": "e5d10a937ae2497a7deb53af1554123c846cce8e", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -14,3 +14,4 @@ perf.data.old\n /dist\n /rust\n /download\n+/git-fixed-subtree.sh"}, {"sha": "157ef4bf3892ecb9ddaba4e22cedad0baf3f9a4b", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -57,18 +57,18 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f3d54eab028f5805ae3b26fd60eca3f3a9cfb76b989d9bab173be3f61356cc3\"\n+checksum = \"a7379abaacee0f14abf3204a7606118f0465785252169d186337bcb75030815a\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2be1d5f2c3cca1efb691844bc1988b89c77291f13f778499a3f3c0cf49c0ed61\"\n+checksum = \"9489fa336927df749631f1008007ced2871068544f40a202ce6d93fbf2366a7b\"\n dependencies = [\n  \"arrayvec\",\n  \"bumpalo\",\n@@ -87,30 +87,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f9b1b1089750ce4005893af7ee00bb08a2cf1c9779999c0f7164cbc8ad2e0d2\"\n+checksum = \"05bbb67da91ec721ed57cef2f7c5ef7728e1cd9bde9ffd3ef8601022e73e3239\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cc5fbaec51de47297fd7304986fd53c8c0030abbe69728a60d72e1c63559318d\"\n+checksum = \"418ecb2f36032f6665dc1a5e2060a143dbab41d83b784882e97710e890a7a16d\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dab984c94593f876090fae92e984bdcc74d9b1acf740ab5f79036001c65cba13\"\n+checksum = \"7cf583f7b093f291005f9fb1323e2c37f6ee4c7909e39ce016b2e8360d461705\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6e0cb3102d21a2fe5f3210af608748ddd0cd09825ac12d42dc56ed5ed8725fe0\"\n+checksum = \"7d361ed0373cf5f086b49c499aa72227b646a64f899f32e34312f97c0fadff75\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -120,15 +120,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.92.0\"\n+version = \"0.93.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72101dd1f441d629735143c41e00b3428f9267738176983ef588ff43382af0a0\"\n+checksum = \"649782a39ce99798dd6b4029e2bb318a2fbeaade1b4fa25330763c10c65bc358\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6557f8ce44d498777f2495aa58d9692a4a37d6f84aa445750d666cef770b6a5c\"\n+checksum = \"9c9909222db472fcc98d9e4e7192fa9d064dac63a3fa657df8c6daae86fb2604\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -145,19 +145,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"88807e1c0c47ec02fe433333ccbe56b480425418b1470e333205e11650697d72\"\n+checksum = \"68689b83e52e605ba48652882d3fccc2e2e136abf139eb64ae667888ba0d52f8\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c22b0d9fcbe3fc5a1af9e7021b44ce42b930bcefac446ce22e02e8f9a0d67120\"\n+checksum = \"f98e4e99a353703475d5acb402b9c13482d41d8a4008b352559bd560afb90363\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -166,9 +166,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.92.0\"\n+version = \"0.93.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"341375758d7c3fedc0b5315f552e6f0feac46baf87c450a15e9455ef47c2b261\"\n+checksum = \"b7a006ce1d8dd11df67567d8673e5920f3a56441812aed52a007ffce8f1b20e9\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -333,6 +333,7 @@ dependencies = [\n  \"cranelift-frontend\",\n  \"cranelift-jit\",\n  \"cranelift-module\",\n+ \"cranelift-native\",\n  \"cranelift-object\",\n  \"gimli\",\n  \"indexmap\",\n@@ -381,9 +382,9 @@ checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n \n [[package]]\n name = \"wasmtime-jit-icache-coherence\"\n-version = \"5.0.0\"\n+version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"08fcba5ebd96da2a9f0747ab6337fe9788adfb3f63fa2c180520d665562d257e\"\n+checksum = \"ec1fd0f0dd79e7cc0f55b102e320d7c77ab76cd272008a8fd98e25b5777e2636\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\","}, {"sha": "0e64fba6bec8db017c3b5f85d2918404a4fc96d1", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -15,14 +15,12 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.92\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = { version = \"0.92\" }\n-cranelift-module = { version = \"0.92\" }\n-# NOTE vendored as src/cranelift_native.rs\n-# FIXME revert back to the external crate with Cranelift 0.93\n-#cranelift-native = { version = \"0.92\" }\n-cranelift-jit = { version = \"0.92\", optional = true }\n-cranelift-object = { version = \"0.92\" }\n+cranelift-codegen = { version = \"0.93\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = { version = \"0.93\" }\n+cranelift-module = { version = \"0.93\" }\n+cranelift-native = { version = \"0.93\" }\n+cranelift-jit = { version = \"0.93\", optional = true }\n+cranelift-object = { version = \"0.93\" }\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }"}, {"sha": "f21507629911ad01d0864bd1f169fe548ba4109e", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.86\"\n+version = \"0.1.89\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5dae98c88e576098d7ab13ebcb40cc43e5114b2beafe61a87cda9200649ff205\"\n+checksum = \"9fc9c2080d347a2c316518840ac9194644a9993dfa1e9778ef38979a339f5d8b\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -117,21 +117,20 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.6\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n+checksum = \"fed44880c466736ef9a5c5b5facefb5ed0785676d0c02d612db14e54f0d84286\"\n dependencies = [\n  \"compiler_builtins\",\n- \"libc\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.139\"\n+version = \"0.2.140\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n+checksum = \"99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -282,10 +281,8 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n  \"core\",\n  \"getopts\",\n- \"libc\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"proc_macro\","}, {"sha": "8219e6b6ccf3bca19d613a2b7331639a30a8d7e1", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -8,7 +8,7 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-compiler_builtins = { version = \"0.1.39\", default-features = false, features = [\"no-asm\"] }\n+compiler_builtins = { version = \"0.1.87\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }"}, {"sha": "76b602fe7196326f9949430b549669862e9a0766", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -46,13 +46,15 @@ pub(crate) fn build_sysroot(\n         let wrapper_name = wrapper_base_name.replace(\"____\", wrapper);\n \n         let mut build_cargo_wrapper_cmd = Command::new(&bootstrap_host_compiler.rustc);\n+        let wrapper_path = DIST_DIR.to_path(dirs).join(&wrapper_name);\n         build_cargo_wrapper_cmd\n             .env(\"TOOLCHAIN_NAME\", toolchain_name.clone())\n             .arg(RelPath::SCRIPTS.to_path(dirs).join(&format!(\"{wrapper}.rs\")))\n             .arg(\"-o\")\n-            .arg(DIST_DIR.to_path(dirs).join(wrapper_name))\n+            .arg(&wrapper_path)\n             .arg(\"-Cstrip=debuginfo\");\n         spawn_and_wait(build_cargo_wrapper_cmd);\n+        try_hard_link(wrapper_path, BIN_DIR.to_path(dirs).join(wrapper_name));\n     }\n \n     let host = build_sysroot_for_triple(\n@@ -247,6 +249,7 @@ fn build_clif_sysroot_for_triple(\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n     }\n+    build_cmd.arg(\"--locked\");\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     if compiler.triple.contains(\"apple\") {\n         build_cmd.env(\"CARGO_PROFILE_RELEASE_SPLIT_DEBUGINFO\", \"packed\");"}, {"sha": "6769e42d44b94181f427210c803616f2e2b8f31e", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -6,15 +6,18 @@ use std::process::Command;\n use super::build_sysroot::{BUILD_SYSROOT, ORIG_BUILD_SYSROOT, SYSROOT_RUSTC_VERSION, SYSROOT_SRC};\n use super::path::{Dirs, RelPath};\n use super::rustc_info::{get_default_sysroot, get_rustc_version};\n+use super::tests::LIBCORE_TESTS_SRC;\n use super::utils::{copy_dir_recursively, git_command, retry_spawn_and_wait, spawn_and_wait};\n \n pub(crate) fn prepare(dirs: &Dirs) {\n     RelPath::DOWNLOAD.ensure_fresh(dirs);\n \n     spawn_and_wait(super::build_backend::CG_CLIF.fetch(\"cargo\", \"rustc\", dirs));\n \n-    prepare_sysroot(dirs);\n+    prepare_stdlib(dirs);\n     spawn_and_wait(super::build_sysroot::STANDARD_LIBRARY.fetch(\"cargo\", \"rustc\", dirs));\n+\n+    prepare_coretests(dirs);\n     spawn_and_wait(super::tests::LIBCORE_TESTS.fetch(\"cargo\", \"rustc\", dirs));\n \n     super::tests::RAND_REPO.fetch(dirs);\n@@ -25,11 +28,11 @@ pub(crate) fn prepare(dirs: &Dirs) {\n     spawn_and_wait(super::tests::PORTABLE_SIMD.fetch(\"cargo\", \"rustc\", dirs));\n }\n \n-fn prepare_sysroot(dirs: &Dirs) {\n+fn prepare_stdlib(dirs: &Dirs) {\n     let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n     assert!(sysroot_src_orig.exists());\n \n-    eprintln!(\"[COPY] sysroot src\");\n+    eprintln!(\"[COPY] stdlib src\");\n \n     // FIXME ensure builds error out or update the copy if any of the files copied here change\n     BUILD_SYSROOT.ensure_fresh(dirs);\n@@ -47,7 +50,25 @@ fn prepare_sysroot(dirs: &Dirs) {\n     eprintln!(\"[GIT] init\");\n     init_git_repo(&SYSROOT_SRC.to_path(dirs));\n \n-    apply_patches(dirs, \"sysroot\", &SYSROOT_SRC.to_path(dirs));\n+    apply_patches(dirs, \"stdlib\", &SYSROOT_SRC.to_path(dirs));\n+}\n+\n+fn prepare_coretests(dirs: &Dirs) {\n+    let sysroot_src_orig = get_default_sysroot(Path::new(\"rustc\")).join(\"lib/rustlib/src/rust\");\n+    assert!(sysroot_src_orig.exists());\n+\n+    eprintln!(\"[COPY] coretests src\");\n+\n+    fs::create_dir_all(LIBCORE_TESTS_SRC.to_path(dirs)).unwrap();\n+    copy_dir_recursively(\n+        &sysroot_src_orig.join(\"library/core/tests\"),\n+        &LIBCORE_TESTS_SRC.to_path(dirs),\n+    );\n+\n+    eprintln!(\"[GIT] init\");\n+    init_git_repo(&LIBCORE_TESTS_SRC.to_path(dirs));\n+\n+    apply_patches(dirs, \"coretests\", &LIBCORE_TESTS_SRC.to_path(dirs));\n }\n \n pub(crate) struct GitRepo {"}, {"sha": "261948a6971375f534935991d7f27d27e1209639", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,4 +1,4 @@\n-use super::build_sysroot::{self, SYSROOT_SRC};\n+use super::build_sysroot;\n use super::config;\n use super::path::{Dirs, RelPath};\n use super::prepare::GitRepo;\n@@ -94,40 +94,42 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::build_bin_and_run(\"aot.issue-72793\", \"example/issue-72793.rs\", &[]),\n ];\n \n+// FIXME(rust-random/rand#1293): Newer rand versions fail to test on Windows. Update once this is\n+// fixed.\n pub(crate) static RAND_REPO: GitRepo =\n-    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+    GitRepo::github(\"rust-random\", \"rand\", \"50b9a447410860af8d6db9a208c3576886955874\", \"rand\");\n \n pub(crate) static RAND: CargoProject = CargoProject::new(&RAND_REPO.source_dir(), \"rand\");\n \n pub(crate) static REGEX_REPO: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+    GitRepo::github(\"rust-lang\", \"regex\", \"a9b2e02352db92ce1f6e5b7ecd41b8bbffbe161a\", \"regex\");\n \n pub(crate) static REGEX: CargoProject = CargoProject::new(&REGEX_REPO.source_dir(), \"regex\");\n \n pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n     \"rust-lang\",\n     \"portable-simd\",\n-    \"582239ac3b32007613df04d7ffa78dc30f4c5645\",\n+    \"9bd30e77b3a3c699af102ebb3df0f6110f8aa02e\",\n     \"portable-simd\",\n );\n \n pub(crate) static PORTABLE_SIMD: CargoProject =\n     CargoProject::new(&PORTABLE_SIMD_REPO.source_dir(), \"portable_simd\");\n \n-pub(crate) static LIBCORE_TESTS: CargoProject =\n-    CargoProject::new(&SYSROOT_SRC.join(\"library/core/tests\"), \"core_tests\");\n+pub(crate) static LIBCORE_TESTS_SRC: RelPath = RelPath::DOWNLOAD.join(\"coretests_src\");\n+\n+pub(crate) static LIBCORE_TESTS: CargoProject = CargoProject::new(&LIBCORE_TESTS_SRC, \"core_tests\");\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.rust-random/rand\", &|runner| {\n         RAND.clean(&runner.dirs);\n \n         if runner.is_native {\n-            eprintln!(\"[TEST] rust-random/rand\");\n             let mut test_cmd = RAND.test(&runner.target_compiler, &runner.dirs);\n-            test_cmd.arg(\"--workspace\");\n+            test_cmd.arg(\"--workspace\").arg(\"--\").arg(\"-q\");\n             spawn_and_wait(test_cmd);\n         } else {\n-            eprintln!(\"[AOT] rust-random/rand\");\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = RAND.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--workspace\").arg(\"--tests\");\n             spawn_and_wait(build_cmd);\n@@ -137,7 +139,9 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n         LIBCORE_TESTS.clean(&runner.dirs);\n \n         if runner.is_native {\n-            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs));\n+            let mut test_cmd = LIBCORE_TESTS.test(&runner.target_compiler, &runner.dirs);\n+            test_cmd.arg(\"--\").arg(\"-q\");\n+            spawn_and_wait(test_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler, &runner.dirs);\n@@ -148,18 +152,13 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.regex-shootout-regex-dna\", &|runner| {\n         REGEX.clean(&runner.dirs);\n \n-        // newer aho_corasick versions throw a deprecation warning\n-        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n-\n         let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n         build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n-        build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n         spawn_and_wait(build_cmd);\n \n         if runner.is_native {\n             let mut run_cmd = REGEX.run(&runner.target_compiler, &runner.dirs);\n             run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n-            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n             let input = fs::read_to_string(\n                 REGEX.source_dir(&runner.dirs).join(\"examples\").join(\"regexdna-input.txt\"),\n@@ -171,13 +170,6 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n             .unwrap();\n \n             let output = spawn_and_wait_with_input(run_cmd, input);\n-            // Make sure `[codegen mono items] start` doesn't poison the diff\n-            let output = output\n-                .lines()\n-                .filter(|line| !line.contains(\"codegen mono items\"))\n-                .chain(Some(\"\")) // This just adds the trailing newline\n-                .collect::<Vec<&str>>()\n-                .join(\"\\r\\n\");\n \n             let output_matches = expected.lines().eq(output.lines());\n             if !output_matches {\n@@ -192,27 +184,14 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::custom(\"test.regex\", &|runner| {\n         REGEX.clean(&runner.dirs);\n \n-        // newer aho_corasick versions throw a deprecation warning\n-        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n-\n         if runner.is_native {\n             let mut run_cmd = REGEX.test(&runner.target_compiler, &runner.dirs);\n-            run_cmd.args([\n-                \"--tests\",\n-                \"--\",\n-                \"--exclude-should-panic\",\n-                \"--test-threads\",\n-                \"1\",\n-                \"-Zunstable-options\",\n-                \"-q\",\n-            ]);\n-            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+            run_cmd.args([\"--workspace\", \"--\", \"-q\"]);\n             spawn_and_wait(run_cmd);\n         } else {\n             eprintln!(\"Cross-Compiling: Not running tests\");\n             let mut build_cmd = REGEX.build(&runner.target_compiler, &runner.dirs);\n             build_cmd.arg(\"--tests\");\n-            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n             spawn_and_wait(build_cmd);\n         }\n     }),"}, {"sha": "4ede2fe4efe82777918ed7cebcefbfe13137872d", "filename": "compiler/rustc_codegen_cranelift/example/alloc_example.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_example.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, core_intrinsics, alloc_error_handler, box_syntax)]\n+#![feature(start, core_intrinsics, alloc_error_handler)]\n #![no_std]\n \n extern crate alloc;\n@@ -29,7 +29,7 @@ fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n \n #[start]\n fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    let world: Box<&str> = box \"Hello World!\\0\";\n+    let world: Box<&str> = Box::new(\"Hello World!\\0\");\n     unsafe {\n         puts(*world as *const str as *const u8);\n     }"}, {"sha": "e64daf96b01c92f26dac3a49d21adc43dc6d8975", "filename": "compiler/rustc_codegen_cranelift/example/alloc_system.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Falloc_system.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,12 +1,6 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// SPDX-License-Identifier: MIT OR Apache-2.0\n+// SPDX-FileCopyrightText: The Rust Project Developers (see https://thanks.rust-lang.org)\n+\n #![no_std]\n \n pub struct System;"}, {"sha": "73b83b89f6d91ea3358c15a5e8cc49354ac62d4a", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -518,6 +518,17 @@ pub struct Box<T: ?Sized>(Unique<T>, ());\n \n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n+impl<T> Box<T> {\n+    pub fn new(val: T) -> Box<T> {\n+        unsafe {\n+            let size = intrinsics::size_of::<T>();\n+            let ptr = libc::malloc(size);\n+            intrinsics::copy(&val as *const T as *const u8, ptr, size);\n+            Box(Unique { pointer: NonNull(ptr as *const T), _marker: PhantomData }, ())\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Drop for Box<T> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler."}, {"sha": "6ad3268e70dd229278b33c6b7e66e2697ace038e", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 301, "deletions": 82, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,16 +1,16 @@\n-#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local, box_syntax)]\n+#![feature(no_core, lang_items, never_type, linkage, extern_types, thread_local, repr_simd)]\n #![no_core]\n #![allow(dead_code, non_camel_case_types)]\n \n extern crate mini_core;\n \n-use mini_core::*;\n use mini_core::libc::*;\n+use mini_core::*;\n \n macro_rules! assert {\n     ($e:expr) => {\n         if !$e {\n-            panic(stringify!(! $e));\n+            panic(stringify!(!$e));\n         }\n     };\n }\n@@ -20,7 +20,7 @@ macro_rules! assert_eq {\n         if $l != $r {\n             panic(stringify!($l != $r));\n         }\n-    }\n+    };\n }\n \n #[lang = \"termination\"]\n@@ -96,9 +96,15 @@ fn start<T: Termination + 'static>(\n     _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n-        unsafe { puts(*argv as *const i8); }\n-        unsafe { puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n-        unsafe { puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8)); }\n+        unsafe {\n+            puts(*argv as *const i8);\n+        }\n+        unsafe {\n+            puts(*((argv as usize + intrinsics::size_of::<*const u8>()) as *const *const i8));\n+        }\n+        unsafe {\n+            puts(*((argv as usize + 2 * intrinsics::size_of::<*const u8>()) as *const *const i8));\n+        }\n     }\n \n     main().report() as isize\n@@ -107,7 +113,6 @@ fn start<T: Termination + 'static>(\n static mut NUM: u8 = 6 * 7;\n static NUM_REF: &'static u8 = unsafe { &NUM };\n \n-\n unsafe fn zeroed<T>() -> T {\n     let mut uninit = MaybeUninit { uninit: () };\n     intrinsics::write_bytes(&mut uninit.value.value as *mut T, 0, 1);\n@@ -144,10 +149,7 @@ extern \"C\" fn bool_struct_in_11(_arg0: bool_11) {}\n \n #[allow(unreachable_code)] // FIXME false positive\n fn main() {\n-    take_unique(Unique {\n-        pointer: unsafe { NonNull(1 as *mut ()) },\n-        _marker: PhantomData,\n-    });\n+    take_unique(Unique { pointer: unsafe { NonNull(1 as *mut ()) }, _marker: PhantomData });\n     take_f32(0.1);\n \n     call_return_u128_pair();\n@@ -178,7 +180,7 @@ fn main() {\n         let ptr: *const i8 = hello as *const [u8] as *const i8;\n         puts(ptr);\n \n-        let world: Box<&str> = box \"World!\\0\";\n+        let world: Box<&str> = Box::new(\"World!\\0\");\n         puts(*world as *const str as *const i8);\n         world as Box<dyn SomeTrait>;\n \n@@ -202,17 +204,17 @@ fn main() {\n         assert_eq!(intrinsics::size_of_val(&0u32) as u8, 4);\n \n         assert_eq!(intrinsics::min_align_of::<u16>() as u8, 2);\n-        assert_eq!(intrinsics::min_align_of_val(&a) as u8, intrinsics::min_align_of::<&str>() as u8);\n+        assert_eq!(\n+            intrinsics::min_align_of_val(&a) as u8,\n+            intrinsics::min_align_of::<&str>() as u8\n+        );\n \n         assert!(!intrinsics::needs_drop::<u8>());\n         assert!(!intrinsics::needs_drop::<[u8]>());\n         assert!(intrinsics::needs_drop::<NoisyDrop>());\n         assert!(intrinsics::needs_drop::<NoisyDropUnsized>());\n \n-        Unique {\n-            pointer: NonNull(1 as *mut &str),\n-            _marker: PhantomData,\n-        } as Unique<dyn SomeTrait>;\n+        Unique { pointer: NonNull(1 as *mut &str), _marker: PhantomData } as Unique<dyn SomeTrait>;\n \n         struct MyDst<T: ?Sized>(T);\n \n@@ -238,19 +240,17 @@ fn main() {\n         }\n     }\n \n-    let _ = box NoisyDrop {\n-        text: \"Boxed outer got dropped!\\0\",\n-        inner: NoisyDropInner,\n-    } as Box<dyn SomeTrait>;\n+    let _ = Box::new(NoisyDrop { text: \"Boxed outer got dropped!\\0\", inner: NoisyDropInner })\n+        as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n     match FUNC_REF {\n-        Some(_) => {},\n+        Some(_) => {}\n         None => assert!(false),\n     }\n \n     match Ordering::Less {\n-        Ordering::Less => {},\n+        Ordering::Less => {}\n         _ => assert!(false),\n     }\n \n@@ -266,19 +266,21 @@ fn main() {\n \n     #[cfg(not(any(jit, windows)))]\n     {\n-        extern {\n+        extern \"C\" {\n             #[linkage = \"extern_weak\"]\n             static ABC: *const u8;\n         }\n \n         {\n-            extern {\n+            extern \"C\" {\n                 #[linkage = \"extern_weak\"]\n                 static ABC: *const u8;\n             }\n         }\n \n-        unsafe { assert_eq!(ABC as usize, 0); }\n+        unsafe {\n+            assert_eq!(ABC as usize, 0);\n+        }\n     }\n \n     &mut (|| Some(0 as *const ())) as &mut dyn FnMut() -> Option<*const ()>;\n@@ -339,7 +341,13 @@ fn main() {\n \n         assert_eq!(unsafe { intrinsics::size_of_val(x) }, 0);\n         assert_eq!(unsafe { intrinsics::min_align_of_val(x) }, 1);\n-}\n+    }\n+\n+    #[repr(simd)]\n+    struct V([f64; 2]);\n+\n+    let f = V([0.0, 1.0]);\n+    let _a = f.0[0];\n }\n \n #[cfg(all(not(jit), target_arch = \"x86_64\", any(target_os = \"linux\", target_os = \"darwin\")))]\n@@ -392,13 +400,10 @@ extern \"C\" {\n         native: *mut pthread_t,\n         attr: *const pthread_attr_t,\n         f: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n-        value: *mut c_void\n+        value: *mut c_void,\n     ) -> c_int;\n \n-    fn pthread_join(\n-        native: pthread_t,\n-        value: *mut *mut c_void\n-    ) -> c_int;\n+    fn pthread_join(native: pthread_t, value: *mut *mut c_void) -> c_int;\n }\n \n type DWORD = u32;\n@@ -410,18 +415,15 @@ type HANDLE = *mut c_void;\n #[link(name = \"msvcrt\")]\n #[cfg(windows)]\n extern \"C\" {\n-    fn WaitForSingleObject(\n-        hHandle: LPVOID,\n-        dwMilliseconds: DWORD\n-    ) -> DWORD;\n+    fn WaitForSingleObject(hHandle: LPVOID, dwMilliseconds: DWORD) -> DWORD;\n \n     fn CreateThread(\n         lpThreadAttributes: LPVOID, // Technically LPSECURITY_ATTRIBUTES, but we don't use it anyway\n         dwStackSize: usize,\n         lpStartAddress: extern \"C\" fn(_: *mut c_void) -> *mut c_void,\n         lpParameter: LPVOID,\n         dwCreationFlags: DWORD,\n-        lpThreadId: LPDWORD\n+        lpThreadId: LPDWORD,\n     ) -> HANDLE;\n }\n \n@@ -447,9 +449,7 @@ impl Thread {\n                 assert!(false);\n             }\n \n-            Thread {\n-                handle: thread,\n-            }\n+            Thread { handle: thread }\n         }\n \n         #[cfg(windows)]\n@@ -460,13 +460,10 @@ impl Thread {\n                 assert!(false);\n             }\n \n-            Thread {\n-                handle,\n-            }\n+            Thread { handle }\n         }\n     }\n \n-\n     unsafe fn join(self) {\n         #[cfg(unix)]\n         {\n@@ -483,16 +480,15 @@ impl Thread {\n     }\n }\n \n-\n-\n-\n #[thread_local]\n #[cfg(not(jit))]\n static mut TLS: u8 = 42;\n \n #[cfg(not(jit))]\n extern \"C\" fn mutate_tls(_: *mut c_void) -> *mut c_void {\n-    unsafe { TLS = 0; }\n+    unsafe {\n+        TLS = 0;\n+    }\n     0 as *mut c_void\n }\n \n@@ -531,44 +527,267 @@ pub enum E1 {\n pub enum E2<X> {\n     V1 { f: bool },\n \n-    /*_00*/ _01(X), _02(X), _03(X), _04(X), _05(X), _06(X), _07(X),\n-    _08(X), _09(X), _0A(X), _0B(X), _0C(X), _0D(X), _0E(X), _0F(X),\n-    _10(X), _11(X), _12(X), _13(X), _14(X), _15(X), _16(X), _17(X),\n-    _18(X), _19(X), _1A(X), _1B(X), _1C(X), _1D(X), _1E(X), _1F(X),\n-    _20(X), _21(X), _22(X), _23(X), _24(X), _25(X), _26(X), _27(X),\n-    _28(X), _29(X), _2A(X), _2B(X), _2C(X), _2D(X), _2E(X), _2F(X),\n-    _30(X), _31(X), _32(X), _33(X), _34(X), _35(X), _36(X), _37(X),\n-    _38(X), _39(X), _3A(X), _3B(X), _3C(X), _3D(X), _3E(X), _3F(X),\n-    _40(X), _41(X), _42(X), _43(X), _44(X), _45(X), _46(X), _47(X),\n-    _48(X), _49(X), _4A(X), _4B(X), _4C(X), _4D(X), _4E(X), _4F(X),\n-    _50(X), _51(X), _52(X), _53(X), _54(X), _55(X), _56(X), _57(X),\n-    _58(X), _59(X), _5A(X), _5B(X), _5C(X), _5D(X), _5E(X), _5F(X),\n-    _60(X), _61(X), _62(X), _63(X), _64(X), _65(X), _66(X), _67(X),\n-    _68(X), _69(X), _6A(X), _6B(X), _6C(X), _6D(X), _6E(X), _6F(X),\n-    _70(X), _71(X), _72(X), _73(X), _74(X), _75(X), _76(X), _77(X),\n-    _78(X), _79(X), _7A(X), _7B(X), _7C(X), _7D(X), _7E(X), _7F(X),\n-    _80(X), _81(X), _82(X), _83(X), _84(X), _85(X), _86(X), _87(X),\n-    _88(X), _89(X), _8A(X), _8B(X), _8C(X), _8D(X), _8E(X), _8F(X),\n-    _90(X), _91(X), _92(X), _93(X), _94(X), _95(X), _96(X), _97(X),\n-    _98(X), _99(X), _9A(X), _9B(X), _9C(X), _9D(X), _9E(X), _9F(X),\n-    _A0(X), _A1(X), _A2(X), _A3(X), _A4(X), _A5(X), _A6(X), _A7(X),\n-    _A8(X), _A9(X), _AA(X), _AB(X), _AC(X), _AD(X), _AE(X), _AF(X),\n-    _B0(X), _B1(X), _B2(X), _B3(X), _B4(X), _B5(X), _B6(X), _B7(X),\n-    _B8(X), _B9(X), _BA(X), _BB(X), _BC(X), _BD(X), _BE(X), _BF(X),\n-    _C0(X), _C1(X), _C2(X), _C3(X), _C4(X), _C5(X), _C6(X), _C7(X),\n-    _C8(X), _C9(X), _CA(X), _CB(X), _CC(X), _CD(X), _CE(X), _CF(X),\n-    _D0(X), _D1(X), _D2(X), _D3(X), _D4(X), _D5(X), _D6(X), _D7(X),\n-    _D8(X), _D9(X), _DA(X), _DB(X), _DC(X), _DD(X), _DE(X), _DF(X),\n-    _E0(X), _E1(X), _E2(X), _E3(X), _E4(X), _E5(X), _E6(X), _E7(X),\n-    _E8(X), _E9(X), _EA(X), _EB(X), _EC(X), _ED(X), _EE(X), _EF(X),\n-    _F0(X), _F1(X), _F2(X), _F3(X), _F4(X), _F5(X), _F6(X), _F7(X),\n-    _F8(X), _F9(X), _FA(X), _FB(X), _FC(X), _FD(X), _FE(X), _FF(X),\n+    /*_00*/ _01(X),\n+    _02(X),\n+    _03(X),\n+    _04(X),\n+    _05(X),\n+    _06(X),\n+    _07(X),\n+    _08(X),\n+    _09(X),\n+    _0A(X),\n+    _0B(X),\n+    _0C(X),\n+    _0D(X),\n+    _0E(X),\n+    _0F(X),\n+    _10(X),\n+    _11(X),\n+    _12(X),\n+    _13(X),\n+    _14(X),\n+    _15(X),\n+    _16(X),\n+    _17(X),\n+    _18(X),\n+    _19(X),\n+    _1A(X),\n+    _1B(X),\n+    _1C(X),\n+    _1D(X),\n+    _1E(X),\n+    _1F(X),\n+    _20(X),\n+    _21(X),\n+    _22(X),\n+    _23(X),\n+    _24(X),\n+    _25(X),\n+    _26(X),\n+    _27(X),\n+    _28(X),\n+    _29(X),\n+    _2A(X),\n+    _2B(X),\n+    _2C(X),\n+    _2D(X),\n+    _2E(X),\n+    _2F(X),\n+    _30(X),\n+    _31(X),\n+    _32(X),\n+    _33(X),\n+    _34(X),\n+    _35(X),\n+    _36(X),\n+    _37(X),\n+    _38(X),\n+    _39(X),\n+    _3A(X),\n+    _3B(X),\n+    _3C(X),\n+    _3D(X),\n+    _3E(X),\n+    _3F(X),\n+    _40(X),\n+    _41(X),\n+    _42(X),\n+    _43(X),\n+    _44(X),\n+    _45(X),\n+    _46(X),\n+    _47(X),\n+    _48(X),\n+    _49(X),\n+    _4A(X),\n+    _4B(X),\n+    _4C(X),\n+    _4D(X),\n+    _4E(X),\n+    _4F(X),\n+    _50(X),\n+    _51(X),\n+    _52(X),\n+    _53(X),\n+    _54(X),\n+    _55(X),\n+    _56(X),\n+    _57(X),\n+    _58(X),\n+    _59(X),\n+    _5A(X),\n+    _5B(X),\n+    _5C(X),\n+    _5D(X),\n+    _5E(X),\n+    _5F(X),\n+    _60(X),\n+    _61(X),\n+    _62(X),\n+    _63(X),\n+    _64(X),\n+    _65(X),\n+    _66(X),\n+    _67(X),\n+    _68(X),\n+    _69(X),\n+    _6A(X),\n+    _6B(X),\n+    _6C(X),\n+    _6D(X),\n+    _6E(X),\n+    _6F(X),\n+    _70(X),\n+    _71(X),\n+    _72(X),\n+    _73(X),\n+    _74(X),\n+    _75(X),\n+    _76(X),\n+    _77(X),\n+    _78(X),\n+    _79(X),\n+    _7A(X),\n+    _7B(X),\n+    _7C(X),\n+    _7D(X),\n+    _7E(X),\n+    _7F(X),\n+    _80(X),\n+    _81(X),\n+    _82(X),\n+    _83(X),\n+    _84(X),\n+    _85(X),\n+    _86(X),\n+    _87(X),\n+    _88(X),\n+    _89(X),\n+    _8A(X),\n+    _8B(X),\n+    _8C(X),\n+    _8D(X),\n+    _8E(X),\n+    _8F(X),\n+    _90(X),\n+    _91(X),\n+    _92(X),\n+    _93(X),\n+    _94(X),\n+    _95(X),\n+    _96(X),\n+    _97(X),\n+    _98(X),\n+    _99(X),\n+    _9A(X),\n+    _9B(X),\n+    _9C(X),\n+    _9D(X),\n+    _9E(X),\n+    _9F(X),\n+    _A0(X),\n+    _A1(X),\n+    _A2(X),\n+    _A3(X),\n+    _A4(X),\n+    _A5(X),\n+    _A6(X),\n+    _A7(X),\n+    _A8(X),\n+    _A9(X),\n+    _AA(X),\n+    _AB(X),\n+    _AC(X),\n+    _AD(X),\n+    _AE(X),\n+    _AF(X),\n+    _B0(X),\n+    _B1(X),\n+    _B2(X),\n+    _B3(X),\n+    _B4(X),\n+    _B5(X),\n+    _B6(X),\n+    _B7(X),\n+    _B8(X),\n+    _B9(X),\n+    _BA(X),\n+    _BB(X),\n+    _BC(X),\n+    _BD(X),\n+    _BE(X),\n+    _BF(X),\n+    _C0(X),\n+    _C1(X),\n+    _C2(X),\n+    _C3(X),\n+    _C4(X),\n+    _C5(X),\n+    _C6(X),\n+    _C7(X),\n+    _C8(X),\n+    _C9(X),\n+    _CA(X),\n+    _CB(X),\n+    _CC(X),\n+    _CD(X),\n+    _CE(X),\n+    _CF(X),\n+    _D0(X),\n+    _D1(X),\n+    _D2(X),\n+    _D3(X),\n+    _D4(X),\n+    _D5(X),\n+    _D6(X),\n+    _D7(X),\n+    _D8(X),\n+    _D9(X),\n+    _DA(X),\n+    _DB(X),\n+    _DC(X),\n+    _DD(X),\n+    _DE(X),\n+    _DF(X),\n+    _E0(X),\n+    _E1(X),\n+    _E2(X),\n+    _E3(X),\n+    _E4(X),\n+    _E5(X),\n+    _E6(X),\n+    _E7(X),\n+    _E8(X),\n+    _E9(X),\n+    _EA(X),\n+    _EB(X),\n+    _EC(X),\n+    _ED(X),\n+    _EE(X),\n+    _EF(X),\n+    _F0(X),\n+    _F1(X),\n+    _F2(X),\n+    _F3(X),\n+    _F4(X),\n+    _F5(X),\n+    _F6(X),\n+    _F7(X),\n+    _F8(X),\n+    _F9(X),\n+    _FA(X),\n+    _FB(X),\n+    _FC(X),\n+    _FD(X),\n+    _FE(X),\n+    _FF(X),\n \n     V3,\n     V4,\n }\n \n-fn check_niche_behavior () {\n+fn check_niche_behavior() {\n     if let E1::V2 { .. } = (E1::V1 { f: true }) {\n         intrinsics::abort();\n     }"}, {"sha": "e34b35d5c4a8c481253e4b51764fdaaf72babc79", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -58,8 +58,9 @@ fn main() {\n     assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n     assert_eq!(core::intrinsics::saturating_sub(0, -170141183460469231731687303715884105728i128), 170141183460469231731687303715884105727i128);\n \n-    let _d = 0i128.checked_div(2i128);\n-    let _d = 0u128.checked_div(2u128);\n+    std::hint::black_box(std::hint::black_box(7571400400375753350092698930310845914i128) * 10);\n+    assert!(0i128.checked_div(2i128).is_some());\n+    assert!(0u128.checked_div(2u128).is_some());\n     assert_eq!(1u128 + 2, 3);\n \n     assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);"}, {"sha": "eb452c5cd377268b031cee0a3890c3b625333ef5", "filename": "compiler/rustc_codegen_cranelift/patches/0003-rand-Disable-rand-tests-on-mingw.patch", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -19,8 +19,8 @@ index 217899e..9cedeb7 100644\n +    // This is broken on x86_64-pc-windows-gnu presumably due to a broken powf implementation\n +    #[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n      fn value_stability() {\n-         fn test_samples<F: Float + core::fmt::Debug, D: Distribution<F>>(\n-             distr: D, zero: F, expected: &[F],\n+         fn test_samples<F: Float + Debug + Display + LowerExp, D: Distribution<F>>(\n+             distr: D, thresh: F, expected: &[F],\n diff --git a/rand_distr/tests/value_stability.rs b/rand_distr/tests/value_stability.rs\n index 192ba74..0101ace 100644\n --- a/rand_distr/tests/value_stability.rs"}, {"sha": "6afa5c71fe51fa8cb16c78ff116d07292e35acef", "filename": "compiler/rustc_codegen_cranelift/patches/0022-coretests-Disable-not-compiling-tests.patch", "status": "renamed", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0022-coretests-Disable-not-compiling-tests.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -13,14 +13,14 @@ Subject: [PATCH] [core] Disable not compiling tests\n  6 files changed, 16 insertions(+), 1 deletion(-)\n  create mode 100644 library/core/tests/Cargo.toml\n \n-diff --git a/library/core/tests/Cargo.toml b/library/core/tests/Cargo.toml\n+diff --git a/Cargo.toml b/Cargo.toml\n new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n-+++ b/library/core/tests/Cargo.toml\n++++ b/Cargo.toml\n @@ -0,0 +1,12 @@\n +[package]\n-+name = \"core\"\n++name = \"coretests\"\n +version = \"0.0.0\"\n +edition = \"2021\"\n +\n@@ -31,5 +31,14 @@ index 0000000..46fd999\n +[dependencies]\n +rand = { version = \"0.8.5\", default-features = false }\n +rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/lib.rs b/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/lib.rs\n++++ b/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0022-sysroot-Disable-not-compiling-tests.patch"}, {"sha": "f2cb82751f0821ff857fe2ae0f229d5aca450501", "filename": "compiler/rustc_codegen_cranelift/patches/0023-coretests-Ignore-failing-tests.patch", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0023-coretests-Ignore-failing-tests.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -10,10 +10,10 @@ Subject: [PATCH] [core] Ignore failing tests\n  library/core/tests/time.rs       |  1 +\n  4 files changed, 18 insertions(+), 2 deletions(-)\n \n-diff --git a/library/core/tests/array.rs b/library/core/tests/array.rs\n+diff --git a/array.rs b/array.rs\n index 4bc44e9..8e3c7a4 100644\n---- a/library/core/tests/array.rs\n-+++ b/library/core/tests/array.rs\n+--- a/array.rs\n++++ b/array.rs\n @@ -242,6 +242,7 @@ fn iterator_drops() {\n      assert_eq!(i.get(), 5);\n  }\n@@ -46,10 +46,10 @@ index 4bc44e9..8e3c7a4 100644\n  \n  #[test]\n  fn cell_allows_array_cycle() {\n-diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n+diff --git a/atomic.rs b/atomic.rs\n index 13b12db..96fe4b9 100644\n---- a/library/core/tests/atomic.rs\n-+++ b/library/core/tests/atomic.rs\n+--- a/atomic.rs\n++++ b/atomic.rs\n @@ -185,6 +185,7 @@ fn ptr_bitops() {\n  }\n  ", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0023-sysroot-Ignore-failing-tests.patch"}, {"sha": "1d5479beddee915871f801c0892a4c2c25baf73d", "filename": "compiler/rustc_codegen_cranelift/patches/0027-coretests-128bit-atomic-operations.patch", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-coretests-128bit-atomic-operations.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,30 @@\n+From ad7ffe71baba46865f2e65266ab025920dfdc20b Mon Sep 17 00:00:00 2001\n+From: bjorn3 <bjorn3@users.noreply.github.com>\n+Date: Thu, 18 Feb 2021 18:45:28 +0100\n+Subject: [PATCH] Disable 128bit atomic operations\n+\n+Cranelift doesn't support them yet\n+---\n+ library/core/src/panic/unwind_safe.rs |  6 -----\n+ library/core/src/sync/atomic.rs       | 38 ---------------------------\n+ library/core/tests/atomic.rs          |  4 ---\n+ 4 files changed, 4 insertions(+), 50 deletions(-)\n+\n+diff --git a/atomic.rs b/atomic.rs\n+index b735957..ea728b6 100644\n+--- a/atomic.rs\n++++ b/atomic.rs\n+@@ -185,10 +185,6 @@ fn atomic_alignment() {\n+     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n+     #[cfg(target_has_atomic = \"64\")]\n+     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n+-    #[cfg(target_has_atomic = \"128\")]\n+-    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n+     #[cfg(target_has_atomic = \"ptr\")]\n+--\n+2.26.2.7.g19db9cfb68\n+"}, {"sha": "45f73f36b93171ddd2b32b2571666fd25674ced6", "filename": "compiler/rustc_codegen_cranelift/patches/0027-stdlib-128bit-atomic-operations.patch", "status": "renamed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0027-stdlib-128bit-atomic-operations.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -85,21 +85,6 @@ index d9de37e..8293fce 100644\n  \n  macro_rules! atomic_int_ptr_sized {\n      ( $($target_pointer_width:literal $align:literal)* ) => { $(\n-diff --git a/library/core/tests/atomic.rs b/library/core/tests/atomic.rs\n-index b735957..ea728b6 100644\n---- a/library/core/tests/atomic.rs\n-+++ b/library/core/tests/atomic.rs\n-@@ -185,10 +185,6 @@ fn atomic_alignment() {\n-     assert_eq!(align_of::<AtomicU64>(), size_of::<AtomicU64>());\n-     #[cfg(target_has_atomic = \"64\")]\n-     assert_eq!(align_of::<AtomicI64>(), size_of::<AtomicI64>());\n--    #[cfg(target_has_atomic = \"128\")]\n--    assert_eq!(align_of::<AtomicU128>(), size_of::<AtomicU128>());\n--    #[cfg(target_has_atomic = \"128\")]\n--    assert_eq!(align_of::<AtomicI128>(), size_of::<AtomicI128>());\n-     #[cfg(target_has_atomic = \"ptr\")]\n-     assert_eq!(align_of::<AtomicUsize>(), size_of::<AtomicUsize>());\n-     #[cfg(target_has_atomic = \"ptr\")]\n --\n 2.26.2.7.g19db9cfb68\n ", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0027-sysroot-128bit-atomic-operations.patch"}, {"sha": "440177018f428e66a124963332c13a9f328e3c9c", "filename": "compiler/rustc_codegen_cranelift/patches/0028-coretests-Disable-long-running-tests.patch", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0028-coretests-Disable-long-running-tests.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -7,10 +7,10 @@ Subject: [PATCH] Disable long running tests\n  library/core/tests/slice.rs | 2 ++\n  1 file changed, 2 insertions(+)\n \n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n+diff --git a/slice.rs b/slice.rs\n index 8402833..84592e0 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n+--- a/slice.rs\n++++ b/slice.rs\n @@ -1809,6 +1809,7 @@ fn sort_unstable() {\n      assert!(v == [0xDEADBEEF]);\n  }", "previous_filename": "compiler/rustc_codegen_cranelift/patches/0028-sysroot-Disable-long-running-tests.patch"}, {"sha": "2236a6ca15521cf1deb6ee9bb69bf07f92c346df", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2023-02-06\"\n+channel = \"nightly-2023-03-15\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "939a1f1ca59001a39feb12e643716b45cf704c5c", "filename": "compiler/rustc_codegen_cranelift/scripts/cargo-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fcargo-clif.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,11 +1,14 @@\n use std::env;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let mut rustflags = String::new();\n     rustflags.push_str(\" -Cpanic=abort -Zpanic-abort-tests -Zcodegen-backend=\");"}, {"sha": "b9bba7f2e084c8d50a43d5e1a760ee5bdb62b65c", "filename": "compiler/rustc_codegen_cranelift/scripts/rustc-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustc-clif.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -2,11 +2,14 @@ use std::env;\n use std::ffi::OsString;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,"}, {"sha": "167631eaf7ee49d5a8121760a9d686a71aa9186c", "filename": "compiler/rustc_codegen_cranelift/scripts/rustdoc-clif.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustdoc-clif.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -2,11 +2,14 @@ use std::env;\n use std::ffi::OsString;\n #[cfg(unix)]\n use std::os::unix::process::CommandExt;\n-use std::path::PathBuf;\n use std::process::Command;\n \n fn main() {\n-    let sysroot = PathBuf::from(env::current_exe().unwrap().parent().unwrap());\n+    let current_exe = env::current_exe().unwrap();\n+    let mut sysroot = current_exe.parent().unwrap();\n+    if sysroot.file_name().unwrap().to_str().unwrap() == \"bin\" {\n+        sysroot = sysroot.parent().unwrap();\n+    }\n \n     let cg_clif_dylib_path = sysroot.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n         env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,"}, {"sha": "3cbeb6375de109011fb29e3847f40173b188cae2", "filename": "compiler/rustc_codegen_cranelift/scripts/rustup.sh", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Frustup.sh?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -2,10 +2,24 @@\n \n set -e\n \n+TOOLCHAIN=${TOOLCHAIN:-$(date +%Y-%m-%d)}\n+\n+function check_git_fixed_subtree() {\n+    if [[ ! -e ./git-fixed-subtree.sh ]]; then\n+        echo \"Missing git-fixed-subtree.sh. Please run the following commands to download it:\"\n+        echo \"curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/bjorn3/git/tqc-subtree-portable/contrib/subtree/git-subtree.sh -o git-fixed-subtree.sh\"\n+        echo \"chmod u+x git-fixed-subtree.sh\"\n+        exit 1\n+    fi\n+    if [[ ! -x ./git-fixed-subtree.sh ]]; then\n+        echo \"git-fixed-subtree.sh is not executable. Please run the following command to make it executable:\"\n+        echo \"chmod u+x git-fixed-subtree.sh\"\n+        exit 1\n+    fi\n+}\n+\n case $1 in\n     \"prepare\")\n-        TOOLCHAIN=$(date +%Y-%m-%d)\n-\n         echo \"=> Installing new nightly\"\n         rustup toolchain install --profile minimal \"nightly-${TOOLCHAIN}\" # Sanity check to see if the nightly exists\n         sed -i \"s/\\\"nightly-.*\\\"/\\\"nightly-${TOOLCHAIN}\\\"/\" rust-toolchain\n@@ -27,28 +41,35 @@ case $1 in\n         git commit -m \"Rustup to $(rustc -V)\"\n         ;;\n     \"push\")\n+        check_git_fixed_subtree\n+\n         cg_clif=$(pwd)\n         pushd ../rust\n         git pull origin master\n         branch=sync_cg_clif-$(date +%Y-%m-%d)\n         git checkout -b \"$branch\"\n-        git subtree pull --prefix=compiler/rustc_codegen_cranelift/ https://github.com/bjorn3/rustc_codegen_cranelift.git master\n+        \"$cg_clif/git-fixed-subtree.sh\" pull --prefix=compiler/rustc_codegen_cranelift/ https://github.com/bjorn3/rustc_codegen_cranelift.git master\n         git push -u my \"$branch\"\n \n         # immediately merge the merge commit into cg_clif to prevent merge conflicts when syncing\n         # from rust-lang/rust later\n-        git subtree push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n+        \"$cg_clif/git-fixed-subtree.sh\" push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n         popd\n         git merge sync_from_rust\n \t;;\n     \"pull\")\n+        check_git_fixed_subtree\n+\n+        RUST_VERS=$(curl \"https://static.rust-lang.org/dist/$TOOLCHAIN/channel-rust-nightly-git-commit-hash.txt\")\n+        echo \"Pulling $RUST_VERS ($TOOLCHAIN)\"\n+\n         cg_clif=$(pwd)\n         pushd ../rust\n-        git pull origin master\n-        rust_vers=\"$(git rev-parse HEAD)\"\n-        git subtree push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n+        git fetch origin master\n+        git checkout \"$RUST_VERS\"\n+        \"$cg_clif/git-fixed-subtree.sh\" push --prefix=compiler/rustc_codegen_cranelift/ \"$cg_clif\" sync_from_rust\n         popd\n-        git merge sync_from_rust -m \"Sync from rust $rust_vers\"\n+        git merge sync_from_rust -m \"Sync from rust $RUST_VERS\"\n         git branch -d sync_from_rust\n         ;;\n     *)"}, {"sha": "abb09775d213511041756911473c75632643ef2a", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -10,7 +10,7 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n-git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-sysroot-*.patch\n+git -c user.name=Dummy -c user.email=dummy@example.com am ../patches/*-stdlib-*.patch\n \n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n@@ -36,7 +36,7 @@ changelog-seen = 2\n ninja = false\n \n [build]\n-rustc = \"$(pwd)/../dist/rustc-clif\"\n+rustc = \"$(pwd)/../dist/bin/rustc-clif\"\n cargo = \"$(rustup which cargo)\"\n full-bootstrap = true\n local-rebuild = true"}, {"sha": "20dcb4cf34d2f8a4e6d2c61f08fda116fa85ce90", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -21,6 +21,7 @@ done\n \n git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n git checkout -- tests/ui/proc-macro/pretty-print-hack/\n+rm tests/ui/parser/unclosed-delimiter-in-dep.rs # submodule contains //~ERROR\n \n # missing features\n # ================\n@@ -80,6 +81,7 @@ rm tests/ui/layout/valid_range_oob.rs # different ICE message\n \n rm tests/ui/consts/issue-miri-1910.rs # different error message\n rm tests/ui/consts/offset_ub.rs # same\n+rm tests/ui/consts/const-eval/ub-slice-get-unchecked.rs # same\n rm tests/ui/intrinsics/panic-uninitialized-zeroed.rs # same\n rm tests/ui/lint/lint-const-item-mutation.rs # same\n rm tests/ui/pattern/usefulness/doc-hidden-non-exhaustive.rs # same\n@@ -110,12 +112,9 @@ rm tests/incremental/spike-neg2.rs # same\n \n rm tests/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unordered doesn't accept an accumulator for integer vectors\n \n-rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type filed (#1318)\n+rm tests/ui/simd/intrinsic/generic-as.rs # crash when accessing vector type field (#1318)\n rm tests/ui/simd/simd-bitmask.rs # crash\n \n-rm tests/ui/dyn-star/dyn-star-to-dyn.rs\n-rm tests/ui/dyn-star/dispatch-on-pin-mut.rs\n-\n # bugs in the test suite\n # ======================\n rm tests/ui/backtrace.rs # TODO warning"}, {"sha": "3bc64c44524ed9c3e76e21df025d6a91541944ab", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -4,6 +4,8 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use std::borrow::Cow;\n+\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n@@ -25,7 +27,7 @@ fn clif_sig_from_fn_abi<'tcx>(\n ) -> Signature {\n     let call_conv = conv_to_call_conv(tcx.sess, fn_abi.conv, default_call_conv);\n \n-    let inputs = fn_abi.args.iter().map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter()).flatten();\n+    let inputs = fn_abi.args.iter().flat_map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter());\n \n     let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n     // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n@@ -116,7 +118,52 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         params: Vec<AbiParam>,\n         returns: Vec<AbiParam>,\n         args: &[Value],\n-    ) -> &[Value] {\n+    ) -> Cow<'_, [Value]> {\n+        if self.tcx.sess.target.is_like_windows {\n+            let (mut params, mut args): (Vec<_>, Vec<_>) =\n+                params\n+                    .into_iter()\n+                    .zip(args)\n+                    .map(|(param, &arg)| {\n+                        if param.value_type == types::I128 {\n+                            let arg_ptr = Pointer::stack_slot(self.bcx.create_sized_stack_slot(\n+                                StackSlotData { kind: StackSlotKind::ExplicitSlot, size: 16 },\n+                            ));\n+                            arg_ptr.store(self, arg, MemFlags::trusted());\n+                            (AbiParam::new(self.pointer_type), arg_ptr.get_addr(self))\n+                        } else {\n+                            (param, arg)\n+                        }\n+                    })\n+                    .unzip();\n+\n+            let indirect_ret_val = returns.len() == 1 && returns[0].value_type == types::I128;\n+\n+            if indirect_ret_val {\n+                params.insert(0, AbiParam::new(self.pointer_type));\n+                let ret_ptr =\n+                    Pointer::stack_slot(self.bcx.create_sized_stack_slot(StackSlotData {\n+                        kind: StackSlotKind::ExplicitSlot,\n+                        size: 16,\n+                    }));\n+                args.insert(0, ret_ptr.get_addr(self));\n+                self.lib_call_unadjusted(name, params, vec![], &args);\n+                return Cow::Owned(vec![ret_ptr.load(self, types::I128, MemFlags::trusted())]);\n+            } else {\n+                return self.lib_call_unadjusted(name, params, returns, &args);\n+            }\n+        }\n+\n+        self.lib_call_unadjusted(name, params, returns, args)\n+    }\n+\n+    pub(crate) fn lib_call_unadjusted(\n+        &mut self,\n+        name: &str,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n+        args: &[Value],\n+    ) -> Cow<'_, [Value]> {\n         let sig = Signature { params, returns, call_conv: self.target_config.default_call_conv };\n         let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n@@ -125,41 +172,11 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         }\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n-            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+            self.add_comment(call_inst, format!(\"lib_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n-        results\n-    }\n-\n-    pub(crate) fn easy_call(\n-        &mut self,\n-        name: &str,\n-        args: &[CValue<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> CValue<'tcx> {\n-        let (input_tys, args): (Vec<_>, Vec<_>) = args\n-            .iter()\n-            .map(|arg| {\n-                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n-            })\n-            .unzip();\n-        let return_layout = self.layout_of(return_ty);\n-        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.iter().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n-        } else {\n-            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n-        };\n-        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n-        match *ret_vals {\n-            [] => CValue::by_ref(\n-                Pointer::const_addr(self, i64::from(self.pointer_type.bytes())),\n-                return_layout,\n-            ),\n-            [val] => CValue::by_val(val, return_layout),\n-            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n-            _ => unreachable!(),\n-        }\n+        Cow::Borrowed(results)\n     }\n }\n \n@@ -275,10 +292,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n-        let layout = fx.layout_of(ty);\n-\n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n-\n         // While this is normally an optimization to prevent an unnecessary copy when an argument is\n         // not mutated by the current function, this is necessary to support unsized arguments.\n         if let ArgKind::Normal(Some(val)) = arg_kind {\n@@ -300,6 +313,8 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n             }\n         }\n \n+        let layout = fx.layout_of(ty);\n+        let is_ssa = ssa_analyzed[local].is_ssa(fx, ty);\n         let place = make_local_place(fx, local, layout, is_ssa);\n         assert_eq!(fx.local_map.push(place), local);\n \n@@ -323,7 +338,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n         let ty = fx.monomorphize(fx.mir.local_decls[local].ty);\n         let layout = fx.layout_of(ty);\n \n-        let is_ssa = ssa_analyzed[local] == crate::analyze::SsaKind::Ssa;\n+        let is_ssa = ssa_analyzed[local].is_ssa(fx, ty);\n \n         let place = make_local_place(fx, local, layout, is_ssa);\n         assert_eq!(fx.local_map.push(place), local);\n@@ -405,9 +420,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     };\n \n     let extra_args = &args[fn_sig.inputs().skip_binder().len()..];\n-    let extra_args = fx\n-        .tcx\n-        .mk_type_list(extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))));\n+    let extra_args = fx.tcx.mk_type_list_from_iter(\n+        extra_args.iter().map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx))),\n+    );\n     let fn_abi = if let Some(instance) = instance {\n         RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(instance, extra_args)\n     } else {\n@@ -515,10 +530,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 args.into_iter()\n                     .enumerate()\n                     .skip(if first_arg_override.is_some() { 1 } else { 0 })\n-                    .map(|(i, arg)| {\n+                    .flat_map(|(i, arg)| {\n                         adjust_arg_for_abi(fx, arg.value, &fn_abi.args[i], arg.is_owned).into_iter()\n-                    })\n-                    .flatten(),\n+                    }),\n             )\n             .collect::<Vec<Value>>();\n "}, {"sha": "6d3e8eda276a4e29127a9ac988fa35ba0105cd73", "filename": "compiler/rustc_codegen_cranelift/src/abi/returning.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Freturning.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -14,7 +14,8 @@ pub(super) fn codegen_return_param<'tcx>(\n ) -> CPlace<'tcx> {\n     let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n         PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(..) => {\n-            let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n+            let is_ssa =\n+                ssa_analyzed[RETURN_PLACE].is_ssa(fx, fx.fn_abi.as_ref().unwrap().ret.layout.ty);\n             (\n                 super::make_local_place(\n                     fx,"}, {"sha": "2c246ceb37d54fa43940774b79a359f39c346da3", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -4,6 +4,7 @@\n use crate::prelude::*;\n \n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_codegen_ssa::base::allocator_kind_for_codegen;\n use rustc_session::config::OomStrategy;\n use rustc_span::symbol::sym;\n \n@@ -13,24 +14,15 @@ pub(crate) fn codegen(\n     module: &mut impl Module,\n     unwind_context: &mut UnwindContext,\n ) -> bool {\n-    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n-        use rustc_middle::middle::dependency_format::Linkage;\n-        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-    });\n-    if any_dynamic_crate {\n-        false\n-    } else if let Some(kind) = tcx.allocator_kind(()) {\n-        codegen_inner(\n-            module,\n-            unwind_context,\n-            kind,\n-            tcx.alloc_error_handler_kind(()).unwrap(),\n-            tcx.sess.opts.unstable_opts.oom,\n-        );\n-        true\n-    } else {\n-        false\n-    }\n+    let Some(kind) = allocator_kind_for_codegen(tcx) else { return false };\n+    codegen_inner(\n+        module,\n+        unwind_context,\n+        kind,\n+        tcx.alloc_error_handler_kind(()).unwrap(),\n+        tcx.sess.opts.unstable_opts.oom,\n+    );\n+    true\n }\n \n fn codegen_inner("}, {"sha": "54d5c1c2ae9e9169f7c841e0d8bc5fa675d4573c", "filename": "compiler/rustc_codegen_cranelift/src/analyze.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fanalyze.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -4,34 +4,30 @@ use crate::prelude::*;\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::StatementKind::*;\n+use rustc_middle::ty::Ty;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub(crate) enum SsaKind {\n     NotSsa,\n-    Ssa,\n+    MaybeSsa,\n+}\n+\n+impl SsaKind {\n+    pub(crate) fn is_ssa<'tcx>(self, fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n+        self == SsaKind::MaybeSsa && (fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some())\n+    }\n }\n \n pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n-    let mut flag_map = fx\n-        .mir\n-        .local_decls\n-        .iter()\n-        .map(|local_decl| {\n-            let ty = fx.monomorphize(local_decl.ty);\n-            if fx.clif_type(ty).is_some() || fx.clif_pair_type(ty).is_some() {\n-                SsaKind::Ssa\n-            } else {\n-                SsaKind::NotSsa\n-            }\n-        })\n-        .collect::<IndexVec<Local, SsaKind>>();\n+    let mut flag_map =\n+        fx.mir.local_decls.iter().map(|_| SsaKind::MaybeSsa).collect::<IndexVec<Local, SsaKind>>();\n \n     for bb in fx.mir.basic_blocks.iter() {\n         for stmt in bb.statements.iter() {\n             match &stmt.kind {\n                 Assign(place_and_rval) => match &place_and_rval.1 {\n                     Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n-                        not_ssa(&mut flag_map, place.local)\n+                        flag_map[place.local] = SsaKind::NotSsa;\n                     }\n                     _ => {}\n                 },\n@@ -42,7 +38,3 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, '_>) -> IndexVec<Local, SsaKind> {\n \n     flag_map\n }\n-\n-fn not_ssa(flag_map: &mut IndexVec<Local, SsaKind>, local: Local) {\n-    flag_map[local] = SsaKind::NotSsa;\n-}"}, {"sha": "1825fb8cb228840ebfa3555612881a5aac2f8803", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -192,7 +192,7 @@ pub(crate) fn compile_fn(\n                         let pass_times = cranelift_codegen::timing::take_current();\n                         // Replace newlines with | as measureme doesn't allow control characters like\n                         // newlines inside strings.\n-                        recorder.record_arg(format!(\"{}\", pass_times).replace(\"\\n\", \" | \"));\n+                        recorder.record_arg(format!(\"{}\", pass_times).replace('\\n', \" | \"));\n                         recording_args = true;\n                     },\n                 )\n@@ -346,17 +346,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 crate::abi::codegen_return(fx);\n             }\n             TerminatorKind::Assert { cond, expected, msg, target, cleanup: _ } => {\n-                if !fx.tcx.sess.overflow_checks() {\n-                    let overflow_not_to_check = match msg {\n-                        AssertKind::OverflowNeg(..) => true,\n-                        AssertKind::Overflow(op, ..) => op.is_checkable(),\n-                        _ => false,\n-                    };\n-                    if overflow_not_to_check {\n-                        let target = fx.get_block(*target);\n-                        fx.bcx.ins().jump(target, &[]);\n-                        continue;\n-                    }\n+                if !fx.tcx.sess.overflow_checks() && msg.is_optional_overflow_check() {\n+                    let target = fx.get_block(*target);\n+                    fx.bcx.ins().jump(target, &[]);\n+                    continue;\n                 }\n                 let cond = codegen_operand(fx, cond).load_scalar(fx);\n \n@@ -365,11 +358,10 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                 fx.bcx.set_cold_block(failure);\n \n                 if *expected {\n-                    fx.bcx.ins().brz(cond, failure, &[]);\n+                    fx.bcx.ins().brif(cond, target, &[], failure, &[]);\n                 } else {\n-                    fx.bcx.ins().brnz(cond, failure, &[]);\n+                    fx.bcx.ins().brif(cond, failure, &[], target, &[]);\n                 };\n-                fx.bcx.ins().jump(target, &[]);\n \n                 fx.bcx.switch_to_block(failure);\n                 fx.bcx.ins().nop();\n@@ -425,11 +417,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                         }\n                     } else {\n                         if test_zero {\n-                            fx.bcx.ins().brz(discr, then_block, &[]);\n-                            fx.bcx.ins().jump(else_block, &[]);\n+                            fx.bcx.ins().brif(discr, else_block, &[], then_block, &[]);\n                         } else {\n-                            fx.bcx.ins().brnz(discr, then_block, &[]);\n-                            fx.bcx.ins().jump(else_block, &[]);\n+                            fx.bcx.ins().brif(discr, then_block, &[], else_block, &[]);\n                         }\n                     }\n                 } else {\n@@ -499,7 +489,6 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n             TerminatorKind::Yield { .. }\n             | TerminatorKind::FalseEdge { .. }\n             | TerminatorKind::FalseUnwind { .. }\n-            | TerminatorKind::DropAndReplace { .. }\n             | TerminatorKind::GeneratorDrop => {\n                 bug!(\"shouldn't exist at codegen {:?}\", bb_data.terminator());\n             }\n@@ -720,6 +709,10 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     operand.coerce_dyn_star(fx, lval);\n                 }\n+                Rvalue::Cast(CastKind::Transmute, ref operand, _to_ty) => {\n+                    let operand = codegen_operand(fx, operand);\n+                    lval.write_cvalue_transmute(fx, operand);\n+                }\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n                     let value = place.to_cvalue(fx);\n@@ -751,8 +744,7 @@ fn codegen_stmt<'tcx>(\n \n                         fx.bcx.switch_to_block(loop_block);\n                         let done = fx.bcx.ins().icmp_imm(IntCC::Equal, index, times as i64);\n-                        fx.bcx.ins().brnz(done, done_block, &[]);\n-                        fx.bcx.ins().jump(loop_block2, &[]);\n+                        fx.bcx.ins().brif(done, done_block, &[], loop_block2, &[]);\n \n                         fx.bcx.switch_to_block(loop_block2);\n                         let to = lval.place_index(fx, index);\n@@ -793,7 +785,7 @@ fn codegen_stmt<'tcx>(\n                             let variant_dest = lval.downcast_variant(fx, variant_index);\n                             (variant_index, variant_dest, active_field_index)\n                         }\n-                        _ => (VariantIdx::from_u32(0), lval, None),\n+                        _ => (FIRST_VARIANT, lval, None),\n                     };\n                     if active_field_index.is_some() {\n                         assert_eq!(operands.len(), 1);\n@@ -820,6 +812,7 @@ fn codegen_stmt<'tcx>(\n         | StatementKind::Nop\n         | StatementKind::FakeRead(..)\n         | StatementKind::Retag { .. }\n+        | StatementKind::PlaceMention(..)\n         | StatementKind::AscribeUserType(..) => {}\n \n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n@@ -997,7 +990,7 @@ fn codegen_panic_inner<'tcx>(\n     let symbol_name = fx.tcx.symbol_name(instance).name;\n \n     fx.lib_call(\n-        &*symbol_name,\n+        symbol_name,\n         args.iter().map(|&arg| AbiParam::new(fx.bcx.func.dfg.value_type(arg))).collect(),\n         vec![],\n         args,"}, {"sha": "032d1151041dbb45b28442075d464a7edae1bb6f", "filename": "compiler/rustc_codegen_cranelift/src/cast.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcast.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -64,17 +64,12 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            let to_rust_ty = match to_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            return fx\n-                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx);\n+            return fx.lib_call(\n+                &name,\n+                vec![AbiParam::new(types::I128)],\n+                vec![AbiParam::new(to_ty)],\n+                &[from],\n+            )[0];\n         }\n \n         // int-like -> float\n@@ -101,16 +96,29 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = match from_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            fx.easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx)\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret = fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &[from],\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: 16,\n+                });\n+                let ret_ptr = Pointer::stack_slot(stack_slot);\n+                ret_ptr.store(fx, ret, MemFlags::trusted());\n+                ret_ptr.load(fx, types::I128, MemFlags::trusted())\n+            } else {\n+                fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &[from],\n+                )[0]\n+            }\n         } else if to_ty == types::I8 || to_ty == types::I16 {\n             // FIXME implement fcvt_to_*int_sat.i8/i16\n             let val = if to_signed {"}, {"sha": "f674ce776a68697da60a5de8e30413bc373e38df", "filename": "compiler/rustc_codegen_cranelift/src/codegen_i128.rs", "status": "modified", "additions": 30, "deletions": 59, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcodegen_i128.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -29,39 +29,24 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked || is_signed => {\n             if !checked {\n-                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-                if fx.tcx.sess.target.is_like_windows {\n-                    let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n-                    let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                    let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                    assert!(lhs_extra.is_none());\n-                    assert!(rhs_extra.is_none());\n-                    let args = [\n-                        ret_place.to_ptr().get_addr(fx),\n-                        lhs_ptr.get_addr(fx),\n-                        rhs_ptr.get_addr(fx),\n-                    ];\n-                    fx.lib_call(\n-                        \"__multi3\",\n-                        vec![\n-                            AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                            AbiParam::new(fx.pointer_type),\n-                            AbiParam::new(fx.pointer_type),\n-                        ],\n-                        vec![],\n-                        &args,\n-                    );\n-                    Some(ret_place.to_cvalue(fx))\n-                } else {\n-                    Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n-                }\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    \"__multi3\",\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(\n+                    ret_val,\n+                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+                ))\n             } else {\n-                let out_ty = fx.tcx.intern_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+                let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n                 let lhs = lhs.load_scalar(fx);\n                 let rhs = rhs.load_scalar(fx);\n                 let oflow_ptr = oflow.to_ptr().get_addr(fx);\n-                let res = fx.lib_call(\n+                let res = fx.lib_call_unadjusted(\n                     \"__muloti4\",\n                     vec![\n                         AbiParam::new(types::I128),\n@@ -78,31 +63,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n         }\n         BinOp::Add | BinOp::Sub | BinOp::Mul => {\n             assert!(checked);\n-            let out_ty = fx.tcx.intern_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(fx.pointer_type),\n-                        AbiParam::new(fx.pointer_type),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n-                )\n-            } else {\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(types::I128),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n-                )\n-            };\n+            let param_types = vec![\n+                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -125,14 +93,10 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 _ => unreachable!(),\n             };\n             if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n                 let ret = fx.lib_call(\n                     name,\n-                    vec![AbiParam::new(fx.pointer_type), AbiParam::new(fx.pointer_type)],\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n                     vec![AbiParam::new(types::I64X2)],\n                     &args,\n                 )[0];\n@@ -141,7 +105,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "d39bf700035f97e0a4ddc79c554ae3ac7f5c7656", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -75,7 +75,7 @@ fn clif_type_from_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Option<types::Typ\n         ty::Adt(adt_def, _) if adt_def.repr().simd() => {\n             let (element, count) = match &tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().abi\n             {\n-                Abi::Vector { element, count } => (element.clone(), *count),\n+                Abi::Vector { element, count } => (*element, *count),\n                 _ => unreachable!(),\n             };\n "}, {"sha": "f3b963200a0fb022f34bc48a2307b9c114830ace", "filename": "compiler/rustc_codegen_cranelift/src/compiler_builtins.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcompiler_builtins.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -39,6 +39,7 @@ builtin_functions! {\n \n     // integers\n     fn __multi3(a: i128, b: i128) -> i128;\n+    fn __muloti4(n: i128, d: i128, oflow: &mut i32) -> i128;\n     fn __udivti3(n: u128, d: u128) -> u128;\n     fn __divti3(n: i128, d: i128) -> i128;\n     fn __umodti3(n: u128, d: u128) -> u128;"}, {"sha": "203219a8a754a6dbc6e548112d876324a750970d", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -32,7 +32,7 @@ impl ConcurrencyLimiter {\n         ConcurrencyLimiter {\n             helper_thread: Some(helper_thread),\n             state,\n-            available_token_condvar: Arc::new(Condvar::new()),\n+            available_token_condvar,\n             finished: false,\n         }\n     }"}, {"sha": "31278f810e911b3d5cc11a512643fd762979559e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -290,7 +290,7 @@ fn data_id_for_static(\n         };\n \n         let data_id = match module.declare_data(\n-            &*symbol_name,\n+            symbol_name,\n             linkage,\n             is_mutable,\n             attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n@@ -338,7 +338,7 @@ fn data_id_for_static(\n     };\n \n     let data_id = match module.declare_data(\n-        &*symbol_name,\n+        symbol_name,\n         linkage,\n         is_mutable,\n         attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL),\n@@ -529,6 +529,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                         | StatementKind::StorageDead(_)\n                         | StatementKind::Retag(_, _)\n                         | StatementKind::AscribeUserType(_, _)\n+                        | StatementKind::PlaceMention(..)\n                         | StatementKind::Coverage(_)\n                         | StatementKind::ConstEvalCounter\n                         | StatementKind::Nop => {}\n@@ -543,8 +544,7 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                     | TerminatorKind::Unreachable\n                     | TerminatorKind::Drop { .. }\n                     | TerminatorKind::Assert { .. } => {}\n-                    TerminatorKind::DropAndReplace { .. }\n-                    | TerminatorKind::Yield { .. }\n+                    TerminatorKind::Yield { .. }\n                     | TerminatorKind::GeneratorDrop\n                     | TerminatorKind::FalseEdge { .. }\n                     | TerminatorKind::FalseUnwind { .. } => unreachable!(),"}, {"sha": "6c4efca442448a700d77e946edb926ab02e8ced9", "filename": "compiler/rustc_codegen_cranelift/src/cranelift_native.rs", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcranelift_native.rs?ref=21549dac539dc220f052d038ec643645cedbbd6d", "patch": "@@ -1,248 +0,0 @@\n-// Vendored from https://github.com/bytecodealliance/wasmtime/blob/b58a197d33f044193c3d608010f5e6ec394ac07e/cranelift/native/src/lib.rs\n-// which is licensed as\n-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n-// unlike rustc_codegen_cranelift itself. Also applies a small change to remove #![cfg_attr] that\n-// rust's CI complains about and to fix formatting to match rustc.\n-// FIXME revert back to the external crate with Cranelift 0.93\n-#![allow(warnings)]\n-\n-//! Performs autodetection of the host for the purposes of running\n-//! Cranelift to generate code to run on the same machine.\n-\n-#![deny(missing_docs, trivial_numeric_casts, unused_extern_crates, unstable_features)]\n-#![warn(unused_import_braces)]\n-\n-use cranelift_codegen::isa;\n-use target_lexicon::Triple;\n-\n-/// Return an `isa` builder configured for the current host\n-/// machine, or `Err(())` if the host machine is not supported\n-/// in the current configuration.\n-pub fn builder() -> Result<isa::Builder, &'static str> {\n-    builder_with_options(true)\n-}\n-\n-/// Return an `isa` builder configured for the current host\n-/// machine, or `Err(())` if the host machine is not supported\n-/// in the current configuration.\n-///\n-/// Selects the given backend variant specifically; this is\n-/// useful when more than oen backend exists for a given target\n-/// (e.g., on x86-64).\n-pub fn builder_with_options(infer_native_flags: bool) -> Result<isa::Builder, &'static str> {\n-    let mut isa_builder = isa::lookup(Triple::host()).map_err(|err| match err {\n-        isa::LookupError::SupportDisabled => \"support for architecture disabled at compile time\",\n-        isa::LookupError::Unsupported => \"unsupported architecture\",\n-    })?;\n-\n-    #[cfg(target_arch = \"x86_64\")]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !std::is_x86_feature_detected!(\"sse2\") {\n-            return Err(\"x86 support requires SSE2\");\n-        }\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        // These are temporarily enabled by default (see #3810 for\n-        // more) so that a default-constructed `Flags` can work with\n-        // default Wasmtime features. Otherwise, the user must\n-        // explicitly use native flags or turn these on when on x86-64\n-        // platforms to avoid a configuration panic. In order for the\n-        // \"enable if detected\" logic below to work, we must turn them\n-        // *off* (differing from the default) and then re-enable below\n-        // if present.\n-        isa_builder.set(\"has_sse3\", \"false\").unwrap();\n-        isa_builder.set(\"has_ssse3\", \"false\").unwrap();\n-        isa_builder.set(\"has_sse41\", \"false\").unwrap();\n-        isa_builder.set(\"has_sse42\", \"false\").unwrap();\n-\n-        if std::is_x86_feature_detected!(\"sse3\") {\n-            isa_builder.enable(\"has_sse3\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"ssse3\") {\n-            isa_builder.enable(\"has_ssse3\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"sse4.1\") {\n-            isa_builder.enable(\"has_sse41\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"sse4.2\") {\n-            isa_builder.enable(\"has_sse42\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"popcnt\") {\n-            isa_builder.enable(\"has_popcnt\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx\") {\n-            isa_builder.enable(\"has_avx\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx2\") {\n-            isa_builder.enable(\"has_avx2\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"fma\") {\n-            isa_builder.enable(\"has_fma\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"bmi1\") {\n-            isa_builder.enable(\"has_bmi1\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"bmi2\") {\n-            isa_builder.enable(\"has_bmi2\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512bitalg\") {\n-            isa_builder.enable(\"has_avx512bitalg\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512dq\") {\n-            isa_builder.enable(\"has_avx512dq\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512f\") {\n-            isa_builder.enable(\"has_avx512f\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512vl\") {\n-            isa_builder.enable(\"has_avx512vl\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"avx512vbmi\") {\n-            isa_builder.enable(\"has_avx512vbmi\").unwrap();\n-        }\n-        if std::is_x86_feature_detected!(\"lzcnt\") {\n-            isa_builder.enable(\"has_lzcnt\").unwrap();\n-        }\n-    }\n-\n-    #[cfg(target_arch = \"aarch64\")]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        if std::arch::is_aarch64_feature_detected!(\"lse\") {\n-            isa_builder.enable(\"has_lse\").unwrap();\n-        }\n-\n-        if std::arch::is_aarch64_feature_detected!(\"paca\") {\n-            isa_builder.enable(\"has_pauth\").unwrap();\n-        }\n-\n-        if cfg!(target_os = \"macos\") {\n-            // Pointer authentication is always available on Apple Silicon.\n-            isa_builder.enable(\"sign_return_address\").unwrap();\n-            // macOS enforces the use of the B key for return addresses.\n-            isa_builder.enable(\"sign_return_address_with_bkey\").unwrap();\n-        }\n-    }\n-\n-    // There is no is_s390x_feature_detected macro yet, so for now\n-    // we use getauxval from the libc crate directly.\n-    #[cfg(all(target_arch = \"s390x\", target_os = \"linux\"))]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n-        const HWCAP_S390X_VXRS_EXT2: libc::c_ulong = 32768;\n-        if (v & HWCAP_S390X_VXRS_EXT2) != 0 {\n-            isa_builder.enable(\"has_vxrs_ext2\").unwrap();\n-            // There is no separate HWCAP bit for mie2, so assume\n-            // that any machine with vxrs_ext2 also has mie2.\n-            isa_builder.enable(\"has_mie2\").unwrap();\n-        }\n-    }\n-\n-    // `is_riscv_feature_detected` is nightly only for now, use\n-    // getauxval from the libc crate directly as a temporary measure.\n-    #[cfg(all(target_arch = \"riscv64\", target_os = \"linux\"))]\n-    {\n-        use cranelift_codegen::settings::Configurable;\n-\n-        if !infer_native_flags {\n-            return Ok(isa_builder);\n-        }\n-\n-        let v = unsafe { libc::getauxval(libc::AT_HWCAP) };\n-\n-        const HWCAP_RISCV_EXT_A: libc::c_ulong = 1 << (b'a' - b'a');\n-        const HWCAP_RISCV_EXT_C: libc::c_ulong = 1 << (b'c' - b'a');\n-        const HWCAP_RISCV_EXT_D: libc::c_ulong = 1 << (b'd' - b'a');\n-        const HWCAP_RISCV_EXT_F: libc::c_ulong = 1 << (b'f' - b'a');\n-        const HWCAP_RISCV_EXT_M: libc::c_ulong = 1 << (b'm' - b'a');\n-        const HWCAP_RISCV_EXT_V: libc::c_ulong = 1 << (b'v' - b'a');\n-\n-        if (v & HWCAP_RISCV_EXT_A) != 0 {\n-            isa_builder.enable(\"has_a\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_C) != 0 {\n-            isa_builder.enable(\"has_c\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_D) != 0 {\n-            isa_builder.enable(\"has_d\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_F) != 0 {\n-            isa_builder.enable(\"has_f\").unwrap();\n-\n-            // TODO: There doesn't seem to be a bit associated with this extension\n-            // rust enables it with the `f` extension:\n-            // https://github.com/rust-lang/stdarch/blob/790411f93c4b5eada3c23abb4c9a063fb0b24d99/crates/std_detect/src/detect/os/linux/riscv.rs#L43\n-            isa_builder.enable(\"has_zicsr\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_M) != 0 {\n-            isa_builder.enable(\"has_m\").unwrap();\n-        }\n-\n-        if (v & HWCAP_RISCV_EXT_V) != 0 {\n-            isa_builder.enable(\"has_v\").unwrap();\n-        }\n-\n-        // TODO: ZiFencei does not have a bit associated with it\n-        // TODO: Zbkb does not have a bit associated with it\n-    }\n-\n-    // squelch warnings about unused mut/variables on some platforms.\n-    drop(&mut isa_builder);\n-    drop(infer_native_flags);\n-\n-    Ok(isa_builder)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::builder;\n-    use cranelift_codegen::isa::CallConv;\n-    use cranelift_codegen::settings;\n-\n-    #[test]\n-    fn test() {\n-        if let Ok(isa_builder) = builder() {\n-            let flag_builder = settings::builder();\n-            let isa = isa_builder.finish(settings::Flags::new(flag_builder)).unwrap();\n-\n-            if cfg!(all(target_os = \"macos\", target_arch = \"aarch64\")) {\n-                assert_eq!(isa.default_call_conv(), CallConv::AppleAarch64);\n-            } else if cfg!(any(unix, target_os = \"nebulet\")) {\n-                assert_eq!(isa.default_call_conv(), CallConv::SystemV);\n-            } else if cfg!(windows) {\n-                assert_eq!(isa.default_call_conv(), CallConv::WindowsFastcall);\n-            }\n-\n-            if cfg!(target_pointer_width = \"64\") {\n-                assert_eq!(isa.pointer_bits(), 64);\n-            } else if cfg!(target_pointer_width = \"32\") {\n-                assert_eq!(isa.pointer_bits(), 32);\n-            } else if cfg!(target_pointer_width = \"16\") {\n-                assert_eq!(isa.pointer_bits(), 16);\n-            }\n-        }\n-    }\n-}\n-\n-/// Version number of this crate.\n-pub const VERSION: &str = env!(\"CARGO_PKG_VERSION\");"}, {"sha": "c4a5627e662f1d06907855640591c6cb985153c2", "filename": "compiler/rustc_codegen_cranelift/src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdebuginfo%2Femit.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -113,7 +113,7 @@ impl Writer for WriterRelocate {\n                     offset: offset as u32,\n                     size,\n                     name: DebugRelocName::Symbol(symbol),\n-                    addend: addend as i64,\n+                    addend,\n                     kind: object::RelocationKind::Absolute,\n                 });\n                 self.write_udata(0, size)"}, {"sha": "3e2e2af968860978c8655162c58660d31d40dcf0", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -377,7 +377,7 @@ pub(crate) fn run_aot(\n     };\n \n     if tcx.dep_graph.is_fully_enabled() {\n-        for cgu in &*cgus {\n+        for cgu in cgus {\n             tcx.ensure().codegen_unit(cgu.name());\n         }\n     }\n@@ -417,7 +417,7 @@ pub(crate) fn run_aot(\n                     CguReuse::PreLto => unreachable!(),\n                     CguReuse::PostLto => {\n                         concurrency_limiter.job_already_done();\n-                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, &*cgu))\n+                        OngoingModuleCodegen::Sync(reuse_workproduct_for_cgu(tcx, cgu))\n                     }\n                 }\n             })"}, {"sha": "f6a48e3257bc246f8731b40fc9142f54c65fb585", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -311,7 +311,11 @@ fn dep_symbol_lookup_fn(\n         .find(|(crate_type, _data)| *crate_type == rustc_session::config::CrateType::Executable)\n         .unwrap()\n         .1;\n-    for &cnum in &crate_info.used_crates {\n+    // `used_crates` is in reverse postorder in terms of dependencies. Reverse the order here to\n+    // get a postorder which ensures that all dependencies of a dylib are loaded before the dylib\n+    // itself. This helps the dynamic linker to find dylibs not in the regular dynamic library\n+    // search path.\n+    for &cnum in crate_info.used_crates.iter().rev() {\n         let src = &crate_info.used_crate_source[&cnum];\n         match data[cnum.as_usize() - 1] {\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}"}, {"sha": "a74f8ffa23d43546acd606b4af8fdb356a8d5d51", "filename": "compiler/rustc_codegen_cranelift/src/global_asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fglobal_asm.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -125,7 +125,7 @@ pub(crate) fn compile_global_asm(\n     let output_object_file = config.output_filenames.temp_path(OutputType::Object, Some(cgu_name));\n \n     // Assemble `global_asm`\n-    let global_asm_object_file = add_file_stem_postfix(output_object_file.clone(), \".asm\");\n+    let global_asm_object_file = add_file_stem_postfix(output_object_file, \".asm\");\n     let mut child = Command::new(&config.assembler)\n         .arg(\"-o\")\n         .arg(&global_asm_object_file)"}, {"sha": "3ba530c040f7f9236df19902f083896f6074dcc8", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -242,7 +242,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                 }\n             }\n             InlineAsmOperand::Const { ref value } => {\n-                let (const_value, ty) = crate::constant::eval_mir_constant(fx, &*value)\n+                let (const_value, ty) = crate::constant::eval_mir_constant(fx, value)\n                     .unwrap_or_else(|| span_bug!(span, \"asm const cannot be resolved\"));\n                 let value = rustc_codegen_ssa::common::asm_const_to_str(\n                     fx.tcx,\n@@ -334,13 +334,13 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             }\n             CInlineAsmOperand::Out { reg: _, late: _, place } => {\n                 if let Some(place) = place {\n-                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), place.clone()));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), *place));\n                 }\n             }\n             CInlineAsmOperand::InOut { reg: _, _late: _, in_value, out_place } => {\n                 inputs.push((asm_gen.stack_slots_input[i].unwrap(), in_value.load_scalar(fx)));\n                 if let Some(out_place) = out_place {\n-                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), out_place.clone()));\n+                    outputs.push((asm_gen.stack_slots_output[i].unwrap(), *out_place));\n                 }\n             }\n             CInlineAsmOperand::Const { value: _ } | CInlineAsmOperand::Symbol { symbol: _ } => {}"}, {"sha": "e5c4b244a1afd8f6f4dc4096b10fe3221013c54a", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -191,7 +191,7 @@ fn llvm_add_sub<'tcx>(\n     // carry0 | carry1 -> carry or borrow respectively\n     let cb_out = fx.bcx.ins().bor(cb0, cb1);\n \n-    let layout = fx.layout_of(fx.tcx.intern_tup(&[fx.tcx.types.u8, fx.tcx.types.u64]));\n+    let layout = fx.layout_of(fx.tcx.mk_tup(&[fx.tcx.types.u8, fx.tcx.types.u64]));\n     let val = CValue::by_val_pair(cb_out, c, layout);\n     ret.write_cvalue(fx, val);\n }"}, {"sha": "03f2a65fccad2444c5097d364b1219cad916751b", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 98, "deletions": 117, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -21,8 +21,9 @@ mod simd;\n pub(crate) use cpuid::codegen_cpuid_call;\n pub(crate) use llvm::codegen_llvm_intrinsic_call;\n \n-use rustc_middle::ty::layout::HasParamEnv;\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty;\n+use rustc_middle::ty::layout::{HasParamEnv, ValidityRequirement};\n+use rustc_middle::ty::print::{with_no_trimmed_paths, with_no_visible_paths};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n@@ -251,41 +252,45 @@ fn codegen_float_intrinsic_call<'tcx>(\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n ) -> bool {\n-    let (name, arg_count, ty) = match intrinsic {\n-        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32),\n-        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64),\n-        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32),\n-        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64),\n-        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32),\n-        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64),\n-        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32), // compiler-builtins\n-        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64), // compiler-builtins\n-        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32),\n-        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64),\n-        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32),\n-        sym::logf64 => (\"log\", 1, fx.tcx.types.f64),\n-        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32),\n-        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64),\n-        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32),\n-        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64),\n-        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32),\n-        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64),\n-        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32),\n-        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64),\n-        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32),\n-        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64),\n-        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32),\n-        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64),\n-        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32),\n-        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n-        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n-        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n-        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n-        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n-        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n-        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n-        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),\n-        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64),\n+    let (name, arg_count, ty, clif_ty) = match intrinsic {\n+        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64, types::F64),\n+        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64, types::F64),\n+        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32, types::F32), // compiler-builtins\n+        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64, types::F64), // compiler-builtins\n+        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64, types::F64),\n+        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::logf64 => (\"log\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32, types::F32),\n+        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64, types::F64),\n+        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64, types::F64),\n+        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64, types::F64),\n+        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64, types::F64),\n+        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64, types::F64),\n+        sym::rintf32 => (\"rintf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::rintf64 => (\"rint\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundevenf32 => (\"roundevenf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundevenf64 => (\"roundeven\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64, types::F64),\n+        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64, types::F64),\n         _ => return false,\n     };\n \n@@ -296,15 +301,19 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let (a, b, c);\n     let args = match args {\n         [x] => {\n-            a = [codegen_operand(fx, x)];\n+            a = [codegen_operand(fx, x).load_scalar(fx)];\n             &a as &[_]\n         }\n         [x, y] => {\n-            b = [codegen_operand(fx, x), codegen_operand(fx, y)];\n+            b = [codegen_operand(fx, x).load_scalar(fx), codegen_operand(fx, y).load_scalar(fx)];\n             &b\n         }\n         [x, y, z] => {\n-            c = [codegen_operand(fx, x), codegen_operand(fx, y), codegen_operand(fx, z)];\n+            c = [\n+                codegen_operand(fx, x).load_scalar(fx),\n+                codegen_operand(fx, y).load_scalar(fx),\n+                codegen_operand(fx, z).load_scalar(fx),\n+            ];\n             &c\n         }\n         _ => unreachable!(),\n@@ -313,15 +322,10 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let layout = fx.layout_of(ty);\n     let res = match intrinsic {\n         sym::fmaf32 | sym::fmaf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            let c = args[2].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+            CValue::by_val(fx.bcx.ins().fma(args[0], args[1], args[2]), layout)\n         }\n         sym::copysignf32 | sym::copysignf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+            CValue::by_val(fx.bcx.ins().fcopysign(args[0], args[1]), layout)\n         }\n         sym::fabsf32\n         | sym::fabsf64\n@@ -331,21 +335,29 @@ fn codegen_float_intrinsic_call<'tcx>(\n         | sym::ceilf64\n         | sym::truncf32\n         | sym::truncf64 => {\n-            let a = args[0].load_scalar(fx);\n-\n             let val = match intrinsic {\n-                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n-                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n-                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n-                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(args[0]),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(args[0]),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(args[0]),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(args[0]),\n                 _ => unreachable!(),\n             };\n \n             CValue::by_val(val, layout)\n         }\n+\n         // These intrinsics aren't supported natively by Cranelift.\n         // Lower them to a libcall.\n-        _ => fx.easy_call(name, &args, ty),\n+        sym::powif32 | sym::powif64 => {\n+            let input_tys: Vec<_> = vec![AbiParam::new(clif_ty), AbiParam::new(types::I32)];\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n+        _ => {\n+            let input_tys: Vec<_> = args.iter().map(|_| AbiParam::new(clif_ty)).collect();\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n     };\n \n     ret.write_cvalue(fx, res);\n@@ -380,7 +392,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n \n             fx.bcx.ins().debugtrap();\n         }\n-        sym::copy | sym::copy_nonoverlapping => {\n+        sym::copy => {\n             intrinsic_args!(fx, args => (src, dst, count); intrinsic);\n             let src = src.load_scalar(fx);\n             let dst = dst.load_scalar(fx);\n@@ -392,13 +404,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let byte_amount =\n                 if elem_size != 1 { fx.bcx.ins().imul_imm(count, elem_size as i64) } else { count };\n \n-            if intrinsic == sym::copy_nonoverlapping {\n-                // FIXME emit_small_memcpy\n-                fx.bcx.call_memcpy(fx.target_config, dst, src, byte_amount);\n-            } else {\n-                // FIXME emit_small_memmove\n-                fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n-            }\n+            // FIXME emit_small_memmove\n+            fx.bcx.call_memmove(fx.target_config, dst, src, byte_amount);\n         }\n         sym::volatile_copy_memory | sym::volatile_copy_nonoverlapping_memory => {\n             // NOTE: the volatile variants have src and dst swapped\n@@ -550,16 +557,6 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             fx.bcx.ins().band(ptr, mask);\n         }\n \n-        sym::transmute => {\n-            intrinsic_args!(fx, args => (from); intrinsic);\n-\n-            if ret.layout().abi.is_uninhabited() {\n-                crate::base::codegen_panic(fx, \"Transmuting to uninhabited type.\", source_info);\n-                return;\n-            }\n-\n-            ret.write_cvalue_transmute(fx, from);\n-        }\n         sym::write_bytes | sym::volatile_set_memory => {\n             intrinsic_args!(fx, args => (dst, val, count); intrinsic);\n             let val = val.load_scalar(fx);\n@@ -627,54 +624,38 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             intrinsic_args!(fx, args => (); intrinsic);\n \n             let ty = substs.type_at(0);\n-            let layout = fx.layout_of(ty);\n-            if layout.abi.is_uninhabited() {\n-                with_no_trimmed_paths!({\n-                    crate::base::codegen_panic_nounwind(\n-                        fx,\n-                        &format!(\"attempted to instantiate uninhabited type `{}`\", layout.ty),\n-                        source_info,\n-                    )\n-                });\n-                return;\n-            }\n \n-            if intrinsic == sym::assert_zero_valid\n-                && !fx\n-                    .tcx\n-                    .permits_zero_init(fx.param_env().and(ty))\n-                    .expect(\"expected to have layout during codegen\")\n-            {\n-                with_no_trimmed_paths!({\n-                    crate::base::codegen_panic_nounwind(\n-                        fx,\n-                        &format!(\n-                            \"attempted to zero-initialize type `{}`, which is invalid\",\n-                            layout.ty\n-                        ),\n-                        source_info,\n-                    );\n-                });\n-                return;\n-            }\n+            let requirement = ValidityRequirement::from_intrinsic(intrinsic);\n \n-            if intrinsic == sym::assert_mem_uninitialized_valid\n-                && !fx\n+            if let Some(requirement) = requirement {\n+                let do_panic = !fx\n                     .tcx\n-                    .permits_uninit_init(fx.param_env().and(ty))\n-                    .expect(\"expected to have layout during codegen\")\n-            {\n-                with_no_trimmed_paths!({\n-                    crate::base::codegen_panic_nounwind(\n-                        fx,\n-                        &format!(\n-                            \"attempted to leave type `{}` uninitialized, which is invalid\",\n-                            layout.ty\n-                        ),\n-                        source_info,\n-                    )\n-                });\n-                return;\n+                    .check_validity_requirement((requirement, fx.param_env().and(ty)))\n+                    .expect(\"expect to have layout during codegen\");\n+\n+                if do_panic {\n+                    let layout = fx.layout_of(ty);\n+                    let msg_str = with_no_visible_paths!({\n+                        with_no_trimmed_paths!({\n+                            if layout.abi.is_uninhabited() {\n+                                // Use this error even for the other intrinsics as it is more precise.\n+                                format!(\"attempted to instantiate uninhabited type `{}`\", ty)\n+                            } else if intrinsic == sym::assert_zero_valid {\n+                                format!(\n+                                    \"attempted to zero-initialize type `{}`, which is invalid\",\n+                                    ty\n+                                )\n+                            } else {\n+                                format!(\n+                                    \"attempted to leave type `{}` uninitialized, which is invalid\",\n+                                    ty\n+                                )\n+                            }\n+                        })\n+                    });\n+                    crate::base::codegen_panic_nounwind(fx, &msg_str, source_info);\n+                    return;\n+                }\n             }\n         }\n "}, {"sha": "034b4e8072cc588787b76fcfc5add316217c747f", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -279,9 +279,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 fx.tcx.sess.span_warn(span, \"Index argument for `simd_extract` is not a constant\");\n                 let trap_block = fx.bcx.create_block();\n                 let true_ = fx.bcx.ins().iconst(types::I8, 1);\n-                fx.bcx.ins().brnz(true_, trap_block, &[]);\n                 let ret_block = fx.get_block(target);\n-                fx.bcx.ins().jump(ret_block, &[]);\n+                fx.bcx.ins().brif(true_, trap_block, &[], ret_block, &[]);\n                 fx.bcx.switch_to_block(trap_block);\n                 crate::trap::trap_unimplemented(\n                     fx,\n@@ -825,8 +824,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let next = fx.bcx.create_block();\n                 let res_lane = fx.bcx.append_block_param(next, lane_clif_ty);\n \n-                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n-                fx.bcx.ins().jump(if_disabled, &[]);\n+                fx.bcx.ins().brif(mask_lane, if_enabled, &[], if_disabled, &[]);\n                 fx.bcx.seal_block(if_enabled);\n                 fx.bcx.seal_block(if_disabled);\n \n@@ -864,8 +862,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 let if_enabled = fx.bcx.create_block();\n                 let next = fx.bcx.create_block();\n \n-                fx.bcx.ins().brnz(mask_lane, if_enabled, &[]);\n-                fx.bcx.ins().jump(next, &[]);\n+                fx.bcx.ins().brif(mask_lane, if_enabled, &[], next, &[]);\n                 fx.bcx.seal_block(if_enabled);\n \n                 fx.bcx.switch_to_block(if_enabled);"}, {"sha": "1bd03403f244b3c5b97f4f9e1d584a8a7c7e8ed0", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -57,8 +57,6 @@ mod compiler_builtins;\n mod concurrency_limiter;\n mod config;\n mod constant;\n-// FIXME revert back to the external crate with Cranelift 0.93\n-mod cranelift_native;\n mod debuginfo;\n mod discriminant;\n mod driver;\n@@ -88,7 +86,7 @@ mod prelude {\n         self, FloatTy, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut,\n         TypeFoldable, TypeVisitableExt, UintTy,\n     };\n-    pub(crate) use rustc_target::abi::{Abi, Scalar, Size, VariantIdx};\n+    pub(crate) use rustc_target::abi::{Abi, Scalar, Size, VariantIdx, FIRST_VARIANT};\n \n     pub(crate) use rustc_data_structures::fx::FxHashMap;\n \n@@ -251,7 +249,7 @@ fn target_triple(sess: &Session) -> target_lexicon::Triple {\n     }\n }\n \n-fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::TargetIsa + 'static> {\n+fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Arc<dyn isa::TargetIsa + 'static> {\n     use target_lexicon::BinaryFormat;\n \n     let target_triple = crate::target_triple(sess);\n@@ -285,14 +283,17 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n-    if let target_lexicon::Architecture::Aarch64(_) | target_lexicon::Architecture::X86_64 =\n-        target_triple.architecture\n+    if let target_lexicon::Architecture::Aarch64(_)\n+    | target_lexicon::Architecture::Riscv64(_)\n+    | target_lexicon::Architecture::X86_64 = target_triple.architecture\n     {\n-        // Windows depends on stack probes to grow the committed part of the stack\n+        // Windows depends on stack probes to grow the committed part of the stack.\n+        // On other platforms it helps prevents stack smashing.\n         flags_builder.enable(\"enable_probestack\").unwrap();\n         flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n     } else {\n-        // __cranelift_probestack is not provided and inline stack probes are only supported on AArch64 and x86_64\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on\n+        // AArch64, Riscv64 and x86_64.\n         flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n     }\n "}, {"sha": "205411e8c27be3ab312331bb57158e3479b07736", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -28,7 +28,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n     if main_def_id.is_local() {\n         let instance = Instance::mono(tcx, main_def_id).polymorphize(tcx);\n-        if !is_jit && module.get_name(&*tcx.symbol_name(instance).name).is_none() {\n+        if !is_jit && module.get_name(tcx.symbol_name(instance).name).is_none() {\n             return;\n         }\n     } else if !is_primary_cgu {\n@@ -119,7 +119,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx,\n                     ParamEnv::reveal_all(),\n                     report.def_id,\n-                    tcx.intern_substs(&[GenericArg::from(main_ret_ty)]),\n+                    tcx.mk_substs(&[GenericArg::from(main_ret_ty)]),\n                 )\n                 .unwrap()\n                 .unwrap()\n@@ -146,7 +146,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n                     tcx,\n                     ParamEnv::reveal_all(),\n                     start_def_id,\n-                    tcx.intern_substs(&[main_ret_ty.into()]),\n+                    tcx.mk_substs(&[main_ret_ty.into()]),\n                 )\n                 .unwrap()\n                 .unwrap()"}, {"sha": "1357b7be1e0959f5348833fe4b11ce18a71ca883", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -170,14 +170,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n-        assert_eq!(\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty,\n-            \"checked int binop requires lhs and rhs of same type\"\n-        );\n-    }\n-\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n@@ -271,25 +263,10 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                 _ => unreachable!(\"invalid non-integer type {}\", ty),\n             }\n         }\n-        BinOp::Shl => {\n-            let val = fx.bcx.ins().ishl(lhs, rhs);\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n-        BinOp::Shr => {\n-            let val =\n-                if !signed { fx.bcx.ins().ushr(lhs, rhs) } else { fx.bcx.ins().sshr(lhs, rhs) };\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n-    let out_layout = fx.layout_of(fx.tcx.intern_tup(&[in_lhs.layout().ty, fx.tcx.types.bool]));\n+    let out_layout = fx.layout_of(fx.tcx.mk_tup(&[in_lhs.layout().ty, fx.tcx.types.bool]));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n@@ -347,12 +324,20 @@ pub(crate) fn codegen_float_binop<'tcx>(\n         BinOp::Mul => b.fmul(lhs, rhs),\n         BinOp::Div => b.fdiv(lhs, rhs),\n         BinOp::Rem => {\n-            let name = match in_lhs.layout().ty.kind() {\n-                ty::Float(FloatTy::F32) => \"fmodf\",\n-                ty::Float(FloatTy::F64) => \"fmod\",\n+            let (name, ty) = match in_lhs.layout().ty.kind() {\n+                ty::Float(FloatTy::F32) => (\"fmodf\", types::F32),\n+                ty::Float(FloatTy::F64) => (\"fmod\", types::F64),\n                 _ => bug!(),\n             };\n-            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+\n+            let ret_val = fx.lib_call(\n+                name,\n+                vec![AbiParam::new(ty), AbiParam::new(ty)],\n+                vec![AbiParam::new(ty)],\n+                &[lhs, rhs],\n+            )[0];\n+\n+            return CValue::by_val(ret_val, in_lhs.layout());\n         }\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n             let fltcc = match bin_op {"}, {"sha": "b60e56720ed5ed7c1f9cbe989c98dc9e10a608ce", "filename": "compiler/rustc_codegen_cranelift/src/pointer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpointer.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -30,11 +30,6 @@ impl Pointer {\n         Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n-        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n-    }\n-\n     pub(crate) fn dangling(align: Align) -> Self {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }"}, {"sha": "e0a081c9d498bb41207ebf3c93aaa2ec060e6332", "filename": "compiler/rustc_codegen_cranelift/src/pretty_clif.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fpretty_clif.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -245,7 +245,7 @@ pub(crate) fn write_clif_file(\n         for flag in isa.flags().iter() {\n             writeln!(file, \"set {}\", flag)?;\n         }\n-        write!(file, \"target {}\", isa.triple().architecture.to_string())?;\n+        write!(file, \"target {}\", isa.triple().architecture)?;\n         for isa_flag in isa.isa_flags().iter() {\n             write!(file, \" {}\", isa_flag)?;\n         }"}, {"sha": "93eefd92342d8f44f64f2b52e2b2361d8471c001", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -28,9 +28,7 @@ pub(crate) fn unsized_info<'tcx>(\n         (\n             &ty::Dynamic(ref data_a, _, src_dyn_kind),\n             &ty::Dynamic(ref data_b, _, target_dyn_kind),\n-        ) => {\n-            assert_eq!(src_dyn_kind, target_dyn_kind);\n-\n+        ) if src_dyn_kind == target_dyn_kind => {\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -55,7 +53,7 @@ pub(crate) fn unsized_info<'tcx>(\n                 old_info\n             }\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n+        (_, ty::Dynamic(data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n@@ -148,7 +146,7 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variant(VariantIdx::new(0)).fields.len() {\n+            for i in 0..def_a.variant(FIRST_VARIANT).fields.len() {\n                 let src_f = src.value_field(fx, mir::Field::new(i));\n                 let dst_f = dst.place_field(fx, mir::Field::new(i));\n "}, {"sha": "58e0a498292d4498637b447f58f54ff50fc82adb", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -3,6 +3,7 @@\n use crate::prelude::*;\n \n use cranelift_codegen::ir::immediates::Offset32;\n+use cranelift_codegen::ir::{InstructionData, Opcode};\n \n fn codegen_field<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -457,13 +458,15 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    #[track_caller]\n     pub(crate) fn to_ptr(self) -> Pointer {\n         match self.to_ptr_maybe_unsized() {\n             (ptr, None) => ptr,\n             (_, Some(_)) => bug!(\"Expected sized cplace, found {:?}\", self),\n         }\n     }\n \n+    #[track_caller]\n     pub(crate) fn to_ptr_maybe_unsized(self) -> (Pointer, Option<Value>) {\n         match self.inner {\n             CPlaceInner::Addr(ptr, extra) => (ptr, extra),\n@@ -787,7 +790,36 @@ impl<'tcx> CPlace<'tcx> {\n         index: Value,\n     ) -> CPlace<'tcx> {\n         let (elem_layout, ptr) = match self.layout().ty.kind() {\n-            ty::Array(elem_ty, _) => (fx.layout_of(*elem_ty), self.to_ptr()),\n+            ty::Array(elem_ty, _) => {\n+                let elem_layout = fx.layout_of(*elem_ty);\n+                match self.inner {\n+                    CPlaceInner::Var(local, var) => {\n+                        // This is a hack to handle `vector_val.0[1]`. It doesn't allow dynamic\n+                        // indexing.\n+                        let lane_idx = match fx.bcx.func.dfg.insts\n+                            [fx.bcx.func.dfg.value_def(index).unwrap_inst()]\n+                        {\n+                            InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => imm,\n+                            _ => bug!(\n+                                \"Dynamic indexing into a vector type is not supported: {self:?}[{index}]\"\n+                            ),\n+                        };\n+                        return CPlace {\n+                            inner: CPlaceInner::VarLane(\n+                                local,\n+                                var,\n+                                lane_idx.bits().try_into().unwrap(),\n+                            ),\n+                            layout: elem_layout,\n+                        };\n+                    }\n+                    CPlaceInner::Addr(addr, None) => (elem_layout, addr),\n+                    CPlaceInner::Addr(_, Some(_))\n+                    | CPlaceInner::VarPair(_, _, _)\n+                    | CPlaceInner::VarLane(_, _, _) => bug!(\"Can't index into {self:?}\"),\n+                }\n+                // FIXME use VarLane in case of Var with simd type\n+            }\n             ty::Slice(elem_ty) => (fx.layout_of(*elem_ty), self.to_ptr_maybe_unsized().0),\n             _ => bug!(\"place_index({:?})\", self.layout().ty),\n         };"}, {"sha": "94806e0d798ed5a239c40aab8be54d771e453c53", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -43,10 +43,27 @@ pub(crate) fn min_align_of_obj(fx: &mut FunctionCx<'_, '_, '_>, vtable: Value) -\n \n pub(crate) fn get_ptr_and_method_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    arg: CValue<'tcx>,\n+    mut arg: CValue<'tcx>,\n     idx: usize,\n ) -> (Pointer, Value) {\n     let (ptr, vtable) = 'block: {\n+        if let Abi::Scalar(_) = arg.layout().abi {\n+            'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr() && !arg.layout().ty.is_ref() {\n+                for i in 0..arg.layout().fields.count() {\n+                    let field = arg.value_field(fx, mir::Field::new(i));\n+                    if !field.layout().is_zst() {\n+                        // we found the one non-zero-sized field that is allowed\n+                        // now find *its* non-zero-sized field, or stop if it's a\n+                        // pointer\n+                        arg = field;\n+                        continue 'descend_newtypes;\n+                    }\n+                }\n+\n+                bug!(\"receiver has no non-zero-sized fields {:?}\", arg);\n+            }\n+        }\n+\n         if let ty::Ref(_, ty, _) = arg.layout().ty.kind() {\n             if ty.is_dyn_star() {\n                 let inner_layout = fx.layout_of(arg.layout().ty.builtin_deref(true).unwrap().ty);"}, {"sha": "d2b7724a2215fc82381804e3031e7df191707ebb", "filename": "compiler/rustc_codegen_gcc/.github/workflows/ci.yml", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -4,36 +4,72 @@ on:\n   - push\n   - pull_request\n \n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n jobs:\n   build:\n-    runs-on: ubuntu-latest\n+    runs-on: ubuntu-22.04\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\", \"libgccjit12.so\"]\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master\" }\n+          - { gcc: \"libgccjit_without_int128.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master-without-128bit-integers\" }\n+          - { gcc: \"libgccjit12.so\", extra: \"--no-default-features\", env_extra: \"TEST_FLAGS='-Cpanic=abort -Zpanic-abort-tests'\", artifacts_branch: \"gcc12\" }\n+        commands: [\n+          \"--mini-tests\",\n+          \"--std-tests\",\n+          # FIXME: re-enable asm tests when GCC can emit in the right syntax.\n+          # \"--asm-tests\",\n+          \"--test-libcore\",\n+          \"--extended-rand-tests\",\n+          \"--extended-regex-example-tests\",\n+          \"--extended-regex-tests\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+          \"--test-failing-rustc\",\n+        ]\n \n     steps:\n-    - uses: actions/checkout@v2\n+    - uses: actions/checkout@v3\n \n-    - uses: actions/checkout@v2\n+    - uses: actions/checkout@v3\n       with:\n         repository: llvm/llvm-project\n         path: llvm\n \n     - name: Install packages\n-      run: sudo apt-get install ninja-build ripgrep\n+      # `llvm-14-tools` is needed to install the `FileCheck` binary which is used for asm tests.\n+      run: sudo apt-get install ninja-build ripgrep llvm-14-tools\n+\n+    - name: Install libgccjit12\n+      if: matrix.libgccjit_version.gcc == 'libgccjit12.so'\n+      run: sudo apt-get install libgccjit-12-dev\n \n     - name: Download artifact\n+      if: matrix.libgccjit_version.gcc != 'libgccjit12.so'\n       uses: dawidd6/action-download-artifact@v2\n       with:\n           workflow: main.yml\n-          name: ${{ matrix.libgccjit_version }}\n+          name: ${{ matrix.libgccjit_version.gcc }}\n           path: gcc-build\n           repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n           search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n \n     - name: Setup path to libgccjit\n+      if: matrix.libgccjit_version.gcc == 'libgccjit12.so'\n+      run: echo /usr/lib/gcc/x86_64-linux-gnu/12 > gcc_path\n+\n+    - name: Setup path to libgccjit\n+      if: matrix.libgccjit_version.gcc != 'libgccjit12.so'\n       run: |\n           echo $(readlink -f gcc-build) > gcc_path\n           # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n@@ -48,49 +84,44 @@ jobs:\n     - name: Set RUST_COMPILER_RT_ROOT\n       run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n \n-    # https://github.com/actions/cache/issues/133\n-    - name: Fixup owner of ~/.cargo/\n-      # Don't remove the trailing /. It is necessary to follow the symlink.\n-      run: sudo chown -R $(whoami):$(id -ng) ~/.cargo/\n-\n     - name: Cache cargo installed crates\n-      uses: actions/cache@v1.1.2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: cargo-installed-crates2-ubuntu-latest\n \n     - name: Cache cargo registry\n-      uses: actions/cache@v1\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/registry\n         key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo index\n-      uses: actions/cache@v1\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/git\n         key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v1.1.2\n+      uses: actions/cache@v3\n       with:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n \n-    - name: Build\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        ./prepare_build.sh\n-        ./build.sh\n-        cargo test\n-        ./clean_all.sh\n+    #- name: Cache rust repository\n+      ## We only clone the rust repository for rustc tests\n+      #if: ${{ contains(matrix.commands, 'rustc') }}\n+      #uses: actions/cache@v3\n+      #id: cache-rust-repository\n+      #with:\n+        #path: rust\n+        #key: ${{ runner.os }}-packages-${{ hashFiles('rust/.git/HEAD') }}\n \n     - name: Build\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n       run: |\n         ./prepare_build.sh\n-        ./build.sh --no-default-features\n-        cargo test --no-default-features\n+        ${{ matrix.libgccjit_version.env_extra }} ./build.sh ${{ matrix.libgccjit_version.extra }}\n+        ${{ matrix.libgccjit_version.env_extra }} cargo test ${{ matrix.libgccjit_version.extra }}\n         ./clean_all.sh\n \n     - name: Prepare dependencies\n@@ -106,26 +137,16 @@ jobs:\n         command: build\n         args: --release\n \n-    - name: Test\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n+    - name: Add more failing tests for GCC 12\n+      if: ${{ matrix.libgccjit_version.gcc == 'libgccjit12.so' }}\n+      run: cat failing-ui-tests12.txt >> failing-ui-tests.txt\n \n-        ./test.sh --release\n-\n-    - name: Test\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n+    - name: Run tests\n       run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n+        ${{ matrix.libgccjit_version.env_extra }} ./test.sh --release --clean --build-sysroot ${{ matrix.commands }} ${{ matrix.libgccjit_version.extra }}\n \n-        ./test.sh --release --no-default-features\n+  duplicates:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+      - run: python tools/check_intrinsics_duplicates.py"}, {"sha": "c4e99469bc20b4fcf27dc2da43507a728d445555", "filename": "compiler/rustc_codegen_gcc/.github/workflows/release.yml", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,111 @@\n+name: CI with sysroot compiled in release mode\n+\n+on:\n+  - push\n+  - pull_request\n+\n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", artifacts_branch: \"master\" }\n+        commands: [\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+        ]\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - uses: actions/checkout@v3\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: ${{ matrix.libgccjit_version.gcc }}\n+          path: gcc-build\n+          repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set env\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --release --release-sysroot\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Run tests\n+      run: |\n+        ./test.sh --release --clean --release-sysroot --build-sysroot ${{ matrix.commands }}"}, {"sha": "42fb35e738ffdbe3bfe14baa80287847a4b6531e", "filename": "compiler/rustc_codegen_gcc/.github/workflows/stdarch.yml", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,116 @@\n+name: stdarch tests with sysroot compiled in release mode\n+\n+on:\n+  - push\n+  - pull_request\n+\n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", artifacts_branch: \"master\" }\n+        commands: [\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+        ]\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - uses: actions/checkout@v3\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: ${{ matrix.libgccjit_version.gcc }}\n+          path: gcc-build\n+          repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set env\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --release --release-sysroot\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Run tests\n+      run: |\n+        ./test.sh --release --clean --release-sysroot --build-sysroot --mini-tests --std-tests --test-libcore\n+\n+    - name: Run stdarch tests\n+      run: |\n+        cd build_sysroot/sysroot_src/library/stdarch/\n+        CHANNEL=release TARGET=x86_64-unknown-linux-gnu ../../../../cargo.sh test"}, {"sha": "80e574189408828204c725279bb9d37cb3785a0c", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -35,15 +35,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -208,6 +208,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"gccjit\",\n  \"lang_tester\",\n+ \"smallvec\",\n  \"tempfile\",\n ]\n \n@@ -220,6 +221,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n+\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "81066d9ce1f0acd9686f452d201db46eee17bc77", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -27,6 +27,8 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n+\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "bb741943892549aa118f2605ed9f8f2ebe160008", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 86, "deletions": 6, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,5 +1,7 @@\n # WIP libgccjit codegen backend for rust\n \n+[![Chat on IRC](https://img.shields.io/badge/irc.libera.chat-%23rustc__codegen__gcc-blue.svg)](https://web.libera.chat/#rustc_codegen_gcc)\n+\n This is a GCC codegen for rustc, which means it can be loaded by the existing rustc frontend, but benefits from GCC: more architectures are supported and GCC's optimizations are used.\n \n **Despite its name, libgccjit can be used for ahead-of-time compilation, as is used here.**\n@@ -16,21 +18,61 @@ The patches in [this repository](https://github.com/antoyo/libgccjit-patches) ne\n (Those patches should work when applied on master, but in case it doesn't work, they are known to work when applied on 079c23cfe079f203d5df83fea8e92a60c7d7e878.)\n You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already includes these patches.**\n \n+To build it (most of these instructions come from [here](https://gcc.gnu.org/onlinedocs/jit/internals/index.html), so don't hesitate to take a look there if you encounter an issue):\n+\n+```bash\n+$ git clone https://github.com/antoyo/gcc\n+$ sudo apt install flex libmpfr-dev libgmp-dev libmpc3 libmpc-dev\n+$ mkdir gcc-build gcc-install\n+$ cd gcc-build\n+$ ../gcc/configure \\\n+    --enable-host-shared \\\n+    --enable-languages=jit \\\n+    --enable-checking=release \\ # it enables extra checks which allow to find bugs\n+    --disable-bootstrap \\\n+    --disable-multilib \\\n+    --prefix=$(pwd)/../gcc-install\n+$ make -j4 # You can replace `4` with another number depending on how many cores you have.\n+```\n+\n+If you want to run libgccjit tests, you will need to also enable the C++ language in the `configure`:\n+\n+```bash\n+--enable-languages=jit,c++\n+```\n+\n+Then to run libgccjit tests:\n+\n+```bash\n+$ cd gcc # from the `gcc-build` folder\n+$ make check-jit\n+# To run one specific test:\n+$ make check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=jit.dg/test-asm.cc\"\n+```\n+\n **Put the path to your custom build of libgccjit in the file `gcc_path`.**\n \n ```bash\n-$ git clone https://github.com/rust-lang/rustc_codegen_gcc.git\n-$ cd rustc_codegen_gcc\n+$ dirname $(readlink -f `find . -name libgccjit.so`) > gcc_path\n+```\n+\n+You also need to set RUST_COMPILER_RT_ROOT:\n+\n+```bash\n $ git clone https://github.com/llvm/llvm-project llvm --depth 1 --single-branch\n $ export RUST_COMPILER_RT_ROOT=\"$PWD/llvm/compiler-rt\"\n-$ ./prepare_build.sh # download and patch sysroot src\n-$ ./build.sh --release\n ```\n \n-To run the tests:\n+Then you can run commands like this:\n \n ```bash\n $ ./prepare.sh # download and patch sysroot src and install hyperfine for benchmarking\n+$ LIBRARY_PATH=$(cat gcc_path) LD_LIBRARY_PATH=$(cat gcc_path) ./build.sh --release\n+```\n+\n+To run the tests:\n+\n+```bash\n $ ./test.sh --release\n ```\n \n@@ -120,13 +162,52 @@ To print a debug representation of a tree:\n debug_tree(expr);\n ```\n \n+(defined in print-tree.h)\n+\n+To print a debug reprensentation of a gimple struct:\n+\n+```c\n+debug_gimple_stmt(gimple_struct)\n+```\n+\n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n \n+To have the correct file paths in `gdb` instead of `/usr/src/debug/gcc/libstdc++-v3/libsupc++/eh_personality.cc`:\n+\n+Maybe by calling the following at the beginning of gdb:\n+\n+```\n+set substitute-path /usr/src/debug/gcc /path/to/gcc-repo/gcc\n+```\n+\n+TODO(antoyo): but that's not what I remember I was doing.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n \n+### How to install a forked git-subtree\n+\n+Using git-subtree with `rustc` requires a patched git to make it work.\n+The PR that is needed is [here](https://github.com/gitgitgadget/git/pull/493).\n+Use the following instructions to install it:\n+\n+```\n+git clone git@github.com:tqc/git.git\n+cd git\n+git checkout tqc/subtree\n+make\n+make install\n+cd contrib/subtree\n+make\n+cp git-subtree ~/bin\n+```\n+\n+### How to use [mem-trace](https://github.com/antoyo/mem-trace)\n+\n+`rustc` needs to be built without `jemalloc` so that `mem-trace` can overload `malloc` since `jemalloc` is linked statically, so a `LD_PRELOAD`-ed library won't a chance to intercept the calls to `malloc`.\n+\n ### How to build a cross-compiling libgccjit\n \n #### Building libgccjit\n@@ -142,6 +223,5 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Since rustc doesn't support this architecture yet, set it back to `TARGET_TRIPLE=\"mips-unknown-linux-gnu\"` (or another target having the same attributes). Alternatively, create a [target specification file](https://book.avr-rust.com/005.1-the-target-specification-json-file.html) (note that the `arch` specified in this file must be supported by the rust compiler).\n  * Set `linker='-Clinker=m68k-linux-gcc'`.\n  * Set the path to the cross-compiling libgccjit in `gcc_path`.\n- * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n  * Comment the line: `context.add_command_line_option(\"-masm=intel\");` in src/base.rs.\n  * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "9d692d599f6bef19852222ea918d3d942856f48c", "filename": "compiler/rustc_codegen_gcc/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -16,7 +16,7 @@ rm Cargo.lock test_target/Cargo.lock 2>/dev/null || true\n rm -r sysroot/ 2>/dev/null || true\n \n # Build libs\n-export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked -Cpanic=abort\"\n+export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked\"\n if [[ \"$1\" == \"--release\" ]]; then\n     sysroot_channel='release'\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release"}, {"sha": "166e83901c4f956b1d89762126eaa3291a8a936b", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot $TEST_FLAGS\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "754e7931412daa8fe46632a74b3a27b13e2a639b", "filename": "compiler/rustc_codegen_gcc/example/alloc_example.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, core_intrinsics, alloc_error_handler)]\n+#![feature(start, core_intrinsics, alloc_error_handler, lang_items)]\n #![no_std]\n \n extern crate alloc;\n@@ -18,21 +18,27 @@ extern \"C\" {\n \n #[panic_handler]\n fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n }\n \n #[alloc_error_handler]\n fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() -> ! {\n+    loop {}\n+}\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    core::intrinsics::unreachable();\n }\n \n #[start]\n fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    let world: Box<&str> = box \"Hello World!\\0\";\n+    let world: Box<&str> = Box::new(\"Hello World!\\0\");\n     unsafe {\n         puts(*world as *const str as *const u8);\n     }"}, {"sha": "9ec18da90d819986856eb55ab47394ce6335195c", "filename": "compiler/rustc_codegen_gcc/example/alloc_system.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_system.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,12 +1,6 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n+// SPDX-License-Identifier: MIT OR Apache-2.0\n+// SPDX-FileCopyrightText: The Rust Project Developers (see https://thanks.rust-lang.org)\n+\n #![no_std]\n #![feature(allocator_api, rustc_private)]\n #![cfg_attr(any(unix, target_os = \"redox\"), feature(libc))]"}, {"sha": "637b8dc53fefd6045253163f4eedde382035def8", "filename": "compiler/rustc_codegen_gcc/example/mini_core.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,6 +1,6 @@\n #![feature(\n     no_core, lang_items, intrinsics, unboxed_closures, type_ascription, extern_types,\n-    untagged_unions, decl_macro, rustc_attrs, transparent_unions, auto_traits,\n+    decl_macro, rustc_attrs, transparent_unions, auto_traits,\n     thread_local\n )]\n #![no_core]\n@@ -17,6 +17,9 @@ pub trait Sized {}\n #[lang = \"destruct\"]\n pub trait Destruct {}\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -39,14 +42,14 @@ impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut\n impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U, ()>> for Box<T, ()> {}\n \n #[lang = \"receiver\"]\n pub trait Receiver {}\n \n impl<T: ?Sized> Receiver for &T {}\n impl<T: ?Sized> Receiver for &mut T {}\n-impl<T: ?Sized> Receiver for Box<T> {}\n+impl<T: ?Sized, A: Allocator> Receiver for Box<T, A> {}\n \n #[lang = \"copy\"]\n pub unsafe trait Copy {}\n@@ -396,7 +399,7 @@ pub struct PhantomData<T: ?Sized>;\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -405,13 +408,21 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_cannot_unwind\"]\n+fn panic_cannot_unwind() -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -450,25 +461,40 @@ pub trait Deref {\n pub trait Allocator {\n }\n \n+impl Allocator for () {}\n+\n pub struct Global;\n \n impl Allocator for Global {}\n \n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[rustc_nonnull_optimization_guaranteed]\n+pub struct NonNull<T: ?Sized>(pub *const T);\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n+\n+pub struct Unique<T: ?Sized> {\n+    pub pointer: NonNull<T>,\n+    pub _marker: PhantomData<T>,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+\n #[lang = \"owned_box\"]\n-pub struct Box<\n-    T: ?Sized,\n-    A: Allocator = Global,\n->(*mut T, A);\n+pub struct Box<T: ?Sized, A: Allocator = Global>(Unique<T>, A);\n \n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n \n impl<T: ?Sized, A: Allocator> Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler.\n     }\n }\n \n-impl<T> Deref for Box<T> {\n+impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {\n@@ -482,8 +508,8 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: *mut T, alloc: A) {\n-    libc::free(ptr as *mut u8);\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n+    libc::free(ptr.pointer.0 as *mut u8);\n }\n \n #[lang = \"drop\"]\n@@ -505,17 +531,25 @@ pub union MaybeUninit<T> {\n }\n \n pub mod intrinsics {\n+    use crate::Sized;\n+\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n+        #[rustc_safe_intrinsic]\n         pub fn size_of<T>() -> usize;\n-        pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn size_of_val<T: ?Sized>(val: *const T) -> usize;\n+        #[rustc_safe_intrinsic]\n         pub fn min_align_of<T>() -> usize;\n-        pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn min_align_of_val<T: ?Sized>(val: *const T) -> usize;\n         pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n         pub fn transmute<T, U>(e: T) -> U;\n         pub fn ctlz_nonzero<T>(x: T) -> T;\n-        pub fn needs_drop<T: ?::Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n+        pub fn needs_drop<T: ?Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n         pub fn bitreverse<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn bswap<T>(x: T) -> T;\n         pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n         pub fn unreachable() -> !;"}, {"sha": "cff26077740b03c0896b85440376d8c2b3a52623", "filename": "compiler/rustc_codegen_gcc/example/mini_core_hello_world.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,7 +1,7 @@\n // Adapted from https://github.com/sunfishcode/mir2cranelift/blob/master/rust-examples/nocore-hello-world.rs\n \n #![feature(\n-    no_core, unboxed_closures, start, lang_items, box_syntax, never_type, linkage,\n+    no_core, unboxed_closures, start, lang_items, never_type, linkage,\n     extern_types, thread_local\n )]\n #![no_core]\n@@ -85,6 +85,7 @@ fn start<T: Termination + 'static>(\n     main: fn() -> T,\n     argc: isize,\n     argv: *const *const u8,\n+    _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n         unsafe { puts(*argv); }\n@@ -162,7 +163,7 @@ fn main() {\n         let ptr: *const u8 = hello as *const [u8] as *const u8;\n         puts(ptr);\n \n-        let world: Box<&str> = box \"World!\\0\";\n+        let world: Box<&str> = Box::new(\"World!\\0\");\n         puts(*world as *const str as *const u8);\n         world as Box<dyn SomeTrait>;\n \n@@ -222,12 +223,13 @@ fn main() {\n         }\n     }\n \n-    let _ = box NoisyDrop {\n+    let _ = Box::new(NoisyDrop {\n         text: \"Boxed outer got dropped!\\0\",\n         inner: NoisyDropInner,\n-    } as Box<dyn SomeTrait>;\n+    }) as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n+    #[allow(unreachable_code)]\n     match FUNC_REF {\n         Some(_) => {},\n         None => assert!(false),"}, {"sha": "5e2e7f25a2c084974d2e36e0a6a01bd1a5ccde48", "filename": "compiler/rustc_codegen_gcc/example/mod_bench.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,14 +1,12 @@\n-#![feature(start, box_syntax, core_intrinsics, lang_items)]\n+#![feature(start, core_intrinsics, lang_items)]\n #![no_std]\n \n #[link(name = \"c\")]\n extern {}\n \n #[panic_handler]\n fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n }\n \n #[lang=\"eh_personality\"]\n@@ -32,6 +30,6 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n #[inline(never)]\n fn black_box(i: u32) {\n     if i != 1 {\n-        unsafe { core::intrinsics::abort(); }\n+        core::intrinsics::abort();\n     }\n }"}, {"sha": "5c171c49fd1940c8be7d44f6194a33e62dcef3b2", "filename": "compiler/rustc_codegen_gcc/example/std_example.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,5 +1,6 @@\n #![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n \n+#[cfg(feature=\"master\")]\n use std::arch::x86_64::*;\n use std::io::Write;\n use std::ops::Generator;"}, {"sha": "8539e27ea6a58352f5dc0f77b3b598051b37c05e", "filename": "compiler/rustc_codegen_gcc/failing-ui-tests.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,68 @@\n+tests/ui/allocator/custom-in-block.rs\n+tests/ui/allocator/custom-in-submodule.rs\n+tests/ui/allocator/custom.rs\n+tests/ui/allocator/hygiene.rs\n+tests/ui/allocator/no_std-alloc-error-handler-custom.rs\n+tests/ui/allocator/no_std-alloc-error-handler-default.rs\n+tests/ui/allocator/xcrate-use.rs\n+tests/ui/allocator/xcrate-use2.rs\n+tests/ui/asm/may_unwind.rs\n+tests/ui/asm/x86_64/multiple-clobber-abi.rs\n+tests/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs\n+tests/ui/functions-closures/parallel-codegen-closures.rs\n+tests/ui/linkage-attr/linkage1.rs\n+tests/ui/lto/dylib-works.rs\n+tests/ui/numbers-arithmetic/saturating-float-casts.rs\n+tests/ui/polymorphization/promoted-function.rs\n+tests/ui/process/nofile-limit.rs\n+tests/ui/sepcomp/sepcomp-cci.rs\n+tests/ui/sepcomp/sepcomp-extern.rs\n+tests/ui/sepcomp/sepcomp-fns-backwards.rs\n+tests/ui/sepcomp/sepcomp-fns.rs\n+tests/ui/sepcomp/sepcomp-statics.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-pass.rs\n+tests/ui/sse2.rs\n+tests/ui/target-feature/missing-plusminus.rs\n+tests/ui/asm/x86_64/may_unwind.rs\n+tests/ui/backtrace.rs\n+tests/ui/catch-unwind-bang.rs\n+tests/ui/cfg/cfg-panic-abort.rs\n+tests/ui/drop/dynamic-drop-async.rs\n+tests/ui/drop/repeat-drop.rs\n+tests/ui/fmt/format-args-capture.rs\n+tests/ui/generator/panic-drops-resume.rs\n+tests/ui/generator/panic-drops.rs\n+tests/ui/intrinsics/panic-uninitialized-zeroed.rs\n+tests/ui/iterators/iter-sum-overflow-debug.rs\n+tests/ui/iterators/iter-sum-overflow-overflow-checks.rs\n+tests/ui/mir/mir_calls_to_shims.rs\n+tests/ui/mir/mir_drop_order.rs\n+tests/ui/mir/mir_let_chains_drop_order.rs\n+tests/ui/oom_unwind.rs\n+tests/ui/panic-runtime/abort-link-to-unwinding-crates.rs\n+tests/ui/panic-runtime/abort.rs\n+tests/ui/panic-runtime/link-to-abort.rs\n+tests/ui/unwind-no-uwtable.rs\n+tests/ui/parser/unclosed-delimiter-in-dep.rs\n+tests/ui/runtime/rt-explody-panic-payloads.rs\n+tests/ui/simd/intrinsic/ptr-cast.rs\n+tests/ui/binding/fn-arg-incomplete-pattern-drop-order.rs\n+tests/ui/consts/missing_span_in_backtrace.rs\n+tests/ui/drop/dynamic-drop.rs\n+tests/ui/dyn-star/box.rs\n+tests/ui/issues/issue-40883.rs\n+tests/ui/issues/issue-43853.rs\n+tests/ui/issues/issue-47364.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs\n+tests/ui/rfc-2091-track-caller/std-panic-locations.rs\n+tests/ui/rfcs/rfc1857-drop-order.rs\n+tests/ui/simd/issue-17170.rs\n+tests/ui/simd/issue-39720.rs\n+tests/ui/simd/issue-89193.rs\n+tests/ui/statics/issue-91050-1.rs\n+tests/ui/statics/issue-91050-2.rs\n+tests/ui/alloc-error/default-alloc-error-hook.rs\n+tests/ui/generator/panic-safe.rs\n+tests/ui/issues/issue-14875.rs\n+tests/ui/issues/issue-29948.rs\n+tests/ui/panic-while-printing.rs"}, {"sha": "8c27bd8b8ca89f133210fa477dca33946f3e11e0", "filename": "compiler/rustc_codegen_gcc/failing-ui-tests12.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,39 @@\n+tests/ui/asm/x86_64/issue-96797.rs\n+tests/ui/intrinsics/const-eval-select-x86_64.rs\n+tests/ui/packed/packed-struct-drop-aligned.rs\n+tests/ui/packed/packed-struct-generic-layout.rs\n+tests/ui/packed/packed-struct-layout.rs\n+tests/ui/packed/packed-struct-optimized-enum.rs\n+tests/ui/packed/packed-struct-size.rs\n+tests/ui/packed/packed-struct-vec.rs\n+tests/ui/packed/packed-tuple-struct-layout.rs\n+tests/ui/simd/array-type.rs\n+tests/ui/simd/intrinsic/float-minmax-pass.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n+tests/ui/simd/intrinsic/generic-as.rs\n+tests/ui/simd/intrinsic/generic-cast-pass.rs\n+tests/ui/simd/intrinsic/generic-cast-pointer-width.rs\n+tests/ui/simd/intrinsic/generic-comparison-pass.rs\n+tests/ui/simd/intrinsic/generic-elements-pass.rs\n+tests/ui/simd/intrinsic/generic-reduction-pass.rs\n+tests/ui/simd/intrinsic/generic-select-pass.rs\n+tests/ui/simd/intrinsic/inlining-issue67557-ice.rs\n+tests/ui/simd/intrinsic/inlining-issue67557.rs\n+tests/ui/simd/monomorphize-shuffle-index.rs\n+tests/ui/simd/shuffle.rs\n+tests/ui/simd/simd-bitmask.rs\n+tests/ui/generator/resume-after-return.rs\n+tests/ui/iterators/iter-step-overflow-debug.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs\n+tests/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs\n+tests/ui/privacy/reachable-unnameable-items.rs\n+tests/ui/rfc-1937-termination-trait/termination-trait-in-test.rs\n+tests/ui/async-await/async-fn-size-moved-locals.rs\n+tests/ui/async-await/async-fn-size-uninit-locals.rs\n+tests/ui/cfg/cfg-panic.rs\n+tests/ui/generator/size-moved-locals.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs\n+tests/ui/simd/intrinsic/generic-gather-pass.rs\n+tests/ui/simd/issue-85915-simd-ptrs.rs\n+tests/ui/issues/issue-68010-large-zst-consts.rs\n+tests/ui/rust-2018/proc-macro-crate-in-paths.rs"}, {"sha": "0a94a08f8dca86fec574ab0833925d5f9b0df2e0", "filename": "compiler/rustc_codegen_gcc/messages.ftl", "status": "renamed", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -60,3 +60,9 @@ codegen_gcc_invalid_monomorphization_unsupported_cast =\n \n codegen_gcc_invalid_monomorphization_unsupported_operation =\n     invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_gcc_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n+\n+codegen_gcc_tied_target_features = the target features {$features} must all be either enabled or disabled together\n+    .help = add the missing features in a `target_feature` attribute", "previous_filename": "compiler/rustc_codegen_gcc/locales/en-US.ftl"}, {"sha": "93c63b5dcacfda4c14539665d4a004baeb2ae3c3", "filename": "compiler/rustc_codegen_gcc/patches/0001-Add-stdarch-Cargo.toml-for-testing.patch", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,39 @@\n+From c3821e02fbd6cb5ad6e06d759fccdc9073712375 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Tue, 7 Jun 2022 21:40:13 -0400\n+Subject: [PATCH] Add stdarch Cargo.toml for testing\n+\n+---\n+ library/stdarch/Cargo.toml | 20 ++++++++++++++++++++\n+ 1 file changed, 20 insertions(+)\n+ create mode 100644 library/stdarch/Cargo.toml\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+new file mode 100644\n+index 0000000..fbe0a95\n+--- /dev/null\n++++ b/library/stdarch/Cargo.toml\n+@@ -0,0 +1,20 @@\n++[workspace]\n++members = [\n++  \"crates/core_arch\",\n++  \"crates/std_detect\",\n++  \"crates/stdarch-gen\",\n++  \"examples/\"\n++]\n++exclude = [\n++  \"crates/wasm-assert-instr-tests\"\n++]\n++\n++[profile.release]\n++debug = true\n++opt-level = 3\n++incremental = true\n++\n++[profile.bench]\n++debug = 1\n++opt-level = 3\n++incremental = true\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "1b71df1ca8df2c4ef5eb86cf408c1574f7277d54", "filename": "compiler/rustc_codegen_gcc/patches/0001-Disable-examples.patch", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,25 @@\n+From a2d53a324a02c04b76c0e9d39dc15cd443a3b8b2 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Fri, 25 Nov 2022 11:18:11 -0500\n+Subject: [PATCH] Disable examples\n+\n+---\n+ library/stdarch/Cargo.toml | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+index fbe0a95..748d72d 100644\n+--- a/library/stdarch/Cargo.toml\n++++ b/library/stdarch/Cargo.toml\n+@@ -3,7 +3,7 @@ members = [\n+   \"crates/core_arch\",\n+   \"crates/std_detect\",\n+   \"crates/stdarch-gen\",\n+-  \"examples/\"\n++  #\"examples/\"\n+ ]\n+ exclude = [\n+   \"crates/wasm-assert-instr-tests\"\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "4db56fa3bd2c7667f525f8db752ef5c84d75f290", "filename": "compiler/rustc_codegen_gcc/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -18,7 +18,7 @@ new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n +++ b/library/core/tests/Cargo.toml\n-@@ -0,0 +1,8 @@\n+@@ -0,0 +1,12 @@\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n@@ -27,37 +27,18 @@ index 0000000..46fd999\n +[lib]\n +name = \"coretests\"\n +path = \"lib.rs\"\n-diff --git a/library/core/tests/num/flt2dec/mod.rs b/library/core/tests/num/flt2dec/mod.rs\n-index a35897e..f0bf645 100644\n---- a/library/core/tests/num/flt2dec/mod.rs\n-+++ b/library/core/tests/num/flt2dec/mod.rs\n-@@ -13,7 +13,6 @@ mod strategy {\n-     mod dragon;\n-     mod grisu;\n- }\n--mod random;\n- \n- pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n-     match decode(v).1 {\n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n-index 6609bc3..241b497 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n-@@ -1209,6 +1209,7 @@ fn brute_force_rotate_test_1() {\n-     }\n- }\n- \n-+/*\n- #[test]\n- #[cfg(not(target_arch = \"wasm32\"))]\n- fn sort_unstable() {\n-@@ -1394,6 +1395,7 @@ fn partition_at_index() {\n-     v.select_nth_unstable(0);\n-     assert!(v == [0xDEADBEEF]);\n- }\n-+*/\n- \n- #[test]\n- #[should_panic(expected = \"index 0 greater than length of slice\")]\n++\n++[dependencies]\n++rand = { version = \"0.8.5\", default-features = false }\n++rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/library/core/tests/lib.rs\n++++ b/library/core/tests/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "c59a40df03988aeec2b908ad36e9e4413793533b", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=21549dac539dc220f052d038ec643645cedbbd6d", "patch": "@@ -1,28 +0,0 @@\n-From b1ae000f6da1abd3b8e9b80c40bc11c89b8ae93c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 30 Dec 2021 16:54:40 +0100\n-Subject: [PATCH] [core] Disable portable-simd test\n-\n----\n- library/core/tests/lib.rs | 1 -\n- 1 file changed, 1 deletion(-)\n-\n-diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n-index 06c7be0..359e2e7 100644\n---- a/library/core/tests/lib.rs\n-+++ b/library/core/tests/lib.rs\n-@@ -75,7 +75,6 @@\n- #![feature(never_type)]\n- #![feature(unwrap_infallible)]\n--#![feature(portable_simd)]\n- #![feature(ptr_metadata)]\n- #![feature(once_cell)]\n- #![feature(option_result_contains)]\n-@@ -127,7 +126,6 @@ mod pin;\n- mod pin_macro;\n- mod ptr;\n- mod result;\n--mod simd;\n- mod slice;\n- mod str;\n- mod str_lossy;"}, {"sha": "933ecd45baadb63632cbd08ba7431e1a9e6ef077", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-06-06\"\n+channel = \"nightly-2023-03-02\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "59143eac37b3f03a23ec3d7538b2a34feec9823c", "filename": "compiler/rustc_codegen_gcc/rustc_patches/compile_test.patch", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch?ref=21549dac539dc220f052d038ec643645cedbbd6d", "patch": "@@ -1,14 +0,0 @@\n-diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n-index 887d27fd6dca4..2c2239f2b83d1 100644\n---- a/src/tools/compiletest/src/header.rs\n-+++ b/src/tools/compiletest/src/header.rs\n-@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n-     cfg: Option<&str>,\n- ) -> test::TestDesc {\n-     let mut ignore = false;\n-     #[cfg(not(bootstrap))]\n--    let ignore_message: Option<String> = None;\n-+    let ignore_message: Option<&str> = None;\n-     let mut should_fail = false;\n-\n-     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();"}, {"sha": "4bad33ee879ee4f1c27ba1c2e1352f98c483d9e1", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_middle::bug;\n@@ -50,7 +52,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n         if tcx.sess.target.options.default_hidden_visibility {\n-            // TODO(antoyo): set visibility.\n+            #[cfg(feature=\"master\")]\n+            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n             // TODO(antoyo): emit unwind tables.\n@@ -61,7 +64,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n             .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n             .collect();\n         let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        // TODO(antoyo): set visibility.\n+        #[cfg(feature=\"master\")]\n+        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n         let block = func.new_block(\"entry\");\n \n@@ -90,12 +94,18 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n+    if tcx.sess.target.default_hidden_visibility {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+    }\n+\n     let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();\n     let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n-    //llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+    #[cfg(feature=\"master\")]\n+    callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n     let block = func.new_block(\"entry\");\n "}, {"sha": "41e9d61a10e50b53dd5b280cc7c1a1e236d163a8", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 125, "deletions": 86, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     use ConstraintOrRegister::*;\n \n                     let (constraint, ty) = match (reg_to_gcc(reg), place) {\n-                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n                         // needs to be of a type that's \"compatible\" with the register class, but specific type\n@@ -226,7 +226,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // This decision is also backed by the fact that LLVM needs in and out\n                     // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n-                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let ty = in_value.layout.gcc_type(self.cx);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n@@ -286,7 +286,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             continue\n                         };\n \n-                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let ty = out_place.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -306,7 +306,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `in(\"explicit register\") var`\n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let ty = value.layout.gcc_type(self.cx);\n                         let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n@@ -325,7 +325,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         // See explanation in the first pass.\n-                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let ty = in_value.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -353,8 +353,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     inputs.push(AsmInOperand {\n                         constraint: \"X\".into(),\n                         rust_idx,\n-                        val: self.cx.rvalue_as_function(get_fn(self.cx, instance))\n-                            .get_address(None),\n+                        val: get_fn(self.cx, instance).get_address(None),\n                     });\n                 }\n \n@@ -382,15 +381,19 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    // TODO(@Commeownist): switch to `Iterator::intersperse` once it's stable\n-                    let mut iter = string.split('%');\n-                    if let Some(s) = iter.next() {\n-                        template_str.push_str(s);\n-                    }\n-\n-                    for s in iter {\n-                        template_str.push_str(\"%%\");\n-                        template_str.push_str(s);\n+                    for char in string.chars() {\n+                        // TODO(antoyo): might also need to escape | if rustc doesn't do it.\n+                        let escaped_char =\n+                            match char {\n+                                '%' => \"%%\",\n+                                '{' => \"%{\",\n+                                '}' => \"%}\",\n+                                _ => {\n+                                    template_str.push(char);\n+                                    continue;\n+                                },\n+                            };\n+                        template_str.push_str(escaped_char);\n                     }\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n@@ -565,56 +568,71 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n                 _ => unimplemented!(),\n             }\n         },\n+        // They can be retrieved from https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => \"x\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => {\n+                unreachable!(\"clobber-only\")\n+            }\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => unimplemented!(),\n-            InlineAsmRegClass::Avr(_) => unimplemented!(),\n-            InlineAsmRegClass::Bpf(_) => unimplemented!(),\n-            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n-            InlineAsmRegClass::Msp430(_) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => unimplemented!(),\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"t\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_upper) => \"d\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw) => \"w\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => \"e\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"d\", // more specific than \"r\"\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n+            // https://github.com/gcc-mirror/gcc/blob/master/gcc/config/nvptx/nvptx.md -> look for\n+            // \"define_constraint\".\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n+\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => \"b\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n             | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n                 unreachable!(\"clobber-only\")\n             },\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => {\n+                unreachable!(\"clobber-only\")\n+            }\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => unimplemented!(),\n-            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n-                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg,\n+                X86InlineAsmRegClass::kreg0\n+                | X86InlineAsmRegClass::x87_reg\n+                | X86InlineAsmRegClass::mmx_reg\n+                | X86InlineAsmRegClass::tmm_reg,\n             ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n             }\n-            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Err => unreachable!(),\n         }\n     };\n@@ -692,21 +710,23 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             && options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n         // Build the template string\n-        let mut template_str = String::new();\n+        let mut template_str = \".pushsection .text\\n\".to_owned();\n+        if att_dialect {\n+            template_str.push_str(\".att_syntax\\n\");\n+        }\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    for line in string.lines() {\n+                    let mut index = 0;\n+                    while index < string.len() {\n                         // NOTE: gcc does not allow inline comment, so remove them.\n-                        let line =\n-                            if let Some(index) = line.rfind(\"//\") {\n-                                &line[..index]\n-                            }\n-                            else {\n-                                line\n-                            };\n-                        template_str.push_str(line);\n-                        template_str.push('\\n');\n+                        let comment_index = string[index..].find(\"//\")\n+                            .map(|comment_index| comment_index + index)\n+                            .unwrap_or(string.len());\n+                        template_str.push_str(&string[index..comment_index]);\n+                        index = string[comment_index..].find('\\n')\n+                            .map(|index| index + comment_index)\n+                            .unwrap_or(string.len());\n                     }\n                 },\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: _ } => {\n@@ -719,6 +739,8 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymFn { instance } => {\n+                            let function = get_fn(self, instance);\n+                            self.add_used_function(function);\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O)\n                             // or byte count suffixes (x86 Windows).\n@@ -727,6 +749,7 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(antoyo): set the global variable as used.\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O).\n                             let instance = Instance::mono(self.tcx, def_id);\n@@ -738,48 +761,51 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             }\n         }\n \n-        let template_str =\n-            if att_dialect {\n-                format!(\".att_syntax\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n-            }\n-            else {\n-                template_str\n-            };\n+        if att_dialect {\n+            template_str.push_str(\"\\n\\t.intel_syntax noprefix\");\n+        }\n         // NOTE: seems like gcc will put the asm in the wrong section, so set it to .text manually.\n-        let template_str = format!(\".pushsection .text\\n{}\\n.popsection\", template_str);\n+        template_str.push_str(\"\\n.popsection\");\n         self.context.add_top_level_asm(None, &template_str);\n     }\n }\n \n fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option<char>) -> Option<char> {\n+    // The modifiers can be retrieved from\n+    // https://gcc.gnu.org/onlinedocs/gcc/Modifiers.html#Modifiers\n     match reg {\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n-        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => modifier,\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n         | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n-            unimplemented!()\n+            if modifier == Some('v') { None } else { modifier }\n+        }\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => {\n+            unreachable!(\"clobber-only\")\n         }\n-        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)  => unimplemented!(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => None,\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n-        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => unimplemented!(),\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => None,\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n-        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => unimplemented!(),\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => Some('P'),\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n-            unimplemented!()\n+            if modifier.is_none() {\n+                Some('q')\n+            } else {\n+                modifier\n+            }\n         }\n-        InlineAsmRegClass::Avr(_) => unimplemented!(),\n-        InlineAsmRegClass::Bpf(_) => unimplemented!(),\n-        InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n-        InlineAsmRegClass::Mips(_) => unimplemented!(),\n-        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n-        InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n-        InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n+        InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::Mips(_) => None,\n+        InlineAsmRegClass::Nvptx(_) => None,\n+        InlineAsmRegClass::PowerPC(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n-        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n-        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => {\n+            unreachable!(\"clobber-only\")\n+        }\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n             None => if arch == InlineAsmArch::X86_64 { Some('q') } else { Some('k') },\n@@ -803,16 +829,29 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg) => {\n+        InlineAsmRegClass::X86(\n+            X86InlineAsmRegClass::x87_reg\n+            | X86InlineAsmRegClass::mmx_reg\n+            | X86InlineAsmRegClass::kreg0\n+            | X86InlineAsmRegClass::tmm_reg,\n+        ) => {\n             unreachable!(\"clobber-only\")\n         }\n-        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n+        InlineAsmRegClass::Bpf(_) => None,\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => match modifier {\n+            Some('h') => Some('B'),\n+            Some('l') => Some('A'),\n+            _ => None,\n+        },\n+        InlineAsmRegClass::Avr(_) => None,\n+        InlineAsmRegClass::S390x(_) => None,\n+        InlineAsmRegClass::Msp430(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n-        },\n-        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n-        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+        }\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }"}, {"sha": "db841b1b52408ab51d986b042f77ff74046df018", "filename": "compiler/rustc_codegen_gcc/src/attributes.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,113 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::Function;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_codegen_ssa::target_features::tied_target_features;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{context::CodegenCx, errors::TiedTargetFeatures};\n+\n+// Given a map from target_features to whether they are enabled or disabled,\n+// ensure only valid combinations are allowed.\n+pub fn check_tied_features(sess: &Session, features: &FxHashMap<&str, bool>) -> Option<&'static [&'static str]> {\n+    for tied in tied_target_features(sess) {\n+        // Tied features must be set to the same value, or not set at all\n+        let mut tied_iter = tied.iter();\n+        let enabled = features.get(tied_iter.next().unwrap());\n+        if tied_iter.any(|feature| enabled != features.get(feature)) {\n+            return Some(tied);\n+        }\n+    }\n+    None\n+}\n+\n+// TODO(antoyo): maybe move to a new module gcc_util.\n+// To find a list of GCC's names, check https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\n+fn to_gcc_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n+    match (arch, s) {\n+        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n+        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n+        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n+        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n+        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n+        (\"x86\", \"avx512vaes\") => smallvec![\"vaes\"],\n+        (\"x86\", \"avx512gfni\") => smallvec![\"gfni\"],\n+        (\"x86\", \"avx512vpclmulqdq\") => smallvec![\"vpclmulqdq\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512vbmi2'.\n+        (\"x86\", \"avx512vbmi2\") => smallvec![\"avx512vbmi2\", \"avx512bw\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512bitalg'.\n+        (\"x86\", \"avx512bitalg\") => smallvec![\"avx512bitalg\", \"avx512bw\"],\n+        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n+        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n+        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n+        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n+        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n+        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n+        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n+        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n+        // but we manually enable neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n+        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n+        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n+        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n+        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n+        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n+        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n+        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n+        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n+        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n+        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n+        (_, s) => smallvec![s],\n+    }\n+}\n+\n+/// Composite function which sets GCC attributes for function depending on its AST (`#[attribute]`)\n+/// attributes.\n+pub fn from_fn_attrs<'gcc, 'tcx>(\n+    cx: &CodegenCx<'gcc, 'tcx>,\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    func: Function<'gcc>,\n+    instance: ty::Instance<'tcx>,\n+) {\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n+\n+    let function_features =\n+        codegen_fn_attrs.target_features.iter().map(|features| features.as_str()).collect::<Vec<&str>>();\n+\n+    if let Some(features) = check_tied_features(cx.tcx.sess, &function_features.iter().map(|features| (*features, true)).collect()) {\n+        let span = cx.tcx\n+            .get_attr(instance.def_id(), sym::target_feature)\n+            .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n+        cx.tcx.sess.create_err(TiedTargetFeatures {\n+            features: features.join(\", \"),\n+            span,\n+        })\n+            .emit();\n+        return;\n+    }\n+\n+    let mut function_features = function_features\n+        .iter()\n+        .flat_map(|feat| to_gcc_features(cx.tcx.sess, feat).into_iter())\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\", // TODO(antoyo): support removing feature.\n+            InstructionSetAttr::ArmT32 => \"thumb-mode\",\n+        }))\n+        .collect::<Vec<_>>();\n+\n+    // TODO(antoyo): check if we really need global backend features. (Maybe they could be applied\n+    // globally?)\n+    let mut global_features = cx.tcx.global_backend_features(()).iter().map(|s| s.as_str());\n+    function_features.extend(&mut global_features);\n+    let target_features = function_features.join(\",\");\n+    if !target_features.is_empty() {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Target(&target_features));\n+    }\n+}"}, {"sha": "5f54ac4ebc69a63c5e372f3b23f73e0587f04901", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -57,6 +57,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 if env::var(\"CG_GCCJIT_DUMP_TO_FILE\").as_deref() == Ok(\"1\") {\n                     let _ = fs::create_dir(\"/tmp/gccjit_dumps\");\n                     let path = &format!(\"/tmp/gccjit_dumps/{}.c\", module.name);\n+                    context.set_debug_info(true);\n                     context.dump_to_file(path, true);\n                 }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));"}, {"sha": "dcd560b3dcd952efe7d81228ac4403d1f8b748ab", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -8,6 +8,8 @@ use gccjit::{\n };\n use rustc_middle::dep_graph;\n use rustc_middle::ty::TyCtxt;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::mir::mono::Visibility;\n use rustc_middle::mir::mono::Linkage;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -20,6 +22,15 @@ use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n+#[cfg(feature=\"master\")]\n+pub fn visibility_to_gcc(linkage: Visibility) -> gccjit::Visibility {\n+    match linkage {\n+        Visibility::Default => gccjit::Visibility::Default,\n+        Visibility::Hidden => gccjit::Visibility::Hidden,\n+        Visibility::Protected => gccjit::Visibility::Protected,\n+    }\n+}\n+\n pub fn global_linkage_to_gcc(linkage: Linkage) -> GlobalKind {\n     match linkage {\n         Linkage::External => GlobalKind::Imported,\n@@ -76,16 +87,34 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n         let context = Context::default();\n+\n+        context.add_command_line_option(\"-fexceptions\");\n+        context.add_driver_option(\"-fexceptions\");\n+\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n         context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n-        context.add_command_line_option(\"-msha\");\n-        context.add_command_line_option(\"-mpclmul\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        context.add_command_line_option(\"-mfma\");\n+        context.add_command_line_option(\"-mfma4\");\n+        context.add_command_line_option(\"-m64\");\n+        context.add_command_line_option(\"-mbmi\");\n+        context.add_command_line_option(\"-mgfni\");\n+        //context.add_command_line_option(\"-mavxvnni\"); // The CI doesn't support this option.\n+        context.add_command_line_option(\"-mf16c\");\n+        context.add_command_line_option(\"-maes\");\n+        context.add_command_line_option(\"-mxsavec\");\n+        context.add_command_line_option(\"-mbmi2\");\n+        context.add_command_line_option(\"-mrtm\");\n+        context.add_command_line_option(\"-mvaes\");\n+        context.add_command_line_option(\"-mvpclmulqdq\");\n+        context.add_command_line_option(\"-mavx\");\n+\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }\n@@ -95,12 +124,20 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n         // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292).\n         context.add_command_line_option(\"-fno-strict-aliasing\");\n+        // NOTE: Rust relies on LLVM doing wrapping on overflow.\n+        context.add_command_line_option(\"-fwrapv\");\n \n         if tcx.sess.opts.unstable_opts.function_sections.unwrap_or(tcx.sess.target.function_sections) {\n             context.add_command_line_option(\"-ffunction-sections\");\n             context.add_command_line_option(\"-fdata-sections\");\n         }\n \n+        if env::var(\"CG_GCCJIT_DUMP_RTL\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-fdump-rtl-vregs\");\n+        }\n+        if env::var(\"CG_GCCJIT_DUMP_TREE_ALL\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-fdump-tree-all\");\n+        }\n         if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n             context.set_dump_code_on_compile(true);\n         }\n@@ -115,7 +152,7 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n             context.set_keep_intermediates(true);\n         }\n \n-        // TODO(bjorn3): Remove once unwinding is properly implemented\n+        // NOTE: The codegen generates unrechable blocks.\n         context.set_allow_unreachable_blocks(true);\n \n         {"}, {"sha": "a3c8142bea2db08c0f669a9112e1878bc723d81b", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 332, "deletions": 81, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && (actual_ty.is_integral() && expected_ty.is_integral()) || (actual_ty.get_pointee().is_some() && expected_ty.get_pointee().is_some()) {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -226,6 +226,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                     else {\n                         assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n                         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+                        // TODO: remove bitcast now that vector types can be compared?\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -279,21 +280,30 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n+        let func_name = format!(\"{:?}\", func_ptr);\n+        let previous_arg_count = args.len();\n+        let orig_args = args;\n+        let args = {\n+            let function_address_names = self.function_address_names.borrow();\n+            let original_function_name = function_address_names.get(&func_ptr);\n+            llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name, original_function_name)\n+        };\n+        let args_adjusted = args.len() != previous_arg_count;\n+        let args = self.check_ptr_call(\"call\", func_ptr, &*args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            let func_name = format!(\"{:?}\", func_ptr);\n-            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n-            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let return_value = self.cx.context.new_call_through_ptr(None, func_ptr, &args);\n+            let return_value = llvm::adjust_intrinsic_return_value(&self, return_value, &func_name, &args, args_adjusted, orig_args);\n+            let result = current_func.new_local(None, return_value.get_type(), &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, return_value);\n             result.to_rvalue()\n         }\n         else {\n@@ -366,10 +376,10 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n+impl<'a, 'gcc, 'tcx> Deref for Builder<'a, 'gcc, 'tcx> {\n     type Target = CodegenCx<'gcc, 'tcx>;\n \n-    fn deref(&self) -> &Self::Target {\n+    fn deref<'b>(&'b self) -> &'a Self::Target {\n         self.cx\n     }\n }\n@@ -387,7 +397,7 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n+    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Builder<'a, 'gcc, 'tcx> {\n         Builder::with_cx(cx, block)\n     }\n \n@@ -444,17 +454,36 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(\n-        &mut self,\n-        typ: Type<'gcc>,\n-        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n-        func: RValue<'gcc>,\n-        args: &[RValue<'gcc>],\n-        then: Block<'gcc>,\n-        catch: Block<'gcc>,\n-        _funclet: Option<&Funclet>,\n-    ) -> RValue<'gcc> {\n-        // TODO(bjorn3): Properly implement unwinding.\n+    #[cfg(feature=\"master\")]\n+    fn invoke(&mut self, typ: Type<'gcc>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let try_block = self.current_func().new_block(\"try\");\n+\n+        let current_block = self.block.clone();\n+        self.block = try_block;\n+        let call = self.call(typ, None, func, args, None); // TODO(antoyo): use funclet here?\n+        self.block = current_block;\n+\n+        let return_value = self.current_func()\n+            .new_local(None, call.get_type(), \"invokeResult\");\n+\n+        try_block.add_assignment(None, return_value, call);\n+\n+        try_block.end_with_jump(None, then);\n+\n+        if self.cleanup_blocks.borrow().contains(&catch) {\n+            self.block.add_try_finally(None, try_block, catch);\n+        }\n+        else {\n+            self.block.add_try_catch(None, try_block, catch);\n+        }\n+\n+        self.block.end_with_jump(None, then);\n+\n+        return_value.to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n@@ -542,6 +571,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): add check in libgccjit since using the binary operator % causes the following error:\n+        // during RTL pass: expand\n+        // libgccjit.so: error: in expmed_mode_index, at expmed.h:240\n+        // 0x7f0101d58dc6 expmed_mode_index\n+        //     ../../../gcc/gcc/expmed.h:240\n+        // 0x7f0101d58e35 expmed_op_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:262\n+        // 0x7f0101d594a1 sdiv_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:531\n+        // 0x7f0101d594f3 sdiv_cost\n+        //     ../../../gcc/gcc/expmed.h:549\n+        // 0x7f0101d6af7e expand_divmod(int, tree_code, machine_mode, rtx_def*, rtx_def*, rtx_def*, int, optab_methods)\n+        //     ../../../gcc/gcc/expmed.cc:4356\n+        // 0x7f0101d94f9e expand_expr_divmod\n+        //     ../../../gcc/gcc/expr.cc:8929\n+        // 0x7f0101d97a26 expand_expr_real_2(separate_ops*, rtx_def*, machine_mode, expand_modifier)\n+        //     ../../../gcc/gcc/expr.cc:9566\n+        // 0x7f0101bef6ef expand_gimple_stmt_1\n+        //     ../../../gcc/gcc/cfgexpand.cc:3967\n+        // 0x7f0101bef910 expand_gimple_stmt\n+        //     ../../../gcc/gcc/cfgexpand.cc:4028\n+        // 0x7f0101bf6ee7 expand_gimple_basic_block\n+        //     ../../../gcc/gcc/cfgexpand.cc:6069\n+        // 0x7f0101bf9194 execute\n+        //     ../../../gcc/gcc/cfgexpand.cc:6795\n         if a.get_type().is_compatible_with(self.cx.float_type) {\n             let fmodf = self.context.get_builtin_function(\"fmodf\");\n             // FIXME(antoyo): this seems to produce the wrong result.\n@@ -616,24 +670,29 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         a * b\n     }\n \n-    fn fadd_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fadd_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs + rhs\n     }\n \n-    fn fsub_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fsub_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs - rhs\n     }\n \n-    fn fmul_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fmul_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs * rhs\n     }\n \n-    fn fdiv_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fdiv_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs / rhs\n     }\n \n-    fn frem_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn frem_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        self.frem(lhs, rhs)\n     }\n \n     fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n@@ -722,7 +781,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if place.layout.is_gcc_immediate() {\n                 let load = self.load(\n-                    place.layout.gcc_type(self, false),\n+                    place.layout.gcc_type(self),\n                     place.llval,\n                     place.align,\n                 );\n@@ -733,7 +792,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n                 let b_offset = a.size(self).align_to(b.align(self).abi);\n-                let pair_type = place.layout.gcc_type(self, false);\n+                let pair_type = place.layout.gcc_type(self);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n                     let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n@@ -833,26 +892,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n-        let mut result = ptr;\n+        let ptr_type = ptr.get_type();\n+        let mut pointee_type = ptr.get_type();\n+        // NOTE: we cannot use array indexing here like in inbounds_gep because array indexing is\n+        // always considered in bounds in GCC (TODO(antoyo): to be verified).\n+        // So, we have to cast to a number.\n+        let mut result = self.context.new_bitcast(None, ptr, self.sizet_type);\n+        // FIXME(antoyo): if there were more than 1 index, this code is probably wrong and would\n+        // require dereferencing the pointer.\n         for index in indices {\n-            result = self.context.new_array_access(None, result, *index).get_address(None).to_rvalue();\n+            pointee_type = pointee_type.get_pointee().expect(\"pointee type\");\n+            let pointee_size = self.context.new_rvalue_from_int(index.get_type(), pointee_type.get_size() as i32);\n+            result = result + self.gcc_int_cast(*index * pointee_size, self.sizet_type);\n         }\n-        result\n+        self.context.new_bitcast(None, result, ptr_type)\n     }\n \n     fn inbounds_gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n-        // FIXME(antoyo): would be safer if doing the same thing (loop) as gep.\n-        // TODO(antoyo): specify inbounds somehow.\n-        match indices.len() {\n-            1 => {\n-                self.context.new_array_access(None, ptr, indices[0]).get_address(None)\n-            },\n-            2 => {\n-                let array = ptr.dereference(None); // TODO(antoyo): assert that first index is 0?\n-                self.context.new_array_access(None, array, indices[1]).get_address(None)\n-            },\n-            _ => unimplemented!(),\n+        // NOTE: array indexing is always considered in bounds in GCC (TODO(antoyo): to be verified).\n+        let mut indices = indices.into_iter();\n+        let index = indices.next().expect(\"first index in inbounds_gep\");\n+        let mut result = self.context.new_array_access(None, ptr, *index);\n+        for index in indices {\n+            result = self.context.new_array_access(None, result, *index);\n         }\n+        result.get_address(None)\n     }\n \n     fn struct_gep(&mut self, value_type: Type<'gcc>, ptr: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n@@ -1034,8 +1098,19 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn extract_element(&mut self, _vec: RValue<'gcc>, _idx: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    #[cfg(feature=\"master\")]\n+    fn extract_element(&mut self, vec: RValue<'gcc>, idx: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_vector_access(None, vec, idx).to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    fn extract_element(&mut self, vec: RValue<'gcc>, idx: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = vec.get_type().unqualified().dyncast_vector().expect(\"Called extract_element on a non-vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let vec_num_units = vector_type.get_num_units();\n+        let array_type = self.context.new_array_type(None, element_type, vec_num_units as u64);\n+        let array = self.context.new_bitcast(None, vec, array_type).to_rvalue();\n+        self.context.new_array_access(None, array, idx).to_rvalue()\n     }\n \n     fn vector_splat(&mut self, _num_elts: usize, _elt: RValue<'gcc>) -> RValue<'gcc> {\n@@ -1116,22 +1191,52 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        // TODO(antoyo)\n+        #[cfg(feature=\"master\")]\n+        {\n+            let personality = self.rvalue_as_function(_personality);\n+            self.current_func().set_personality_function(personality);\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn cleanup_landing_pad(&mut self, pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        self.set_personality_fn(pers_fn);\n+\n+        // NOTE: insert the current block in a variable so that a later call to invoke knows to\n+        // generate a try/finally instead of a try/catch for this block.\n+        self.cleanup_blocks.borrow_mut().insert(self.block);\n+\n+        let eh_pointer_builtin = self.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = self.cx.context.new_rvalue_zero(self.int_type);\n+        let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+\n+        let value1_type = self.u8_type.make_pointer();\n+        let ptr = self.cx.context.new_cast(None, ptr, value1_type);\n+        let value1 = ptr;\n+        let value2 = zero; // TODO(antoyo): set the proper value here (the type of exception?).\n+\n+        (value1, value2)\n     }\n \n+    #[cfg(not(feature=\"master\"))]\n     fn cleanup_landing_pad(&mut self, _pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n-        (\n-            self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n-                .to_rvalue(),\n-            self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue(),\n-        )\n-        // TODO(antoyo): Properly implement unwinding.\n-        // the above is just to make the compilation work as it seems\n-        // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n+        let value1 = self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n+                .to_rvalue();\n+        let value2 = self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue();\n+        (value1, value2)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn resume(&mut self, exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n+        let exn_type = exn0.get_type();\n+        let exn = self.context.new_cast(None, exn0, exn_type);\n+        let unwind_resume = self.context.get_target_builtin_function(\"__builtin_unwind_resume\");\n+        self.llbb().add_eval(None, self.context.new_call(None, unwind_resume, &[exn]));\n+        self.unreachable();\n     }\n \n+    #[cfg(not(feature=\"master\"))]\n     fn resume(&mut self, _exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n-        // TODO(bjorn3): Properly implement unwinding.\n         self.unreachable();\n     }\n \n@@ -1160,6 +1265,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn atomic_cmpxchg(&mut self, dst: RValue<'gcc>, cmp: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n         let expected = self.current_func().new_local(None, cmp.get_type(), \"expected\");\n         self.llbb().add_assignment(None, expected, cmp);\n+        // NOTE: gcc doesn't support a failure memory model that is stronger than the success\n+        // memory model.\n+        let order =\n+            if failure_order as i32 > order as i32 {\n+                failure_order\n+            }\n+            else {\n+                order\n+            };\n         let success = self.compare_exchange(dst, expected, src, order, failure_order, weak);\n \n         let pair_type = self.cx.type_struct(&[src.get_type(), self.bool_type], false);\n@@ -1469,7 +1583,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n-        let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");\n+        let struct_type = mask.get_type().is_struct().expect(\"mask should be of struct type\");\n \n         // TODO(antoyo): use a recursive unqualified() here.\n         let vector_type = v1.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n@@ -1501,22 +1615,17 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             vector_elements.push(self.context.new_rvalue_zero(mask_element_type));\n         }\n \n-        let array_type = self.context.new_array_type(None, element_type, vec_num_units as i32);\n         let result_type = self.context.new_vector_type(element_type, mask_num_units as u64);\n         let (v1, v2) =\n             if vec_num_units < mask_num_units {\n                 // NOTE: the mask needs to be the same length as the input vectors, so join the 2\n                 // vectors and create a dummy second vector.\n-                // TODO(antoyo): switch to using new_vector_access.\n-                let array = self.context.new_bitcast(None, v1, array_type);\n                 let mut elements = vec![];\n                 for i in 0..vec_num_units {\n-                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                    elements.push(self.context.new_vector_access(None, v1, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n-                // TODO(antoyo): switch to using new_vector_access.\n-                let array = self.context.new_bitcast(None, v2, array_type);\n                 for i in 0..(mask_num_units - vec_num_units) {\n-                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                    elements.push(self.context.new_vector_access(None, v2, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n                 let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);\n                 let zero = self.context.new_rvalue_zero(element_type);\n@@ -1536,10 +1645,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             // NOTE: if padding was added, only select the number of elements of the masks to\n             // remove that padding in the result.\n             let mut elements = vec![];\n-            // TODO(antoyo): switch to using new_vector_access.\n-            let array = self.context.new_bitcast(None, result, array_type);\n             for i in 0..mask_num_units {\n-                elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                elements.push(self.context.new_vector_access(None, result, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n             }\n             self.context.new_rvalue_from_vector(None, result_type, &elements)\n         }\n@@ -1558,18 +1665,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let mask_element_type = self.type_ix(element_type.get_size() as u64 * 8);\n         let element_count = vector_type.get_num_units();\n         let mut vector_elements = vec![];\n         for i in 0..element_count {\n             vector_elements.push(i);\n         }\n-        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mask_type = self.context.new_vector_type(mask_element_type, element_count as u64);\n         let mut shift = 1;\n         let mut res = src;\n         while shift < element_count {\n             let vector_elements: Vec<_> =\n                 vector_elements.iter()\n-                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .map(|i| self.context.new_rvalue_from_int(mask_element_type, ((i + shift) % element_count) as i32))\n                     .collect();\n             let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n             let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n@@ -1581,7 +1690,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    pub fn vector_reduce<F>(&mut self, _src: RValue<'gcc>, _op: F) -> RValue<'gcc>\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         unimplemented!();\n@@ -1595,54 +1704,196 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fadd(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x + i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fadd(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmul(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x * i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmul(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!()\n+    }\n+\n     // Inspired by Hacker's Delight min implementation.\n     pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n         })\n     }\n \n     // Inspired by Hacker's Delight max implementation.\n     pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n         })\n     }\n \n+    fn vector_extremum(&mut self, a: RValue<'gcc>, b: RValue<'gcc>, direction: ExtremumOperation) -> RValue<'gcc> {\n+        let vector_type = a.get_type();\n+\n+        // mask out the NaNs in b and replace them with the corresponding lane in a, so when a and\n+        // b get compared & spliced together, we get the numeric values instead of NaNs.\n+        let b_nan_mask = self.context.new_comparison(None, ComparisonOp::NotEquals, b, b);\n+        let mask_type = b_nan_mask.get_type();\n+        let b_nan_mask_inverted = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, mask_type, b_nan_mask);\n+        let a_cast = self.context.new_bitcast(None, a, mask_type);\n+        let b_cast = self.context.new_bitcast(None, b, mask_type);\n+        let res = (b_nan_mask & a_cast) | (b_nan_mask_inverted & b_cast);\n+        let b = self.context.new_bitcast(None, res, vector_type);\n+\n+        // now do the actual comparison\n+        let comparison_op = match direction {\n+            ExtremumOperation::Min => ComparisonOp::LessThan,\n+            ExtremumOperation::Max => ComparisonOp::GreaterThan,\n+        };\n+        let cmp = self.context.new_comparison(None, comparison_op, a, b);\n+        let cmp_inverted = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, cmp.get_type(), cmp);\n+        let res = (cmp & a_cast) | (cmp_inverted & res);\n+        self.context.new_bitcast(None, res, vector_type)\n+    }\n+\n+    pub fn vector_fmin(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_extremum(a, b, ExtremumOperation::Min)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmin(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::LessThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmin(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_fmax(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_extremum(a, b, ExtremumOperation::Max)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmax(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::GreaterThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmax(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n         // cond is a vector of integers, not of bools.\n-        let cond_type = cond.get_type();\n-        let vector_type = cond_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let vector_type = cond.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n         let num_units = vector_type.get_num_units();\n         let element_type = vector_type.get_element_type();\n+\n+        #[cfg(feature=\"master\")]\n+        let (cond, element_type) = {\n+            let then_val_vector_type = then_val.get_type().dyncast_vector().expect(\"vector type\");\n+            let then_val_element_type = then_val_vector_type.get_element_type();\n+            let then_val_element_size = then_val_element_type.get_size();\n+\n+            // NOTE: the mask needs to be of the same size as the other arguments in order for the &\n+            // operation to work.\n+            if then_val_element_size != element_type.get_size() {\n+                let new_element_type = self.type_ix(then_val_element_size as u64 * 8);\n+                let new_vector_type = self.context.new_vector_type(new_element_type, num_units as u64);\n+                let cond = self.context.convert_vector(None, cond, new_vector_type);\n+                (cond, new_element_type)\n+            }\n+            else {\n+                (cond, element_type)\n+            }\n+        };\n+\n+        let cond_type = cond.get_type();\n+\n         let zeros = vec![self.context.new_rvalue_zero(element_type); num_units];\n         let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n \n+        let result_type = then_val.get_type();\n+\n         let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+        // the & operation work.\n+        let then_val = self.bitcast_if_needed(then_val, masks.get_type());\n         let then_vals = masks & then_val;\n \n-        let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n-        let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n-        let inverted_masks = masks + ones;\n+        let minus_ones = vec![self.context.new_rvalue_from_int(element_type, -1); num_units];\n+        let minus_ones = self.context.new_rvalue_from_vector(None, cond_type, &minus_ones);\n+        let inverted_masks = masks ^ minus_ones;\n         // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n         // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n         // operation to work.\n+        // TODO: remove bitcast now that vector types can be compared?\n         let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n         let else_vals = inverted_masks & else_val;\n \n-        then_vals | else_vals\n+        let res = then_vals | else_vals;\n+        self.bitcast_if_needed(res, result_type)\n     }\n }\n \n fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n     let difference = a - b;\n     let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+    // the & operation work.\n+    let a_type = a.get_type();\n+    let masks =\n+        if masks.get_type() != a_type {\n+            context.new_bitcast(None, masks, a_type)\n+        }\n+        else {\n+            masks\n+        };\n     difference & masks\n }\n "}, {"sha": "ba1e86562089e756e167d2cbf14990a7560c596f", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 105, "deletions": 8, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,9 +1,10 @@\n-use gccjit::{FunctionType, RValue};\n-use rustc_codegen_ssa::traits::BaseTypeMethods;\n+#[cfg(feature=\"master\")]\n+use gccjit::{FnAttribute, Visibility};\n+use gccjit::{FunctionType, Function};\n use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n-use crate::abi::FnAbiGccExt;\n+use crate::attributes;\n use crate::context::CodegenCx;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -13,22 +14,26 @@ use crate::context::CodegenCx;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> RValue<'gcc> {\n+pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n+    let sym = tcx.symbol_name(instance).name;\n+\n     if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n         return func;\n     }\n \n-    let sym = tcx.symbol_name(instance).name;\n-\n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n-        if let Some(func) = cx.get_declared_value(&sym) {\n+        if let Some(_func) = cx.get_declared_value(&sym) {\n+            // FIXME(antoyo): we never reach this because get_declared_value only returns global variables\n+            // and here we try to get a function.\n+            unreachable!();\n+            /*\n             // Create a fn pointer with the new signature.\n             let ptrty = fn_abi.ptr_to_gcc_type(cx);\n \n@@ -61,13 +66,105 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             }\n             else {\n                 func\n-            }\n+            }*/\n         }\n         else {\n             cx.linkage.set(FunctionType::Extern);\n             let func = cx.declare_fn(&sym, &fn_abi);\n \n+            attributes::from_fn_attrs(cx, func, instance);\n+\n+            let instance_def_id = instance.def_id();\n+\n             // TODO(antoyo): set linkage and attributes.\n+\n+            // Apply an appropriate linkage/visibility value to our item that we\n+            // just declared.\n+            //\n+            // This is sort of subtle. Inside our codegen unit we started off\n+            // compilation by predefining all our own `MonoItem` instances. That\n+            // is, everything we're codegenning ourselves is already defined. That\n+            // means that anything we're actually codegenning in this codegen unit\n+            // will have hit the above branch in `get_declared_value`. As a result,\n+            // we're guaranteed here that we're declaring a symbol that won't get\n+            // defined, or in other words we're referencing a value from another\n+            // codegen unit or even another crate.\n+            //\n+            // So because this is a foreign value we blanket apply an external\n+            // linkage directive because it's coming from a different object file.\n+            // The visibility here is where it gets tricky. This symbol could be\n+            // referencing some foreign crate or foreign library (an `extern`\n+            // block) in which case we want to leave the default visibility. We may\n+            // also, though, have multiple codegen units. It could be a\n+            // monomorphization, in which case its expected visibility depends on\n+            // whether we are sharing generics or not. The important thing here is\n+            // that the visibility we apply to the declaration is the same one that\n+            // has been applied to the definition (wherever that definition may be).\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+            if is_generic {\n+                // This is a monomorphization. Its expected visibility depends\n+                // on whether we are in share-generics mode.\n+\n+                if cx.tcx.sess.opts.share_generics() {\n+                    // We are in share_generics mode.\n+\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n+                        // This is a definition from the current crate. If the\n+                        // definition is unreachable for downstream crates or\n+                        // the current crate does not re-export generics, the\n+                        // definition of the instance will have been declared\n+                        // as `hidden`.\n+                        if cx.tcx.is_unreachable_local_definition(instance_def_id)\n+                            || !cx.tcx.local_crate_exports_generics()\n+                        {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a monomorphization of a generic function\n+                        // defined in an upstream crate.\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n+                            // This is instantiated in another crate. It cannot\n+                            // be `hidden`.\n+                        } else {\n+                            // This is a local instantiation of an upstream definition.\n+                            // If the current crate does not re-export it\n+                            // (because it is a C library or an executable), it\n+                            // will have been declared `hidden`.\n+                            if !cx.tcx.local_crate_exports_generics() {\n+                                #[cfg(feature=\"master\")]\n+                                func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // When not sharing generics, all instances are in the same\n+                    // crate and have hidden visibility\n+                    #[cfg(feature=\"master\")]\n+                    func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                }\n+            } else {\n+                // This is a non-generic function\n+                if cx.tcx.is_codegened_item(instance_def_id) {\n+                    // This is a function that is instantiated in the local crate\n+\n+                    if instance_def_id.is_local() {\n+                        // This is function that is defined in the local crate.\n+                        // If it is not reachable, it is hidden.\n+                        if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a function from an upstream crate that has\n+                        // been instantiated here. These are always hidden.\n+                        #[cfg(feature=\"master\")]\n+                        func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                    }\n+                }\n+            }\n+\n             func\n         };\n "}, {"sha": "ac04b61a30672cf152dfb5736830899b2e5a6c11", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -36,7 +36,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n     let context = &cx.context;\n     let byte_type = context.new_type::<u8>();\n-    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as u64);\n     let elements: Vec<_> =\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n@@ -73,6 +73,11 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         }\n     }\n \n+    fn const_poison(&self, typ: Type<'gcc>) -> RValue<'gcc> {\n+        // No distinction between undef and poison.\n+        self.const_undef(typ)\n+    }\n+\n     fn const_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n         self.gcc_int(typ, int)\n     }\n@@ -115,8 +120,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.const_uint(self.usize_type, i)\n     }\n \n-    fn const_u8(&self, _i: u8) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_u8(&self, i: u8) -> RValue<'gcc> {\n+        self.const_uint(self.type_u8(), i as u64)\n     }\n \n     fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n@@ -133,7 +138,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             .1;\n         let len = s.len();\n         let cs = self.const_ptrcast(str_global.get_address(None),\n-            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self)),\n         );\n         (cs, self.const_usize(len as u64))\n     }\n@@ -174,8 +179,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                // TODO(bjorn3): assert size is correct\n-                self.const_bitcast(value, ty)\n+                let bytesize = layout.size(self).bytes();\n+                if bitsize > 1 && ty.is_integral() && bytesize as u32 == ty.get_size() {\n+                    // NOTE: since the intrinsic _xabort is called with a bitcast, which\n+                    // is non-const, but expects a constant, do a normal cast instead of a bitcast.\n+                    // FIXME(antoyo): fix bitcast to work in constant contexts.\n+                    // TODO(antoyo): perhaps only use bitcast for pointers?\n+                    self.context.new_cast(None, value, ty)\n+                }\n+                else {\n+                    // TODO(bjorn3): assert size is correct\n+                    self.const_bitcast(value, ty)\n+                }\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n@@ -227,11 +242,11 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n         assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self, true));\n+        let ty = self.type_ptr_to(layout.gcc_type(self));\n         let value =\n             if layout.size == Size::ZERO {\n                 let value = self.const_usize(alloc.inner().align.bytes());\n-                self.context.new_cast(None, value, ty)\n+                self.const_bitcast(value, ty)\n             }\n             else {\n                 let init = const_alloc_to_gcc(self, alloc);"}, {"sha": "792ab8f890d8feab0f2c7cabdf30d293c1551c17", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 86, "deletions": 85, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,8 +1,8 @@\n-use gccjit::{GlobalKind, LValue, RValue, ToRValue, Type};\n+#[cfg(feature = \"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n-use rustc_hir as hir;\n-use rustc_hir::Node;\n-use rustc_middle::{bug, span_bug};\n+use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -13,6 +13,7 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMinimumAlignment;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -30,6 +31,21 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n+fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>, mut align: Align) {\n+    // The target may require greater alignment for globals than the type does.\n+    // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n+    // which can force it to be smaller. Rust doesn't support this yet.\n+    if let Some(min) = cx.sess().target.min_global_align {\n+        match Align::from_bits(min) {\n+            Ok(min) => align = align.max(min),\n+            Err(err) => {\n+                cx.sess().emit_err(InvalidMinimumAlignment { err });\n+            }\n+        }\n+    }\n+    gv.set_alignment(align.bytes() as i32);\n+}\n+\n impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         // TODO(antoyo): implement a proper rvalue comparison in libgccjit instead of doing the\n@@ -79,9 +95,9 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n-        // TODO(antoyo): set alignment.\n+        set_global_alignment(self, global, self.align_of(ty));\n \n         let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n@@ -158,12 +174,19 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn add_compiler_used_global(&self, _global: RValue<'gcc>) {\n-        // TODO(antoyo)\n+    fn add_compiler_used_global(&self, global: RValue<'gcc>) {\n+        // NOTE: seems like GCC does not make the distinction between compiler.used and used.\n+        self.add_used_global(global);\n     }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    pub fn add_used_function(&self, function: Function<'gcc>) {\n+        #[cfg(feature = \"master\")]\n+        function.add_attribute(FnAttribute::Used);\n+    }\n+\n     pub fn static_addr_of_mut(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         let global =\n             match kind {\n@@ -208,82 +231,59 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let sym = self.tcx.symbol_name(instance).name;\n \n         let global =\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self, true);\n-                // FIXME: refactor this to work without accessing the HIR\n-                let global = match self.tcx.hir().get(id) {\n-                    Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n-                        if let Some(global) = self.get_declared_value(&sym) {\n-                            if self.val_ty(global) != self.type_ptr_to(llty) {\n-                                span_bug!(span, \"Conflicting types for static\");\n-                            }\n-                        }\n-\n-                        let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-                        let global = self.declare_global(\n-                            &sym,\n-                            llty,\n-                            GlobalKind::Exported,\n-                            is_tls,\n-                            fn_attrs.link_section,\n-                        );\n-\n-                        if !self.tcx.is_reachable_non_generic(def_id) {\n-                            // TODO(antoyo): set visibility.\n-                        }\n-\n-                        global\n-                    }\n-\n-                    Node::ForeignItem(&hir::ForeignItem {\n-                        span: _,\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    }) => {\n-                        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n-                    }\n-\n-                    item => bug!(\"get_static: expected static, found {:?}\", item),\n-                };\n+            if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+            let llty = self.layout_of(ty).gcc_type(self);\n+            if let Some(global) = self.get_declared_value(sym) {\n+                if self.val_ty(global) != self.type_ptr_to(llty) {\n+                    span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n+                }\n+            }\n \n-                global\n+            let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+            let global = self.declare_global(\n+                &sym,\n+                llty,\n+                GlobalKind::Exported,\n+                is_tls,\n+                fn_attrs.link_section,\n+            );\n+\n+            if !self.tcx.is_reachable_non_generic(def_id) {\n+                // TODO(antoyo): set visibility.\n             }\n-            else {\n-                // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-                //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n-\n-                let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                let global = check_and_apply_linkage(&self, &attrs, ty, sym);\n-\n-                let needs_dll_storage_attr = false; // TODO(antoyo)\n-\n-                // If this assertion triggers, there's something wrong with commandline\n-                // argument validation.\n-                debug_assert!(\n-                    !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                        && self.tcx.sess.target.options.is_like_msvc\n-                        && self.tcx.sess.opts.cg.prefer_dynamic)\n-                );\n-\n-                if needs_dll_storage_attr {\n-                    // This item is external but not foreign, i.e., it originates from an external Rust\n-                    // crate. Since we don't know whether this crate will be linked dynamically or\n-                    // statically in the final application, we always mark such symbols as 'dllimport'.\n-                    // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n-                    // to make things work.\n-                    //\n-                    // However, in some scenarios we defer emission of statics to downstream\n-                    // crates, so there are cases where a static with an upstream DefId\n-                    // is actually present in the current crate. We can find out via the\n-                    // is_codegened_item query.\n-                    if !self.tcx.is_codegened_item(def_id) {\n-                        unimplemented!();\n-                    }\n+\n+            global\n+        } else {\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n+        };\n+\n+        if !def_id.is_local() {\n+            let needs_dll_storage_attr = false; // TODO(antoyo)\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.options.is_like_msvc\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unimplemented!();\n                 }\n-                global\n-            };\n+            }\n+        }\n \n         // TODO(antoyo): set dll storage class.\n \n@@ -357,7 +357,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n \n fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-    let llty = cx.layout_of(ty).gcc_type(cx, true);\n+    let gcc_type = cx.layout_of(ty).gcc_type(cx);\n     if let Some(linkage) = attrs.import_linkage {\n         // Declare a symbol `foo` with the desired linkage.\n         let global1 = cx.declare_global_with_linkage(&sym, cx.type_i8(), base::global_linkage_to_gcc(linkage));\n@@ -370,9 +370,10 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // zero.\n         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n         real_name.push_str(&sym);\n-        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n+        let global2 = cx.define_global(&real_name, gcc_type, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_rvalue(global1.get_address(None));\n+        let value = cx.const_ptrcast(global1.get_address(None), gcc_type);\n+        global2.global_set_initializer_rvalue(value);\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }\n@@ -386,6 +387,6 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        cx.declare_global(&sym, llty, GlobalKind::Imported, is_tls, attrs.link_section)\n+        cx.declare_global(&sym, gcc_type, GlobalKind::Imported, is_tls, attrs.link_section)\n     }\n }"}, {"sha": "661681bdb50f2f1094b0f18736ad43846110cc64", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,17 +1,18 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n+    BaseTypeMethods,\n     MiscMethods,\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOf, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n@@ -33,6 +34,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     // TODO(bjorn3): Can this field be removed?\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n+    pub function_address_names: RefCell<FxHashMap<RValue<'gcc>, String>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n     pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n@@ -78,12 +80,10 @@ pub struct CodegenCx<'gcc, 'tcx> {\n \n     pub struct_types: RefCell<FxHashMap<Vec<Type<'gcc>>, Type<'gcc>>>,\n \n-    pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n-\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n-    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, Function<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n@@ -110,6 +110,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n \n     eh_personality: Cell<Option<RValue<'gcc>>>,\n+    pub rust_try_fn: Cell<Option<(Type<'gcc>, Function<'gcc>)>>,\n \n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n \n@@ -119,6 +120,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// they can be dereferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n+\n+    pub cleanup_blocks: RefCell<FxHashSet<Block<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -194,6 +197,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             context,\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n+            function_address_names: Default::default(),\n             functions: RefCell::new(functions),\n             intrinsics: RefCell::new(FxHashMap::default()),\n \n@@ -243,11 +247,12 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             types: Default::default(),\n             tcx,\n             struct_types: Default::default(),\n-            types_with_fields_to_set: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n+            cleanup_blocks: Default::default(),\n         }\n     }\n \n@@ -327,8 +332,9 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn get_fn(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n         let func = get_fn(self, instance);\n-        *self.current_func.borrow_mut() = Some(self.rvalue_as_function(func));\n-        func\n+        *self.current_func.borrow_mut() = Some(func);\n+        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+        unsafe { std::mem::transmute(func) }\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n@@ -339,15 +345,15 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 self.intrinsics.borrow()[func_name].clone()\n             }\n             else {\n-                let func = get_fn(self, instance);\n-                self.rvalue_as_function(func)\n+                get_fn(self, instance)\n             };\n         let ptr = func.get_address(None);\n \n         // TODO(antoyo): don't do this twice: i.e. in declare_fn and here.\n         // FIXME(antoyo): the rustc API seems to call get_fn_addr() when not needed (e.g. for FFI).\n \n         self.normal_function_addresses.borrow_mut().insert(ptr);\n+        self.function_address_names.borrow_mut().insert(ptr, func_name.to_string());\n \n         ptr\n     }\n@@ -377,31 +383,40 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             return llpersonality;\n         }\n         let tcx = self.tcx;\n-        let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    tcx.intern_substs(&[]),\n-                )\n-                .unwrap().unwrap(),\n-            ),\n-            _ => {\n-                let _name = if wants_msvc_seh(self.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                //let func = self.declare_func(name, self.type_i32(), &[], true);\n-                // FIXME(antoyo): this hack should not be needed. That will probably be removed when\n-                // unwinding support is added.\n-                self.context.new_rvalue_from_int(self.int_type, 0)\n-            }\n-        };\n+        let func =\n+            match tcx.lang_items().eh_personality() {\n+                Some(def_id) if !wants_msvc_seh(self.sess()) => {\n+                    let instance =\n+                        ty::Instance::resolve(\n+                            tcx,\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            ty::List::empty(),\n+                        )\n+                        .unwrap().unwrap();\n+\n+                    let symbol_name = tcx.symbol_name(instance).name;\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n+                    self.linkage.set(FunctionType::Extern);\n+                    let func = self.declare_fn(symbol_name, &fn_abi);\n+                    let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n+                    func\n+                },\n+                _ => {\n+                    let name =\n+                        if wants_msvc_seh(self.sess()) {\n+                            \"__CxxFrameHandler3\"\n+                        }\n+                        else {\n+                            \"rust_eh_personality\"\n+                        };\n+                    let func = self.declare_func(name, self.type_i32(), &[], true);\n+                    unsafe { std::mem::transmute(func) }\n+                }\n+            };\n         // TODO(antoyo): apply target cpu attributes.\n-        self.eh_personality.set(Some(llfn));\n-        llfn\n+        self.eh_personality.set(Some(func));\n+        func\n     }\n \n     fn sess(&self) -> &Session {"}, {"sha": "4748e7e4be2a3afe401ed49886cc7ae9a862c6b3", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -38,12 +38,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    /*pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> RValue<'gcc> {\n-        self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n-    }*/\n+    pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+        self.linkage.set(FunctionType::Extern);\n+        declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic)\n+    }\n \n     pub fn declare_global(&self, name: &str, ty: Type<'gcc>, global_kind: GlobalKind, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, global_kind, ty, name);\n@@ -79,12 +77,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n+        func\n     }\n \n     pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {"}, {"sha": "9305bd1e043d564010bd360c27b92ef4b266e82a", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -221,3 +221,18 @@ pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_minimum_alignment)]\n+pub(crate) struct InvalidMinimumAlignment {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_tied_target_features)]\n+#[help]\n+pub(crate) struct TiedTargetFeatures {\n+    #[primary_span]\n+    pub span: Span,\n+    pub features: String,\n+}"}, {"sha": "0cf1204791d336c75afe591660e994e7e94fb36a", "filename": "compiler/rustc_codegen_gcc/src/int.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -389,18 +389,22 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 };\n             self.context.new_comparison(None, op, cmp, self.context.new_rvalue_from_int(self.int_type, limit))\n         }\n+        else if a_type.get_pointee().is_some() && b_type.get_pointee().is_some() {\n+            // NOTE: gcc cannot compare pointers to different objects, but rustc does that, so cast them to usize.\n+            lhs = self.context.new_bitcast(None, lhs, self.usize_type);\n+            rhs = self.context.new_bitcast(None, rhs, self.usize_type);\n+            self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+        }\n         else {\n-            let left_type = lhs.get_type();\n-            let right_type = rhs.get_type();\n-            if left_type != right_type {\n+            if a_type != b_type {\n                 // NOTE: because libgccjit cannot compare function pointers.\n-                if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n+                if a_type.dyncast_function_ptr_type().is_some() && b_type.dyncast_function_ptr_type().is_some() {\n                     lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n                     rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n                 }\n                 // NOTE: hack because we try to cast a vector type to the same vector type.\n-                else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n-                    rhs = self.context.new_cast(None, rhs, left_type);\n+                else if format!(\"{:?}\", a_type) != format!(\"{:?}\", b_type) {\n+                    rhs = self.context.new_cast(None, rhs, a_type);\n                 }\n             }\n             self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)"}, {"sha": "8a4559355ea6716877df1b2de076d43e51a6cf38", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/archs.rs", "status": "modified", "additions": 2379, "deletions": 64, "changes": 2443, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "0edec566be309987bac044515be59f69d4ab8c86", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/llvm.rs", "status": "modified", "additions": 663, "deletions": 134, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,159 +1,387 @@\n use std::borrow::Cow;\n \n-use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue, UnaryOp};\n+use rustc_codegen_ssa::traits::BuilderMethods;\n \n use crate::{context::CodegenCx, builder::Builder};\n \n-pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str, original_function_name: Option<&String>) -> Cow<'b, [RValue<'gcc>]> {\n     // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n     // arguments here.\n     if gcc_func.get_param_count() != args.len() {\n         match &*func_name {\n-            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n-                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+            // NOTE: the following intrinsics have a different number of parameters in LLVM and GCC.\n+            \"__builtin_ia32_prold512_mask\" | \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n                 | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n-                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n-                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\"\n                 | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n-                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n-                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\"\n+                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\" | \"__builtin_ia32_pslldi512_mask\"\n+                | \"__builtin_ia32_psrldi512_mask\" | \"__builtin_ia32_psllqi512_mask\" | \"__builtin_ia32_psrlqi512_mask\"\n+                | \"__builtin_ia32_pslld512_mask\" | \"__builtin_ia32_psrld512_mask\" | \"__builtin_ia32_psllq512_mask\"\n+                | \"__builtin_ia32_psrlq512_mask\" | \"__builtin_ia32_psrad512_mask\" | \"__builtin_ia32_psraq512_mask\"\n+                | \"__builtin_ia32_psradi512_mask\" | \"__builtin_ia32_psraqi512_mask\" | \"__builtin_ia32_psrav16si_mask\"\n+                | \"__builtin_ia32_psrav8di_mask\" | \"__builtin_ia32_prolvd512_mask\" | \"__builtin_ia32_prorvd512_mask\"\n+                | \"__builtin_ia32_prolvq512_mask\" | \"__builtin_ia32_prorvq512_mask\" | \"__builtin_ia32_psllv16si_mask\"\n+                | \"__builtin_ia32_psrlv16si_mask\" | \"__builtin_ia32_psllv8di_mask\" | \"__builtin_ia32_psrlv8di_mask\"\n+                | \"__builtin_ia32_permvarsi512_mask\" | \"__builtin_ia32_vpermilvarps512_mask\"\n+                | \"__builtin_ia32_vpermilvarpd512_mask\" | \"__builtin_ia32_permvardi512_mask\"\n+                | \"__builtin_ia32_permvarsf512_mask\" | \"__builtin_ia32_permvarqi512_mask\"\n+                | \"__builtin_ia32_permvarqi256_mask\" | \"__builtin_ia32_permvarqi128_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb512_mask\" | \"__builtin_ia32_vpmultishiftqb256_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb128_mask\"\n                 => {\n-                    // TODO: refactor by separating those intrinsics outside of this branch.\n-                    let add_before_last_arg =\n-                        match &*func_name {\n-                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n-                            _ => false,\n-                        };\n-                    let new_first_arg_is_zero =\n-                        match &*func_name {\n-                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n-                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n-                            _ => false\n-                        };\n-                    let arg3_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n-                            _ => 2,\n-                        };\n-                    let mut new_args = args.to_vec();\n-                    let arg3_type = gcc_func.get_param_type(arg3_index);\n-                    let first_arg =\n-                        if new_first_arg_is_zero {\n-                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n-                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n-                            let num_units = vector_type.get_num_units();\n-                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n-                        }\n-                        else {\n-                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n-                        };\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, first_arg);\n-                    }\n-                    else {\n-                        new_args.push(first_arg);\n-                    }\n-                    let arg4_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n-                            _ => 3,\n-                        };\n-                    let arg4_type = gcc_func.get_param_type(arg4_index);\n-                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, minus_one);\n-                    }\n-                    else {\n-                        new_args.push(minus_one);\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let first_arg = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_prold256_mask\" | \"__builtin_ia32_prold128_mask\"\n+                | \"__builtin_ia32_prord512_mask\" | \"__builtin_ia32_prord256_mask\" | \"__builtin_ia32_prord128_mask\"\n+                | \"__builtin_ia32_prolq256_mask\" | \"__builtin_ia32_prolq128_mask\" | \"__builtin_ia32_prorq256_mask\"\n+                | \"__builtin_ia32_prorq128_mask\" | \"__builtin_ia32_psraq256_mask\" | \"__builtin_ia32_psraq128_mask\"\n+                | \"__builtin_ia32_psraqi256_mask\" | \"__builtin_ia32_psraqi128_mask\" | \"__builtin_ia32_psravq256_mask\"\n+                | \"__builtin_ia32_psravq128_mask\" | \"__builtin_ia32_prolvd256_mask\" | \"__builtin_ia32_prolvd128_mask\"\n+                | \"__builtin_ia32_prorvd256_mask\" | \"__builtin_ia32_prorvd128_mask\" | \"__builtin_ia32_prolvq256_mask\"\n+                | \"__builtin_ia32_prolvq128_mask\" | \"__builtin_ia32_prorvq256_mask\" | \"__builtin_ia32_prorvq128_mask\"\n+                | \"__builtin_ia32_permvardi256_mask\" | \"__builtin_ia32_permvardf512_mask\" | \"__builtin_ia32_permvardf256_mask\"\n+                | \"__builtin_ia32_pmulhuw512_mask\" | \"__builtin_ia32_pmulhw512_mask\" | \"__builtin_ia32_pmulhrsw512_mask\"\n+                | \"__builtin_ia32_pmaxuw512_mask\" | \"__builtin_ia32_pmaxub512_mask\" | \"__builtin_ia32_pmaxsw512_mask\"\n+                | \"__builtin_ia32_pmaxsb512_mask\" | \"__builtin_ia32_pminuw512_mask\" | \"__builtin_ia32_pminub512_mask\"\n+                | \"__builtin_ia32_pminsw512_mask\" | \"__builtin_ia32_pminsb512_mask\"\n+                | \"__builtin_ia32_pmaddwd512_mask\" | \"__builtin_ia32_pmaddubsw512_mask\" | \"__builtin_ia32_packssdw512_mask\"\n+                | \"__builtin_ia32_packsswb512_mask\" | \"__builtin_ia32_packusdw512_mask\" | \"__builtin_ia32_packuswb512_mask\"\n+                | \"__builtin_ia32_pavgw512_mask\" | \"__builtin_ia32_pavgb512_mask\" | \"__builtin_ia32_psllw512_mask\"\n+                | \"__builtin_ia32_psllwi512_mask\" | \"__builtin_ia32_psllv32hi_mask\" | \"__builtin_ia32_psrlw512_mask\"\n+                | \"__builtin_ia32_psrlwi512_mask\" | \"__builtin_ia32_psllv16hi_mask\" | \"__builtin_ia32_psllv8hi_mask\"\n+                | \"__builtin_ia32_psrlv32hi_mask\" | \"__builtin_ia32_psraw512_mask\" | \"__builtin_ia32_psrawi512_mask\"\n+                | \"__builtin_ia32_psrlv16hi_mask\" | \"__builtin_ia32_psrlv8hi_mask\" | \"__builtin_ia32_psrav32hi_mask\"\n+                | \"__builtin_ia32_permvarhi512_mask\" | \"__builtin_ia32_pshufb512_mask\" | \"__builtin_ia32_psrav16hi_mask\"\n+                | \"__builtin_ia32_psrav8hi_mask\" | \"__builtin_ia32_permvarhi256_mask\" | \"__builtin_ia32_permvarhi128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_dbpsadbw512_mask\" | \"__builtin_ia32_dbpsadbw256_mask\" | \"__builtin_ia32_dbpsadbw128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let vector_type = arg4_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg4_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+                | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                // Remove last arg as it doesn't seem to be used in GCC and is always false.\n+                new_args.pop();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpconflictsi_512_mask\" | \"__builtin_ia32_vpconflictsi_256_mask\"\n+                | \"__builtin_ia32_vpconflictsi_128_mask\" | \"__builtin_ia32_vpconflictdi_512_mask\"\n+                | \"__builtin_ia32_vpconflictdi_256_mask\" | \"__builtin_ia32_vpconflictdi_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+\n+                let mut last_arg = None;\n+                if args.len() == 4 {\n+                    last_arg = new_args.pop();\n+                }\n+\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+\n+                if args.len() == 3 {\n+                    // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                    // the same GCC intrinsic, but the former has 3 parameters and the\n+                    // latter has 4 so it doesn't require this additional argument.\n+                    let arg5_type = gcc_func.get_param_type(4);\n+                    new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                }\n+\n+                if let Some(last_arg) = last_arg {\n+                    new_args.push(last_arg);\n+                }\n+\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+                | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                |  \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermi2vard512_mask\" | \"__builtin_ia32_vpermi2vard256_mask\"\n+                | \"__builtin_ia32_vpermi2vard128_mask\" | \"__builtin_ia32_vpermi2varq512_mask\"\n+                | \"__builtin_ia32_vpermi2varq256_mask\" | \"__builtin_ia32_vpermi2varq128_mask\"\n+                | \"__builtin_ia32_vpermi2varps512_mask\" | \"__builtin_ia32_vpermi2varps256_mask\"\n+                | \"__builtin_ia32_vpermi2varps128_mask\" | \"__builtin_ia32_vpermi2varpd512_mask\"\n+                | \"__builtin_ia32_vpermi2varpd256_mask\" | \"__builtin_ia32_vpermi2varpd128_mask\" | \"__builtin_ia32_vpmadd52huq512_mask\"\n+                | \"__builtin_ia32_vpmadd52luq512_mask\" | \"__builtin_ia32_vpmadd52huq256_mask\" | \"__builtin_ia32_vpmadd52luq256_mask\"\n+                | \"__builtin_ia32_vpmadd52huq128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\"\n+                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let undefined = builder.current_func().new_local(None, arg2_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_stmxcsr\" => {\n+                args = vec![].into();\n+            },\n+            \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let variable = builder.current_func().new_local(None, arg2_type, \"addcarryResult\");\n+                new_args.push(variable.get_address(None));\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermt2varqi512_mask\" | \"__builtin_ia32_vpermt2varqi256_mask\"\n+                | \"__builtin_ia32_vpermt2varqi128_mask\" | \"__builtin_ia32_vpermt2varhi512_mask\"\n+                | \"__builtin_ia32_vpermt2varhi256_mask\" | \"__builtin_ia32_vpermt2varhi128_mask\"\n+                => {\n+                let new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                args = vec![new_args[1], new_args[0], new_args[2], minus_one].into();\n+            },\n+            \"__builtin_ia32_xrstor\" | \"__builtin_ia32_xsavec\" => {\n+                let new_args = args.to_vec();\n+                let thirty_two = builder.context.new_rvalue_from_int(new_args[1].get_type(), 32);\n+                let arg2 = new_args[1] << thirty_two | new_args[2];\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg2 = builder.context.new_cast(None, arg2, arg2_type);\n+                args = vec![new_args[0], arg2].into();\n+            },\n+            \"__builtin_prefetch\" => {\n+                let mut new_args = args.to_vec();\n+                new_args.pop();\n+                args = new_args.into();\n+            },\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match &*func_name {\n+            \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+                let new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let arg3 = builder.context.new_cast(None, new_args[4], arg3_type);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let arg4 = builder.context.new_bitcast(None, new_args[2], arg4_type);\n+                args = vec![new_args[0], new_args[1], arg3, arg4, new_args[3], new_args[5]].into();\n+            },\n+            // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+            // FIXME: the intrinsics like _mm_mask_fmadd_sd should probably directly call the GCC\n+            // instrinsic to avoid this.\n+            \"__builtin_ia32_vfmaddss3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 4]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 4]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 4]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsd3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 2]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 2]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\"\n+                | \"__builtin_ia32_vfmaddsubpd\" => {\n+                if let Some(original_function_name) = original_function_name {\n+                    match &**original_function_name {\n+                        \"llvm.x86.fma.vfmsubadd.pd.256\" | \"llvm.x86.fma.vfmsubadd.ps\" | \"llvm.x86.fma.vfmsubadd.ps.256\"\n+                            | \"llvm.x86.fma.vfmsubadd.pd\" => {\n+                            // NOTE: since both llvm.x86.fma.vfmsubadd.ps and llvm.x86.fma.vfmaddsub.ps maps to\n+                            // __builtin_ia32_vfmaddsubps, only add minus if this comes from a\n+                            // subadd LLVM intrinsic, e.g. _mm256_fmsubadd_pd.\n+                            let mut new_args = args.to_vec();\n+                            let arg3 = &mut new_args[2];\n+                            *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n+                            args = new_args.into();\n+                        },\n+                        _ => (),\n                     }\n-                    args = new_args.into();\n-                },\n-                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n-                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n-                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n-                        new_args.push(minus_one);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-\n-                        let mut last_arg = None;\n-                        if args.len() == 4 {\n-                            last_arg = new_args.pop();\n-                        }\n-\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-\n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg5_type = gcc_func.get_param_type(4);\n-                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n-                        }\n-\n-                        if let Some(last_arg) = last_arg {\n-                            new_args.push(last_arg);\n-                        }\n-\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n-                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n-                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n-                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg3_type = gcc_func.get_param_type(2);\n-                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n-                        new_args.push(undefined);\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    _ => (),\n+                }\n+            },\n+            \"__builtin_ia32_ldmxcsr\" => {\n+                // The builtin __builtin_ia32_ldmxcsr takes an integer value while llvm.x86.sse.ldmxcsr takes a pointer,\n+                // so dereference the pointer.\n+                let mut new_args = args.to_vec();\n+                let uint_ptr_type = builder.uint_type.make_pointer();\n+                let arg1 = builder.context.new_cast(None, args[0], uint_ptr_type);\n+                new_args[0] = arg1.dereference(None).to_rvalue();\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_rcp14sd_mask\" | \"__builtin_ia32_rcp14ss_mask\" | \"__builtin_ia32_rsqrt14sd_mask\"\n+                | \"__builtin_ia32_rsqrt14ss_mask\" => {\n+                let new_args = args.to_vec();\n+                args = vec![new_args[1], new_args[0], new_args[2], new_args[3]].into();\n+            },\n+            \"__builtin_ia32_sqrtsd_mask_round\" | \"__builtin_ia32_sqrtss_mask_round\" => {\n+                let new_args = args.to_vec();\n+                args = vec![new_args[1], new_args[0], new_args[2], new_args[3], new_args[4]].into();\n+            },\n+            _ => (),\n         }\n     }\n \n     args\n }\n \n+pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>], args_adjusted: bool, orig_args: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    match func_name {\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n+            #[cfg(feature=\"master\")]\n+            {\n+                let zero = builder.context.new_rvalue_zero(builder.int_type);\n+                return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            }\n+        },\n+        \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+            // Both llvm.x86.addcarry.32 and llvm.x86.addcarryx.u32 points to the same GCC builtin,\n+            // but only the former requires adjusting the return value.\n+            // Those 2 LLVM intrinsics differ by their argument count, that's why we check if the\n+            // arguments were adjusted.\n+            if args_adjusted {\n+                let last_arg = args.last().expect(\"last arg\");\n+                let field1 = builder.context.new_field(None, builder.u8_type, \"carryFlag\");\n+                let field2 = builder.context.new_field(None, args[1].get_type(), \"carryResult\");\n+                let struct_type = builder.context.new_struct_type(None, \"addcarryResult\", &[field1, field2]);\n+                return_value = builder.context.new_struct_constructor(None, struct_type.as_type(), None, &[return_value, last_arg.dereference(None).to_rvalue()]);\n+            }\n+        },\n+        \"__builtin_ia32_stmxcsr\" => {\n+            // The builtin __builtin_ia32_stmxcsr returns a value while llvm.x86.sse.stmxcsr writes\n+            // the result in its pointer argument.\n+            // We removed the argument since __builtin_ia32_stmxcsr takes no arguments, so we need\n+            // to get back the original argument to get the pointer we need to write the result to.\n+            let uint_ptr_type = builder.uint_type.make_pointer();\n+            let ptr = builder.context.new_cast(None, orig_args[0], uint_ptr_type);\n+            builder.llbb().add_assignment(None, ptr.dereference(None), return_value);\n+            // The return value was assigned to the result pointer above. In order to not call the\n+            // builtin twice, we overwrite the return value with a dummy value.\n+            return_value = builder.context.new_rvalue_zero(builder.int_type);\n+        },\n+        _ => (),\n+    }\n+\n+    return_value\n+}\n+\n pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n-    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-    // last argument type check.\n     // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n     match func_name {\n+        // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+        // last argument type check.\n         \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n             | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n             | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n             | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n             | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n             | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n-            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\"\n+            | \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n                 if index == args_len - 1 {\n                     return true;\n                 }\n             },\n+        \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+            if index == 2 || index == 3 {\n+                return true;\n+            }\n+        },\n         \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n             // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n             // one of them has a missing parameter before the last one, we check the number of\n@@ -162,6 +390,14 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                 return true;\n             }\n         },\n+        // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => return true,\n+        \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+            | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+            if index == args_len - 1 {\n+                return true;\n+            }\n+        },\n         _ => (),\n     }\n \n@@ -171,7 +407,7 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n #[cfg(not(feature=\"master\"))]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n     match name {\n-        \"llvm.x86.xgetbv\" => {\n+        \"llvm.x86.xgetbv\" | \"llvm.x86.sse2.pause\" => {\n             let gcc_name = \"__builtin_trap\";\n             let func = cx.context.get_builtin_function(gcc_name);\n             cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n@@ -183,24 +419,26 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n \n #[cfg(feature=\"master\")]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n+    match name {\n+        \"llvm.prefetch\" => {\n+            let gcc_name = \"__builtin_prefetch\";\n+            let func = cx.context.get_builtin_function(gcc_name);\n+            cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+            return func\n+        },\n+        _ => (),\n+    }\n+\n     let gcc_name = match name {\n         \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n         // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n         \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n         \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n         \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n         \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n         \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n         \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n         \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n         \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n@@ -221,6 +459,153 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n         \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n+        \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.512\" => \"__builtin_ia32_ucmpd512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.256\" => \"__builtin_ia32_ucmpd256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.128\" => \"__builtin_ia32_ucmpd128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.512\" => \"__builtin_ia32_cmpd512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.256\" => \"__builtin_ia32_cmpd256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.128\" => \"__builtin_ia32_cmpd128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.512\" => \"__builtin_ia32_ucmpq512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.256\" => \"__builtin_ia32_ucmpq256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.128\" => \"__builtin_ia32_ucmpq128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.512\" => \"__builtin_ia32_cmpq512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.256\" => \"__builtin_ia32_cmpq256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.128\" => \"__builtin_ia32_cmpq128_mask\",\n+        \"llvm.x86.avx512.mask.max.ss.round\" => \"__builtin_ia32_maxss_mask_round\",\n+        \"llvm.x86.avx512.mask.max.sd.round\" => \"__builtin_ia32_maxsd_mask_round\",\n+        \"llvm.x86.avx512.mask.min.ss.round\" => \"__builtin_ia32_minss_mask_round\",\n+        \"llvm.x86.avx512.mask.min.sd.round\" => \"__builtin_ia32_minsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.ss\" => \"__builtin_ia32_sqrtss_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.sd\" => \"__builtin_ia32_sqrtsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.ss\" => \"__builtin_ia32_getexpss_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.sd\" => \"__builtin_ia32_getexpsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.ss\" => \"__builtin_ia32_getmantss_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.sd\" => \"__builtin_ia32_getmantsd_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.ss\" => \"__builtin_ia32_rndscaless_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.sd\" => \"__builtin_ia32_rndscalesd_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.ss\" => \"__builtin_ia32_scalefss_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.sd\" => \"__builtin_ia32_scalefsd_mask_round\",\n+        \"llvm.x86.avx512.vfmadd.f32\" => \"__builtin_ia32_vfmaddss3_round\",\n+        \"llvm.x86.avx512.vfmadd.f64\" => \"__builtin_ia32_vfmaddsd3_round\",\n+        \"llvm.ceil.v4f64\" => \"__builtin_ia32_ceilpd256\",\n+        \"llvm.ceil.v8f32\" => \"__builtin_ia32_ceilps256\",\n+        \"llvm.floor.v4f64\" => \"__builtin_ia32_floorpd256\",\n+        \"llvm.floor.v8f32\" => \"__builtin_ia32_floorps256\",\n+        \"llvm.sqrt.v4f64\" => \"__builtin_ia32_sqrtpd256\",\n+        \"llvm.x86.sse.stmxcsr\" => \"__builtin_ia32_stmxcsr\",\n+        \"llvm.x86.sse.ldmxcsr\" => \"__builtin_ia32_ldmxcsr\",\n+        \"llvm.ctpop.v16i32\" => \"__builtin_ia32_vpopcountd_v16si\",\n+        \"llvm.ctpop.v8i32\" => \"__builtin_ia32_vpopcountd_v8si\",\n+        \"llvm.ctpop.v4i32\" => \"__builtin_ia32_vpopcountd_v4si\",\n+        \"llvm.ctpop.v8i64\" => \"__builtin_ia32_vpopcountq_v8di\",\n+        \"llvm.ctpop.v4i64\" => \"__builtin_ia32_vpopcountq_v4di\",\n+        \"llvm.ctpop.v2i64\" => \"__builtin_ia32_vpopcountq_v2di\",\n+        \"llvm.x86.addcarry.64\" => \"__builtin_ia32_addcarryx_u64\",\n+        \"llvm.x86.subborrow.64\" => \"__builtin_ia32_sbb_u64\",\n+        \"llvm.floor.v2f64\" => \"__builtin_ia32_floorpd\",\n+        \"llvm.floor.v4f32\" => \"__builtin_ia32_floorps\",\n+        \"llvm.ceil.v2f64\" => \"__builtin_ia32_ceilpd\",\n+        \"llvm.ceil.v4f32\" => \"__builtin_ia32_ceilps\",\n+        \"llvm.fma.v2f64\" => \"__builtin_ia32_vfmaddpd\",\n+        \"llvm.fma.v4f64\" => \"__builtin_ia32_vfmaddpd256\",\n+        \"llvm.fma.v4f32\" => \"__builtin_ia32_vfmaddps\",\n+        \"llvm.fma.v8f32\" => \"__builtin_ia32_vfmaddps256\",\n+        \"llvm.ctlz.v16i32\" => \"__builtin_ia32_vplzcntd_512_mask\",\n+        \"llvm.ctlz.v8i32\" => \"__builtin_ia32_vplzcntd_256_mask\",\n+        \"llvm.ctlz.v4i32\" => \"__builtin_ia32_vplzcntd_128_mask\",\n+        \"llvm.ctlz.v8i64\" => \"__builtin_ia32_vplzcntq_512_mask\",\n+        \"llvm.ctlz.v4i64\" => \"__builtin_ia32_vplzcntq_256_mask\",\n+        \"llvm.ctlz.v2i64\" => \"__builtin_ia32_vplzcntq_128_mask\",\n+        \"llvm.ctpop.v32i16\" => \"__builtin_ia32_vpopcountw_v32hi\",\n+        \"llvm.x86.fma.vfmsub.sd\" => \"__builtin_ia32_vfmsubsd3\",\n+        \"llvm.x86.fma.vfmsub.ss\" => \"__builtin_ia32_vfmsubss3\",\n+        \"llvm.x86.fma.vfmsubadd.pd\" => \"__builtin_ia32_vfmaddsubpd\",\n+        \"llvm.x86.fma.vfmsubadd.pd.256\" => \"__builtin_ia32_vfmaddsubpd256\",\n+        \"llvm.x86.fma.vfmsubadd.ps\" => \"__builtin_ia32_vfmaddsubps\",\n+        \"llvm.x86.fma.vfmsubadd.ps.256\" => \"__builtin_ia32_vfmaddsubps256\",\n+        \"llvm.x86.fma.vfnmadd.sd\" => \"__builtin_ia32_vfnmaddsd3\",\n+        \"llvm.x86.fma.vfnmadd.ss\" => \"__builtin_ia32_vfnmaddss3\",\n+        \"llvm.x86.fma.vfnmsub.sd\" => \"__builtin_ia32_vfnmsubsd3\",\n+        \"llvm.x86.fma.vfnmsub.ss\" => \"__builtin_ia32_vfnmsubss3\",\n+        \"llvm.x86.avx512.conflict.d.512\" => \"__builtin_ia32_vpconflictsi_512_mask\",\n+        \"llvm.x86.avx512.conflict.d.256\" => \"__builtin_ia32_vpconflictsi_256_mask\",\n+        \"llvm.x86.avx512.conflict.d.128\" => \"__builtin_ia32_vpconflictsi_128_mask\",\n+        \"llvm.x86.avx512.conflict.q.512\" => \"__builtin_ia32_vpconflictdi_512_mask\",\n+        \"llvm.x86.avx512.conflict.q.256\" => \"__builtin_ia32_vpconflictdi_256_mask\",\n+        \"llvm.x86.avx512.conflict.q.128\" => \"__builtin_ia32_vpconflictdi_128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.512\" => \"__builtin_ia32_vpermt2varqi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.256\" => \"__builtin_ia32_vpermt2varqi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.128\" => \"__builtin_ia32_vpermt2varqi128_mask\",\n+        \"llvm.x86.avx512.permvar.qi.512\" => \"__builtin_ia32_permvarqi512_mask\",\n+        \"llvm.x86.avx512.permvar.qi.256\" => \"__builtin_ia32_permvarqi256_mask\",\n+        \"llvm.x86.avx512.permvar.qi.128\" => \"__builtin_ia32_permvarqi128_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.512\" => \"__builtin_ia32_vpmultishiftqb512_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.256\" => \"__builtin_ia32_vpmultishiftqb256_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.128\" => \"__builtin_ia32_vpmultishiftqb128_mask\",\n+        \"llvm.ctpop.v16i16\" => \"__builtin_ia32_vpopcountw_v16hi\",\n+        \"llvm.ctpop.v8i16\" => \"__builtin_ia32_vpopcountw_v8hi\",\n+        \"llvm.ctpop.v64i8\" => \"__builtin_ia32_vpopcountb_v64qi\",\n+        \"llvm.ctpop.v32i8\" => \"__builtin_ia32_vpopcountb_v32qi\",\n+        \"llvm.ctpop.v16i8\" => \"__builtin_ia32_vpopcountb_v16qi\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.512\" => \"__builtin_ia32_vpshufbitqmb512_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.256\" => \"__builtin_ia32_vpshufbitqmb256_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.128\" => \"__builtin_ia32_vpshufbitqmb128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.512\" => \"__builtin_ia32_ucmpw512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.256\" => \"__builtin_ia32_ucmpw256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.128\" => \"__builtin_ia32_ucmpw128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.512\" => \"__builtin_ia32_ucmpb512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.256\" => \"__builtin_ia32_ucmpb256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.128\" => \"__builtin_ia32_ucmpb128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.512\" => \"__builtin_ia32_cmpw512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.256\" => \"__builtin_ia32_cmpw256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.128\" => \"__builtin_ia32_cmpw128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.512\" => \"__builtin_ia32_cmpb512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.256\" => \"__builtin_ia32_cmpb256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.128\" => \"__builtin_ia32_cmpb128_mask\",\n+        \"llvm.x86.xrstor\" => \"__builtin_ia32_xrstor\",\n+        \"llvm.x86.xsavec\" => \"__builtin_ia32_xsavec\",\n+        \"llvm.x86.addcarry.32\" => \"__builtin_ia32_addcarryx_u32\",\n+        \"llvm.x86.subborrow.32\" => \"__builtin_ia32_sbb_u32\",\n+        \"llvm.x86.avx512.mask.compress.store.w.512\" => \"__builtin_ia32_compressstoreuhi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.256\" => \"__builtin_ia32_compressstoreuhi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.128\" => \"__builtin_ia32_compressstoreuhi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.512\" => \"__builtin_ia32_compressstoreuqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.256\" => \"__builtin_ia32_compressstoreuqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.128\" => \"__builtin_ia32_compressstoreuqi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.512\" => \"__builtin_ia32_compresshi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.256\" => \"__builtin_ia32_compresshi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.128\" => \"__builtin_ia32_compresshi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.512\" => \"__builtin_ia32_compressqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.256\" => \"__builtin_ia32_compressqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.128\" => \"__builtin_ia32_compressqi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.512\" => \"__builtin_ia32_expandhi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.256\" => \"__builtin_ia32_expandhi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.128\" => \"__builtin_ia32_expandhi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.512\" => \"__builtin_ia32_expandqi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.256\" => \"__builtin_ia32_expandqi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.128\" => \"__builtin_ia32_expandqi128_mask\",\n+        \"llvm.fshl.v8i64\" => \"__builtin_ia32_vpshldv_v8di\",\n+        \"llvm.fshl.v4i64\" => \"__builtin_ia32_vpshldv_v4di\",\n+        \"llvm.fshl.v2i64\" => \"__builtin_ia32_vpshldv_v2di\",\n+        \"llvm.fshl.v16i32\" => \"__builtin_ia32_vpshldv_v16si\",\n+        \"llvm.fshl.v8i32\" => \"__builtin_ia32_vpshldv_v8si\",\n+        \"llvm.fshl.v4i32\" => \"__builtin_ia32_vpshldv_v4si\",\n+        \"llvm.fshl.v32i16\" => \"__builtin_ia32_vpshldv_v32hi\",\n+        \"llvm.fshl.v16i16\" => \"__builtin_ia32_vpshldv_v16hi\",\n+        \"llvm.fshl.v8i16\" => \"__builtin_ia32_vpshldv_v8hi\",\n+        \"llvm.fshr.v8i64\" => \"__builtin_ia32_vpshrdv_v8di\",\n+        \"llvm.fshr.v4i64\" => \"__builtin_ia32_vpshrdv_v4di\",\n+        \"llvm.fshr.v2i64\" => \"__builtin_ia32_vpshrdv_v2di\",\n+        \"llvm.fshr.v16i32\" => \"__builtin_ia32_vpshrdv_v16si\",\n+        \"llvm.fshr.v8i32\" => \"__builtin_ia32_vpshrdv_v8si\",\n+        \"llvm.fshr.v4i32\" => \"__builtin_ia32_vpshrdv_v4si\",\n+        \"llvm.fshr.v32i16\" => \"__builtin_ia32_vpshrdv_v32hi\",\n+        \"llvm.fshr.v16i16\" => \"__builtin_ia32_vpshrdv_v16hi\",\n+        \"llvm.fshr.v8i16\" => \"__builtin_ia32_vpshrdv_v8hi\",\n+        \"llvm.x86.fma.vfmadd.sd\" => \"__builtin_ia32_vfmaddsd3\",\n+        \"llvm.x86.fma.vfmadd.ss\" => \"__builtin_ia32_vfmaddss3\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n@@ -239,7 +624,151 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n         \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n         \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n-        \"\" => \"\",\n+        \"llvm.x86.avx512.pslli.d.512\" => \"__builtin_ia32_pslldi512_mask\",\n+        \"llvm.x86.avx512.psrli.d.512\" => \"__builtin_ia32_psrldi512_mask\",\n+        \"llvm.x86.avx512.pslli.q.512\" => \"__builtin_ia32_psllqi512_mask\",\n+        \"llvm.x86.avx512.psrli.q.512\" => \"__builtin_ia32_psrlqi512_mask\",\n+        \"llvm.x86.avx512.psll.d.512\" => \"__builtin_ia32_pslld512_mask\",\n+        \"llvm.x86.avx512.psrl.d.512\" => \"__builtin_ia32_psrld512_mask\",\n+        \"llvm.x86.avx512.psll.q.512\" => \"__builtin_ia32_psllq512_mask\",\n+        \"llvm.x86.avx512.psrl.q.512\" => \"__builtin_ia32_psrlq512_mask\",\n+        \"llvm.x86.avx512.psra.d.512\" => \"__builtin_ia32_psrad512_mask\",\n+        \"llvm.x86.avx512.psra.q.512\" => \"__builtin_ia32_psraq512_mask\",\n+        \"llvm.x86.avx512.psra.q.256\" => \"__builtin_ia32_psraq256_mask\",\n+        \"llvm.x86.avx512.psra.q.128\" => \"__builtin_ia32_psraq128_mask\",\n+        \"llvm.x86.avx512.psrai.d.512\" => \"__builtin_ia32_psradi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.512\" => \"__builtin_ia32_psraqi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.256\" => \"__builtin_ia32_psraqi256_mask\",\n+        \"llvm.x86.avx512.psrai.q.128\" => \"__builtin_ia32_psraqi128_mask\",\n+        \"llvm.x86.avx512.psrav.d.512\" => \"__builtin_ia32_psrav16si_mask\",\n+        \"llvm.x86.avx512.psrav.q.512\" => \"__builtin_ia32_psrav8di_mask\",\n+        \"llvm.x86.avx512.psrav.q.256\" => \"__builtin_ia32_psravq256_mask\",\n+        \"llvm.x86.avx512.psrav.q.128\" => \"__builtin_ia32_psravq128_mask\",\n+        \"llvm.x86.avx512.psllv.d.512\" => \"__builtin_ia32_psllv16si_mask\",\n+        \"llvm.x86.avx512.psrlv.d.512\" => \"__builtin_ia32_psrlv16si_mask\",\n+        \"llvm.x86.avx512.psllv.q.512\" => \"__builtin_ia32_psllv8di_mask\",\n+        \"llvm.x86.avx512.psrlv.q.512\" => \"__builtin_ia32_psrlv8di_mask\",\n+        \"llvm.x86.avx512.permvar.si.512\" => \"__builtin_ia32_permvarsi512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.ps.512\" => \"__builtin_ia32_vpermilvarps512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.pd.512\" => \"__builtin_ia32_vpermilvarpd512_mask\",\n+        \"llvm.x86.avx512.permvar.di.512\" => \"__builtin_ia32_permvardi512_mask\",\n+        \"llvm.x86.avx512.permvar.di.256\" => \"__builtin_ia32_permvardi256_mask\",\n+        \"llvm.x86.avx512.permvar.sf.512\" => \"__builtin_ia32_permvarsf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.512\" => \"__builtin_ia32_permvardf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.256\" => \"__builtin_ia32_permvardf256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.512\" => \"__builtin_ia32_vpermi2vard512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.256\" => \"__builtin_ia32_vpermi2vard256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.128\" => \"__builtin_ia32_vpermi2vard128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.512\" => \"__builtin_ia32_vpermi2varq512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.256\" => \"__builtin_ia32_vpermi2varq256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.128\" => \"__builtin_ia32_vpermi2varq128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.512\" => \"__builtin_ia32_vpermi2varps512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.256\" => \"__builtin_ia32_vpermi2varps256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.128\" => \"__builtin_ia32_vpermi2varps128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.512\" => \"__builtin_ia32_vpermi2varpd512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.256\" => \"__builtin_ia32_vpermi2varpd256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.128\" => \"__builtin_ia32_vpermi2varpd128_mask\",\n+        \"llvm.x86.avx512.mask.add.ss.round\" => \"__builtin_ia32_addss_mask_round\",\n+        \"llvm.x86.avx512.mask.add.sd.round\" => \"__builtin_ia32_addsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.ss.round\" => \"__builtin_ia32_subss_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.sd.round\" => \"__builtin_ia32_subsd_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.ss.round\" => \"__builtin_ia32_mulss_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.sd.round\" => \"__builtin_ia32_mulsd_mask_round\",\n+        \"llvm.x86.avx512.mask.div.ss.round\" => \"__builtin_ia32_divss_mask_round\",\n+        \"llvm.x86.avx512.mask.div.sd.round\" => \"__builtin_ia32_divsd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtss2sd.round\" => \"__builtin_ia32_cvtss2sd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtsd2ss.round\" => \"__builtin_ia32_cvtsd2ss_mask_round\",\n+        \"llvm.x86.avx512.mask.range.ss\" => \"__builtin_ia32_rangess128_mask_round\",\n+        \"llvm.x86.avx512.mask.range.sd\" => \"__builtin_ia32_rangesd128_mask_round\",\n+        \"llvm.x86.avx512.rcp28.ss\" => \"__builtin_ia32_rcp28ss_mask_round\",\n+        \"llvm.x86.avx512.rcp28.sd\" => \"__builtin_ia32_rcp28sd_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.ss\" => \"__builtin_ia32_rsqrt28ss_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.sd\" => \"__builtin_ia32_rsqrt28sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.add.sh.round\" => \"__builtin_ia32_addsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.div.sh.round\" => \"__builtin_ia32_divsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.getmant.sh\" => \"__builtin_ia32_getmantsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.max.sh.round\" => \"__builtin_ia32_maxsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.min.sh.round\" => \"__builtin_ia32_minsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.mul.sh.round\" => \"__builtin_ia32_mulsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.rndscale.sh\" => \"__builtin_ia32_rndscalesh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.scalef.sh\" => \"__builtin_ia32_scalefsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.sub.sh.round\" => \"__builtin_ia32_subsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsd2sh.round\" => \"__builtin_ia32_vcvtsd2sh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2sd.round\" => \"__builtin_ia32_vcvtsh2sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2ss.round\" => \"__builtin_ia32_vcvtsh2ss_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtss2sh.round\" => \"__builtin_ia32_vcvtss2sh_mask_round\",\n+        \"llvm.x86.aesni.aesenc.256\" => \"__builtin_ia32_vaesenc_v32qi\",\n+        \"llvm.x86.aesni.aesenclast.256\" => \"__builtin_ia32_vaesenclast_v32qi\",\n+        \"llvm.x86.aesni.aesdec.256\" => \"__builtin_ia32_vaesdec_v32qi\",\n+        \"llvm.x86.aesni.aesdeclast.256\" => \"__builtin_ia32_vaesdeclast_v32qi\",\n+        \"llvm.x86.aesni.aesenc.512\" => \"__builtin_ia32_vaesenc_v64qi\",\n+        \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n+        \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n+        \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32bf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.256\" => \"__builtin_ia32_cvtneps2bf16_v8sf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.512\" => \"__builtin_ia32_cvtneps2bf16_v16sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.128\" => \"__builtin_ia32_dpbf16ps_v4sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.256\" => \"__builtin_ia32_dpbf16ps_v8sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.512\" => \"__builtin_ia32_dpbf16ps_v16sf\",\n+        \"llvm.x86.pclmulqdq.512\" => \"__builtin_ia32_vpclmulqdq_v8di\",\n+        \"llvm.x86.pclmulqdq.256\" => \"__builtin_ia32_vpclmulqdq_v4di\",\n+        \"llvm.x86.avx512.pmulhu.w.512\" => \"__builtin_ia32_pmulhuw512_mask\",\n+        \"llvm.x86.avx512.pmulh.w.512\" => \"__builtin_ia32_pmulhw512_mask\",\n+        \"llvm.x86.avx512.pmul.hr.sw.512\" => \"__builtin_ia32_pmulhrsw512_mask\",\n+        \"llvm.x86.avx512.pmaddw.d.512\" => \"__builtin_ia32_pmaddwd512_mask\",\n+        \"llvm.x86.avx512.pmaddubs.w.512\" => \"__builtin_ia32_pmaddubsw512_mask\",\n+        \"llvm.x86.avx512.packssdw.512\" => \"__builtin_ia32_packssdw512_mask\",\n+        \"llvm.x86.avx512.packsswb.512\" => \"__builtin_ia32_packsswb512_mask\",\n+        \"llvm.x86.avx512.packusdw.512\" => \"__builtin_ia32_packusdw512_mask\",\n+        \"llvm.x86.avx512.packuswb.512\" => \"__builtin_ia32_packuswb512_mask\",\n+        \"llvm.x86.avx512.pavg.w.512\" => \"__builtin_ia32_pavgw512_mask\",\n+        \"llvm.x86.avx512.pavg.b.512\" => \"__builtin_ia32_pavgb512_mask\",\n+        \"llvm.x86.avx512.psll.w.512\" => \"__builtin_ia32_psllw512_mask\",\n+        \"llvm.x86.avx512.pslli.w.512\" => \"__builtin_ia32_psllwi512_mask\",\n+        \"llvm.x86.avx512.psllv.w.512\" => \"__builtin_ia32_psllv32hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.256\" => \"__builtin_ia32_psllv16hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.128\" => \"__builtin_ia32_psllv8hi_mask\",\n+        \"llvm.x86.avx512.psrl.w.512\" => \"__builtin_ia32_psrlw512_mask\",\n+        \"llvm.x86.avx512.psrli.w.512\" => \"__builtin_ia32_psrlwi512_mask\",\n+        \"llvm.x86.avx512.psrlv.w.512\" => \"__builtin_ia32_psrlv32hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.256\" => \"__builtin_ia32_psrlv16hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.128\" => \"__builtin_ia32_psrlv8hi_mask\",\n+        \"llvm.x86.avx512.psra.w.512\" => \"__builtin_ia32_psraw512_mask\",\n+        \"llvm.x86.avx512.psrai.w.512\" => \"__builtin_ia32_psrawi512_mask\",\n+        \"llvm.x86.avx512.psrav.w.512\" => \"__builtin_ia32_psrav32hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.256\" => \"__builtin_ia32_psrav16hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.128\" => \"__builtin_ia32_psrav8hi_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.512\" => \"__builtin_ia32_vpermt2varhi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.256\" => \"__builtin_ia32_vpermt2varhi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.128\" => \"__builtin_ia32_vpermt2varhi128_mask\",\n+        \"llvm.x86.avx512.permvar.hi.512\" => \"__builtin_ia32_permvarhi512_mask\",\n+        \"llvm.x86.avx512.permvar.hi.256\" => \"__builtin_ia32_permvarhi256_mask\",\n+        \"llvm.x86.avx512.permvar.hi.128\" => \"__builtin_ia32_permvarhi128_mask\",\n+        \"llvm.x86.avx512.pshuf.b.512\" => \"__builtin_ia32_pshufb512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.512\" => \"__builtin_ia32_dbpsadbw512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.256\" => \"__builtin_ia32_dbpsadbw256_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.128\" => \"__builtin_ia32_dbpsadbw128_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.512\" => \"__builtin_ia32_vpmadd52huq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.512\" => \"__builtin_ia32_vpmadd52luq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.256\" => \"__builtin_ia32_vpmadd52huq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.256\" => \"__builtin_ia32_vpmadd52luq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.128\" => \"__builtin_ia32_vpmadd52huq128_mask\",\n+        \"llvm.x86.avx512.vpdpwssd.512\" => \"__builtin_ia32_vpdpwssd_v16si\",\n+        \"llvm.x86.avx512.vpdpwssd.256\" => \"__builtin_ia32_vpdpwssd_v8si\",\n+        \"llvm.x86.avx512.vpdpwssd.128\" => \"__builtin_ia32_vpdpwssd_v4si\",\n+        \"llvm.x86.avx512.vpdpwssds.512\" => \"__builtin_ia32_vpdpwssds_v16si\",\n+        \"llvm.x86.avx512.vpdpwssds.256\" => \"__builtin_ia32_vpdpwssds_v8si\",\n+        \"llvm.x86.avx512.vpdpwssds.128\" => \"__builtin_ia32_vpdpwssds_v4si\",\n+        \"llvm.x86.avx512.vpdpbusd.512\" => \"__builtin_ia32_vpdpbusd_v16si\",\n+        \"llvm.x86.avx512.vpdpbusd.256\" => \"__builtin_ia32_vpdpbusd_v8si\",\n+        \"llvm.x86.avx512.vpdpbusd.128\" => \"__builtin_ia32_vpdpbusd_v4si\",\n+        \"llvm.x86.avx512.vpdpbusds.512\" => \"__builtin_ia32_vpdpbusds_v16si\",\n+        \"llvm.x86.avx512.vpdpbusds.256\" => \"__builtin_ia32_vpdpbusds_v8si\",\n+        \"llvm.x86.avx512.vpdpbusds.128\" => \"__builtin_ia32_vpdpbusds_v4si\",\n+\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "94dc8c9e93b0de1b4ce3145503b4c8b33a7b6c1c", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 152, "deletions": 6, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,22 +1,33 @@\n pub mod llvm;\n mod simd;\n \n+#[cfg(feature=\"master\")]\n+use std::iter;\n+\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::traits::{DerivedTypeMethods, MiscMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::PanicStrategy;\n+#[cfg(feature=\"master\")]\n+use rustc_target::spec::abi::Abi;\n \n use crate::abi::GccType;\n+#[cfg(feature=\"master\")]\n+use crate::abi::FnAbiGccExt;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n@@ -68,6 +79,8 @@ fn get_simple_intrinsic<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, name: Symbol) ->\n         sym::nearbyintf64 => \"nearbyint\",\n         sym::roundf32 => \"roundf\",\n         sym::roundf64 => \"round\",\n+        sym::roundevenf32 => \"roundevenf\",\n+        sym::roundevenf64 => \"roundeven\",\n         sym::abort => \"abort\",\n         _ => return None,\n     };\n@@ -91,7 +104,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let name = tcx.item_name(def_id);\n         let name_str = name.as_str();\n \n-        let llret_ty = self.layout_of(ret_ty).gcc_type(self, true);\n+        let llret_ty = self.layout_of(ret_ty).gcc_type(self);\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n@@ -404,7 +417,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        self.layout.gcc_type(cx, true)\n+        self.layout.gcc_type(cx)\n     }\n \n     /// Stores a direct/indirect value described by this ArgAbi into a\n@@ -1120,10 +1133,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n }\n \n-fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n-    // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n-    if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n-        // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n+fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n@@ -1134,6 +1145,141 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n         unimplemented!();\n     }\n     else {\n+        #[cfg(feature=\"master\")]\n+        codegen_gnu_try(bx, try_func, data, _catch_func, dest);\n+        #[cfg(not(feature=\"master\"))]\n         unimplemented!();\n     }\n }\n+\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n+// instructions).\n+//\n+// This codegen is a little surprising because we always call a shim\n+// function instead of inlining the call to `invoke` manually here. This is done\n+// because in LLVM we're only allowed to have one personality per function\n+// definition. The call to the `try` intrinsic is being inlined into the\n+// function calling it, and that function may already have other personality\n+// functions in play. By calling a shim we're guaranteed that our shim will have\n+// the right personality function.\n+#[cfg(feature=\"master\")]\n+fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>, data: RValue<'gcc>, catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    let cx: &CodegenCx<'gcc, '_> = bx.cx;\n+    let (llty, func) = get_rust_try_fn(cx, &mut |mut bx| {\n+        // Codegens the shims described above:\n+        //\n+        //   bx:\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret 0\n+        //\n+        //   catch:\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n+        //      ret 1\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n+\n+        let func = bx.current_func();\n+        let try_func = func.get_param(0).to_rvalue();\n+        let data = func.get_param(1).to_rvalue();\n+        let catch_func = func.get_param(2).to_rvalue();\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+\n+        let current_block = bx.block.clone();\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n+\n+        // Type indicator for the exception being thrown.\n+        //\n+        // The value is a pointer to the exception object\n+        // being thrown.\n+        bx.switch_to_block(catch);\n+        bx.set_personality_fn(bx.eh_personality());\n+\n+        let eh_pointer_builtin = bx.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n+        let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n+\n+        // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n+        // generate a try/catch.\n+        // FIXME(antoyo): add a check in the libgccjit API to prevent this.\n+        bx.switch_to_block(current_block);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n+    });\n+\n+    let func = unsafe { std::mem::transmute(func) };\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = bx.call(llty, None, func, &[try_func, data, catch_func], None);\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n+    bx.store(ret, dest, i32_align);\n+}\n+\n+\n+// Helper function used to get a handle to the `__rust_try` function used to\n+// catch exceptions.\n+//\n+// This function is only generated once and is then cached.\n+#[cfg(feature=\"master\")]\n+fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n+        return llfn;\n+    }\n+\n+    // Define the type up front for the signature of the rust_try function.\n+    let tcx = cx.tcx;\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        iter::once(i8p),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        [try_fn_ty, i8p, catch_fn_ty],\n+        tcx.types.i32,\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n+    cx.rust_try_fn.set(Some(rust_try));\n+    rust_try\n+}\n+\n+// Helper function to give a Block to a closure to codegen a shim function.\n+// This is currently primarily used for the `try` intrinsic functions above.\n+#[cfg(feature=\"master\")]\n+fn gen_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, name: &str, rust_fn_sig: ty::PolyFnSig<'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n+    let (typ, _, _, _) = fn_abi.gcc_type(cx);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    cx.linkage.set(FunctionType::Internal);\n+    let func = cx.declare_fn(name, fn_abi);\n+    let func_val = unsafe { std::mem::transmute(func) };\n+    cx.set_frame_pointer_type(func_val);\n+    cx.apply_target_cpu_attr(func_val);\n+    let block = Builder::append_block(cx, func_val, \"entry-block\");\n+    let bx = Builder::build(cx, block);\n+    codegen(bx);\n+    (typ, func)\n+}"}, {"sha": "b59c3a64f5728bdd2ad61fd728ccc64b4e9709b9", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 582, "deletions": 257, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,8 +1,13 @@\n-use std::cmp::Ordering;\n+#[cfg(feature=\"master\")]\n+use gccjit::{ComparisonOp, UnaryOp};\n+use gccjit::ToRValue;\n+use gccjit::{BinaryOp, RValue, Type};\n \n-use gccjit::{BinaryOp, RValue, ToRValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::TypeKind;\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::errors::ExpectedPointerMutability;\n+use rustc_codegen_ssa::errors::InvalidMonomorphization;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,18 +19,21 @@ use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+#[cfg(feature=\"master\")]\n+use crate::context::CodegenCx;\n+#[cfg(feature=\"master\")]\n+use crate::errors::{InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationInsertedType};\n use crate::errors::{\n-    InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationExpectedSimd,\n-    InvalidMonomorphizationInsertedType, InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationInvalidBitmask,\n     InvalidMonomorphizationInvalidFloatVector, InvalidMonomorphizationMaskType,\n     InvalidMonomorphizationMismatchedLengths, InvalidMonomorphizationNotFloat,\n     InvalidMonomorphizationReturnElement, InvalidMonomorphizationReturnIntegerType,\n     InvalidMonomorphizationReturnLength, InvalidMonomorphizationReturnLengthInputType,\n     InvalidMonomorphizationReturnType, InvalidMonomorphizationSimdShuffle,\n-    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedCast,\n-    InvalidMonomorphizationUnsupportedElement, InvalidMonomorphizationUnsupportedOperation,\n+    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationUnsupportedOperation,\n };\n-use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n     bx: &mut Builder<'a, 'gcc, 'tcx>,\n@@ -105,14 +113,19 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let arg1_vector_type = arg1_type.unqualified().dyncast_vector().expect(\"vector type\");\n         let arg1_element_type = arg1_vector_type.get_element_type();\n \n+        // NOTE: since the arguments can be vectors of floats, make sure the mask is a vector of\n+        // integer.\n+        let mask_element_type = bx.type_ix(arg1_element_type.get_size() as u64 * 8);\n+        let vector_mask_type = bx.context.new_vector_type(mask_element_type, arg1_vector_type.get_num_units() as u64);\n+\n         let mut elements = vec![];\n         let one = bx.context.new_rvalue_one(mask.get_type());\n         for _ in 0..len {\n-            let element = bx.context.new_cast(None, mask & one, arg1_element_type);\n+            let element = bx.context.new_cast(None, mask & one, mask_element_type);\n             elements.push(element);\n             mask = mask >> one;\n         }\n-        let vector_mask = bx.context.new_rvalue_from_vector(None, arg1_type, &elements);\n+        let vector_mask = bx.context.new_rvalue_from_vector(None, vector_mask_type, &elements);\n \n         return Ok(bx.vector_select(vector_mask, arg1, args[2].immediate()));\n     }\n@@ -210,48 +223,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n         let value = args[2].immediate();\n-        // TODO(antoyo): use a recursive unqualified() here.\n-        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n-        let element_type = vector_type.get_element_type();\n-        // NOTE: we cannot cast to an array and assign to its element here because the value might\n-        // not be an l-value. So, call a builtin to set the element.\n-        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n-        // TODO(antoyo): don't use target specific builtins here.\n-        let func_name = match in_len {\n-            2 => {\n-                if element_type == bx.i64_type {\n-                    \"__builtin_ia32_vec_set_v2di\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            4 => {\n-                if element_type == bx.i32_type {\n-                    \"__builtin_ia32_vec_set_v4si\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            8 => {\n-                if element_type == bx.i16_type {\n-                    \"__builtin_ia32_vec_set_v8hi\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            _ => unimplemented!(\"Len: {}\", in_len),\n-        };\n-        let builtin = bx.context.get_target_builtin_function(func_name);\n-        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n-        let result = bx.context.new_call(\n-            None,\n-            builtin,\n-            &[vector, value, bx.context.new_cast(None, index, bx.int_type)],\n-        );\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+        let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n+        bx.llbb().add_assignment(None, variable, vector);\n+        let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n+        // TODO(antoyo): if simd_insert is constant, use BIT_REF.\n+        bx.llbb().add_assignment(None, lvalue, value);\n+        return Ok(variable.to_rvalue());\n     }\n \n     #[cfg(feature = \"master\")]\n@@ -280,7 +257,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n \n-    if name == sym::simd_cast {\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_cast || name == sym::simd_as {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n@@ -301,125 +279,40 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n \n         enum Style {\n             Float,\n-            Int(/* is signed? */ bool),\n+            Int,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind() {\n-            // vectors of pointer-sized integers should've been\n-            // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-        let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-\n-        let extend = |in_type, out_type| {\n-            let vector_type = bx.context.new_vector_type(out_type, 8);\n-            let vector = args[0].immediate();\n-            let array_type = bx.context.new_array_type(None, in_type, 8);\n-            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n-            let array = bx.context.new_bitcast(None, vector, array_type);\n-\n-            let cast_vec_element = |index| {\n-                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n-                bx.context.new_cast(\n-                    None,\n-                    bx.context.new_array_access(None, array, index).to_rvalue(),\n-                    out_type,\n-                )\n+        let in_style =\n+            match in_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n             };\n \n-            bx.context.new_rvalue_from_vector(\n-                None,\n-                vector_type,\n-                &[\n-                    cast_vec_element(0),\n-                    cast_vec_element(1),\n-                    cast_vec_element(2),\n-                    cast_vec_element(3),\n-                    cast_vec_element(4),\n-                    cast_vec_element(5),\n-                    cast_vec_element(6),\n-                    cast_vec_element(7),\n-                ],\n-            )\n-        };\n+        let out_style =\n+            match out_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n+            };\n \n         match (in_style, out_style) {\n-            (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n-                    Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => {\n-                        if in_is_signed {\n-                            match (in_width, out_width) {\n-                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n-                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n-                                // we can generate a call to it.\n-                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n-                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n-                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n-                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n-                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n-                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        } else {\n-                            match (in_width, out_width) {\n-                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n-                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n-                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n-                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n-                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n-                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        }\n+            (Style::Unsupported, Style::Unsupported) => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedCast {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty,\n+                        out_elem\n                     }\n-                });\n-            }\n-            (Style::Int(_), Style::Float) => {\n-                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n-                // doing like __builtin_convertvector?\n-                // Or maybe provide convert_vector as an API since it might not easy to get the\n-                // types of internal functions.\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Int(_)) => {\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Float) => {\n-                unimplemented!();\n-            }\n-            _ => { /* Unsupported. Fallthrough. */ }\n+                );\n+            },\n+            _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n         }\n-        return_error!(InvalidMonomorphizationUnsupportedCast {\n-            span,\n-            name,\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n-        });\n     }\n \n     macro_rules! arith_binary {\n@@ -436,6 +329,71 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         }\n     }\n \n+    if name == sym::simd_bitmask {\n+        // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n+\n+        let vector = args[0].immediate();\n+        let vector_type = vector.get_type().dyncast_vector().expect(\"vector type\");\n+        let elem_type = vector_type.get_element_type();\n+\n+        let expected_int_bits = in_len.max(8);\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+        // FIXME(antoyo): that's not going to work for masks bigger than 128 bits.\n+        let result_type = bx.type_ix(expected_int_bits);\n+        let mut result = bx.context.new_rvalue_zero(result_type);\n+\n+        let elem_size = elem_type.get_size() * 8;\n+        let sign_shift = bx.context.new_rvalue_from_int(elem_type, elem_size as i32 - 1);\n+        let one = bx.context.new_rvalue_one(elem_type);\n+\n+        let mut shift = 0;\n+        for i in 0..in_len {\n+            let elem = bx.extract_element(vector, bx.context.new_rvalue_from_int(bx.int_type, i as i32));\n+            let shifted = elem >> sign_shift;\n+            let masked = shifted & one;\n+            result = result | (bx.context.new_cast(None, masked, result_type) << bx.context.new_rvalue_from_int(result_type, shift));\n+            shift += 1;\n+        }\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(result);\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array length:\n+                let ze = bx.zext(result, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            }),\n+        }\n+    }\n+\n     fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n         name: Symbol,\n         in_elem: Ty<'_>,\n@@ -451,55 +409,66 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 return Err(());\n             }};\n         }\n-        let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n-            let elem_ty = bx.cx.type_float_from_ty(*f);\n-            match f.bit_width() {\n-                32 => (\"f32\", elem_ty),\n-                64 => (\"f64\", elem_ty),\n-                _ => {\n-                    return_error!(InvalidMonomorphizationInvalidFloatVector {\n-                        span,\n-                        name,\n-                        elem_ty: f.name_str(),\n-                        vec_ty: in_ty\n-                    });\n+        let (elem_ty_str, elem_ty) =\n+            if let ty::Float(f) = in_elem.kind() {\n+                let elem_ty = bx.cx.type_float_from_ty(*f);\n+                match f.bit_width() {\n+                    32 => (\"f\", elem_ty),\n+                    64 => (\"\", elem_ty),\n+                    _ => {\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n+                    }\n                 }\n             }\n-        } else {\n-            return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n-        };\n+            else {\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n+            };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n \n-        let (intr_name, fn_ty) = match name {\n-            sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)), // TODO(antoyo): pand with 170141183420855150465331762880109871103\n-            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n-            sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => return_error!(InvalidMonomorphizationUnrecognized { span, name }),\n-        };\n-        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n-        let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n-        let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n-        let c = bx.call(\n-            fn_ty,\n-            None,\n-            function,\n-            &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-            None,\n-        );\n+        let intr_name =\n+            match name {\n+                sym::simd_ceil => \"ceil\",\n+                sym::simd_fabs => \"fabs\", // TODO(antoyo): pand with 170141183420855150465331762880109871103\n+                sym::simd_fcos => \"cos\",\n+                sym::simd_fexp2 => \"exp2\",\n+                sym::simd_fexp => \"exp\",\n+                sym::simd_flog10 => \"log10\",\n+                sym::simd_flog2 => \"log2\",\n+                sym::simd_flog => \"log\",\n+                sym::simd_floor => \"floor\",\n+                sym::simd_fma => \"fma\",\n+                sym::simd_fpowi => \"__builtin_powi\",\n+                sym::simd_fpow => \"pow\",\n+                sym::simd_fsin => \"sin\",\n+                sym::simd_fsqrt => \"sqrt\",\n+                sym::simd_round => \"round\",\n+                sym::simd_trunc => \"trunc\",\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n+            };\n+        let builtin_name = format!(\"{}{}\", intr_name, elem_ty_str);\n+        let funcs = bx.cx.functions.borrow();\n+        let function = funcs.get(&builtin_name).unwrap_or_else(|| panic!(\"unable to find builtin function {}\", builtin_name));\n+\n+        // TODO(antoyo): add platform-specific behavior here for architectures that have these\n+        // intrinsics as instructions (for instance, gpus)\n+        let mut vector_elements = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.ulong_type, i as i64);\n+            // we have to treat fpowi specially, since fpowi's second argument is always an i32\n+            let arguments = if name == sym::simd_fpowi {\n+                vec![\n+                    bx.extract_element(args[0].immediate(), index).to_rvalue(),\n+                    args[1].immediate(),\n+                ]\n+            } else {\n+                args.iter()\n+                    .map(|arg| bx.extract_element(arg.immediate(), index).to_rvalue())\n+                    .collect()\n+            };\n+            vector_elements.push(bx.context.new_call(None, *function, &arguments));\n+        }\n+        let c = bx.context.new_rvalue_from_vector(None, vec_ty, &vector_elements);\n         Ok(c)\n     }\n \n@@ -525,6 +494,297 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn vector_ty<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, elem_ty: Ty<'tcx>, vec_len: u64) -> Type<'gcc> {\n+        // FIXME: use cx.layout_of(ty).llvm_type() ?\n+        let elem_ty = match *elem_ty.kind() {\n+            ty::Int(v) => cx.type_int_from_ty(v),\n+            ty::Uint(v) => cx.type_uint_from_ty(v),\n+            ty::Float(v) => cx.type_float_from_ty(v),\n+            _ => unreachable!(),\n+        };\n+        cx.type_vector(elem_ty, vec_len)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn gather<'a, 'gcc, 'tcx>(default: RValue<'gcc>, pointers: RValue<'gcc>, mask: RValue<'gcc>, pointer_count: usize, bx: &mut Builder<'a, 'gcc, 'tcx>, in_len: u64, underlying_ty: Ty<'tcx>, invert: bool) -> RValue<'gcc> {\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        let mut values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            let value = ptr.dereference(None).to_rvalue();\n+            values.push(value);\n+        }\n+\n+        let vector = bx.context.new_rvalue_from_vector(None, vector_type, &values);\n+\n+        let mut mask_types = vec![];\n+        let mut mask_values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            mask_types.push(bx.context.new_field(None, bx.i32_type, \"m\"));\n+            let mask_value = bx.context.new_vector_access(None, mask, index).to_rvalue();\n+            let masked = bx.context.new_rvalue_from_int(bx.i32_type, in_len as i32) & mask_value;\n+            let value = index + masked;\n+            mask_values.push(value);\n+        }\n+        let mask_type = bx.context.new_struct_type(None, \"mask_type\", &mask_types);\n+        let mask = bx.context.new_struct_constructor(None, mask_type.as_type(), None, &mask_values);\n+\n+        if invert {\n+            bx.shuffle_vector(vector, default, mask)\n+        }\n+        else {\n+            bx.shuffle_vector(default, vector, mask)\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_gather {\n+        // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n+        //             mask: <N x i{M}>) -> <N x T>\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(ret_ty, \"return\");\n+\n+        // Of the same length:\n+        let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n+        );\n+        require!(\n+            in_len == out_len2,\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n+        );\n+\n+        // The return type must match the first argument type\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(element_ty1), non_ptr(element_ty1)),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n+                );\n+            }\n+        }\n+\n+        return Ok(gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, false));\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_scatter {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == element_len1,\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n+        );\n+        require!(\n+            in_len == element_len2,\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+                (ptr_count(element_ty1), non_ptr(element_ty1))\n+            }\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n+                );\n+            }\n+        }\n+\n+        let result = gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, true);\n+\n+        let pointers = args[1].immediate();\n+\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_int(bx.int_type, i as i32);\n+            let value = bx.context.new_vector_access(None, result, index);\n+\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            bx.llbb().add_assignment(None, ptr.dereference(None), value);\n+        }\n+\n+        return Ok(bx.context.new_rvalue_zero(bx.i32_type));\n+    }\n+\n     arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;\n@@ -536,6 +796,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         simd_and: Uint, Int => and;\n         simd_or: Uint, Int => or; // FIXME(antoyo): calling `or` might not work on vectors.\n         simd_xor: Uint, Int => xor;\n+        simd_fmin: Float => vector_fmin;\n+        simd_fmax: Float => vector_fmax;\n     }\n \n     macro_rules! arith_unary {\n@@ -562,10 +824,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n-            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n-            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n-            _ => {\n+        let (signed, elem_width, elem_ty) =\n+            match *in_elem.kind() {\n+                ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n+                ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n+                _ => {\n                 return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n                     span,\n                     name,\n@@ -574,33 +837,78 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 });\n             }\n         };\n-        let builtin_name = match (signed, is_add, in_len, elem_width) {\n-            (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-            (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-            (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-            (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-            (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-            (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-            (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-            (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-            _ => unimplemented!(\n-                \"signed: {}, is_add: {}, in_len: {}, elem_width: {}\",\n-                signed,\n-                is_add,\n-                in_len,\n-                elem_width\n-            ),\n-        };\n-        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n-\n-        let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_param(0).to_rvalue().get_type();\n-        let param2_type = func.get_param(1).to_rvalue().get_type();\n-        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n-        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n-        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+\n+        let result =\n+            match (signed, is_add) {\n+                (false, true) => {\n+                    let res = lhs + rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+                    res | cmp\n+                },\n+                (true, true) => {\n+                    // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n+                    // TODO(antoyo): improve using conditional operators if possible.\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                },\n+                (false, false) => {\n+                    let res = lhs - rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+                    res & cmp\n+                },\n+                (true, false) => {\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): this uses the same algorithm from saturating add, but add the\n+                    // negative of the right operand. Find a proper subtraction algorithm.\n+                    let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n+\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                }\n+            };\n+\n+        return Ok(result);\n     }\n \n     macro_rules! arith_red {\n@@ -650,33 +958,50 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         add,\n         0.0 // TODO: Use this argument.\n     );\n-    arith_red!(simd_reduce_mul_unordered: BinaryOp::Mult, vector_reduce_fmul_fast, false, mul, 1.0);\n+    arith_red!(\n+        simd_reduce_mul_unordered: BinaryOp::Mult,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n+    );\n+    arith_red!(\n+        simd_reduce_add_ordered: BinaryOp::Plus,\n+        vector_reduce_fadd,\n+        true,\n+        add,\n+        0.0\n+    );\n+    arith_red!(\n+        simd_reduce_mul_ordered: BinaryOp::Mult,\n+        vector_reduce_fmul,\n+        true,\n+        mul,\n+        1.0\n+    );\n+\n \n     macro_rules! minmax_red {\n-        ($name:ident: $reduction:ident) => {\n+        ($name:ident: $int_red:ident, $float_red:ident) => {\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n                     InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n-                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n-                        Ok(bx.$reduction(args[0].immediate()))\n-                    }\n-                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n-                        span,\n-                        name,\n-                        in_ty,\n-                        elem_ty: in_elem,\n-                        ret_ty\n-                    }),\n+                    ty::Int(_) | ty::Uint(_) => Ok(bx.$int_red(args[0].immediate())),\n+                    ty::Float(_) => Ok(bx.$float_red(args[0].immediate())),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n     }\n \n-    minmax_red!(simd_reduce_min: vector_reduce_min);\n-    minmax_red!(simd_reduce_max: vector_reduce_max);\n+    minmax_red!(simd_reduce_min: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max: vector_reduce_max, vector_reduce_fmax);\n+    // TODO(sadlerap): revisit these intrinsics to generate more optimal reductions\n+    minmax_red!(simd_reduce_min_nanless: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max_nanless: vector_reduce_max, vector_reduce_fmax);\n \n     macro_rules! bitwise_red {\n         ($name:ident : $op:expr, $boolean:expr) => {\n@@ -699,15 +1024,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                         }),\n                     }\n \n-                    // boolean reductions operate on vectors of i1s:\n-                    let i1 = bx.type_i1();\n-                    let i1xn = bx.type_vector(i1, in_len as u64);\n-                    bx.trunc(args[0].immediate(), i1xn)\n+                    args[0].immediate()\n                 };\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.vector_reduce_op(input, $op);\n-                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                        Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n                     _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n                         span,\n@@ -723,6 +1045,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n \n     bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n     bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+    bitwise_red!(simd_reduce_xor: BinaryOp::BitwiseXor, false);\n+    bitwise_red!(simd_reduce_all: BinaryOp::BitwiseAnd, true);\n+    bitwise_red!(simd_reduce_any: BinaryOp::BitwiseOr, true);\n \n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "0b661505acc00c0c415f00793f63f1f24576648d", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,7 +1,7 @@\n /*\n  * TODO(antoyo): implement equality in libgccjit based on https://zpz.github.io/blog/overloading-equality-operator-in-cpp-class-hierarchy/ (for type equality?)\n  * TODO(antoyo): support #[inline] attributes.\n- * TODO(antoyo): support LTO (gcc's equivalent to Thin LTO is enabled by -fwhopr: https://stackoverflow.com/questions/64954525/does-gcc-have-thin-lto).\n+ * TODO(antoyo): support LTO (gcc's equivalent to Full LTO is -flto -flto-partition=one \u2014 https://documentation.suse.com/sbp/all/html/SBP-GCC-10/index.html).\n  *\n  * TODO(antoyo): remove the patches.\n  */\n@@ -23,6 +23,7 @@\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n+extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -43,6 +44,7 @@ mod abi;\n mod allocator;\n mod archive;\n mod asm;\n+mod attributes;\n mod back;\n mod base;\n mod builder;\n@@ -85,7 +87,7 @@ use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n use tempfile::TempDir;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n@@ -314,9 +316,12 @@ pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n             // Probably using the equivalent of __builtin_cpu_supports.\n+            // TODO(antoyo): maybe use whatever outputs the following command:\n+            // gcc -march=native -Q --help=target\n             #[cfg(feature=\"master\")]\n             {\n-                _feature.contains(\"sse\") || _feature.contains(\"avx\")\n+                // NOTE: the CPU in the CI doesn't support sse4a, so disable it to make the stdarch tests pass in the CI.\n+                (_feature.contains(\"sse\") || _feature.contains(\"avx\")) && !_feature.contains(\"avx512\") && !_feature.contains(\"sse4a\")\n             }\n             #[cfg(not(feature=\"master\"))]\n             {"}, {"sha": "c1f6340866cacc5edc6e13276f47f2fa4be140cd", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,38 +1,66 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{VarAttribute, FnAttribute};\n use rustc_codegen_ssa::traits::PreDefineMethods;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n-use rustc_span::def_id::DefId;\n \n+use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n+        #[cfg(feature=\"master\")]\n+        global.add_attribute(VarAttribute::Visibility(base::visibility_to_gcc(visibility)));\n \n-        // TODO(antoyo): set linkage and visibility.\n+        // TODO(antoyo): set linkage.\n         self.instances.borrow_mut().insert(instance, global);\n     }\n \n-    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         assert!(!instance.substs.needs_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        let decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n+        attributes::from_fn_attrs(self, decl, instance);\n+\n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != Linkage::Internal\n+            && linkage != Linkage::Private\n+            && self.tcx.is_compiler_builtins(LOCAL_CRATE)\n+        {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+        }\n+        else {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(base::visibility_to_gcc(visibility)));\n+        }\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above.\n+\n+        self.functions.borrow_mut().insert(symbol_name.to_string(), decl);\n+        self.function_instances.borrow_mut().insert(instance, unsafe { std::mem::transmute(decl) });\n     }\n }"}, {"sha": "daa661f35c4c108767b9bfde5476544944506b47", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryInto;\n-\n use gccjit::{RValue, Struct, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, TypeMembershipMethods};\n use rustc_codegen_ssa::common::TypeKind;\n@@ -202,23 +200,17 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         value.get_type()\n     }\n \n-    fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n-        if let Some(struct_type) = ty.is_struct() {\n+    fn type_array(&self, ty: Type<'gcc>, len: u64) -> Type<'gcc> {\n+        // TODO: remove this as well?\n+        /*if let Some(struct_type) = ty.is_struct() {\n             if struct_type.get_field_count() == 0 {\n                 // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n                 // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n                 // zero for ZSTs.\n                 // FIXME(antoyo): fix gccjit API.\n                 len = 0;\n             }\n-        }\n-\n-        // NOTE: see note above. Some other test uses usize::MAX.\n-        if len == u64::MAX {\n-            len = 0;\n-        }\n-\n-        let len: i32 = len.try_into().expect(\"array len\");\n+        }*/\n \n         self.context.new_array_type(None, ty, len)\n     }\n@@ -247,10 +239,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n-\n-    pub fn type_bool(&self) -> Type<'gcc> {\n-        self.context.new_type::<bool>()\n-    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {\n@@ -273,7 +261,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n         result.push(cx.type_padding_filler(padding, padding_align));\n \n-        result.push(field.gcc_type(cx, !field.ty.is_any_ptr())); // FIXME(antoyo): might need to check if the type is inside another, like Box<Type>.\n+        result.push(field.gcc_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }"}, {"sha": "5df8c1a209db2e8f9301edb488379200f66832a9", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n+use rustc_target::abi::{self, Abi, Align, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n \n use crate::abi::{FnAbiGccExt, GccType};\n@@ -50,11 +50,25 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+        self.layout_of(ty).align.abi\n+    }\n+}\n+\n+fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n             let element = layout.scalar_gcc_type_at(cx, element, Size::ZERO);\n+            let element =\n+                // NOTE: gcc doesn't allow pointer types in vectors.\n+                if element.get_pointee().is_some() {\n+                    cx.usize_type\n+                }\n+                else {\n+                    element\n+                };\n             return cx.context.new_vector_type(element, count);\n         },\n         Abi::ScalarPair(..) => {\n@@ -114,7 +128,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n                 },\n             }\n         }\n-        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx, true), count),\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx), count),\n         FieldsShape::Arbitrary { .. } =>\n             match name {\n                 None => {\n@@ -133,7 +147,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n pub trait LayoutGccExt<'tcx> {\n     fn is_gcc_immediate(&self) -> bool;\n     fn is_gcc_scalar_pair(&self) -> bool;\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc>;\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc>;\n     fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc>;\n@@ -168,8 +182,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    //TODO(antoyo): do we still need the set_fields parameter?\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc> {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n         if let Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -179,10 +192,10 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             let ty =\n                 match *self.ty.kind() {\n                     ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx, set_fields))\n+                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx))\n                     }\n                     ty::Adt(def, _) if def.is_box() => {\n-                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n+                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx))\n                     }\n                     ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n                     _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n@@ -199,13 +212,6 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             };\n         let cached_type = cx.types.borrow().get(&(self.ty, variant_index)).cloned();\n         if let Some(ty) = cached_type {\n-            let type_to_set_fields = cx.types_with_fields_to_set.borrow_mut().remove(&ty);\n-            if let Some((struct_type, layout)) = type_to_set_fields {\n-                // Since we might be trying to generate a type containing another type which is not\n-                // completely generated yet, we deferred setting the fields until now.\n-                let (fields, packed) = struct_fields(cx, layout);\n-                cx.set_struct_body(struct_type, &fields, packed);\n-            }\n             return ty;\n         }\n \n@@ -222,17 +228,17 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 if let Some(v) = variant_index {\n                     layout = layout.for_variant(cx, v);\n                 }\n-                layout.gcc_type(cx, true)\n+                layout.gcc_type(cx)\n             }\n             else {\n                 uncached_gcc_type(cx, *self, &mut defer)\n             };\n \n         cx.types.borrow_mut().insert((self.ty, variant_index), ty);\n \n-        if let Some((ty, layout)) = defer {\n+        if let Some((deferred_ty, layout)) = defer {\n             let (fields, packed) = struct_fields(cx, layout);\n-            cx.set_struct_body(ty, &fields, packed);\n+            cx.set_struct_body(deferred_ty, &fields, packed);\n         }\n \n         ty\n@@ -244,7 +250,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 return cx.type_i1();\n             }\n         }\n-        self.gcc_type(cx, true)\n+        self.gcc_type(cx)\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n@@ -273,7 +279,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n-                return self.field(cx, index).gcc_type(cx, true);\n+                return self.field(cx, index).gcc_type(cx);\n             }\n             // only wide pointer boxes are handled as pointers\n             // thin pointer boxes with scalar allocators are handled by the general logic below\n@@ -343,7 +349,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n \n impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n-        layout.gcc_type(self, true)\n+        layout.gcc_type(self)\n     }\n \n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {"}, {"sha": "6139892aefca7d2d42bf35aad2bb9de2726e7f40", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 184, "deletions": 56, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -17,17 +17,20 @@ export LIBRARY_PATH=\"$GCC_PATH\"\n flags=\n gcc_master_branch=1\n channel=\"debug\"\n-func=all\n+funcs=()\n build_only=0\n+nb_parts=0\n+current_part=0\n \n while [[ $# -gt 0 ]]; do\n     case $1 in\n         --release)\n             codegen_channel=release\n+            channel=\"release\"\n             shift\n             ;;\n         --release-sysroot)\n-            sysroot_channel=release\n+            sysroot_channel=\"--release\"\n             shift\n             ;;\n         --no-default-features)\n@@ -40,43 +43,83 @@ while [[ $# -gt 0 ]]; do\n             flags=\"$flags --features $1\"\n             shift\n             ;;\n-        --release)\n-            channel=\"release\"\n+        \"--test-rustc\")\n+            funcs+=(test_rustc)\n             shift\n             ;;\n-        \"--test-rustc\")\n-            func=test_rustc\n+        \"--test-successful-rustc\")\n+            funcs+=(test_successful_rustc)\n+            shift\n+            ;;\n+        \"--test-failing-rustc\")\n+            funcs+=(test_failing_rustc)\n             shift\n             ;;\n \n         \"--test-libcore\")\n-            func=test_libcore\n+            funcs+=(test_libcore)\n             shift\n             ;;\n \n         \"--clean-ui-tests\")\n-            func=clean_ui_tests\n+            funcs+=(clean_ui_tests)\n+            shift\n+            ;;\n+        \"--clean\")\n+            funcs+=(clean)\n             shift\n             ;;\n \n         \"--std-tests\")\n-            func=std_tests\n+            funcs+=(std_tests)\n+            shift\n+            ;;\n+\n+        \"--asm-tests\")\n+            funcs+=(asm_tests)\n             shift\n             ;;\n \n         \"--extended-tests\")\n-            func=extended_sysroot_tests\n+            funcs+=(extended_sysroot_tests)\n+            shift\n+            ;;\n+        \"--extended-rand-tests\")\n+            funcs+=(extended_rand_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-example-tests\")\n+            funcs+=(extended_regex_example_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-tests\")\n+            funcs+=(extended_regex_tests)\n+            shift\n+            ;;\n+\n+        \"--mini-tests\")\n+            funcs+=(mini_tests)\n             shift\n             ;;\n \n         \"--build-sysroot\")\n-            func=build_sysroot\n+            funcs+=(build_sysroot)\n             shift\n             ;;\n         \"--build\")\n             build_only=1\n             shift\n             ;;\n+        \"--nb-parts\")\n+            shift\n+            nb_parts=$1\n+            shift\n+            ;;\n+        \"--current-part\")\n+            shift\n+            current_part=$1\n+            shift\n+            ;;\n         *)\n             echo \"Unknown option $1\"\n             exit 1\n@@ -87,14 +130,14 @@ done\n if [[ $channel == \"release\" ]]; then\n     export CHANNEL='release'\n     CARGO_INCREMENTAL=1 cargo rustc --release $flags\n-    shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n     cargo rustc $flags\n fi\n \n if (( $build_only == 1 )); then\n+    echo \"Since it's 'build-only', exiting...\"\n     exit\n fi\n \n@@ -119,7 +162,7 @@ function mini_tests() {\n \n function build_sysroot() {\n     echo \"[BUILD] sysroot\"\n-    time ./build_sysroot/build_sysroot.sh\n+    time ./build_sysroot/build_sysroot.sh $sysroot_channel\n }\n \n function std_tests() {\n@@ -148,17 +191,57 @@ function std_tests() {\n     $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n \n     echo \"[AOT] subslice-patterns-const-eval\"\n-    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n \n     echo \"[AOT] track-caller-attribute\"\n-    $RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/track-caller-attribute.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/track-caller-attribute\n \n     echo \"[BUILD] mod_bench\"\n     $RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n }\n \n+function setup_rustc() {\n+    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n+\n+    git clone https://github.com/rust-lang/rust.git || true\n+    cd rust\n+    git fetch\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n+    export RUSTFLAGS=\n+\n+    rm config.toml || true\n+\n+    cat > config.toml <<EOF\n+[rust]\n+codegen-backends = []\n+deny-warnings = false\n+\n+[build]\n+cargo = \"$(which cargo)\"\n+local-rebuild = true\n+rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n+\n+[target.x86_64-unknown-linux-gnu]\n+llvm-filecheck = \"`which FileCheck-10 || which FileCheck-11 || which FileCheck-12 || which FileCheck-13 || which FileCheck-14`\"\n+\n+[llvm]\n+download-ci-llvm = false\n+EOF\n+\n+    rustc -V | cut -d' ' -f3 | tr -d '('\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n+}\n+\n+function asm_tests() {\n+    setup_rustc\n+\n+    echo \"[TEST] rustc test suite\"\n+    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/assembly/asm --rustc-args \"$RUSTC_ARGS\"\n+}\n+\n # FIXME(antoyo): linker gives multiple definitions error on Linux\n #echo \"[BUILD] sysroot in release mode\"\n #./build_sysroot/build_sysroot.sh --release\n@@ -187,7 +270,7 @@ function test_libcore() {\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n-function extended_sysroot_tests() {\n+function extended_rand_tests() {\n     if (( $gcc_master_branch == 0 )); then\n         return\n     fi\n@@ -197,17 +280,12 @@ function extended_sysroot_tests() {\n     echo \"[TEST] rust-random/rand\"\n     ../cargo.sh test --workspace\n     popd\n+}\n \n-    #pushd simple-raytracer\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n-    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n-    #\"../cargo.sh build\"\n-\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-    #cp ./target/debug/main ./raytracer_cg_gcc\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n-    #popd\n+function extended_regex_example_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n@@ -219,73 +297,123 @@ function extended_sysroot_tests() {\n         | ../cargo.sh run --example shootout-regex-dna \\\n         | grep -v \"Spawned thread\" > res.txt\n     diff -u res.txt examples/regexdna-output.txt\n+    popd\n+}\n+\n+function extended_regex_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n+    pushd regex\n     echo \"[TEST] rust-lang/regex tests\"\n+    export CG_RUSTFLAGS=\"--cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n     ../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n     popd\n }\n \n-function test_rustc() {\n-    echo\n-    echo \"[TEST] rust-lang/rust\"\n-\n-    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n-\n-    git clone https://github.com/rust-lang/rust.git || true\n-    cd rust\n-    git fetch\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n-    export RUSTFLAGS=\n-\n-    git apply ../rustc_patches/compile_test.patch || true\n+function extended_sysroot_tests() {\n+    #pushd simple-raytracer\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n+    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    #\"../cargo.sh build\"\n \n-    rm config.toml || true\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/debug/main ./raytracer_cg_gcc\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n+    #popd\n \n-    cat > config.toml <<EOF\n-[rust]\n-codegen-backends = []\n-deny-warnings = false\n+    extended_rand_tests\n+    extended_regex_example_tests\n+    extended_regex_tests\n+}\n \n-[build]\n-cargo = \"$(which cargo)\"\n-local-rebuild = true\n-rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n-EOF\n+function test_rustc() {\n+    echo\n+    echo \"[TEST] rust-lang/rust\"\n \n-    rustc -V | cut -d' ' -f3 | tr -d '('\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n+    setup_rustc\n \n     for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" tests/ui); do\n       rm $test\n     done\n \n     git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r tests/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n-    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" tests/ui); do\n+    rm -r tests/ui/{abi*,extern/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n+    rm tests/ui/mir/mir_heavy_promoted.rs # this tests is oom-killed in the CI.\n+    for test in $(rg --files-with-matches \"thread|lto\" tests/ui); do\n       rm $test\n     done\n+    git checkout tests/ui/lto/auxiliary/dylib.rs\n     git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n     git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    git checkout tests/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs\n+\n+    RUSTC_ARGS=\"$TEST_FLAGS -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot\"\n+\n+    if [ $# -eq 0 ]; then\n+        # No argument supplied to the function. Doing nothing.\n+        echo \"No argument provided. Keeping all UI tests\"\n+    elif [ $1 = \"0\" ]; then\n+        # Removing the failing tests.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' rm\n+    else\n+        # Removing all tests.\n+        find tests/ui -type f -name '*.rs' -not -path '*/auxiliary/*' -delete\n+        # Putting back only the failing ones.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' git checkout --\n+    fi\n \n-    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    if [ $nb_parts -gt 0 ]; then\n+        echo \"Splitting ui_test into $nb_parts parts (and running part $current_part)\"\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" > ui_tests\n+        # To ensure it'll be always the same sub files, we sort the content.\n+        sort ui_tests -o ui_tests\n+        count=$((`wc -l < ui_tests` / $nb_parts))\n+        # We increment the number of tests by one because if this is an odd number, we would skip\n+        # one test.\n+        count=$((count + 1))\n+        split -d -l $count -a 1 ui_tests ui_tests.split\n+        # Removing all tests.\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" -delete\n+        # Putting back only the ones we want to test.\n+        xargs -a \"ui_tests.split$current_part\" -d'\\n' git checkout --\n+    fi\n \n     echo \"[TEST] rustc test suite\"\n     COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/ui/ --rustc-args \"$RUSTC_ARGS\"\n }\n \n+function test_failing_rustc() {\n+    test_rustc \"1\"\n+}\n+\n+function test_successful_rustc() {\n+    test_rustc \"0\"\n+}\n+\n function clean_ui_tests() {\n-    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n+    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -delete\n }\n \n function all() {\n     clean\n     mini_tests\n     build_sysroot\n     std_tests\n+    #asm_tests\n     test_libcore\n     extended_sysroot_tests\n     test_rustc\n }\n \n-$func\n+if [ ${#funcs[@]} -eq 0 ]; then\n+    echo \"No command passed, running '--all'...\"\n+    all\n+else\n+    for t in ${funcs[@]}; do\n+        $t\n+    done\n+fi"}, {"sha": "06de26f7efc9f8c8497e79e4d24e911ed6dbe80c", "filename": "compiler/rustc_codegen_gcc/tests/lang_tests_common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -46,11 +46,15 @@ pub fn main_inner(profile: Profile) {\n                 &format!(\"-Zcodegen-backend={}/target/debug/librustc_codegen_gcc.so\", current_dir),\n                 \"--sysroot\", &format!(\"{}/build_sysroot/sysroot/\", current_dir),\n                 \"-Zno-parallel-llvm\",\n-                \"-C\", \"panic=abort\",\n                 \"-C\", \"link-arg=-lc\",\n                 \"-o\", exe.to_str().expect(\"to_str\"),\n                 path.to_str().expect(\"to_str\"),\n             ]);\n+            if let Some(flags) = option_env!(\"TEST_FLAGS\") {\n+                for flag in flags.split_whitespace() {\n+                    compiler.arg(&flag);\n+                }\n+            }\n             match profile {\n                 Profile::Debug => {}\n                 Profile::Release => {"}, {"sha": "25041d93e748a6feb2acbd7c14aff9011bb1e7a4", "filename": "compiler/rustc_codegen_gcc/tests/run/abort1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "e7443c8dbe5b2f5574784f0b85ea54644904e082", "filename": "compiler/rustc_codegen_gcc/tests/run/abort2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "49b28d98f2fecaa4d0bb0f6935cf460ca441f012", "filename": "compiler/rustc_codegen_gcc/tests/run/array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -79,7 +79,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -105,6 +105,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "427c1a250339749f41627b0d6e7dd40f6886cf7a", "filename": "compiler/rustc_codegen_gcc/tests/run/assign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -57,14 +57,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "8daa681abf7dac19c0838b9717890a8c1119094e", "filename": "compiler/rustc_codegen_gcc/tests/run/closure.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -97,10 +97,14 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -114,7 +118,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -123,7 +127,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n@@ -177,7 +181,7 @@ impl Add for isize {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();"}, {"sha": "b7a13081deae0df4babd931ae1f968ff3cbfe05e", "filename": "compiler/rustc_codegen_gcc/tests/run/condition.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -82,7 +82,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -108,6 +108,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "8a196f774c82bcd6cb5930cee4a823124513db07", "filename": "compiler/rustc_codegen_gcc/tests/run/fun_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "bfe73c38435a31ec68ccdeff5bd861b392cec3d7", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -3,22 +3,14 @@\n // Run-time:\n //   status: 0\n \n-#![feature(const_black_box, core_intrinsics, start)]\n-\n-#![no_std]\n-\n-#[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    core::intrinsics::abort();\n-}\n+#![feature(const_black_box)]\n \n /*\n  * Code\n  */\n \n-#[start]\n-fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    use core::hint::black_box;\n+fn main() {\n+    use std::hint::black_box;\n \n     macro_rules! check {\n         ($ty:ty, $expr:expr) => {\n@@ -335,6 +327,4 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n         const VAL5: T = 73236519889708027473620326106273939584_i128;\n         check_ops128!();\n     }\n-\n-    0\n }"}, {"sha": "c3fcb3c0a2a069ac97b36066be3f3abe9fab5f0d", "filename": "compiler/rustc_codegen_gcc/tests/run/int_overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -55,14 +55,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         // Panicking is expected iff overflow checking is enabled.\n         #[cfg(debug_assertions)]"}, {"sha": "2a2ea8b8bf0ab0152cb618ce84fd1f3194292891", "filename": "compiler/rustc_codegen_gcc/tests/run/mut_ref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -59,14 +59,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "67b9f241dbbb3d06bbba2c3571824a56d54de35a", "filename": "compiler/rustc_codegen_gcc/tests/run/operations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -65,14 +65,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "da8a8295d564cc31012f6baac799d5180ac644a4", "filename": "compiler/rustc_codegen_gcc/tests/run/ptr_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "96f1c4792e58fa199f794bfd9f6565691bc301da", "filename": "compiler/rustc_codegen_gcc/tests/run/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -102,6 +102,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "19201f1df2667ca9a6e21450690415865b85f63e", "filename": "compiler/rustc_codegen_gcc/tests/run/static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -45,6 +45,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "c09fb3c759f3b10189ac2780096a6731d43ad974", "filename": "compiler/rustc_codegen_gcc/tools/check_intrinsics_duplicates.py", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -0,0 +1,67 @@\n+import sys\n+\n+\n+def check_duplicates():\n+    auto_content = \"\"\n+    manual_content = \"\"\n+\n+    with open(\"src/intrinsic/llvm.rs\", \"r\", encoding=\"utf8\") as f:\n+        manual_content = f.read()\n+    with open(\"src/intrinsic/archs.rs\", \"r\", encoding=\"utf8\") as f:\n+        auto_content = f.read()\n+\n+    intrinsics_map = {}\n+    for line in auto_content.splitlines():\n+        line = line.strip()\n+        if not line.startswith('\"'):\n+            continue\n+        parts = line.split('\"')\n+        if len(parts) != 5:\n+            continue\n+        intrinsics_map[parts[1]] = parts[3]\n+\n+    if len(intrinsics_map) == 0:\n+        print(\"No intrinsics found in auto code... Aborting.\")\n+        return 1\n+    print(\"Found {} intrinsics in auto code\".format(len(intrinsics_map)))\n+    errors = []\n+    lines = manual_content.splitlines()\n+    pos = 0\n+    found = 0\n+    while pos < len(lines):\n+        line = lines[pos].strip()\n+        # This is our marker.\n+        if line == \"let gcc_name = match name {\":\n+            while pos < len(lines):\n+                line = lines[pos].strip()\n+                pos += 1\n+                if line == \"};\":\n+                    # We're done!\n+                    if found == 0:\n+                        print(\"No intrinsics found in manual code even though we found the \"\n+                            \"marker... Aborting...\")\n+                        return 1\n+                    for error in errors:\n+                        print(\"ERROR => {}\".format(error))\n+                    return 1 if len(errors) != 0 else 0\n+                parts = line.split('\"')\n+                if len(parts) != 5:\n+                    continue\n+                found += 1\n+                if parts[1] in intrinsics_map:\n+                    if parts[3] != intrinsics_map[parts[1]]:\n+                        print(\"Same intrinsics (`{}` at line {}) but different GCC \"\n+                            \"translations: `{}` != `{}`\".format(\n+                                parts[1], pos, intrinsics_map[parts[1]], parts[3]))\n+                    else:\n+                        errors.append(\"Duplicated intrinsics: `{}` at line {}. Please remove it \"\n+                            \" from manual code\".format(parts[1], pos))\n+            # Weird but whatever...\n+            return 1 if len(errors) != 0 else 0\n+        pos += 1\n+    print(\"No intrinsics found in manual code... Aborting\")\n+    return 1\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(check_duplicates())"}, {"sha": "6188924b0d50a52ef4ac4ca30ee28ebd02eac216", "filename": "compiler/rustc_codegen_gcc/tools/generate_intrinsics.py", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -13,7 +13,7 @@ def run_command(command, cwd=None):\n         sys.exit(1)\n \n \n-def clone_repository(repo_name, path, repo_url, sub_path=None):\n+def clone_repository(repo_name, path, repo_url, sub_paths=None):\n     if os.path.exists(path):\n         while True:\n             choice = input(\"There is already a `{}` folder, do you want to update it? [y/N]\".format(path))\n@@ -27,69 +27,58 @@ def clone_repository(repo_name, path, repo_url, sub_path=None):\n             else:\n                 print(\"Didn't understand answer...\")\n     print(\"Cloning {} repository...\".format(repo_name))\n-    if sub_path is None:\n+    if sub_paths is None:\n         run_command([\"git\", \"clone\", repo_url, \"--depth\", \"1\", path])\n     else:\n         run_command([\"git\", \"clone\", repo_url, \"--filter=tree:0\", \"--no-checkout\", path])\n         run_command([\"git\", \"sparse-checkout\", \"init\"], cwd=path)\n-        run_command([\"git\", \"sparse-checkout\", \"set\", \"add\", sub_path], cwd=path)\n+        run_command([\"git\", \"sparse-checkout\", \"set\", *sub_paths], cwd=path)\n         run_command([\"git\", \"checkout\"], cwd=path)\n \n \n def append_intrinsic(array, intrinsic_name, translation):\n     array.append((intrinsic_name, translation))\n \n \n-def extract_instrinsics(intrinsics, file):\n-    print(\"Extracting intrinsics from `{}`...\".format(file))\n-    with open(file, \"r\", encoding=\"utf8\") as f:\n-        content = f.read()\n+def convert_to_string(content):\n+    if content.__class__.__name__ == 'bytes':\n+        return content.decode('utf-8')\n+    return content\n \n-    lines = content.splitlines()\n+\n+def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n+    p = subprocess.Popen(\n+        [\"llvm-tblgen\", \"llvm/IR/Intrinsics.td\"],\n+        cwd=os.path.join(llvm_path, \"llvm/include\"),\n+        stdout=subprocess.PIPE)\n+    output, err = p.communicate()\n+    lines = convert_to_string(output).splitlines()\n     pos = 0\n-    current_arch = None\n     while pos < len(lines):\n-        line = lines[pos].strip()\n-        if line.startswith(\"let TargetPrefix =\"):\n-            current_arch = line.split('\"')[1].strip()\n-            if len(current_arch) == 0:\n-                current_arch = None\n-        elif current_arch is None:\n-            pass\n-        elif line == \"}\":\n-            current_arch = None\n-        elif line.startswith(\"def \"):\n-            content = \"\"\n-            while not content.endswith(\";\") and not content.endswith(\"}\") and pos < len(lines):\n-                line = lines[pos].split(\" // \")[0].strip()\n-                content += line\n-                pos += 1\n-            entries = re.findall('GCCBuiltin<\"(\\\\w+)\">', content)\n-            if len(entries) > 0:\n-                intrinsic = content.split(\"def \")[1].strip().split(\":\")[0].strip()\n-                intrinsic = intrinsic.split(\"_\")\n-                if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n-                    continue\n-                intrinsic[0] = \"llvm\"\n-                intrinsic = \".\".join(intrinsic)\n-                if current_arch not in intrinsics:\n-                    intrinsics[current_arch] = []\n-                for entry in entries:\n-                    append_intrinsic(intrinsics[current_arch], intrinsic, entry)\n+        line = lines[pos]\n+        if not line.startswith(\"def \"):\n+            pos += 1\n             continue\n-        pos += 1\n-        continue\n-    print(\"Done!\")\n-\n-\n-def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n-    files = []\n-    intrinsics_path = os.path.join(llvm_path, \"llvm/include/llvm/IR\")\n-    for (dirpath, dirnames, filenames) in walk(intrinsics_path):\n-        files.extend([os.path.join(intrinsics_path, f) for f in filenames if f.endswith(\".td\")])\n-\n-    for file in files:\n-        extract_instrinsics(intrinsics, file)\n+        intrinsic = line.split(\" \")[1].strip()\n+        content = line\n+        while pos < len(lines):\n+            line = lines[pos].split(\" // \")[0].strip()\n+            content += line\n+            pos += 1\n+            if line == \"}\":\n+                break\n+        entries = re.findall('string ClangBuiltinName = \"(\\\\w+)\";', content)\n+        current_arch = re.findall('string TargetPrefix = \"(\\\\w+)\";', content)\n+        if len(entries) == 1 and len(current_arch) == 1:\n+            current_arch = current_arch[0]\n+            intrinsic = intrinsic.split(\"_\")\n+            if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n+                continue\n+            intrinsic[0] = \"llvm\"\n+            intrinsic = \".\".join(intrinsic)\n+            if current_arch not in intrinsics:\n+                intrinsics[current_arch] = []\n+            append_intrinsic(intrinsics[current_arch], intrinsic, entries[0])\n \n \n def append_translation(json_data, p, array):\n@@ -193,6 +182,8 @@ def update_intrinsics(llvm_path, llvmint, llvmint2):\n             for entry in intrinsics[arch]:\n                 if entry[2] == True: # if it is a duplicate\n                     out.write('    // [DUPLICATE]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+                elif \"_round_mask\" in entry[1]:\n+                    out.write('    // [INVALID CONVERSION]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n                 else:\n                     out.write('    \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n         out.write('    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\\n')\n@@ -219,7 +210,7 @@ def main():\n         \"llvm-project\",\n         llvm_path,\n         \"https://github.com/llvm/llvm-project\",\n-        sub_path=\"llvm/include/llvm/IR\",\n+        sub_paths=[\"llvm/include/llvm/IR\", \"llvm/include/llvm/CodeGen/\"],\n     )\n     clone_repository(\n         \"llvmint\","}, {"sha": "a7ba2f8b69533d8a7f6048671845ee78f77a8763", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -36,3 +36,5 @@ smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n tempfile = \"3.2.0\"\n+serde = { version = \"1\", features = [ \"derive\" ]}\n+serde_json = \"1\""}, {"sha": "e5df417370bb9030abf8ad18fe765b4bc0f265fc", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_codegen_llvm/locales/en-US.ftl"}, {"sha": "a570f2af0f0e5dda96addff18fbf11700dfd6f02", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -189,6 +189,15 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                 path.push(lib_name);\n                 path\n             };\n+            // dlltool target architecture args from:\n+            // https://github.com/llvm/llvm-project-release-prs/blob/llvmorg-15.0.6/llvm/lib/ToolDrivers/llvm-dlltool/DlltoolDriver.cpp#L69\n+            let (dlltool_target_arch, dlltool_target_bitness) = match sess.target.arch.as_ref() {\n+                \"x86_64\" => (\"i386:x86-64\", \"--64\"),\n+                \"x86\" => (\"i386\", \"--32\"),\n+                \"aarch64\" => (\"arm64\", \"--64\"),\n+                \"arm\" => (\"arm\", \"--32\"),\n+                _ => panic!(\"unsupported arch {}\", sess.target.arch),\n+            };\n             let result = std::process::Command::new(dlltool)\n                 .args([\n                     \"-d\",\n@@ -197,6 +206,10 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n                     lib_name,\n                     \"-l\",\n                     output_path.to_str().unwrap(),\n+                    \"-m\",\n+                    dlltool_target_arch,\n+                    \"-f\",\n+                    dlltool_target_bitness,\n                     \"--no-leading-underscore\",\n                     \"--temp-prefix\",\n                     temp_prefix.to_str().unwrap(),\n@@ -422,24 +435,22 @@ fn find_binutils_dlltool(sess: &Session) -> OsString {\n         return dlltool_path.clone().into_os_string();\n     }\n \n-    let mut tool_name: OsString = if sess.host.arch != sess.target.arch {\n-        // We are cross-compiling, so we need the tool with the prefix matching our target\n-        if sess.target.arch == \"x86\" {\n-            \"i686-w64-mingw32-dlltool\"\n-        } else {\n-            \"x86_64-w64-mingw32-dlltool\"\n-        }\n+    let tool_name: OsString = if sess.host.options.is_like_windows {\n+        // If we're compiling on Windows, always use \"dlltool.exe\".\n+        \"dlltool.exe\"\n     } else {\n-        // We are not cross-compiling, so we just want `dlltool`\n-        \"dlltool\"\n+        // On other platforms, use the architecture-specific name.\n+        match sess.target.arch.as_ref() {\n+            \"x86_64\" => \"x86_64-w64-mingw32-dlltool\",\n+            \"x86\" => \"i686-w64-mingw32-dlltool\",\n+            \"aarch64\" => \"aarch64-w64-mingw32-dlltool\",\n+\n+            // For non-standard architectures (e.g., aarch32) fallback to \"dlltool\".\n+            _ => \"dlltool\",\n+        }\n     }\n     .into();\n \n-    if sess.host.options.is_like_windows {\n-        // If we're compiling on Windows, add the .exe suffix\n-        tool_name.push(\".exe\");\n-    }\n-\n     // NOTE: it's not clear how useful it is to explicitly search PATH.\n     for dir in env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()) {\n         let full_path = dir.join(&tool_name);"}, {"sha": "a4ae1b01e869d48428d5af05b75df55bc1647d71", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -761,6 +761,7 @@ pub(crate) unsafe fn codegen(\n             EmitObj::None => {}\n         }\n \n+        record_llvm_cgu_instructions_stats(&cgcx.prof, llmod);\n         drop(handlers);\n     }\n \n@@ -974,3 +975,23 @@ fn record_artifact_size(\n         self_profiler_ref.artifact_size(artifact_kind, artifact_name.to_string_lossy(), file_size);\n     }\n }\n+\n+fn record_llvm_cgu_instructions_stats(prof: &SelfProfilerRef, llmod: &llvm::Module) {\n+    if !prof.enabled() {\n+        return;\n+    }\n+\n+    let raw_stats =\n+        llvm::build_string(|s| unsafe { llvm::LLVMRustModuleInstructionStats(&llmod, s) })\n+            .expect(\"cannot get module instruction stats\");\n+\n+    #[derive(serde::Deserialize)]\n+    struct InstructionsStats {\n+        module: String,\n+        total: u64,\n+    }\n+\n+    let InstructionsStats { module, total } =\n+        serde_json::from_str(&raw_stats).expect(\"cannot parse llvm cgu instructions stats\");\n+    prof.artifact_size(\"cgu_instructions\", module, total);\n+}"}, {"sha": "580451ba26546ebf9c2cd6e8484abb26353f12b5", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -990,7 +990,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn resume(&mut self, exn0: &'ll Value, exn1: &'ll Value) {\n         let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n-        let mut exn = self.const_undef(ty);\n+        let mut exn = self.const_poison(ty);\n         exn = self.insert_value(exn, exn0, 0);\n         exn = self.insert_value(exn, exn1, 1);\n         unsafe {"}, {"sha": "efa0c13226ecffe4f7ac48b41709a222c3288f72", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -10,6 +10,7 @@ use crate::value::Value;\n use rustc_ast::Mutability;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::DefId;\n use rustc_middle::bug;\n use rustc_middle::mir::interpret::{ConstAllocation, GlobalAlloc, Scalar};\n@@ -129,6 +130,10 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe { llvm::LLVMGetUndef(t) }\n     }\n \n+    fn const_poison(&self, t: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMGetPoison(t) }\n+    }\n+\n     fn const_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n         unsafe { llvm::LLVMConstInt(t, i as u64, True) }\n     }\n@@ -252,8 +257,13 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                             Mutability::Mut => self.static_addr_of_mut(init, alloc.align, None),\n                             _ => self.static_addr_of(init, alloc.align, None),\n                         };\n-                        if !self.sess().fewer_names() {\n-                            llvm::set_value_name(value, format!(\"{:?}\", alloc_id).as_bytes());\n+                        if !self.sess().fewer_names() && llvm::get_value_name(value).is_empty() {\n+                            let hash = self.tcx.with_stable_hashing_context(|mut hcx| {\n+                                let mut hasher = StableHasher::new();\n+                                alloc.hash_stable(&mut hcx, &mut hasher);\n+                                hasher.finish::<u128>()\n+                            });\n+                            llvm::set_value_name(value, format!(\"alloc_{hash:032x}\").as_bytes());\n                         }\n                         (value, AddressSpace::DATA)\n                     }"}, {"sha": "f0d729d4779c6dd5bd6c858327f72313b468d885", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -520,14 +520,9 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n         let llfn = match tcx.lang_items().eh_personality() {\n             Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    tcx.intern_substs(&[]),\n-                )\n-                .unwrap()\n-                .unwrap(),\n+                ty::Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, ty::List::empty())\n+                    .unwrap()\n+                    .unwrap(),\n             ),\n             _ => {\n                 let name = if wants_msvc_seh(self.sess()) {\n@@ -740,9 +735,13 @@ impl<'ll> CodegenCx<'ll, '_> {\n \n         ifn!(\"llvm.copysign.f32\", fn(t_f32, t_f32) -> t_f32);\n         ifn!(\"llvm.copysign.f64\", fn(t_f64, t_f64) -> t_f64);\n+\n         ifn!(\"llvm.round.f32\", fn(t_f32) -> t_f32);\n         ifn!(\"llvm.round.f64\", fn(t_f64) -> t_f64);\n \n+        ifn!(\"llvm.roundeven.f32\", fn(t_f32) -> t_f32);\n+        ifn!(\"llvm.roundeven.f64\", fn(t_f64) -> t_f64);\n+\n         ifn!(\"llvm.rint.f32\", fn(t_f32) -> t_f32);\n         ifn!(\"llvm.rint.f64\", fn(t_f64) -> t_f64);\n         ifn!(\"llvm.nearbyint.f32\", fn(t_f32) -> t_f32);"}, {"sha": "ff2b005d757672cf666734e0890cba1c5abc8e40", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -5,12 +5,12 @@ use crate::llvm;\n use crate::builder::Builder;\n use crate::common::CodegenCx;\n use crate::value::Value;\n+use rustc_ast::attr;\n use rustc_codegen_ssa::base::collect_debugger_visualizers_transitive;\n use rustc_codegen_ssa::traits::*;\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::bug;\n use rustc_session::config::{CrateType, DebugInfo};\n-\n use rustc_span::symbol::sym;\n use rustc_span::DebuggerVisualizerType;\n \n@@ -87,7 +87,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global<'ll>(cx: &CodegenCx<'ll, '\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n-        cx.tcx.sess.contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+        attr::contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     // To ensure the section `__rustc_debug_gdb_scripts_section__` will not create\n     // ODR violations at link time, this section will not be emitted for rlibs since"}, {"sha": "978141917c6b0cac9882ab22b0d0445084de4fd8", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -438,6 +438,7 @@ fn build_enum_variant_member_di_node<'ll, 'tcx>(\n ///         DW_TAG_structure_type            (type of variant 1)\n ///         DW_TAG_structure_type            (type of variant 2)\n ///         DW_TAG_structure_type            (type of variant 3)\n+/// ```\n struct VariantMemberInfo<'a, 'll> {\n     variant_index: VariantIdx,\n     variant_name: Cow<'a, str>,"}, {"sha": "6bcd3e5bf58f3030e0f164681fc2780df3c8e7d1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Futils.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -5,7 +5,7 @@ use super::CodegenUnitDebugContext;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::layout::{HasParamEnv, LayoutOf};\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_middle::ty::{self, Ty};\n use trace;\n \n use crate::common::CodegenCx;"}, {"sha": "012e25884ca99a1a99c04fcd00f201d3cbd096a8", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -71,6 +71,8 @@ fn get_simple_intrinsic<'ll>(\n         sym::roundf32 => \"llvm.round.f32\",\n         sym::roundf64 => \"llvm.round.f64\",\n         sym::ptr_mask => \"llvm.ptrmask\",\n+        sym::roundevenf32 => \"llvm.roundeven.f32\",\n+        sym::roundevenf64 => \"llvm.roundeven.f64\",\n         _ => return None,\n     };\n     Some(cx.get_intrinsic(llvm_name))\n@@ -376,7 +378,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 }\n             }\n \n-            _ => bug!(\"unknown intrinsic '{}'\", name),\n+            _ => bug!(\"unknown intrinsic '{}' -- should it have been lowered earlier?\", name),\n         };\n \n         if !fn_abi.ret.is_ignore() {"}, {"sha": "e5bae009ed64b9651b927d08988b406e7e54987a", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -84,7 +84,7 @@ mod type_of;\n mod va_arg;\n mod value;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n #[derive(Clone)]\n pub struct LlvmCodegenBackend(());\n@@ -361,12 +361,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n             .expect(\"Expected LlvmCodegenBackend's OngoingCodegen, found Box<Any>\")\n             .join(sess);\n \n-        sess.time(\"llvm_dump_timing_file\", || {\n-            if sess.opts.unstable_opts.llvm_time_trace {\n+        if sess.opts.unstable_opts.llvm_time_trace {\n+            sess.time(\"llvm_dump_timing_file\", || {\n                 let file_name = outputs.with_extension(\"llvm_timings.json\");\n                 llvm_util::time_trace_profiler_finish(&file_name);\n-            }\n-        });\n+            });\n+        }\n \n         Ok((codegen_results, work_products))\n     }"}, {"sha": "9e5265188b5035cee20776f49a11d1b15ae34ccc", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -640,9 +640,6 @@ extern \"C\" {\n pub struct Builder<'a>(InvariantOpaque<'a>);\n #[repr(C)]\n pub struct PassManager<'a>(InvariantOpaque<'a>);\n-extern \"C\" {\n-    pub type PassManagerBuilder;\n-}\n extern \"C\" {\n     pub type Pass;\n }\n@@ -1072,6 +1069,7 @@ extern \"C\" {\n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;\n     pub fn LLVMGetUndef(Ty: &Type) -> &Value;\n+    pub fn LLVMGetPoison(Ty: &Type) -> &Value;\n \n     // Operations on metadata\n     pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> &Value;\n@@ -1814,8 +1812,6 @@ extern \"C\" {\n     /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    pub fn LLVMInitializePasses();\n-\n     pub fn LLVMTimeTraceProfilerInitialize();\n \n     pub fn LLVMTimeTraceProfilerFinishThread();\n@@ -2410,6 +2406,8 @@ extern \"C\" {\n     pub fn LLVMRustModuleBufferLen(p: &ModuleBuffer) -> usize;\n     pub fn LLVMRustModuleBufferFree(p: &'static mut ModuleBuffer);\n     pub fn LLVMRustModuleCost(M: &Module) -> u64;\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustModuleInstructionStats(M: &Module, Str: &RustString);\n \n     pub fn LLVMRustThinLTOBufferCreate(M: &Module, is_thin: bool) -> &'static mut ThinLTOBuffer;\n     pub fn LLVMRustThinLTOBufferFree(M: &'static mut ThinLTOBuffer);"}, {"sha": "46692fd5e8bcfadd23e27842b5fc137db3c87a71", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -120,8 +120,6 @@ unsafe fn configure_llvm(sess: &Session) {\n         llvm::LLVMTimeTraceProfilerInitialize();\n     }\n \n-    llvm::LLVMInitializePasses();\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n@@ -426,7 +424,7 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n         .filter_map(|s| {\n             let enable_disable = match s.chars().next() {\n                 None => return None,\n-                Some(c @ '+' | c @ '-') => c,\n+                Some(c @ ('+' | '-')) => c,\n                 Some(_) => {\n                     if diagnostics {\n                         sess.emit_warning(UnknownCTargetFeaturePrefix { feature: s });"}, {"sha": "8fe5f8d50abe2aa9696ccb519f2c4e7b7b3079db", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_codegen_ssa/locales/en-US.ftl"}, {"sha": "6a0d0ca55c255e39e47643fe42c88d3087064c19", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -358,9 +358,9 @@ fn link_rlib<'a>(\n             let (data, _) = create_wrapper_file(sess, b\".bundled_lib\".to_vec(), &src);\n             let wrapper_file = emit_wrapper_file(sess, &data, tmpdir, filename.as_str());\n             packed_bundled_libs.push(wrapper_file);\n-        } else if let Some(name) = lib.name {\n+        } else {\n             let path =\n-                find_native_static_library(name.as_str(), lib.verbatim, &lib_search_paths, sess);\n+                find_native_static_library(lib.name.as_str(), lib.verbatim, &lib_search_paths, sess);\n             ab.add_archive(&path, Box::new(|_| false)).unwrap_or_else(|error| {\n                 sess.emit_fatal(errors::AddNativeLibrary { library_path: path, error })});\n         }\n@@ -436,7 +436,7 @@ fn collate_raw_dylibs<'a, 'b>(\n     for lib in used_libraries {\n         if lib.kind == NativeLibKind::RawDylib {\n             let ext = if lib.verbatim { \"\" } else { \".dll\" };\n-            let name = format!(\"{}{}\", lib.name.expect(\"unnamed raw-dylib library\"), ext);\n+            let name = format!(\"{}{}\", lib.name, ext);\n             let imports = dylib_table.entry(name.clone()).or_default();\n             for import in &lib.dll_imports {\n                 if let Some(old_import) = imports.insert(import.name, import) {\n@@ -1199,15 +1199,17 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                     .and_then(|(lhs, rhs)| rhs.chars().all(char::is_numeric).then_some(lhs))\n                     .unwrap_or(stem);\n \n-                // GCC can have an optional target prefix.\n+                // GCC/Clang can have an optional target prefix.\n                 let flavor = if stem == \"emcc\" {\n                     LinkerFlavor::EmCc\n                 } else if stem == \"gcc\"\n                     || stem.ends_with(\"-gcc\")\n                     || stem == \"g++\"\n                     || stem.ends_with(\"-g++\")\n                     || stem == \"clang\"\n+                    || stem.ends_with(\"-clang\")\n                     || stem == \"clang++\"\n+                    || stem.ends_with(\"-clang++\")\n                 {\n                     LinkerFlavor::from_cli(LinkerFlavorCli::Gcc, &sess.target)\n                 } else if stem == \"wasm-ld\" || stem.ends_with(\"-wasm-ld\") {\n@@ -1294,7 +1296,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n         .filter_map(|lib| {\n-            let name = lib.name?;\n+            let name = lib.name;\n             match lib.kind {\n                 NativeLibKind::Static { bundle: Some(false), .. }\n                 | NativeLibKind::Dylib { .. }\n@@ -1315,6 +1317,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                 // These are included, no need to print them\n                 NativeLibKind::Static { bundle: None | Some(true), .. }\n                 | NativeLibKind::LinkArg\n+                | NativeLibKind::WasmImportModule\n                 | NativeLibKind::RawDylib => None,\n             }\n         })\n@@ -2273,21 +2276,18 @@ fn add_native_libs_from_crate(\n \n     let mut last = (None, NativeLibKind::Unspecified, false);\n     for lib in native_libs {\n-        let Some(name) = lib.name else {\n-            continue;\n-        };\n         if !relevant_lib(sess, lib) {\n             continue;\n         }\n \n         // Skip if this library is the same as the last.\n-        last = if (lib.name, lib.kind, lib.verbatim) == last {\n+        last = if (Some(lib.name), lib.kind, lib.verbatim) == last {\n             continue;\n         } else {\n-            (lib.name, lib.kind, lib.verbatim)\n+            (Some(lib.name), lib.kind, lib.verbatim)\n         };\n \n-        let name = name.as_str();\n+        let name = lib.name.as_str();\n         let verbatim = lib.verbatim;\n         match lib.kind {\n             NativeLibKind::Static { bundle, whole_archive } => {\n@@ -2344,6 +2344,7 @@ fn add_native_libs_from_crate(\n             NativeLibKind::RawDylib => {\n                 // Handled separately in `linker_with_args`.\n             }\n+            NativeLibKind::WasmImportModule => {}\n             NativeLibKind::LinkArg => {\n                 if link_static {\n                     cmd.arg(name);"}, {"sha": "dd11768195079edafe620dd3ea7607642559d947", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -133,6 +133,9 @@ pub fn get_linker<'a>(\n         LinkerFlavor::Unix(Cc::No) if sess.target.os == \"l4re\" => {\n             Box::new(L4Bender::new(cmd, sess)) as Box<dyn Linker>\n         }\n+        LinkerFlavor::Unix(Cc::No) if sess.target.os == \"aix\" => {\n+            Box::new(AixLinker::new(cmd, sess)) as Box<dyn Linker>\n+        }\n         LinkerFlavor::WasmLld(Cc::No) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n         LinkerFlavor::Gnu(cc, _)\n         | LinkerFlavor::Darwin(cc, _)\n@@ -720,6 +723,7 @@ impl<'a> Linker for GccLinker<'a> {\n                 let mut arg = OsString::from(\"--version-script=\");\n                 arg.push(path);\n                 self.linker_arg(arg);\n+                self.linker_arg(\"--no-undefined-version\");\n             }\n         }\n     }\n@@ -1473,6 +1477,177 @@ impl<'a> L4Bender<'a> {\n     }\n }\n \n+/// Linker for AIX.\n+pub struct AixLinker<'a> {\n+    cmd: Command,\n+    sess: &'a Session,\n+    hinted_static: bool,\n+}\n+\n+impl<'a> AixLinker<'a> {\n+    pub fn new(cmd: Command, sess: &'a Session) -> AixLinker<'a> {\n+        AixLinker { cmd: cmd, sess: sess, hinted_static: false }\n+    }\n+\n+    fn hint_static(&mut self) {\n+        if !self.hinted_static {\n+            self.cmd.arg(\"-bstatic\");\n+            self.hinted_static = true;\n+        }\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if self.hinted_static {\n+            self.cmd.arg(\"-bdynamic\");\n+            self.hinted_static = false;\n+        }\n+    }\n+\n+    fn build_dylib(&mut self, _out_filename: &Path) {\n+        self.cmd.arg(\"-bM:SRE\");\n+        self.cmd.arg(\"-bnoentry\");\n+        // FIXME: Use CreateExportList utility to create export list\n+        // and remove -bexpfull.\n+        self.cmd.arg(\"-bexpfull\");\n+    }\n+}\n+\n+impl<'a> Linker for AixLinker<'a> {\n+    fn link_dylib(&mut self, lib: &str, _verbatim: bool, _as_needed: bool) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_staticlib(&mut self, lib: &str, _verbatim: bool) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n+        self.cmd.arg(lib);\n+    }\n+\n+    fn include_path(&mut self, path: &Path) {\n+        self.cmd.arg(\"-L\").arg(path);\n+    }\n+\n+    fn framework_path(&mut self, _: &Path) {\n+        bug!(\"frameworks are not supported on AIX\");\n+    }\n+\n+    fn output_filename(&mut self, path: &Path) {\n+        self.cmd.arg(\"-o\").arg(path);\n+    }\n+\n+    fn add_object(&mut self, path: &Path) {\n+        self.cmd.arg(path);\n+    }\n+\n+    fn full_relro(&mut self) {}\n+\n+    fn partial_relro(&mut self) {}\n+\n+    fn no_relro(&mut self) {}\n+\n+    fn cmd(&mut self) -> &mut Command {\n+        &mut self.cmd\n+    }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicDylib => {\n+                self.hint_dynamic();\n+                self.build_dylib(out_filename);\n+            }\n+            LinkOutputKind::StaticDylib => {\n+                self.hint_static();\n+                self.build_dylib(out_filename);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn link_rust_dylib(&mut self, lib: &str, _: &Path) {\n+        self.hint_dynamic();\n+        self.cmd.arg(format!(\"-l{}\", lib));\n+    }\n+\n+    fn link_framework(&mut self, _framework: &str, _as_needed: bool) {\n+        bug!(\"frameworks not supported on AIX\");\n+    }\n+\n+    fn link_whole_staticlib(&mut self, lib: &str, verbatim: bool, search_path: &[PathBuf]) {\n+        self.hint_static();\n+        let lib = find_native_static_library(lib, verbatim, search_path, &self.sess);\n+        self.cmd.arg(format!(\"-bkeepfile:{}\", lib.to_str().unwrap()));\n+    }\n+\n+    fn link_whole_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n+        self.cmd.arg(format!(\"-bkeepfile:{}\", lib.to_str().unwrap()));\n+    }\n+\n+    fn gc_sections(&mut self, _keep_metadata: bool) {\n+        self.cmd.arg(\"-bgc\");\n+    }\n+\n+    fn no_gc_sections(&mut self) {\n+        self.cmd.arg(\"-bnogc\");\n+    }\n+\n+    fn optimize(&mut self) {}\n+\n+    fn pgo_gen(&mut self) {}\n+\n+    fn control_flow_guard(&mut self) {}\n+\n+    fn debuginfo(&mut self, strip: Strip, _: &[PathBuf]) {\n+        match strip {\n+            Strip::None => {}\n+            // FIXME: -s strips the symbol table, line number information\n+            // and relocation information.\n+            Strip::Debuginfo | Strip::Symbols => {\n+                self.cmd.arg(\"-s\");\n+            }\n+        }\n+    }\n+\n+    fn no_crt_objects(&mut self) {}\n+\n+    fn no_default_libraries(&mut self) {}\n+\n+    fn export_symbols(&mut self, tmpdir: &Path, _crate_type: CrateType, symbols: &[String]) {\n+        let path = tmpdir.join(\"list.exp\");\n+        let res: io::Result<()> = try {\n+            let mut f = BufWriter::new(File::create(&path)?);\n+            // TODO: use llvm-nm to generate export list.\n+            for symbol in symbols {\n+                debug!(\"  _{}\", symbol);\n+                writeln!(f, \"  {}\", symbol)?;\n+            }\n+        };\n+        if let Err(e) = res {\n+            self.sess.fatal(&format!(\"failed to write export file: {}\", e));\n+        }\n+        self.cmd.arg(format!(\"-bE:{}\", path.to_str().unwrap()));\n+    }\n+\n+    fn subsystem(&mut self, _subsystem: &str) {}\n+\n+    fn reset_per_library_state(&mut self) {\n+        self.hint_dynamic();\n+    }\n+\n+    fn linker_plugin_lto(&mut self) {}\n+\n+    fn add_eh_frame_header(&mut self) {}\n+\n+    fn add_no_exec(&mut self) {}\n+\n+    fn add_as_needed(&mut self) {}\n+}\n+\n fn for_each_exported_symbols_include_dep<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     crate_type: CrateType,"}, {"sha": "4ab56699922f54022d74f054dd5669ba818d79e0", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -306,7 +306,13 @@ pub fn create_compressed_metadata_file(\n     symbol_name: &str,\n ) -> Vec<u8> {\n     let mut compressed = rustc_metadata::METADATA_HEADER.to_vec();\n+    // Our length will be backfilled once we're done writing\n+    compressed.write_all(&[0; 4]).unwrap();\n     FrameEncoder::new(&mut compressed).write_all(metadata.raw_data()).unwrap();\n+    let meta_len = rustc_metadata::METADATA_HEADER.len();\n+    let data_len = (compressed.len() - meta_len - 4) as u32;\n+    compressed[meta_len..meta_len + 4].copy_from_slice(&data_len.to_be_bytes());\n+\n     let Some(mut file) = create_object_file(sess) else {\n         return compressed.to_vec();\n     };"}, {"sha": "e403a1fd8ae78666c654664896630fe00faa9326", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -1,3 +1,5 @@\n+use crate::base::allocator_kind_for_codegen;\n+\n use std::collections::hash_map::Entry::*;\n \n use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n@@ -8,10 +10,11 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::exported_symbols::{\n     metadata_symbol_name, ExportedSymbol, SymbolExportInfo, SymbolExportKind, SymbolExportLevel,\n };\n+use rustc_middle::query::LocalCrate;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n-use rustc_middle::ty::{self, DefIdTree, SymbolName, TyCtxt};\n+use rustc_middle::ty::{self, SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, OomStrategy};\n use rustc_target::spec::SanitizerSet;\n \n@@ -39,9 +42,7 @@ pub fn crates_export_threshold(crate_types: &[CrateType]) -> SymbolExportLevel {\n     }\n }\n \n-fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<SymbolExportInfo> {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n+fn reachable_non_generics_provider(tcx: TyCtxt<'_>, _: LocalCrate) -> DefIdMap<SymbolExportInfo> {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         return Default::default();\n     }\n@@ -58,7 +59,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n \n     let mut reachable_non_generics: DefIdMap<_> = tcx\n         .reachable_set(())\n-        .iter()\n+        .items()\n         .filter_map(|&def_id| {\n             // We want to ignore some FFI functions that are not exposed from\n             // this crate. Reachable FFI functions can be lumped into two\n@@ -136,7 +137,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             };\n             (def_id.to_def_id(), info)\n         })\n-        .collect();\n+        .into();\n \n     if let Some(id) = tcx.proc_macro_decls_static(()) {\n         reachable_non_generics.insert(\n@@ -152,10 +153,10 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n     reachable_non_generics\n }\n \n-fn is_reachable_non_generic_provider_local(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+fn is_reachable_non_generic_provider_local(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     let export_threshold = threshold(tcx);\n \n-    if let Some(&info) = tcx.reachable_non_generics(def_id.krate).get(&def_id) {\n+    if let Some(&info) = tcx.reachable_non_generics(LOCAL_CRATE).get(&def_id.to_def_id()) {\n         info.level.is_below_threshold(export_threshold)\n     } else {\n         false\n@@ -168,10 +169,8 @@ fn is_reachable_non_generic_provider_extern(tcx: TyCtxt<'_>, def_id: DefId) -> b\n \n fn exported_symbols_provider_local(\n     tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n+    _: LocalCrate,\n ) -> &[(ExportedSymbol<'_>, SymbolExportInfo)] {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n     if !tcx.sess.opts.output_types.should_codegen() {\n         return &[];\n     }\n@@ -200,7 +199,8 @@ fn exported_symbols_provider_local(\n         ));\n     }\n \n-    if tcx.allocator_kind(()).is_some() {\n+    // Mark allocator shim symbols as exported only if they were generated.\n+    if allocator_kind_for_codegen(tcx).is_some() {\n         for symbol_name in ALLOCATOR_METHODS\n             .iter()\n             .map(|method| format!(\"__rust_{}\", method.name))\n@@ -373,7 +373,7 @@ fn upstream_monomorphizations_provider(\n                 ExportedSymbol::Generic(def_id, substs) => (def_id, substs),\n                 ExportedSymbol::DropGlue(ty) => {\n                     if let Some(drop_in_place_fn_def_id) = drop_in_place_fn_def_id {\n-                        (drop_in_place_fn_def_id, tcx.intern_substs(&[ty.into()]))\n+                        (drop_in_place_fn_def_id, tcx.mk_substs(&[ty.into()]))\n                     } else {\n                         // `drop_in_place` in place does not exist, don't try\n                         // to use it.\n@@ -592,7 +592,7 @@ fn wasm_import_module_map(tcx: TyCtxt<'_>, cnum: CrateNum) -> FxHashMap<DefId, S\n \n     let mut ret = FxHashMap::default();\n     for (def_id, lib) in tcx.foreign_modules(cnum).iter() {\n-        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module);\n+        let module = def_id_to_native_lib.get(&def_id).and_then(|s| s.wasm_import_module());\n         let Some(module) = module else { continue };\n         ret.extend(lib.foreign_items.iter().map(|id| {\n             assert_eq!(id.krate, cnum);"}, {"sha": "7ce72d2172799ceaeb85ce9f0345f29d04cfbb82", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n };\n use jobserver::{Acquired, Client};\n+use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n@@ -447,8 +448,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let sess = tcx.sess;\n \n     let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-    let no_builtins = tcx.sess.contains_name(crate_attrs, sym::no_builtins);\n-    let is_compiler_builtins = tcx.sess.contains_name(crate_attrs, sym::compiler_builtins);\n+    let no_builtins = attr::contains_name(crate_attrs, sym::no_builtins);\n+    let is_compiler_builtins = attr::contains_name(crate_attrs, sym::compiler_builtins);\n \n     let crate_info = CrateInfo::new(tcx, target_cpu);\n "}, {"sha": "6c4ca8f7fb12dade7a68ff5f8f51765886d27765", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -13,6 +13,7 @@ use crate::mir::place::PlaceRef;\n use crate::traits::*;\n use crate::{CachedModuleCodegen, CompiledModule, CrateInfo, MemFlags, ModuleCodegen, ModuleKind};\n \n+use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n@@ -23,7 +24,6 @@ use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::Idx;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols;\n@@ -39,7 +39,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::{Align, FIRST_VARIANT};\n \n use std::collections::BTreeSet;\n use std::time::{Duration, Instant};\n@@ -306,7 +306,7 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variant(VariantIdx::new(0)).fields.len() {\n+            for i in 0..def_a.variant(FIRST_VARIANT).fields.len() {\n                 let src_f = src.project_field(bx, i);\n                 let dst_f = dst.project_field(bx, i);\n \n@@ -476,7 +476,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                     cx.tcx(),\n                     ty::ParamEnv::reveal_all(),\n                     start_def_id,\n-                    cx.tcx().intern_substs(&[main_ret_ty.into()]),\n+                    cx.tcx().mk_substs(&[main_ret_ty.into()]),\n                 )\n                 .unwrap()\n                 .unwrap(),\n@@ -545,6 +545,23 @@ pub fn collect_debugger_visualizers_transitive(\n         .collect::<BTreeSet<_>>()\n }\n \n+/// Decide allocator kind to codegen. If `Some(_)` this will be the same as\n+/// `tcx.allocator_kind`, but it may be `None` in more cases (e.g. if using\n+/// allocator definitions from a dylib dependency).\n+pub fn allocator_kind_for_codegen(tcx: TyCtxt<'_>) -> Option<AllocatorKind> {\n+    // If the crate doesn't have an `allocator_kind` set then there's definitely\n+    // no shim to generate. Otherwise we also check our dependency graph for all\n+    // our output crate types. If anything there looks like its a `Dynamic`\n+    // linkage, then it's already got an allocator shim and we'll be using that\n+    // one instead. If nothing exists then it's our job to generate the\n+    // allocator!\n+    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n+        use rustc_middle::middle::dependency_format::Linkage;\n+        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n+    });\n+    if any_dynamic_crate { None } else { tcx.allocator_kind(()) }\n+}\n+\n pub fn codegen_crate<B: ExtraBackendMethods>(\n     backend: B,\n     tcx: TyCtxt<'_>,\n@@ -615,20 +632,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     );\n \n     // Codegen an allocator shim, if necessary.\n-    //\n-    // If the crate doesn't have an `allocator_kind` set then there's definitely\n-    // no shim to generate. Otherwise we also check our dependency graph for all\n-    // our output crate types. If anything there looks like its a `Dynamic`\n-    // linkage, then it's already got an allocator shim and we'll be using that\n-    // one instead. If nothing exists then it's our job to generate the\n-    // allocator!\n-    let any_dynamic_crate = tcx.dependency_formats(()).iter().any(|(_, list)| {\n-        use rustc_middle::middle::dependency_format::Linkage;\n-        list.iter().any(|&linkage| linkage == Linkage::Dynamic)\n-    });\n-    let allocator_module = if any_dynamic_crate {\n-        None\n-    } else if let Some(kind) = tcx.allocator_kind(()) {\n+    if let Some(kind) = allocator_kind_for_codegen(tcx) {\n         let llmod_id =\n             cgu_name_builder.build_cgu_name(LOCAL_CRATE, &[\"crate\"], Some(\"allocator\")).to_string();\n         let module_llvm = tcx.sess.time(\"write_allocator_module\", || {\n@@ -642,13 +646,10 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             )\n         });\n \n-        Some(ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator })\n-    } else {\n-        None\n-    };\n-\n-    if let Some(allocator_module) = allocator_module {\n-        ongoing_codegen.submit_pre_codegened_module_to_llvm(tcx, allocator_module);\n+        ongoing_codegen.submit_pre_codegened_module_to_llvm(\n+            tcx,\n+            ModuleCodegen { name: llmod_id, module_llvm, kind: ModuleKind::Allocator },\n+        );\n     }\n \n     // For better throughput during parallel processing by LLVM, we used to sort\n@@ -784,6 +785,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             total_codegen_time,\n             start_rss.unwrap(),\n             end_rss,\n+            tcx.sess.opts.unstable_opts.time_passes_format,\n         );\n     }\n \n@@ -807,7 +809,7 @@ impl CrateInfo {\n             .collect();\n         let local_crate_name = tcx.crate_name(LOCAL_CRATE);\n         let crate_attrs = tcx.hir().attrs(rustc_hir::CRATE_HIR_ID);\n-        let subsystem = tcx.sess.first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n+        let subsystem = attr::first_attr_value_str_by_name(crate_attrs, sym::windows_subsystem);\n         let windows_subsystem = subsystem.map(|subsystem| {\n             if subsystem != sym::windows && subsystem != sym::console {\n                 tcx.sess.emit_fatal(errors::InvalidWindowsSubsystem { subsystem });"}, {"sha": "037b07dec62972740b8b78cfb4229fec7c05840e", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::{lang_items, weak_lang_items::WEAK_LANG_ITEMS, LangItem};\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self as ty, DefIdTree, TyCtxt};\n+use rustc_middle::ty::{self as ty, TyCtxt};\n use rustc_session::{lint, parse::feature_err};\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};\n@@ -43,7 +43,7 @@ fn linkage_by_name(tcx: TyCtxt<'_>, def_id: LocalDefId, name: &str) -> Linkage {\n     }\n }\n \n-fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n+fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n     if cfg!(debug_assertions) {\n         let def_kind = tcx.def_kind(did);\n         assert!(\n@@ -52,7 +52,6 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n         );\n     }\n \n-    let did = did.expect_local();\n     let attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(did));\n     let mut codegen_fn_attrs = CodegenFnAttrs::new();\n     if tcx.should_inherit_track_caller(did) {\n@@ -61,25 +60,29 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n \n     let supported_target_features = tcx.supported_target_features(LOCAL_CRATE);\n \n-    // In some cases, attribute are only valid on functions, but it's the `check_attr`\n-    // pass that check that they aren't used anywhere else, rather this module.\n-    // In these cases, we bail from performing further checks that are only meaningful for\n-    // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n-    // report a delayed bug, just in case `check_attr` isn't doing its job.\n-    let validate_fn_only_attr = |attr_sp| -> bool {\n-        let def_kind = tcx.def_kind(did);\n-        if let DefKind::Fn | DefKind::AssocFn | DefKind::Variant | DefKind::Ctor(..) = def_kind {\n-            true\n-        } else {\n-            tcx.sess.delay_span_bug(attr_sp, \"this attribute can only be applied to functions\");\n-            false\n-        }\n-    };\n-\n     let mut inline_span = None;\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n+\n     for attr in attrs.iter() {\n+        // In some cases, attribute are only valid on functions, but it's the `check_attr`\n+        // pass that check that they aren't used anywhere else, rather this module.\n+        // In these cases, we bail from performing further checks that are only meaningful for\n+        // functions (such as calling `fn_sig`, which ICEs if given a non-function). We also\n+        // report a delayed bug, just in case `check_attr` isn't doing its job.\n+        let fn_sig = || {\n+            use DefKind::*;\n+\n+            let def_kind = tcx.def_kind(did);\n+            if let Fn | AssocFn | Variant | Ctor(..) = def_kind {\n+                Some(tcx.fn_sig(did))\n+            } else {\n+                tcx.sess\n+                    .delay_span_bug(attr.span, \"this attribute can only be applied to functions\");\n+                None\n+            }\n+        };\n+\n         if attr.has_name(sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n         } else if attr.has_name(sym::rustc_allocator) {\n@@ -169,8 +172,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                 }\n             }\n         } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if validate_fn_only_attr(attr.span)\n-                && !matches!(tcx.fn_sig(did).skip_binder().abi(), abi::Abi::C { .. })\n+            if let Some(fn_sig) = fn_sig()\n+                && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n             {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -189,8 +192,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n         } else if attr.has_name(sym::track_caller) {\n             if !tcx.is_closure(did.to_def_id())\n-                && validate_fn_only_attr(attr.span)\n-                && tcx.fn_sig(did).skip_binder().abi() != abi::Abi::Rust\n+                && let Some(fn_sig) = fn_sig()\n+                && fn_sig.skip_binder().abi() != abi::Abi::Rust\n             {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n@@ -222,7 +225,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n             }\n         } else if attr.has_name(sym::target_feature) {\n             if !tcx.is_closure(did.to_def_id())\n-                && tcx.fn_sig(did).skip_binder().unsafety() == hir::Unsafety::Normal\n+                && let Some(fn_sig) = fn_sig()\n+                && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n             {\n                 if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n                     // The `#[target_feature]` attribute is allowed on\n@@ -242,6 +246,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: DefId) -> CodegenFnAttrs {\n                     // Note that this is also allowed if `actually_rustdoc` so\n                     // if a target is documenting some wasm-specific code then\n                     // it's not spuriously denied.\n+                    //\n+                    // This exception needs to be kept in sync with allowing\n+                    // `#[target_feature]` on `main` and `start`.\n                 } else if !tcx.features().target_feature_11 {\n                     let mut err = feature_err(\n                         &tcx.sess.parse_sess,"}, {"sha": "c34f1dbf8569da79ebbfdb083e20f68f95745de2", "filename": "compiler/rustc_codegen_ssa/src/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fglue.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -46,7 +46,7 @@ pub fn size_and_align_of_dst<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // NOTE: ideally, we want the effects of both `unchecked_smul` and `unchecked_umul`\n                 // (resulting in `mul nsw nuw` in LLVM IR), since we know that the multiplication\n                 // cannot signed wrap, and that both operands are non-negative. But at the time of writing,\n-                // `BuilderMethods` can't do this, and it doesn't seem to enable any further optimizations.\n+                // the `LLVM-C` binding can't do this, and it doesn't seem to enable any further optimizations.\n                 bx.unchecked_smul(info.unwrap(), bx.const_usize(unit.size.bytes())),\n                 bx.const_usize(unit.align.abi.bytes()),\n             )"}, {"sha": "81227b04e8a7efe0690b6a98db20af8883d593a3", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -56,7 +56,7 @@ pub mod mono_item;\n pub mod target_features;\n pub mod traits;\n \n-fluent_messages! { \"../locales/en-US.ftl\" }\n+fluent_messages! { \"../messages.ftl\" }\n \n pub struct ModuleCodegen<M> {\n     /// The name of the module. When the crate may be saved between\n@@ -118,7 +118,7 @@ bitflags::bitflags! {\n #[derive(Clone, Debug, Encodable, Decodable, HashStable)]\n pub struct NativeLib {\n     pub kind: NativeLibKind,\n-    pub name: Option<Symbol>,\n+    pub name: Symbol,\n     pub filename: Option<Symbol>,\n     pub cfg: Option<ast::MetaItem>,\n     pub verbatim: bool,"}, {"sha": "0ce395e912db319c32386b93b0b1854f16dcc7f9", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "patch": "@@ -295,7 +295,6 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n                 TerminatorKind::Call { cleanup: unwind, .. }\n                 | TerminatorKind::InlineAsm { cleanup: unwind, .. }\n                 | TerminatorKind::Assert { cleanup: unwind, .. }\n-                | TerminatorKind::DropAndReplace { unwind, .. }\n                 | TerminatorKind::Drop { unwind, .. } => {\n                     if let Some(unwind) = unwind {\n                         debug!("}, {"sha": "5da0e826c56401da89df91414b4b07043ac6d691", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "6e32c28a42c65c2b1ad4a55b025c7c27bf580426", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "5cffca5230a8f4c3f6193f7b2dbbfda68eb54015", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "25721f7558383be62eb2ba2abe84c01a75bbcba6", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f6523a448e32dc0b37df4ea71817f33f3549a100", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "4bc4fdab59e1974e322b78991bb5a71a54878ef7", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "41f585f7fccc1613db7492bda5c93108752f463f", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "754b085f1a83229a14c14152b9ded4bfb2841dc4", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "61906302779e95dbdc864d31dd49ee0519c3d6c5", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "33bb116d6fa23f01c513d1b34b0d7e8ed9007070", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_const_eval/locales/en-US.ftl"}, {"sha": "7564ba17b404a02e213e3815e1b90f570a286eb8", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "088a824fd8f14c05b6a15529eea4e6b6fbe9589d", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "350ce529ef538855dd996453804a6935b932214c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "8e4454d7cec28dc7618d42110662b04887243af9", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "163e3f86993224edd626bb1e3c15c365919a3635", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "0918ffcd9821442a92ef261da3c2204f9606d4a2", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "b220d21f68b72b0f2a371afd2f570fe3df8af166", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "26fb041b455136bb1c1a79ae31f857dd725e817e", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 52, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "76c8d0a975ac0b882812f5345e2fff60d2ce9ae9", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "aca68dc454beeeb6c32e1790c2a9a4e724863b6c", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "a3764a7d142663d454030eac69b3a3eda82768cd", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "4decfe863e6349cadc71a1e99aecb9da8f4eadf1", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "a95bcaa3f9988f9e28ca0baf47e0946f0c0b081f", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "9a366364e769eb6639f599897cc7dbcd443b337f", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "fc83985eaca22fdc5596fc370081327353b70c23", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f7881c5096021d6f710afcac1634e41d29284ef6", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "16b83af91ac951fb25b65d0a1bbfe1d5f7d28858", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "0d9cd78fe12ac9acd2f91c94fe78754dcb34783d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "c0f5b3725b36d355d854164931bb38b6de83b7cc", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f01ab4c5d611da57e5edc4672de9f2edc6490406", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "6758cba2eed3485a6efeb82d0b98c2317cc26241", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "78c74e1892dc51baa3d17b32872a13c00125a960", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "648a86d32fcf33b7252d0408d05cd14b393ca359", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "2be385d551e8a98bafb47fea12e5ec7d2a3fb896", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "23fcd22c52b8e02b0868a0a33d9b8a4bfa0f5efe", "filename": "compiler/rustc_const_eval/src/util/check_validity_requirement.rs", "status": "renamed", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcheck_validity_requirement.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs"}, {"sha": "c0aabd77ceeadb3153cc8750b2ca556ff93c1f37", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "056ee1f63be0311799a7a49c484e9454c4006347", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f58844f281794ba9ce48b089702036e83d340071", "filename": "compiler/rustc_data_structures/src/flat_map_in_place.rs", "status": "renamed", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fflat_map_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fflat_map_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflat_map_in_place.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_data_structures/src/map_in_place.rs"}, {"sha": "efdb44248d1d7ef98657be0b6c3cfd7448c5281b", "filename": "compiler/rustc_data_structures/src/flock.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "da128f464a607b59447316d8c404fe2bdd7b9548", "filename": "compiler/rustc_data_structures/src/flock/windows.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "513df666d0da1bf646056f43e5a701f5ff73effc", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "7c866da60090f9541c333c138f773396c2e4be0c", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Ftests.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "0339fb925d4587870037fb09cab5dcb091c63646", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "27a869eb7cdb013afba153a1e0206df0bfbb6b66", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "58a0609e29655dff934ab6f553ba6a6ed1918db3", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 77, "deletions": 28, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "7d23ff5194870cf547ae97ef3eb952e332a7bbb0", "filename": "compiler/rustc_data_structures/src/sorted_map/index_map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Findex_map.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "def7a7112fb3f2acf6f34d74cf58dd2649970338", "filename": "compiler/rustc_data_structures/src/sorted_map/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map%2Ftests.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "de9842156d61f4588598c60f7d849437d83158cd", "filename": "compiler/rustc_data_structures/src/stable_hasher.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "724be5888ddb46da7e35744835fc60aeb15e331f", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "5c2435a0122ebeb161cf75f2ff8636a224b4f09c", "filename": "compiler/rustc_data_structures/src/unord.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Funord.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "d1a99bcaeb75452a28b497c99f1bddddea8ecd3e", "filename": "compiler/rustc_data_structures/src/vec_map.rs", "status": "removed", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map.rs?ref=21549dac539dc220f052d038ec643645cedbbd6d"}, {"sha": "458b60077dc75a76d5c3f63e31cf8bfbdb10012e", "filename": "compiler/rustc_data_structures/src/vec_map/tests.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21549dac539dc220f052d038ec643645cedbbd6d/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fvec_map%2Ftests.rs?ref=21549dac539dc220f052d038ec643645cedbbd6d"}, {"sha": "73a1f79a020f1da162ee5f2b6a6a5faeb9318906", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f19b1ff6426177c16eb24dd9093bfa268cb21464", "filename": "compiler/rustc_driver_impl/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_driver_impl%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_driver_impl%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_driver_impl/locales/en-US.ftl"}, {"sha": "1e835f6065a6379d3d6493b16f477837f1d4e852", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "d104ff0891d34d06b95089a27cb19b78ce7853ed", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f03f8a6605f664d82b6d695d29261eb494ef060a", "filename": "compiler/rustc_error_codes/src/error_codes/E0010.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0010.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "71d6c6fe2ef2c5377fcf625456ab26d630665330", "filename": "compiler/rustc_error_codes/src/error_codes/E0080.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "9e85234bdbb3ab7532c32d99cd2d92c52e9400a1", "filename": "compiler/rustc_error_codes/src/error_codes/E0206.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0206.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0206.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0206.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "b18e8758d712e60ef96f2279efd66ec9cce2c26e", "filename": "compiler/rustc_error_codes/src/error_codes/E0368.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0368.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0368.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0368.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "8c0edcee52147bd176139af3accbf478ef7d49e4", "filename": "compiler/rustc_error_codes/src/error_codes/E0416.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0416.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "fc141ba77f5df1ef6bf1bed0919cd1c13b060cc5", "filename": "compiler/rustc_error_codes/src/error_codes/E0476.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0476.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "84d55d524267ebbdf9130a356dd6cd8fde8c763b", "filename": "compiler/rustc_error_codes/src/error_codes/E0710.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0710.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0710.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0710.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "4377a292473319ccd11ff91f53e5a66073a1dcff", "filename": "compiler/rustc_error_codes/src/error_codes/E0794.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "d6b120e4dfcf23b81c3f029707beefdfb412cd35", "filename": "compiler/rustc_error_codes/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "e62923744482260f697a0083a88241a34cb0bc74", "filename": "compiler/rustc_error_messages/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_messages%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_messages%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_error_messages/locales/en-US.ftl"}, {"sha": "301dacc28248245edc31205bcf3e2be6eb3a3ff8", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "e1ead08ea66bdf9dd4ad4919010627cb855e49d5", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "dde1d6c0a819c6560d36ad532c4ef9c42e772793", "filename": "compiler/rustc_errors/messages.ftl", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fmessages.ftl?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6", "previous_filename": "compiler/rustc_errors/locales/en-US.ftl"}, {"sha": "e82bad67b21ecc122043dc34ff5eceb5c857f0c0", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "1b2e7b7e083b4f7275a22fbaaca320608ef4f648", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "f32d6b96b9b2429d13e47d61f29789c23daaf392", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}, {"sha": "9866a9bffe0e183dd2c28fa56bb712532a23cb2a", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af489afeb7b6ca6f31848c4141652f4dcb2a7fa6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=af489afeb7b6ca6f31848c4141652f4dcb2a7fa6"}]}