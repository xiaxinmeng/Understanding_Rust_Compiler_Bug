{"sha": "28548db57d0acbc00ee80b43816953dbe31d53ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NTQ4ZGI1N2QwYWNiYzAwZWU4MGI0MzgxNjk1M2RiZTMxZDUzYmE=", "commit": {"author": {"name": "Angelo Polo", "email": "polo.language@gmail.com", "date": "2016-11-13T18:31:34Z"}, "committer": {"name": "Angelo Polo", "email": "polo.language@gmail.com", "date": "2016-11-13T18:31:34Z"}, "message": "Improved punctuation, capitalization, and sentence structure of code snippet comments", "tree": {"sha": "b41072d64055ba6fcf3511117a9983360d8635d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b41072d64055ba6fcf3511117a9983360d8635d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28548db57d0acbc00ee80b43816953dbe31d53ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28548db57d0acbc00ee80b43816953dbe31d53ba", "html_url": "https://github.com/rust-lang/rust/commit/28548db57d0acbc00ee80b43816953dbe31d53ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28548db57d0acbc00ee80b43816953dbe31d53ba/comments", "author": {"login": "polo-language", "id": 6944615, "node_id": "MDQ6VXNlcjY5NDQ2MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6944615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/polo-language", "html_url": "https://github.com/polo-language", "followers_url": "https://api.github.com/users/polo-language/followers", "following_url": "https://api.github.com/users/polo-language/following{/other_user}", "gists_url": "https://api.github.com/users/polo-language/gists{/gist_id}", "starred_url": "https://api.github.com/users/polo-language/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/polo-language/subscriptions", "organizations_url": "https://api.github.com/users/polo-language/orgs", "repos_url": "https://api.github.com/users/polo-language/repos", "events_url": "https://api.github.com/users/polo-language/events{/privacy}", "received_events_url": "https://api.github.com/users/polo-language/received_events", "type": "User", "site_admin": false}, "committer": {"login": "polo-language", "id": 6944615, "node_id": "MDQ6VXNlcjY5NDQ2MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6944615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/polo-language", "html_url": "https://github.com/polo-language", "followers_url": "https://api.github.com/users/polo-language/followers", "following_url": "https://api.github.com/users/polo-language/following{/other_user}", "gists_url": "https://api.github.com/users/polo-language/gists{/gist_id}", "starred_url": "https://api.github.com/users/polo-language/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/polo-language/subscriptions", "organizations_url": "https://api.github.com/users/polo-language/orgs", "repos_url": "https://api.github.com/users/polo-language/repos", "events_url": "https://api.github.com/users/polo-language/events{/privacy}", "received_events_url": "https://api.github.com/users/polo-language/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea02f87daab14fff71af751c8e3f66b689cac3cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea02f87daab14fff71af751c8e3f66b689cac3cd", "html_url": "https://github.com/rust-lang/rust/commit/ea02f87daab14fff71af751c8e3f66b689cac3cd"}], "stats": {"total": 367, "additions": 184, "deletions": 183}, "files": [{"sha": "f416e600415bdab133619196950b73773af73d73", "filename": "src/doc/book/associated-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fassociated-types.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -11,7 +11,7 @@ this:\n trait Graph<N, E> {\n     fn has_edge(&self, &N, &N) -> bool;\n     fn edges(&self, &N) -> Vec<E>;\n-    // etc\n+    // Etc.\n }\n ```\n \n@@ -36,7 +36,7 @@ trait Graph {\n \n     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n     fn edges(&self, &Self::N) -> Vec<Self::E>;\n-    // etc\n+    // Etc.\n }\n ```\n "}, {"sha": "e054736eb30b63e8ec6ef09b0c101a441bbe5568", "filename": "src/doc/book/benchmark-tests.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fbenchmark-tests.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -110,7 +110,7 @@ computation entirely. This could be done for the example above by adjusting the\n # struct X;\n # impl X { fn iter<T, F>(&self, _: F) where F: FnMut() -> T {} } let b = X;\n b.iter(|| {\n-    // note lack of `;` (could also use an explicit `return`).\n+    // Note lack of `;` (could also use an explicit `return`).\n     (0..1000).fold(0, |old, new| old ^ new)\n });\n ```"}, {"sha": "cbf65dfa9ba8c1b3e110835d27a787d0441ba628", "filename": "src/doc/book/box-syntax-and-patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fbox-syntax-and-patterns.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -38,7 +38,7 @@ so as to avoid copying a large data structure. For example:\n struct BigStruct {\n     one: i32,\n     two: i32,\n-    // etc\n+    // Etc.\n     one_hundred: i32,\n }\n \n@@ -68,7 +68,7 @@ This is an antipattern in Rust. Instead, write this:\n struct BigStruct {\n     one: i32,\n     two: i32,\n-    // etc\n+    // Etc.\n     one_hundred: i32,\n }\n "}, {"sha": "296384ab6efd9507921cfa06e0e6ddc660e3e84a", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -106,7 +106,7 @@ from integers, and to cast between pointers to different types subject to\n some constraints. It is only unsafe to dereference the pointer:\n \n ```rust\n-let a = 300 as *const char; // a pointer to location 300\n+let a = 300 as *const char; // `a` is a pointer to location 300.\n let b = a as u32;\n ```\n \n@@ -135,14 +135,14 @@ cast four bytes into a `u32`:\n ```rust,ignore\n let a = [0u8, 0u8, 0u8, 0u8];\n \n-let b = a as u32; // four u8s makes a u32\n+let b = a as u32; // Four u8s makes a u32.\n ```\n \n This errors with:\n \n ```text\n error: non-scalar cast: `[u8; 4]` as `u32`\n-let b = a as u32; // four u8s makes a u32\n+let b = a as u32; // Four u8s makes a u32.\n         ^~~~~~~~\n ```\n \n@@ -170,7 +170,7 @@ fn main() {\n         let a = [0u8, 1u8, 0u8, 0u8];\n         let b = mem::transmute::<[u8; 4], u32>(a);\n         println!(\"{}\", b); // 256\n-        // or, more concisely:\n+        // Or, more concisely:\n         let c: u32 = mem::transmute(a);\n         println!(\"{}\", c); // 256\n     }"}, {"sha": "9dca3479d35e846e02965d8c2dec8f43166f1675", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -25,7 +25,7 @@ the following:\n ```rust\n let x = Box::new(1);\n let y = x;\n-// x no longer accessible here\n+// `x` is no longer accessible here.\n ```\n \n Here, the box was _moved_ into `y`. As `x` no longer owns it, the compiler will no longer allow the\n@@ -291,9 +291,9 @@ the inner data (mutably), and the lock will be released when the guard goes out\n ```rust,ignore\n {\n     let guard = mutex.lock();\n-    // guard dereferences mutably to the inner type\n+    // `guard` dereferences mutably to the inner type.\n     *guard += 1;\n-} // lock released when destructor runs\n+} // Lock is released when destructor runs.\n ```\n \n "}, {"sha": "a3c7333c6bec27af4444aaa784c78a9a4c96b5e2", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -116,7 +116,7 @@ let mut num = 5;\n {\n     let plus_num = |x: i32| x + num;\n \n-} // plus_num goes out of scope, borrow of num ends\n+} // `plus_num` goes out of scope; borrow of `num` ends.\n \n let y = &mut num;\n ```"}, {"sha": "8fa397cd9a666fa3d94092d674a94d98d5ee0f1f", "filename": "src/doc/book/comments.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcomments.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -10,7 +10,7 @@ and *doc comments*.\n ```rust\n // Line comments are anything after \u2018//\u2019 and extend to the end of the line.\n \n-let x = 5; // this is also a line comment.\n+let x = 5; // This is also a line comment.\n \n // If you have a long explanation for something, you can put line comments next\n // to each other. Put a space between the // and your comment so that it\u2019s"}, {"sha": "ff29358df9407e56c09469ba0606e5fc58539499", "filename": "src/doc/book/compiler-plugins.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcompiler-plugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcompiler-plugins.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -48,7 +48,7 @@ extern crate rustc_plugin;\n use syntax::parse::token;\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // trait for expr_usize\n+use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n use syntax::ext::quote::rt::Span;\n use rustc_plugin::Registry;\n "}, {"sha": "67d89d5484ca76a15c0c573910d3db82cc7d64ce", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -213,10 +213,10 @@ fn main() {\n     let mut data = Rc::new(vec![1, 2, 3]);\n \n     for i in 0..3 {\n-        // create a new owned reference\n+        // Create a new owned reference:\n         let data_ref = data.clone();\n \n-        // use it in a thread\n+        // Use it in a thread:\n         thread::spawn(move || {\n             data_ref[0] += i;\n         });\n@@ -390,8 +390,8 @@ use std::sync::mpsc;\n fn main() {\n     let data = Arc::new(Mutex::new(0));\n \n-    // `tx` is the \"transmitter\" or \"sender\"\n-    // `rx` is the \"receiver\"\n+    // `tx` is the \"transmitter\" or \"sender\".\n+    // `rx` is the \"receiver\".\n     let (tx, rx) = mpsc::channel();\n \n     for _ in 0..10 {"}, {"sha": "0e336635235b3ddef0251124790137d61026fa26", "filename": "src/doc/book/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcrates-and-modules.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -126,7 +126,7 @@ Instead of declaring a module like this:\n \n ```rust,ignore\n mod english {\n-    // contents of our module go here\n+    // Contents of our module go here.\n }\n ```\n "}, {"sha": "1996305f09e7311fe458ea45264d87c3466dcda7", "filename": "src/doc/book/custom-allocators.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcustom-allocators.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fcustom-allocators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcustom-allocators.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -41,7 +41,7 @@ which allocator is in use is done simply by linking to the desired allocator:\n extern crate alloc_system;\n \n fn main() {\n-    let a = Box::new(4); // allocates from the system allocator\n+    let a = Box::new(4); // Allocates from the system allocator.\n     println!(\"{}\", a);\n }\n ```\n@@ -57,7 +57,7 @@ uses jemalloc by default one would write:\n extern crate alloc_jemalloc;\n \n pub fn foo() {\n-    let a = Box::new(4); // allocates from jemalloc\n+    let a = Box::new(4); // Allocates from jemalloc.\n     println!(\"{}\", a);\n }\n # fn main() {}\n@@ -72,11 +72,11 @@ crate which implements the allocator API (e.g. the same as `alloc_system` or\n annotated version of `alloc_system`\n \n ```rust,no_run\n-# // only needed for rustdoc --test down below\n+# // Only needed for rustdoc --test down below.\n # #![feature(lang_items)]\n // The compiler needs to be instructed that this crate is an allocator in order\n // to realize that when this is linked in another allocator like jemalloc should\n-// not be linked in\n+// not be linked in.\n #![feature(allocator)]\n #![allocator]\n \n@@ -85,7 +85,7 @@ annotated version of `alloc_system`\n // however, can use all of libcore.\n #![no_std]\n \n-// Let's give a unique name to our custom allocator\n+// Let's give a unique name to our custom allocator:\n #![crate_name = \"my_allocator\"]\n #![crate_type = \"rlib\"]\n \n@@ -126,15 +126,15 @@ pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,\n #[no_mangle]\n pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,\n                                         _size: usize, _align: usize) -> usize {\n-    old_size // this api is not supported by libc\n+    old_size // This api is not supported by libc.\n }\n \n #[no_mangle]\n pub extern fn __rust_usable_size(size: usize, _align: usize) -> usize {\n     size\n }\n \n-# // only needed to get rustdoc to test this\n+# // Only needed to get rustdoc to test this:\n # fn main() {}\n # #[lang = \"panic_fmt\"] fn panic_fmt() {}\n # #[lang = \"eh_personality\"] fn eh_personality() {}\n@@ -149,7 +149,7 @@ After we compile this crate, it can be used as follows:\n extern crate my_allocator;\n \n fn main() {\n-    let a = Box::new(8); // allocates memory via our custom allocator crate\n+    let a = Box::new(8); // Allocates memory via our custom allocator crate.\n     println!(\"{}\", a);\n }\n ```"}, {"sha": "864cd282d93710ad94e59e6fac7e1d6fbb1ae1cd", "filename": "src/doc/book/deref-coercions.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fderef-coercions.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fderef-coercions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fderef-coercions.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -33,13 +33,13 @@ automatically coerce to a `&T`. Here\u2019s an example:\n \n ```rust\n fn foo(s: &str) {\n-    // borrow a string for a second\n+    // Borrow a string for a second.\n }\n \n-// String implements Deref<Target=str>\n+// String implements Deref<Target=str>.\n let owned = \"Hello\".to_string();\n \n-// therefore, this works:\n+// Therefore, this works:\n foo(&owned);\n ```\n \n@@ -55,14 +55,14 @@ type implements `Deref<Target=T>`, so this works:\n use std::rc::Rc;\n \n fn foo(s: &str) {\n-    // borrow a string for a second\n+    // Borrow a string for a second.\n }\n \n-// String implements Deref<Target=str>\n+// String implements Deref<Target=str>.\n let owned = \"Hello\".to_string();\n let counted = Rc::new(owned);\n \n-// therefore, this works:\n+// Therefore, this works:\n foo(&counted);\n ```\n \n@@ -76,10 +76,10 @@ Another very common implementation provided by the standard library is:\n \n ```rust\n fn foo(s: &[i32]) {\n-    // borrow a slice for a second\n+    // Borrow a slice for a second.\n }\n \n-// Vec<T> implements Deref<Target=[T]>\n+// Vec<T> implements Deref<Target=[T]>.\n let owned = vec![1, 2, 3];\n \n foo(&owned);"}, {"sha": "f30a95b4e7890bd89e9e333408408eca52fe369e", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -28,7 +28,7 @@ code. You can use documentation comments for this purpose:\n /// let five = Rc::new(5);\n /// ```\n pub fn new(value: T) -> Rc<T> {\n-    // implementation goes here\n+    // Implementation goes here.\n }\n ```\n \n@@ -483,7 +483,7 @@ you have a module in `foo.rs`, you'll often open its code and see this:\n ```rust\n //! A module for using `foo`s.\n //!\n-//! The `foo` module contains a lot of useful functionality blah blah blah\n+//! The `foo` module contains a lot of useful functionality blah blah blah...\n ```\n \n ### Crate documentation"}, {"sha": "0b7ddcfbe8856e80178b49e2476f1c69bfb5977b", "filename": "src/doc/book/drop.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fdrop.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fdrop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdrop.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -18,9 +18,9 @@ impl Drop for HasDrop {\n fn main() {\n     let x = HasDrop;\n \n-    // do stuff\n+    // Do stuff.\n \n-} // x goes out of scope here\n+} // `x` goes out of scope here.\n ```\n \n When `x` goes out of scope at the end of `main()`, the code for `Drop` will"}, {"sha": "790d6ff85469f24a313bacf4bcd9b6e2f0b28896", "filename": "src/doc/book/enums.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fenums.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -51,7 +51,7 @@ possible variants:\n \n ```rust,ignore\n fn process_color_change(msg: Message) {\n-    let Message::ChangeColor(r, g, b) = msg; // compile-time error\n+    let Message::ChangeColor(r, g, b) = msg; // This causes a compile-time error.\n }\n ```\n "}, {"sha": "0d9f49d66cbd8bac8ea1795792fc238abdf99561", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -65,7 +65,7 @@ and in most cases, the entire program aborts.) Here's an example:\n \n ```rust,should_panic\n // Guess a number between 1 and 10.\n-// If it matches the number we had in mind, return true. Else, return false.\n+// If it matches the number we had in mind, return `true`. Else, return `false`.\n fn guess(n: i32) -> bool {\n     if n < 1 || n > 10 {\n         panic!(\"Invalid number: {}\", n);\n@@ -350,7 +350,7 @@ fn file_path_ext_explicit(file_path: &str) -> Option<&str> {\n }\n \n fn file_name(file_path: &str) -> Option<&str> {\n-  // implementation elided\n+  // Implementation elided.\n   unimplemented!()\n }\n ```\n@@ -360,7 +360,7 @@ analysis, but its type doesn't quite fit...\n \n ```rust,ignore\n fn file_path_ext(file_path: &str) -> Option<&str> {\n-    file_name(file_path).map(|x| extension(x)) //Compilation error\n+    file_name(file_path).map(|x| extension(x)) // This causes a compilation error.\n }\n ```\n \n@@ -1235,11 +1235,11 @@ use std::fs;\n use std::io;\n use std::num;\n \n-// We have to jump through some hoops to actually get error values.\n+// We have to jump through some hoops to actually get error values:\n let io_err: io::Error = io::Error::last_os_error();\n let parse_err: num::ParseIntError = \"not a number\".parse::<i32>().unwrap_err();\n \n-// OK, here are the conversions.\n+// OK, here are the conversions:\n let err1: Box<Error> = From::from(io_err);\n let err2: Box<Error> = From::from(parse_err);\n ```\n@@ -1609,7 +1609,7 @@ fn main() {\n     let data_path = &matches.free[0];\n     let city: &str = &matches.free[1];\n \n-    // Do stuff with information\n+    // Do stuff with information.\n }\n ```\n \n@@ -1747,7 +1747,7 @@ simply ignoring that row.\n use std::path::Path;\n \n struct Row {\n-    // unchanged\n+    // This struct remains unchanged.\n }\n \n struct PopulationCount {\n@@ -1769,7 +1769,7 @@ fn search<P: AsRef<Path>>(file_path: P, city: &str) -> Vec<PopulationCount> {\n     for row in rdr.decode::<Row>() {\n         let row = row.unwrap();\n         match row.population {\n-            None => { } // skip it\n+            None => { } // Skip it.\n             Some(count) => if row.city == city {\n                 found.push(PopulationCount {\n                     city: row.city,\n@@ -1825,7 +1825,7 @@ Let's try it:\n ```rust,ignore\n use std::error::Error;\n \n-// The rest of the code before this is unchanged\n+// The rest of the code before this is unchanged.\n \n fn search<P: AsRef<Path>>\n          (file_path: P, city: &str)\n@@ -1836,7 +1836,7 @@ fn search<P: AsRef<Path>>\n     for row in rdr.decode::<Row>() {\n         let row = try!(row);\n         match row.population {\n-            None => { } // skip it\n+            None => { } // Skip it.\n             Some(count) => if row.city == city {\n                 found.push(PopulationCount {\n                     city: row.city,\n@@ -1957,7 +1957,7 @@ that it is generic on some type parameter `R` that satisfies\n ```rust,ignore\n use std::io;\n \n-// The rest of the code before this is unchanged\n+// The rest of the code before this is unchanged.\n \n fn search<P: AsRef<Path>>\n          (file_path: &Option<P>, city: &str)\n@@ -2070,7 +2070,7 @@ fn search<P: AsRef<Path>>\n     for row in rdr.decode::<Row>() {\n         let row = try!(row);\n         match row.population {\n-            None => { } // skip it\n+            None => { } // Skip it.\n             Some(count) => if row.city == city {\n                 found.push(PopulationCount {\n                     city: row.city,"}, {"sha": "c58fc47c2d36cf426110b640c49bb48b739c2260", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -277,7 +277,7 @@ extern {\n fn main() {\n     unsafe {\n         register_callback(callback);\n-        trigger_callback(); // Triggers the callback\n+        trigger_callback(); // Triggers the callback.\n     }\n }\n ```\n@@ -294,7 +294,7 @@ int32_t register_callback(rust_callback callback) {\n }\n \n void trigger_callback() {\n-  cb(7); // Will call callback(7) in Rust\n+  cb(7); // Will call callback(7) in Rust.\n }\n ```\n \n@@ -320,13 +320,13 @@ Rust code:\n #[repr(C)]\n struct RustObject {\n     a: i32,\n-    // other members\n+    // Other members...\n }\n \n extern \"C\" fn callback(target: *mut RustObject, a: i32) {\n     println!(\"I'm called from C with value {0}\", a);\n     unsafe {\n-        // Update the value in RustObject with the value received from the callback\n+        // Update the value in RustObject with the value received from the callback:\n         (*target).a = a;\n     }\n }\n@@ -339,7 +339,7 @@ extern {\n }\n \n fn main() {\n-    // Create the object that will be referenced in the callback\n+    // Create the object that will be referenced in the callback:\n     let mut rust_object = Box::new(RustObject { a: 5 });\n \n     unsafe {\n@@ -363,7 +363,7 @@ int32_t register_callback(void* callback_target, rust_callback callback) {\n }\n \n void trigger_callback() {\n-  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n+  cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust.\n }\n ```\n \n@@ -606,7 +606,7 @@ use libc::c_int;\n \n # #[cfg(hidden)]\n extern \"C\" {\n-    /// Register the callback.\n+    /// Registers the callback.\n     fn register(cb: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>, c_int) -> c_int>);\n }\n # unsafe fn register(_: Option<extern \"C\" fn(Option<extern \"C\" fn(c_int) -> c_int>,"}, {"sha": "b453936fe00d5f1a0183ae3034b6242595b276a7", "filename": "src/doc/book/functions.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ffunctions.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -135,7 +135,7 @@ In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n following will produce a compile-time error:\n \n ```rust,ignore\n-let x = (let y = 5); // expected identifier, found keyword `let`\n+let x = (let y = 5); // Expected identifier, found keyword `let`.\n ```\n \n The compiler is telling us here that it was expecting to see the beginning of\n@@ -151,7 +151,7 @@ other returned value would be too surprising:\n ```rust\n let mut y = 5;\n \n-let x = (y = 6);  // x has the value `()`, not `6`\n+let x = (y = 6);  // `x` has the value `()`, not `6`.\n ```\n \n The second kind of statement in Rust is the *expression statement*. Its\n@@ -183,7 +183,7 @@ But what about early returns? Rust does have a keyword for that, `return`:\n fn foo(x: i32) -> i32 {\n     return x;\n \n-    // we never run this code!\n+    // We never run this code!\n     x + 1\n }\n ```\n@@ -307,10 +307,10 @@ fn plus_one(i: i32) -> i32 {\n     i + 1\n }\n \n-// without type inference\n+// Without type inference:\n let f: fn(i32) -> i32 = plus_one;\n \n-// with type inference\n+// With type inference:\n let f = plus_one;\n ```\n "}, {"sha": "eafad6a05fc3d1275f68968a81b66b4917dd91f4", "filename": "src/doc/book/generics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgenerics.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -78,7 +78,7 @@ We can write functions that take generic types with a similar syntax:\n \n ```rust\n fn takes_anything<T>(x: T) {\n-    // do something with x\n+    // Do something with `x`.\n }\n ```\n "}, {"sha": "c854b7c373d20e144977972b1d7b94c10caa37c8", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -158,8 +158,8 @@ take a name on the left hand side of the assignment, it actually accepts a\n to use for now:\n \n ```rust\n-let foo = 5; // immutable.\n-let mut bar = 5; // mutable\n+let foo = 5; // `foo` is immutable.\n+let mut bar = 5; // `bar` is mutable.\n ```\n \n [immutable]: mutability.html"}, {"sha": "e531d5d7fc0ff7d3ffc35be49cca25bc4fa4045c", "filename": "src/doc/book/inline-assembly.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Finline-assembly.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -34,7 +34,7 @@ fn foo() {\n     }\n }\n \n-// other platforms\n+// Other platforms:\n #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n fn foo() { /* ... */ }\n \n@@ -130,7 +130,7 @@ stay valid.\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n-// Put the value 0x200 in eax\n+// Put the value 0x200 in eax:\n asm!(\"mov $$0x200, %eax\" : /* no outputs */ : /* no inputs */ : \"eax\");\n # } }\n # #[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]"}, {"sha": "6a08c1b6bb468a403514468d264ee5b4c5146692", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -32,7 +32,7 @@ pub struct Box<T>(*mut T);\n unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     let p = libc::malloc(size as libc::size_t) as *mut u8;\n \n-    // malloc failed\n+    // Check if `malloc` failed:\n     if p as usize == 0 {\n         abort();\n     }"}, {"sha": "397263c69733002afee50d718e039ae01b312b5e", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -54,13 +54,13 @@ dangling pointer or \u2018use after free\u2019, when the resource is memory. A small\n example of such a situation would be:\n \n ```rust,compile_fail\n-let r;              // Introduce reference: r\n+let r;              // Introduce reference: `r`.\n {\n-    let i = 1;      // Introduce scoped value: i\n-    r = &i;         // Store reference of i in r\n-}                   // i goes out of scope and is dropped.\n+    let i = 1;      // Introduce scoped value: `i`.\n+    r = &i;         // Store reference of `i` in `r`.\n+}                   // `i` goes out of scope and is dropped.\n \n-println!(\"{}\", r);  // r still refers to i\n+println!(\"{}\", r);  // `r` still refers to `i`.\n ```\n \n To fix this, we have to make sure that step four never happens after step\n@@ -81,9 +81,9 @@ let lang = \"en\";\n \n let v;\n {\n-    let p = format!(\"lang:{}=\", lang);  // -+ p goes into scope\n+    let p = format!(\"lang:{}=\", lang);  // -+ `p` comes into scope.\n     v = skip_prefix(line, p.as_str());  //  |\n-}                                       // -+ p goes out of scope\n+}                                       // -+ `p` goes out of scope.\n println!(\"{}\", v);\n ```\n \n@@ -191,7 +191,7 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n     let f = Foo { x: y };\n \n     println!(\"{}\", f.x);\n@@ -233,7 +233,7 @@ impl<'a> Foo<'a> {\n }\n \n fn main() {\n-    let y = &5; // this is the same as `let _y = 5; let y = &_y;`\n+    let y = &5; // This is the same as `let _y = 5; let y = &_y;`.\n     let f = Foo { x: y };\n \n     println!(\"x is: {}\", f.x());\n@@ -274,11 +274,11 @@ valid for. For example:\n \n ```rust\n fn main() {\n-    let y = &5;     // -+ y goes into scope\n+    let y = &5;     // -+ `y` comes into scope.\n                     //  |\n-    // stuff        //  |\n+    // Stuff...     //  |\n                     //  |\n-}                   // -+ y goes out of scope\n+}                   // -+ `y` goes out of scope.\n ```\n \n Adding in our `Foo`:\n@@ -289,11 +289,12 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let y = &5;           // -+ y goes into scope\n-    let f = Foo { x: y }; // -+ f goes into scope\n-    // stuff              //  |\n+    let y = &5;           // -+ `y` comes into scope.\n+    let f = Foo { x: y }; // -+ `f` comes into scope.\n                           //  |\n-}                         // -+ f and y go out of scope\n+    // Stuff...           //  |\n+                          //  |\n+}                         // -+ `f` and `y` go out of scope.\n ```\n \n Our `f` lives within the scope of `y`, so everything works. What if it didn\u2019t?\n@@ -305,16 +306,16 @@ struct Foo<'a> {\n }\n \n fn main() {\n-    let x;                    // -+ x goes into scope\n+    let x;                    // -+ `x` comes into scope.\n                               //  |\n     {                         //  |\n-        let y = &5;           // ---+ y goes into scope\n-        let f = Foo { x: y }; // ---+ f goes into scope\n-        x = &f.x;             //  | | error here\n-    }                         // ---+ f and y go out of scope\n+        let y = &5;           // ---+ `y` comes into scope.\n+        let f = Foo { x: y }; // ---+ `f` comes into scope.\n+        x = &f.x;             //  | | This causes an error.\n+    }                         // ---+ `f` and y go out of scope.\n                               //  |\n     println!(\"{}\", x);        //  |\n-}                             // -+ x goes out of scope\n+}                             // -+ `x` goes out of scope.\n ```\n \n Whew! As you can see here, the scopes of `f` and `y` are smaller than the scope"}, {"sha": "688e8c552653b8e156b646de4f6a982a337375ed", "filename": "src/doc/book/loops.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Floops.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Floops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Floops.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -202,8 +202,8 @@ of the outer loops, you can use labels to specify which loop the `break` or\n ```rust\n 'outer: for x in 0..10 {\n     'inner: for y in 0..10 {\n-        if x % 2 == 0 { continue 'outer; } // continues the loop over x\n-        if y % 2 == 0 { continue 'inner; } // continues the loop over y\n+        if x % 2 == 0 { continue 'outer; } // Continues the loop over `x`.\n+        if y % 2 == 0 { continue 'inner; } // Continues the loop over `y`.\n         println!(\"x: {}, y: {}\", x, y);\n     }\n }"}, {"sha": "7f52b33948ee146ff5cd924374141e938d64ea0e", "filename": "src/doc/book/macros.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmacros.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -533,33 +533,33 @@ An example:\n ```rust\n macro_rules! m1 { () => (()) }\n \n-// visible here: m1\n+// Visible here: `m1`.\n \n mod foo {\n-    // visible here: m1\n+    // Visible here: `m1`.\n \n     #[macro_export]\n     macro_rules! m2 { () => (()) }\n \n-    // visible here: m1, m2\n+    // Visible here: `m1`, `m2`.\n }\n \n-// visible here: m1\n+// Visible here: `m1`.\n \n macro_rules! m3 { () => (()) }\n \n-// visible here: m1, m3\n+// Visible here: `m1`, `m3`.\n \n #[macro_use]\n mod bar {\n-    // visible here: m1, m3\n+    // Visible here: `m1`, `m3`.\n \n     macro_rules! m4 { () => (()) }\n \n-    // visible here: m1, m3, m4\n+    // Visible here: `m1`, `m3`, `m4`.\n }\n \n-// visible here: m1, m3, m4\n+// Visible here: `m1`, `m3`, `m4`.\n # fn main() { }\n ```\n \n@@ -644,7 +644,7 @@ macro_rules! bct {\n     (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n         => (bct!($($ps),*, 1, $p ; $($ds),*));\n \n-    // halt on empty data string\n+    // Halt on empty data string:\n     ( $($ps:tt),* ; )\n         => (());\n }\n@@ -694,7 +694,7 @@ Like this:\n assert!(true);\n assert_eq!(5, 3 + 2);\n \n-// nope :(\n+// Nope :(\n \n assert!(5 < 3);\n assert_eq!(5, 3);"}, {"sha": "18017cc4a5e54f83074d6e894a291cb7465f0971", "filename": "src/doc/book/mutability.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmutability.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -6,15 +6,15 @@ status:\n \n ```rust,ignore\n let x = 5;\n-x = 6; // error!\n+x = 6; // Error!\n ```\n \n We can introduce mutability with the `mut` keyword:\n \n ```rust\n let mut x = 5;\n \n-x = 6; // no problem!\n+x = 6; // No problem!\n ```\n \n This is a mutable [variable binding][vb]. When a binding is mutable, it means\n@@ -136,7 +136,7 @@ some fields mutable and some immutable:\n ```rust,ignore\n struct Point {\n     x: i32,\n-    mut y: i32, // nope\n+    mut y: i32, // Nope.\n }\n ```\n \n@@ -154,7 +154,7 @@ a.x = 10;\n \n let b = Point { x: 5, y: 6};\n \n-b.x = 10; // error: cannot assign to immutable field `b.x`\n+b.x = 10; // Error: cannot assign to immutable field `b.x`.\n ```\n \n [struct]: structs.html"}, {"sha": "a06de35c0ce69cfd4bf0c5e84392b3e73f39a1cf", "filename": "src/doc/book/no-stdlib.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fno-stdlib.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -41,10 +41,10 @@ in the same format as C:\n #![feature(start)]\n #![no_std]\n \n-// Pull in the system libc library for what crt0.o likely requires\n+// Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n \n-// Entry point for this program\n+// Entry point for this program.\n #[start]\n fn start(_argc: isize, _argv: *const *const u8) -> isize {\n     0\n@@ -84,10 +84,10 @@ compiler's name mangling too:\n #![no_std]\n #![no_main]\n \n-// Pull in the system libc library for what crt0.o likely requires\n+// Pull in the system libc library for what crt0.o likely requires.\n extern crate libc;\n \n-// Entry point for this program\n+// Entry point for this program.\n #[no_mangle] // ensure that this symbol is called `main` in the output\n pub extern fn main(_argc: i32, _argv: *const *const u8) -> i32 {\n     0"}, {"sha": "78ff871046ef753e586883b60beef3b12c4fd2ae", "filename": "src/doc/book/operators-and-overloading.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Foperators-and-overloading.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -69,7 +69,7 @@ impl Add<i32> for Point {\n     type Output = f64;\n \n     fn add(self, rhs: i32) -> f64 {\n-        // add an i32 to a Point and get an f64\n+        // Add an i32 to a Point and get an f64.\n # 1.0\n     }\n }"}, {"sha": "11eda399adc9b9c4118c6fcad2583d066d42cd6f", "filename": "src/doc/book/ownership.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fownership.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -107,7 +107,7 @@ try to use something after we\u2019ve passed it as an argument:\n \n ```rust,ignore\n fn take(v: Vec<i32>) {\n-    // what happens here isn\u2019t important.\n+    // What happens here isn\u2019t important.\n }\n \n let v = vec![1, 2, 3];\n@@ -264,9 +264,9 @@ Of course, if we had to hand ownership back with every function we wrote:\n \n ```rust\n fn foo(v: Vec<i32>) -> Vec<i32> {\n-    // do stuff with v\n+    // Do stuff with `v`.\n \n-    // hand back ownership\n+    // Hand back ownership.\n     v\n }\n ```\n@@ -275,9 +275,9 @@ This would get very tedious. It gets worse the more things we want to take owner\n \n ```rust\n fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n-    // do stuff with v1 and v2\n+    // Do stuff with `v1` and `v2`.\n \n-    // hand back ownership, and the result of our function\n+    // Hand back ownership, and the result of our function.\n     (v1, v2, 42)\n }\n "}, {"sha": "b50fa01b8e2be903b1f27b65319cfb6474f1fba8", "filename": "src/doc/book/patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fpatterns.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -163,7 +163,7 @@ ignore parts of a larger structure:\n \n ```rust\n fn coordinate() -> (i32, i32, i32) {\n-    // generate and return some sort of triple tuple\n+    // Generate and return some sort of triple tuple.\n # (1, 2, 3)\n }\n \n@@ -182,7 +182,7 @@ let tuple: (u32, String) = (5, String::from(\"five\"));\n // Here, tuple is moved, because the String moved:\n let (x, _s) = tuple;\n \n-// The next line would give \"error: use of partially moved value: `tuple`\"\n+// The next line would give \"error: use of partially moved value: `tuple`\".\n // println!(\"Tuple is: {:?}\", tuple);\n \n // However,"}, {"sha": "c4169d64ccc67885fb135cacbcbcf5ce69da3c3e", "filename": "src/doc/book/primitive-types.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fprimitive-types.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -54,9 +54,9 @@ bigger numbers.\n If a number literal has nothing to cause its type to be inferred, it defaults:\n \n ```rust\n-let x = 42; // x has type i32\n+let x = 42; // `x` has type `i32`.\n \n-let y = 1.0; // y has type f64\n+let y = 1.0; // `y` has type `f64`.\n ```\n \n Here\u2019s a list of the different numeric types, with links to their documentation\n@@ -177,8 +177,8 @@ length of the slice:\n \n ```rust\n let a = [0, 1, 2, 3, 4];\n-let complete = &a[..]; // A slice containing all of the elements in a\n-let middle = &a[1..4]; // A slice of a: only the elements 1, 2, and 3\n+let complete = &a[..]; // A slice containing all of the elements in `a`.\n+let middle = &a[1..4]; // A slice of `a`: only the elements `1`, `2`, and `3`.\n ```\n \n Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover\n@@ -264,8 +264,8 @@ You can disambiguate a single-element tuple from a value in parentheses with a\n comma:\n \n ```rust\n-(0,); // single-element tuple\n-(0); // zero in parentheses\n+(0,); // A single-element tuple.\n+(0); // A zero in parentheses.\n ```\n \n ## Tuple Indexing"}, {"sha": "2386475d15ea3478bd1cf6de7a8ea233f3800a9f", "filename": "src/doc/book/raw-pointers.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fraw-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fraw-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fraw-pointers.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -101,11 +101,11 @@ programmer *must* guarantee this.\n The recommended method for the conversion is:\n \n ```rust\n-// explicit cast\n+// Explicit cast:\n let i: u32 = 1;\n let p_imm: *const u32 = &i as *const u32;\n \n-// implicit coercion\n+// Implicit coercion:\n let mut m: u32 = 2;\n let p_mut: *mut u32 = &mut m;\n "}, {"sha": "6c9c4fa7dd4b77a6de70fff639ce6cfb02a1616b", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -46,9 +46,9 @@ like this:\n \n ```rust\n fn foo(v1: Vec<i32>, v2: Vec<i32>) -> (Vec<i32>, Vec<i32>, i32) {\n-    // do stuff with v1 and v2\n+    // Do stuff with `v1` and `v2`.\n \n-    // hand back ownership, and the result of our function\n+    // Hand back ownership, and the result of our function.\n     (v1, v2, 42)\n }\n \n@@ -63,9 +63,9 @@ the first step:\n \n ```rust\n fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n-    // do stuff with v1 and v2\n+    // Do stuff with `v1` and `v2`.\n \n-    // return the answer\n+    // Return the answer.\n     42\n }\n \n@@ -74,7 +74,7 @@ let v2 = vec![1, 2, 3];\n \n let answer = foo(&v1, &v2);\n \n-// we can use v1 and v2 here!\n+// We can use `v1` and `v2` here!\n ```\n \n A more concrete example:\n@@ -88,10 +88,10 @@ fn main() {\n     // Borrow two vectors and sum them.\n     // This kind of borrowing does not allow mutation through the borrowed reference.\n     fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {\n-        // do stuff with v1 and v2\n+        // Do stuff with `v1` and `v2`.\n         let s1 = sum_vec(v1);\n         let s2 = sum_vec(v2);\n-        // return the answer\n+        // Return the answer.\n         s1 + s2\n     }\n \n@@ -248,12 +248,12 @@ scopes look like this:\n fn main() {\n     let mut x = 5;\n \n-    let y = &mut x;    // -+ &mut borrow of x starts here\n+    let y = &mut x;    // -+ &mut borrow of `x` starts here.\n                        //  |\n     *y += 1;           //  |\n                        //  |\n-    println!(\"{}\", x); // -+ - try to borrow x here\n-}                      // -+ &mut borrow of x ends here\n+    println!(\"{}\", x); // -+ - Try to borrow `x` here.\n+}                      // -+ &mut borrow of `x` ends here.\n                        \n ```\n \n@@ -265,11 +265,11 @@ So when we add the curly braces:\n let mut x = 5;\n \n {\n-    let y = &mut x; // -+ &mut borrow starts here\n+    let y = &mut x; // -+ &mut borrow starts here.\n     *y += 1;        //  |\n-}                   // -+ ... and ends here\n+}                   // -+ ... and ends here.\n \n-println!(\"{}\", x);  // <- try to borrow x here\n+println!(\"{}\", x);  // <- Try to borrow `x` here.\n ```\n \n There\u2019s no problem. Our mutable borrow goes out of scope before we create an"}, {"sha": "6af15d8768363bd947d8f73b589dec852436fe77", "filename": "src/doc/book/strings.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstrings.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -83,10 +83,10 @@ converted using `&*`.\n ```rust,no_run\n use std::net::TcpStream;\n \n-TcpStream::connect(\"192.168.0.1:3000\"); // &str parameter\n+TcpStream::connect(\"192.168.0.1:3000\"); // Parameter is of type &str.\n \n let addr_string = \"192.168.0.1:3000\".to_string();\n-TcpStream::connect(&*addr_string); // convert addr_string to &str\n+TcpStream::connect(&*addr_string); // Convert `addr_string` to &str.\n ```\n \n Viewing a `String` as a `&str` is cheap, but converting the `&str` to a\n@@ -138,7 +138,7 @@ You can get something similar to an index like this:\n \n ```rust\n # let hachiko = \"\u5fe0\u72ac\u30cf\u30c1\u516c\";\n-let dog = hachiko.chars().nth(1); // kinda like hachiko[1]\n+let dog = hachiko.chars().nth(1); // Kinda like `hachiko[1]`.\n ```\n \n This emphasizes that we have to walk from the beginning of the list of `chars`."}, {"sha": "cfd00cf997e0b7ce2922eec0ea4efddc52cc5496", "filename": "src/doc/book/structs.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstructs.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -82,9 +82,9 @@ fn main() {\n \n     point.x = 5;\n \n-    let point = point; // now immutable\n+    let point = point; // `point` is now immutable.\n \n-    point.y = 6; // this causes an error\n+    point.y = 6; // This causes an error.\n }\n ```\n \n@@ -234,10 +234,10 @@ rather than positions.\n You can define a `struct` with no members at all:\n \n ```rust\n-struct Electron {} // use empty braces...\n-struct Proton;     // ...or just a semicolon\n+struct Electron {} // Use empty braces...\n+struct Proton;     // ...or just a semicolon.\n \n-// whether you declared the struct with braces or not, do the same when creating one\n+// Whether you declared the struct with braces or not, do the same when creating one.\n let x = Electron {};\n let y = Proton;\n ```"}, {"sha": "0f48f5798644db0935d2c1b5dd1f5608e9e8e792", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -299,7 +299,7 @@ fn it_works() {\n #[test]\n #[ignore]\n fn expensive_test() {\n-    // code that takes an hour to run\n+    // Code that takes an hour to run...\n }\n ```\n "}, {"sha": "a0396a75fa26e6663e2e36a807aef1ef0f904c45", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -221,8 +221,8 @@ struct FooVtable {\n // u8:\n \n fn call_method_on_u8(x: *const ()) -> String {\n-    // the compiler guarantees that this function is only called\n-    // with `x` pointing to a u8\n+    // The compiler guarantees that this function is only called\n+    // with `x` pointing to a u8.\n     let byte: &u8 = unsafe { &*(x as *const u8) };\n \n     byte.method()\n@@ -233,24 +233,24 @@ static Foo_for_u8_vtable: FooVtable = FooVtable {\n     size: 1,\n     align: 1,\n \n-    // cast to a function pointer\n+    // Cast to a function pointer:\n     method: call_method_on_u8 as fn(*const ()) -> String,\n };\n \n \n // String:\n \n fn call_method_on_String(x: *const ()) -> String {\n-    // the compiler guarantees that this function is only called\n-    // with `x` pointing to a String\n+    // The compiler guarantees that this function is only called\n+    // with `x` pointing to a String.\n     let string: &String = unsafe { &*(x as *const String) };\n \n     string.method()\n }\n \n static Foo_for_String_vtable: FooVtable = FooVtable {\n     destructor: /* compiler magic */,\n-    // values for a 64-bit computer, halve them for 32-bit ones\n+    // Values for a 64-bit computer, halve them for 32-bit ones.\n     size: 24,\n     align: 8,\n \n@@ -278,17 +278,17 @@ let x: u8 = 1;\n \n // let b: &Foo = &a;\n let b = TraitObject {\n-    // store the data\n+    // Store the data:\n     data: &a,\n-    // store the methods\n+    // Store the methods:\n     vtable: &Foo_for_String_vtable\n };\n \n // let y: &Foo = x;\n let y = TraitObject {\n-    // store the data\n+    // Store the data:\n     data: &x,\n-    // store the methods\n+    // Store the methods:\n     vtable: &Foo_for_u8_vtable\n };\n "}, {"sha": "4747869b65c70f8ad4df4385a3238a685434e5d0", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -270,9 +270,9 @@ won\u2019t have its methods:\n \n ```rust,ignore\n let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");\n-let buf = b\"whatever\"; // byte string literal. buf: &[u8; 8]\n+let buf = b\"whatever\"; // buf: &[u8; 8], a byte string literal.\n let result = f.write(buf);\n-# result.unwrap(); // ignore the error\n+# result.unwrap(); // Ignore the error.\n ```\n \n Here\u2019s the error:\n@@ -291,7 +291,7 @@ use std::io::Write;\n let mut f = std::fs::File::create(\"foo.txt\").expect(\"Couldn\u2019t create foo.txt\");\n let buf = b\"whatever\";\n let result = f.write(buf);\n-# result.unwrap(); // ignore the error\n+# result.unwrap(); // Ignore the error.\n ```\n \n This will compile without error.\n@@ -413,14 +413,14 @@ impl ConvertTo<i64> for i32 {\n     fn convert(&self) -> i64 { *self as i64 }\n }\n \n-// can be called with T == i32\n+// Can be called with T == i32.\n fn normal<T: ConvertTo<i64>>(x: &T) -> i64 {\n     x.convert()\n }\n \n-// can be called with T == i64\n+// Can be called with T == i64.\n fn inverse<T>(x: i32) -> T\n-        // this is using ConvertTo as if it were \"ConvertTo<i64>\"\n+        // This is using ConvertTo as if it were \"ConvertTo<i64>\".\n         where i32: ConvertTo<T> {\n     x.convert()\n }\n@@ -470,15 +470,15 @@ impl Foo for OverrideDefault {\n \n     fn is_invalid(&self) -> bool {\n         println!(\"Called OverrideDefault.is_invalid!\");\n-        true // overrides the expected value of is_invalid()\n+        true // Overrides the expected value of `is_invalid()`.\n     }\n }\n \n let default = UseDefault;\n-assert!(!default.is_invalid()); // prints \"Called UseDefault.is_valid.\"\n+assert!(!default.is_invalid()); // Prints \"Called UseDefault.is_valid.\"\n \n let over = OverrideDefault;\n-assert!(over.is_invalid()); // prints \"Called OverrideDefault.is_invalid!\"\n+assert!(over.is_invalid()); // Prints \"Called OverrideDefault.is_invalid!\"\n ```\n \n # Inheritance"}, {"sha": "a272afa70bb1be3013a98d89123d725007e1ec4b", "filename": "src/doc/book/unsafe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Funsafe.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -12,7 +12,7 @@ four contexts. The first one is to mark a function as unsafe:\n \n ```rust\n unsafe fn danger_will_robinson() {\n-    // scary stuff\n+    // Scary stuff...\n }\n ```\n \n@@ -23,7 +23,7 @@ The second use of `unsafe` is an unsafe block:\n \n ```rust\n unsafe {\n-    // scary stuff\n+    // Scary stuff...\n }\n ```\n "}, {"sha": "54316649c715f3169b7e533413df92fbd833c23b", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -194,7 +194,7 @@ fn main() {\n         let y: i32 = 3;\n         println!(\"The value of x is {} and value of y is {}\", x, y);\n     }\n-    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work\n+    println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n }\n ```\n \n@@ -207,7 +207,7 @@ Instead we get this error:\n $ cargo build\n    Compiling hello v0.1.0 (file:///home/you/projects/hello_world)\n main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`? [E0425]\n-main.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work\n+main.rs:7     println!(\"The value of x is {} and value of y is {}\", x, y); // This won't work.\n                                                                        ^\n note: in expansion of format_args!\n <std macros>:2:25: 2:56 note: expansion site\n@@ -229,13 +229,13 @@ scope will override the previous binding.\n ```rust\n let x: i32 = 8;\n {\n-    println!(\"{}\", x); // Prints \"8\"\n+    println!(\"{}\", x); // Prints \"8\".\n     let x = 12;\n-    println!(\"{}\", x); // Prints \"12\"\n+    println!(\"{}\", x); // Prints \"12\".\n }\n-println!(\"{}\", x); // Prints \"8\"\n+println!(\"{}\", x); // Prints \"8\".\n let x =  42;\n-println!(\"{}\", x); // Prints \"42\"\n+println!(\"{}\", x); // Prints \"42\".\n ```\n \n Shadowing and mutable bindings may appear as two sides of the same coin, but\n@@ -249,8 +249,8 @@ by any means.\n ```rust\n let mut x: i32 = 1;\n x = 7;\n-let x = x; // x is now immutable and is bound to 7\n+let x = x; // `x` is now immutable and is bound to `7`.\n \n let y = 4;\n-let y = \"I can also be bound to text!\"; // y is now of a different type\n+let y = \"I can also be bound to text!\"; // `y` is now of a different type.\n ```"}, {"sha": "b948a54f44a5b62b38f87cb61d16ab6f3e25df24", "filename": "src/doc/book/vectors.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/28548db57d0acbc00ee80b43816953dbe31d53ba/src%2Fdoc%2Fbook%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvectors.md?ref=28548db57d0acbc00ee80b43816953dbe31d53ba", "patch": "@@ -17,7 +17,7 @@ situation, this is just convention.)\n There\u2019s an alternate form of `vec!` for repeating an initial value:\n \n ```rust\n-let v = vec![0; 10]; // ten zeroes\n+let v = vec![0; 10]; // A vector of ten zeroes.\n ```\n \n Vectors store their contents as contiguous arrays of `T` on the heap. This means\n@@ -46,10 +46,10 @@ let v = vec![1, 2, 3, 4, 5];\n let i: usize = 0;\n let j: i32 = 0;\n \n-// works\n+// Works:\n v[i];\n \n-// doesn\u2019t\n+// Doesn\u2019t:\n v[j];\n ```\n "}]}