{"sha": "23d1521684380a0a3099cb7439270cd650de36fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzZDE1MjE2ODQzODBhMGEzMDk5Y2I3NDM5MjcwY2Q2NTBkZTM2ZmI=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2017-06-08T05:49:54Z"}, "committer": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2017-06-29T12:23:33Z"}, "message": "Add unsized tuple coercions.", "tree": {"sha": "faa52647e9e113406bce7553d0b4e648b1b07647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa52647e9e113406bce7553d0b4e648b1b07647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23d1521684380a0a3099cb7439270cd650de36fb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJZVPFJAAoJEHynqF4EmoLoNIoQAIVIXnp5I07oBIDN+65Wo85a\neh1+dlVAeP3Wumt9lmUAwquBRhE7LBi/MZz+2/+/JreQd+icqdizYZJ8elIhn11n\n+MaX7lFOD+M8S0FYkv1azR4pEYoE3PRLPHUWUkqM9zFzIFNLIdcuJioLeKrnck1G\n+PeZUpxjx4pNaVITJZdwHHtHxDI5rL0j7nIVSU6Md9KRnsnGA2cDoibNYzvyckxl\nl3l1tjCDq1kkY8uPwf3n3Ita/pTh+YWQIAc2eEDdSjCe7nBXYnEOeoCEg9rp9tdv\nVs4ubZ+BN/O8y62OlCnLzrZZUHQgUigVDDah35Jxw9xBvSI5w5lrrwKrGiq62DTa\nHQx58Qjk3wx/JK02KVXkNWyf38J6oz0R46lfkfkCe2J3TUBtnJLTZbJ9fi/yqiBy\noyHiXII1SPc8OKoRJtB4ngtvNqw5McHTMgBr4TVGSTP/m/cFOXbe4k59vgkmHEiY\n6vLZcLRMLu1pS3k6uOHnHFvgxx30NRIkSGVSv0A+3NoL1/KEGhwE8oINFlMec/vJ\nBrrdMXmJwmP6DCR/SSoskR+w+FYR6jOPTRLSu0Kygu6Zk5rLKxDo8HSN9rYy+3Fo\nyZ01EWtKNlC+v0an8eWxBmYRGnlOKVDXqmDv3HjYV36Ae04ByL+hkXlvVhSAkwU0\nrtpG6Rj2MYgx2X+dpsgd\n=QciB\n-----END PGP SIGNATURE-----", "payload": "tree faa52647e9e113406bce7553d0b4e648b1b07647\nparent 17fca8b4604bc4cf89ac06292f6475614984edc9\nauthor Masaki Hara <ackie.h.gmai@gmail.com> 1496900994 +0900\ncommitter Masaki Hara <ackie.h.gmai@gmail.com> 1498739013 +0900\n\nAdd unsized tuple coercions.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23d1521684380a0a3099cb7439270cd650de36fb", "html_url": "https://github.com/rust-lang/rust/commit/23d1521684380a0a3099cb7439270cd650de36fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23d1521684380a0a3099cb7439270cd650de36fb/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17fca8b4604bc4cf89ac06292f6475614984edc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/17fca8b4604bc4cf89ac06292f6475614984edc9", "html_url": "https://github.com/rust-lang/rust/commit/17fca8b4604bc4cf89ac06292f6475614984edc9"}], "stats": {"total": 567, "additions": 549, "deletions": 18}, "files": [{"sha": "0bf0e21baaf93e2973ff6886bb1e6a6cd55dbf62", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -1060,7 +1060,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }\n             ObligationCauseCode::TupleElem => {\n-                err.note(\"tuple elements must have `Sized` type\");\n+                err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n                 err.note(&format!(\"required so that the projection `{}` is well-formed\","}, {"sha": "11169eefdaf879866985722dfaa9e6f896d4aeab", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -1651,6 +1651,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 def_id_a == def_id_b\n             }\n \n+            // (.., T) -> (.., U).\n+            (&ty::TyTuple(tys_a, _), &ty::TyTuple(tys_b, _)) => {\n+                tys_a.len() == tys_b.len()\n+            }\n+\n             _ => false\n         };\n \n@@ -2617,6 +2622,37 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     &[inner_target]));\n             }\n \n+            // (.., T) -> (.., U).\n+            (&ty::TyTuple(tys_a, _), &ty::TyTuple(tys_b, _)) => {\n+                assert_eq!(tys_a.len(), tys_b.len());\n+\n+                // The last field of the tuple has to exist.\n+                let (a_last, a_mid) = if let Some(x) = tys_a.split_last() {\n+                    x\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+                let b_last = tys_b.last().unwrap();\n+\n+                // Check that the source tuple with the target's\n+                // last element is a subtype of the target.\n+                let new_tuple = tcx.mk_tup(a_mid.iter().chain(Some(b_last)), false);\n+                let InferOk { obligations, .. } =\n+                    self.infcx.at(&obligation.cause, obligation.param_env)\n+                              .eq(target, new_tuple)\n+                              .map_err(|_| Unimplemented)?;\n+                self.inferred_obligations.extend(obligations);\n+\n+                // Construct the nested T: Unsize<U> predicate.\n+                nested.push(tcx.predicate_for_trait_def(\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.predicate.def_id(),\n+                    obligation.recursion_depth + 1,\n+                    a_last,\n+                    &[b_last]));\n+            }\n+\n             _ => bug!()\n         };\n "}, {"sha": "e1aa89078a33b5456973752d268e4422b2f01f0e", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -1220,12 +1220,16 @@ impl<'a, 'tcx> Layout {\n             }\n \n             ty::TyTuple(tys, _) => {\n-                // FIXME(camlorn): if we ever allow unsized tuples, this needs to be checked.\n-                // See the univariant case below to learn how.\n+                let kind = if tys.len() == 0 {\n+                    StructKind::AlwaysSizedUnivariant\n+                } else {\n+                    StructKind::MaybeUnsizedUnivariant\n+                };\n+\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(tcx, param_env))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &ReprOptions::default(), kind, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n "}, {"sha": "df4bbad3859f4ecc46623ed3b7bf30911dc814c4", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -317,15 +317,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  target: Ty<'tcx>)\n                                  -> (Ty<'tcx>, Ty<'tcx>) {\n         let (mut a, mut b) = (source, target);\n-        while let (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs)) = (&a.sty, &b.sty) {\n-            if a_def != b_def || !a_def.is_struct() {\n-                break;\n-            }\n-            match a_def.struct_variant().fields.last() {\n-                Some(f) => {\n-                    a = f.ty(self, a_substs);\n-                    b = f.ty(self, b_substs);\n-                }\n+        loop {\n+            match (&a.sty, &b.sty) {\n+                (&TyAdt(a_def, a_substs), &TyAdt(b_def, b_substs))\n+                        if a_def == b_def && a_def.is_struct() => {\n+                    if let Some(f) = a_def.struct_variant().fields.last() {\n+                        a = f.ty(self, a_substs);\n+                        b = f.ty(self, b_substs);\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                (&TyTuple(a_tys, _), &TyTuple(b_tys, _))\n+                        if a_tys.len() == b_tys.len() => {\n+                    if let Some(a_last) = a_tys.last() {\n+                        a = a_last;\n+                        b = b_tys.last().unwrap();\n+                    } else {\n+                        break;\n+                    }\n+                },\n                 _ => break,\n             }\n         }"}, {"sha": "c2f44c089a2d6a7f8cd7b0fcbffd817490e2b038", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -76,7 +76,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     }\n     assert!(!info.is_null());\n     match t.sty {\n-        ty::TyAdt(def, substs) => {\n+        ty::TyAdt(..) | ty::TyTuple(..) => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n             // Don't use size_of because it also rounds up to alignment, which we\n@@ -101,8 +101,14 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let last_field = def.struct_variant().fields.last().unwrap();\n-            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n+            let field_ty = match t.sty {\n+                ty::TyAdt(def, substs) => {\n+                    let last_field = def.struct_variant().fields.last().unwrap();\n+                    monomorphize::field_ty(bcx.tcx(), substs, last_field)\n+                },\n+                ty::TyTuple(tys, _) => tys.last().unwrap(),\n+                _ => unreachable!(),\n+            };\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding"}, {"sha": "3c089edf00130093a4b60cc26bbf293525fbd1c0", "filename": "src/test/compile-fail/dst-bad-assign-3.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-assign-3.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Forbid assignment into a dynamically sized type.\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+//~^ WARNING trait bounds are not (yet) enforced\n+\n+#[derive(PartialEq,Eq)]\n+struct Bar;\n+\n+#[derive(PartialEq,Eq)]\n+struct Bar1 {\n+    f: isize\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> isize;\n+}\n+\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+pub fn main() {\n+    // Assignment.\n+    let f5: &mut Fat<ToBar> = &mut (5, \"some str\", Bar1 {f :42});\n+    let z: Box<ToBar> = Box::new(Bar1 {f: 36});\n+    f5.2 = Bar1 {f: 36};\n+    //~^ ERROR mismatched types\n+    //~| expected type `ToBar`\n+    //~| found type `Bar1`\n+    //~| expected trait ToBar, found struct `Bar1`\n+    //~| ERROR `ToBar: std::marker::Sized` is not satisfied\n+}"}, {"sha": "722ff8f25d6102387bfbb3d504292bf52ef4f3a4", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -29,4 +29,16 @@ pub fn main() {\n     let f2: &Fat<Foo> = &f1;\n     let f3: &Fat<Bar> = f2;\n     //~^ ERROR `Foo: Bar` is not satisfied\n+\n+    // Tuple with a vec of isize.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1;\n+    let f3: &([usize],) = f2;\n+    //~^ ERROR mismatched types\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1;\n+    let f3: &(Bar,) = f2;\n+    //~^ ERROR `Foo: Bar` is not satisfied\n }"}, {"sha": "9e92f649b2d5696acd2d8d67fbddf0bed421eca6", "filename": "src/test/compile-fail/dst-bad-coerce2.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce2.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -28,4 +28,14 @@ pub fn main() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1;\n     let f3: &mut Fat<Bar> = f2; //~ ERROR mismatched types\n+\n+    // Tuple with a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1;\n+    let f3: &mut ([isize],) = f2; //~ ERROR mismatched types\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1;\n+    let f3: &mut (Bar,) = f2; //~ ERROR mismatched types\n }"}, {"sha": "4dedae9331bc3b78033861e89a3781047dacea11", "filename": "src/test/compile-fail/dst-bad-coerce3.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce3.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -28,6 +28,16 @@ fn baz<'a>() {\n     let f1 = Fat { ptr: Foo };\n     let f2: &Fat<Foo> = &f1; //~ ERROR `f1` does not live long enough\n     let f3: &'a Fat<Bar> = f2;\n+\n+    // Tuple with a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    let f2: &([isize; 3],) = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a ([isize],) = f2;\n+\n+    // Tuple with a trait.\n+    let f1 = (Foo,);\n+    let f2: &(Foo,) = &f1; //~ ERROR `f1` does not live long enough\n+    let f3: &'a (Bar,) = f2;\n }\n \n pub fn main() {"}, {"sha": "2e78108a8dea0401cb6fa282286c091962d706f8", "filename": "src/test/compile-fail/dst-bad-coerce4.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce4.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -22,4 +22,12 @@ pub fn main() {\n     //~| expected type `&Fat<[isize; 3]>`\n     //~| found type `&Fat<[isize]>`\n     //~| expected array of 3 elements, found slice\n+\n+    // Tuple with a vec of isizes.\n+    let f1: &([isize],) = &([1, 2, 3],);\n+    let f2: &([isize; 3],) = f1;\n+    //~^ ERROR mismatched types\n+    //~| expected type `&([isize; 3],)`\n+    //~| found type `&([isize],)`\n+    //~| expected array of 3 elements, found slice\n }"}, {"sha": "831afd27153aea443ed4555d2d969fe5788e3b71", "filename": "src/test/compile-fail/dst-bad-deep-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-deep-2.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Try to initialise a DST struct where the lost information is deeply nested.\n+// This is an error because it requires an unsized rvalue. This is a problem\n+// because it would require stack allocation of an unsized temporary (*g in the\n+// test).\n+\n+pub fn main() {\n+    let f: ([isize; 3],) = ([5, 6, 7],);\n+    let g: &([isize],) = &f;\n+    let h: &(([isize],),) = &(*g,);\n+    //~^ ERROR `[isize]: std::marker::Sized` is not satisfied\n+}"}, {"sha": "00bfebb3f1e242549132d8b9795212e8af2613b5", "filename": "src/test/run-pass-valgrind/dst-dtor-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-1.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -28,7 +28,8 @@ struct Fat<T: ?Sized> {\n \n pub fn main() {\n     {\n-        let _x: Box<Fat<Trait>> = Box::<Fat<Foo>>::new(Fat { f: Foo });\n+        let _x: Box<(i32, Fat<Trait>)> =\n+            Box::<(i32, Fat<Foo>)>::new((42, Fat { f: Foo }));\n     }\n     unsafe {\n         assert!(DROP_RAN);"}, {"sha": "fa0c6c0322539f917e4b5cfa9094ef9976fe6a87", "filename": "src/test/run-pass-valgrind/dst-dtor-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fdst-dtor-2.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -25,7 +25,8 @@ struct Fat<T: ?Sized> {\n \n pub fn main() {\n     {\n-        let _x: Box<Fat<[Foo]>> = Box::<Fat<[Foo; 3]>>::new(Fat { f: [Foo, Foo, Foo] });\n+        let _x: Box<(Fat<[Foo]>,)> =\n+            Box::<(Fat<[Foo; 3]>,)>::new((Fat { f: [Foo, Foo, Foo] },));\n     }\n     unsafe {\n         assert_eq!(DROP_RAN, 3);"}, {"sha": "bd6ad9207adcd43da2b00f07b60065e7f73eef66", "filename": "src/test/run-pass/dst-irrefutable-bind.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-irrefutable-bind.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -21,4 +21,14 @@ fn main() {\n     let slice = &[1,2,3];\n     let x = Test(&slice);\n     let Test(&_slice) = x;\n+\n+\n+    let x = (10, [1,2,3]);\n+    let x : &(i32, [i32]) = &x;\n+\n+    let & ref _y = x;\n+\n+    let slice = &[1,2,3];\n+    let x = (10, &slice);\n+    let (_, &_slice) = x;\n }"}, {"sha": "c82cbd75044fbaab6c6df0fc86d3a84f9fb5890c", "filename": "src/test/run-pass/dst-raw.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -45,6 +45,14 @@ pub fn main() {\n     };\n     assert_eq!(r, 42);\n \n+    // raw DST tuple\n+    let p = (A { f: 42 },);\n+    let o: *const (Trait,) = &p;\n+    let r = unsafe {\n+        (&*o).0.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n     // raw slice\n     let a: *const [_] = &[1, 2, 3];\n     unsafe {\n@@ -72,6 +80,15 @@ pub fn main() {\n         assert_eq!(len, 3);\n     }\n \n+    // raw DST tuple with slice\n+    let c: *const ([_],) = &([1, 2, 3],);\n+    unsafe {\n+        let b = (&*c).0[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).0.len();\n+        assert_eq!(len, 3);\n+    }\n+\n     // all of the above with *mut\n     let mut x = A { f: 42 };\n     let z: *mut Trait = &mut x;\n@@ -87,6 +104,13 @@ pub fn main() {\n     };\n     assert_eq!(r, 42);\n \n+    let mut p = (A { f: 42 },);\n+    let o: *mut (Trait,) = &mut p;\n+    let r = unsafe {\n+        (&*o).0.foo()\n+    };\n+    assert_eq!(r, 42);\n+\n     let a: *mut [_] = &mut [1, 2, 3];\n     unsafe {\n         let b = (*a)[2];\n@@ -110,4 +134,12 @@ pub fn main() {\n         let len = (&*c).f.len();\n         assert_eq!(len, 3);\n     }\n+\n+    let c: *mut ([_],) = &mut ([1, 2, 3],);\n+    unsafe {\n+        let b = (&*c).0[0];\n+        assert_eq!(b, 1);\n+        let len = (&*c).0.len();\n+        assert_eq!(len, 3);\n+    }\n }"}, {"sha": "ab60e95c74e8191e94f9eebb581382ce94af993f", "filename": "src/test/run-pass/dst-trait-tuple.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-trait-tuple.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unused_features)]\n+#![feature(box_syntax)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+struct Bar1 {\n+    f: isize\n+}\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+    fn to_val(&self) -> isize;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+    fn to_val(&self) -> isize {\n+        0\n+    }\n+}\n+impl ToBar for Bar1 {\n+    fn to_bar(&self) -> Bar {\n+        Bar\n+    }\n+    fn to_val(&self) -> isize {\n+        self.f\n+    }\n+}\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<ToBar>) {\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!(x.2.to_bar(), Bar);\n+    assert_eq!(x.2.to_val(), 42);\n+\n+    let y = &x.2;\n+    assert_eq!(y.to_bar(), Bar);\n+    assert_eq!(y.to_val(), 42);\n+}\n+\n+fn bar(x: &ToBar) {\n+    assert_eq!(x.to_bar(), Bar);\n+    assert_eq!(x.to_val(), 42);\n+}\n+\n+fn baz(x: &Fat<Fat<ToBar>>) {\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!((x.2).0, 8);\n+    assert_eq!((x.2).1, \"deep str\");\n+    assert_eq!((x.2).2.to_bar(), Bar);\n+    assert_eq!((x.2).2.to_val(), 42);\n+\n+    let y = &(x.2).2;\n+    assert_eq!(y.to_bar(), Bar);\n+    assert_eq!(y.to_val(), 42);\n+\n+}\n+\n+pub fn main() {\n+    let f1 = (5, \"some str\", Bar1 {f :42});\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<ToBar> = f2;\n+    foo(f3);\n+    let f4: &Fat<ToBar> = &f1;\n+    foo(f4);\n+    let f5: &Fat<ToBar> = &(5, \"some str\", Bar1 {f :42});\n+    foo(f5);\n+\n+    // Zero size object.\n+    let f6: &Fat<ToBar> = &(5, \"some str\", Bar);\n+    assert_eq!(f6.2.to_bar(), Bar);\n+\n+    // &*\n+    //\n+    let f7: Box<ToBar> = Box::new(Bar1 {f :42});\n+    bar(&*f7);\n+\n+    // Deep nesting\n+    let f1 = (5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    baz(&f1);\n+    let f2 = &f1;\n+    baz(f2);\n+    let f3: &Fat<Fat<ToBar>> = f2;\n+    baz(f3);\n+    let f4: &Fat<Fat<ToBar>> = &f1;\n+    baz(f4);\n+    let f5: &Fat<Fat<ToBar>> = &(5, \"some str\", (8, \"deep str\", Bar1 {f :42}));\n+    baz(f5);\n+}"}, {"sha": "d3901a7555fd70ef53f56284e370904e7b3eebb1", "filename": "src/test/run-pass/dst-tuple-sole.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-tuple-sole.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// As dst-tuple.rs, but the unsized field is the only field in the tuple.\n+\n+\n+type Fat<T: ?Sized> = (T,);\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.0;\n+    assert_eq!(x.0.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.0[1], 2);\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.0;\n+    let bar = Bar;\n+    assert_eq!(x.0.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.0[1].to_bar(), bar);\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = ([1, 2, 3],);\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &([1, 2, 3],);\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = ([bar, bar, bar],);\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &([bar, bar, bar],);\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut ([1, 2, 3],);\n+    f5.0[1] = 34;\n+    assert_eq!(f5.0[0], 1);\n+    assert_eq!(f5.0[1], 34);\n+    assert_eq!(f5.0[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &([],);\n+    assert!(f5.0.is_empty());\n+    let f5: &Fat<[Bar]> = &([],);\n+    assert!(f5.0.is_empty());\n+}"}, {"sha": "130294feb6ca511ea24e67ce4d922950c84f773e", "filename": "src/test/run-pass/dst-tuple.rs", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23d1521684380a0a3099cb7439270cd650de36fb/src%2Ftest%2Frun-pass%2Fdst-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-tuple.rs?ref=23d1521684380a0a3099cb7439270cd650de36fb", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+#![allow(unknown_features)]\n+#![feature(box_syntax)]\n+\n+type Fat<T: ?Sized> = (isize, &'static str, T);\n+\n+// x is a fat pointer\n+fn foo(x: &Fat<[isize]>) {\n+    let y = &x.2;\n+    assert_eq!(x.2.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!(x.2[1], 2);\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+}\n+\n+fn foo2<T:ToBar>(x: &Fat<[T]>) {\n+    let y = &x.2;\n+    let bar = Bar;\n+    assert_eq!(x.2.len(), 3);\n+    assert_eq!(y[0].to_bar(), bar);\n+    assert_eq!(x.2[1].to_bar(), bar);\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+}\n+\n+fn foo3(x: &Fat<Fat<[isize]>>) {\n+    let y = &(x.2).2;\n+    assert_eq!(x.0, 5);\n+    assert_eq!(x.1, \"some str\");\n+    assert_eq!((x.2).0, 8);\n+    assert_eq!((x.2).1, \"deep str\");\n+    assert_eq!((x.2).2.len(), 3);\n+    assert_eq!(y[0], 1);\n+    assert_eq!((x.2).2[1], 2);\n+}\n+\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Bar;\n+\n+trait ToBar {\n+    fn to_bar(&self) -> Bar;\n+}\n+\n+impl ToBar for Bar {\n+    fn to_bar(&self) -> Bar {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    // With a vec of ints.\n+    let f1 = (5, \"some str\", [1, 2, 3]);\n+    foo(&f1);\n+    let f2 = &f1;\n+    foo(f2);\n+    let f3: &Fat<[isize]> = f2;\n+    foo(f3);\n+    let f4: &Fat<[isize]> = &f1;\n+    foo(f4);\n+    let f5: &Fat<[isize]> = &(5, \"some str\", [1, 2, 3]);\n+    foo(f5);\n+\n+    // With a vec of Bars.\n+    let bar = Bar;\n+    let f1 = (5, \"some str\", [bar, bar, bar]);\n+    foo2(&f1);\n+    let f2 = &f1;\n+    foo2(f2);\n+    let f3: &Fat<[Bar]> = f2;\n+    foo2(f3);\n+    let f4: &Fat<[Bar]> = &f1;\n+    foo2(f4);\n+    let f5: &Fat<[Bar]> = &(5, \"some str\", [bar, bar, bar]);\n+    foo2(f5);\n+\n+    // Assignment.\n+    let f5: &mut Fat<[isize]> = &mut (5, \"some str\", [1, 2, 3]);\n+    f5.2[1] = 34;\n+    assert_eq!(f5.2[0], 1);\n+    assert_eq!(f5.2[1], 34);\n+    assert_eq!(f5.2[2], 3);\n+\n+    // Zero size vec.\n+    let f5: &Fat<[isize]> = &(5, \"some str\", []);\n+    assert!(f5.2.is_empty());\n+    let f5: &Fat<[Bar]> = &(5, \"some str\", []);\n+    assert!(f5.2.is_empty());\n+\n+    // Deeply nested.\n+    let f1 = (5, \"some str\", (8, \"deep str\", [1, 2, 3]));\n+    foo3(&f1);\n+    let f2 = &f1;\n+    foo3(f2);\n+    let f3: &Fat<Fat<[isize]>> = f2;\n+    foo3(f3);\n+    let f4: &Fat<Fat<[isize]>> = &f1;\n+    foo3(f4);\n+    let f5: &Fat<Fat<[isize]>> = &(5, \"some str\", (8, \"deep str\", [1, 2, 3]));\n+    foo3(f5);\n+\n+    // Box.\n+    let f1 = Box::new([1, 2, 3]);\n+    assert_eq!((*f1)[1], 2);\n+    let f2: Box<[isize]> = f1;\n+    assert_eq!((*f2)[1], 2);\n+\n+    // Nested Box.\n+    let f1 : Box<Fat<[isize; 3]>> = box (5, \"some str\", [1, 2, 3]);\n+    foo(&*f1);\n+    let f2 : Box<Fat<[isize]>> = f1;\n+    foo(&*f2);\n+\n+    let f3 : Box<Fat<[isize]>> =\n+        Box::<Fat<[_; 3]>>::new((5, \"some str\", [1, 2, 3]));\n+    foo(&*f3);\n+}"}]}