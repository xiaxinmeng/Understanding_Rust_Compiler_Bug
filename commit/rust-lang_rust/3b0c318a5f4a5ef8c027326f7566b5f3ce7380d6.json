{"sha": "3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMGMzMThhNWY0YTVlZjhjMDI3MzI2Zjc1NjZiNWYzY2U3MzgwZDY=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2016-09-26T20:44:01Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2016-09-26T20:44:01Z"}, "message": "Make spreading use `Option<Local>`", "tree": {"sha": "ed9fe37dab01656b78775c36ee4f94c874133214", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed9fe37dab01656b78775c36ee4f94c874133214"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "html_url": "https://github.com/rust-lang/rust/commit/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "894c083c40a84d92f137bf1b354b26aa63c9f515", "url": "https://api.github.com/repos/rust-lang/rust/commits/894c083c40a84d92f137bf1b354b26aa63c9f515", "html_url": "https://github.com/rust-lang/rust/commit/894c083c40a84d92f137bf1b354b26aa63c9f515"}], "stats": {"total": 111, "additions": 57, "deletions": 54}, "files": [{"sha": "128d0d21da597c72c9e6d882a862ee5cb42767be", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "patch": "@@ -95,11 +95,11 @@ pub struct Mir<'tcx> {\n     /// the first argument is either the closure or a reference to it.\n     pub upvar_decls: Vec<UpvarDecl>,\n \n-    /// A boolean indicating whether the last argument (which must be a tuple)\n-    /// is passed as its individual components at the LLVM level.\n+    /// Mark an argument local (which must be a tuple) as getting passed as\n+    /// its individual components at the LLVM level.\n     ///\n     /// This is used for the \"rust-call\" ABI.\n-    pub spread_last_arg: bool,\n+    pub spread_arg: Option<Local>,\n \n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n@@ -134,7 +134,7 @@ impl<'tcx> Mir<'tcx> {\n             local_decls: local_decls,\n             arg_count: arg_count,\n             upvar_decls: upvar_decls,\n-            spread_last_arg: false,\n+            spread_arg: None,\n             span: span,\n             cache: Cache::new()\n         }"}, {"sha": "353aaaa45e18bed2d9f9bc9c9794ac37404edf55", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "patch": "@@ -187,11 +187,11 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     }));\n     assert_eq!(block, builder.return_block());\n \n-    let mut spread_last_arg = false;\n+    let mut spread_arg = None;\n     match tcx.node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {\n             // RustCall pseudo-ABI untuples the last argument.\n-            spread_last_arg = true;\n+            spread_arg = Some(Local::new(arguments.len()));\n         }\n         _ => {}\n     }\n@@ -221,7 +221,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     });\n \n     let (mut mir, aux) = builder.finish(upvar_decls, return_ty);\n-    mir.spread_last_arg = spread_last_arg;\n+    mir.spread_arg = spread_arg;\n     (mir, aux)\n }\n "}, {"sha": "2bd258059ad25a4a0b56fd96234c3fa647accbe2", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 50, "deletions": 47, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=3b0c318a5f4a5ef8c027326f7566b5f3ce7380d6", "patch": "@@ -359,57 +359,60 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n     mir.arg_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n         let arg_ty = bcx.monomorphize(&arg_decl.ty);\n-        if mir.spread_last_arg && arg_index == mir.arg_count - 1 {\n-            // This argument (e.g. the last argument in the \"rust-call\" ABI)\n-            // is a tuple that was spread at the ABI level and now we have\n-            // to reconstruct it into a tuple local variable, from multiple\n-            // individual LLVM function arguments.\n-\n-            let tupled_arg_tys = match arg_ty.sty {\n-                ty::TyTuple(ref tys) => tys,\n-                _ => bug!(\"spread argument isn't a tuple?!\")\n-            };\n \n-            let lltuplety = type_of::type_of(bcx.ccx(), arg_ty);\n-            let lltemp = bcx.with_block(|bcx| {\n-                base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n-            });\n-            for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n-                let dst = bcx.struct_gep(lltemp, i);\n-                let arg = &fcx.fn_ty.args[idx];\n-                idx += 1;\n-                if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n-                    // We pass fat pointers as two words, but inside the tuple\n-                    // they are the two sub-fields of a single aggregate field.\n-                    let meta = &fcx.fn_ty.args[idx];\n+        if let Some(spread_local) = mir.spread_arg {\n+            if local == spread_local {\n+                // This argument (e.g. the last argument in the \"rust-call\" ABI)\n+                // is a tuple that was spread at the ABI level and now we have\n+                // to reconstruct it into a tuple local variable, from multiple\n+                // individual LLVM function arguments.\n+\n+                let tupled_arg_tys = match arg_ty.sty {\n+                    ty::TyTuple(ref tys) => tys,\n+                    _ => bug!(\"spread argument isn't a tuple?!\")\n+                };\n+\n+                let lltuplety = type_of::type_of(bcx.ccx(), arg_ty);\n+                let lltemp = bcx.with_block(|bcx| {\n+                    base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n+                });\n+                for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                    let dst = bcx.struct_gep(lltemp, i);\n+                    let arg = &fcx.fn_ty.args[idx];\n                     idx += 1;\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n-                    meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n-                } else {\n-                    arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n-                }\n+                    if common::type_is_fat_ptr(tcx, tupled_arg_ty) {\n+                        // We pass fat pointers as two words, but inside the tuple\n+                        // they are the two sub-fields of a single aggregate field.\n+                        let meta = &fcx.fn_ty.args[idx];\n+                        idx += 1;\n+                        arg.store_fn_arg(bcx, &mut llarg_idx, get_dataptr(bcx, dst));\n+                        meta.store_fn_arg(bcx, &mut llarg_idx, get_meta(bcx, dst));\n+                    } else {\n+                        arg.store_fn_arg(bcx, &mut llarg_idx, dst);\n+                    }\n \n-                bcx.with_block(|bcx| arg_scope.map(|scope| {\n-                    let byte_offset_of_var_in_tuple =\n-                        machine::llelement_offset(bcx.ccx(), lltuplety, i);\n-\n-                    let ops = unsafe {\n-                        [llvm::LLVMRustDIBuilderCreateOpDeref(),\n-                         llvm::LLVMRustDIBuilderCreateOpPlus(),\n-                         byte_offset_of_var_in_tuple as i64]\n-                    };\n-\n-                    let variable_access = VariableAccess::IndirectVariable {\n-                        alloca: lltemp,\n-                        address_operations: &ops\n-                    };\n-                    declare_local(bcx, keywords::Invalid.name(),\n-                                  tupled_arg_ty, scope, variable_access,\n-                                  VariableKind::ArgumentVariable(arg_index + i + 1),\n-                                  bcx.fcx().span.unwrap_or(DUMMY_SP));\n-                }));\n+                    bcx.with_block(|bcx| arg_scope.map(|scope| {\n+                        let byte_offset_of_var_in_tuple =\n+                            machine::llelement_offset(bcx.ccx(), lltuplety, i);\n+\n+                        let ops = unsafe {\n+                            [llvm::LLVMRustDIBuilderCreateOpDeref(),\n+                             llvm::LLVMRustDIBuilderCreateOpPlus(),\n+                             byte_offset_of_var_in_tuple as i64]\n+                        };\n+\n+                        let variable_access = VariableAccess::IndirectVariable {\n+                            alloca: lltemp,\n+                            address_operations: &ops\n+                        };\n+                        declare_local(bcx, keywords::Invalid.name(),\n+                                      tupled_arg_ty, scope, variable_access,\n+                                      VariableKind::ArgumentVariable(arg_index + i + 1),\n+                                      bcx.fcx().span.unwrap_or(DUMMY_SP));\n+                    }));\n+                }\n+                return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n             }\n-            return LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(arg_ty)));\n         }\n \n         let arg = &fcx.fn_ty.args[idx];"}]}