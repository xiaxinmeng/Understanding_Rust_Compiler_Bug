{"sha": "87bacf22ec93a9479dbd829de5d1917c16b17255", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YmFjZjIyZWM5M2E5NDc5ZGJkODI5ZGU1ZDE5MTdjMTZiMTcyNTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-09T21:28:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-09T21:28:58Z"}, "message": "Auto merge of #81132 - bugadani:map-prealloc, r=matthewjasper\n\nBorrowck: refactor visited map to a bitset\n\nThis PR refactors `Borrows`  and the `precompute_borrows_out_of_scope` function so that this initial phase has a much reduced memory pressure. This is achieved by reducing what is stored on the heap, and also reusing heap memory as much as possible.", "tree": {"sha": "128f7a9d7f29f84887a232267d124784eacedfb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/128f7a9d7f29f84887a232267d124784eacedfb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87bacf22ec93a9479dbd829de5d1917c16b17255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87bacf22ec93a9479dbd829de5d1917c16b17255", "html_url": "https://github.com/rust-lang/rust/commit/87bacf22ec93a9479dbd829de5d1917c16b17255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87bacf22ec93a9479dbd829de5d1917c16b17255/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "097bc6a84f2280a889b9ab4b544f27851a978927", "url": "https://api.github.com/repos/rust-lang/rust/commits/097bc6a84f2280a889b9ab4b544f27851a978927", "html_url": "https://github.com/rust-lang/rust/commit/097bc6a84f2280a889b9ab4b544f27851a978927"}, {"sha": "5271c628be9eda5f0a4e3a5700d057ce95cf9da8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5271c628be9eda5f0a4e3a5700d057ce95cf9da8", "html_url": "https://github.com/rust-lang/rust/commit/5271c628be9eda5f0a4e3a5700d057ce95cf9da8"}], "stats": {"total": 189, "additions": 96, "deletions": 93}, "files": [{"sha": "7d47b26e2d5d5f3a509199c35a14023d22dcbde0", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87bacf22ec93a9479dbd829de5d1917c16b17255/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/87bacf22ec93a9479dbd829de5d1917c16b17255/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=87bacf22ec93a9479dbd829de5d1917c16b17255", "patch": "@@ -5395,7 +5395,7 @@ dependencies = [\n  \"chrono\",\n  \"lazy_static\",\n  \"matchers\",\n- \"parking_lot 0.11.0\",\n+ \"parking_lot 0.9.0\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\","}, {"sha": "0bd0a4060b5999360f70a355abe2a6c9b7d7c48e", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87bacf22ec93a9479dbd829de5d1917c16b17255/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87bacf22ec93a9479dbd829de5d1917c16b17255/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=87bacf22ec93a9479dbd829de5d1917c16b17255", "patch": "@@ -243,7 +243,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let regioncx = Rc::new(regioncx);\n \n-    let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n+    let flow_borrows = Borrows::new(tcx, &body, &regioncx, &borrow_set)\n         .into_engine(tcx, &body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n@@ -287,7 +287,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n                 regioncx: regioncx.clone(),\n                 used_mut: Default::default(),\n                 used_mut_upvars: SmallVec::new(),\n-                borrow_set: borrow_set.clone(),\n+                borrow_set: Rc::clone(&borrow_set),\n                 dominators,\n                 upvars: Vec::new(),\n                 local_names: IndexVec::from_elem(None, &promoted_body.local_decls),\n@@ -317,10 +317,10 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n-        regioncx,\n+        regioncx: Rc::clone(&regioncx),\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n-        borrow_set,\n+        borrow_set: Rc::clone(&borrow_set),\n         dominators,\n         upvars,\n         local_names,"}, {"sha": "b149ffa9667a3ef0b1fcbe9747289d616fd5f6be", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 91, "deletions": 88, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/87bacf22ec93a9479dbd829de5d1917c16b17255/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87bacf22ec93a9479dbd829de5d1917c16b17255/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=87bacf22ec93a9479dbd829de5d1917c16b17255", "patch": "@@ -11,7 +11,6 @@ use crate::borrow_check::{\n use crate::dataflow::{self, fmt::DebugWithContext, GenKill};\n \n use std::fmt;\n-use std::rc::Rc;\n \n rustc_index::newtype_index! {\n     pub struct BorrowIndex {\n@@ -30,132 +29,136 @@ pub struct Borrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n \n-    borrow_set: Rc<BorrowSet<'tcx>>,\n+    borrow_set: &'a BorrowSet<'tcx>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n-\n-    /// NLL region inference context with which NLL queries should be resolved\n-    _nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n }\n \n struct StackEntry {\n     bb: mir::BasicBlock,\n     lo: usize,\n     hi: usize,\n-    first_part_only: bool,\n }\n \n-fn precompute_borrows_out_of_scope<'tcx>(\n-    body: &Body<'tcx>,\n-    regioncx: &Rc<RegionInferenceContext<'tcx>>,\n-    borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n-    borrow_index: BorrowIndex,\n-    borrow_region: RegionVid,\n-    location: Location,\n-) {\n-    // We visit one BB at a time. The complication is that we may start in the\n-    // middle of the first BB visited (the one containing `location`), in which\n-    // case we may have to later on process the first part of that BB if there\n-    // is a path back to its start.\n-\n-    // For visited BBs, we record the index of the first statement processed.\n-    // (In fully processed BBs this index is 0.) Note also that we add BBs to\n-    // `visited` once they are added to `stack`, before they are actually\n-    // processed, because this avoids the need to look them up again on\n-    // completion.\n-    let mut visited = FxHashMap::default();\n-    visited.insert(location.block, location.statement_index);\n-\n-    let mut stack = vec![];\n-    stack.push(StackEntry {\n-        bb: location.block,\n-        lo: location.statement_index,\n-        hi: body[location.block].statements.len(),\n-        first_part_only: false,\n-    });\n-\n-    while let Some(StackEntry { bb, lo, hi, first_part_only }) = stack.pop() {\n-        let mut finished_early = first_part_only;\n-        for i in lo..=hi {\n-            let location = Location { block: bb, statement_index: i };\n-            // If region does not contain a point at the location, then add to list and skip\n-            // successor locations.\n-            if !regioncx.region_contains(borrow_region, location) {\n-                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-                borrows_out_of_scope_at_location.entry(location).or_default().push(borrow_index);\n-                finished_early = true;\n-                break;\n-            }\n+struct OutOfScopePrecomputer<'a, 'tcx> {\n+    visited: BitSet<mir::BasicBlock>,\n+    visit_stack: Vec<StackEntry>,\n+    body: &'a Body<'tcx>,\n+    regioncx: &'a RegionInferenceContext<'tcx>,\n+    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n+}\n+\n+impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n+    fn new(body: &'a Body<'tcx>, regioncx: &'a RegionInferenceContext<'tcx>) -> Self {\n+        OutOfScopePrecomputer {\n+            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            visit_stack: vec![],\n+            body,\n+            regioncx,\n+            borrows_out_of_scope_at_location: FxHashMap::default(),\n         }\n+    }\n+}\n \n-        if !finished_early {\n-            // Add successor BBs to the work list, if necessary.\n-            let bb_data = &body[bb];\n-            assert!(hi == bb_data.statements.len());\n-            for &succ_bb in bb_data.terminator().successors() {\n-                visited\n-                    .entry(succ_bb)\n-                    .and_modify(|lo| {\n-                        // `succ_bb` has been seen before. If it wasn't\n-                        // fully processed, add its first part to `stack`\n-                        // for processing.\n-                        if *lo > 0 {\n-                            stack.push(StackEntry {\n+impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n+    fn precompute_borrows_out_of_scope(\n+        &mut self,\n+        borrow_index: BorrowIndex,\n+        borrow_region: RegionVid,\n+        location: Location,\n+    ) {\n+        // We visit one BB at a time. The complication is that we may start in the\n+        // middle of the first BB visited (the one containing `location`), in which\n+        // case we may have to later on process the first part of that BB if there\n+        // is a path back to its start.\n+\n+        // For visited BBs, we record the index of the first statement processed.\n+        // (In fully processed BBs this index is 0.) Note also that we add BBs to\n+        // `visited` once they are added to `stack`, before they are actually\n+        // processed, because this avoids the need to look them up again on\n+        // completion.\n+        self.visited.insert(location.block);\n+\n+        let mut first_lo = location.statement_index;\n+        let first_hi = self.body[location.block].statements.len();\n+\n+        self.visit_stack.push(StackEntry { bb: location.block, lo: first_lo, hi: first_hi });\n+\n+        while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n+            // If we process the first part of the first basic block (i.e. we encounter that block\n+            // for the second time), we no longer have to visit its successors again.\n+            let mut finished_early = bb == location.block && hi != first_hi;\n+            for i in lo..=hi {\n+                let location = Location { block: bb, statement_index: i };\n+                // If region does not contain a point at the location, then add to list and skip\n+                // successor locations.\n+                if !self.regioncx.region_contains(borrow_region, location) {\n+                    debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n+                    self.borrows_out_of_scope_at_location\n+                        .entry(location)\n+                        .or_default()\n+                        .push(borrow_index);\n+                    finished_early = true;\n+                    break;\n+                }\n+            }\n+\n+            if !finished_early {\n+                // Add successor BBs to the work list, if necessary.\n+                let bb_data = &self.body[bb];\n+                debug_assert!(hi == bb_data.statements.len());\n+                for &succ_bb in bb_data.terminator().successors() {\n+                    if self.visited.insert(succ_bb) == false {\n+                        if succ_bb == location.block && first_lo > 0 {\n+                            // `succ_bb` has been seen before. If it wasn't\n+                            // fully processed, add its first part to `stack`\n+                            // for processing.\n+                            self.visit_stack.push(StackEntry {\n                                 bb: succ_bb,\n                                 lo: 0,\n-                                hi: *lo - 1,\n-                                first_part_only: true,\n+                                hi: first_lo - 1,\n                             });\n+\n+                            // And update this entry with 0, to represent the\n+                            // whole BB being processed.\n+                            first_lo = 0;\n                         }\n-                        // And update this entry with 0, to represent the\n-                        // whole BB being processed.\n-                        *lo = 0;\n-                    })\n-                    .or_insert_with(|| {\n+                    } else {\n                         // succ_bb hasn't been seen before. Add it to\n                         // `stack` for processing.\n-                        stack.push(StackEntry {\n+                        self.visit_stack.push(StackEntry {\n                             bb: succ_bb,\n                             lo: 0,\n-                            hi: body[succ_bb].statements.len(),\n-                            first_part_only: false,\n+                            hi: self.body[succ_bb].statements.len(),\n                         });\n-                        // Insert 0 for this BB, to represent the whole BB\n-                        // being processed.\n-                        0\n-                    });\n+                    }\n+                }\n             }\n         }\n+\n+        self.visited.clear();\n     }\n }\n \n impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n-        nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n-        borrow_set: &Rc<BorrowSet<'tcx>>,\n+        nonlexical_regioncx: &'a RegionInferenceContext<'tcx>,\n+        borrow_set: &'a BorrowSet<'tcx>,\n     ) -> Self {\n-        let mut borrows_out_of_scope_at_location = FxHashMap::default();\n+        let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx);\n         for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n             let borrow_region = borrow_data.region.to_region_vid();\n             let location = borrow_data.reserve_location;\n \n-            precompute_borrows_out_of_scope(\n-                body,\n-                &nonlexical_regioncx,\n-                &mut borrows_out_of_scope_at_location,\n-                borrow_index,\n-                borrow_region,\n-                location,\n-            );\n+            prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);\n         }\n \n         Borrows {\n             tcx,\n             body,\n-            borrow_set: borrow_set.clone(),\n-            borrows_out_of_scope_at_location,\n-            _nonlexical_regioncx: nonlexical_regioncx,\n+            borrow_set,\n+            borrows_out_of_scope_at_location: prec.borrows_out_of_scope_at_location,\n         }\n     }\n "}]}