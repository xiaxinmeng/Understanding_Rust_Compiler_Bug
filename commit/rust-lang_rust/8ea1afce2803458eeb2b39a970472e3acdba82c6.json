{"sha": "8ea1afce2803458eeb2b39a970472e3acdba82c6", "node_id": "C_kwDOAAsO6NoAKDhlYTFhZmNlMjgwMzQ1OGVlYjJiMzlhOTcwNDcyZTNhY2RiYTgyYzY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-28T14:22:12Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-28T14:32:26Z"}, "message": "Simplify", "tree": {"sha": "34e0cfd4a5252112f9195d7d4e1b0ffe4a82c6fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e0cfd4a5252112f9195d7d4e1b0ffe4a82c6fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ea1afce2803458eeb2b39a970472e3acdba82c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ea1afce2803458eeb2b39a970472e3acdba82c6", "html_url": "https://github.com/rust-lang/rust/commit/8ea1afce2803458eeb2b39a970472e3acdba82c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ea1afce2803458eeb2b39a970472e3acdba82c6/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "284c1741d6536be6e7d4d4d252c424b90d6f1e45", "url": "https://api.github.com/repos/rust-lang/rust/commits/284c1741d6536be6e7d4d4d252c424b90d6f1e45", "html_url": "https://github.com/rust-lang/rust/commit/284c1741d6536be6e7d4d4d252c424b90d6f1e45"}], "stats": {"total": 392, "additions": 196, "deletions": 196}, "files": [{"sha": "c75627e0f7a0f650f7ace227d6718ed6a42ababb", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -151,7 +151,7 @@ impl CoerceMany {\n             if let Some(id) = expr {\n                 ctx.result.type_mismatches.insert(\n                     id.into(),\n-                    TypeMismatch { expected: self.merged_ty().clone(), actual: expr_ty.clone() },\n+                    TypeMismatch { expected: self.merged_ty(), actual: expr_ty.clone() },\n                 );\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);"}, {"sha": "b524837abbb6e990a7a9d9e06b7af16e95174f3c", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -331,7 +331,7 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n                 let prev_ret_coercion =\n-                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty.clone())));\n+                    mem::replace(&mut self.return_coercion, Some(CoerceMany::new(ret_ty)));\n                 let prev_resume_yield_tys =\n                     mem::replace(&mut self.resume_yield_tys, resume_yield_tys);\n \n@@ -402,7 +402,7 @@ impl<'a> InferenceContext<'a> {\n                                     .push(callee_ty.clone())\n                                     .push(TyBuilder::tuple_with(params.iter().cloned()))\n                                     .build();\n-                                self.write_method_resolution(tgt_expr, func, subst.clone());\n+                                self.write_method_resolution(tgt_expr, func, subst)\n                             }\n                         }\n                         self.write_expr_adj(*callee, adjustments);\n@@ -803,7 +803,7 @@ impl<'a> InferenceContext<'a> {\n                             .push(self_ty.clone())\n                             .push(index_ty.clone())\n                             .build();\n-                        self.write_method_resolution(tgt_expr, func, substs.clone());\n+                        self.write_method_resolution(tgt_expr, func, substs);\n                     }\n                     self.resolve_associated_type_with_params(\n                         self_ty,\n@@ -912,7 +912,7 @@ impl<'a> InferenceContext<'a> {\n                 (elem_ty, consteval::usize_const(self.db, Some(0), krate))\n             }\n             Array::ElementList { elements, .. } => {\n-                let mut coerce = CoerceMany::new(elem_ty.clone());\n+                let mut coerce = CoerceMany::new(elem_ty);\n                 for &expr in elements.iter() {\n                     let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n                     coerce.coerce(self, Some(expr), &cur_elem_ty);\n@@ -1214,7 +1214,7 @@ impl<'a> InferenceContext<'a> {\n         let g = self.resolver.update_to_inner_scope(self.db.upcast(), self.owner, expr);\n \n         let (break_ty, ty) =\n-            self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty.clone()), label, |this| {\n+            self.with_breakable_ctx(BreakableKind::Block, Some(coerce_ty), label, |this| {\n                 for stmt in statements {\n                     match stmt {\n                         Statement::Let { pat, type_ref, initializer, else_branch } => {"}, {"sha": "874f808cda1b67bc63ebb934c726549402571228", "filename": "crates/hir-ty/src/interner.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -51,8 +51,8 @@ impl chalk_ir::interner::Interner for Interner {\n     type InternedGoal = Arc<GoalData<Self>>;\n     type InternedGoals = Vec<Goal<Self>>;\n     type InternedSubstitution = Interned<InternedWrapper<SmallVec<[GenericArg; 2]>>>;\n-    type InternedProgramClause = chalk_ir::ProgramClauseData<Self>;\n     type InternedProgramClauses = Interned<InternedWrapper<Vec<chalk_ir::ProgramClause<Self>>>>;\n+    type InternedProgramClause = chalk_ir::ProgramClauseData<Self>;\n     type InternedQuantifiedWhereClauses =\n         Interned<InternedWrapper<Vec<chalk_ir::QuantifiedWhereClause<Self>>>>;\n     type InternedVariableKinds = Interned<InternedWrapper<Vec<chalk_ir::VariableKind<Interner>>>>;\n@@ -86,6 +86,27 @@ impl chalk_ir::interner::Interner for Interner {\n         tls::with_current_program(|prog| Some(prog?.debug_assoc_type_id(id, fmt)))\n     }\n \n+    fn debug_opaque_ty_id(\n+        opaque_ty_id: chalk_ir::OpaqueTyId<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"OpaqueTy#{}\", opaque_ty_id.0))\n+    }\n+\n+    fn debug_fn_def_id(\n+        fn_def_id: chalk_ir::FnDefId<Self>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        tls::with_current_program(|prog| Some(prog?.debug_fn_def_id(fn_def_id, fmt)))\n+    }\n+\n+    fn debug_closure_id(\n+        _fn_def_id: chalk_ir::ClosureId<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n     fn debug_alias(\n         alias: &chalk_ir::AliasTy<Interner>,\n         fmt: &mut fmt::Formatter<'_>,\n@@ -113,13 +134,6 @@ impl chalk_ir::interner::Interner for Interner {\n         Some(write!(fmt, \"{:?}\", opaque_ty.opaque_ty_id))\n     }\n \n-    fn debug_opaque_ty_id(\n-        opaque_ty_id: chalk_ir::OpaqueTyId<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"OpaqueTy#{}\", opaque_ty_id.0))\n-    }\n-\n     fn debug_ty(ty: &chalk_ir::Ty<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", ty.data(Interner)))\n     }\n@@ -131,76 +145,56 @@ impl chalk_ir::interner::Interner for Interner {\n         Some(write!(fmt, \"{:?}\", lifetime.data(Interner)))\n     }\n \n-    fn debug_generic_arg(\n-        parameter: &GenericArg,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", parameter.data(Interner).inner_debug()))\n-    }\n-\n-    fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n-        let goal_data = goal.data(Interner);\n-        Some(write!(fmt, \"{goal_data:?}\"))\n-    }\n-\n-    fn debug_goals(\n-        goals: &chalk_ir::Goals<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", goals.debug(Interner)))\n-    }\n-\n-    fn debug_program_clause_implication(\n-        pci: &chalk_ir::ProgramClauseImplication<Interner>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", pci.debug(Interner)))\n-    }\n-\n-    fn debug_substitution(\n-        substitution: &chalk_ir::Substitution<Interner>,\n+    fn debug_const(\n+        constant: &chalk_ir::Const<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", substitution.debug(Interner)))\n+        Some(write!(fmt, \"{:?}\", constant.data(Interner)))\n     }\n \n-    fn debug_separator_trait_ref(\n-        separator_trait_ref: &chalk_ir::SeparatorTraitRef<'_, Interner>,\n+    fn debug_generic_arg(\n+        parameter: &GenericArg,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", separator_trait_ref.debug(Interner)))\n+        Some(write!(fmt, \"{:?}\", parameter.data(Interner).inner_debug()))\n     }\n \n-    fn debug_fn_def_id(\n-        fn_def_id: chalk_ir::FnDefId<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        tls::with_current_program(|prog| Some(prog?.debug_fn_def_id(fn_def_id, fmt)))\n-    }\n-    fn debug_const(\n-        constant: &chalk_ir::Const<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        Some(write!(fmt, \"{:?}\", constant.data(Interner)))\n-    }\n     fn debug_variable_kinds(\n         variable_kinds: &chalk_ir::VariableKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", variable_kinds.as_slice(Interner)))\n     }\n+\n     fn debug_variable_kinds_with_angles(\n         variable_kinds: &chalk_ir::VariableKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", variable_kinds.inner_debug(Interner)))\n     }\n+\n     fn debug_canonical_var_kinds(\n         canonical_var_kinds: &chalk_ir::CanonicalVarKinds<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", canonical_var_kinds.as_slice(Interner)))\n     }\n+    fn debug_goal(goal: &Goal<Interner>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        let goal_data = goal.data(Interner);\n+        Some(write!(fmt, \"{goal_data:?}\"))\n+    }\n+    fn debug_goals(\n+        goals: &chalk_ir::Goals<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", goals.debug(Interner)))\n+    }\n+    fn debug_program_clause_implication(\n+        pci: &chalk_ir::ProgramClauseImplication<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", pci.debug(Interner)))\n+    }\n     fn debug_program_clause(\n         clause: &chalk_ir::ProgramClause<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n@@ -213,13 +207,33 @@ impl chalk_ir::interner::Interner for Interner {\n     ) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", clauses.as_slice(Interner)))\n     }\n+    fn debug_substitution(\n+        substitution: &chalk_ir::Substitution<Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", substitution.debug(Interner)))\n+    }\n+    fn debug_separator_trait_ref(\n+        separator_trait_ref: &chalk_ir::SeparatorTraitRef<'_, Interner>,\n+        fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        Some(write!(fmt, \"{:?}\", separator_trait_ref.debug(Interner)))\n+    }\n+\n     fn debug_quantified_where_clauses(\n         clauses: &chalk_ir::QuantifiedWhereClauses<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n     ) -> Option<fmt::Result> {\n         Some(write!(fmt, \"{:?}\", clauses.as_slice(Interner)))\n     }\n \n+    fn debug_constraints(\n+        _clauses: &chalk_ir::Constraints<Self>,\n+        _fmt: &mut fmt::Formatter<'_>,\n+    ) -> Option<fmt::Result> {\n+        None\n+    }\n+\n     fn intern_ty(self, kind: chalk_ir::TyKind<Self>) -> Self::InternedType {\n         let flags = kind.compute_flags(self);\n         Interned::new(InternedWrapper(chalk_ir::TyData { kind, flags }))\n@@ -272,17 +286,17 @@ impl chalk_ir::interner::Interner for Interner {\n         Arc::new(goal)\n     }\n \n+    fn goal_data(self, goal: &Self::InternedGoal) -> &GoalData<Self> {\n+        goal\n+    }\n+\n     fn intern_goals<E>(\n         self,\n         data: impl IntoIterator<Item = Result<Goal<Self>, E>>,\n     ) -> Result<Self::InternedGoals, E> {\n         data.into_iter().collect()\n     }\n \n-    fn goal_data(self, goal: &Self::InternedGoal) -> &GoalData<Self> {\n-        goal\n-    }\n-\n     fn goals_data(self, goals: &Self::InternedGoals) -> &[Goal<Interner>] {\n         goals\n     }\n@@ -367,32 +381,18 @@ impl chalk_ir::interner::Interner for Interner {\n     ) -> &[chalk_ir::CanonicalVarKind<Self>] {\n         canonical_var_kinds\n     }\n-\n     fn intern_constraints<E>(\n         self,\n         data: impl IntoIterator<Item = Result<chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>, E>>,\n     ) -> Result<Self::InternedConstraints, E> {\n         data.into_iter().collect()\n     }\n-\n     fn constraints_data(\n         self,\n         constraints: &Self::InternedConstraints,\n     ) -> &[chalk_ir::InEnvironment<chalk_ir::Constraint<Self>>] {\n         constraints\n     }\n-    fn debug_closure_id(\n-        _fn_def_id: chalk_ir::ClosureId<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        None\n-    }\n-    fn debug_constraints(\n-        _clauses: &chalk_ir::Constraints<Self>,\n-        _fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        None\n-    }\n \n     fn intern_variances<E>(\n         self,"}, {"sha": "ea494a0dbdec52e590342cd10de512c72a56f8ce", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -588,7 +588,7 @@ pub fn callable_sig_from_fnonce(\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;\n \n-    let mut table = InferenceTable::new(db, env.clone());\n+    let mut table = InferenceTable::new(db, env);\n     let b = TyBuilder::trait_ref(db, fn_once_trait);\n     if b.remaining() != 2 {\n         return None;"}, {"sha": "84b59b5eeb91ae2b507ed72baa1ef5317483e0bc", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -1414,7 +1414,7 @@ impl Evaluator<'_> {\n             }\n             CallableDefId::StructId(id) => {\n                 let (size, variant_layout, tag) =\n-                    self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n+                    self.layout_of_variant(id.into(), generic_args, &locals)?;\n                 let result = self.make_by_layout(\n                     size,\n                     &variant_layout,\n@@ -1425,7 +1425,7 @@ impl Evaluator<'_> {\n             }\n             CallableDefId::EnumVariantId(id) => {\n                 let (size, variant_layout, tag) =\n-                    self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n+                    self.layout_of_variant(id.into(), generic_args, &locals)?;\n                 let result = self.make_by_layout(\n                     size,\n                     &variant_layout,\n@@ -1507,7 +1507,7 @@ impl Evaluator<'_> {\n                 );\n             }\n             let (imp, generic_args) =\n-                lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args.clone());\n+                lookup_impl_method(self.db, self.trait_env.clone(), def, generic_args);\n             let generic_args = self.subst_filler(&generic_args, &locals);\n             let def = imp.into();\n             let mir_body ="}, {"sha": "9d97ab84a56ab04f307ad70aea5e480d80b4c1da", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -69,9 +69,7 @@ pub(super) fn all_super_trait_refs<T>(\n     cb: impl FnMut(TraitRef) -> Option<T>,\n ) -> Option<T> {\n     let seen = iter::once(trait_ref.trait_id).collect();\n-    let mut stack = Vec::new();\n-    stack.push(trait_ref);\n-    SuperTraits { db, seen, stack }.find_map(cb)\n+    SuperTraits { db, seen, stack: vec![trait_ref] }.find_map(cb)\n }\n \n struct SuperTraits<'a> {"}, {"sha": "7384390f28b57d9d8b7ee9cdf4f4372fb72334c4", "filename": "crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -148,7 +148,7 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n             return None;\n         }\n \n-        let variants_of_enums = vec![variants.clone(); len];\n+        let variants_of_enums = vec![variants; len];\n \n         let missing_pats = variants_of_enums\n             .into_iter()"}, {"sha": "5f7056b9c1c435000e9ee1d19d3df2b6af529cc2", "filename": "crates/ide-assists/src/handlers/convert_let_else_to_match.rs", "status": "modified", "additions": 82, "deletions": 79, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_let_else_to_match.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -5,6 +5,88 @@ use syntax::T;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n+// Assist: convert_let_else_to_match\n+//\n+// Converts let-else statement to let statement and match expression.\n+//\n+// ```\n+// fn main() {\n+//     let Ok(mut x) = f() else$0 { return };\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     let mut x = match f() {\n+//         Ok(x) => x,\n+//         _ => return,\n+//     };\n+// }\n+// ```\n+pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    // should focus on else token to trigger\n+    let let_stmt = ctx\n+        .find_token_syntax_at_offset(T![else])\n+        .and_then(|it| it.parent()?.parent())\n+        .or_else(|| ctx.find_token_syntax_at_offset(T![let])?.parent())?;\n+    let let_stmt = LetStmt::cast(let_stmt)?;\n+    let let_else_block = let_stmt.let_else()?.block_expr()?;\n+    let let_init = let_stmt.initializer()?;\n+    if let_stmt.ty().is_some() {\n+        // don't support let with type annotation\n+        return None;\n+    }\n+    let pat = let_stmt.pat()?;\n+    let mut binders = Vec::new();\n+    binders_in_pat(&mut binders, &pat, &ctx.sema)?;\n+\n+    let target = let_stmt.syntax().text_range();\n+    acc.add(\n+        AssistId(\"convert_let_else_to_match\", AssistKind::RefactorRewrite),\n+        \"Convert let-else to let and match\",\n+        target,\n+        |edit| {\n+            let indent_level = let_stmt.indent_level().0 as usize;\n+            let indent = \"    \".repeat(indent_level);\n+            let indent1 = \"    \".repeat(indent_level + 1);\n+\n+            let binders_str = binders_to_str(&binders, false);\n+            let binders_str_mut = binders_to_str(&binders, true);\n+\n+            let init_expr = let_init.syntax().text();\n+            let mut pat_no_mut = pat.syntax().text().to_string();\n+            // remove the mut from the pattern\n+            for (b, ismut) in binders.iter() {\n+                if *ismut {\n+                    pat_no_mut = pat_no_mut.replace(&format!(\"mut {b}\"), &b.to_string());\n+                }\n+            }\n+\n+            let only_expr = let_else_block.statements().next().is_none();\n+            let branch2 = match &let_else_block.tail_expr() {\n+                Some(tail) if only_expr => format!(\"{tail},\"),\n+                _ => let_else_block.syntax().text().to_string(),\n+            };\n+            let replace = if binders.is_empty() {\n+                format!(\n+                    \"match {init_expr} {{\n+{indent1}{pat_no_mut} => {binders_str}\n+{indent1}_ => {branch2}\n+{indent}}}\"\n+                )\n+            } else {\n+                format!(\n+                    \"let {binders_str_mut} = match {init_expr} {{\n+{indent1}{pat_no_mut} => {binders_str},\n+{indent1}_ => {branch2}\n+{indent}}};\"\n+                )\n+            };\n+            edit.replace(target, replace);\n+        },\n+    )\n+}\n+\n /// Gets a list of binders in a pattern, and whether they are mut.\n fn binders_in_pat(\n     acc: &mut Vec<(Name, bool)>,\n@@ -97,85 +179,6 @@ fn binders_to_str(binders: &[(Name, bool)], addmut: bool) -> String {\n     }\n }\n \n-// Assist: convert_let_else_to_match\n-//\n-// Converts let-else statement to let statement and match expression.\n-//\n-// ```\n-// fn main() {\n-//     let Ok(mut x) = f() else$0 { return };\n-// }\n-// ```\n-// ->\n-// ```\n-// fn main() {\n-//     let mut x = match f() {\n-//         Ok(x) => x,\n-//         _ => return,\n-//     };\n-// }\n-// ```\n-pub(crate) fn convert_let_else_to_match(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    // should focus on else token to trigger\n-    let else_token = ctx.find_token_syntax_at_offset(T![else])?;\n-    let let_stmt = LetStmt::cast(else_token.parent()?.parent()?)?;\n-    let let_else_block = let_stmt.let_else()?.block_expr()?;\n-    let let_init = let_stmt.initializer()?;\n-    if let_stmt.ty().is_some() {\n-        // don't support let with type annotation\n-        return None;\n-    }\n-    let pat = let_stmt.pat()?;\n-    let mut binders = Vec::new();\n-    binders_in_pat(&mut binders, &pat, &ctx.sema)?;\n-\n-    let target = let_stmt.syntax().text_range();\n-    acc.add(\n-        AssistId(\"convert_let_else_to_match\", AssistKind::RefactorRewrite),\n-        \"Convert let-else to let and match\",\n-        target,\n-        |edit| {\n-            let indent_level = let_stmt.indent_level().0 as usize;\n-            let indent = \"    \".repeat(indent_level);\n-            let indent1 = \"    \".repeat(indent_level + 1);\n-\n-            let binders_str = binders_to_str(&binders, false);\n-            let binders_str_mut = binders_to_str(&binders, true);\n-\n-            let init_expr = let_init.syntax().text();\n-            let mut pat_no_mut = pat.syntax().text().to_string();\n-            // remove the mut from the pattern\n-            for (b, ismut) in binders.iter() {\n-                if *ismut {\n-                    pat_no_mut = pat_no_mut.replace(&format!(\"mut {b}\"), &b.to_string());\n-                }\n-            }\n-\n-            let only_expr = let_else_block.statements().next().is_none();\n-            let branch2 = match &let_else_block.tail_expr() {\n-                Some(tail) if only_expr => format!(\"{tail},\"),\n-                _ => let_else_block.syntax().text().to_string(),\n-            };\n-            let replace = if binders.is_empty() {\n-                format!(\n-                    \"match {init_expr} {{\n-{indent1}{pat_no_mut} => {binders_str}\n-{indent1}_ => {branch2}\n-{indent}}}\"\n-                )\n-            } else {\n-                format!(\n-                    \"let {binders_str_mut} = match {init_expr} {{\n-{indent1}{pat_no_mut} => {binders_str},\n-{indent1}_ => {branch2}\n-{indent}}};\"\n-                )\n-            };\n-            edit.replace(target, replace);\n-        },\n-    )\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "fc6236a17558c35e02a559ae7d656dce31ad9ade", "filename": "crates/ide-assists/src/handlers/convert_match_to_let_else.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_match_to_let_else.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -16,7 +16,7 @@ use crate::{\n // ```\n // # //- minicore: option\n // fn foo(opt: Option<()>) {\n-//     let val = $0match opt {\n+//     let val$0 = match opt {\n //         Some(it) => it,\n //         None => return,\n //     };\n@@ -30,7 +30,10 @@ use crate::{\n // ```\n pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n     let let_stmt: ast::LetStmt = ctx.find_node_at_offset()?;\n-    let binding = let_stmt.pat()?;\n+    let pat = let_stmt.pat()?;\n+    if ctx.offset() > pat.syntax().text_range().end() {\n+        return None;\n+    }\n \n     let Some(ast::Expr::MatchExpr(initializer)) = let_stmt.initializer() else { return None };\n     let initializer_expr = initializer.expr()?;\n@@ -56,7 +59,7 @@ pub(crate) fn convert_match_to_let_else(acc: &mut Assists, ctx: &AssistContext<'\n         let_stmt.syntax().text_range(),\n         |builder| {\n             let extracting_arm_pat =\n-                rename_variable(&extracting_arm_pat, &extracted_variable_positions, binding);\n+                rename_variable(&extracting_arm_pat, &extracted_variable_positions, pat);\n             builder.replace(\n                 let_stmt.syntax().text_range(),\n                 format!(\"let {extracting_arm_pat} = {initializer_expr} else {diverging_arm_expr};\"),\n@@ -161,7 +164,7 @@ mod tests {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<()>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(it) => it,\n         None => (),\n     };\n@@ -211,7 +214,7 @@ fn foo(opt: Option<Foo>) -> Result<u32, ()> {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<i32>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(it) => it + 1,\n         None => return,\n     };\n@@ -224,7 +227,7 @@ fn foo(opt: Option<i32>) {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<()>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(it) => {\n             let _ = 1 + 1;\n             it\n@@ -244,7 +247,7 @@ fn foo(opt: Option<()>) {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<()>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(it) if 2 > 1 => it,\n         None => return,\n     };\n@@ -260,7 +263,7 @@ fn foo(opt: Option<()>) {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<()>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(it) => it,\n         None => return,\n     };\n@@ -281,7 +284,7 @@ fn foo(opt: Option<()>) {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<()>) {\n-    let ref mut val = $0match opt {\n+    let ref mut val$0 = match opt {\n         Some(it) => it,\n         None => return,\n     };\n@@ -302,7 +305,7 @@ fn foo(opt: Option<()>) {\n             r#\"\n //- minicore: option, result\n fn foo(opt: Option<Result<()>>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(Ok(it)) => it,\n         _ => return,\n     };\n@@ -324,7 +327,7 @@ fn foo(opt: Option<Result<()>>) {\n //- minicore: option\n fn foo(opt: Option<()>) {\n     loop {\n-        let val = $0match opt {\n+        let val$0 = match opt {\n             Some(it) => it,\n             None => break,\n         };\n@@ -346,7 +349,7 @@ fn foo(opt: Option<()>) {\n //- minicore: option\n fn foo(opt: Option<()>) {\n     loop {\n-        let val = $0match opt {\n+        let val$0 = match opt {\n             Some(it) => it,\n             None => continue,\n         };\n@@ -370,7 +373,7 @@ fn panic() -> ! {}\n \n fn foo(opt: Option<()>) {\n     loop {\n-        let val = $0match opt {\n+        let val$0 = match opt {\n             Some(it) => it,\n             None => panic(),\n         };\n@@ -401,7 +404,7 @@ struct Point {\n }\n \n fn foo(opt: Option<Point>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(Point { x: 0, y }) => y,\n         _ => return,\n     };\n@@ -427,7 +430,7 @@ fn foo(opt: Option<Point>) {\n             r#\"\n //- minicore: option\n fn foo(opt: Option<i32>) -> Option<i32> {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         it @ Some(42) => it,\n         _ => return None,\n     };\n@@ -450,7 +453,7 @@ fn foo(opt: Option<i32>) -> Option<i32> {\n             r#\"\n //- minicore: option\n fn f() {\n-    let (x, y) = $0match Some((0, 1)) {\n+    let (x, y)$0 = match Some((0, 1)) {\n         Some(it) => it,\n         None => return,\n     };\n@@ -471,7 +474,7 @@ fn f() {\n             r#\"\n //- minicore: option\n fn f() {\n-    let x = $0match Some(()) {\n+    let x$0 = match Some(()) {\n         Some(it) => it,\n         None => {//comment\n             println!(\"nope\");"}, {"sha": "57bb679729f311ef424354a7fe606604d7cad2b3", "filename": "crates/ide-assists/src/handlers/generate_constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_constant.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -106,10 +106,10 @@ fn get_text_for_generate_constant(\n     let mut text = format!(\"{vis}const {constant_token}: {type_name} = $0;\");\n     while let Some(name_ref) = not_exist_name_ref.pop() {\n         let vis = if not_exist_name_ref.len() == 0 && !outer_exists { \"\" } else { \"\\npub \" };\n-        text = text.replace(\"\\n\", \"\\n    \");\n+        text = text.replace('\\n', \"\\n    \");\n         text = format!(\"{vis}mod {name_ref} {{{text}\\n}}\");\n     }\n-    Some(text.replace(\"\\n\", &format!(\"\\n{indent}\")))\n+    Some(text.replace('\\n', &format!(\"\\n{indent}\")))\n }\n \n fn target_data_for_generate_constant(\n@@ -131,7 +131,7 @@ fn target_data_for_generate_constant(\n \n             let siblings_has_newline = l_curly_token\n                 .siblings_with_tokens(Direction::Next)\n-                .find(|it| it.kind() == SyntaxKind::WHITESPACE && it.to_string().contains(\"\\n\"))\n+                .find(|it| it.kind() == SyntaxKind::WHITESPACE && it.to_string().contains('\\n'))\n                 .is_some();\n             let post_string =\n                 if siblings_has_newline { format!(\"{indent}\") } else { format!(\"\\n{indent}\") };"}, {"sha": "cd977a68a67d713f8c632d92fc5ad41ee600d6b4", "filename": "crates/ide-assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -20,9 +20,10 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n // const test: Foo = Foo {foo: 1, bar: 0}\n // ```\n pub(crate) fn reorder_fields(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let record = ctx.find_node_at_offset::<Either<ast::RecordExpr, ast::RecordPat>>()?;\n+    let path = ctx.find_node_at_offset::<ast::Path>()?;\n+    let record =\n+        path.syntax().parent().and_then(<Either<ast::RecordExpr, ast::RecordPat>>::cast)?;\n \n-    let path = record.as_ref().either(|it| it.path(), |it| it.path())?;\n     let ranks = compute_fields_ranks(&path, ctx)?;\n     let get_rank_of_field =\n         |of: Option<_>| *ranks.get(&of.unwrap_or_default()).unwrap_or(&usize::MAX);"}, {"sha": "939055f148c45af785812af16eda7839ee1735a9", "filename": "crates/ide-assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -51,15 +51,11 @@ pub(crate) fn unwrap_block(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n         let replaced = match list.syntax().last_child() {\n             Some(last) => {\n                 let stmts: Vec<ast::Stmt> = list.statements().collect();\n-                let initializer = ast::Expr::cast(last.clone())?;\n+                let initializer = ast::Expr::cast(last)?;\n                 let let_stmt = make::let_stmt(pattern, ty, Some(initializer));\n                 if stmts.len() > 0 {\n                     let block = make::block_expr(stmts, None);\n-                    format!(\n-                        \"{}\\n    {}\",\n-                        update_expr_string(block.to_string()),\n-                        let_stmt.to_string()\n-                    )\n+                    format!(\"{}\\n    {}\", update_expr_string(block.to_string()), let_stmt)\n                 } else {\n                     let_stmt.to_string()\n                 }"}, {"sha": "dd8705d797c211ab0c874f895c4e3d17f3d853f7", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -439,7 +439,7 @@ fn doctest_convert_match_to_let_else() {\n         r#####\"\n //- minicore: option\n fn foo(opt: Option<()>) {\n-    let val = $0match opt {\n+    let val$0 = match opt {\n         Some(it) => it,\n         None => return,\n     };"}, {"sha": "145e18c5c48c862ca467955d128e289ac67096d6", "filename": "crates/ide-diagnostics/src/handlers/unlinked_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -92,7 +92,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, file_id: FileId) -> Option<Vec<Assist>> {\n     // if we aren't adding to a crate root, walk backwards such that we support `#[path = ...]` overrides if possible\n \n     // build all parent paths of the form `../module_name/mod.rs` and `../module_name.rs`\n-    let paths = iter::successors(Some(parent.clone()), |prev| prev.parent()).filter_map(|path| {\n+    let paths = iter::successors(Some(parent), |prev| prev.parent()).filter_map(|path| {\n         let parent = path.parent()?;\n         let (name, _) = path.name_and_extension()?;\n         Some(([parent.join(&format!(\"{name}.rs\"))?, path.join(\"mod.rs\")?], name.to_owned()))"}, {"sha": "1c848090b6a49e08b39452955914ee42dd2de840", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -66,7 +66,6 @@ impl flags::Scip {\n                     .as_os_str()\n                     .to_str()\n                     .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n-                    .to_string()\n             ),\n             text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n             special_fields: Default::default(),\n@@ -212,7 +211,7 @@ fn new_descriptor_str(\n \n fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_types::Descriptor {\n     let mut name = name.to_string();\n-    if name.contains(\"'\") {\n+    if name.contains('\\'') {\n         name = format!(\"`{name}`\");\n     }\n "}, {"sha": "2b9dfecceff0ff109cb9f6d551d4b5e8cb31168d", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ea1afce2803458eeb2b39a970472e3acdba82c6/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=8ea1afce2803458eeb2b39a970472e3acdba82c6", "patch": "@@ -279,7 +279,7 @@ fn completion_item(\n \n     let mut lsp_item = lsp_types::CompletionItem {\n         label: item.label.to_string(),\n-        detail: item.detail.map(|it| it.to_string()),\n+        detail: item.detail,\n         filter_text: Some(lookup),\n         kind: Some(completion_item_kind(item.kind)),\n         text_edit: Some(text_edit),"}]}