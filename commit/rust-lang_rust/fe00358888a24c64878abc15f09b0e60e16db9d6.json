{"sha": "fe00358888a24c64878abc15f09b0e60e16db9d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMDAzNTg4ODhhMjRjNjQ4NzhhYmMxNWYwOWIwZTYwZTE2ZGI5ZDY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-11T14:28:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-11T14:28:08Z"}, "message": "Merge #9569\n\n9569: internal: Explicitly check for reference locals or fields in Name classification r=Veykril a=Veykril\n\nCloses #7524\r\nInlines all the calls to reference related name classification as well as emits both goto definition targets for field shorthands.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "20f2d6ac3deb23c9f6edf2dfc0de71d6537e860f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20f2d6ac3deb23c9f6edf2dfc0de71d6537e860f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe00358888a24c64878abc15f09b0e60e16db9d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg6v/4CRBK7hj4Ov3rIwAAOg4IAFkYsldIwXEC7OojYREl/oBf\n4H3TRySt770iOeO5jf/GZ3lPlljnuCuMrXpcU+V4O8cLic4siteU7OWPCiZXEG4y\nI+Qx/+/+D2ZNrsKPWbnCdfmxNlUO1yjfM23qFFGSQnDYlqHjsn/olglicrNcaQPC\nCXJAqyDFz6zBel4lVszZq8IRlgOia3ZRPiM5LJt9R+UJFshApWEavwoSkcp4+3yW\nHQJoAOPfXSn1OrjCA4uBx/0Fkz0iLAE9btx7/Ss9otxCK9B9M+9ZnXBFDTs+XC+E\nsswgpEFWE5pMxsedzVAXc8HV1FkSPU5pUMafCnFW7mVN98pMkLtmnuqa5FaNRGk=\n=ji3a\n-----END PGP SIGNATURE-----\n", "payload": "tree 20f2d6ac3deb23c9f6edf2dfc0de71d6537e860f\nparent 3fc5f01f59d6dcf8b3854575e9e5e212ebb60892\nparent ab2647769c611dc7f7696d940c9e09c1cc966f83\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626013688 +0000\ncommitter GitHub <noreply@github.com> 1626013688 +0000\n\nMerge #9569\n\n9569: internal: Explicitly check for reference locals or fields in Name classification r=Veykril a=Veykril\n\nCloses #7524\r\nInlines all the calls to reference related name classification as well as emits both goto definition targets for field shorthands.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe00358888a24c64878abc15f09b0e60e16db9d6", "html_url": "https://github.com/rust-lang/rust/commit/fe00358888a24c64878abc15f09b0e60e16db9d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe00358888a24c64878abc15f09b0e60e16db9d6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fc5f01f59d6dcf8b3854575e9e5e212ebb60892", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc5f01f59d6dcf8b3854575e9e5e212ebb60892", "html_url": "https://github.com/rust-lang/rust/commit/3fc5f01f59d6dcf8b3854575e9e5e212ebb60892"}, {"sha": "ab2647769c611dc7f7696d940c9e09c1cc966f83", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2647769c611dc7f7696d940c9e09c1cc966f83", "html_url": "https://github.com/rust-lang/rust/commit/ab2647769c611dc7f7696d940c9e09c1cc966f83"}], "stats": {"total": 314, "additions": 202, "deletions": 112}, "files": [{"sha": "480adb841912764a1e3bfc9dc8800a69c516efc3", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -112,8 +112,16 @@ pub(crate) fn external_docs(\n     let node = token.parent()?;\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced())?,\n-            ast::Name(name) => NameClass::classify(&sema, &name).map(|d| d.referenced_or_defined())?,\n+            ast::NameRef(name_ref) => match NameRefClass::classify(&sema, &name_ref)? {\n+                NameRefClass::Definition(def) => def,\n+                NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+                    Definition::Field(field_ref)\n+                }\n+            },\n+            ast::Name(name) => match NameClass::classify(&sema, &name)? {\n+                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                NameClass::PatFieldShorthand { local_def: _, field_ref } => Definition::Field(field_ref),\n+            },\n             _ => return None,\n         }\n     };"}, {"sha": "7c73751045148bce59f5220774e0c01ff236dd10", "filename": "crates/ide/src/fixture.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffixture.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -51,11 +51,3 @@ pub(crate) fn annotations(ra_fixture: &str) -> (Analysis, FilePosition, Vec<(Fil\n         .collect();\n     (host.analysis(), FilePosition { file_id, offset }, annotations)\n }\n-\n-pub(crate) fn nav_target_annotation(ra_fixture: &str) -> (Analysis, FilePosition, FileRange) {\n-    let (analysis, position, mut annotations) = annotations(ra_fixture);\n-    let (expected, data) = annotations.pop().unwrap();\n-    assert!(annotations.is_empty());\n-    assert_eq!(data, \"\");\n-    (analysis, position, expected)\n-}"}, {"sha": "2e4132b6a0c26861152c99ab95a118d0b1d60bdd", "filename": "crates/ide/src/goto_declaration.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fgoto_declaration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_declaration.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -23,45 +23,56 @@ pub(crate) fn goto_declaration(\n     let parent = token.parent()?;\n     let def = match_ast! {\n         match parent {\n-            ast::NameRef(name_ref) => {\n-                let name_kind = NameRefClass::classify(&sema, &name_ref)?;\n-                name_kind.referenced()\n+            ast::NameRef(name_ref) => match NameRefClass::classify(&sema, &name_ref)? {\n+                NameRefClass::Definition(it) => Some(it),\n+                _ => None\n             },\n-            ast::Name(name) => {\n-                NameClass::classify(&sema, &name)?.referenced_or_defined()\n+            ast::Name(name) => match NameClass::classify(&sema, &name)? {\n+                NameClass::Definition(it) => Some(it),\n+                _ => None\n             },\n-            _ => return None,\n+            _ => None,\n         }\n     };\n-    match def {\n+    match def? {\n         Definition::ModuleDef(hir::ModuleDef::Module(module)) => Some(RangeInfo::new(\n             original_token.text_range(),\n             vec![NavigationTarget::from_module_to_decl(db, module)],\n         )),\n-        _ => return None,\n+        _ => None,\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n     use crate::fixture;\n \n     fn check(ra_fixture: &str) {\n-        let (analysis, position, expected) = fixture::nav_target_annotation(ra_fixture);\n-        let mut navs = analysis\n+        let (analysis, position, expected) = fixture::annotations(ra_fixture);\n+        let navs = analysis\n             .goto_declaration(position)\n             .unwrap()\n             .expect(\"no declaration or definition found\")\n             .info;\n         if navs.len() == 0 {\n             panic!(\"unresolved reference\")\n         }\n-        assert_eq!(navs.len(), 1);\n \n-        let nav = navs.pop().unwrap();\n-        assert_eq!(expected, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() });\n+        let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n+        let navs = navs\n+            .into_iter()\n+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        let expected = expected\n+            .into_iter()\n+            .map(|(FileRange { file_id, range }, _)| FileRange { file_id, range })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        assert_eq!(expected, navs);\n     }\n \n     #[test]"}, {"sha": "595c0ec05c49fb90a459025b750ac3e5ccb3ce5c", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -1,4 +1,4 @@\n-use std::convert::TryInto;\n+use std::{convert::TryInto, iter};\n \n use either::Either;\n use hir::{AsAssocItem, InFile, ModuleDef, Semantics};\n@@ -11,7 +11,7 @@ use ide_db::{\n use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, T};\n \n use crate::{\n-    display::TryToNav,\n+    display::{ToNav, TryToNav},\n     doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n@@ -54,36 +54,44 @@ pub(crate) fn goto_definition(\n         let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n     }\n-    let nav = match_ast! {\n+\n+    let navs = match_ast! {\n         match parent {\n             ast::NameRef(name_ref) => {\n                 reference_definition(&sema, Either::Right(&name_ref))\n             },\n             ast::Name(name) => {\n-                let def = NameClass::classify(&sema, &name)?.referenced_or_defined();\n-                try_find_trait_item_definition(sema.db, &def)\n-                    .or_else(|| def.try_to_nav(sema.db))\n+                match NameClass::classify(&sema, &name)? {\n+                    NameClass::Definition(def) | NameClass::ConstReference(def) => {\n+                        try_find_trait_item_definition(sema.db, &def).unwrap_or_else(|| def_to_nav(sema.db, def))\n+                    }\n+                    NameClass::PatFieldShorthand { local_def, field_ref } => {\n+                        local_and_field_to_nav(sema.db, local_def, field_ref)\n+                    },\n+                }\n             },\n             ast::Lifetime(lt) => if let Some(name_class) = NameClass::classify_lifetime(&sema, &lt) {\n-                let def = name_class.referenced_or_defined();\n-                def.try_to_nav(sema.db)\n+                match name_class {\n+                    NameClass::Definition(def) => def_to_nav(sema.db, def),\n+                    _ => return None,\n+                }\n             } else {\n                 reference_definition(&sema, Either::Left(&lt))\n             },\n-            ast::TokenTree(tt) => try_lookup_include_path(sema.db, tt, token, position.file_id),\n+            ast::TokenTree(tt) => try_lookup_include_path(sema.db, tt, token, position.file_id)?,\n             _ => return None,\n         }\n     };\n \n-    Some(RangeInfo::new(original_token.text_range(), nav.into_iter().collect()))\n+    Some(RangeInfo::new(original_token.text_range(), navs))\n }\n \n fn try_lookup_include_path(\n     db: &RootDatabase,\n     tt: ast::TokenTree,\n     token: SyntaxToken,\n     file_id: FileId,\n-) -> Option<NavigationTarget> {\n+) -> Option<Vec<NavigationTarget>> {\n     let path = ast::String::cast(token)?.value()?.into_owned();\n     let macro_call = tt.syntax().parent().and_then(ast::MacroCall::cast)?;\n     let name = macro_call.path()?.segment()?.name_ref()?;\n@@ -92,7 +100,7 @@ fn try_lookup_include_path(\n     }\n     let file_id = db.resolve_path(AnchoredPath { anchor: file_id, path: &path })?;\n     let size = db.file_text(file_id).len().try_into().ok()?;\n-    Some(NavigationTarget {\n+    Some(vec![NavigationTarget {\n         file_id,\n         full_range: TextRange::new(0.into(), size),\n         name: path.into(),\n@@ -101,7 +109,7 @@ fn try_lookup_include_path(\n         container_name: None,\n         description: None,\n         docs: None,\n-    })\n+    }])\n }\n \n /// finds the trait definition of an impl'd item\n@@ -111,7 +119,10 @@ fn try_lookup_include_path(\n /// struct S;\n /// impl A for S { fn a(); } // <-- on this function, will get the location of a() in the trait\n /// ```\n-fn try_find_trait_item_definition(db: &RootDatabase, def: &Definition) -> Option<NavigationTarget> {\n+fn try_find_trait_item_definition(\n+    db: &RootDatabase,\n+    def: &Definition,\n+) -> Option<Vec<NavigationTarget>> {\n     let name = def.name(db)?;\n     let assoc = match def {\n         Definition::ModuleDef(ModuleDef::Function(f)) => f.as_assoc_item(db),\n@@ -130,37 +141,66 @@ fn try_find_trait_item_definition(db: &RootDatabase, def: &Definition) -> Option\n         .items(db)\n         .iter()\n         .find_map(|itm| (itm.name(db)? == name).then(|| itm.try_to_nav(db)).flatten())\n+        .map(|it| vec![it])\n }\n \n pub(crate) fn reference_definition(\n     sema: &Semantics<RootDatabase>,\n     name_ref: Either<&ast::Lifetime, &ast::NameRef>,\n-) -> Option<NavigationTarget> {\n-    let name_kind = name_ref.either(\n+) -> Vec<NavigationTarget> {\n+    let name_kind = match name_ref.either(\n         |lifetime| NameRefClass::classify_lifetime(sema, lifetime),\n         |name_ref| NameRefClass::classify(sema, name_ref),\n-    )?;\n-    let def = name_kind.referenced();\n-    def.try_to_nav(sema.db)\n+    ) {\n+        Some(class) => class,\n+        None => return Vec::new(),\n+    };\n+    match name_kind {\n+        NameRefClass::Definition(def) => def_to_nav(sema.db, def),\n+        NameRefClass::FieldShorthand { local_ref, field_ref } => {\n+            local_and_field_to_nav(sema.db, local_ref, field_ref)\n+        }\n+    }\n+}\n+\n+fn def_to_nav(db: &RootDatabase, def: Definition) -> Vec<NavigationTarget> {\n+    def.try_to_nav(db).map(|it| vec![it]).unwrap_or_default()\n+}\n+\n+fn local_and_field_to_nav(\n+    db: &RootDatabase,\n+    local: hir::Local,\n+    field: hir::Field,\n+) -> Vec<NavigationTarget> {\n+    iter::once(local.to_nav(db)).chain(field.try_to_nav(db)).collect()\n }\n \n #[cfg(test)]\n mod tests {\n     use ide_db::base_db::FileRange;\n+    use itertools::Itertools;\n \n     use crate::fixture;\n \n     fn check(ra_fixture: &str) {\n-        let (analysis, position, expected) = fixture::nav_target_annotation(ra_fixture);\n-        let mut navs =\n-            analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n+        let (analysis, position, expected) = fixture::annotations(ra_fixture);\n+        let navs = analysis.goto_definition(position).unwrap().expect(\"no definition found\").info;\n         if navs.len() == 0 {\n             panic!(\"unresolved reference\")\n         }\n-        assert_eq!(navs.len(), 1);\n \n-        let nav = navs.pop().unwrap();\n-        assert_eq!(expected, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() });\n+        let cmp = |&FileRange { file_id, range }: &_| (file_id, range.start());\n+        let navs = navs\n+            .into_iter()\n+            .map(|nav| FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        let expected = expected\n+            .into_iter()\n+            .map(|(FileRange { file_id, range }, _)| FileRange { file_id, range })\n+            .sorted_by_key(cmp)\n+            .collect::<Vec<_>>();\n+        assert_eq!(expected, navs);\n     }\n \n     fn check_unresolved(ra_fixture: &str) {\n@@ -863,6 +903,7 @@ fn bar() {\n         check(\n             r#\"\n struct Foo { x: i32 }\n+           //^\n fn main() {\n     let x = 92;\n       //^\n@@ -878,10 +919,12 @@ fn main() {\n             r#\"\n enum Foo {\n     Bar { x: i32 }\n-}       //^\n+        //^\n+}\n fn baz(foo: Foo) {\n     match foo {\n         Foo::Bar { x$0 } => x\n+                 //^\n     };\n }\n \"#,\n@@ -1126,13 +1169,15 @@ fn foo<'foobar>(_: &'foobar ()) {\n     fn goto_lifetime_hrtb() {\n         // FIXME: requires the HIR to somehow track these hrtb lifetimes\n         check_unresolved(\n-            r#\"trait Foo<T> {}\n+            r#\"\n+trait Foo<T> {}\n fn foo<T>() where for<'a> T: Foo<&'a$0 (u8, u16)>, {}\n                     //^^\n \"#,\n         );\n         check_unresolved(\n-            r#\"trait Foo<T> {}\n+            r#\"\n+trait Foo<T> {}\n fn foo<T>() where for<'a$0> T: Foo<&'a (u8, u16)>, {}\n                     //^^\n \"#,"}, {"sha": "bde0fbd176b132393c20d1890bde23e3d0bd4cf3", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -28,11 +28,19 @@ pub(crate) fn goto_implementation(\n \n     let node = sema.find_node_at_offset_with_descend(&syntax, position.offset)?;\n     let def = match &node {\n-        ast::NameLike::Name(name) => {\n-            NameClass::classify(&sema, name).map(|class| class.referenced_or_defined())\n-        }\n+        ast::NameLike::Name(name) => NameClass::classify(&sema, name).map(|class| match class {\n+            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                Definition::Local(local_def)\n+            }\n+        }),\n         ast::NameLike::NameRef(name_ref) => {\n-            NameRefClass::classify(&sema, name_ref).map(|class| class.referenced())\n+            NameRefClass::classify(&sema, name_ref).map(|class| match class {\n+                NameRefClass::Definition(def) => def,\n+                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                    Definition::Local(local_ref)\n+                }\n+            })\n         }\n         ast::NameLike::Lifetime(_) => None,\n     }?;"}, {"sha": "49a06a2851722a2fb9854fefe474a1b6a1226d76", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -96,18 +96,23 @@ pub(crate) fn hover(\n         match node {\n             // we don't use NameClass::referenced_or_defined here as we do not want to resolve\n             // field pattern shorthands to their definition\n-            ast::Name(name) => NameClass::classify(&sema, &name).and_then(|class| match class {\n-                NameClass::ConstReference(def) => Some(def),\n-                def => def.defined(),\n+            ast::Name(name) => NameClass::classify(&sema, &name).map(|class| match class {\n+                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                NameClass::PatFieldShorthand { local_def, field_ref: _ } => Definition::Local(local_def),\n+            }),\n+            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|class| match class {\n+                NameRefClass::Definition(def) => def,\n+                NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+                    Definition::Field(field_ref)\n+                }\n             }),\n-            ast::NameRef(name_ref) => {\n-                NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced())\n-            },\n             ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n-                || NameRefClass::classify_lifetime(&sema, &lifetime).map(|d| d.referenced()),\n+                || NameRefClass::classify_lifetime(&sema, &lifetime).and_then(|class| match class {\n+                    NameRefClass::Definition(it) => Some(it),\n+                    _ => None,\n+                }),\n                 |d| d.defined(),\n             ),\n-\n             _ => {\n                 if ast::Comment::cast(token.clone()).is_some() {\n                     cov_mark::hit!(no_highlight_on_comment_hover);"}, {"sha": "6b08212c75c8b388070eeacca6fb65d485800149", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -58,7 +58,15 @@ pub(crate) fn find_all_refs(\n \n     let (def, is_literal_search) =\n         if let Some(name) = get_name_of_item_declaration(&syntax, position) {\n-            (NameClass::classify(sema, &name)?.referenced_or_defined(), true)\n+            (\n+                match NameClass::classify(sema, &name)? {\n+                    NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                    NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n+                        Definition::Field(field_ref)\n+                    }\n+                },\n+                true,\n+            )\n         } else {\n             (find_def(sema, &syntax, position.offset)?, false)\n         };\n@@ -116,13 +124,28 @@ pub(crate) fn find_def(\n     offset: TextSize,\n ) -> Option<Definition> {\n     let def = match sema.find_node_at_offset_with_descend(syntax, offset)? {\n-        ast::NameLike::NameRef(name_ref) => NameRefClass::classify(sema, &name_ref)?.referenced(),\n-        ast::NameLike::Name(name) => NameClass::classify(sema, &name)?.referenced_or_defined(),\n+        ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n+            NameRefClass::Definition(def) => def,\n+            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                Definition::Local(local_ref)\n+            }\n+        },\n+        ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n+            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                Definition::Local(local_def)\n+            }\n+        },\n         ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n-            .map(|class| class.referenced())\n+            .and_then(|class| match class {\n+                NameRefClass::Definition(it) => Some(it),\n+                _ => None,\n+            })\n             .or_else(|| {\n-                NameClass::classify_lifetime(sema, &lifetime)\n-                    .map(|class| class.referenced_or_defined())\n+                NameClass::classify_lifetime(sema, &lifetime).and_then(|class| match class {\n+                    NameClass::Definition(it) => Some(it),\n+                    _ => None,\n+                })\n             })?,\n     };\n     Some(def)"}, {"sha": "f58be6d3fd08d4da60202505ee7fced0824e0f3e", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -107,13 +107,19 @@ fn find_definition(\n         {\n             bail!(\"Renaming aliases is currently unsupported\")\n         }\n-        ast::NameLike::Name(name) => {\n-            NameClass::classify(sema, &name).map(|class| class.referenced_or_defined())\n-        }\n+        ast::NameLike::Name(name) => NameClass::classify(sema, &name).map(|class| match class {\n+            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                Definition::Local(local_def)\n+            }\n+        }),\n         ast::NameLike::NameRef(name_ref) => {\n-            if let Some(def) =\n-                NameRefClass::classify(sema, &name_ref).map(|class| class.referenced())\n-            {\n+            if let Some(def) = NameRefClass::classify(sema, &name_ref).map(|class| match class {\n+                NameRefClass::Definition(def) => def,\n+                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                    Definition::Local(local_ref)\n+                }\n+            }) {\n                 // if the name differs from the definitions name it has to be an alias\n                 if def.name(sema.db).map_or(false, |it| it.to_string() != name_ref.text()) {\n                     bail!(\"Renaming aliases is currently unsupported\");\n@@ -124,9 +130,15 @@ fn find_definition(\n             }\n         }\n         ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n-            .map(|class| class.referenced())\n+            .and_then(|class| match class {\n+                NameRefClass::Definition(def) => Some(def),\n+                _ => None,\n+            })\n             .or_else(|| {\n-                NameClass::classify_lifetime(sema, &lifetime).map(|it| it.referenced_or_defined())\n+                NameClass::classify_lifetime(sema, &lifetime).and_then(|it| match it {\n+                    NameClass::Definition(it) => Some(it),\n+                    _ => None,\n+                })\n             }),\n     }\n     .ok_or_else(|| format_err!(\"No references found at position\"))?;"}, {"sha": "197a32da069438c00d1ee8839c1687980c478025", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -58,10 +58,8 @@ pub(super) fn element(\n                 Some(NameClass::ConstReference(def)) => highlight_def(db, krate, def),\n                 Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n                     let mut h = HlTag::Symbol(SymbolKind::Field).into();\n-                    if let Definition::Field(field) = field_ref {\n-                        if let hir::VariantDef::Union(_) = field.parent_def(db) {\n-                            h |= HlMod::Unsafe;\n-                        }\n+                    if let hir::VariantDef::Union(_) = field_ref.parent_def(db) {\n+                        h |= HlMod::Unsafe;\n                     }\n                     h\n                 }"}, {"sha": "4f0b1f5b79055f484432bf3ae91c241203ba13fa", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -638,7 +638,12 @@ fn vars_used_in_body(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n     body.descendants()\n         .filter_map(ast::NameRef::cast)\n         .filter_map(|name_ref| NameRefClass::classify(&ctx.sema, &name_ref))\n-        .map(|name_kind| name_kind.referenced())\n+        .map(|name_kind| match name_kind {\n+            NameRefClass::Definition(def) => def,\n+            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                Definition::Local(local_ref)\n+            }\n+        })\n         .filter_map(|definition| match definition {\n             Definition::Local(local) => Some(local),\n             _ => None,"}, {"sha": "198b568ad88226942c25243c3da626ed42462c37", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -112,12 +112,11 @@ pub enum NameClass {\n     /// `None` in `if let None = Some(82) {}`.\n     /// Syntactically, it is a name, but semantically it is a reference.\n     ConstReference(Definition),\n-    /// `field` in `if let Foo { field } = foo`. Here, `ast::Name` both Here the\n-    /// name both introduces a definition into a local scope, and refers to an\n-    /// existing definition.\n+    /// `field` in `if let Foo { field } = foo`. Here, `ast::Name` both introduces\n+    /// a definition into a local scope, and refers to an existing definition.\n     PatFieldShorthand {\n         local_def: Local,\n-        field_ref: Definition,\n+        field_ref: Field,\n     },\n }\n \n@@ -134,14 +133,6 @@ impl NameClass {\n         Some(res)\n     }\n \n-    /// `Definition` referenced or defined by this name.\n-    pub fn referenced_or_defined(self) -> Definition {\n-        match self {\n-            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-            NameClass::PatFieldShorthand { local_def: _, field_ref } => field_ref,\n-        }\n-    }\n-\n     pub fn classify(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n         let _p = profile::span(\"classify_name\");\n \n@@ -183,7 +174,12 @@ impl NameClass {\n                             })\n                             .and_then(|name_ref| NameRefClass::classify(sema, &name_ref))?;\n \n-                        Some(NameClass::Definition(name_ref_class.referenced()))\n+                        Some(NameClass::Definition(match name_ref_class {\n+                            NameRefClass::Definition(def) => def,\n+                            NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+                                Definition::Field(field_ref)\n+                            }\n+                        }))\n                     } else {\n                         let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n                         let krate = sema.resolve_extern_crate(&extern_crate)?;\n@@ -197,7 +193,6 @@ impl NameClass {\n                     if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n                         if record_pat_field.name_ref().is_none() {\n                             if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-                                let field = Definition::Field(field);\n                                 return Some(NameClass::PatFieldShorthand { local_def: local, field_ref: field });\n                             }\n                         }\n@@ -302,22 +297,10 @@ impl NameClass {\n #[derive(Debug)]\n pub enum NameRefClass {\n     Definition(Definition),\n-    FieldShorthand { local_ref: Local, field_ref: Definition },\n+    FieldShorthand { local_ref: Local, field_ref: Field },\n }\n \n impl NameRefClass {\n-    /// `Definition`, which this name refers to.\n-    pub fn referenced(self) -> Definition {\n-        match self {\n-            NameRefClass::Definition(def) => def,\n-            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                // FIXME: this is inherently ambiguous -- this name refers to\n-                // two different defs....\n-                Definition::Local(local_ref)\n-            }\n-        }\n-    }\n-\n     // Note: we don't have unit-tests for this rather important function.\n     // It is primarily exercised via goto definition tests in `ide`.\n     pub fn classify(\n@@ -342,9 +325,8 @@ impl NameRefClass {\n \n         if let Some(record_field) = ast::RecordExprField::for_field_name(name_ref) {\n             if let Some((field, local, _)) = sema.resolve_record_field(&record_field) {\n-                let field = Definition::Field(field);\n                 let res = match local {\n-                    None => NameRefClass::Definition(field),\n+                    None => NameRefClass::Definition(Definition::Field(field)),\n                     Some(local) => {\n                         NameRefClass::FieldShorthand { field_ref: field, local_ref: local }\n                     }"}, {"sha": "41254b784741416e0cc74d24bdd211ecfbbb7454", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe00358888a24c64878abc15f09b0e60e16db9d6/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=fe00358888a24c64878abc15f09b0e60e16db9d6", "patch": "@@ -550,6 +550,7 @@ impl<'a> FindUsages<'a> {\n                 }\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n+                let field = Definition::Field(field);\n                 let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let access = match self.def {\n                     Definition::Field(_) if field == self.def => reference_access(&field, name_ref),\n@@ -574,7 +575,7 @@ impl<'a> FindUsages<'a> {\n         match NameClass::classify(self.sema, name) {\n             Some(NameClass::PatFieldShorthand { local_def: _, field_ref })\n                 if matches!(\n-                    self.def, Definition::Field(_) if field_ref == self.def\n+                    self.def, Definition::Field(_) if Definition::Field(field_ref) == self.def\n                 ) =>\n             {\n                 let FileRange { file_id, range } = self.sema.original_range(name.syntax());"}]}