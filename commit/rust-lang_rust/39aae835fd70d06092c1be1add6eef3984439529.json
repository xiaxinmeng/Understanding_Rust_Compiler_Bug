{"sha": "39aae835fd70d06092c1be1add6eef3984439529", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5YWFlODM1ZmQ3MGQwNjA5MmMxYmUxYWRkNmVlZjM5ODQ0Mzk1Mjk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-15T12:41:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-15T12:41:07Z"}, "message": "Merge #6886\n\n6886: Expand statements for macros in lowering r=matklad a=edwin0cheng\n\nFixes #6811\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "d59398a2d4674a214d776ab97576209783aa4629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d59398a2d4674a214d776ab97576209783aa4629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39aae835fd70d06092c1be1add6eef3984439529", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf2K7jCRBK7hj4Ov3rIwAAdHIIAFTgJ4PF+yrTBIdX2k0W0W8c\nGyb8As3L6gm396KorXot73owj9t+IcflKWGSVWiWZRTP2vrSy3Pwoo0E56kTNT+d\nBUnQuJxIS4oqVhNzC8nSVmUR1ox6G4NFAq7wLAmSol9+HcYE+B5/G2BvAzmQYRCI\nwtZY4p99BnCVX/WslQegIgiVqQtlbBK1Ur5d8U4JdQ0iGHUaEYsxNYh6Xj/+DzEY\nPjjXA2M/7nG4xkE+hIYKBYIVgUk0VF8QaNVIyWW0GvRQpnj+tvmHW4YxRugC1fcL\n9HlpKgMgj3VBsskzpveYgSYpxMbnfGFFwF6KOKfR777EQ1qC0SafLIZJu7UCALQ=\n=saLJ\n-----END PGP SIGNATURE-----\n", "payload": "tree d59398a2d4674a214d776ab97576209783aa4629\nparent 435d46b1835eb29ffdefc6dacd609838a5c1035a\nparent 1f4da7098c46a81784a099d80ba63539f94092d2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1608036067 +0000\ncommitter GitHub <noreply@github.com> 1608036067 +0000\n\nMerge #6886\n\n6886: Expand statements for macros in lowering r=matklad a=edwin0cheng\n\nFixes #6811\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39aae835fd70d06092c1be1add6eef3984439529", "html_url": "https://github.com/rust-lang/rust/commit/39aae835fd70d06092c1be1add6eef3984439529", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39aae835fd70d06092c1be1add6eef3984439529/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "435d46b1835eb29ffdefc6dacd609838a5c1035a", "url": "https://api.github.com/repos/rust-lang/rust/commits/435d46b1835eb29ffdefc6dacd609838a5c1035a", "html_url": "https://github.com/rust-lang/rust/commit/435d46b1835eb29ffdefc6dacd609838a5c1035a"}, {"sha": "1f4da7098c46a81784a099d80ba63539f94092d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4da7098c46a81784a099d80ba63539f94092d2", "html_url": "https://github.com/rust-lang/rust/commit/1f4da7098c46a81784a099d80ba63539f94092d2"}], "stats": {"total": 247, "additions": 163, "deletions": 84}, "files": [{"sha": "6c0de3ee88be817360fc20b69a88f68e2192cb16", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 134, "deletions": 82, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=39aae835fd70d06092c1be1add6eef3984439529", "patch": "@@ -548,62 +548,83 @@ impl ExprCollector<'_> {\n                 }\n             }\n             ast::Expr::MacroCall(e) => {\n-                if let Some(name) = e.is_macro_rules().map(|it| it.as_name()) {\n-                    let mac = MacroDefId {\n-                        krate: Some(self.expander.module.krate),\n-                        ast_id: Some(self.expander.ast_id(&e)),\n-                        kind: MacroDefKind::Declarative,\n-                        local_inner: false,\n-                    };\n-                    self.body.item_scope.define_legacy_macro(name, mac);\n-\n-                    // FIXME: do we still need to allocate this as missing ?\n-                    self.alloc_expr(Expr::Missing, syntax_ptr)\n-                } else {\n-                    // File containing the macro call. Expansion errors will be attached here.\n-                    let outer_file = self.expander.current_file_id;\n-\n-                    let macro_call = self.expander.to_source(AstPtr::new(&e));\n-                    let res = self.expander.enter_expand(self.db, Some(&self.body.item_scope), e);\n-\n-                    match res.err {\n-                        Some(ExpandError::UnresolvedProcMacro) => {\n-                            self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro(\n-                                UnresolvedProcMacro {\n-                                    file: outer_file,\n-                                    node: syntax_ptr.clone().into(),\n-                                    precise_location: None,\n-                                    macro_name: None,\n-                                },\n-                            ));\n-                        }\n-                        Some(err) => {\n-                            self.source_map.diagnostics.push(BodyDiagnostic::MacroError(\n-                                MacroError {\n-                                    file: outer_file,\n-                                    node: syntax_ptr.clone().into(),\n-                                    message: err.to_string(),\n-                                },\n-                            ));\n-                        }\n-                        None => {}\n-                    }\n+                let mut ids = vec![];\n+                self.collect_macro_call(e, syntax_ptr.clone(), |this, expansion| {\n+                    ids.push(match expansion {\n+                        Some(it) => this.collect_expr(it),\n+                        None => this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                    })\n+                });\n+                ids[0]\n+            }\n+        }\n+    }\n \n-                    match res.value {\n-                        Some((mark, expansion)) => {\n-                            self.source_map\n-                                .expansions\n-                                .insert(macro_call, self.expander.current_file_id);\n-\n-                            let item_tree = self.db.item_tree(self.expander.current_file_id);\n-                            self.item_trees.insert(self.expander.current_file_id, item_tree);\n-                            let id = self.collect_expr(expansion);\n-                            self.expander.exit(self.db, mark);\n-                            id\n-                        }\n-                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+    fn collect_macro_call<F: FnMut(&mut Self, Option<T>), T: ast::AstNode>(\n+        &mut self,\n+        e: ast::MacroCall,\n+        syntax_ptr: AstPtr<ast::Expr>,\n+        mut collector: F,\n+    ) {\n+        if let Some(name) = e.is_macro_rules().map(|it| it.as_name()) {\n+            let mac = MacroDefId {\n+                krate: Some(self.expander.module.krate),\n+                ast_id: Some(self.expander.ast_id(&e)),\n+                kind: MacroDefKind::Declarative,\n+                local_inner: false,\n+            };\n+            self.body.item_scope.define_legacy_macro(name, mac);\n+\n+            // FIXME: do we still need to allocate this as missing ?\n+            collector(self, None);\n+        } else {\n+            // File containing the macro call. Expansion errors will be attached here.\n+            let outer_file = self.expander.current_file_id;\n+\n+            let macro_call = self.expander.to_source(AstPtr::new(&e));\n+            let res = self.expander.enter_expand(self.db, Some(&self.body.item_scope), e);\n+\n+            match &res.err {\n+                Some(ExpandError::UnresolvedProcMacro) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::UnresolvedProcMacro(\n+                        UnresolvedProcMacro {\n+                            file: outer_file,\n+                            node: syntax_ptr.into(),\n+                            precise_location: None,\n+                            macro_name: None,\n+                        },\n+                    ));\n+                }\n+                Some(err) => {\n+                    self.source_map.diagnostics.push(BodyDiagnostic::MacroError(MacroError {\n+                        file: outer_file,\n+                        node: syntax_ptr.into(),\n+                        message: err.to_string(),\n+                    }));\n+                }\n+                None => {}\n+            }\n+\n+            match res.value {\n+                Some((mark, expansion)) => {\n+                    // FIXME: Statements are too complicated to recover from error for now.\n+                    // It is because we don't have any hygenine for local variable expansion right now.\n+                    if T::can_cast(syntax::SyntaxKind::MACRO_STMTS) && res.err.is_some() {\n+                        self.expander.exit(self.db, mark);\n+                        collector(self, None);\n+                    } else {\n+                        self.source_map\n+                            .expansions\n+                            .insert(macro_call, self.expander.current_file_id);\n+\n+                        let item_tree = self.db.item_tree(self.expander.current_file_id);\n+                        self.item_trees.insert(self.expander.current_file_id, item_tree);\n+\n+                        collector(self, Some(expansion));\n+                        self.expander.exit(self.db, mark);\n                     }\n                 }\n+                None => collector(self, None),\n             }\n         }\n     }\n@@ -642,44 +663,75 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n-        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n-        self.collect_block_items(&block);\n-        let statements = block\n-            .statements()\n-            .filter_map(|s| {\n-                let stmt = match s {\n-                    ast::Stmt::LetStmt(stmt) => {\n-                        self.check_cfg(&stmt)?;\n-\n-                        let pat = self.collect_pat_opt(stmt.pat());\n-                        let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n-                        let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                        Statement::Let { pat, type_ref, initializer }\n-                    }\n-                    ast::Stmt::ExprStmt(stmt) => {\n-                        self.check_cfg(&stmt)?;\n+    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Vec<Statement>> {\n+        let stmt =\n+            match s {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    self.check_cfg(&stmt)?;\n \n-                        Statement::Expr(self.collect_expr_opt(stmt.expr()))\n-                    }\n-                    ast::Stmt::Item(item) => {\n-                        self.check_cfg(&item)?;\n+                    let pat = self.collect_pat_opt(stmt.pat());\n+                    let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                    vec![Statement::Let { pat, type_ref, initializer }]\n+                }\n+                ast::Stmt::ExprStmt(stmt) => {\n+                    self.check_cfg(&stmt)?;\n+\n+                    // Note that macro could be expended to multiple statements\n+                    if let Some(ast::Expr::MacroCall(m)) = stmt.expr() {\n+                        let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n+                        let mut stmts = vec![];\n+\n+                        self.collect_macro_call(m, syntax_ptr.clone(), |this, expansion| {\n+                            match expansion {\n+                                Some(expansion) => {\n+                                    let statements: ast::MacroStmts = expansion;\n+                                    this.collect_stmts_items(statements.statements());\n \n-                        return None;\n+                                    statements.statements().for_each(|stmt| {\n+                                        if let Some(mut r) = this.collect_stmt(stmt) {\n+                                            stmts.append(&mut r);\n+                                        }\n+                                    });\n+                                    if let Some(expr) = statements.expr() {\n+                                        stmts.push(Statement::Expr(this.collect_expr(expr)));\n+                                    }\n+                                }\n+                                None => {\n+                                    stmts.push(Statement::Expr(\n+                                        this.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                                    ));\n+                                }\n+                            }\n+                        });\n+                        stmts\n+                    } else {\n+                        vec![Statement::Expr(self.collect_expr_opt(stmt.expr()))]\n                     }\n-                };\n-                Some(stmt)\n-            })\n-            .collect();\n+                }\n+                ast::Stmt::Item(item) => {\n+                    self.check_cfg(&item)?;\n+\n+                    return None;\n+                }\n+            };\n+\n+        Some(stmt)\n+    }\n+\n+    fn collect_block(&mut self, block: ast::BlockExpr) -> ExprId {\n+        let syntax_node_ptr = AstPtr::new(&block.clone().into());\n+        self.collect_stmts_items(block.statements());\n+        let statements =\n+            block.statements().filter_map(|s| self.collect_stmt(s)).flatten().collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n         self.alloc_expr(Expr::Block { statements, tail, label: None }, syntax_node_ptr)\n     }\n \n-    fn collect_block_items(&mut self, block: &ast::BlockExpr) {\n+    fn collect_stmts_items(&mut self, stmts: ast::AstChildren<ast::Stmt>) {\n         let container = ContainerId::DefWithBodyId(self.def);\n \n-        let items = block\n-            .statements()\n+        let items = stmts\n             .filter_map(|stmt| match stmt {\n                 ast::Stmt::Item(it) => Some(it),\n                 ast::Stmt::LetStmt(_) | ast::Stmt::ExprStmt(_) => None,"}, {"sha": "864fad170fc7a8d7364f9a0b798bb7de1d1215ad", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=39aae835fd70d06092c1be1add6eef3984439529", "patch": "@@ -94,6 +94,9 @@ impl ItemTree {\n                 ast::MacroItems(items) => {\n                     ctx.lower_module_items(&items)\n                 },\n+                ast::MacroStmts(stmts) => {\n+                    ctx.lower_inner_items(stmts.syntax())\n+                },\n                 // Macros can expand to expressions. We return an empty item tree in this case, but\n                 // still need to collect inner items.\n                 ast::Expr(e) => {"}, {"sha": "11b5b98c87de3db54419649d38b13d7300ffb4dd", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=39aae835fd70d06092c1be1add6eef3984439529", "patch": "@@ -394,8 +394,8 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n             // FIXME: Handle Pattern\n             FragmentKind::Expr\n         }\n-        // FIXME: Expand to statements in appropriate positions; HIR lowering needs to handle that\n-        EXPR_STMT | BLOCK_EXPR => FragmentKind::Expr,\n+        EXPR_STMT => FragmentKind::Statements,\n+        BLOCK_EXPR => FragmentKind::Expr,\n         ARG_LIST => FragmentKind::Expr,\n         TRY_EXPR => FragmentKind::Expr,\n         TUPLE_EXPR => FragmentKind::Expr,"}, {"sha": "307a257b177098e8637854c8e325e3e128345328", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39aae835fd70d06092c1be1add6eef3984439529/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=39aae835fd70d06092c1be1add6eef3984439529", "patch": "@@ -592,6 +592,30 @@ fn issue_4465_dollar_crate_at_type() {\n     );\n }\n \n+#[test]\n+fn issue_6811() {\n+    check_infer(\n+        r#\"\n+        macro_rules! profile_function {\n+            () => {\n+                let _a = 1;\n+                let _b = 1;\n+            };\n+        }\n+        fn main() {\n+            profile_function!();\n+        }\n+        \"#,\n+        expect![[r#\"\n+            !3..5 '_a': i32\n+            !6..7 '1': i32\n+            !11..13 '_b': i32\n+            !14..15 '1': i32\n+            103..131 '{     ...!(); }': ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn issue_4053_diesel_where_clauses() {\n     check_infer("}]}