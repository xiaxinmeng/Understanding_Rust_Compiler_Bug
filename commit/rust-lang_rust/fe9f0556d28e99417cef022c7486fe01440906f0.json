{"sha": "fe9f0556d28e99417cef022c7486fe01440906f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOWYwNTU2ZDI4ZTk5NDE3Y2VmMDIyYzc0ODZmZTAxNDQwOTA2ZjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-06T19:30:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-09-06T19:31:33Z"}, "message": "Refactor ty_var and ty_var_integral into one ty_infer variant", "tree": {"sha": "7efc9a27db829be585a1fa1cfd05a55e9bb0ba9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7efc9a27db829be585a1fa1cfd05a55e9bb0ba9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe9f0556d28e99417cef022c7486fe01440906f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9f0556d28e99417cef022c7486fe01440906f0", "html_url": "https://github.com/rust-lang/rust/commit/fe9f0556d28e99417cef022c7486fe01440906f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe9f0556d28e99417cef022c7486fe01440906f0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b3e44b472dd94e9f0fb9b6d5f4f992df18a6a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b3e44b472dd94e9f0fb9b6d5f4f992df18a6a5", "html_url": "https://github.com/rust-lang/rust/commit/d5b3e44b472dd94e9f0fb9b6d5f4f992df18a6a5"}], "stats": {"total": 356, "additions": 182, "deletions": 174}, "files": [{"sha": "24f706eeb462d4ebf9b1ca15c89375a866243778", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -274,7 +274,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         parse_ty_rust_fn(st, conv)\n       }\n       'X' => {\n-        return ty::mk_var(st.tcx, ty::tv_vid(parse_int(st) as uint));\n+        return ty::mk_var(st.tcx, ty::ty_vid(parse_int(st) as uint));\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {"}, {"sha": "0ecb9dc3dc0be04adcdea170b665f0c4bf380e7c", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -274,11 +274,11 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_fn(f) => {\n         enc_ty_fn(w, cx, f);\n       }\n-      ty::ty_var(id) => {\n+      ty::ty_infer(ty::TyVar(id)) => {\n         w.write_char('X');\n         w.write_uint(id.to_uint());\n       }\n-      ty::ty_var_integral(id) => {\n+      ty::ty_infer(ty::IntVar(id)) => {\n         w.write_char('X');\n         w.write_char('I');\n         w.write_uint(id.to_uint());"}, {"sha": "5aeddac8ab3fc93c500b45ff47b5f318e7e0edf2", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -272,8 +272,7 @@ impl reflector {\n \n           // Miscallaneous extra types\n           ty::ty_trait(_, _, _) => self.leaf(~\"trait\"),\n-          ty::ty_var(_) => self.leaf(~\"var\"),\n-          ty::ty_var_integral(_) => self.leaf(~\"var_integral\"),\n+          ty::ty_infer(_) => self.leaf(~\"infer\"),\n           ty::ty_param(p) => self.visit(~\"param\", ~[self.c_uint(p.idx)]),\n           ty::ty_self => self.leaf(~\"self\"),\n           ty::ty_type => self.leaf(~\"type\"),"}, {"sha": "92ee4e5dc904669758b75d9006a2eb9f12d0d011", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -363,7 +363,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n         ~[shape_bare_fn],\n       ty::ty_opaque_closure_ptr(_) =>\n         ~[shape_opaque_closure_ptr],\n-      ty::ty_var(_) | ty::ty_var_integral(_) | ty::ty_self =>\n+      ty::ty_infer(_) | ty::ty_self =>\n         ccx.sess.bug(~\"shape_of: unexpected type struct found\")\n     }\n }"}, {"sha": "3cdb132f26cb50e0812d0d6eb87785e1a50e1744", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -171,11 +171,8 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         common::T_named_struct(llvm_type_name(cx, a_class, did, substs.tps))\n       }\n       ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n-      ty::ty_var(_) => cx.tcx.sess.bug(~\"type_of with ty_var\"),\n+      ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n       ty::ty_param(*) => cx.tcx.sess.bug(~\"type_of with ty_param\"),\n-      ty::ty_var_integral(_) => {\n-        cx.tcx.sess.bug(~\"type_of shouldn't see a ty_var_integral\");\n-      }\n     };\n \n     cx.lltypes.insert(t, llty);"}, {"sha": "2f352efc86497472c60cc2b5ddab84dfc9bbe4ed", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -21,7 +21,7 @@ use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n use std::serialization::{serialize_Option,\n                             deserialize_Option};\n \n-export tv_vid, tvi_vid, region_vid, vid;\n+export ty_vid, int_vid, region_vid, vid;\n export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n@@ -99,8 +99,8 @@ export ty_tup, mk_tup;\n export ty_type, mk_type;\n export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n-export ty_var, mk_var, type_is_var;\n-export ty_var_integral, mk_var_integral, type_is_var_integral;\n+export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var;\n+export InferTy, TyVar, IntVar;\n export ty_self, mk_self, type_has_self;\n export ty_class;\n export region, bound_region, encl_region;\n@@ -510,12 +510,11 @@ enum sty {\n     ty_class(def_id, substs),\n     ty_tup(~[t]),\n \n-    ty_var(tv_vid), // type variable during typechecking\n-    ty_var_integral(tvi_vid), // type variable during typechecking, for\n-                              // integral types only\n     ty_param(param_ty), // type parameter\n     ty_self, // special, implicit `self` type parameter\n \n+    ty_infer(InferTy), // soething used only during inference/typeck\n+\n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n@@ -568,21 +567,26 @@ enum param_bound {\n     bound_trait(t),\n }\n \n-enum tv_vid = uint;\n-enum tvi_vid = uint;\n+enum ty_vid = uint;\n+enum int_vid = uint;\n enum region_vid = uint;\n \n+enum InferTy {\n+    TyVar(ty_vid),\n+    IntVar(int_vid)\n+}\n+\n trait vid {\n     pure fn to_uint() -> uint;\n     pure fn to_str() -> ~str;\n }\n \n-impl tv_vid: vid {\n+impl ty_vid: vid {\n     pure fn to_uint() -> uint { *self }\n     pure fn to_str() -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n-impl tvi_vid: vid {\n+impl int_vid: vid {\n     pure fn to_uint() -> uint { *self }\n     pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n@@ -592,6 +596,22 @@ impl region_vid: vid {\n     pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n }\n \n+impl InferTy {\n+    pure fn to_hash() -> uint {\n+        match self {\n+            TyVar(v) => v.to_uint() << 1,\n+            IntVar(v) => (v.to_uint() << 1) + 1\n+        }\n+    }\n+\n+    pure fn to_str() -> ~str {\n+        match self {\n+            TyVar(v) => v.to_str(),\n+            IntVar(v) => v.to_str()\n+        }\n+    }\n+}\n+\n trait purity_to_str {\n     pure fn to_str() -> ~str;\n }\n@@ -744,7 +764,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n       ty_opaque_box => (),\n       ty_param(_) => flags |= has_params as uint,\n-      ty_var(_) | ty_var_integral(_) => flags |= needs_infer as uint,\n+      ty_infer(_) => flags |= needs_infer as uint,\n       ty_self => flags |= has_self as uint,\n       ty_enum(_, ref substs) | ty_class(_, ref substs)\n       | ty_trait(_, ref substs, _) => {\n@@ -882,12 +902,14 @@ fn mk_class(cx: ctxt, class_id: ast::def_id, +substs: substs) -> t {\n     mk_t(cx, ty_class(class_id, substs))\n }\n \n-fn mk_var(cx: ctxt, v: tv_vid) -> t { mk_t(cx, ty_var(v)) }\n+fn mk_var(cx: ctxt, v: ty_vid) -> t { mk_infer(cx, TyVar(v)) }\n \n-fn mk_var_integral(cx: ctxt, v: tvi_vid) -> t {\n-    mk_t(cx, ty_var_integral(v))\n+fn mk_int_var(cx: ctxt, v: int_vid) -> t {\n+    mk_infer(cx, IntVar(v))\n }\n \n+fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+\n fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n@@ -939,8 +961,7 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     match get(ty).struct {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n-      ty_opaque_closure_ptr(_) | ty_var(_) | ty_var_integral(_) |\n-      ty_param(_) => {\n+      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) => {\n       }\n       ty_box(tm) | ty_evec(tm, _) | ty_unboxed_vec(tm) |\n       ty_ptr(tm) | ty_rptr(_, tm) => {\n@@ -1023,8 +1044,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box | ty_var(_) | ty_var_integral(_) |\n-      ty_param(*) | ty_self => {\n+      ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self => {\n         *sty\n       }\n     }\n@@ -1240,16 +1260,9 @@ fn type_is_nil(ty: t) -> bool { get(ty).struct == ty_nil }\n \n fn type_is_bot(ty: t) -> bool { get(ty).struct == ty_bot }\n \n-fn type_is_var(ty: t) -> bool {\n+fn type_is_ty_var(ty: t) -> bool {\n     match get(ty).struct {\n-      ty_var(_) => true,\n-      _ => false\n-    }\n-}\n-\n-fn type_is_var_integral(ty: t) -> bool {\n-    match get(ty).struct {\n-      ty_var_integral(_) => true,\n+      ty_infer(TyVar(_)) => true,\n       _ => false\n     }\n }\n@@ -1370,7 +1383,7 @@ pure fn type_is_unique(ty: t) -> bool {\n pure fn type_is_scalar(ty: t) -> bool {\n     match get(ty).struct {\n       ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_var_integral(_) | ty_type | ty_ptr(_) => true,\n+      ty_infer(IntVar(_)) | ty_type | ty_ptr(_) => true,\n       _ => false\n     }\n }\n@@ -1852,7 +1865,7 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       // is never bounded in any way, hence it has the bottom kind.\n       ty_self => kind_noncopyable(),\n \n-      ty_var(_) | ty_var_integral(_) => {\n+      ty_infer(_) => {\n         cx.sess.bug(~\"Asked to compute kind of a type variable\");\n       }\n       ty_type | ty_opaque_closure_ptr(_)\n@@ -1923,7 +1936,7 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n         1\n       }\n \n-      ty_var(_) | ty_var_integral(_) => {\n+      ty_infer(_) => {\n         cx.sess.bug(~\"Asked to compute kind of a type variable\");\n       }\n       ty_type | ty_opaque_closure_ptr(_)\n@@ -1969,8 +1982,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_float(_) |\n           ty_estr(_) |\n           ty_fn(_) |\n-          ty_var(_) |\n-          ty_var_integral(_) |\n+          ty_infer(_) |\n           ty_param(_) |\n           ty_self |\n           ty_type |\n@@ -2103,7 +2115,7 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n \n fn type_is_integral(ty: t) -> bool {\n     match get(ty).struct {\n-      ty_var_integral(_) | ty_int(_) | ty_uint(_) | ty_bool => true,\n+      ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) | ty_bool => true,\n       _ => false\n     }\n }\n@@ -2176,7 +2188,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         result = false;\n       }\n \n-      ty_var(*) | ty_var_integral(*) | ty_self(*) => {\n+      ty_infer(*) | ty_self(*) => {\n         cx.sess.bug(~\"non concrete type in type_is_pod\");\n       }\n     }\n@@ -2353,8 +2365,7 @@ pure fn hash_type_structure(st: &sty) -> uint {\n         hash_subty(h, f.output)\n       }\n       ty_self => 28u,\n-      ty_var(v) => hash_uint(29u, v.to_uint()),\n-      ty_var_integral(v) => hash_uint(30u, v.to_uint()),\n+      ty_infer(v) => hash_uint(29u, v.to_hash()),\n       ty_param(p) => hash_def(hash_uint(31u, p.idx), p.def_id),\n       ty_type => 32u,\n       ty_bot => 34u,\n@@ -2462,21 +2473,23 @@ fn is_pred_ty(fty: t) -> bool {\n     is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n }\n \n-fn ty_var_id(typ: t) -> tv_vid {\n+/*\n+fn ty_var_id(typ: t) -> ty_vid {\n     match get(typ).struct {\n-      ty_var(vid) => return vid,\n+      ty_infer(TyVar(vid)) => return vid,\n       _ => { error!(\"ty_var_id called on non-var ty\"); fail; }\n     }\n }\n \n-fn ty_var_integral_id(typ: t) -> tvi_vid {\n+fn int_var_id(typ: t) -> int_vid {\n     match get(typ).struct {\n-      ty_var_integral(vid) => return vid,\n+      ty_infer(IntVar(vid)) => return vid,\n       _ => { error!(\"ty_var_integral_id called on ty other than \\\n                   ty_var_integral\");\n          fail; }\n     }\n }\n+*/\n \n // Type accessors for AST nodes\n fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n@@ -2752,15 +2765,15 @@ fn param_tys_in_type(ty: t) -> ~[param_ty] {\n     rslt\n }\n \n-fn occurs_check(tcx: ctxt, sp: span, vid: tv_vid, rt: t) {\n+fn occurs_check(tcx: ctxt, sp: span, vid: ty_vid, rt: t) {\n \n     // Returns a vec of all the type variables occurring in `ty`. It may\n     // contain duplicates.  (Integral type vars aren't counted.)\n-    fn vars_in_type(ty: t) -> ~[tv_vid] {\n+    fn vars_in_type(ty: t) -> ~[ty_vid] {\n         let mut rslt = ~[];\n         do walk_ty(ty) |ty| {\n             match get(ty).struct {\n-              ty_var(v) => vec::push(rslt, v),\n+              ty_infer(TyVar(v)) => vec::push(rslt, v),\n               _ => ()\n             }\n         }\n@@ -2876,8 +2889,8 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n       ty_class(id, _) => fmt!(\"class %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n-      ty_var(_) => ~\"variable\",\n-      ty_var_integral(_) => ~\"integral variable\",\n+      ty_infer(TyVar(_)) => ~\"inferred type\",\n+      ty_infer(IntVar(_)) => ~\"integral variable\",\n       ty_param(_) => ~\"type parameter\",\n       ty_self => ~\"self\"\n     }\n@@ -3487,7 +3500,7 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     fn tycat(ty: t) -> int {\n         match get(ty).struct {\n           ty_bool => tycat_bool,\n-          ty_int(_) | ty_uint(_) | ty_var_integral(_) => tycat_int,\n+          ty_int(_) | ty_uint(_) | ty_infer(IntVar(_)) => tycat_int,\n           ty_float(_) => tycat_float,\n           ty_rec(_) | ty_tup(_) | ty_enum(_, _) => tycat_struct,\n           ty_bot => tycat_bot,\n@@ -3706,14 +3719,14 @@ impl fn_ty : cmp::Eq {\n     }\n }\n \n-impl tv_vid: cmp::Eq {\n-    pure fn eq(&&other: tv_vid) -> bool {\n+impl ty_vid: cmp::Eq {\n+    pure fn eq(&&other: ty_vid) -> bool {\n         *self == *other\n     }\n }\n \n-impl tvi_vid: cmp::Eq {\n-    pure fn eq(&&other: tvi_vid) -> bool {\n+impl int_vid: cmp::Eq {\n+    pure fn eq(&&other: int_vid) -> bool {\n         *self == *other\n     }\n }\n@@ -3800,6 +3813,12 @@ impl substs : cmp::Eq {\n     }\n }\n \n+impl InferTy : cmp::Eq {\n+    pure fn eq(&&other: InferTy) -> bool {\n+        self.to_hash() == other.to_hash()\n+    }\n+}\n+\n impl sty : cmp::Eq {\n     pure fn eq(&&other: sty) -> bool {\n         match self {\n@@ -3912,15 +3931,9 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ty_var(e0a) => {\n-                match other {\n-                    ty_var(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_var_integral(e0a) => {\n+            ty_infer(e0a) => {\n                 match other {\n-                    ty_var_integral(e0b) => e0a == e0b,\n+                    ty_infer(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }"}, {"sha": "933629bdf91852bf7cf7d1ab4627368861ce6ccc", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -422,7 +422,7 @@ fn ty_of_arg<AC: ast_conv, RS: region_scope copy owned>(\n               // If the type is not specified, then this must be a fn expr.\n               // Leave the mode as infer(_), it will get inferred based\n               // on constraints elsewhere.\n-              ty::ty_var(_) => a.mode,\n+              ty::ty_infer(_) => a.mode,\n \n               // If the type is known, then use the default for that type.\n               // Here we unify m and the default.  This should update the"}, {"sha": "52970baa54794476a40e6ef9d79a6e7b98df3682", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -60,15 +60,15 @@ type variable is rather an \"instance\" of a type parameter: that is,\n given a generic function `fn foo<T>(t: T)`: while checking the\n function `foo`, the type `ty_param(0)` refers to the type `T`, which\n is treated in abstract.  When `foo()` is called, however, `T` will be\n-substituted for a fresh type variable `ty_var(N)`.  This variable will\n+substituted for a fresh type variable `N`.  This variable will\n eventually be resolved to some concrete type (which might itself be\n type parameter).\n \n */\n \n use astconv::{ast_conv, ast_path_to_ty, ast_ty_to_ty};\n use astconv::{ast_region_to_region};\n-use middle::ty::{tv_vid, vid};\n+use middle::ty::{ty_vid, vid};\n use regionmanip::{replace_bound_regions_in_fn_ty};\n use rscope::{anon_rscope, binding_rscope, empty_rscope, in_anon_rscope};\n use rscope::{in_binding_rscope, region_scope, type_rscope,\n@@ -98,7 +98,7 @@ type self_info = {\n /// share the inherited fields.\n struct inherited {\n     infcx: infer::infer_ctxt;\n-    locals: hashmap<ast::node_id, tv_vid>;\n+    locals: hashmap<ast::node_id, ty_vid>;\n     node_types: hashmap<ast::node_id, ty::t>;\n     node_type_substs: hashmap<ast::node_id, ty::substs>;\n     borrowings: hashmap<ast::node_id, ty::borrow>;\n@@ -749,33 +749,33 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n \n         // Some extra checks to detect weird cycles and so forth:\n         match sty {\n-          ty::ty_box(inner) | ty::ty_uniq(inner) | ty::ty_rptr(_, inner) => {\n-            match ty::get(t1).struct {\n-              ty::ty_var(v1) => {\n-                ty::occurs_check(fcx.ccx.tcx, sp, v1,\n-                                 ty::mk_box(fcx.ccx.tcx, inner));\n-              }\n-              _ => ()\n+            ty::ty_box(inner) | ty::ty_uniq(inner) | ty::ty_rptr(_, inner) => {\n+                match ty::get(t1).struct {\n+                    ty::ty_infer(ty::TyVar(v1)) => {\n+                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n+                                         ty::mk_box(fcx.ccx.tcx, inner));\n+                    }\n+                    _ => ()\n+                }\n             }\n-          }\n-          ty::ty_enum(did, _) => {\n-            // Watch out for a type like `enum t = @t`.  Such a type would\n-            // otherwise infinitely auto-deref.  This is the only autoderef\n-            // loop that needs to be concerned with this, as an error will be\n-            // reported on the enum definition as well because the enum is not\n-            // instantiable.\n-            if vec::contains(enum_dids, did) {\n-                return t1;\n+            ty::ty_enum(did, _) => {\n+                // Watch out for a type like `enum t = @t`.  Such a type would\n+                // otherwise infinitely auto-deref.  This is the only autoderef\n+                // loop that needs to be concerned with this, as an error will be\n+                // reported on the enum definition as well because the enum is not\n+                // instantiable.\n+                if vec::contains(enum_dids, did) {\n+                    return t1;\n+                }\n+                vec::push(enum_dids, did);\n             }\n-            vec::push(enum_dids, did);\n-          }\n-          _ => { /*ok*/ }\n+            _ => { /*ok*/ }\n         }\n \n         // Otherwise, deref if type is derefable:\n         match ty::deref_sty(fcx.ccx.tcx, &sty, false) {\n-          None => return t1,\n-          Some(mt) => t1 = mt.ty\n+            None => return t1,\n+            Some(mt) => t1 = mt.ty\n         }\n     };\n }\n@@ -791,7 +791,7 @@ fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n       ast::lit_int_unsuffixed(_) => {\n         // An unsuffixed integer literal could have any integral type,\n         // so we create an integral type variable for it.\n-        ty::mk_var_integral(tcx, fcx.infcx().next_ty_var_integral_id())\n+        ty::mk_int_var(tcx, fcx.infcx().next_int_var_id())\n       }\n       ast::lit_float(_, t) => ty::mk_mach_float(tcx, t),\n       ast::lit_nil => ty::mk_nil(tcx),\n@@ -2304,7 +2304,7 @@ fn self_ref(fcx: @fn_ctxt, id: ast::node_id) -> bool {\n                         ast_util::is_self)\n }\n \n-fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> tv_vid {\n+fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ty_vid {\n     match fcx.inh.locals.find(id) {\n         Some(x) => x,\n         _ => {\n@@ -2441,7 +2441,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n // resolution is possible, then an error is reported.\n fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n-        Ok(t_s) if !ty::type_is_var(t_s) => return t_s,\n+        Ok(t_s) if !ty::type_is_ty_var(t_s) => return t_s,\n         _ => {\n             fcx.ccx.tcx.sess.span_fatal\n                 (sp, ~\"the type of this value must be known in this context\");"}, {"sha": "c1473f08b828a7cf7b06ab74449d48065937bce8", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -12,9 +12,9 @@ use middle::ty::{get, lookup_item_type, subst, t, ty_box};\n use middle::ty::{ty_uniq, ty_ptr, ty_rptr, ty_enum};\n use middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec};\n-use middle::ty::{ty_fn, ty_trait, ty_tup, ty_var, ty_var_integral};\n+use middle::ty::{ty_fn, ty_trait, ty_tup, ty_infer};\n use middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n-use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_var};\n+use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_ty_var};\n use middle::typeck::infer::{infer_ctxt, can_mk_subty};\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use syntax::ast::{crate, def_id, def_mod};\n@@ -43,7 +43,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n     match resolve_type(inference_context,\n                      original_type,\n                      resolve_ivar) {\n-        Ok(resulting_type) if !type_is_var(resulting_type) => {\n+        Ok(resulting_type) if !type_is_ty_var(resulting_type) => {\n             resolved_type = resulting_type;\n         }\n         _ => {\n@@ -72,7 +72,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n \n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n         ty_estr(*) | ty_evec(*) | ty_rec(*) |\n-        ty_fn(*) | ty_tup(*) | ty_var(*) | ty_var_integral(*) |\n+        ty_fn(*) | ty_tup(*) | ty_infer(*) |\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) => {\n             debug!(\"(getting base type) no base type; found %?\","}, {"sha": "a658ef044dfc99fac2f252c6016949c04c6de4d7", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -250,8 +250,8 @@ use std::smallintmap;\n use std::smallintmap::smallintmap;\n use std::map::hashmap;\n use middle::ty;\n-use middle::ty::{tv_vid, tvi_vid, region_vid, vid,\n-                    ty_int, ty_uint, get, terr_fn};\n+use middle::ty::{ty_vid, int_vid, region_vid, vid,\n+                 ty_int, ty_uint, get, terr_fn, TyVar, IntVar};\n use syntax::{ast, ast_util};\n use syntax::ast::{ret_style, purity};\n use util::ppaux::{ty_to_str, mt_to_str};\n@@ -312,25 +312,25 @@ enum infer_ctxt = @{\n     // We instantiate vals_and_bindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    ty_var_bindings: vals_and_bindings<ty::tv_vid, bounds<ty::t>>,\n+    ty_var_bindings: vals_and_bindings<ty::ty_vid, bounds<ty::t>>,\n \n     // The types that might instantiate an integral type variable are\n     // represented by an int_ty_set.\n-    ty_var_integral_bindings: vals_and_bindings<ty::tvi_vid, int_ty_set>,\n+    int_var_bindings: vals_and_bindings<ty::int_vid, int_ty_set>,\n \n     // For region variables.\n     region_vars: RegionVarBindings,\n \n     // For keeping track of existing type and region variables.\n     ty_var_counter: @mut uint,\n-    ty_var_integral_counter: @mut uint,\n+    int_var_counter: @mut uint,\n     region_var_counter: @mut uint\n };\n \n enum fixup_err {\n-    unresolved_int_ty(tvi_vid),\n-    unresolved_ty(tv_vid),\n-    cyclic_ty(tv_vid),\n+    unresolved_int_ty(int_vid),\n+    unresolved_ty(ty_vid),\n+    cyclic_ty(ty_vid),\n     unresolved_region(region_vid),\n     region_var_bound_by_region_var(region_vid, region_vid)\n }\n@@ -358,10 +358,10 @@ fn new_vals_and_bindings<V:copy, T:copy>() -> vals_and_bindings<V, T> {\n fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n     infer_ctxt(@{tcx: tcx,\n                  ty_var_bindings: new_vals_and_bindings(),\n-                 ty_var_integral_bindings: new_vals_and_bindings(),\n+                 int_var_bindings: new_vals_and_bindings(),\n                  region_vars: RegionVarBindings(tcx),\n                  ty_var_counter: @mut 0u,\n-                 ty_var_integral_counter: @mut 0u,\n+                 int_var_counter: @mut 0u,\n                  region_var_counter: @mut 0u})}\n \n fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n@@ -508,7 +508,7 @@ fn rollback_to<V:copy vid, T:copy>(\n \n struct Snapshot {\n     ty_var_bindings_len: uint;\n-    ty_var_integral_bindings_len: uint;\n+    int_var_bindings_len: uint;\n     region_vars_snapshot: uint;\n }\n \n@@ -532,8 +532,8 @@ impl infer_ctxt {\n         Snapshot {\n             ty_var_bindings_len:\n                 self.ty_var_bindings.bindings.len(),\n-            ty_var_integral_bindings_len:\n-                self.ty_var_integral_bindings.bindings.len(),\n+            int_var_bindings_len:\n+                self.int_var_bindings.bindings.len(),\n             region_vars_snapshot:\n                 self.region_vars.start_snapshot(),\n         }\n@@ -543,9 +543,9 @@ impl infer_ctxt {\n         debug!(\"rollback!\");\n         rollback_to(&self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n-        // FIXME(#3211) -- ty_var_integral not transactional\n-        //rollback_to(&self.ty_var_integral_bindings,\n-        //            snapshot.ty_var_integral_bindings_len);\n+        // FIXME(#3211) -- int_var not transactional\n+        //rollback_to(&self.int_var_bindings,\n+        //            snapshot.int_var_bindings_len);\n \n         self.region_vars.rollback_to(\n             snapshot.region_vars_snapshot);\n@@ -563,7 +563,7 @@ impl infer_ctxt {\n             // destructors but kept the vec at its currently allocated\n             // length\n             self.ty_var_bindings.bindings = ~[];\n-            self.ty_var_integral_bindings.bindings = ~[];\n+            self.int_var_bindings.bindings = ~[];\n             self.region_vars.commit();\n             r\n         }\n@@ -596,12 +596,12 @@ impl infer_ctxt {\n }\n \n impl infer_ctxt {\n-    fn next_ty_var_id() -> tv_vid {\n+    fn next_ty_var_id() -> ty_vid {\n         let id = *self.ty_var_counter;\n         *self.ty_var_counter += 1u;\n         self.ty_var_bindings.vals.insert(id,\n                                          root({lb: None, ub: None}, 0u));\n-        return tv_vid(id);\n+        return ty_vid(id);\n     }\n \n     fn next_ty_var() -> ty::t {\n@@ -612,17 +612,17 @@ impl infer_ctxt {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_ty_var_integral_id() -> tvi_vid {\n-        let id = *self.ty_var_integral_counter;\n-        *self.ty_var_integral_counter += 1u;\n+    fn next_int_var_id() -> int_vid {\n+        let id = *self.int_var_counter;\n+        *self.int_var_counter += 1u;\n \n-        self.ty_var_integral_bindings.vals.insert(id,\n+        self.int_var_bindings.vals.insert(id,\n                               root(int_ty_set_all(), 0u));\n-        return tvi_vid(id);\n+        return int_vid(id);\n     }\n \n-    fn next_ty_var_integral() -> ty::t {\n-        ty::mk_var_integral(self.tcx, self.next_ty_var_integral_id())\n+    fn next_int_var() -> ty::t {\n+        ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n     fn next_region_var_nb(span: span) -> ty::region {"}, {"sha": "42dc90156f9c4700d483e2b334c765b3c5586a25", "filename": "src/rustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -75,7 +75,7 @@ impl Assign {\n                 Ok(None)\n             }\n \n-            (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n+            (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n                 let nde_a = self.infcx.get(&self.infcx.ty_var_bindings, a_id);\n                 let nde_b = self.infcx.get(&self.infcx.ty_var_bindings, b_id);\n                 let a_bounds = nde_a.possible_types;\n@@ -86,15 +86,15 @@ impl Assign {\n                 self.assign_tys_or_sub(a, b, a_bnd, b_bnd)\n             }\n \n-            (ty::ty_var(a_id), _) => {\n+            (ty::ty_infer(TyVar(a_id)), _) => {\n                 let nde_a = self.infcx.get(&self.infcx.ty_var_bindings, a_id);\n                 let a_bounds = nde_a.possible_types;\n \n                 let a_bnd = option::or(a_bounds.ub, a_bounds.lb);\n                 self.assign_tys_or_sub(a, b, a_bnd, Some(b))\n             }\n \n-            (_, ty::ty_var(b_id)) => {\n+            (_, ty::ty_infer(TyVar(b_id))) => {\n                 let nde_b = self.infcx.get(&self.infcx.ty_var_bindings, b_id);\n                 let b_bounds = nde_b.possible_types;\n "}, {"sha": "2b194ebdf177ca08b3cef317452a67b181e322b9", "filename": "src/rustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -345,8 +345,8 @@ fn super_tys<C:combine>(\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (ty::ty_bot, _) |\n       (_, ty::ty_bot) |\n-      (ty::ty_var(_), _) |\n-      (_, ty::ty_var(_)) => {\n+      (ty::ty_infer(TyVar(_)), _) |\n+      (_, ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n             fmt!(\"%s: bot and var types should have been handled (%s,%s)\",\n                  self.tag(),\n@@ -355,16 +355,16 @@ fn super_tys<C:combine>(\n       }\n \n       // Relate integral variables to other types\n-      (ty::ty_var_integral(a_id), ty::ty_var_integral(b_id)) => {\n-        self.infcx().vars_integral(a_id, b_id).then(|| Ok(a) )\n+      (ty::ty_infer(IntVar(a_id)), ty::ty_infer(IntVar(b_id))) => {\n+        self.infcx().int_vars(a_id, b_id).then(|| Ok(a) )\n       }\n-      (ty::ty_var_integral(a_id), ty::ty_int(_)) |\n-      (ty::ty_var_integral(a_id), ty::ty_uint(_)) => {\n-        self.infcx().var_integral_sub_t(a_id, b).then(|| Ok(a) )\n+      (ty::ty_infer(IntVar(a_id)), ty::ty_int(_)) |\n+      (ty::ty_infer(IntVar(a_id)), ty::ty_uint(_)) => {\n+        self.infcx().int_var_sub_t(a_id, b).then(|| Ok(a) )\n       }\n-      (ty::ty_int(_), ty::ty_var_integral(b_id)) |\n-      (ty::ty_uint(_), ty::ty_var_integral(b_id)) => {\n-        self.infcx().t_sub_var_integral(a, b_id).then(|| Ok(a) )\n+      (ty::ty_int(_), ty::ty_infer(IntVar(b_id))) |\n+      (ty::ty_uint(_), ty::ty_infer(IntVar(b_id))) => {\n+        self.infcx().t_sub_int_var(a, b_id).then(|| Ok(a) )\n       }\n \n       (ty::ty_int(_), _) |"}, {"sha": "5fc9ee8d1a7e1ab7349fe91ea2c9f5f148067a94", "filename": "src/rustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -46,17 +46,17 @@ fn lattice_tys<L:lattice_ops combine>(\n           (ty::ty_bot, _) => self.ty_bot(b),\n           (_, ty::ty_bot) => self.ty_bot(a),\n \n-          (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n+          (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n             lattice_vars(self, a, a_id, b_id,\n                          |x, y| self.tys(x, y) )\n           }\n \n-          (ty::ty_var(a_id), _) => {\n+          (ty::ty_infer(TyVar(a_id)), _) => {\n             lattice_var_and_t(self, a_id, b,\n                               |x, y| self.tys(x, y) )\n           }\n \n-          (_, ty::ty_var(b_id)) => {\n+          (_, ty::ty_infer(TyVar(b_id))) => {\n             lattice_var_and_t(self, b_id, a,\n                               |x, y| self.tys(x, y) )\n           }\n@@ -68,7 +68,7 @@ fn lattice_tys<L:lattice_ops combine>(\n }\n \n fn lattice_vars<L:lattice_ops combine>(\n-    self: &L, +a_t: ty::t, +a_vid: ty::tv_vid, +b_vid: ty::tv_vid,\n+    self: &L, +a_t: ty::t, +a_vid: ty::ty_vid, +b_vid: ty::ty_vid,\n     c_ts: fn(ty::t, ty::t) -> cres<ty::t>) -> cres<ty::t> {\n \n     // The comments in this function are written for LUB and types,\n@@ -112,7 +112,7 @@ fn lattice_vars<L:lattice_ops combine>(\n }\n \n fn lattice_var_and_t<L:lattice_ops combine>(\n-    self: &L, a_id: ty::tv_vid, b: ty::t,\n+    self: &L, a_id: ty::ty_vid, b: ty::t,\n     c_ts: fn(ty::t, ty::t) -> cres<ty::t>) -> cres<ty::t> {\n \n     let vb = &self.infcx().ty_var_bindings;"}, {"sha": "8d6841357c08a6719efb0694cf6b4767a32766c8", "filename": "src/rustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -55,7 +55,7 @@ type resolve_state_ = {\n     infcx: infer_ctxt,\n     modes: uint,\n     mut err: Option<fixup_err>,\n-    mut v_seen: ~[tv_vid]\n+    mut v_seen: ~[ty_vid]\n };\n \n enum resolve_state {\n@@ -113,11 +113,11 @@ impl resolve_state {\n             if !ty::type_needs_infer(typ) { return typ; }\n \n             match ty::get(typ).struct {\n-              ty::ty_var(vid) => {\n+              ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n               }\n-              ty::ty_var_integral(vid) => {\n-                self.resolve_ty_var_integral(vid)\n+              ty::ty_infer(IntVar(vid)) => {\n+                self.resolve_int_var(vid)\n               }\n               _ => {\n                 if !self.should(resolve_rvar) &&\n@@ -169,7 +169,7 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_ty_var(vid: tv_vid) -> ty::t {\n+    fn resolve_ty_var(vid: ty_vid) -> ty::t {\n         if vec::contains(self.v_seen, vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n@@ -202,12 +202,12 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_ty_var_integral(vid: tvi_vid) -> ty::t {\n+    fn resolve_int_var(vid: int_vid) -> ty::t {\n         if !self.should(resolve_ivar) {\n-            return ty::mk_var_integral(self.infcx.tcx, vid);\n+            return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n \n-        let nde = self.infcx.get(&self.infcx.ty_var_integral_bindings, vid);\n+        let nde = self.infcx.get(&self.infcx.int_var_bindings, vid);\n         let pt = nde.possible_types;\n \n         // If there's only one type in the set of possible types, then\n@@ -219,13 +219,13 @@ impl resolve_state {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n-                    &self.infcx.ty_var_integral_bindings, vid,\n+                    &self.infcx.int_var_bindings, vid,\n                     root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n                                                            ty),\n                         nde.rank));\n                 ty\n             } else {\n-                ty::mk_var_integral(self.infcx.tcx, vid)\n+                ty::mk_int_var(self.infcx.tcx, vid)\n             }\n           }\n         }"}, {"sha": "f3853134a373896a18873320ede29d23ef6c0a30", "filename": "src/rustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -105,13 +105,13 @@ impl Sub: combine {\n               (ty::ty_bot, _) => {\n                 Ok(a)\n               }\n-              (ty::ty_var(a_id), ty::ty_var(b_id)) => {\n+              (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n                 var_sub_var(&self, a_id, b_id).then(|| Ok(a) )\n               }\n-              (ty::ty_var(a_id), _) => {\n+              (ty::ty_infer(TyVar(a_id)), _) => {\n                 var_sub_t(&self, a_id, b).then(|| Ok(a) )\n               }\n-              (_, ty::ty_var(b_id)) => {\n+              (_, ty::ty_infer(TyVar(b_id))) => {\n                 t_sub_var(&self, a, b_id).then(|| Ok(a) )\n               }\n               (_, ty::ty_bot) => {"}, {"sha": "e8e834cfc57d094ee59824bf4fe4e1bc924b43be", "filename": "src/rustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -113,7 +113,7 @@ fn merge_bnds<C: combine>(\n \n fn set_var_to_merged_bounds<C: combine>(\n     self: &C,\n-    v_id: ty::tv_vid,\n+    v_id: ty::ty_vid,\n     a: bounds<ty::t>,\n     b: bounds<ty::t>,\n     rank: uint) -> ures {\n@@ -175,8 +175,8 @@ fn set_var_to_merged_bounds<C: combine>(\n /// subtle and tricky process, as described in detail at the top\n /// of infer.rs\n fn var_sub_var<C: combine>(self: &C,\n-                           a_id: ty::tv_vid,\n-                           b_id: ty::tv_vid) -> ures {\n+                           a_id: ty::ty_vid,\n+                           b_id: ty::ty_vid) -> ures {\n     let vb = &self.infcx().ty_var_bindings;\n \n     // Need to make sub_id a subtype of sup_id.\n@@ -241,7 +241,7 @@ fn var_sub_var<C: combine>(self: &C,\n }\n \n /// make variable a subtype of T\n-fn var_sub_t<C: combine>(self: &C, a_id: ty::tv_vid, b: ty::t) -> ures {\n+fn var_sub_t<C: combine>(self: &C, a_id: ty::ty_vid, b: ty::t) -> ures {\n \n     let vb = &self.infcx().ty_var_bindings;\n     let nde_a = self.infcx().get(vb, a_id);\n@@ -257,7 +257,7 @@ fn var_sub_t<C: combine>(self: &C, a_id: ty::tv_vid, b: ty::t) -> ures {\n }\n \n /// make T a subtype of variable\n-fn t_sub_var<C: combine>(self: &C, a: ty::t, b_id: ty::tv_vid) -> ures {\n+fn t_sub_var<C: combine>(self: &C, a: ty::t, b_id: ty::ty_vid) -> ures {\n \n     let vb = &self.infcx().ty_var_bindings;\n     let a_bounds = {lb: Some(a), ub: None};\n@@ -294,8 +294,8 @@ fn bnds<C: combine>(\n // Integral variables\n \n impl infer_ctxt {\n-    fn vars_integral(a_id: ty::tvi_vid, b_id: ty::tvi_vid) -> ures {\n-        let vb = &self.ty_var_integral_bindings;\n+    fn int_vars(a_id: ty::int_vid, b_id: ty::int_vid) -> ures {\n+        let vb = &self.int_var_bindings;\n \n         let nde_a = self.get(vb, a_id);\n         let nde_b = self.get(vb, b_id);\n@@ -317,18 +317,18 @@ impl infer_ctxt {\n \n         // Rank optimization\n         if nde_a.rank > nde_b.rank {\n-            debug!(\"vars_integral(): a has smaller rank\");\n+            debug!(\"int_vars(): a has smaller rank\");\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n             self.set(vb, a_id, root(intersection, nde_a.rank));\n             self.set(vb, b_id, redirect(a_id));\n         } else if nde_a.rank < nde_b.rank {\n-            debug!(\"vars_integral(): b has smaller rank\");\n+            debug!(\"int_vars(): b has smaller rank\");\n             // b has greater rank, so a should redirect to b.\n             self.set(vb, b_id, root(intersection, nde_b.rank));\n             self.set(vb, a_id, redirect(b_id));\n         } else {\n-            debug!(\"vars_integral(): a and b have equal rank\");\n+            debug!(\"int_vars(): a and b have equal rank\");\n             assert nde_a.rank == nde_b.rank;\n             // If equal, just redirect one to the other and increment\n             // the other's rank.  We choose arbitrarily to redirect b\n@@ -340,10 +340,10 @@ impl infer_ctxt {\n         uok()\n     }\n \n-    fn var_integral_sub_t(a_id: ty::tvi_vid, b: ty::t) -> ures {\n+    fn int_var_sub_t(a_id: ty::int_vid, b: ty::t) -> ures {\n         assert ty::type_is_integral(b);\n \n-        let vb = &self.ty_var_integral_bindings;\n+        let vb = &self.int_var_bindings;\n         let nde_a = self.get(vb, a_id);\n         let a_id = nde_a.root;\n         let a_pt = nde_a.possible_types;\n@@ -358,9 +358,9 @@ impl infer_ctxt {\n         uok()\n     }\n \n-    fn t_sub_var_integral(a: ty::t, b_id: ty::tvi_vid) -> ures {\n+    fn t_sub_int_var(a: ty::t, b_id: ty::int_vid) -> ures {\n         assert ty::type_is_integral(a);\n-        let vb = &self.ty_var_integral_bindings;\n+        let vb = &self.int_var_bindings;\n \n         let nde_b = self.get(vb, b_id);\n         let b_id = nde_b.root;"}, {"sha": "bb54e9df19bd01b27cad647a6226efa4183cd803", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe9f0556d28e99417cef022c7486fe01440906f0/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=fe9f0556d28e99417cef022c7486fe01440906f0", "patch": "@@ -9,7 +9,7 @@ use middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n-use middle::ty::{ty_type, ty_uniq, ty_uint, ty_var, ty_var_integral};\n+use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n use middle::ty::{ty_unboxed_vec, vid};\n use metadata::encoder;\n use syntax::codemap;\n@@ -335,8 +335,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         fn_to_str(cx, f.purity, f.proto, None, f.inputs,\n                   f.output, f.ret_style)\n       }\n-      ty_var(v) => v.to_str(),\n-      ty_var_integral(v) => v.to_str(),\n+      ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_param({idx: id, _}) => {\n         ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n       }"}]}