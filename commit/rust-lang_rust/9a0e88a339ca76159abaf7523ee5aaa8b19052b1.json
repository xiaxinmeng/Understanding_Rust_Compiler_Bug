{"sha": "9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMGU4OGEzMzljYTc2MTU5YWJhZjc1MjNlZTVhYWE4YjE5MDUyYjE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-18T09:45:06Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-22T07:13:54Z"}, "message": "Refactor away `ParentLink`.", "tree": {"sha": "a01ee9d9bfb6280a5b86cfad8634cead3262fcdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a01ee9d9bfb6280a5b86cfad8634cead3262fcdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "html_url": "https://github.com/rust-lang/rust/commit/9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf592fa40ca4104b59b867817881ca056f408ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf592fa40ca4104b59b867817881ca056f408ad", "html_url": "https://github.com/rust-lang/rust/commit/1cf592fa40ca4104b59b867817881ca056f408ad"}], "stats": {"total": 179, "additions": 78, "deletions": 101}, "files": [{"sha": "8c36d712a0dd7cd8e53ce2846e1abecddd5eecbc", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "patch": "@@ -14,10 +14,9 @@\n //! any imports resolved.\n \n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport};\n-use Module;\n+use {Module, ModuleKind};\n use Namespace::{self, TypeNS, ValueNS};\n use {NameBinding, NameBindingKind, ToNameBinding};\n-use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -196,19 +195,17 @@ impl<'b> Resolver<'b> {\n                         krate: crate_id,\n                         index: CRATE_DEF_INDEX,\n                     };\n-                    let parent_link = ModuleParentLink(parent, name);\n                     let def = Def::Mod(def_id);\n-                    let module = self.new_extern_crate_module(parent_link, def, item.id);\n+                    let module = self.new_extern_crate_module(parent, name, def, item.id);\n                     self.define(parent, name, TypeNS, (module, sp, vis));\n \n                     self.populate_module_if_necessary(module);\n                 }\n             }\n \n             ItemKind::Mod(..) => {\n-                let parent_link = ModuleParentLink(parent, name);\n                 let def = Def::Mod(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), Some(item.id));\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), Some(item.id));\n                 module.no_implicit_prelude.set({\n                     parent.no_implicit_prelude.get() ||\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n@@ -244,9 +241,8 @@ impl<'b> Resolver<'b> {\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n-                let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Enum(self.definitions.local_def_id(item.id));\n-                let module = self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n+                let kind = ModuleKind::Def(Def::Enum(self.definitions.local_def_id(item.id)), name);\n+                let module = self.new_module(parent, kind, parent.normal_ancestor_id);\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n \n                 for variant in &(*enum_definition).variants {\n@@ -297,10 +293,8 @@ impl<'b> Resolver<'b> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let parent_link = ModuleParentLink(parent, name);\n-                let def = Def::Trait(def_id);\n-                let module_parent =\n-                    self.new_module(parent_link, Some(def), parent.normal_ancestor_id);\n+                let kind = ModuleKind::Def(Def::Trait(def_id), name);\n+                let module_parent = self.new_module(parent, kind, parent.normal_ancestor_id);\n                 self.define(parent, name, TypeNS, (module_parent, sp, vis));\n \n                 // Add the names of all the items to the trait info.\n@@ -375,8 +369,8 @@ impl<'b> Resolver<'b> {\n                     {}\",\n                    block_id);\n \n-            let parent_link = BlockParentLink(parent, block_id);\n-            let new_module = self.new_module(parent_link, None, parent.normal_ancestor_id);\n+            let new_module =\n+                self.new_module(parent, ModuleKind::Block(block_id), parent.normal_ancestor_id);\n             self.module_map.insert(block_id, new_module);\n             self.current_module = new_module; // Descend into the block.\n         }\n@@ -407,8 +401,7 @@ impl<'b> Resolver<'b> {\n             Def::Mod(_) | Def::Enum(..) => {\n                 debug!(\"(building reduced graph for external crate) building module {} {:?}\",\n                        name, vis);\n-                let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), None);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), None);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::Variant(variant_id) => {\n@@ -451,8 +444,7 @@ impl<'b> Resolver<'b> {\n                     self.trait_item_map.insert((trait_item_name, def_id), false);\n                 }\n \n-                let parent_link = ModuleParentLink(parent, name);\n-                let module = self.new_module(parent_link, Some(def), None);\n+                let module = self.new_module(parent, ModuleKind::Def(def, name), None);\n                 let _ = self.try_define(parent, name, TypeNS, (module, DUMMY_SP, vis));\n             }\n             Def::TyAlias(..) | Def::AssociatedTy(..) => {"}, {"sha": "0a8514ffc73fbf202c093ca9c67eb3d86e8027d5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 66, "deletions": 81, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "patch": "@@ -41,7 +41,6 @@ use self::TypeParameters::*;\n use self::RibKind::*;\n use self::UseLexicalScopeFlag::*;\n use self::ModulePrefixResult::*;\n-use self::ParentLink::*;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n@@ -753,18 +752,15 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n-/// The link from a module up to its nearest parent node.\n-#[derive(Clone,Debug)]\n-enum ParentLink<'a> {\n-    NoParentLink,\n-    ModuleParentLink(Module<'a>, Name),\n-    BlockParentLink(Module<'a>, NodeId),\n+enum ModuleKind {\n+    Block(NodeId),\n+    Def(Def, Name),\n }\n \n /// One node in the tree of modules.\n pub struct ModuleS<'a> {\n-    parent_link: ParentLink<'a>,\n-    def: Option<Def>,\n+    parent: Option<Module<'a>>,\n+    kind: ModuleKind,\n \n     // The node id of the closest normal module (`mod`) ancestor (including this module).\n     normal_ancestor_id: Option<NodeId>,\n@@ -792,11 +788,11 @@ pub struct ModuleS<'a> {\n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-    fn new(parent_link: ParentLink<'a>, def: Option<Def>, normal_ancestor_id: Option<NodeId>)\n+    fn new(parent: Option<Module<'a>>, kind: ModuleKind, normal_ancestor_id: Option<NodeId>)\n            -> Self {\n         ModuleS {\n-            parent_link: parent_link,\n-            def: def,\n+            parent: parent,\n+            kind: kind,\n             normal_ancestor_id: normal_ancestor_id,\n             extern_crate_id: None,\n             resolutions: RefCell::new(FnvHashMap()),\n@@ -814,36 +810,36 @@ impl<'a> ModuleS<'a> {\n         }\n     }\n \n+    fn def(&self) -> Option<Def> {\n+        match self.kind {\n+            ModuleKind::Def(def, _) => Some(def),\n+            _ => None,\n+        }\n+    }\n+\n     fn def_id(&self) -> Option<DefId> {\n-        self.def.as_ref().map(Def::def_id)\n+        self.def().as_ref().map(Def::def_id)\n     }\n \n     // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n-        match self.def {\n-            Some(Def::Mod(_)) => true,\n+        match self.kind {\n+            ModuleKind::Def(Def::Mod(_), _) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n-        match self.def {\n-            Some(Def::Trait(_)) => true,\n+        match self.kind {\n+            ModuleKind::Def(Def::Trait(_), _) => true,\n             _ => false,\n         }\n     }\n-\n-    fn parent(&self) -> Option<&'a Self> {\n-        match self.parent_link {\n-            ModuleParentLink(parent, _) | BlockParentLink(parent, _) => Some(parent),\n-            NoParentLink => None,\n-        }\n-    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?}\", self.def)\n+        write!(f, \"{:?}\", self.def())\n     }\n }\n \n@@ -903,7 +899,7 @@ impl<'a> NameBinding<'a> {\n     fn def(&self) -> Def {\n         match self.kind {\n             NameBindingKind::Def(def) => def,\n-            NameBindingKind::Module(module) => module.def.unwrap(),\n+            NameBindingKind::Module(module) => module.def().unwrap(),\n             NameBindingKind::Import { binding, .. } => binding.def(),\n             NameBindingKind::Ambiguity { .. } => Def::Err,\n         }\n@@ -1111,7 +1107,7 @@ impl<'a> ResolverArenas<'a> {\n impl<'a> ty::NodeIdTree for Resolver<'a> {\n     fn is_descendant_of(&self, mut node: NodeId, ancestor: NodeId) -> bool {\n         while node != ancestor {\n-            node = match self.module_map[&node].parent() {\n+            node = match self.module_map[&node].parent {\n                 Some(parent) => parent.normal_ancestor_id.unwrap(),\n                 None => return false,\n             }\n@@ -1178,10 +1174,10 @@ impl<'a> Resolver<'a> {\n                macro_loader: &'a mut MacroLoader,\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n-        let root_def_id = DefId::local(CRATE_DEF_INDEX);\n+        let graph_root_kind =\n+            ModuleKind::Def(Def::Mod(DefId::local(CRATE_DEF_INDEX)), keywords::Invalid.name());\n         let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), Some(CRATE_NODE_ID));\n-        let graph_root = arenas.alloc_module(graph_root);\n+            arenas.alloc_module(ModuleS::new(None, graph_root_kind, Some(CRATE_NODE_ID)));\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n \n@@ -1263,18 +1259,15 @@ impl<'a> Resolver<'a> {\n         self.report_errors();\n     }\n \n-    fn new_module(&self,\n-                  parent_link: ParentLink<'a>,\n-                  def: Option<Def>,\n-                  normal_ancestor_id: Option<NodeId>)\n+    fn new_module(&self, parent: Module<'a>, kind: ModuleKind, normal_ancestor_id: Option<NodeId>)\n                   -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, normal_ancestor_id))\n+        self.arenas.alloc_module(ModuleS::new(Some(parent), kind, normal_ancestor_id))\n     }\n \n-    fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def, local_node_id: NodeId)\n+    fn new_extern_crate_module(&self, parent: Module<'a>, name: Name, def: Def, node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), Some(local_node_id));\n-        module.extern_crate_id = Some(local_node_id);\n+        let mut module = ModuleS::new(Some(parent), ModuleKind::Def(def, name), Some(node_id));\n+        module.extern_crate_id = Some(node_id);\n         module.populated.set(false);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1336,11 +1329,10 @@ impl<'a> Resolver<'a> {\n                                        -> Option<Module<'a>> {\n             match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n-                _ => match module.parent_link {\n-                    ModuleParentLink(ref parent, _) => {\n-                        search_parent_externals(this, needle, parent)\n-                    }\n-                    _ => None,\n+                _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n+                    search_parent_externals(this, needle, parent)\n+                } else {\n+                    None\n                 },\n             }\n         }\n@@ -1516,15 +1508,13 @@ impl<'a> Resolver<'a> {\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n \n-                // We can only see through anonymous modules\n-                if module.def.is_some() {\n-                    return match self.prelude {\n-                        Some(prelude) if !module.no_implicit_prelude.get() => {\n-                            self.resolve_name_in_module(prelude, name, ns, false, None).success()\n-                                .map(LexicalScopeBinding::Item)\n-                        }\n-                        _ => None,\n-                    };\n+                if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n+                } else if !module.no_implicit_prelude.get() {\n+                    return self.prelude.and_then(|prelude| {\n+                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                    }).map(LexicalScopeBinding::Item)\n+                } else {\n+                    return None;\n                 }\n             }\n \n@@ -1561,7 +1551,7 @@ impl<'a> Resolver<'a> {\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n-            if let Some(parent) = containing_module.parent() {\n+            if let Some(parent) = containing_module.parent {\n                 containing_module = self.module_map[&parent.normal_ancestor_id.unwrap()];\n                 i += 1;\n             } else {\n@@ -2954,7 +2944,7 @@ impl<'a> Resolver<'a> {\n                                                                    UseLexicalScope,\n                                                                    Some(expr.span)) {\n                                         Success(e) => {\n-                                            if let Some(def_type) = e.def {\n+                                            if let Some(def_type) = e.def() {\n                                                 def = def_type;\n                                             }\n                                             context = UnresolvedNameContext::PathIsMod(parent);\n@@ -3163,16 +3153,13 @@ impl<'a> Resolver<'a> {\n             };\n             search_in_module(self, search_module);\n \n-            match search_module.parent_link {\n-                NoParentLink | ModuleParentLink(..) => {\n-                    if !search_module.no_implicit_prelude.get() {\n-                        self.prelude.map(|prelude| search_in_module(self, prelude));\n-                    }\n-                    break;\n-                }\n-                BlockParentLink(parent_module, _) => {\n-                    search_module = parent_module;\n+            if let ModuleKind::Block(..) = search_module.kind {\n+                search_module = search_module.parent.unwrap();\n+            } else {\n+                if !search_module.no_implicit_prelude.get() {\n+                    self.prelude.map(|prelude| search_in_module(self, prelude));\n                 }\n+                break;\n             }\n         }\n \n@@ -3240,9 +3227,9 @@ impl<'a> Resolver<'a> {\n                 // collect submodules to explore\n                 if let Ok(module) = name_binding.module() {\n                     // form the path\n-                    let path_segments = match module.parent_link {\n-                        NoParentLink => path_segments.clone(),\n-                        ModuleParentLink(_, name) => {\n+                    let path_segments = match module.kind {\n+                        _ if module.parent.is_none() => path_segments.clone(),\n+                        ModuleKind::Def(_, name) => {\n                             let mut paths = path_segments.clone();\n                             let ident = ast::Ident::with_empty_ctxt(name);\n                             let params = PathParameters::none();\n@@ -3259,7 +3246,7 @@ impl<'a> Resolver<'a> {\n                     if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                         // add the module to the lookup\n                         let is_extern = in_module_is_extern || name_binding.is_extern_crate();\n-                        if !worklist.iter().any(|&(m, ..)| m.def == module.def) {\n+                        if !worklist.iter().any(|&(m, ..)| m.def() == module.def()) {\n                             worklist.push((module, path_segments, is_extern));\n                         }\n                     }\n@@ -3294,7 +3281,7 @@ impl<'a> Resolver<'a> {\n         let mut path_resolution = err_path_resolution();\n         let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n-                path_resolution = PathResolution::new(module.def.unwrap());\n+                path_resolution = PathResolution::new(module.def().unwrap());\n                 ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n             }\n             Indeterminate => unreachable!(),\n@@ -3360,10 +3347,10 @@ impl<'a> Resolver<'a> {\n             return self.report_conflict(parent, name, ns, old_binding, binding);\n         }\n \n-        let container = match parent.def {\n-            Some(Def::Mod(_)) => \"module\",\n-            Some(Def::Trait(_)) => \"trait\",\n-            None => \"block\",\n+        let container = match parent.kind {\n+            ModuleKind::Def(Def::Mod(_), _) => \"module\",\n+            ModuleKind::Def(Def::Trait(_), _) => \"trait\",\n+            ModuleKind::Block(..) => \"block\",\n             _ => \"enum\",\n         };\n \n@@ -3510,17 +3497,15 @@ fn module_to_string(module: Module) -> String {\n     let mut names = Vec::new();\n \n     fn collect_mod(names: &mut Vec<ast::Name>, module: Module) {\n-        match module.parent_link {\n-            NoParentLink => {}\n-            ModuleParentLink(ref module, name) => {\n+        if let ModuleKind::Def(_, name) = module.kind {\n+            if let Some(parent) = module.parent {\n                 names.push(name);\n-                collect_mod(names, module);\n-            }\n-            BlockParentLink(ref module, _) => {\n-                // danger, shouldn't be ident?\n-                names.push(token::intern(\"<opaque>\"));\n-                collect_mod(names, module);\n+                collect_mod(names, parent);\n             }\n+        } else {\n+            // danger, shouldn't be ident?\n+            names.push(token::intern(\"<opaque>\"));\n+            collect_mod(names, module);\n         }\n     }\n     collect_mod(&mut names, module);"}, {"sha": "ba45b773c09f36915174a4c5078e5da9bcbf0ef7", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a0e88a339ca76159abaf7523ee5aaa8b19052b1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=9a0e88a339ca76159abaf7523ee5aaa8b19052b1", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let module = directive.imported_module.get().unwrap();\n         self.populate_module_if_necessary(module);\n \n-        if let Some(Def::Trait(_)) = module.def {\n+        if let Some(Def::Trait(_)) = module.def() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n         } else if module.def_id() == directive.parent.def_id()  {"}]}