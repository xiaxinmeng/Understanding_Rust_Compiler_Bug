{"sha": "4d92cb5c63469003903a87574e30308f512314cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkOTJjYjVjNjM0NjkwMDM5MDNhODc1NzRlMzAzMDhmNTEyMzE0Y2M=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-25T19:31:16Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-25T19:33:09Z"}, "message": "Removing mention of domain, updating the communication examples.", "tree": {"sha": "7932c193deed86f88860ffd2b989461a82496115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7932c193deed86f88860ffd2b989461a82496115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d92cb5c63469003903a87574e30308f512314cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d92cb5c63469003903a87574e30308f512314cc", "html_url": "https://github.com/rust-lang/rust/commit/4d92cb5c63469003903a87574e30308f512314cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d92cb5c63469003903a87574e30308f512314cc/comments", "author": null, "committer": null, "parents": [{"sha": "880fd788eb04717d7a75bd5bbf0b8f0a692bda53", "url": "https://api.github.com/repos/rust-lang/rust/commits/880fd788eb04717d7a75bd5bbf0b8f0a692bda53", "html_url": "https://github.com/rust-lang/rust/commit/880fd788eb04717d7a75bd5bbf0b8f0a692bda53"}], "stats": {"total": 85, "additions": 23, "deletions": 62}, "files": [{"sha": "c904e094149713184f989991298626e8142bade4", "filename": "doc/rust.texi", "status": "modified", "additions": 23, "deletions": 62, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4d92cb5c63469003903a87574e30308f512314cc/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/4d92cb5c63469003903a87574e30308f512314cc/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=4d92cb5c63469003903a87574e30308f512314cc", "patch": "@@ -1227,15 +1227,6 @@ immediately destructed (if acyclic) or else collected using a general\n (cycle-aware) garbage-collector local to each task. Garbage collection within\n a local heap does not interrupt execution of other tasks.\n \n-Immutable boxes are @dfn{shared}, and can be multiply-referenced by many\n-different tasks. Like any other immutable type, they can pass over channels,\n-and live as long as the last task referencing them within a given domain. When\n-unreferenced, they are destroyed immediately (due to reference-counting) and\n-returned to the heap memory allocator. Destruction of an immutable box also\n-executes within the context of the task that drops the last reference to a\n-shared heap allocation, so executing a long-running destructor does not\n-interrupt execution of other tasks.\n-\n \n @node       Ref.Mem.Own\n @subsection Ref.Mem.Own\n@@ -1371,25 +1362,23 @@ fn main() @{\n @node       Ref.Mem.Acct\n @subsection Ref.Mem.Acct\n @c * Ref.Mem.Acct::                Memory accounting model.\n-@cindex Domain\n @cindex Accounting\n @cindex Memory budget\n \n-Every task belongs to a domain, and that domain tracks the amount of memory\n-allocated and not yet released by tasks within it. @xref{Ref.Task.Dom}. Each\n-domain has a memory budget. The @dfn{budget} of a domain is the maximum amount\n-of memory that can be simultaneously allocated in the domain. If a task tries\n-to allocate memory within a domain with an exceeded budget, the task will\n-receive a signal.\n+Every task tracks the amount of memory allocated and not yet released. Each\n+task may have a memory budget. The @dfn{budget} of a task is the maximum\n+amount of memory that can be simultaneously allocated in the task. If a task\n+tries to allocate memory with an exceeded budget, the task will receive a\n+signal.\n \n Within a task, accounting is strictly enforced: all memory allocated through\n-the runtime library, both user data, sub-domains and runtime-support\n-structures such as channel and signal queues, are charged to a task's domain.\n+the runtime library, both user data and runtime-support structures such as\n+channel and signal queues, are charged to a task.\n \n-When a communication channel crosses from one domain to another, any value\n+When a communication channel crosses from one task to another, any value\n sent over the channel is guaranteed to have been @emph{detached} from the\n-domain's memory graph (singly referenced, and/or deep-copied), so its memory\n-cost is transferred to the receiving domain.\n+task's memory graph (singly referenced, and/or deep-copied), so its memory\n+cost is transferred to the receiving task.\n \n \n @page\n@@ -1414,7 +1403,6 @@ operating-system processes.\n @menu\n * Ref.Task.Comm::               Inter-task communication.\n * Ref.Task.Life::               Task lifecycle and state transitions.\n-* Ref.Task.Dom::                Task domains.\n * Ref.Task.Sched::              Task scheduling model.\n * Ref.Task.Spawn::              Library interface for making new tasks.\n * Ref.Task.Send::               Library interface for sending messages.\n@@ -1467,12 +1455,12 @@ transmit side. A channel contains a message queue and asynchronously sending a\n message merely inserts it into the sending channel's queue; message receipt is\n the responsibility of the receiving task.\n \n-Queued messages in channels are charged to the domain of the @emph{sending}\n-task. If too many messages are queued for transmission from a single sending\n-task, without being received by a receiving task, the sending task may exceed\n-its memory budget, which causes a run-time signal. To help control this\n-possibility, a semi-synchronous send operation is possible, which blocks until\n-there is room in the existing queue before sending send.\n+Queued messages in channels are charged to the @emph{sending} task. If too\n+many messages are queued for transmission from a single sending task, without\n+being received by a receiving task, the sending task may exceed its memory\n+budget, which causes a run-time signal. To help control this possibility, a\n+semi-synchronous send operation is possible, which blocks until there is room\n+in the existing queue before sending send.\n \n Messages are sent on channels and received on ports using standard library\n functions.\n@@ -1535,31 +1523,6 @@ A task in the @emph{dead} state cannot transition to other states; it exists\n only to have its termination status inspected by other tasks, and/or to await\n reclamation when the last reference to it drops.\n \n-@node       Ref.Task.Dom\n-@subsection Ref.Task.Dom\n-@c * Ref.Task.Dom::                Task domains\n-\n-@cindex Domain\n-@cindex Process\n-@cindex Thread\n-\n-Every task belongs to a domain. A @dfn{domain} is a structure that owns tasks,\n-schedules tasks, tracks memory allocation within tasks and manages access to\n-runtime services on behalf of tasks.\n-\n-Typically each domain runs on a separate operating-system @emph{thread}, or\n-within an isolated operating-system @emph{process}. An easy way to think of a\n-domain is as an abstraction over either an operating-system thread @emph{or} a\n-process.\n-\n-The key feature of a domain is that it isolates memory references created by\n-the Rust tasks within it. No Rust task can refer directly to memory outside\n-its domain.\n-\n-Tasks can own sub-domains, which in turn own their own tasks. Every domain\n-owns one @emph{root task}, which is the root of the tree of tasks owned by the\n-domain.\n-\n @node       Ref.Task.Sched\n @subsection Ref.Task.Sched\n @c * Ref.Task.Sched::              Task scheduling model.\n@@ -1568,11 +1531,9 @@ domain.\n @cindex Preemption\n @cindex Yielding control\n \n-Every task is @emph{scheduled} within its domain. @xref{Ref.Task.Dom}. The\n-currently scheduled task is given a finite @emph{time slice} in which to\n+The currently scheduled task is given a finite @emph{time slice} in which to\n execute, after which it is @emph{descheduled} at a loop-edge or similar\n-preemption point, and another task within the domain is scheduled,\n-pseudo-randomly.\n+preemption point, and another task within is scheduled, pseudo-randomly.\n \n An executing task can @code{yield} control at any time, which deschedules it\n immediately. Entering any other non-executing state (blocked, dead) similarly\n@@ -1591,7 +1552,7 @@ function. The passed function is referred to as the @dfn{entry function} for\n the spawned task, and any captured environment is carries is moved from the\n spawning task to the spawned task before the spawned task begins execution.\n \n-The result of a @code{spawn} call is a @code{std::task::task_id} value.\n+The result of a @code{spawn} call is a @code{std::task::task} value.\n \n An example of a @code{spawn} call:\n @example\n@@ -1606,10 +1567,10 @@ fn helper(c: chan<u8>) @{\n \n let p: port<u8>;\n \n-spawn(bind helper(p.mk_chan()));\n+spawn(bind helper(chan(p)));\n // let task run, do other things.\n // ...\n-let result = p.recv();\n+let result = recv(p);\n \n @end example\n \n@@ -1649,7 +1610,7 @@ An example of a @emph{receive}:\n @example\n import std::comm::*;\n let p: port<str> = @dots{};\n-let s: str = p.recv();\n+let s: str = recv(p);\n @end example\n \n \n@@ -3699,7 +3660,7 @@ signal queue associated with each task. Sending a signal to a task inserts the\n signal into the task's signal queue and marks the task as having a pending\n signal. At the next scheduling opportunity, the runtime processes signals in\n the task's queue using its dispatch table. The signal queue memory is charged\n-to the task's domain; if the queue grows too big, the task will fail.\n+to the task; if the queue grows too big, the task will fail.\n \n @c ############################################################\n @c end main body of nodes"}]}