{"sha": "fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmZmVhYTdiODNkZjA3NjAwMDkyYWM1YjJhM2Q4NGU1ZGM3NjYzN2I=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-10-05T00:29:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-05T00:29:33Z"}, "message": "Rollup merge of #77407 - pietroalbini:less-build-manifest, r=Mark-Simulacrum\n\nImprove build-manifest to work with the improved promote-release\n\nThis PR makes some changes to build-manifest to have it work better with the other improvements I'm making to [promote-release](https://github.com/rust-lang/promote-release).\n\nA new way to invoke the tool was added: `./x.py run src/tools/build-manifest`. The new invocation disables the generation of `.sha256` files and the generation of GPG signatures, as those steps are not tied to the Rust version we're building the manifest of: handling them in `promote-release` will improve the maintenability of our release process. Invocations through the old command (`./x.py dist hash-and-sign`) are referred inside the source code as \"legacy\". The new invocation also enables internal parallelism, disabled on legacy to avoid overloading our old server.\n\nImprovements were also made on how the checksums included in the manifest are generated:\n\n* The manifest is first generated with placeholder checksums, and then a function walks through the manifes and calculates only the needed hashes. Before this PR, all the hashes were calculated beforehand, including the hashes of unused files.\n* Calculating the hashes is now done in parallel with rayon, to better utilize all the available disk bandwidth.\n* The `sha2` crate is now used instead of the `sha256sum` CLI tool: this avoids the overhead of calling another process, but more importantly enables hardware acceleration whenever available (the `sha256sum` CLI tool doesn't support it at all).\n\nr? @Mark-Simulacrum\nThis PR is best reviewed commit-by-commit.", "tree": {"sha": "665b5a6c50c1f263987e1f7a7a6bde6aea063c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/665b5a6c50c1f263987e1f7a7a6bde6aea063c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfemjtCRBK7hj4Ov3rIwAAdHIIADgOCVxwA9NzS9WZtxNlzfFQ\nsDKHMLdOcRpsCw7VLfG084IukhPjh/1+PPIIeFXq1R0iA5VYynfDX9Obo3qCn54n\nAoVTUMx0X93lbC7abiyqmW8Tkx3A4Wl1X2ABWaQs5O+JeYVbmAaS192g5dUzUZkd\n4KkBOakMtKthVKucfdTJUIgYJzmRSLDoDA4iucF6ryjmCjQ46ml+jr639BnfzERY\nFP2A6nbHW/p9zjw+GxbqWe1MUfM35z6zKnI6Jov2J6y+nD02IVe53RDQu0EG7uYu\n07G2rqxhTzQGyHRIxEurNfEskLX7cH83JNOVmG42Rwhn5SaOYAEsYQVlKdpJW04=\n=ucP8\n-----END PGP SIGNATURE-----\n", "payload": "tree 665b5a6c50c1f263987e1f7a7a6bde6aea063c20\nparent fe087ece94021ef8bed00f0c32138c0aa52bfc64\nparent 9352062bc3aa3c1b3cc635069a806915fcba5b1e\nauthor Dylan DPC <dylan.dpc@gmail.com> 1601857773 +0200\ncommitter GitHub <noreply@github.com> 1601857773 +0200\n\nRollup merge of #77407 - pietroalbini:less-build-manifest, r=Mark-Simulacrum\n\nImprove build-manifest to work with the improved promote-release\n\nThis PR makes some changes to build-manifest to have it work better with the other improvements I'm making to [promote-release](https://github.com/rust-lang/promote-release).\n\nA new way to invoke the tool was added: `./x.py run src/tools/build-manifest`. The new invocation disables the generation of `.sha256` files and the generation of GPG signatures, as those steps are not tied to the Rust version we're building the manifest of: handling them in `promote-release` will improve the maintenability of our release process. Invocations through the old command (`./x.py dist hash-and-sign`) are referred inside the source code as \"legacy\". The new invocation also enables internal parallelism, disabled on legacy to avoid overloading our old server.\n\nImprovements were also made on how the checksums included in the manifest are generated:\n\n* The manifest is first generated with placeholder checksums, and then a function walks through the manifes and calculates only the needed hashes. Before this PR, all the hashes were calculated beforehand, including the hashes of unused files.\n* Calculating the hashes is now done in parallel with rayon, to better utilize all the available disk bandwidth.\n* The `sha2` crate is now used instead of the `sha256sum` CLI tool: this avoids the overhead of calling another process, but more importantly enables hardware acceleration whenever available (the `sha256sum` CLI tool doesn't support it at all).\n\nr? @Mark-Simulacrum\nThis PR is best reviewed commit-by-commit.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "html_url": "https://github.com/rust-lang/rust/commit/fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe087ece94021ef8bed00f0c32138c0aa52bfc64", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe087ece94021ef8bed00f0c32138c0aa52bfc64", "html_url": "https://github.com/rust-lang/rust/commit/fe087ece94021ef8bed00f0c32138c0aa52bfc64"}, {"sha": "9352062bc3aa3c1b3cc635069a806915fcba5b1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9352062bc3aa3c1b3cc635069a806915fcba5b1e", "html_url": "https://github.com/rust-lang/rust/commit/9352062bc3aa3c1b3cc635069a806915fcba5b1e"}], "stats": {"total": 464, "additions": 334, "deletions": 130}, "files": [{"sha": "fd27f053638329422284cf9f590d0123df5087f8", "filename": "Cargo.lock", "status": "modified", "additions": 64, "deletions": 8, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -183,7 +183,16 @@ dependencies = [\n  \"block-padding\",\n  \"byte-tools\",\n  \"byteorder\",\n- \"generic-array\",\n+ \"generic-array 0.12.3\",\n+]\n+\n+[[package]]\n+name = \"block-buffer\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4152116fd6e9dadb291ae18fc1ec3575ed6d84c29642d97890f4b4a3417297e4\"\n+dependencies = [\n+ \"generic-array 0.14.4\",\n ]\n \n [[package]]\n@@ -233,8 +242,11 @@ version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n  \"flate2\",\n+ \"hex 0.4.2\",\n+ \"rayon\",\n  \"serde\",\n  \"serde_json\",\n+ \"sha2\",\n  \"tar\",\n  \"toml\",\n ]\n@@ -687,6 +699,12 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a21fa21941700a3cd8fcb4091f361a6a712fac632f85d9f487cc892045d55c6\"\n \n+[[package]]\n+name = \"cpuid-bool\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8aebca1129a03dc6dc2b127edd729435bbc4a37e1d5f4d7513165089ceb02634\"\n+\n [[package]]\n name = \"crates-io\"\n version = \"0.31.1\"\n@@ -884,7 +902,16 @@ version = \"0.8.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f3d0c8c8752312f9713efd397ff63acb9f85585afbf179282e720e7704954dd5\"\n dependencies = [\n- \"generic-array\",\n+ \"generic-array 0.12.3\",\n+]\n+\n+[[package]]\n+name = \"digest\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d3dd60d1080a57a05ab032377049e0591415d2b31afd7028356dbf3cc6dcb066\"\n+dependencies = [\n+ \"generic-array 0.14.4\",\n ]\n \n [[package]]\n@@ -1166,6 +1193,16 @@ dependencies = [\n  \"typenum\",\n ]\n \n+[[package]]\n+name = \"generic-array\"\n+version = \"0.14.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"501466ecc8a30d1d3b7fc9229b122b2ce8ed6e9d9223f1138d4babb253e51817\"\n+dependencies = [\n+ \"typenum\",\n+ \"version_check\",\n+]\n+\n [[package]]\n name = \"getopts\"\n version = \"0.2.21\"\n@@ -1835,9 +1872,9 @@ version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"a18af3dcaf2b0219366cdb4e2af65a6101457b415c3d1a5c71dd9c2b7c77b9c8\"\n dependencies = [\n- \"block-buffer\",\n- \"digest\",\n- \"opaque-debug\",\n+ \"block-buffer 0.7.3\",\n+ \"digest 0.8.1\",\n+ \"opaque-debug 0.2.3\",\n ]\n \n [[package]]\n@@ -2097,6 +2134,12 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2839e79665f131bdb5782e51f2c6c9599c133c6098982a54c794358bf432529c\"\n \n+[[package]]\n+name = \"opaque-debug\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"624a8340c38c1b80fd549087862da4ba43e08858af025b236e509b6649fc13d5\"\n+\n [[package]]\n name = \"open\"\n version = \"1.4.0\"\n@@ -4362,10 +4405,23 @@ version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f7d94d0bede923b3cea61f3f1ff57ff8cdfd77b400fb8f9998949e0cf04163df\"\n dependencies = [\n- \"block-buffer\",\n- \"digest\",\n+ \"block-buffer 0.7.3\",\n+ \"digest 0.8.1\",\n  \"fake-simd\",\n- \"opaque-debug\",\n+ \"opaque-debug 0.2.3\",\n+]\n+\n+[[package]]\n+name = \"sha2\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2933378ddfeda7ea26f48c555bdad8bb446bf8a3d17832dc83e380d444cfb8c1\"\n+dependencies = [\n+ \"block-buffer 0.9.0\",\n+ \"cfg-if\",\n+ \"cpuid-bool\",\n+ \"digest 0.9.0\",\n+ \"opaque-debug 0.3.0\",\n ]\n \n [[package]]"}, {"sha": "c87476d8f58b85c5b5964cf9e428e77397637fa0", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -477,7 +477,7 @@ impl<'a> Builder<'a> {\n                 install::Src,\n                 install::Rustc\n             ),\n-            Kind::Run => describe!(run::ExpandYamlAnchors,),\n+            Kind::Run => describe!(run::ExpandYamlAnchors, run::BuildManifest,),\n         }\n     }\n "}, {"sha": "857e06d846de4b52ce5be2a9d17e00f5b38c2934", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -46,7 +46,7 @@ pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n     }\n }\n \n-fn distdir(builder: &Builder<'_>) -> PathBuf {\n+pub(crate) fn distdir(builder: &Builder<'_>) -> PathBuf {\n     builder.out.join(\"dist\")\n }\n \n@@ -2371,6 +2371,7 @@ impl Step for HashSign {\n         cmd.arg(addr);\n         cmd.arg(&builder.config.channel);\n         cmd.arg(&builder.src);\n+        cmd.env(\"BUILD_MANIFEST_LEGACY\", \"1\");\n \n         builder.create_dir(&distdir(builder));\n "}, {"sha": "80c093e713eff8619d427c5ec2872b5a6b0c9e27", "filename": "src/bootstrap/run.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Fbootstrap%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Fbootstrap%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frun.rs?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -1,5 +1,7 @@\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n+use crate::dist::distdir;\n use crate::tool::Tool;\n+use build_helper::output;\n use std::process::Command;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -41,3 +43,43 @@ fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     }\n     true\n }\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct BuildManifest;\n+\n+impl Step for BuildManifest {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/build-manifest\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(BuildManifest);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        // This gets called by `promote-release`\n+        // (https://github.com/rust-lang/promote-release).\n+        let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n+        let sign = builder.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+            panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n+        });\n+        let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+            panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n+        });\n+\n+        let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n+\n+        cmd.arg(sign);\n+        cmd.arg(distdir(builder));\n+        cmd.arg(today.trim());\n+        cmd.arg(addr);\n+        cmd.arg(&builder.config.channel);\n+        cmd.arg(&builder.src);\n+\n+        builder.create_dir(&distdir(builder));\n+        builder.run(&mut cmd);\n+    }\n+}"}, {"sha": "4ae4dbfc06edead6bd990ceef7a23301b2c06006", "filename": "src/tools/build-manifest/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -11,3 +11,6 @@ serde_json = \"1.0\"\n anyhow = \"1.0.32\"\n flate2 = \"1.0.16\"\n tar = \"0.4.29\"\n+sha2 = \"0.9.1\"\n+rayon = \"1.3.1\"\n+hex = \"0.4.2\""}, {"sha": "26e96c9fd8fdaf56d035dc6c3816af25b569b858", "filename": "src/tools/build-manifest/README.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FREADME.md?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -20,8 +20,7 @@ Then, you can generate the manifest and all the packages from `path/to/dist` to\n `path/to/output` with:\n \n ```\n-$ BUILD_MANIFEST_DISABLE_SIGNING=1 cargo +nightly run \\\n-    path/to/dist path/to/output 1970-01-01 http://example.com \\\n+$ cargo +nightly run path/to/dist path/to/output 1970-01-01 http://example.com \\\n     CHANNEL path/to/rust/repo\n ```\n "}, {"sha": "c7e7d88c68fa8e85cf4303d97a30d5a56c1aed15", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 107, "deletions": 118, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -4,17 +4,22 @@\n //! via `x.py dist hash-and-sign`; the cmdline arguments are set up\n //! by rustbuild (in `src/bootstrap/dist.rs`).\n \n+mod manifest;\n mod versions;\n \n+use crate::manifest::{Component, FileHash, Manifest, Package, Rename, Target};\n use crate::versions::{PkgType, Versions};\n-use serde::Serialize;\n-use std::collections::BTreeMap;\n-use std::collections::HashMap;\n+use rayon::prelude::*;\n+use sha2::Digest;\n+use std::collections::{BTreeMap, HashMap, HashSet};\n use std::env;\n+use std::error::Error;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{self, BufReader, Read, Write};\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n+use std::sync::Mutex;\n+use std::time::Instant;\n \n static HOSTS: &[&str] = &[\n     \"aarch64-unknown-linux-gnu\",\n@@ -167,57 +172,6 @@ static MINGW: &[&str] = &[\"i686-pc-windows-gnu\", \"x86_64-pc-windows-gnu\"];\n \n static NIGHTLY_ONLY_COMPONENTS: &[&str] = &[\"miri-preview\", \"rust-analyzer-preview\"];\n \n-#[derive(Serialize)]\n-#[serde(rename_all = \"kebab-case\")]\n-struct Manifest {\n-    manifest_version: String,\n-    date: String,\n-    pkg: BTreeMap<String, Package>,\n-    renames: BTreeMap<String, Rename>,\n-    profiles: BTreeMap<String, Vec<String>>,\n-}\n-\n-#[derive(Serialize)]\n-struct Package {\n-    version: String,\n-    git_commit_hash: Option<String>,\n-    target: BTreeMap<String, Target>,\n-}\n-\n-#[derive(Serialize)]\n-struct Rename {\n-    to: String,\n-}\n-\n-#[derive(Serialize, Default)]\n-struct Target {\n-    available: bool,\n-    url: Option<String>,\n-    hash: Option<String>,\n-    xz_url: Option<String>,\n-    xz_hash: Option<String>,\n-    components: Option<Vec<Component>>,\n-    extensions: Option<Vec<Component>>,\n-}\n-\n-impl Target {\n-    fn unavailable() -> Self {\n-        Self::default()\n-    }\n-}\n-\n-#[derive(Serialize)]\n-struct Component {\n-    pkg: String,\n-    target: String,\n-}\n-\n-impl Component {\n-    fn from_str(pkg: &str, target: &str) -> Self {\n-        Self { pkg: pkg.to_string(), target: target.to_string() }\n-    }\n-}\n-\n macro_rules! t {\n     ($e:expr) => {\n         match $e {\n@@ -232,25 +186,33 @@ struct Builder {\n \n     input: PathBuf,\n     output: PathBuf,\n-    gpg_passphrase: String,\n-    digests: BTreeMap<String, String>,\n     s3_address: String,\n     date: String,\n \n-    should_sign: bool,\n+    legacy: bool,\n+    legacy_gpg_passphrase: String,\n }\n \n fn main() {\n-    // Avoid signing packages while manually testing\n-    // Do NOT set this envvar in CI\n-    let should_sign = env::var(\"BUILD_MANIFEST_DISABLE_SIGNING\").is_err();\n-\n-    // Safety check to ensure signing is always enabled on CI\n-    // The CI environment variable is set by both Travis and AppVeyor\n-    if !should_sign && env::var(\"CI\").is_ok() {\n-        println!(\"The 'BUILD_MANIFEST_DISABLE_SIGNING' env var can't be enabled on CI.\");\n-        println!(\"If you're not running this on CI, unset the 'CI' env var.\");\n-        panic!();\n+    // Up until Rust 1.48 the release process relied on build-manifest to create the SHA256\n+    // checksums of released files and to sign the tarballs. That was moved over to promote-release\n+    // in time for the branching of Rust 1.48, but the old release process still had to work the\n+    // old way.\n+    //\n+    // When running build-manifest through the old ./x.py dist hash-and-sign the environment\n+    // variable will be set, enabling the legacy behavior of generating the .sha256 files and\n+    // signing the tarballs.\n+    //\n+    // Once the old release process is fully decommissioned, the environment variable, all the\n+    // related code in this tool and ./x.py dist hash-and-sign can be removed.\n+    let legacy = env::var(\"BUILD_MANIFEST_LEGACY\").is_ok();\n+\n+    // Avoid overloading the old server in legacy mode.\n+    if legacy {\n+        rayon::ThreadPoolBuilder::new()\n+            .num_threads(1)\n+            .build_global()\n+            .expect(\"failed to initialize Rayon\");\n     }\n \n     let mut args = env::args().skip(1);\n@@ -263,7 +225,7 @@ fn main() {\n \n     // Do not ask for a passphrase while manually testing\n     let mut passphrase = String::new();\n-    if should_sign {\n+    if legacy {\n         // `x.py` passes the passphrase via stdin.\n         t!(io::stdin().read_to_string(&mut passphrase));\n     }\n@@ -273,20 +235,21 @@ fn main() {\n \n         input,\n         output,\n-        gpg_passphrase: passphrase,\n-        digests: BTreeMap::new(),\n         s3_address,\n         date,\n \n-        should_sign,\n+        legacy,\n+        legacy_gpg_passphrase: passphrase,\n     }\n     .build();\n }\n \n impl Builder {\n     fn build(&mut self) {\n         self.check_toolstate();\n-        self.digest_and_sign();\n+        if self.legacy {\n+            self.digest_and_sign();\n+        }\n         let manifest = self.build_manifest();\n \n         let rust_version = self.versions.package_version(&PkgType::Rust).unwrap();\n@@ -324,10 +287,9 @@ impl Builder {\n     /// Hash all files, compute their signatures, and collect the hashes in `self.digests`.\n     fn digest_and_sign(&mut self) {\n         for file in t!(self.input.read_dir()).map(|e| t!(e).path()) {\n-            let filename = file.file_name().unwrap().to_str().unwrap();\n-            let digest = self.hash(&file);\n+            file.file_name().unwrap().to_str().unwrap();\n+            self.hash(&file);\n             self.sign(&file);\n-            assert!(self.digests.insert(filename.to_string(), digest).is_none());\n         }\n     }\n \n@@ -343,6 +305,9 @@ impl Builder {\n         self.add_profiles_to(&mut manifest);\n         self.add_renames_to(&mut manifest);\n         manifest.pkg.insert(\"rust\".to_string(), self.rust_package(&manifest));\n+\n+        self.fill_missing_hashes(&mut manifest);\n+\n         manifest\n     }\n \n@@ -438,9 +403,12 @@ impl Builder {\n \n     fn target_host_combination(&mut self, host: &str, manifest: &Manifest) -> Option<Target> {\n         let filename = self.versions.tarball_name(&PkgType::Rust, host).unwrap();\n-        let digest = self.digests.remove(&filename)?;\n-        let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n-        let xz_digest = self.digests.remove(&xz_filename);\n+\n+        let mut target = Target::from_compressed_tar(self, &filename);\n+        if !target.available {\n+            return None;\n+        }\n+\n         let mut components = Vec::new();\n         let mut extensions = Vec::new();\n \n@@ -496,15 +464,9 @@ impl Builder {\n         extensions.retain(&has_component);\n         components.retain(&has_component);\n \n-        Some(Target {\n-            available: true,\n-            url: Some(self.url(&filename)),\n-            hash: Some(digest),\n-            xz_url: xz_digest.as_ref().map(|_| self.url(&xz_filename)),\n-            xz_hash: xz_digest,\n-            components: Some(components),\n-            extensions: Some(extensions),\n-        })\n+        target.components = Some(components);\n+        target.extensions = Some(extensions);\n+        Some(target)\n     }\n \n     fn profile(\n@@ -542,37 +504,19 @@ impl Builder {\n         let targets = targets\n             .iter()\n             .map(|name| {\n-                if is_present {\n-                    // The component generally exists, but it might still be missing for this target.\n+                let target = if is_present {\n                     let filename = self\n                         .versions\n                         .tarball_name(&PkgType::from_component(pkgname), name)\n                         .unwrap();\n-                    let digest = match self.digests.remove(&filename) {\n-                        Some(digest) => digest,\n-                        // This component does not exist for this target -- skip it.\n-                        None => return (name.to_string(), Target::unavailable()),\n-                    };\n-                    let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n-                    let xz_digest = self.digests.remove(&xz_filename);\n-\n-                    (\n-                        name.to_string(),\n-                        Target {\n-                            available: true,\n-                            url: Some(self.url(&filename)),\n-                            hash: Some(digest),\n-                            xz_url: xz_digest.as_ref().map(|_| self.url(&xz_filename)),\n-                            xz_hash: xz_digest,\n-                            components: None,\n-                            extensions: None,\n-                        },\n-                    )\n+\n+                    Target::from_compressed_tar(self, &filename)\n                 } else {\n                     // If the component is not present for this build add it anyway but mark it as\n                     // unavailable -- this way rustup won't allow upgrades without --force\n-                    (name.to_string(), Target::unavailable())\n-                }\n+                    Target::unavailable()\n+                };\n+                (name.to_string(), target)\n             })\n             .collect();\n \n@@ -586,8 +530,9 @@ impl Builder {\n         );\n     }\n \n-    fn url(&self, filename: &str) -> String {\n-        format!(\"{}/{}/{}\", self.s3_address, self.date, filename)\n+    fn url(&self, path: &Path) -> String {\n+        let file_name = path.file_name().unwrap().to_str().unwrap();\n+        format!(\"{}/{}/{}\", self.s3_address, self.date, file_name)\n     }\n \n     fn hash(&self, path: &Path) -> String {\n@@ -608,7 +553,7 @@ impl Builder {\n     }\n \n     fn sign(&self, path: &Path) {\n-        if !self.should_sign {\n+        if !self.legacy {\n             return;\n         }\n \n@@ -631,10 +576,45 @@ impl Builder {\n             .arg(path)\n             .stdin(Stdio::piped());\n         let mut child = t!(cmd.spawn());\n-        t!(child.stdin.take().unwrap().write_all(self.gpg_passphrase.as_bytes()));\n+        t!(child.stdin.take().unwrap().write_all(self.legacy_gpg_passphrase.as_bytes()));\n         assert!(t!(child.wait()).success());\n     }\n \n+    fn fill_missing_hashes(&self, manifest: &mut Manifest) {\n+        // First collect all files that need hashes\n+        let mut need_hashes = HashSet::new();\n+        crate::manifest::visit_file_hashes(manifest, |file_hash| {\n+            if let FileHash::Missing(path) = file_hash {\n+                need_hashes.insert(path.clone());\n+            }\n+        });\n+\n+        let collected = Mutex::new(HashMap::new());\n+        let collection_start = Instant::now();\n+        println!(\n+            \"collecting hashes for {} tarballs across {} threads\",\n+            need_hashes.len(),\n+            rayon::current_num_threads().min(need_hashes.len()),\n+        );\n+        need_hashes.par_iter().for_each(|path| match fetch_hash(path) {\n+            Ok(hash) => {\n+                collected.lock().unwrap().insert(path, hash);\n+            }\n+            Err(err) => eprintln!(\"error while fetching the hash for {}: {}\", path.display(), err),\n+        });\n+        let collected = collected.into_inner().unwrap();\n+        println!(\"collected {} hashes in {:.2?}\", collected.len(), collection_start.elapsed());\n+\n+        crate::manifest::visit_file_hashes(manifest, |file_hash| {\n+            if let FileHash::Missing(path) = file_hash {\n+                match collected.get(path) {\n+                    Some(hash) => *file_hash = FileHash::Present(hash.clone()),\n+                    None => panic!(\"missing hash for file {}\", path.display()),\n+                }\n+            }\n+        })\n+    }\n+\n     fn write_channel_files(&self, channel_name: &str, manifest: &Manifest) {\n         self.write(&toml::to_string(&manifest).unwrap(), channel_name, \".toml\");\n         self.write(&manifest.date, channel_name, \"-date.txt\");\n@@ -648,7 +628,16 @@ impl Builder {\n     fn write(&self, contents: &str, channel_name: &str, suffix: &str) {\n         let dst = self.output.join(format!(\"channel-rust-{}{}\", channel_name, suffix));\n         t!(fs::write(&dst, contents));\n-        self.hash(&dst);\n-        self.sign(&dst);\n+        if self.legacy {\n+            self.hash(&dst);\n+            self.sign(&dst);\n+        }\n     }\n }\n+\n+fn fetch_hash(path: &Path) -> Result<String, Box<dyn Error>> {\n+    let mut file = BufReader::new(File::open(path)?);\n+    let mut sha256 = sha2::Sha256::default();\n+    std::io::copy(&mut file, &mut sha256)?;\n+    Ok(hex::encode(sha256.finalize()))\n+}"}, {"sha": "20e62abb54cfa33bfa3f6fc4ffcd8e0c86903d0a", "filename": "src/tools/build-manifest/src/manifest.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmanifest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fffeaa7b83df07600092ac5b2a3d84e5dc76637b/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmanifest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmanifest.rs?ref=fffeaa7b83df07600092ac5b2a3d84e5dc76637b", "patch": "@@ -0,0 +1,114 @@\n+use crate::Builder;\n+use serde::{Serialize, Serializer};\n+use std::collections::BTreeMap;\n+use std::path::{Path, PathBuf};\n+\n+#[derive(Serialize)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub(crate) struct Manifest {\n+    pub(crate) manifest_version: String,\n+    pub(crate) date: String,\n+    pub(crate) pkg: BTreeMap<String, Package>,\n+    pub(crate) renames: BTreeMap<String, Rename>,\n+    pub(crate) profiles: BTreeMap<String, Vec<String>>,\n+}\n+\n+#[derive(Serialize)]\n+pub(crate) struct Package {\n+    pub(crate) version: String,\n+    pub(crate) git_commit_hash: Option<String>,\n+    pub(crate) target: BTreeMap<String, Target>,\n+}\n+\n+#[derive(Serialize)]\n+pub(crate) struct Rename {\n+    pub(crate) to: String,\n+}\n+\n+#[derive(Serialize, Default)]\n+pub(crate) struct Target {\n+    pub(crate) available: bool,\n+    pub(crate) url: Option<String>,\n+    pub(crate) hash: Option<FileHash>,\n+    pub(crate) xz_url: Option<String>,\n+    pub(crate) xz_hash: Option<FileHash>,\n+    pub(crate) components: Option<Vec<Component>>,\n+    pub(crate) extensions: Option<Vec<Component>>,\n+}\n+\n+impl Target {\n+    pub(crate) fn from_compressed_tar(builder: &Builder, base_path: &str) -> Self {\n+        let base_path = builder.input.join(base_path);\n+        let gz = Self::tarball_variant(&base_path, \"gz\");\n+        let xz = Self::tarball_variant(&base_path, \"xz\");\n+\n+        if gz.is_none() {\n+            return Self::unavailable();\n+        }\n+\n+        Self {\n+            available: true,\n+            components: None,\n+            extensions: None,\n+            // .gz\n+            url: gz.as_ref().map(|path| builder.url(path)),\n+            hash: gz.map(FileHash::Missing),\n+            // .xz\n+            xz_url: xz.as_ref().map(|path| builder.url(path)),\n+            xz_hash: xz.map(FileHash::Missing),\n+        }\n+    }\n+\n+    fn tarball_variant(base: &Path, ext: &str) -> Option<PathBuf> {\n+        let mut path = base.to_path_buf();\n+        path.set_extension(ext);\n+        if path.is_file() { Some(path) } else { None }\n+    }\n+\n+    pub(crate) fn unavailable() -> Self {\n+        Self::default()\n+    }\n+}\n+\n+#[derive(Serialize)]\n+pub(crate) struct Component {\n+    pub(crate) pkg: String,\n+    pub(crate) target: String,\n+}\n+\n+impl Component {\n+    pub(crate) fn from_str(pkg: &str, target: &str) -> Self {\n+        Self { pkg: pkg.to_string(), target: target.to_string() }\n+    }\n+}\n+\n+#[allow(unused)]\n+pub(crate) enum FileHash {\n+    Missing(PathBuf),\n+    Present(String),\n+}\n+\n+impl Serialize for FileHash {\n+    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\n+        match self {\n+            FileHash::Missing(path) => Err(serde::ser::Error::custom(format!(\n+                \"can't serialize a missing hash for file {}\",\n+                path.display()\n+            ))),\n+            FileHash::Present(inner) => inner.serialize(serializer),\n+        }\n+    }\n+}\n+\n+pub(crate) fn visit_file_hashes(manifest: &mut Manifest, mut f: impl FnMut(&mut FileHash)) {\n+    for pkg in manifest.pkg.values_mut() {\n+        for target in pkg.target.values_mut() {\n+            if let Some(hash) = &mut target.hash {\n+                f(hash);\n+            }\n+            if let Some(hash) = &mut target.xz_hash {\n+                f(hash);\n+            }\n+        }\n+    }\n+}"}]}