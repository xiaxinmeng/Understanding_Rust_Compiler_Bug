{"sha": "d7072b5bb42eb005ab3adac2605f175d8719e1f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MDcyYjViYjQyZWIwMDVhYjNhZGFjMjYwNWYxNzVkODcxOWUxZjE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-27T21:12:17Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-28T08:04:51Z"}, "message": "Fix rebase", "tree": {"sha": "3d1d4884e8f468d106dc742d6fc855fcd7532ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d1d4884e8f468d106dc742d6fc855fcd7532ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7072b5bb42eb005ab3adac2605f175d8719e1f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7072b5bb42eb005ab3adac2605f175d8719e1f1", "html_url": "https://github.com/rust-lang/rust/commit/d7072b5bb42eb005ab3adac2605f175d8719e1f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7072b5bb42eb005ab3adac2605f175d8719e1f1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "554b4282d8597e620b415463afc203d4b9e61fef", "url": "https://api.github.com/repos/rust-lang/rust/commits/554b4282d8597e620b415463afc203d4b9e61fef", "html_url": "https://github.com/rust-lang/rust/commit/554b4282d8597e620b415463afc203d4b9e61fef"}], "stats": {"total": 129, "additions": 71, "deletions": 58}, "files": [{"sha": "260ad00328344210dab0d6ca555640647571036c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -676,15 +676,15 @@ impl<'a> LoweringContext<'a> {\n                 // that collisions are ok here and this shouldn't\n                 // really show up for end-user.\n                 let str_name = match hir_name {\n-                    ParamName::Plain(ident) => name.as_interned_str(),\n+                    ParamName::Plain(ident) => ident.as_interned_str(),\n                     ParamName::Fresh(_) => keywords::UnderscoreLifetime.name().as_interned_str(),\n                 };\n \n                 // Add a definition for the in-band lifetime def\n                 self.resolver.definitions().create_def_with_parent(\n                     parent_id.index,\n                     def_node_id,\n-                    DefPathData::LifetimeDef(str_name),\n+                    DefPathData::LifetimeParam(str_name),\n                     DefIndexAddressSpace::High,\n                     Mark::root(),\n                     span,\n@@ -719,10 +719,10 @@ impl<'a> LoweringContext<'a> {\n             return;\n         }\n \n-        let hir_name = ParamName::Plain(name);\n+        let hir_name = ParamName::Plain(ident);\n \n         if self.lifetimes_to_define.iter()\n-                                   .any(|(_, lt_name)| *lt_name.modern() == hir_name.modern()) {\n+                                   .any(|(_, lt_name)| lt_name.modern() == hir_name.modern()) {\n             return;\n         }\n \n@@ -1185,10 +1185,11 @@ impl<'a> LoweringContext<'a> {\n                         let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n                         self.in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n-                            ident: ParamName::Plain(ident),\n+                            name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n                             attrs: hir_vec![],\n                             bounds: hir_bounds,\n+                            span,\n                             kind: hir::GenericParamKind::Type {\n                                 default: None,\n                                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n@@ -1438,7 +1439,7 @@ impl<'a> LoweringContext<'a> {\n \n                     let name = match name {\n                         hir::LifetimeName::Underscore => {\n-                            hir::ParamName::Plain(keywords::UnderscoreLifetime.name())\n+                            hir::ParamName::Plain(keywords::UnderscoreLifetime.ident())\n                         }\n                         hir::LifetimeName::Param(param_name) => param_name,\n                         _ => bug!(\"expected LifetimeName::Param or ParamName::Plain\"),\n@@ -2101,7 +2102,7 @@ impl<'a> LoweringContext<'a> {\n             let future_params = P(hir::GenericArgs {\n                 args: hir_vec![],\n                 bindings: hir_vec![hir::TypeBinding {\n-                    name: Symbol::intern(FN_OUTPUT_NAME),\n+                    ident: Ident::from_str(FN_OUTPUT_NAME),\n                     ty: output_ty,\n                     id: this.next_id().node_id,\n                     span,\n@@ -2163,7 +2164,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = l.ident.span;\n-        match self.lower_ident(l.ident) {\n+        match l.ident {\n             ident if ident.name == keywords::StaticLifetime.name() =>\n                 self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n             ident if ident.name == keywords::UnderscoreLifetime.name() =>\n@@ -2221,7 +2222,7 @@ impl<'a> LoweringContext<'a> {\n                 let lt = self.lower_lifetime(&Lifetime { id: param.id, ident: param.ident });\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n-                    _ => hir::ParamName::Plain(lt.name.name()),\n+                    _ => hir::ParamName::Plain(lt.name.ident()),\n                 };\n                 let param = hir::GenericParam {\n                     id: lt.id,\n@@ -2238,14 +2239,14 @@ impl<'a> LoweringContext<'a> {\n                 param\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                let mut name = self.lower_ident(param.ident);\n-\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n                 // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-                if name == keywords::SelfType.name() {\n-                    name = Symbol::gensym(\"Self\");\n-                }\n+                let ident = if param.ident.name == keywords::SelfType.name() {\n+                    param.ident.gensym()\n+                } else {\n+                    param.ident\n+                };\n \n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n@@ -2256,11 +2257,11 @@ impl<'a> LoweringContext<'a> {\n \n                 hir::GenericParam {\n                     id: self.lower_node_id(param.id).node_id,\n-                    name: hir::ParamName::Plain(name),\n-                    span: param.ident.span,\n+                    name: hir::ParamName::Plain(ident),\n                     pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n                     attrs: self.lower_attrs(&param.attrs),\n                     bounds,\n+                    span: ident.span,\n                     kind: hir::GenericParamKind::Type {\n                         default: default.as_ref().map(|x| {\n                             self.lower_ty(x, ImplTraitContext::Disallowed)\n@@ -3656,7 +3657,7 @@ impl<'a> LoweringContext<'a> {\n                 let e2 = self.lower_expr(e2);\n                 let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n                 let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n-                let new_seg = P(hir::PathSegment::from_name(Ident::from_str(\"new\")));\n+                let new_seg = P(hir::PathSegment::from_ident(Ident::from_str(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n                 let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n                 hir::ExprCall(new, hir_vec![e1, e2])"}, {"sha": "b7071970a04b9e0bc01f6c25168718ce3cc603e8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -616,7 +616,7 @@ impl<'hir> Map<'hir> {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeGenericParam(param) => param.name.ident(),\n+            NodeGenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n@@ -955,7 +955,7 @@ impl<'hir> Map<'hir> {\n             NodeField(f) => f.ident.name,\n             NodeLifetime(lt) => lt.name.ident().name,\n             NodeGenericParam(param) => param.name.ident().name,\n-            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n+            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n@@ -1021,7 +1021,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryBlock(_, _, block)) => block.span,\n             Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n             Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n-            Some(EntryGenericParam(_, _, param)) => param.ident.span,\n+            Some(EntryGenericParam(_, _, param)) => param.span,\n             Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,"}, {"sha": "5416474721045acbe022baad0abae5e39e060b01", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -201,7 +201,7 @@ pub struct Lifetime {\n #[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n-    Plain(Name),\n+    Plain(Ident),\n \n     /// Synthetic name generated when user elided a lifetime in an impl header,\n     /// e.g. the lifetimes in cases like these:\n@@ -220,10 +220,17 @@ pub enum ParamName {\n }\n \n impl ParamName {\n-    pub fn name(&self) -> Name {\n+    pub fn ident(&self) -> Ident {\n+        match *self {\n+            ParamName::Plain(ident) => ident,\n+            ParamName::Fresh(_) => keywords::UnderscoreLifetime.ident(),\n+        }\n+    }\n+\n+    pub fn modern(&self) -> ParamName {\n         match *self {\n-            ParamName::Plain(name) => name,\n-            ParamName::Fresh(_) => keywords::UnderscoreLifetime.name(),\n+            ParamName::Plain(ident) => ParamName::Plain(ident.modern()),\n+            param_name => param_name,\n         }\n     }\n }\n@@ -247,24 +254,22 @@ impl LifetimeName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             LifetimeName::Implicit => keywords::Invalid.ident(),\n-            LifetimeName::Fresh(_) | LifetimeName::Underscore =>\n-                keywords::UnderscoreLifetime.ident(),\n+            LifetimeName::Underscore => keywords::UnderscoreLifetime.ident(),\n             LifetimeName::Static => keywords::StaticLifetime.ident(),\n-            LifetimeName::Ident(ident) => ident,\n+            LifetimeName::Param(param_name) => param_name.ident(),\n         }\n     }\n \n     pub fn is_elided(&self) -> bool {\n-        use self::LifetimeName::*;\n         match self {\n-            Implicit | Underscore => true,\n+            LifetimeName::Implicit | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n             // *not* elided -- but this is because, as far as the code\n             // in the compiler is concerned -- `Fresh(_)` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            Param(_) | Static => false,\n+            LifetimeName::Param(_) | LifetimeName::Static => false,\n         }\n     }\n \n@@ -274,7 +279,7 @@ impl LifetimeName {\n \n     pub fn modern(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Ident(ident) => LifetimeName::Ident(ident.modern()),\n+            LifetimeName::Param(param_name) => LifetimeName::Param(param_name.modern()),\n             lifetime_name => lifetime_name,\n         }\n     }\n@@ -492,6 +497,7 @@ pub struct GenericParam {\n     pub name: ParamName,\n     pub attrs: HirVec<Attribute>,\n     pub bounds: GenericBounds,\n+    pub span: Span,\n     pub pure_wrt_drop: bool,\n \n     pub kind: GenericParamKind,"}, {"sha": "c6f69a84d034d73f0657ee829189913ea8f29239", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -2113,7 +2113,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_generic_param(&mut self, param: &GenericParam) -> io::Result<()> {\n-        self.print_name(param.name.name())?;\n+        self.print_ident(param.name.ident())?;\n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n                 let mut sep = \":\";\n@@ -2144,7 +2144,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n-        self.print_name(lifetime.name.name())\n+        self.print_ident(lifetime.name.ident())\n     }\n \n     pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) -> io::Result<()> {"}, {"sha": "d59a20c652250d12b9ee511ecc9a5ec5c599aa9e", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -203,6 +203,7 @@ impl_stable_hash_for!(struct hir::GenericParam {\n     pure_wrt_drop,\n     attrs,\n     bounds,\n+    span,\n     kind\n });\n "}, {"sha": "ed2b9c5068929c49a720f2b78be98730423e2acc", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -689,7 +689,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n                             if let hir::ParamName::Plain(param_name) = name {\n-                                if param_name == keywords::UnderscoreLifetime.name() {\n+                                if param_name.name == keywords::UnderscoreLifetime.name() {\n                                     // Pick the elided lifetime \"definition\" if one exists\n                                     // and use it to make an elision scope.\n                                     elision = Some(reg);\n@@ -1175,7 +1175,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                     ref lifetimes, s, ..\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&hir::LifetimeName::Ident(label.modern())) {\n+                    if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n                         let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -1397,10 +1397,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n                         hir::map::NodeLifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n+                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n                         hir::map::NodeGenericParam(param) => {\n-                            Some((param.id, param.span, param.name.name()))\n+                            Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n@@ -1423,10 +1423,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n                         hir::map::NodeLifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n+                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n                         hir::map::NodeGenericParam(param) => {\n-                            Some((param.id, param.span, param.name.name()))\n+                            Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n@@ -2243,15 +2243,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }).collect();\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n-                let name = lifetime_i_name.name();\n+                let name = lifetime_i_name.ident().name;\n                 if name == keywords::UnderscoreLifetime.name() ||\n                    name == keywords::StaticLifetime.name() {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         lifetime_i.span,\n                         E0262,\n                         \"invalid lifetime parameter name: `{}`\",\n-                        lifetime\n+                        lifetime_i.name.ident(),\n                     );\n                     err.span_label(\n                         lifetime_i.span,\n@@ -2269,7 +2269,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         lifetime_j.span,\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n-                        lifetime_j.name.name()\n+                        lifetime_j.name.ident()\n                     ).span_label(lifetime_j.span, \"declared twice\")\n                      .span_label(lifetime_i.span, \"previous declaration here\")\n                      .emit();\n@@ -2298,12 +2298,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 lifetime_i.span.to(lt.span),\n                                 &format!(\n                                     \"unnecessary lifetime parameter `{}`\",\n-                                    lifetime_i.name.name(),\n+                                    lifetime_i.name.ident(),\n                                 ),\n                             ).help(&format!(\n                                 \"you can use the `'static` lifetime directly, in place \\\n                                     of `{}`\",\n-                                lifetime_i.name.name(),\n+                                lifetime_i.name.ident(),\n                             )).emit();\n                         }\n                         hir::LifetimeName::Param(_)\n@@ -2549,7 +2549,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n-               param.name.name(),\n+               param.name.ident(),\n                param.id);\n \n         let inserted = map.late_bound.insert(param.id);"}, {"sha": "19b3654d2c7dc123756d2e825e037219b4245dae", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -331,7 +331,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n                     err.span_suggestion_with_applicability(\n                         p.span,\n                         \"to match on the variant, qualify the path\",\n-                        format!(\"{}::{}\", ty_path, name.node),\n+                        format!(\"{}::{}\", ty_path, ident),\n                         Applicability::MachineApplicable\n                     );\n                     err.emit();"}, {"sha": "464356eb5d242206d57395cf70be46516bc230ec", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -1497,17 +1497,17 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         args: Option<P<hir::GenericArgs>>,\n         is_value: bool\n     ) -> hir::Path {\n-        let mut segments = iter::once(keywords::CrateRoot.name())\n+        let mut segments = iter::once(keywords::CrateRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Symbol::intern)\n-            ).map(hir::PathSegment::from_name).collect::<Vec<_>>();\n+                    .map(Ident::from_str)\n+            ).map(hir::PathSegment::from_ident).collect::<Vec<_>>();\n \n         if let Some(args) = args {\n-            let name = segments.last().unwrap().name;\n+            let ident = segments.last().unwrap().ident;\n             *segments.last_mut().unwrap() = hir::PathSegment {\n-                name,\n+                ident,\n                 args: Some(args),\n                 infer_types: true,\n             };"}, {"sha": "f8c4bfc9ad723ab3f88d72abbe9a677b0a74b1b8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -3836,7 +3836,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n                         if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 && path.segments[0].name == \"rust\" {\n+                            if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n                         }"}, {"sha": "527aef80a8d9dcf26e736323fbc62e55a9eff146", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -251,7 +251,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             match param.kind {\n                 ty::GenericParamDefKind::Lifetime => {\n                     let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.name())\n+                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n                     } else {\n                         hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n                     };"}, {"sha": "e9f8aeb9ec8c53b8bf98fd56722a550ed06bb3bb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -1896,19 +1896,19 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.name();\n-                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n+                    let name = bounds.next().unwrap().name.ident();\n+                    let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n-                        s.push_str(&format!(\" + {}\", bound.name.name()));\n+                        s.push_str(&format!(\" + {}\", bound.name.ident()));\n                     }\n                     s\n                 } else {\n-                    self.name.name().to_string()\n+                    self.name.ident().to_string()\n                 };\n                 (name, GenericParamDefKind::Lifetime)\n             }\n             hir::GenericParamKind::Type { ref default, synthetic, .. } => {\n-                (self.name.name().clean(cx), GenericParamDefKind::Type {\n+                (self.name.ident().name.clean(cx), GenericParamDefKind::Type {\n                     did: cx.tcx.hir.local_def_id(self.id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),"}, {"sha": "bb64dad12085dfaa0e18e8674efef1a10c7c060d", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7072b5bb42eb005ab3adac2605f175d8719e1f1/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d7072b5bb42eb005ab3adac2605f175d8719e1f1", "patch": "@@ -59,6 +59,11 @@ impl Ident {\n         Ident::new(Symbol::intern(self.as_str().trim_left_matches('\\'')), self.span)\n     }\n \n+    /// \"Normalize\" ident for use in comparisons using \"item hygiene\".\n+    /// Identifiers with same string value become same if they came from the same \"modern\" macro\n+    /// (e.g. `macro` item, but not `macro_rules` item) and stay different if they came from\n+    /// different \"modern\" macros.\n+    /// Technically, this operation strips all non-opaque marks from ident's syntactic context.\n     pub fn modern(self) -> Ident {\n         Ident::new(self.name, self.span.modern())\n     }"}]}