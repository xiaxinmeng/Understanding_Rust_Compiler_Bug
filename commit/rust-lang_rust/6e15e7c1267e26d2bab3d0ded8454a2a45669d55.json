{"sha": "6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMTVlN2MxMjY3ZTI2ZDJiYWIzZDBkZWQ4NDU0YTJhNDU2NjlkNTU=", "commit": {"author": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-08-03T14:32:21Z"}, "committer": {"name": "Masaki Hara", "email": "ackie.h.gmai@gmail.com", "date": "2018-08-18T23:07:33Z"}, "message": "Integrate PassMode::UnsizedIndirect into PassMode::Indirect.", "tree": {"sha": "e544800e450215f882aa6667cdbdd12318772531", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e544800e450215f882aa6667cdbdd12318772531"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "html_url": "https://github.com/rust-lang/rust/commit/6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/comments", "author": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "qnighy", "id": 41755, "node_id": "MDQ6VXNlcjQxNzU1", "avatar_url": "https://avatars.githubusercontent.com/u/41755?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qnighy", "html_url": "https://github.com/qnighy", "followers_url": "https://api.github.com/users/qnighy/followers", "following_url": "https://api.github.com/users/qnighy/following{/other_user}", "gists_url": "https://api.github.com/users/qnighy/gists{/gist_id}", "starred_url": "https://api.github.com/users/qnighy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qnighy/subscriptions", "organizations_url": "https://api.github.com/users/qnighy/orgs", "repos_url": "https://api.github.com/users/qnighy/repos", "events_url": "https://api.github.com/users/qnighy/events{/privacy}", "received_events_url": "https://api.github.com/users/qnighy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0c422a752bdbe8f68b89f7656835bd7f36b2428", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c422a752bdbe8f68b89f7656835bd7f36b2428", "html_url": "https://github.com/rust-lang/rust/commit/a0c422a752bdbe8f68b89f7656835bd7f36b2428"}], "stats": {"total": 95, "additions": 42, "deletions": 53}, "files": [{"sha": "d699d786d1909e3e7bda5cfcdd42bdeb27a8ba2a", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "patch": "@@ -187,7 +187,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             return;\n         }\n         let cx = bx.cx;\n-        if self.is_indirect() {\n+        if self.is_sized_indirect() {\n             OperandValue::Ref(val, self.layout.align).store(bx, dst)\n         } else if self.is_unsized_indirect() {\n             bug!(\"unsized ArgType must be handled through store_fn_arg\");\n@@ -248,10 +248,10 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n-            PassMode::UnsizedIndirect(..) => {\n+            PassMode::Indirect(_, Some(_)) => {\n                 OperandValue::UnsizedRef(next(), next()).store(bx, dst);\n             }\n-            PassMode::Direct(_) | PassMode::Indirect(_) | PassMode::Cast(_) => {\n+            PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n                 self.store(bx, next(), dst);\n             }\n         }\n@@ -547,9 +547,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 }\n \n                 let size = arg.layout.size;\n-                if arg.layout.is_unsized() {\n-                    arg.make_unsized_indirect(None);\n-                } else if size > layout::Pointer.size(cx) {\n+                if arg.layout.is_unsized() || size > layout::Pointer.size(cx) {\n                     arg.make_indirect();\n                 } else {\n                     // We want to pass small aggregates as immediates, but using\n@@ -565,7 +563,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             for arg in &mut self.args {\n                 fixup(arg);\n             }\n-            if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n                 attrs.set(ArgAttribute::StructRet);\n             }\n             return;\n@@ -582,7 +580,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect(_) = self.ret.mode { 1 } else { 0 } + args_capacity\n+            if let PassMode::Indirect(..) = self.ret.mode { 1 } else { 0 } + args_capacity\n         );\n \n         let llreturn_ty = match self.ret.mode {\n@@ -591,11 +589,10 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 self.ret.layout.immediate_llvm_type(cx)\n             }\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n-            PassMode::Indirect(_) => {\n+            PassMode::Indirect(..) => {\n                 llargument_tys.push(self.ret.memory_ty(cx).ptr_to());\n                 Type::void(cx)\n             }\n-            PassMode::UnsizedIndirect(..) => bug!(\"return type must be sized\"),\n         };\n \n         for arg in &self.args {\n@@ -612,15 +609,15 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::UnsizedIndirect(..) => {\n+                PassMode::Indirect(_, Some(_)) => {\n                     let ptr_ty = cx.tcx.mk_mut_ptr(arg.layout.ty);\n                     let ptr_layout = cx.layout_of(ptr_ty);\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 0, true));\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_) => arg.memory_ty(cx).ptr_to(),\n+                PassMode::Indirect(_, None) => arg.memory_ty(cx).ptr_to(),\n             };\n             llargument_tys.push(llarg_ty);\n         }\n@@ -659,7 +656,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             PassMode::Direct(ref attrs) => {\n                 attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n             }\n-            PassMode::Indirect(ref attrs) => apply(attrs),\n+            PassMode::Indirect(ref attrs, _) => apply(attrs),\n             _ => {}\n         }\n         for arg in &self.args {\n@@ -669,8 +666,8 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             match arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n-                PassMode::Indirect(ref attrs) => apply(attrs),\n-                PassMode::UnsizedIndirect(ref attrs, ref extra_attrs) => {\n+                PassMode::Indirect(ref attrs, None) => apply(attrs),\n+                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n                     apply(attrs);\n                     apply(extra_attrs);\n                 }\n@@ -693,7 +690,7 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             PassMode::Direct(ref attrs) => {\n                 attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite);\n             }\n-            PassMode::Indirect(ref attrs) => apply(attrs),\n+            PassMode::Indirect(ref attrs, _) => apply(attrs),\n             _ => {}\n         }\n         if let layout::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n@@ -717,8 +714,8 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n             match arg.mode {\n                 PassMode::Ignore => {}\n                 PassMode::Direct(ref attrs) |\n-                PassMode::Indirect(ref attrs) => apply(attrs),\n-                PassMode::UnsizedIndirect(ref attrs, ref extra_attrs) => {\n+                PassMode::Indirect(ref attrs, None) => apply(attrs),\n+                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n                     apply(attrs);\n                     apply(extra_attrs);\n                 }"}, {"sha": "1bd7bf48cda122e68d03048c9c758ee8c6866295", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "patch": "@@ -225,7 +225,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n \n             mir::TerminatorKind::Return => {\n                 let llval = match self.fn_ty.ret.mode {\n-                    PassMode::Ignore | PassMode::Indirect(_) => {\n+                    PassMode::Ignore | PassMode::Indirect(..) => {\n                         bx.ret_void();\n                         return;\n                     }\n@@ -270,8 +270,6 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                             bx.pointercast(llslot, cast_ty.llvm_type(bx.cx).ptr_to()),\n                             self.fn_ty.ret.layout.align)\n                     }\n-\n-                    PassMode::UnsizedIndirect(..) => bug!(\"return value must be sized\"),\n                 };\n                 bx.ret(llval);\n             }\n@@ -667,7 +665,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 }\n                 _ => bug!(\"codegen_argument: {:?} invalid for pair arugment\", op)\n             }\n-        } else if let PassMode::UnsizedIndirect(..) = arg.mode {\n+        } else if arg.is_unsized_indirect() {\n             match op.val {\n                 UnsizedRef(a, b) => {\n                     llargs.push(a);\n@@ -682,7 +680,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 match arg.mode {\n-                    PassMode::Indirect(_) | PassMode::Cast(_) => {\n+                    PassMode::Indirect(..) | PassMode::Cast(_) => {\n                         let scratch = PlaceRef::alloca(bx, arg.layout, \"arg\");\n                         op.val.store(bx, scratch);\n                         (scratch.llval, scratch.align, true)"}, {"sha": "5991bb80c30e64b9d0435fea4e6449b6ec766e69", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "patch": "@@ -541,7 +541,7 @@ fn arg_local_refs(\n             }\n         }\n \n-        let place = if arg.is_indirect() {\n+        let place = if arg.is_sized_indirect() {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up.\n             // FIXME: lifetimes"}, {"sha": "78ed4b2d615a4449067e7dcf466e83a16081576c", "filename": "src/librustc_target/abi/call/mod.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fmod.rs?ref=6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "patch": "@@ -44,9 +44,9 @@ pub enum PassMode {\n     /// a single uniform or a pair of registers.\n     Cast(CastTarget),\n     /// Pass the argument indirectly via a hidden pointer.\n-    Indirect(ArgAttributes),\n-    /// Pass the unsized argument indirectly via a hidden pointer.\n-    UnsizedIndirect(ArgAttributes, ArgAttributes),\n+    /// The second value, if any, is for the extra data (vtable or length)\n+    /// which indicates that it refers to an unsized rvalue.\n+    Indirect(ArgAttributes, Option<ArgAttributes>),\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -370,38 +370,25 @@ impl<'a, Ty> ArgType<'a, Ty> {\n         // i686-pc-windows-msvc, it results in wrong stack offsets.\n         // attrs.pointee_align = Some(self.layout.align);\n \n-        self.mode = PassMode::Indirect(attrs);\n+        let extra_attrs = if self.layout.is_unsized() {\n+            Some(ArgAttributes::new())\n+        } else {\n+            None\n+        };\n+\n+        self.mode = PassMode::Indirect(attrs, extra_attrs);\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n         self.make_indirect();\n         match self.mode {\n-            PassMode::Indirect(ref mut attrs) => {\n+            PassMode::Indirect(ref mut attrs, _) => {\n                 attrs.set(ArgAttribute::ByVal);\n             }\n             _ => unreachable!()\n         }\n     }\n \n-    pub fn make_unsized_indirect(&mut self, vtable_size: Option<Size>) {\n-        self.make_indirect();\n-\n-        let attrs = if let PassMode::Indirect(attrs) = self.mode {\n-            attrs\n-        } else {\n-            unreachable!()\n-        };\n-\n-        let mut extra_attrs = ArgAttributes::new();\n-        if let Some(vtable_size) = vtable_size {\n-            extra_attrs.set(ArgAttribute::NoAlias)\n-                       .set(ArgAttribute::NonNull);\n-            extra_attrs.pointee_size = vtable_size;\n-        }\n-\n-        self.mode = PassMode::UnsizedIndirect(attrs, extra_attrs);\n-    }\n-\n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n         if let Abi::Scalar(ref scalar) = self.layout.abi {\n@@ -430,14 +417,21 @@ impl<'a, Ty> ArgType<'a, Ty> {\n \n     pub fn is_indirect(&self) -> bool {\n         match self.mode {\n-            PassMode::Indirect(_) => true,\n+            PassMode::Indirect(..) => true,\n+            _ => false\n+        }\n+    }\n+\n+    pub fn is_sized_indirect(&self) -> bool {\n+        match self.mode {\n+            PassMode::Indirect(_, None) => true,\n             _ => false\n         }\n     }\n \n     pub fn is_unsized_indirect(&self) -> bool {\n         match self.mode {\n-            PassMode::UnsizedIndirect(..) => true,\n+            PassMode::Indirect(_, Some(_)) => true,\n             _ => false\n         }\n     }\n@@ -534,7 +528,7 @@ impl<'a, Ty> FnType<'a, Ty> {\n             a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n-        if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+        if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n             attrs.set(ArgAttribute::StructRet);\n         }\n "}, {"sha": "1dcaafcf77fcf77527a45c51674ec5133c8ea52b", "filename": "src/librustc_target/abi/call/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e15e7c1267e26d2bab3d0ded8454a2a45669d55/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fcall%2Fx86.rs?ref=6e15e7c1267e26d2bab3d0ded8454a2a45669d55", "patch": "@@ -99,10 +99,10 @@ pub fn compute_abi_info<'a, Ty, C>(cx: C, fty: &mut FnType<'a, Ty>, flavor: Flav\n         for arg in &mut fty.args {\n             let attrs = match arg.mode {\n                 PassMode::Ignore |\n-                PassMode::Indirect(_) => continue,\n+                PassMode::Indirect(_, None) => continue,\n                 PassMode::Direct(ref mut attrs) => attrs,\n                 PassMode::Pair(..) |\n-                PassMode::UnsizedIndirect(..) |\n+                PassMode::Indirect(_, Some(_)) |\n                 PassMode::Cast(_) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }"}]}