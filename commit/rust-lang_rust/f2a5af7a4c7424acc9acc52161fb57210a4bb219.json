{"sha": "f2a5af7a4c7424acc9acc52161fb57210a4bb219", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYTVhZjdhNGM3NDI0YWNjOWFjYzUyMTYxZmI1NzIxMGE0YmIyMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-04T10:13:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-04T10:13:55Z"}, "message": "Auto merge of #43442 - zackmdavis:note_available_field_names_if_levenshtein_fails, r=nikomatsakis\n\nfield does not exist error: note fields if Levenshtein suggestion fails\n\nWhen trying to access or initialize a nonexistent field, if we can't infer what\nfield was meant (by virtue of the purported field in the source being a small\nLevenshtein distance away from an actual field, suggestive of a typo), issue a\nnote listing all the available fields. To reduce terminal clutter, we don't\nissue the note when we have a `find_best_match_for_name` Levenshtein\nsuggestion: the suggestion is probably right.\n\nThe third argument of the call to `find_best_match_for_name` is changed to\n`None`, accepting the default maximum Levenshtein distance of one-third of the\nidentifier supplied for correction. The previous value of `Some(name.len())`\nwas overzealous, inappropriately very Levenshtein-distant suggestions when the\nattempted field access could not plausibly be a mere typo. For example, if a\nstruct has fields `mule` and `phone`, but I type `.donkey`, I'd rather the\nerror have a note listing that the available fields are, in fact, `mule` and\n`phone` (which is the behavior induced by this patch) rather than the error\nasking \"did you mean `phone`?\" (which is the behavior on master). The \"only\nfind fits with at least one matching letter\" comment was accurate when it was\nfirst introduced in 09d992471 (January 2015), but is a vicious lie in its\npresent context before a call to `find_best_match_for_name` and must be\ndestroyed (replacing every letter is within a Levenshtein distance of name.len()).\n\nThe present author claims that this suffices to resolve #42599.", "tree": {"sha": "3a1c9f259c17e8f2bfa2d95f043f869ac638053f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a1c9f259c17e8f2bfa2d95f043f869ac638053f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a5af7a4c7424acc9acc52161fb57210a4bb219", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a5af7a4c7424acc9acc52161fb57210a4bb219", "html_url": "https://github.com/rust-lang/rust/commit/f2a5af7a4c7424acc9acc52161fb57210a4bb219", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a5af7a4c7424acc9acc52161fb57210a4bb219/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "url": "https://api.github.com/repos/rust-lang/rust/commits/c523b3f95498cf35a2f1a6bb8c071394ca4a6143", "html_url": "https://github.com/rust-lang/rust/commit/c523b3f95498cf35a2f1a6bb8c071394ca4a6143"}, {"sha": "2dbfa3995e44af6ce4fbeaa2f9de4730e5d2fbd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dbfa3995e44af6ce4fbeaa2f9de4730e5d2fbd5", "html_url": "https://github.com/rust-lang/rust/commit/2dbfa3995e44af6ce4fbeaa2f9de4730e5d2fbd5"}], "stats": {"total": 144, "additions": 131, "deletions": 13}, "files": [{"sha": "e53e5e7b08c97eb46644a981b076fa97b75305ed", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 9, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -2960,6 +2960,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                format!(\"did you mean `{}`?\", suggested_field_name));\n                             } else {\n                                 err.span_label(field.span, \"unknown field\");\n+                                let struct_variant_def = def.struct_variant();\n+                                let field_names = self.available_field_names(struct_variant_def);\n+                                if !field_names.is_empty() {\n+                                    err.note(&format!(\"available fields are: {}\",\n+                                                      self.name_series_display(field_names)));\n+                                }\n                             };\n                     }\n                     ty::TyRawPtr(..) => {\n@@ -2983,7 +2989,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Return an hint about the closest match in field names\n     fn suggest_field_name(variant: &'tcx ty::VariantDef,\n                           field: &Spanned<ast::Name>,\n-                          skip : Vec<InternedString>)\n+                          skip: Vec<InternedString>)\n                           -> Option<Symbol> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n@@ -2996,8 +3002,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        // only find fits with at least one matching letter\n-        find_best_match_for_name(names, &name, Some(name.len()))\n+        find_best_match_for_name(names, &name, None)\n+    }\n+\n+    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n+        let mut available = Vec::new();\n+        for field in variant.fields.iter() {\n+            let (_, def_scope) = self.tcx.adjust(field.name, variant.did, self.body_id);\n+            if field.vis.is_accessible_from(def_scope, self.tcx) {\n+                available.push(field.name);\n+            }\n+        }\n+        available\n+    }\n+\n+    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n+        // dynamic limit, to never omit just one field\n+        let limit = if names.len() == 6 { 6 } else { 5 };\n+        let mut display = names.iter().take(limit)\n+            .map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        if names.len() > limit {\n+            display = format!(\"{} ... and {} others\", display, names.len() - limit);\n+        }\n+        display\n     }\n \n     // Check tuple index expressions\n@@ -3111,13 +3138,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n-                ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    err.span_label(field.name.span, format!(\"`{}::{}` does not have this field\",\n-                                                             ty, variant.name));\n-                }\n-                _ => {\n-                    err.span_label(field.name.span, format!(\"`{}` does not have this field\", ty));\n+                ty::TyAdt(adt, ..) => {\n+                    if adt.is_enum() {\n+                        err.span_label(field.name.span,\n+                                       format!(\"`{}::{}` does not have this field\",\n+                                               ty, variant.name));\n+                    } else {\n+                        err.span_label(field.name.span,\n+                                       format!(\"`{}` does not have this field\", ty));\n+                    }\n+                    let available_field_names = self.available_field_names(variant);\n+                    if !available_field_names.is_empty() {\n+                        err.note(&format!(\"available fields are: {}\",\n+                                          self.name_series_display(available_field_names)));\n+                    }\n                 }\n+                _ => bug!(\"non-ADT passed to report_unknown_field\")\n             }\n         };\n         err.emit();"}, {"sha": "e8b0915d2b533fa24e339911715073f2b5cc2dd1", "filename": "src/test/compile-fail/E0559.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2FE0559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2FE0559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0559.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -15,5 +15,6 @@ enum Field {\n fn main() {\n     let s = Field::Fool { joke: 0 };\n     //~^ ERROR E0559\n-    //~| NOTE field does not exist - did you mean `x`?\n+    //~| NOTE `Field::Fool` does not have this field\n+    //~| NOTE available fields are: `x`\n }"}, {"sha": "955ef7ca99ceb51df2d73999c0aa3a94b41a81e0", "filename": "src/test/compile-fail/E0560.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2FE0560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2FE0560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0560.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -16,4 +16,5 @@ fn main() {\n     let s = Simba { mother: 1, father: 0 };\n     //~^ ERROR E0560\n     //~| NOTE `Simba` does not have this field\n+    //~| NOTE available fields are: `mother`\n }"}, {"sha": "938ccb343d4270099b2524eeecef1cd4ea5d3570", "filename": "src/test/compile-fail/issue-19922.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -15,5 +15,6 @@ enum Homura {\n fn main() {\n     let homura = Homura::Akemi { kaname: () };\n     //~^ ERROR variant `Homura::Akemi` has no field named `kaname`\n-    //~| NOTE field does not exist - did you mean `madoka`?\n+    //~| NOTE `Homura::Akemi` does not have this field\n+    //~| NOTE available fields are: `madoka`\n }"}, {"sha": "d6e091a1472cd903c483bced35d8e527e78bc4ea", "filename": "src/test/compile-fail/numeric-fields.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -13,7 +13,8 @@ struct S(u8, u16);\n fn main() {\n     let s = S{0b1: 10, 0: 11};\n     //~^ ERROR struct `S` has no field named `0b1`\n-    //~| NOTE field does not exist - did you mean `1`?\n+    //~| NOTE `S` does not have this field\n+    //~| NOTE available fields are: `0`, `1`\n     match s {\n         S{0: a, 0x1: b, ..} => {}\n         //~^ ERROR does not have a field named `0x1`"}, {"sha": "b1af142ad0fd230fd6fb6d5d9f660728ee7017dc", "filename": "src/test/compile-fail/struct-fields-too-many.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -18,5 +18,6 @@ fn main() {\n         bar: 0\n         //~^ ERROR struct `BuildData` has no field named `bar`\n         //~| NOTE `BuildData` does not have this field\n+        //~| NOTE available fields are: `foo`\n     };\n }"}, {"sha": "d0752b5f02f06d74f2bd78d98bf8187f164dd7a8", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -27,7 +27,8 @@ fn main () {\n         //~| NOTE field does not exist - did you mean `a`?\n         bb: 20,\n         //~^ ERROR struct `xc::B` has no field named `bb`\n-        //~| NOTE field does not exist - did you mean `a`?\n+        //~| NOTE `xc::B` does not have this field\n+        //~| NOTE available fields are: `a`\n     };\n     // local crate struct\n     let l = A {"}, {"sha": "124b16f99b1afd50db88ff8525cfd511ce19e786", "filename": "src/test/compile-fail/union/union-fields.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -20,6 +20,7 @@ fn main() {\n     let u = U { a: 0, b: 1, c: 2 }; //~ ERROR union expressions should have exactly one field\n                                     //~^ ERROR union `U` has no field named `c`\n                                     //~| NOTE `U` does not have this field\n+                                    //~| NOTE available fields are: `a`, `b`\n     let u = U { ..u }; //~ ERROR union expressions should have exactly one field\n                        //~^ ERROR functional record update syntax requires a struct\n "}, {"sha": "20bb7d4c91de3ac7e8843e8bab643ddd47208072", "filename": "src/test/ui/did_you_mean/issue-36798_unknown_field.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798_unknown_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798_unknown_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798_unknown_field.stderr?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -3,6 +3,8 @@ error[E0609]: no field `zz` on type `Foo`\n    |\n 17 |     f.zz;\n    |       ^^ unknown field\n+   |\n+   = note: available fields are: `bar`\n \n error: aborting due to previous error\n "}, {"sha": "7fe9950801227f1d1509cbcfe976418f92c6808c", "filename": "src/test/ui/did_you_mean/issue-42599_available_fields_note.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.rs?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod submodule {\n+\n+    #[derive(Default)]\n+    pub struct Demo {\n+        pub favorite_integer: isize,\n+        secret_integer: isize,\n+        pub innocently_misspellable: (),\n+        another_field: bool,\n+        yet_another_field: bool,\n+        always_more_fields: bool,\n+        and_ever: bool,\n+    }\n+\n+    impl Demo {\n+        fn new_with_secret_two() -> Self {\n+            Self { secret_integer: 2, inocently_mispellable: () }\n+        }\n+\n+        fn new_with_secret_three() -> Self {\n+            Self { secret_integer: 3, egregiously_nonexistent_field: () }\n+        }\n+    }\n+\n+}\n+\n+fn main() {\n+    use submodule::Demo;\n+\n+    let demo = Demo::default();\n+    let innocent_field_misaccess = demo.inocently_mispellable;\n+    // note shouldn't suggest private fields\n+    let egregious_field_misaccess = demo.egregiously_nonexistent_field;\n+}"}, {"sha": "e2bb7fbd9a895b1ee34b56c2275edd0dc554419a", "filename": "src/test/ui/did_you_mean/issue-42599_available_fields_note.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f2a5af7a4c7424acc9acc52161fb57210a4bb219/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr?ref=f2a5af7a4c7424acc9acc52161fb57210a4bb219", "patch": "@@ -0,0 +1,30 @@\n+error[E0560]: struct `submodule::Demo` has no field named `inocently_mispellable`\n+  --> $DIR/issue-42599_available_fields_note.rs:26:39\n+   |\n+26 |             Self { secret_integer: 2, inocently_mispellable: () }\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^ field does not exist - did you mean `innocently_misspellable`?\n+\n+error[E0560]: struct `submodule::Demo` has no field named `egregiously_nonexistent_field`\n+  --> $DIR/issue-42599_available_fields_note.rs:30:39\n+   |\n+30 |             Self { secret_integer: 3, egregiously_nonexistent_field: () }\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `submodule::Demo` does not have this field\n+   |\n+   = note: available fields are: `favorite_integer`, `secret_integer`, `innocently_misspellable`, `another_field`, `yet_another_field` ... and 2 others\n+\n+error[E0609]: no field `inocently_mispellable` on type `submodule::Demo`\n+  --> $DIR/issue-42599_available_fields_note.rs:40:41\n+   |\n+40 |     let innocent_field_misaccess = demo.inocently_mispellable;\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^ did you mean `innocently_misspellable`?\n+\n+error[E0609]: no field `egregiously_nonexistent_field` on type `submodule::Demo`\n+  --> $DIR/issue-42599_available_fields_note.rs:42:42\n+   |\n+42 |     let egregious_field_misaccess = demo.egregiously_nonexistent_field;\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown field\n+   |\n+   = note: available fields are: `favorite_integer`, `innocently_misspellable`\n+\n+error: aborting due to 4 previous errors\n+"}]}