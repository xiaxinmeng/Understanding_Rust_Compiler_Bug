{"sha": "d448329849bb2cef355cabfdc6cb4d8b5b76b80e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NDgzMjk4NDliYjJjZWYzNTVjYWJmZGM2Y2I0ZDhiNWI3NmI4MGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-24T15:50:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-03-30T11:56:58Z"}, "message": "fix handling of blocks with `CoerceMany`", "tree": {"sha": "06e11b25dc40e561829c423ae226b9637ecc29a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06e11b25dc40e561829c423ae226b9637ecc29a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d448329849bb2cef355cabfdc6cb4d8b5b76b80e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d448329849bb2cef355cabfdc6cb4d8b5b76b80e", "html_url": "https://github.com/rust-lang/rust/commit/d448329849bb2cef355cabfdc6cb4d8b5b76b80e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d448329849bb2cef355cabfdc6cb4d8b5b76b80e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83706454fd00c2a3b7873b50223b68ca2cbd0d0", "html_url": "https://github.com/rust-lang/rust/commit/f83706454fd00c2a3b7873b50223b68ca2cbd0d0"}], "stats": {"total": 139, "additions": 51, "deletions": 88}, "files": [{"sha": "8a9db674c6ebcd567881fa8ffcca78b21822a3da", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d448329849bb2cef355cabfdc6cb4d8b5b76b80e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d448329849bb2cef355cabfdc6cb4d8b5b76b80e/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=d448329849bb2cef355cabfdc6cb4d8b5b76b80e", "patch": "@@ -926,7 +926,7 @@ pub struct CoerceMany<'gcx, 'tcx, 'exprs, E>\n \n /// The type of a `CoerceMany` that is storing up the expressions into\n /// a buffer. We use this in `check/mod.rs` for things like `break`.\n-pub type DynamicCoerceMany<'gcx, 'tcx> = CoerceMany<'gcx, 'tcx, 'static, hir::Expr>;\n+pub type DynamicCoerceMany<'gcx, 'tcx> = CoerceMany<'gcx, 'tcx, 'gcx, P<hir::Expr>>;\n \n #[derive(Clone)] // (*)\n enum Expressions<'gcx, 'exprs, E>"}, {"sha": "413d09117af08502865107bfcb5d906ad289d162", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 87, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/d448329849bb2cef355cabfdc6cb4d8b5b76b80e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d448329849bb2cef355cabfdc6cb4d8b5b76b80e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d448329849bb2cef355cabfdc6cb4d8b5b76b80e", "patch": "@@ -86,6 +86,7 @@ use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use hir::def::{Def, CtorKind};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_back::slice::ref_slice;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin, TypeTrace};\n use rustc::infer::type_variable::{self, TypeVariableOrigin};\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -4108,102 +4109,64 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             replace(&mut *fcx_ps, unsafety_state)\n         };\n \n-        let mut ty = if blk.targeted_by_break {\n-            let unified = self.next_ty_var(TypeVariableOrigin::TypeInference(blk.span));\n-            let coerce_to = expected.only_has_type(self).unwrap_or(unified);\n-            let ctxt = BreakableCtxt {\n-                unified: unified,\n-                coerce_to: coerce_to,\n-                break_exprs: vec![],\n-                may_break: false,\n+        // In some cases, blocks have just one exit, but other blocks\n+        // can be targeted by multiple breaks. This cannot happen in\n+        // normal Rust syntax today, but it can happen when we desugar\n+        // a `do catch { ... }` expression.\n+        //\n+        // Example 1:\n+        //\n+        //    'a: { if true { break 'a Err(()); } Ok(()) }\n+        //\n+        // Here we would wind up with two coercions, one from\n+        // `Err(())` and the other from the tail expression\n+        // `Ok(())`. If the tail expression is omitted, that's a\n+        // \"forced unit\" -- unless the block diverges, in which\n+        // case we can ignore the tail expression (e.g., `'a: {\n+        // break 'a 22; }` would not force the type of the block\n+        // to be `()`).\n+        let tail_expr = blk.expr.as_ref();\n+        let coerce_to_ty = expected.coercion_target_type(self, blk.span);\n+        let coerce = if blk.targeted_by_break {\n+            CoerceMany::new(coerce_to_ty)\n+        } else {\n+            let tail_expr: &[P<hir::Expr>] = match tail_expr {\n+                Some(e) => ref_slice(e),\n+                None => &[],\n             };\n+            CoerceMany::with_coercion_sites(coerce_to_ty, tail_expr)\n+        };\n \n-            let (mut ctxt, (e_ty, cause)) = self.with_breakable_ctxt(blk.id, ctxt, || {\n-                for s in &blk.stmts {\n-                    self.check_stmt(s);\n-                }\n-                let coerce_to = {\n-                    let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-                    enclosing_breakables.find_breakable(blk.id).coerce_to\n-                };\n-                let e_ty;\n-                let cause;\n-                match blk.expr {\n-                    Some(ref e) => {\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                    },\n-                    None => {\n-                        e_ty = if self.diverges.get().always() {\n-                            self.tcx.types.never\n-                        } else {\n-                            self.tcx.mk_nil()\n-                        };\n-                        cause = self.misc(blk.span);\n-                    }\n-                };\n-\n-                (e_ty, cause)\n-            });\n-\n-        if let ExpectHasType(ety) = expected {\n-            if let Some(ref e) = blk.expr {\n-                let result = if !ctxt.may_break {\n-                    self.try_coerce(e, e_ty, ctxt.coerce_to)\n-                } else {\n-                    self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n-                                               ctxt.unified, e, e_ty)\n-                };\n-                match result {\n-                    Ok(ty) => ctxt.unified = ty,\n-                    Err(err) =>\n-                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err).emit(),\n-                }\n-            } else if self.diverges.get().always() {\n-                // No tail expression and the body diverges; ignore\n-                // the expected type, and keep `!` as the type of the\n-                // block.\n-            } else {\n-                self.check_block_no_expr(blk, self.tcx.mk_nil(), e_ty);\n-            };\n+        let ctxt = BreakableCtxt {\n+            coerce: Some(coerce),\n+            may_break: false,\n+        };\n \n-            ctxt.unified\n-        } else {\n+        let (ctxt, ()) = self.with_breakable_ctxt(blk.id, ctxt, || {\n             for s in &blk.stmts {\n                 self.check_stmt(s);\n             }\n \n-            let mut ty = match blk.expr {\n-                Some(ref e) => self.check_expr_with_expectation(e, expected),\n-                None => if self.diverges.get().always() {\n-                    self.tcx.types.never\n-                } else {\n-                    self.tcx.mk_nil()\n-                },\n-            };\n+            // check the tail expression **without** holding the\n+            // `enclosing_breakables` lock below.\n+            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n \n-            if let ExpectHasType(ety) = expected {\n-                if let Some(ref e) = blk.expr {\n-                    // Coerce the tail expression to the right type.\n-                    self.demand_coerce(e, ty, ety);\n-\n-                    // We already applied the type (and potentially errored),\n-                    // use the expected type to avoid further errors out.\n-                    ty = ety;\n-                } else if self.diverges.get().always() {\n-                    // No tail expression and the body diverges; ignore\n-                    // the expected type, and keep `!` as the type of the\n-                    // block.\n-                } else {\n-                    self.check_block_no_expr(blk, ty, ety);\n-\n-                    // We already applied the type (and potentially errored),\n-                    // use the expected type to avoid further errors out.\n-                    ty = ety;\n-                }\n+            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+            let mut ctxt = enclosing_breakables.find_breakable(blk.id);\n+            let mut coerce = ctxt.coerce.as_mut().unwrap();\n+            if let Some(tail_expr_ty) = tail_expr_ty {\n+                let tail_expr = tail_expr.unwrap();\n+                coerce.coerce(self,\n+                              &self.misc(tail_expr.span),\n+                              tail_expr,\n+                              tail_expr_ty,\n+                              self.diverges.get()); // TODO\n+            } else if !self.diverges.get().always() {\n+                coerce.coerce_forced_unit(self, &self.misc(blk.span));\n             }\n-            ty\n-        };\n+        });\n+\n+        let mut ty = ctxt.coerce.unwrap().complete(self);\n \n         if self.has_errors.get() || ty.references_error() {\n             ty = self.tcx.types.err"}]}