{"sha": "c2e457686b77a7eec906549b73feba314667235b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyZTQ1NzY4NmI3N2E3ZWVjOTA2NTQ5YjczZmViYTMxNDY2NzIzNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T01:41:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T01:41:45Z"}, "message": "auto merge of #13237 : alexcrichton/rust/private-tuple-structs, r=brson\n\nThis is the final commit need to implement [RFC #4](https://github.com/rust-lang/rfcs/blob/master/active/0004-private-fields.md), it makes all tuple struct fields private by default, overridable with the `pub` keyword.\r\n\r\nI'll note one divergence from the original RFC which is outlined in the first commit.", "tree": {"sha": "7502e270074fa24186b7599ee78ec4116cd96261", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7502e270074fa24186b7599ee78ec4116cd96261"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2e457686b77a7eec906549b73feba314667235b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2e457686b77a7eec906549b73feba314667235b", "html_url": "https://github.com/rust-lang/rust/commit/c2e457686b77a7eec906549b73feba314667235b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2e457686b77a7eec906549b73feba314667235b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7fe20722904cd2829a65f845ee7a1718cdf7292", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7fe20722904cd2829a65f845ee7a1718cdf7292", "html_url": "https://github.com/rust-lang/rust/commit/e7fe20722904cd2829a65f845ee7a1718cdf7292"}, {"sha": "922dcfdc6950f4d68d3334199de5572eef52b75a", "url": "https://api.github.com/repos/rust-lang/rust/commits/922dcfdc6950f4d68d3334199de5572eef52b75a", "html_url": "https://github.com/rust-lang/rust/commit/922dcfdc6950f4d68d3334199de5572eef52b75a"}], "stats": {"total": 405, "additions": 326, "deletions": 79}, "files": [{"sha": "70dd0da3130ed298dfdcbe8b40e70a28b690b49b", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -28,7 +28,7 @@ use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n /// Generate Normal Random\n /// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n /// College, Oxford\n-pub struct Exp1(f64);\n+pub struct Exp1(pub f64);\n \n // This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n impl Rand for Exp1 {"}, {"sha": "2745ddd4ce785782e86246b50da43910b2025bd9", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -27,7 +27,7 @@ use distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n /// Generate Normal Random\n /// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n /// College, Oxford\n-pub struct StandardNormal(f64);\n+pub struct StandardNormal(pub f64);\n \n impl Rand for StandardNormal {\n     fn rand<R:Rng>(rng: &mut R) -> StandardNormal {"}, {"sha": "1784349b1eb4dd993d5205676aa913843167dbdd", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -666,7 +666,7 @@ pub fn random<T: Rand>() -> T {\n /// let Open01(val) = random::<Open01<f32>>();\n /// println!(\"f32 from (0,1): {}\", val);\n /// ```\n-pub struct Open01<F>(F);\n+pub struct Open01<F>(pub F);\n \n /// A wrapper for generating floating point numbers uniformly in the\n /// closed interval `[0,1]` (including both endpoints).\n@@ -682,7 +682,7 @@ pub struct Open01<F>(F);\n /// let Closed01(val) = random::<Closed01<f32>>();\n /// println!(\"f32 from [0,1]: {}\", val);\n /// ```\n-pub struct Closed01<F>(F);\n+pub struct Closed01<F>(pub F);\n \n #[cfg(test)]\n mod test {"}, {"sha": "977db296af96b8eef3f2255d58a607354aa8f2b0", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -290,3 +290,11 @@ pub fn get_exported_macros(cstore: &cstore::CStore,\n     let cdata = cstore.get_crate_data(crate_num);\n     decoder::get_exported_macros(cdata)\n }\n+\n+pub fn get_tuple_struct_definition_if_ctor(cstore: &cstore::CStore,\n+                                           def_id: ast::DefId)\n+    -> Option<ast::DefId>\n+{\n+    let cdata = cstore.get_crate_data(def_id.krate);\n+    decoder::get_tuple_struct_definition_if_ctor(cdata, def_id.node)\n+}"}, {"sha": "556f0a38b03544a6049ff9aec2d0cea3e7a65fdc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -929,23 +929,26 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,\n-                                           node_id: ast::NodeId) -> Option<ast::NodeId> {\n+                                           node_id: ast::NodeId)\n+    -> Option<ast::DefId>\n+{\n     let item = lookup_item(node_id, cdata.data());\n     let mut ret = None;\n     reader::tagged_docs(item, tag_items_data_item_is_tuple_struct_ctor, |_| {\n         ret = Some(item_reqd_and_translated_parent_item(cdata.cnum, item));\n         false\n     });\n-    ret.map(|x| x.node)\n+    ret\n }\n \n pub fn get_item_attrs(cdata: Cmd,\n-                      node_id: ast::NodeId,\n+                      orig_node_id: ast::NodeId,\n                       f: |Vec<@ast::MetaItem> |) {\n     // The attributes for a tuple struct are attached to the definition, not the ctor;\n     // we assume that someone passing in a tuple struct ctor is actually wanting to\n     // look at the definition\n-    let node_id = get_tuple_struct_definition_if_ctor(cdata, node_id).unwrap_or(node_id);\n+    let node_id = get_tuple_struct_definition_if_ctor(cdata, orig_node_id);\n+    let node_id = node_id.map(|x| x.node).unwrap_or(orig_node_id);\n     let item = lookup_item(node_id, cdata.data());\n     reader::tagged_docs(item, tag_attributes, |attributes| {\n         reader::tagged_docs(attributes, tag_attribute, |attribute| {"}, {"sha": "2705f9bf9bf4dfc0e4de7cd98409a7076f981a41", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -56,11 +56,11 @@ pub struct Edge<E> {\n }\n \n #[deriving(Eq)]\n-pub struct NodeIndex(uint);\n+pub struct NodeIndex(pub uint);\n pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n \n #[deriving(Eq)]\n-pub struct EdgeIndex(uint);\n+pub struct EdgeIndex(pub uint);\n pub static InvalidEdgeIndex: EdgeIndex = EdgeIndex(uint::MAX);\n \n // Use a private field here to guarantee no more instances are created:"}, {"sha": "9d9faee36450a4fb0e9ddae98e9938c03c06b186", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 98, "deletions": 21, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -14,6 +14,7 @@\n \n use std::mem::replace;\n \n+use metadata::csearch;\n use middle::lint;\n use middle::resolve;\n use middle::ty;\n@@ -358,6 +359,12 @@ enum PrivacyResult {\n     DisallowedBy(ast::NodeId),\n }\n \n+enum FieldName {\n+    UnnamedField(uint), // index\n+    // FIXME #6993: change type (and name) from Ident to Name\n+    NamedField(ast::Ident),\n+}\n+\n impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> ~str {\n@@ -560,18 +567,23 @@ impl<'a> PrivacyVisitor<'a> {\n     }\n \n     // Checks that a field is in scope.\n-    // FIXME #6993: change type (and name) from Ident to Name\n-    fn check_field(&mut self, span: Span, id: ast::DefId, ident: ast::Ident) {\n-        for field in ty::lookup_struct_fields(self.tcx, id).iter() {\n-            if field.name != ident.name { continue; }\n-            if field.vis == ast::Public { break }\n-            if !is_local(field.id) ||\n-               !self.private_accessible(field.id.node) {\n-                self.tcx.sess.span_err(span,\n-                                       format!(\"field `{}` is private\",\n-                                               token::get_ident(ident)))\n+    fn check_field(&mut self, span: Span, id: ast::DefId,\n+                   name: FieldName) {\n+        let fields = ty::lookup_struct_fields(self.tcx, id);\n+        let field = match name {\n+            NamedField(ident) => {\n+                fields.iter().find(|f| f.name == ident.name).unwrap()\n             }\n-            break;\n+            UnnamedField(idx) => fields.get(idx)\n+        };\n+        if field.vis == ast::Public { return }\n+        if !is_local(field.id) || !self.private_accessible(field.id.node) {\n+            let msg = match name {\n+                NamedField(name) => format!(\"field `{}` is private\",\n+                                            token::get_ident(name)),\n+                UnnamedField(idx) => format!(\"field \\\\#{} is private\", idx + 1),\n+            };\n+            self.tcx.sess.span_err(span, msg);\n         }\n     }\n \n@@ -634,10 +646,11 @@ impl<'a> PrivacyVisitor<'a> {\n                             _ => {},\n                         }\n                     }\n-                    // If an import is not used in either namespace, we still want to check\n-                    // that it could be legal. Therefore we check in both namespaces and only\n-                    // report an error if both would be illegal. We only report one error,\n-                    // even if it is illegal to import from both namespaces.\n+                    // If an import is not used in either namespace, we still\n+                    // want to check that it could be legal. Therefore we check\n+                    // in both namespaces and only report an error if both would\n+                    // be illegal. We only report one error, even if it is\n+                    // illegal to import from both namespaces.\n                     match (value_priv, check_value, type_priv, check_type) {\n                         (Some(p), resolve::Unused, None, _) |\n                         (None, _, Some(p), resolve::Unused) => {\n@@ -701,7 +714,8 @@ impl<'a> PrivacyVisitor<'a> {\n             // is whether the trait itself is accessible or not.\n             MethodParam(MethodParam { trait_id: trait_id, .. }) |\n             MethodObject(MethodObject { trait_id: trait_id, .. }) => {\n-                self.report_error(self.ensure_public(span, trait_id, None, \"source trait\"));\n+                self.report_error(self.ensure_public(span, trait_id, None,\n+                                                     \"source trait\"));\n             }\n         }\n     }\n@@ -726,7 +740,7 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty_adjusted(self.tcx, base,\n                                                    &*self.method_map.borrow())).sty {\n                     ty::ty_struct(id, _) => {\n-                        self.check_field(expr.span, id, ident);\n+                        self.check_field(expr.span, id, NamedField(ident));\n                     }\n                     _ => {}\n                 }\n@@ -749,15 +763,16 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::expr_ty(self.tcx, expr)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in (*fields).iter() {\n-                            self.check_field(expr.span, id, field.ident.node);\n+                            self.check_field(expr.span, id,\n+                                             NamedField(field.ident.node));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().get_copy(&expr.id) {\n                             ast::DefVariant(_, variant_id, _) => {\n                                 for field in fields.iter() {\n                                     self.check_field(expr.span, variant_id,\n-                                                     field.ident.node);\n+                                                     NamedField(field.ident.node));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(expr.span,\n@@ -772,6 +787,46 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                                             struct type?!\"),\n                 }\n             }\n+            ast::ExprPath(..) => {\n+                let guard = |did: ast::DefId| {\n+                    let fields = ty::lookup_struct_fields(self.tcx, did);\n+                    let any_priv = fields.iter().any(|f| {\n+                        f.vis != ast::Public && (\n+                            !is_local(f.id) ||\n+                            !self.private_accessible(f.id.node))\n+                    });\n+                    if any_priv {\n+                        self.tcx.sess.span_err(expr.span,\n+                            \"cannot invoke tuple struct constructor \\\n+                             with private fields\");\n+                    }\n+                };\n+                match self.tcx.def_map.borrow().find(&expr.id) {\n+                    Some(&ast::DefStruct(did)) => {\n+                        guard(if is_local(did) {\n+                            local_def(self.tcx.map.get_parent(did.node))\n+                        } else {\n+                            // \"tuple structs\" with zero fields (such as\n+                            // `pub struct Foo;`) don't have a ctor_id, hence\n+                            // the unwrap_or to the same struct id.\n+                            let maybe_did =\n+                                csearch::get_tuple_struct_definition_if_ctor(\n+                                    &self.tcx.sess.cstore, did);\n+                            maybe_did.unwrap_or(did)\n+                        })\n+                    }\n+                    // Tuple struct constructors across crates are identified as\n+                    // DefFn types, so we explicitly handle that case here.\n+                    Some(&ast::DefFn(did, _)) if !is_local(did) => {\n+                        match csearch::get_tuple_struct_definition_if_ctor(\n+                                    &self.tcx.sess.cstore, did) {\n+                            Some(did) => guard(did),\n+                            None => {}\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n             _ => {}\n         }\n \n@@ -821,15 +876,16 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                 match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n                     ty::ty_struct(id, _) => {\n                         for field in fields.iter() {\n-                            self.check_field(pattern.span, id, field.ident);\n+                            self.check_field(pattern.span, id,\n+                                             NamedField(field.ident));\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n                         match self.tcx.def_map.borrow().find(&pattern.id) {\n                             Some(&ast::DefVariant(_, variant_id, _)) => {\n                                 for field in fields.iter() {\n                                     self.check_field(pattern.span, variant_id,\n-                                                     field.ident);\n+                                                     NamedField(field.ident));\n                                 }\n                             }\n                             _ => self.tcx.sess.span_bug(pattern.span,\n@@ -844,6 +900,27 @@ impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n                                                  struct type?!\"),\n                 }\n             }\n+\n+            // Patterns which bind no fields are allowable (the path is check\n+            // elsewhere).\n+            ast::PatEnum(_, Some(ref fields)) => {\n+                match ty::get(ty::pat_ty(self.tcx, pattern)).sty {\n+                    ty::ty_struct(id, _) => {\n+                        for (i, field) in fields.iter().enumerate() {\n+                            match field.node {\n+                                ast::PatWild(..) => continue,\n+                                _ => {}\n+                            }\n+                            self.check_field(field.span, id, UnnamedField(i));\n+                        }\n+                    }\n+                    ty::ty_enum(..) => {\n+                        // enum fields have no privacy at this time\n+                    }\n+                    _ => {}\n+                }\n+\n+            }\n             _ => {}\n         }\n "}, {"sha": "303ad5fbce2ce25283fc13cd4820f60e9121297f", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -12,7 +12,7 @@ use lib::llvm::{llvm, BasicBlockRef};\n use middle::trans::value::{Users, Value};\n use std::iter::{Filter, Map};\n \n-pub struct BasicBlock(BasicBlockRef);\n+pub struct BasicBlock(pub BasicBlockRef);\n \n pub type Preds<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, Users>>;\n "}, {"sha": "1efb47ad42fb5bc0daa36bf80d640e90b1aca651", "filename": "src/librustc/middle/trans/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fvalue.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -13,7 +13,7 @@ use middle::trans::basic_block::BasicBlock;\n use middle::trans::common::Block;\n use std::libc::c_uint;\n \n-pub struct Value(ValueRef);\n+pub struct Value(pub ValueRef);\n \n macro_rules! opt_val ( ($e:expr) => (\n     unsafe {"}, {"sha": "4aefa3b9edcccb1643e07374f4f1514efd7c333d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -866,13 +866,13 @@ impl CLike for BuiltinBound {\n }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n-pub struct TyVid(uint);\n+pub struct TyVid(pub uint);\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n-pub struct IntVid(uint);\n+pub struct IntVid(pub uint);\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n-pub struct FloatVid(uint);\n+pub struct FloatVid(pub uint);\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct RegionVid {"}, {"sha": "8a1662ca701d349273e4f12dda7ec6be6e0bbb10", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -84,7 +84,7 @@ use syntax::ast;\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-pub struct Coerce<'f>(CombineFields<'f>);\n+pub struct Coerce<'f>(pub CombineFields<'f>);\n \n impl<'f> Coerce<'f> {\n     pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> {"}, {"sha": "83fc315bcebc82f1465638f86828c275505eb6d9", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -28,7 +28,7 @@ use collections::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n-pub struct Glb<'f>(CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n+pub struct Glb<'f>(pub CombineFields<'f>);  // \"greatest lower bound\" (common subtype)\n \n impl<'f> Glb<'f> {\n     pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Glb(ref v) = *self; v }"}, {"sha": "7f48e2333676aadb7d9a772c2e528ecd4f556f62", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -27,7 +27,7 @@ use syntax::ast::{ExternFn, ImpureFn, UnsafeFn};\n use syntax::ast::{Onceness, Purity};\n use util::ppaux::mt_to_str;\n \n-pub struct Lub<'f>(CombineFields<'f>);  // least-upper-bound: common supertype\n+pub struct Lub<'f>(pub CombineFields<'f>);  // least-upper-bound: common supertype\n \n impl<'f> Lub<'f> {\n     pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Lub(ref v) = *self; v }"}, {"sha": "b22e6f4677bd72d820234035fac339341ae4b43d", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -27,7 +27,7 @@ use util::ppaux::bound_region_to_str;\n \n use syntax::ast::{Onceness, Purity};\n \n-pub struct Sub<'f>(CombineFields<'f>);  // \"subtype\", \"subregion\" etc\n+pub struct Sub<'f>(pub CombineFields<'f>);  // \"subtype\", \"subregion\" etc\n \n impl<'f> Sub<'f> {\n     pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f> { let Sub(ref v) = *self; v }"}, {"sha": "60fcbe33a1be956e8e6671530e7d1aea5517ec76", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -17,7 +17,7 @@ use std::fmt;\n \n /// Wrapper struct which will emit the HTML-escaped version of the contained\n /// string when passed to a format string.\n-pub struct Escape<'a>(&'a str);\n+pub struct Escape<'a>(pub &'a str);\n \n impl<'a> fmt::Show for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "10c155262c31e504c2fbddb35fb81c192a070f04", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -28,12 +28,12 @@ use html::render::{cache_key, current_location_key};\n \n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n-pub struct VisSpace(Option<ast::Visibility>);\n+pub struct VisSpace(pub Option<ast::Visibility>);\n /// Similarly to VisSpace, this structure is used to render a purity with a\n /// space after it.\n-pub struct PuritySpace(ast::Purity);\n+pub struct PuritySpace(pub ast::Purity);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(&'a clean::SelfTy, &'a clean::FnDecl);\n+pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n \n impl VisSpace {\n     pub fn get(&self) -> Option<ast::Visibility> {"}, {"sha": "ff2462cfb22ba28f526dc2f3182fc398cebd350a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -42,10 +42,10 @@ use html::highlight;\n /// A unit struct which has the `fmt::Show` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-pub struct Markdown<'a>(&'a str);\n+pub struct Markdown<'a>(pub &'a str);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(&'a str);\n+pub struct MarkdownWithToc<'a>(pub &'a str);\n \n static OUTPUT_UNIT: libc::size_t = 64;\n static MKDEXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 0;"}, {"sha": "fc266df11e4be4a1f36b69678e19739044cf84d7", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -58,7 +58,7 @@ pub struct Task {\n }\n \n pub struct GarbageCollector;\n-pub struct LocalStorage(Option<local_data::Map>);\n+pub struct LocalStorage(pub Option<local_data::Map>);\n \n /// A handle to a blocked task. Usually this means having the ~Task pointer by\n /// ownership, but if the task is killable, a killer can steal it at any time."}, {"sha": "a7a314d35e7368bdf62d270b66d38ac72055fcc4", "filename": "src/libstd/unstable/simd.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibstd%2Funstable%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibstd%2Funstable%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsimd.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -14,40 +14,48 @@\n \n #[experimental]\n #[simd]\n-pub struct i8x16(i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8);\n+pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n+                 pub i8, pub i8, pub i8, pub i8,\n+                 pub i8, pub i8, pub i8, pub i8,\n+                 pub i8, pub i8, pub i8, pub i8);\n \n #[experimental]\n #[simd]\n-pub struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n+                 pub i16, pub i16, pub i16, pub i16);\n \n #[experimental]\n #[simd]\n-pub struct i32x4(i32, i32, i32, i32);\n+pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n #[experimental]\n #[simd]\n-pub struct i64x2(i64, i64);\n+pub struct i64x2(pub i64, pub i64);\n \n #[experimental]\n #[simd]\n-pub struct u8x16(u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8, u8);\n+pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n+                 pub u8, pub u8, pub u8, pub u8,\n+                 pub u8, pub u8, pub u8, pub u8,\n+                 pub u8, pub u8, pub u8, pub u8);\n \n #[experimental]\n #[simd]\n-pub struct u16x8(u16, u16, u16, u16, u16, u16, u16, u16);\n+pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n+                 pub u16, pub u16, pub u16, pub u16);\n \n #[experimental]\n #[simd]\n-pub struct u32x4(u32, u32, u32, u32);\n+pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n #[experimental]\n #[simd]\n-pub struct u64x2(u64, u64);\n+pub struct u64x2(pub u64, pub u64);\n \n #[experimental]\n #[simd]\n-pub struct f32x4(f32, f32, f32, f32);\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n #[experimental]\n #[simd]\n-pub struct f64x2(f64, f64);\n+pub struct f64x2(pub f64, pub f64);"}, {"sha": "53d2ac97b49fb746363e54cd1b523c8eb05b9c08", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -493,10 +493,10 @@ pub enum Expr_ {\n     ExprVstore(@Expr, ExprVstore),\n     // First expr is the place; second expr is the value.\n     ExprBox(@Expr, @Expr),\n-    ExprVec(Vec<@Expr> , Mutability),\n-    ExprCall(@Expr, Vec<@Expr> ),\n-    ExprMethodCall(Ident, Vec<P<Ty>> , Vec<@Expr> ),\n-    ExprTup(Vec<@Expr> ),\n+    ExprVec(Vec<@Expr>, Mutability),\n+    ExprCall(@Expr, Vec<@Expr>),\n+    ExprMethodCall(Ident, Vec<P<Ty>>, Vec<@Expr>),\n+    ExprTup(Vec<@Expr>),\n     ExprBinary(BinOp, @Expr, @Expr),\n     ExprUnary(UnOp, @Expr),\n     ExprLit(@Lit),\n@@ -508,14 +508,14 @@ pub enum Expr_ {\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name>\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(@Expr, Vec<Arm> ),\n+    ExprMatch(@Expr, Vec<Arm>),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),\n     ExprAssignOp(BinOp, @Expr, @Expr),\n-    ExprField(@Expr, Ident, Vec<P<Ty>> ),\n+    ExprField(@Expr, Ident, Vec<P<Ty>>),\n     ExprIndex(@Expr, @Expr),\n \n     /// Expression that looks like a \"name\". For example,"}, {"sha": "cf584ff62ac02670536b8bf793a18f88055b8a99", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -66,7 +66,7 @@ impl<'a> Iterator<PathElem> for LinkedPath<'a> {\n \n // HACK(eddyb) move this into libstd (value wrapper for slice::Items).\n #[deriving(Clone)]\n-pub struct Values<'a, T>(slice::Items<'a, T>);\n+pub struct Values<'a, T>(pub slice::Items<'a, T>);\n \n impl<'a, T: Copy> Iterator<T> for Values<'a, T> {\n     fn next(&mut self) -> Option<T> {"}, {"sha": "7cadce547659446734e0078bba547f8a4e4ce135", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -33,13 +33,13 @@ pub trait Pos {\n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n /// a lot of them.\n #[deriving(Clone, Eq, TotalEq, Hash, Ord, Show)]\n-pub struct BytePos(u32);\n+pub struct BytePos(pub u32);\n \n /// A character offset. Because of multibyte utf8 characters, a byte offset\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n #[deriving(Eq, Hash, Ord, Show)]\n-pub struct CharPos(uint);\n+pub struct CharPos(pub uint);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n // have been unsuccessful"}, {"sha": "c5dc3439f2f8d78ef407b820232c1637e64b9fc1", "filename": "src/test/auxiliary/issue-11508.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue-11508.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue-11508.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11508.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct Closed01<F>(F);\n+pub struct Closed01<F>(pub F);\n \n pub trait Bar { fn new() -> Self; }\n "}, {"sha": "a8a4c438e67343905d49322a963a57666cfdecf3", "filename": "src/test/auxiliary/issue-11529.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue-11529.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue-11529.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11529.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct A<'a>(&'a int);\n+pub struct A<'a>(pub &'a int);"}, {"sha": "e197e84442b10d23b7585f61d06ebfe2594ce2de", "filename": "src/test/auxiliary/issue-7899.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue-7899.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue-7899.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-7899.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct V2<T>(T, T);\n+pub struct V2<T>(pub T, pub T);"}, {"sha": "f0f1af2e3a3da9478255989cfede9ecbc0fc9ba1", "filename": "src/test/auxiliary/issue_10031_aux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue_10031_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue_10031_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_10031_aux.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct Wrap<A>(A);\n+pub struct Wrap<A>(pub A);"}, {"sha": "5f55476427fe2fd7bdfeed380210e33a26353f03", "filename": "src/test/auxiliary/issue_2472_b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2472_b.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-pub struct S(());\n+pub struct S(pub ());\n \n impl S {\n     pub fn foo(&self) { }"}, {"sha": "5afbf4492b30d778a172cc8e838ee892526ded77", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -161,15 +161,15 @@ pub enum Enum {\n }\n \n #[deprecated]\n-pub struct DeprecatedTupleStruct(int);\n+pub struct DeprecatedTupleStruct(pub int);\n #[experimental]\n-pub struct ExperimentalTupleStruct(int);\n+pub struct ExperimentalTupleStruct(pub int);\n #[unstable]\n-pub struct UnstableTupleStruct(int);\n-pub struct UnmarkedTupleStruct(int);\n+pub struct UnstableTupleStruct(pub int);\n+pub struct UnmarkedTupleStruct(pub int);\n #[stable]\n-pub struct StableTupleStruct(int);\n+pub struct StableTupleStruct(pub int);\n #[frozen]\n-pub struct FrozenTupleStruct(int);\n+pub struct FrozenTupleStruct(pub int);\n #[locked]\n-pub struct LockedTupleStruct(int);\n+pub struct LockedTupleStruct(pub int);"}, {"sha": "60c64842c71468d5af50412fdea491abdcd958b3", "filename": "src/test/auxiliary/newtype_struct_xc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fnewtype_struct_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fnewtype_struct_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnewtype_struct_xc.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -10,4 +10,4 @@\n \n #[crate_type=\"lib\"];\n \n-pub struct Au(int);\n+pub struct Au(pub int);"}, {"sha": "2fb9d9923cb76b6f50380b290485b0b5d1d77e69", "filename": "src/test/auxiliary/privacy-tuple-struct.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fprivacy-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fauxiliary%2Fprivacy-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprivacy-tuple-struct.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct A(());\n+pub struct B(int);\n+pub struct C(pub int, int);\n+pub struct D(pub int);"}, {"sha": "c057236265e94ad218c05fa6cac2671517e4a539", "filename": "src/test/compile-fail/privacy5.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2e457686b77a7eec906549b73feba314667235b/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy5.rs?ref=c2e457686b77a7eec906549b73feba314667235b", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:privacy-tuple-struct.rs\n+// ignore-fast\n+\n+extern crate other = \"privacy-tuple-struct\";\n+\n+mod a {\n+    pub struct A(());\n+    pub struct B(int);\n+    pub struct C(pub int, int);\n+    pub struct D(pub int);\n+\n+    fn test() {\n+        let a = A(());\n+        let b = B(2);\n+        let c = C(2, 3);\n+        let d = D(4);\n+\n+        let A(()) = a;\n+        let A(_) = a;\n+        match a { A(()) => {} }\n+        match a { A(_) => {} }\n+\n+        let B(_) = b;\n+        let B(_b) = b;\n+        match b { B(_) => {} }\n+        match b { B(_b) => {} }\n+        match b { B(1) => {} B(_) => {} }\n+\n+        let C(_, _) = c;\n+        let C(_a, _) = c;\n+        let C(_, _b) = c;\n+        let C(_a, _b) = c;\n+        match c { C(_, _) => {} }\n+        match c { C(_a, _) => {} }\n+        match c { C(_, _b) => {} }\n+        match c { C(_a, _b) => {} }\n+\n+        let D(_) = d;\n+        let D(_d) = d;\n+        match d { D(_) => {} }\n+        match d { D(_d) => {} }\n+        match d { D(1) => {} D(_) => {} }\n+\n+        let a2 = A;\n+        let b2 = B;\n+        let c2 = C;\n+        let d2 = D;\n+    }\n+}\n+\n+fn this_crate() {\n+    let a = a::A(()); //~ ERROR: cannot invoke tuple struct constructor\n+    let b = a::B(2); //~ ERROR: cannot invoke tuple struct constructor\n+    let c = a::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let d = a::D(4);\n+\n+    let a::A(()) = a; //~ ERROR: field #1 is private\n+    let a::A(_) = a;\n+    match a { a::A(()) => {} } //~ ERROR: field #1 is private\n+    match a { a::A(_) => {} }\n+\n+    let a::B(_) = b;\n+    let a::B(_b) = b; //~ ERROR: field #1 is private\n+    match b { a::B(_) => {} }\n+    match b { a::B(_b) => {} } //~ ERROR: field #1 is private\n+    match b { a::B(1) => {} a::B(_) => {} } //~ ERROR: field #1 is private\n+\n+    let a::C(_, _) = c;\n+    let a::C(_a, _) = c;\n+    let a::C(_, _b) = c; //~ ERROR: field #2 is private\n+    let a::C(_a, _b) = c; //~ ERROR: field #2 is private\n+    match c { a::C(_, _) => {} }\n+    match c { a::C(_a, _) => {} }\n+    match c { a::C(_, _b) => {} } //~ ERROR: field #2 is private\n+    match c { a::C(_a, _b) => {} } //~ ERROR: field #2 is private\n+\n+    let a::D(_) = d;\n+    let a::D(_d) = d;\n+    match d { a::D(_) => {} }\n+    match d { a::D(_d) => {} }\n+    match d { a::D(1) => {} a::D(_) => {} }\n+\n+    let a2 = a::A; //~ ERROR: cannot invoke tuple struct constructor\n+    let b2 = a::B; //~ ERROR: cannot invoke tuple struct constructor\n+    let c2 = a::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let d2 = a::D;\n+}\n+\n+fn xcrate() {\n+    let a = other::A(()); //~ ERROR: cannot invoke tuple struct constructor\n+    let b = other::B(2); //~ ERROR: cannot invoke tuple struct constructor\n+    let c = other::C(2, 3); //~ ERROR: cannot invoke tuple struct constructor\n+    let d = other::D(4);\n+\n+    let other::A(()) = a; //~ ERROR: field #1 is private\n+    let other::A(_) = a;\n+    match a { other::A(()) => {} } //~ ERROR: field #1 is private\n+    match a { other::A(_) => {} }\n+\n+    let other::B(_) = b;\n+    let other::B(_b) = b; //~ ERROR: field #1 is private\n+    match b { other::B(_) => {} }\n+    match b { other::B(_b) => {} } //~ ERROR: field #1 is private\n+    match b { other::B(1) => {} other::B(_) => {} } //~ ERROR: field #1 is private\n+\n+    let other::C(_, _) = c;\n+    let other::C(_a, _) = c;\n+    let other::C(_, _b) = c; //~ ERROR: field #2 is private\n+    let other::C(_a, _b) = c; //~ ERROR: field #2 is private\n+    match c { other::C(_, _) => {} }\n+    match c { other::C(_a, _) => {} }\n+    match c { other::C(_, _b) => {} } //~ ERROR: field #2 is private\n+    match c { other::C(_a, _b) => {} } //~ ERROR: field #2 is private\n+\n+    let other::D(_) = d;\n+    let other::D(_d) = d;\n+    match d { other::D(_) => {} }\n+    match d { other::D(_d) => {} }\n+    match d { other::D(1) => {} other::D(_) => {} }\n+\n+    let a2 = other::A; //~ ERROR: cannot invoke tuple struct constructor\n+    let b2 = other::B; //~ ERROR: cannot invoke tuple struct constructor\n+    let c2 = other::C; //~ ERROR: cannot invoke tuple struct constructor\n+    let d2 = other::D;\n+}\n+\n+fn main() {}"}]}