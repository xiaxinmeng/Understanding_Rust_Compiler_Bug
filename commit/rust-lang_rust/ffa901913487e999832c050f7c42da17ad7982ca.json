{"sha": "ffa901913487e999832c050f7c42da17ad7982ca", "node_id": "C_kwDOAAsO6NoAKGZmYTkwMTkxMzQ4N2U5OTk4MzJjMDUwZjdjNDJkYTE3YWQ3OTgyY2E", "commit": {"author": {"name": "Ayush Singh", "email": "ayushsingh1325@gmail.com", "date": "2023-03-08T19:19:41Z"}, "committer": {"name": "Ayush Singh", "email": "ayushsingh1325@gmail.com", "date": "2023-03-10T12:05:24Z"}, "message": "Move __thread_local_inner to sys\n\nMove __thread_local_inner macro in crate::thread::local to crate::sys.\nCurrently, the tidy check does not fail for `library/std/src/thread/local.rs` even though it contains platform specific code. This is beacause target_family did not exist at the time the tidy checks were written [1].\n\n[1]: https://github.com/rust-lang/rust/pull/105861#discussion_r1125841678\n\nSigned-off-by: Ayush Singh <ayushsingh1325@gmail.com>", "tree": {"sha": "5dd7a4be60838e41a39ffd1d415197e17c97706f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dd7a4be60838e41a39ffd1d415197e17c97706f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffa901913487e999832c050f7c42da17ad7982ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEPXedWmbgyJF/geU7Z/nHg7Wh49UFAmQLHQQACgkQZ/nHg7Wh\n49VDJRAAj9nAK5cIpfuTHPeW5adIN5xcxMwGh07EtVz+ndGzXa7QFnRw51maFTOy\nCxeInBpjq0kvg6Nbb8aQIaTY6RTIKIEwxfO8a1Gwo2Sbnt+SvrbGKGqG/bxR9b3g\nXb8RaoDZuYctuXX9KfcSfb8mkE0Li/fyZ4Rc8EQlHSJ0f8uJDfewJVY9f9+wAYho\nsT/NFAsEeocQ+UKsrJqqm3n5OCfO9VlujmLFA0Wxi7i+y75V9+TMtSILTi4LCOYD\nkrKIMozv+H6SUOAe/beWs96nTY4hXGs7iWMHx02qDR/pZzgh1MOvDpnMIl6DPJA/\n+Yp7vYrEgJ9H7EvFEJ6QjQA5sSsmMBVWjV2sWuQH85i8eGwrYtHD40aciyIKnvH5\nuzuhyhZ9T49G78HKU5TjYitq5yubc2zAYGgfyAWJGCOsT66e40SXQcBtfH8E+S6W\n7rEodOUgkwvUGs4j9rvi3tFMeAarndVeweLkaAZDGOZ/P+I+24xzPil2KhPE156R\nuWQfB4zZco9pdjGPhwAkiDRZAFJJsvAXtxOl2uBPda1Wiwt0ogkte/u/+0l2OObQ\nH5IwJ4auzo/JmG72XvN1B0+Eutrms+7Vxp+/2jdNXb5kyISTaGw8LSt9kw06O0t7\nJhmzqb6VizLUCFRz+a+fmF/y2xI7VD38siRREPMVvXnGcd/p8aw=\n=0zzW\n-----END PGP SIGNATURE-----", "payload": "tree 5dd7a4be60838e41a39ffd1d415197e17c97706f\nparent 104f4300cfddbd956e32820ef202a732f06ec848\nauthor Ayush Singh <ayushsingh1325@gmail.com> 1678303181 +0530\ncommitter Ayush Singh <ayushsingh1325@gmail.com> 1678449924 +0530\n\nMove __thread_local_inner to sys\n\nMove __thread_local_inner macro in crate::thread::local to crate::sys.\nCurrently, the tidy check does not fail for `library/std/src/thread/local.rs` even though it contains platform specific code. This is beacause target_family did not exist at the time the tidy checks were written [1].\n\n[1]: https://github.com/rust-lang/rust/pull/105861#discussion_r1125841678\n\nSigned-off-by: Ayush Singh <ayushsingh1325@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa901913487e999832c050f7c42da17ad7982ca", "html_url": "https://github.com/rust-lang/rust/commit/ffa901913487e999832c050f7c42da17ad7982ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffa901913487e999832c050f7c42da17ad7982ca/comments", "author": {"login": "Ayush1325", "id": 22546812, "node_id": "MDQ6VXNlcjIyNTQ2ODEy", "avatar_url": "https://avatars.githubusercontent.com/u/22546812?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ayush1325", "html_url": "https://github.com/Ayush1325", "followers_url": "https://api.github.com/users/Ayush1325/followers", "following_url": "https://api.github.com/users/Ayush1325/following{/other_user}", "gists_url": "https://api.github.com/users/Ayush1325/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ayush1325/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ayush1325/subscriptions", "organizations_url": "https://api.github.com/users/Ayush1325/orgs", "repos_url": "https://api.github.com/users/Ayush1325/repos", "events_url": "https://api.github.com/users/Ayush1325/events{/privacy}", "received_events_url": "https://api.github.com/users/Ayush1325/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ayush1325", "id": 22546812, "node_id": "MDQ6VXNlcjIyNTQ2ODEy", "avatar_url": "https://avatars.githubusercontent.com/u/22546812?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ayush1325", "html_url": "https://github.com/Ayush1325", "followers_url": "https://api.github.com/users/Ayush1325/followers", "following_url": "https://api.github.com/users/Ayush1325/following{/other_user}", "gists_url": "https://api.github.com/users/Ayush1325/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ayush1325/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ayush1325/subscriptions", "organizations_url": "https://api.github.com/users/Ayush1325/orgs", "repos_url": "https://api.github.com/users/Ayush1325/repos", "events_url": "https://api.github.com/users/Ayush1325/events{/privacy}", "received_events_url": "https://api.github.com/users/Ayush1325/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "104f4300cfddbd956e32820ef202a732f06ec848", "url": "https://api.github.com/repos/rust-lang/rust/commits/104f4300cfddbd956e32820ef202a732f06ec848", "html_url": "https://github.com/rust-lang/rust/commit/104f4300cfddbd956e32820ef202a732f06ec848"}], "stats": {"total": 388, "additions": 194, "deletions": 194}, "files": [{"sha": "5bbe39610cc3dfdc037bcbf815979270552effb7", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ffa901913487e999832c050f7c42da17ad7982ca/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa901913487e999832c050f7c42da17ad7982ca/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=ffa901913487e999832c050f7c42da17ad7982ca", "patch": "@@ -76,3 +76,197 @@ cfg_if::cfg_if! {\n         pub mod c;\n     }\n }\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+#[macro_export]\n+#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+            // wasm without atomics maps directly to `static mut`, and dtors\n+            // aren't implemented because thread dtors aren't really a thing\n+            // on wasm right now\n+            //\n+            // FIXME(#84224) this should come after the `target_thread_local`\n+            // block.\n+            #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n+            {\n+                static mut VAL: $t = INIT_EXPR;\n+                unsafe { $crate::option::Option::Some(&VAL) }\n+            }\n+\n+            // If the platform has support for `#[thread_local]`, use it.\n+            #[cfg(all(\n+                target_thread_local,\n+                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n+            ))]\n+            {\n+                #[thread_local]\n+                static mut VAL: $t = INIT_EXPR;\n+\n+                // If a dtor isn't needed we can do something \"very raw\" and\n+                // just get going.\n+                if !$crate::mem::needs_drop::<$t>() {\n+                    unsafe {\n+                        return $crate::option::Option::Some(&VAL)\n+                    }\n+                }\n+\n+                // 0 == dtor not registered\n+                // 1 == dtor registered, dtor not run\n+                // 2 == dtor registered and is running or has run\n+                #[thread_local]\n+                static mut STATE: $crate::primitive::u8 = 0;\n+\n+                unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n+                    let ptr = ptr as *mut $t;\n+\n+                    unsafe {\n+                        $crate::debug_assert_eq!(STATE, 1);\n+                        STATE = 2;\n+                        $crate::ptr::drop_in_place(ptr);\n+                    }\n+                }\n+\n+                unsafe {\n+                    match STATE {\n+                        // 0 == we haven't registered a destructor, so do\n+                        //   so now.\n+                        0 => {\n+                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n+                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n+                                destroy,\n+                            );\n+                            STATE = 1;\n+                            $crate::option::Option::Some(&VAL)\n+                        }\n+                        // 1 == the destructor is registered and the value\n+                        //   is valid, so return the pointer.\n+                        1 => $crate::option::Option::Some(&VAL),\n+                        // otherwise the destructor has already run, so we\n+                        // can't give access.\n+                        _ => $crate::option::Option::None,\n+                    }\n+                }\n+            }\n+\n+            // On platforms without `#[thread_local]` we fall back to the\n+            // same implementation as below for os thread locals.\n+            #[cfg(all(\n+                not(target_thread_local),\n+                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n+            ))]\n+            {\n+                #[inline]\n+                const fn __init() -> $t { INIT_EXPR }\n+                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                    $crate::thread::__OsLocalKeyInner::new();\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = _init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing initial value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n+                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n+                    $crate::thread::__StaticLocalKeyInner::new();\n+\n+                #[thread_local]\n+                #[cfg(all(\n+                    target_thread_local,\n+                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n+                ))]\n+                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n+                    $crate::thread::__FastLocalKeyInner::new();\n+\n+                #[cfg(all(\n+                    not(target_thread_local),\n+                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n+                ))]\n+                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                    $crate::thread::__OsLocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}"}, {"sha": "c82b5c2284f1f738ea773adbc1f6ceaae88f74ec", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ffa901913487e999832c050f7c42da17ad7982ca/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffa901913487e999832c050f7c42da17ad7982ca/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=ffa901913487e999832c050f7c42da17ad7982ca", "patch": "@@ -173,200 +173,6 @@ macro_rules! thread_local {\n     );\n }\n \n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n-#[macro_export]\n-#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n-#[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n-    // used to generate the `LocalKey` value for const-initialized thread locals\n-    (@key $t:ty, const $init:expr) => {{\n-        #[cfg_attr(not(windows), inline)] // see comments below\n-        #[deny(unsafe_op_in_unsafe_fn)]\n-        unsafe fn __getit(\n-            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-        ) -> $crate::option::Option<&'static $t> {\n-            const INIT_EXPR: $t = $init;\n-\n-            // wasm without atomics maps directly to `static mut`, and dtors\n-            // aren't implemented because thread dtors aren't really a thing\n-            // on wasm right now\n-            //\n-            // FIXME(#84224) this should come after the `target_thread_local`\n-            // block.\n-            #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-            {\n-                static mut VAL: $t = INIT_EXPR;\n-                unsafe { $crate::option::Option::Some(&VAL) }\n-            }\n-\n-            // If the platform has support for `#[thread_local]`, use it.\n-            #[cfg(all(\n-                target_thread_local,\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[thread_local]\n-                static mut VAL: $t = INIT_EXPR;\n-\n-                // If a dtor isn't needed we can do something \"very raw\" and\n-                // just get going.\n-                if !$crate::mem::needs_drop::<$t>() {\n-                    unsafe {\n-                        return $crate::option::Option::Some(&VAL)\n-                    }\n-                }\n-\n-                // 0 == dtor not registered\n-                // 1 == dtor registered, dtor not run\n-                // 2 == dtor registered and is running or has run\n-                #[thread_local]\n-                static mut STATE: $crate::primitive::u8 = 0;\n-\n-                unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n-                    let ptr = ptr as *mut $t;\n-\n-                    unsafe {\n-                        $crate::debug_assert_eq!(STATE, 1);\n-                        STATE = 2;\n-                        $crate::ptr::drop_in_place(ptr);\n-                    }\n-                }\n-\n-                unsafe {\n-                    match STATE {\n-                        // 0 == we haven't registered a destructor, so do\n-                        //   so now.\n-                        0 => {\n-                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n-                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n-                                destroy,\n-                            );\n-                            STATE = 1;\n-                            $crate::option::Option::Some(&VAL)\n-                        }\n-                        // 1 == the destructor is registered and the value\n-                        //   is valid, so return the pointer.\n-                        1 => $crate::option::Option::Some(&VAL),\n-                        // otherwise the destructor has already run, so we\n-                        // can't give access.\n-                        _ => $crate::option::Option::None,\n-                    }\n-                }\n-            }\n-\n-            // On platforms without `#[thread_local]` we fall back to the\n-            // same implementation as below for os thread locals.\n-            #[cfg(all(\n-                not(target_thread_local),\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[inline]\n-                const fn __init() -> $t { INIT_EXPR }\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = _init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing initial value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-        }\n-\n-        unsafe {\n-            $crate::thread::LocalKey::new(__getit)\n-        }\n-    }};\n-\n-    // used to generate the `LocalKey` value for `thread_local!`\n-    (@key $t:ty, $init:expr) => {\n-        {\n-            #[inline]\n-            fn __init() -> $t { $init }\n-\n-            // When reading this function you might ask \"why is this inlined\n-            // everywhere other than Windows?\", and that's a very reasonable\n-            // question to ask. The short story is that it segfaults rustc if\n-            // this function is inlined. The longer story is that Windows looks\n-            // to not support `extern` references to thread locals across DLL\n-            // boundaries. This appears to at least not be supported in the ABI\n-            // that LLVM implements.\n-            //\n-            // Because of this we never inline on Windows, but we do inline on\n-            // other platforms (where external references to thread locals\n-            // across DLLs are supported). A better fix for this would be to\n-            // inline this function on Windows, but only for \"statically linked\"\n-            // components. For example if two separately compiled rlibs end up\n-            // getting linked into a DLL then it's fine to inline this function\n-            // across that boundary. It's only not fine to inline this function\n-            // across a DLL boundary. Unfortunately rustc doesn't currently\n-            // have this sort of logic available in an attribute, and it's not\n-            // clear that rustc is even equipped to answer this (it's more of a\n-            // Cargo question kinda). This means that, unfortunately, Windows\n-            // gets the pessimistic path for now where it's never inlined.\n-            //\n-            // The issue of \"should enable on Windows sometimes\" is #84933\n-            #[cfg_attr(not(windows), inline)]\n-            unsafe fn __getit(\n-                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-            ) -> $crate::option::Option<&'static $t> {\n-                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n-                    $crate::thread::__StaticLocalKeyInner::new();\n-\n-                #[thread_local]\n-                #[cfg(all(\n-                    target_thread_local,\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n-                    $crate::thread::__FastLocalKeyInner::new();\n-\n-                #[cfg(all(\n-                    not(target_thread_local),\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-\n-                // FIXME: remove the #[allow(...)] marker when macros don't\n-                // raise warning for missing/extraneous unsafe blocks anymore.\n-                // See https://github.com/rust-lang/rust/issues/74838.\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing default value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-\n-            unsafe {\n-                $crate::thread::LocalKey::new(__getit)\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n-        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n #[non_exhaustive]"}]}