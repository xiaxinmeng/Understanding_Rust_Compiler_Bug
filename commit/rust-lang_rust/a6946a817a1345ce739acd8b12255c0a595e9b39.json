{"sha": "a6946a817a1345ce739acd8b12255c0a595e9b39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OTQ2YTgxN2ExMzQ1Y2U3MzlhY2Q4YjEyMjU1YzBhNTk1ZTliMzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-13T15:37:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-13T15:37:15Z"}, "message": "Auto merge of #63420 - spastorino:place2_5, r=oli-obk\n\n[Place 2.0] Convert Place's projection to a boxed slice\n\nThis is still work in progress, it's not compiling right now I need to review a bit more to see what's going on but wanted to open the PR to start discussing it.\n\nr? @oli-obk", "tree": {"sha": "08b5a7f009903637c3baa44ada87eb0b662eff3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08b5a7f009903637c3baa44ada87eb0b662eff3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6946a817a1345ce739acd8b12255c0a595e9b39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6946a817a1345ce739acd8b12255c0a595e9b39", "html_url": "https://github.com/rust-lang/rust/commit/a6946a817a1345ce739acd8b12255c0a595e9b39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6946a817a1345ce739acd8b12255c0a595e9b39/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3287a65fc05028dce3b521765f4643384ebc4346", "url": "https://api.github.com/repos/rust-lang/rust/commits/3287a65fc05028dce3b521765f4643384ebc4346", "html_url": "https://github.com/rust-lang/rust/commit/3287a65fc05028dce3b521765f4643384ebc4346"}, {"sha": "28db2c9e953f4e1e0f1511193c90b84f4d170d1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/28db2c9e953f4e1e0f1511193c90b84f4d170d1a", "html_url": "https://github.com/rust-lang/rust/commit/28db2c9e953f4e1e0f1511193c90b84f4d170d1a"}], "stats": {"total": 3366, "additions": 1590, "deletions": 1776}, "files": [{"sha": "0ebc70750a6bba18aaffb2f1372e03ca7c723da0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 91, "deletions": 217, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -32,7 +32,6 @@ use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n use std::vec::IntoIter;\n@@ -1548,7 +1547,7 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Statement<'_>, 56);\n+static_assert_size!(Statement<'_>, 32);\n \n impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n@@ -1569,7 +1568,7 @@ impl Statement<'_> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n-    Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n+    Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n     /// This represents all the reading that a pattern match may do\n     /// (e.g., inspecting constants and discriminant values), and the\n@@ -1578,10 +1577,10 @@ pub enum StatementKind<'tcx> {\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n-    FakeRead(FakeReadCause, Place<'tcx>),\n+    FakeRead(FakeReadCause, Box<Place<'tcx>>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant { place: Place<'tcx>, variant_index: VariantIdx },\n+    SetDiscriminant { place: Box<Place<'tcx>>, variant_index: VariantIdx },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1598,7 +1597,7 @@ pub enum StatementKind<'tcx> {\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n     /// for more details.\n-    Retag(RetagKind, Place<'tcx>),\n+    Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n@@ -1612,7 +1611,7 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection>),\n+    AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1676,7 +1675,7 @@ impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n-            Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n+            Assign(box(ref place, ref rv)) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n             Retag(ref kind, ref place) => write!(\n                 fmt,\n@@ -1697,7 +1696,7 @@ impl Debug for Statement<'_> {\n             InlineAsm(ref asm) => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs)\n             }\n-            AscribeUserType(ref place, ref variance, ref c_ty) => {\n+            AscribeUserType(box(ref place, ref c_ty), ref variance) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n             Nop => write!(fmt, \"nop\"),\n@@ -1717,7 +1716,7 @@ pub struct Place<'tcx> {\n     pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: Option<Box<Projection<'tcx>>>,\n+    pub projection: Box<[PlaceElem<'tcx>]>,\n }\n \n #[derive(\n@@ -1760,15 +1759,6 @@ impl_stable_hash_for!(struct Static<'tcx> {\n     def_id\n });\n \n-/// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n-pub struct Projection<'tcx> {\n-    pub base: Option<Box<Projection<'tcx>>>,\n-    pub elem: PlaceElem<'tcx>,\n-}\n-\n #[derive(\n     Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n@@ -1850,14 +1840,22 @@ newtype_index! {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n     pub base: &'a PlaceBase<'tcx>,\n-    pub projection: &'a Option<Box<Projection<'tcx>>>,\n+    pub projection: &'a [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub const RETURN_PLACE: Place<'tcx> = Place {\n-        base: PlaceBase::Local(RETURN_PLACE),\n-        projection: None,\n-    };\n+    // FIXME change this back to a const when projection is a shared slice.\n+    //\n+    // pub const RETURN_PLACE: Place<'tcx> = Place {\n+    //     base: PlaceBase::Local(RETURN_PLACE),\n+    //     projection: &[],\n+    // };\n+    pub fn return_place() -> Place<'tcx> {\n+        Place {\n+            base: PlaceBase::Local(RETURN_PLACE),\n+            projection: Box::new([]),\n+        }\n+    }\n \n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n@@ -1883,9 +1881,13 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        // FIXME(spastorino): revisit this again once projection is not a Box<[T]> anymore\n+        let mut projection = self.projection.into_vec();\n+        projection.push(elem);\n+\n         Place {\n             base: self.base,\n-            projection: Some(Box::new(Projection { base: self.projection, elem })),\n+            projection: projection.into_boxed_slice(),\n         }\n     }\n \n@@ -1894,7 +1896,7 @@ impl<'tcx> Place<'tcx> {\n     /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n     /// same region of memory as its base.\n     pub fn is_indirect(&self) -> bool {\n-        self.iterate(|_, mut projections| projections.any(|proj| proj.elem.is_indirect()))\n+        self.projection.iter().any(|elem| elem.is_indirect())\n     }\n \n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n@@ -1905,61 +1907,16 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             } |\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: box [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n \n-    /// Recursively \"iterates\" over place components, generating a `PlaceBase` and\n-    /// `Projections` list and invoking `op` with a `ProjectionsIter`.\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(&self.base, &self.projection, op)\n-    }\n-\n-    pub fn iterate_over<R>(\n-        place_base: &PlaceBase<'tcx>,\n-        place_projection: &Option<Box<Projection<'tcx>>>,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        fn iterate_over2<'tcx, R>(\n-            place_base: &PlaceBase<'tcx>,\n-            place_projection: &Option<Box<Projection<'tcx>>>,\n-            next: &Projections<'_, 'tcx>,\n-            op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-        ) -> R {\n-            match place_projection {\n-                None => {\n-                    op(place_base, next.iter())\n-                }\n-\n-                Some(interior) => {\n-                    iterate_over2(\n-                        place_base,\n-                        &interior.base,\n-                        &Projections::List {\n-                            projection: interior,\n-                            next,\n-                        },\n-                        op,\n-                    )\n-                }\n-            }\n-        }\n-\n-        iterate_over2(place_base, place_projection, &Projections::Empty, op)\n-    }\n-\n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n         PlaceRef {\n             base: &self.base,\n@@ -1972,7 +1929,7 @@ impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n         Place {\n             base: local.into(),\n-            projection: None,\n+            projection: Box::new([]),\n         }\n     }\n }\n@@ -1984,13 +1941,6 @@ impl From<Local> for PlaceBase<'_> {\n }\n \n impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(self.base, self.projection, op)\n-    }\n-\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //\n@@ -1999,143 +1949,71 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n         match self {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } |\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n }\n \n-/// A linked list of projections running up the stack; begins with the\n-/// innermost projection and extends to the outermost (e.g., `a.b.c`\n-/// would have the place `b` with a \"next\" pointer to `b.c`).\n-/// Created by `Place::iterate`.\n-///\n-/// N.B., this particular impl strategy is not the most obvious. It was\n-/// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-pub enum Projections<'p, 'tcx> {\n-    Empty,\n-\n-    List { projection: &'p Projection<'tcx>, next: &'p Projections<'p, 'tcx> },\n-}\n-\n-impl<'p, 'tcx> Projections<'p, 'tcx> {\n-    fn iter(&self) -> ProjectionsIter<'_, 'tcx> {\n-        ProjectionsIter { value: self }\n-    }\n-}\n-\n-impl<'p, 'tcx> IntoIterator for &'p Projections<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-    type IntoIter = ProjectionsIter<'p, 'tcx>;\n-\n-    /// Converts a list of `Projection` components into an iterator;\n-    /// this iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermost\" projection and then with each\n-    /// projection therefrom. So given a place like `a.b.c` it would\n-    /// yield up:\n-    ///\n-    /// ```notrust\n-    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n-    /// ```\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-/// Iterator over components; see `Projections::iter` for more\n-/// information.\n-///\n-/// N.B., this is not a *true* Rust iterator -- the code above just\n-/// manually invokes `next`. This is because we (sometimes) want to\n-/// keep executing even after `None` has been returned.\n-pub struct ProjectionsIter<'p, 'tcx> {\n-    pub value: &'p Projections<'p, 'tcx>,\n-}\n-\n-impl<'p, 'tcx> Iterator for ProjectionsIter<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let &Projections::List { projection, next } = self.value {\n-            self.value = next;\n-            Some(projection)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'p, 'tcx> FusedIterator for ProjectionsIter<'p, 'tcx> {}\n-\n impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        self.iterate(|_place_base, place_projections| {\n-            // FIXME: remove this collect once we have migrated to slices\n-            let projs_vec: Vec<_> = place_projections.collect();\n-            for projection in projs_vec.iter().rev() {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n-                        write!(fmt, \"(\").unwrap();\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \"(*\").unwrap();\n-                    }\n-                    ProjectionElem::Index(_)\n-                    | ProjectionElem::ConstantIndex { .. }\n-                    | ProjectionElem::Subslice { .. } => {}\n+        for elem in self.projection.iter().rev() {\n+            match elem {\n+                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n+                    write!(fmt, \"(\").unwrap();\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \"(*\").unwrap();\n                 }\n+                ProjectionElem::Index(_)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {}\n             }\n-        });\n+        }\n \n-        self.iterate(|place_base, place_projections| {\n-            write!(fmt, \"{:?}\", place_base)?;\n+        write!(fmt, \"{:?}\", self.base)?;\n \n-            for projection in place_projections {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(Some(name), _index) => {\n-                        write!(fmt, \" as {})\", name)?;\n-                    }\n-                    ProjectionElem::Downcast(None, index) => {\n-                        write!(fmt, \" as variant#{:?})\", index)?;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \")\")?;\n-                    }\n-                    ProjectionElem::Field(field, ty) => {\n-                        write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n-                    }\n-                    ProjectionElem::Index(ref index) => {\n-                        write!(fmt, \"[{:?}]\", index)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n-                        write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n-                        write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if to == 0 => {\n-                        write!(fmt, \"[{:?}:]\", from)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if from == 0 => {\n-                        write!(fmt, \"[:-{:?}]\", to)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } => {\n-                        write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n-                    }\n+        for elem in self.projection.iter() {\n+            match elem {\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \" as {})\", name)?;\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \" as variant#{:?})\", index)?;\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \")\")?;\n+                }\n+                ProjectionElem::Field(field, ty) => {\n+                    write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n+                }\n+                ProjectionElem::Index(ref index) => {\n+                    write!(fmt, \"[{:?}]\", index)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n+                    write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n+                    write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *to == 0 => {\n+                    write!(fmt, \"[{:?}:]\", from)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *from == 0 => {\n+                    write!(fmt, \"[:-{:?}]\", to)?;\n+                }\n+                ProjectionElem::Subslice { from, to } => {\n+                    write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n                 }\n             }\n+        }\n \n-            Ok(())\n-        })\n+        Ok(())\n     }\n }\n \n@@ -3120,14 +2998,14 @@ BraceStructTypeFoldableImpl! {\n \n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for StatementKind<'tcx> {\n-        (StatementKind::Assign)(a, b),\n+        (StatementKind::Assign)(a),\n         (StatementKind::FakeRead)(cause, place),\n         (StatementKind::SetDiscriminant) { place, variant_index },\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm)(a),\n         (StatementKind::Retag)(kind, place),\n-        (StatementKind::AscribeUserType)(a, v, b),\n+        (StatementKind::AscribeUserType)(a, v),\n         (StatementKind::Nop),\n     }\n }\n@@ -3409,30 +3287,26 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n-        let base = self.base.fold_with(folder);\n-        let elem = match self.elem {\n+        match self {\n             Deref => Deref,\n-            Field(f, ref ty) => Field(f, ty.fold_with(folder)),\n-            Index(ref v) => Index(v.fold_with(folder)),\n-            ref elem => elem.clone(),\n-        };\n-\n-        Projection { base, elem }\n+            Field(f, ty) => Field(*f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            elem => elem.clone(),\n+        }\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use crate::mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor)\n-            || match self.elem {\n-                Field(_, ref ty) => ty.visit_with(visitor),\n-                Index(ref v) => v.visit_with(visitor),\n-                _ => false,\n-            }\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n     }\n }\n "}, {"sha": "d7768098397433176a95c4450c872033b601dd98", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -121,21 +121,16 @@ BraceStructTypeFoldableImpl! {\n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n         base: &PlaceBase<'tcx>,\n-        projection: &Option<Box<Projection<'tcx>>>,\n+        projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>\n     ) -> PlaceTy<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n-        Place::iterate_over(base, projection, |place_base, place_projections| {\n-            let mut place_ty = place_base.ty(local_decls);\n-\n-            for proj in place_projections {\n-                place_ty = place_ty.projection_ty(tcx, &proj.elem);\n-            }\n-\n-            place_ty\n-        })\n+        projection.iter().fold(\n+            base.ty(local_decls),\n+            |place_ty, elem| place_ty.projection_ty(tcx, elem)\n+        )\n     }\n \n     pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>"}, {"sha": "1e3b9eb29c79d0f07198409ccc43ee32f66eb1c3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -152,18 +152,18 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_place_base(place_base, context, location);\n+                self.super_place_base(base, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                place: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place_base, place, context, location);\n+                self.super_projection(base, projection, context, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -344,7 +344,9 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_source_info(source_info);\n                 match kind {\n-                    StatementKind::Assign(place, rvalue) => {\n+                    StatementKind::Assign(\n+                        box(ref $($mutability)? place, ref $($mutability)? rvalue)\n+                    ) => {\n                         self.visit_assign(place, rvalue, location);\n                     }\n                     StatementKind::FakeRead(_, place) => {\n@@ -391,7 +393,10 @@ macro_rules! make_mir_visitor {\n                     StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n+                    StatementKind::AscribeUserType(\n+                        box(ref $($mutability)? place, ref $($mutability)? user_ty),\n+                        variance\n+                    ) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -685,7 +690,7 @@ macro_rules! make_mir_visitor {\n                             location: Location) {\n                 let mut context = context;\n \n-                if place.projection.is_some() {\n+                if !place.projection.is_empty() {\n                     context = if context.is_mutating_use() {\n                         PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                     } else {\n@@ -695,9 +700,10 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_place_base(& $($mutability)? place.base, context, location);\n \n-                if let Some(box proj) = & $($mutability)? place.projection {\n-                    self.visit_projection(& $($mutability)? place.base, proj, context, location);\n-                }\n+                self.visit_projection(& $($mutability)? place.base,\n+                                      & $($mutability)? place.projection,\n+                                      context,\n+                                      location);\n             }\n \n             fn super_place_base(&mut self,\n@@ -715,31 +721,31 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                proj: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                if let Some(box proj_base) = & $($mutability)? proj.base {\n-                    self.visit_projection(place_base, proj_base, context, location);\n-                }\n+                if let [proj_base @ .., elem] = projection {\n+                    self.visit_projection(base, proj_base, context, location);\n \n-                match & $($mutability)? proj.elem {\n-                    ProjectionElem::Field(_field, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n-                    }\n-                    ProjectionElem::Index(local) => {\n-                        self.visit_local(\n-                            local,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                            location\n-                        );\n-                    }\n-                    ProjectionElem::Deref |\n-                    ProjectionElem::Subslice { from: _, to: _ } |\n-                    ProjectionElem::ConstantIndex { offset: _,\n-                                                    min_length: _,\n-                                                    from_end: _ } |\n-                    ProjectionElem::Downcast(_, _) => {\n+                    match elem {\n+                        ProjectionElem::Field(_field, ty) => {\n+                            self.visit_ty(ty, TyContext::Location(location));\n+                        }\n+                        ProjectionElem::Index(local) => {\n+                            self.visit_local(\n+                                local,\n+                                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                                location\n+                            );\n+                        }\n+                        ProjectionElem::Deref |\n+                        ProjectionElem::Subslice { from: _, to: _ } |\n+                        ProjectionElem::ConstantIndex { offset: _,\n+                                                        min_length: _,\n+                                                        from_end: _ } |\n+                        ProjectionElem::Downcast(_, _) => {\n+                        }\n                     }\n                 }\n             }"}, {"sha": "1708d7235b45b1d56badb6b3d7288d32b2bca6f4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -4,6 +4,7 @@\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n+#![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]"}, {"sha": "d192f2ffb6fba8bddd54076d55752fb9f30e2998", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -105,7 +105,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n     ) {\n         let cx = self.fx.cx;\n \n-        if let Some(proj) = place_ref.projection {\n+        if let [proj_base @ .., elem] = place_ref.projection {\n             // Allow uses of projections that are ZSTs or from scalar fields.\n             let is_consume = match context {\n                 PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) |\n@@ -114,12 +114,12 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             };\n             if is_consume {\n                 let base_ty =\n-                    mir::Place::ty_from(place_ref.base, &proj.base, self.fx.mir, cx.tcx());\n+                    mir::Place::ty_from(place_ref.base, proj_base, self.fx.mir, cx.tcx());\n                 let base_ty = self.fx.monomorphize(&base_ty);\n \n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty\n-                    .projection_ty(cx.tcx(), &proj.elem)\n+                    .projection_ty(cx.tcx(), elem)\n                     .ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n                 let span = if let mir::PlaceBase::Local(index) = place_ref.base {\n@@ -131,7 +131,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     return;\n                 }\n \n-                if let mir::ProjectionElem::Field(..) = proj.elem {\n+                if let mir::ProjectionElem::Field(..) = elem {\n                     let layout = cx.spanned_layout_of(base_ty.ty, span);\n                     if cx.is_backend_immediate(layout) || cx.is_backend_scalar_pair(layout) {\n                         // Recurse with the same context, instead of `Projection`,\n@@ -140,7 +140,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                         self.process_place(\n                             &mir::PlaceRef {\n                                 base: place_ref.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             context,\n                             location,\n@@ -151,11 +151,11 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n             }\n \n             // A deref projection only reads the pointer, never needs the place.\n-            if let mir::ProjectionElem::Deref = proj.elem {\n+            if let mir::ProjectionElem::Deref = elem {\n                 self.process_place(\n                     &mir::PlaceRef {\n                         base: place_ref.base,\n-                        projection: &proj.base,\n+                        projection: proj_base,\n                     },\n                     PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n                     location\n@@ -168,7 +168,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         // visit_place API\n         let mut context = context;\n \n-        if place_ref.projection.is_some() {\n+        if !place_ref.projection.is_empty() {\n             context = if context.is_mutating_use() {\n                 PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             } else {\n@@ -177,10 +177,7 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n         }\n \n         self.visit_place_base(place_ref.base, context, location);\n-\n-        if let Some(box proj) = place_ref.projection {\n-            self.visit_projection(place_ref.base, proj, context, location);\n-        }\n+        self.visit_projection(place_ref.base, place_ref.projection, context, location);\n     }\n \n }\n@@ -196,7 +193,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n \n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *place {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;"}, {"sha": "915006938fe566770ed312c477d42469cc70099a", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n-                    self.codegen_consume(&mut bx, &mir::Place::RETURN_PLACE.as_ref());\n+                    self.codegen_consume(&mut bx, &mir::Place::return_place().as_ref());\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -612,7 +612,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     ty,\n                                     def_id: _,\n                                 }),\n-                                projection: None,\n+                                projection: box [],\n                             }\n                         ) |\n                         mir::Operand::Move(\n@@ -622,7 +622,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     ty,\n                                     def_id: _,\n                                 }),\n-                                projection: None,\n+                                projection: box [],\n                             }\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n@@ -1105,7 +1105,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n         let dest = if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n@@ -1166,7 +1166,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) {\n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),"}, {"sha": "58a13d685ddf97e972f10a2f0c42e4bb8f2cd512", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -384,47 +384,45 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        place_ref.iterate(|place_base, place_projection| {\n-            if let mir::PlaceBase::Local(index) = place_base {\n-                match self.locals[*index] {\n-                    LocalRef::Operand(Some(mut o)) => {\n-                        // Moves out of scalar and scalar pair fields are trivial.\n-                        for proj in place_projection {\n-                            match proj.elem {\n-                                mir::ProjectionElem::Field(ref f, _) => {\n-                                    o = o.extract_field(bx, f.index());\n-                                }\n-                                mir::ProjectionElem::Index(_) |\n-                                mir::ProjectionElem::ConstantIndex { .. } => {\n-                                    // ZSTs don't require any actual memory access.\n-                                    // FIXME(eddyb) deduplicate this with the identical\n-                                    // checks in `codegen_consume` and `extract_field`.\n-                                    let elem = o.layout.field(bx.cx(), 0);\n-                                    if elem.is_zst() {\n-                                        o = OperandRef::new_zst(bx, elem);\n-                                    } else {\n-                                        return None;\n-                                    }\n+        if let mir::PlaceBase::Local(index) = place_ref.base {\n+            match self.locals[*index] {\n+                LocalRef::Operand(Some(mut o)) => {\n+                    // Moves out of scalar and scalar pair fields are trivial.\n+                    for elem in place_ref.projection.iter() {\n+                        match elem {\n+                            mir::ProjectionElem::Field(ref f, _) => {\n+                                o = o.extract_field(bx, f.index());\n+                            }\n+                            mir::ProjectionElem::Index(_) |\n+                            mir::ProjectionElem::ConstantIndex { .. } => {\n+                                // ZSTs don't require any actual memory access.\n+                                // FIXME(eddyb) deduplicate this with the identical\n+                                // checks in `codegen_consume` and `extract_field`.\n+                                let elem = o.layout.field(bx.cx(), 0);\n+                                if elem.is_zst() {\n+                                    o = OperandRef::new_zst(bx, elem);\n+                                } else {\n+                                    return None;\n                                 }\n-                                _ => return None,\n                             }\n+                            _ => return None,\n                         }\n-\n-                        Some(o)\n-                    }\n-                    LocalRef::Operand(None) => {\n-                        bug!(\"use of {:?} before def\", place_ref);\n-                    }\n-                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                        // watch out for locals that do not have an\n-                        // alloca; they are handled somewhat differently\n-                        None\n                     }\n+\n+                    Some(o)\n+                }\n+                LocalRef::Operand(None) => {\n+                    bug!(\"use of {:?} before def\", place_ref);\n+                }\n+                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                    // watch out for locals that do not have an\n+                    // alloca; they are handled somewhat differently\n+                    None\n                 }\n-            } else {\n-                None\n             }\n-        })\n+        } else {\n+            None\n+        }\n     }\n \n     pub fn codegen_consume("}, {"sha": "ef9fc36b0f173425aebcda1d1976b136ede48bee", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let result = match &place_ref {\n             mir::PlaceRef {\n                 base: mir::PlaceBase::Local(index),\n-                projection: None,\n+                projection: [],\n             } => {\n                 match self.locals[*index] {\n                     LocalRef::Place(place) => {\n@@ -469,7 +469,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     kind: mir::StaticKind::Promoted(promoted, substs),\n                     def_id,\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let instance = Instance::new(*def_id, self.monomorphize(substs));\n@@ -504,7 +504,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     kind: mir::StaticKind::Static,\n                     def_id,\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n@@ -514,10 +514,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             },\n             mir::PlaceRef {\n                 base,\n-                projection: Some(box mir::Projection {\n-                    base: proj_base,\n-                    elem: mir::ProjectionElem::Deref,\n-                }),\n+                projection: [proj_base @ .., mir::ProjectionElem::Deref],\n             } => {\n                 // Load the pointer from its location.\n                 self.codegen_consume(bx, &mir::PlaceRef {\n@@ -527,22 +524,22 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n             mir::PlaceRef {\n                 base,\n-                projection: Some(projection),\n+                projection: [proj_base @ .., elem],\n             } => {\n                 // FIXME turn this recursion into iteration\n                 let cg_base = self.codegen_place(bx, &mir::PlaceRef {\n                     base,\n-                    projection: &projection.base,\n+                    projection: proj_base,\n                 });\n \n-                match projection.elem {\n+                match elem {\n                     mir::ProjectionElem::Deref => bug!(),\n                     mir::ProjectionElem::Field(ref field, _) => {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n                         let index = &mir::Operand::Copy(\n-                            mir::Place::from(index)\n+                            mir::Place::from(*index)\n                         );\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n@@ -551,27 +548,27 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(*offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = bx.cx().const_usize(offset as u64);\n+                        let lloffset = bx.cx().const_usize(*offset as u64);\n                         let lllen = cg_base.len(bx.cx());\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            bx.cx().const_usize(from as u64));\n+                            bx.cx().const_usize(*from as u64));\n                         let projected_ty = PlaceTy::from_ty(cg_base.layout.ty)\n-                            .projection_ty(tcx, &projection.elem).ty;\n+                            .projection_ty(tcx, elem).ty;\n                         subslice.layout = bx.cx().layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                bx.cx().const_usize((from as u64) + (to as u64))));\n+                                bx.cx().const_usize((*from as u64) + (*to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new\n@@ -582,7 +579,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         subslice\n                     }\n                     mir::ProjectionElem::Downcast(_, v) => {\n-                        cg_base.project_downcast(bx, v)\n+                        cg_base.project_downcast(bx, *v)\n                     }\n                 }\n             }"}, {"sha": "0a932bc3e157486ce948e01f31a18488e8b1a34f", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -522,7 +522,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // because codegen_place() panics if Local is operand.\n         if let mir::Place {\n             base: mir::PlaceBase::Local(index),\n-            projection: None,\n+            projection: box [],\n         } = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {"}, {"sha": "dab7dfc04175110b57b369126d2817c1d9bb34fe", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -16,12 +16,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n-            mir::StatementKind::Assign(ref place, ref rvalue) => {\n+            mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n                 if let mir::Place {\n                     base: mir::PlaceBase::Local(index),\n-                    projection: None,\n-                } = *place {\n-                    match self.locals[index] {\n+                    projection: box [],\n+                } = place {\n+                    match self.locals[*index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n@@ -30,7 +30,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         LocalRef::Operand(None) => {\n                             let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            if let Some(name) = self.mir.local_decls[index].name {\n+                            if let Some(name) = self.mir.local_decls[*index].name {\n                                 match operand.val {\n                                     OperandValue::Ref(x, ..) |\n                                     OperandValue::Immediate(x) => {\n@@ -44,7 +44,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     }\n                                 }\n                             }\n-                            self.locals[index] = LocalRef::Operand(Some(operand));\n+                            self.locals[*index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {\n@@ -64,7 +64,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     self.codegen_rvalue(bx, cg_dest, rvalue)\n                 }\n             }\n-            mir::StatementKind::SetDiscriminant{ref place, variant_index} => {\n+            mir::StatementKind::SetDiscriminant{box ref place, variant_index} => {\n                 self.codegen_place(&mut bx, &place.as_ref())\n                     .codegen_set_discr(&mut bx, variant_index);\n                 bx"}, {"sha": "db19cbc3175f8c60be5c0edbcdd637525134cc49", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -317,7 +317,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         // so extract `temp`.\n         let temp = if let &mir::Place {\n             base: mir::PlaceBase::Local(temp),\n-            projection: None,\n+            projection: box [],\n         } = assigned_place {\n             temp\n         } else {"}, {"sha": "4b4516d6bf290ea206ab41a1810f5d7c569d8d59", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -2,8 +2,8 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory, Local,\n-    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, Projection, PlaceRef,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n+    LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, PlaceRef, ProjectionElem, Rvalue,\n+    Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -244,7 +244,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 let span = if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = place {\n                     let decl = &self.body.local_decls[*local];\n                     Some(decl.source_info.span)\n@@ -614,17 +614,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = first_borrowed_place;\n \n-                let mut current = projection;\n+                for (i, elem) in projection.iter().enumerate().rev() {\n+                    let proj_base = &projection[..i];\n \n-                while let Some(box Projection { base: base_proj, elem }) = current {\n                     match elem {\n-                        ProjectionElem::Field(field, _) if union_ty(base, base_proj).is_some() => {\n+                        ProjectionElem::Field(field, _) if union_ty(base, proj_base).is_some() => {\n                             return Some((PlaceRef {\n                                 base: base,\n-                                projection: base_proj,\n+                                projection: proj_base,\n                             }, field));\n                         },\n-                        _ => current = base_proj,\n+                        _ => {},\n                     }\n                 }\n                 None\n@@ -637,9 +637,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = second_borrowed_place;\n \n-                let mut current = projection;\n+                for (i, elem) in projection.iter().enumerate().rev() {\n+                    let proj_base = &projection[..i];\n \n-                while let Some(box Projection { base: proj_base, elem }) = current {\n                     if let ProjectionElem::Field(field, _) = elem {\n                         if let Some(union_ty) = union_ty(base, proj_base) {\n                             if field != target_field\n@@ -660,8 +660,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                         }\n                     }\n-\n-                    current = proj_base;\n                 }\n                 None\n             })\n@@ -707,7 +705,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.var_or_use();\n \n-        assert!(root_place.projection.is_none());\n+        assert!(root_place.projection.is_empty());\n         let proper_span = match root_place.base {\n             PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n             _ => drop_span,\n@@ -716,7 +714,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if self.access_place_error_reported\n             .contains(&(Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.clone(),\n+                projection: root_place.projection.to_vec().into_boxed_slice(),\n             }, borrow_span))\n         {\n             debug!(\n@@ -729,7 +727,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.access_place_error_reported\n             .insert((Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.clone(),\n+                projection: root_place.projection.to_vec().into_boxed_slice(),\n             }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n@@ -1107,7 +1105,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let local_kind = match borrow.borrowed_place {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } => {\n                     match self.body.local_kind(local) {\n                         LocalKind::ReturnPointer\n@@ -1136,7 +1134,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 .unwrap();\n             let local = if let PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } = root_place {\n                 local\n             } else {\n@@ -1446,7 +1444,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) {\n         let (from_arg, local_decl) = if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = *err_place {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n@@ -1519,28 +1517,29 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn classify_drop_access_kind(&self, place: PlaceRef<'cx, 'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place.projection {\n-            None => {\n+            [] => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n-            Some(box Projection { ref base, ref elem }) => {\n+            [proj_base @ .., elem] => {\n+                // FIXME(spastorino) make this iterate\n                 let base_access = self.classify_drop_access_kind(PlaceRef {\n                     base: place.base,\n-                    projection: base,\n+                    projection: proj_base,\n                 });\n                 match elem {\n                     ProjectionElem::Deref => match base_access {\n                         StorageDeadOrDrop::LocalStorageDead\n                         | StorageDeadOrDrop::BoxedStorageDead => {\n                             assert!(\n-                                Place::ty_from(&place.base, base, self.body, tcx).ty.is_box(),\n+                                Place::ty_from(&place.base, proj_base, self.body, tcx).ty.is_box(),\n                                 \"Drop of value behind a reference or raw pointer\"\n                             );\n                             StorageDeadOrDrop::BoxedStorageDead\n                         }\n                         StorageDeadOrDrop::Destructor(_) => base_access,\n                     },\n                     ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n-                        let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n+                        let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n                         match base_ty.sty {\n                             ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                 // Report the outermost adt with a destructor\n@@ -1598,7 +1597,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"annotate_argument_and_return_for_borrow: location={:?}\",\n             location\n         );\n-        if let Some(&Statement { kind: StatementKind::Assign(ref reservation, _), ..})\n+        if let Some(&Statement { kind: StatementKind::Assign(box(ref reservation, _)), ..})\n              = &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\n@@ -1609,7 +1608,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let mut target = *match reservation {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } if self.body.local_kind(*local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n@@ -1623,11 +1622,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     target, stmt\n                 );\n                 if let StatementKind::Assign(\n-                    Place {\n-                        base: PlaceBase::Local(assigned_to),\n-                        projection: None,\n-                    },\n-                    box rvalue\n+                    box(\n+                        Place {\n+                            base: PlaceBase::Local(assigned_to),\n+                            projection: box [],\n+                        },\n+                        rvalue\n+                    )\n                 ) = &stmt.kind {\n                     debug!(\n                         \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n@@ -1753,7 +1754,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let TerminatorKind::Call {\n                 destination: Some((Place {\n                     base: PlaceBase::Local(assigned_to),\n-                    projection: None,\n+                    projection: box [],\n                 }, _)),\n                 args,\n                 .."}, {"sha": "5bccd2835c980d32f6d75caee10ead5fa486e834", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -41,7 +41,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut target = place.local_or_deref_local();\n         for stmt in &self.body[location.block].statements[location.statement_index..] {\n             debug!(\"add_moved_or_invoked_closure_note: stmt={:?} target={:?}\", stmt, target);\n-            if let StatementKind::Assign(into, box Rvalue::Use(from)) = &stmt.kind {\n+            if let StatementKind::Assign(box(into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n                     Operand::Copy(ref place) |\n@@ -152,7 +152,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n@@ -162,7 +162,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 buf.push_str(\"promoted\");\n             }\n@@ -173,15 +173,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         def_id,\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n             }\n             PlaceRef {\n                 base,\n-                projection: Some(ref proj),\n+                projection: [proj_base @ .., elem],\n             } => {\n-                match proj.elem {\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let upvar_field_projection =\n                             self.is_upvar_field_projection(place);\n@@ -199,20 +199,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 self.append_place_to_string(\n                                     PlaceRef {\n                                         base,\n-                                        projection: &proj.base,\n+                                        projection: proj_base,\n                                     },\n                                     buf,\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n                             } else {\n-                                match (&proj.base, base) {\n-                                    (None, PlaceBase::Local(local)) => {\n+                                match (proj_base, base) {\n+                                    ([], PlaceBase::Local(local)) => {\n                                         if self.body.local_decls[*local].is_ref_for_guard() {\n                                             self.append_place_to_string(\n                                                 PlaceRef {\n                                                     base,\n-                                                    projection: &proj.base,\n+                                                    projection: proj_base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -224,7 +224,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                             self.append_place_to_string(\n                                                 PlaceRef {\n                                                     base,\n-                                                    projection: &proj.base,\n+                                                    projection: proj_base,\n                                                 },\n                                                 buf,\n                                                 autoderef,\n@@ -238,7 +238,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                         self.append_place_to_string(\n                                             PlaceRef {\n                                                 base,\n-                                                projection: &proj.base,\n+                                                projection: proj_base,\n                                             },\n                                             buf,\n                                             autoderef,\n@@ -253,7 +253,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n@@ -275,12 +275,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         } else {\n                             let field_name = self.describe_field(PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n-                            }, field);\n+                                projection: proj_base,\n+                            }, *field);\n                             self.append_place_to_string(\n                                 PlaceRef {\n                                     base,\n-                                    projection: &proj.base,\n+                                    projection: proj_base,\n                                 },\n                                 buf,\n                                 autoderef,\n@@ -295,14 +295,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n                             &including_downcast,\n                         )?;\n                         buf.push_str(\"[\");\n-                        if self.append_local_to_string(index, buf).is_err() {\n+                        if self.append_local_to_string(*index, buf).is_err() {\n                             buf.push_str(\"_\");\n                         }\n                         buf.push_str(\"]\");\n@@ -315,7 +315,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         self.append_place_to_string(\n                             PlaceRef {\n                                 base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             },\n                             buf,\n                             autoderef,\n@@ -349,28 +349,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n             PlaceRef {\n                 base: PlaceBase::Static(static_),\n-                projection: None,\n+                projection: [],\n             } =>\n                 self.describe_field_from_ty(&static_.ty, field, None),\n             PlaceRef {\n                 base,\n-                projection: Some(proj),\n-            } => match proj.elem {\n-                ProjectionElem::Deref => self.describe_field(PlaceRef {\n-                    base,\n-                    projection: &proj.base,\n-                }, field),\n+                projection: [proj_base @ .., elem],\n+            } => match elem {\n+                ProjectionElem::Deref => {\n+                    self.describe_field(PlaceRef {\n+                        base,\n+                        projection: proj_base,\n+                    }, field)\n+                }\n                 ProjectionElem::Downcast(_, variant_index) => {\n                     let base_ty =\n                         Place::ty_from(place.base, place.projection, self.body, self.infcx.tcx).ty;\n-                    self.describe_field_from_ty(&base_ty, field, Some(variant_index))\n+                    self.describe_field_from_ty(&base_ty, field, Some(*variant_index))\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field, None)\n@@ -380,7 +382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 | ProjectionElem::Subslice { .. } => {\n                     self.describe_field(PlaceRef {\n                         base,\n-                        projection: &proj.base,\n+                        projection: proj_base,\n                     }, field)\n                 }\n             },\n@@ -445,7 +447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 def_id,\n                 ..\n             }),\n-            projection: None,\n+            projection: [],\n         } = place_ref {\n             let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(sym::thread_local));\n@@ -790,8 +792,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n         if let  StatementKind::Assign(\n-            _,\n-            box Rvalue::Aggregate(ref kind, ref places)\n+            box(_, Rvalue::Aggregate(ref kind, ref places))\n         ) = stmt.kind {\n             let (def_id, is_generator) = match kind {\n                 box AggregateKind::Closure(def_id, _) => (def_id, false),\n@@ -828,10 +829,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(Place {\n+                kind: StatementKind::Assign(box(Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n-                }, _),\n+                    projection: box [],\n+                }, _)),\n                 ..\n             }) => local,\n             _ => return OtherUse(use_span),\n@@ -844,7 +845,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n             if let StatementKind::Assign(\n-                _, box Rvalue::Aggregate(ref kind, ref places)\n+                box(_, Rvalue::Aggregate(ref kind, ref places))\n             ) = stmt.kind {\n                 let (def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),"}, {"sha": "5ef70461296c7b3aecbcc93e60c7f949ee1a3d87", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -10,10 +10,10 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceRef,\n-    Static, StaticKind\n+    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, PlaceElem,\n+    PlaceRef, Static, StaticKind\n };\n-use rustc::mir::{Field, Projection, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n+use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n@@ -546,7 +546,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n         self.check_activations(location, span, flow_state);\n \n         match stmt.kind {\n-            StatementKind::Assign(ref lhs, ref rhs) => {\n+            StatementKind::Assign(box(ref lhs, ref rhs)) => {\n                 self.consume_rvalue(\n                     location,\n                     (rhs, span),\n@@ -561,7 +561,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                     flow_state,\n                 );\n             }\n-            StatementKind::FakeRead(_, ref place) => {\n+            StatementKind::FakeRead(_, box ref place) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -905,7 +905,7 @@ enum InitializationRequiringAction {\n \n struct RootPlace<'d, 'tcx> {\n     place_base: &'d PlaceBase<'tcx>,\n-    place_projection: &'d Option<Box<Projection<'tcx>>>,\n+    place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n \n@@ -1191,7 +1191,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // before (at this point in the flow).\n         if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = place_span.0 {\n             if let Mutability::Not = self.body.local_decls[*local].mutability {\n                 // check for reassignments to immutable local variables\n@@ -1331,7 +1331,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n     fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n         let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n-            if place.projection.is_some() {\n+            if !place.projection.is_empty() {\n                 if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n                     this.used_mut_upvars.push(field);\n                 }\n@@ -1346,11 +1346,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match *operand {\n             Operand::Move(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) |\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) if self.body.local_decls[local].is_user_variable.is_none() => {\n                 if self.body.local_decls[local].ty.is_mutable_ptr() {\n                     // The variable will be marked as mutable by the borrow.\n@@ -1387,7 +1387,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let stmt = &bbd.statements[loc.statement_index];\n                 debug!(\"temporary assigned in: stmt={:?}\", stmt);\n \n-                if let StatementKind::Assign(_, box Rvalue::Ref(_, _, ref source)) = stmt.kind {\n+                if let StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref source))) = stmt.kind {\n                     propagate_closure_used_mut_place(self, source);\n                 } else {\n                     bug!(\"closures should only capture user variables \\\n@@ -1468,7 +1468,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n-        assert!(root_place.projection.is_none());\n+        assert!(root_place.projection.is_empty());\n         let (might_be_alive, will_be_dropped) = match root_place.base {\n             PlaceBase::Static(box Static {\n                 kind: StaticKind::Promoted(..),\n@@ -1756,13 +1756,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n-        // recur down place; dispatch to external checks when necessary\n-        let mut place_projection = &place.projection;\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        while let Some(proj) = place_projection {\n-            let Projection { ref base, ref elem } = **proj;\n-            match *elem {\n+        for (i, elem) in place.projection.iter().enumerate().rev() {\n+            match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n@@ -1774,11 +1771,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 // assigning to (*P) requires P to be initialized\n                 ProjectionElem::Deref => {\n+                    let proj_base = &place.projection[..i];\n+\n                     self.check_if_full_path_is_moved(\n                         location, InitializationRequiringAction::Use,\n                         (PlaceRef {\n                             base: &place.base,\n-                            projection: base,\n+                            projection: proj_base,\n                         }, span), flow_state);\n                     // (base initialized; no need to\n                     // recur further)\n@@ -1791,18 +1790,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n \n                 ProjectionElem::Field(..) => {\n+                    let proj_base = &place.projection[..i];\n                     // if type of `P` has a dtor, then\n                     // assigning to `P.f` requires `P` itself\n                     // be already initialized\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&place.base, base, self.body, tcx).ty;\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, tcx).ty;\n                     match base_ty.sty {\n                         ty::Adt(def, _) if def.has_dtor(tcx) => {\n                             self.check_if_path_or_subpath_is_moved(\n                                 location, InitializationRequiringAction::Assignment,\n                                 (PlaceRef {\n                                     base: &place.base,\n-                                    projection: base,\n+                                    projection: proj_base,\n                                 }, span), flow_state);\n \n                             // (base initialized; no need to\n@@ -1815,7 +1815,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ty::Adt(..) | ty::Tuple(..) => {\n                             check_parent_of_field(self, location, PlaceRef {\n                                 base: &place.base,\n-                                projection: base,\n+                                projection: proj_base,\n                             }, span, flow_state);\n \n                             if let PlaceBase::Local(local) = place.base {\n@@ -1835,8 +1835,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }\n                 }\n             }\n-\n-            place_projection = base;\n         }\n \n         fn check_parent_of_field<'cx, 'tcx>(\n@@ -2084,7 +2082,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match root_place {\n             RootPlace {\n                 place_base: PlaceBase::Local(local),\n-                place_projection: None,\n+                place_projection: [],\n                 is_local_mutation_allowed,\n             } => {\n                 // If the local may have been initialized, and it is now currently being\n@@ -2103,7 +2101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             } => {}\n             RootPlace {\n                 place_base,\n-                place_projection: place_projection @ Some(_),\n+                place_projection: place_projection @ [.., _],\n                 is_local_mutation_allowed: _,\n             } => {\n                 if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -2115,7 +2113,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             RootPlace {\n                 place_base: PlaceBase::Static(..),\n-                place_projection: None,\n+                place_projection: [],\n                 is_local_mutation_allowed: _,\n             } => {}\n         }\n@@ -2131,7 +2129,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 let local = &self.body.local_decls[*local];\n                 match local.mutability {\n@@ -2162,7 +2160,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } =>\n                 Ok(RootPlace {\n                     place_base: place.base,\n@@ -2175,7 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     def_id,\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 if !self.infcx.tcx.is_mutable_static(*def_id) {\n                     Err(place)\n@@ -2189,12 +2187,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n             PlaceRef {\n                 base: _,\n-                projection: Some(proj),\n+                projection: [proj_base @ .., elem],\n             } => {\n-                match proj.elem {\n+                match elem {\n                     ProjectionElem::Deref => {\n                         let base_ty =\n-                            Place::ty_from(place.base, &proj.base, self.body, self.infcx.tcx).ty;\n+                            Place::ty_from(place.base, proj_base, self.body, self.infcx.tcx).ty;\n \n                         // Check the kind of deref to decide\n                         match base_ty.sty {\n@@ -2216,7 +2214,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                                         self.is_mutable(PlaceRef {\n                                             base: place.base,\n-                                            projection: &proj.base,\n+                                            projection: proj_base,\n                                         }, mode)\n                                     }\n                                 }\n@@ -2240,7 +2238,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             _ if base_ty.is_box() => {\n                                 self.is_mutable(PlaceRef {\n                                     base: place.base,\n-                                    projection: &proj.base,\n+                                    projection: proj_base,\n                                 }, is_local_mutation_allowed)\n                             }\n                             // Deref should only be for reference, pointers or boxes\n@@ -2297,7 +2295,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // ```\n                                     let _ = self.is_mutable(PlaceRef {\n                                         base: place.base,\n-                                        projection: &proj.base,\n+                                        projection: proj_base,\n                                     }, is_local_mutation_allowed)?;\n                                     Ok(RootPlace {\n                                         place_base: place.base,\n@@ -2309,7 +2307,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         } else {\n                             self.is_mutable(PlaceRef {\n                                 base: place.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             }, is_local_mutation_allowed)\n                         }\n                     }\n@@ -2326,21 +2324,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut place_projection = place_ref.projection;\n         let mut by_ref = false;\n \n-        if let Some(box Projection {\n-            base,\n-            elem: ProjectionElem::Deref,\n-        }) = place_projection {\n-            place_projection = &base;\n+        if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n+            place_projection = proj_base;\n             by_ref = true;\n         }\n \n         match place_projection {\n-            Some(box Projection {\n-                base,\n-                elem: ProjectionElem::Field(field, _ty),\n-            }) => {\n+            [base @ .., ProjectionElem::Field(field, _ty)] => {\n                 let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.base, &base, self.body, tcx).ty;\n+                let base_ty = Place::ty_from(place_ref.base, base, self.body, tcx).ty;\n \n                 if (base_ty.is_closure() || base_ty.is_generator()) &&\n                     (!by_ref || self.upvars[field.index()].by_ref) {"}, {"sha": "aa732b0092a223f300a5528c6420ceab3498115b", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -89,11 +89,13 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: None,\n-                    },\n-                    box Rvalue::Use(Operand::Move(move_from)),\n+                    box(\n+                        Place {\n+                            base: PlaceBase::Local(local),\n+                            projection: box [],\n+                        },\n+                        Rvalue::Use(Operand::Move(move_from))\n+                    )\n                 )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n@@ -274,16 +276,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         place: &Place<'tcx>,\n         span: Span\n     ) -> DiagnosticBuilder<'a> {\n-        let description = if place.projection.is_none() {\n+        let description = if place.projection.is_empty() {\n             format!(\"static item `{}`\", self.describe_place(place.as_ref()).unwrap())\n         } else {\n-            let mut base_static = &place.projection;\n-            while let Some(box Projection { base: Some(ref proj), .. }) = base_static {\n-                base_static = &proj.base;\n-            }\n             let base_static = PlaceRef {\n                 base: &place.base,\n-                projection: base_static,\n+                projection: &place.projection[..1],\n             };\n \n             format!(\n@@ -309,17 +307,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n-        let deref_base = match deref_target_place.projection {\n-            Some(box Projection { ref base, elem: ProjectionElem::Deref }) => PlaceRef {\n-                base: &deref_target_place.base,\n-                projection: base,\n-            },\n+        let deref_base = match &deref_target_place.projection {\n+            box [proj_base @ .., ProjectionElem::Deref] => {\n+                PlaceRef {\n+                    base: &deref_target_place.base,\n+                    projection: proj_base,\n+                }\n+            }\n             _ => bug!(\"deref_target_place is not a deref projection\"),\n         };\n \n         if let PlaceRef {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: [],\n         } = deref_base {\n             let decl = &self.body.local_decls[*local];\n             if decl.is_ref_for_guard() {"}, {"sha": "14b76d97b3e57f02172ca2e6e0af5c39ff659c90", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 31, "deletions": 73, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Body};\n use rustc::mir::{\n-    Mutability, Place, PlaceRef, PlaceBase, Projection, ProjectionElem, Static, StaticKind\n+    Mutability, Place, PlaceRef, PlaceBase, ProjectionElem, Static, StaticKind\n };\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -47,12 +47,12 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         match the_place_err {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                 if let Place {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: box [],\n                 } = access_place {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n@@ -65,14 +65,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Field(upvar_index, _),\n-                    }),\n+                projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&the_place_err.base, &base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(&the_place_err.base, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n@@ -86,14 +82,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base,\n-                        elem: ProjectionElem::Deref,\n-                    }),\n+                projection: [proj_base @ .., ProjectionElem::Deref],\n             } => {\n                 if the_place_err.base == &PlaceBase::Local(Local::new(1)) &&\n-                    base.is_none() &&\n+                    proj_base.is_empty() &&\n                     !self.upvars.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.body.local_decls[Local::new(1)].ty.is_region_ptr());\n@@ -114,7 +106,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                         }\n                 } else if {\n-                    if let (PlaceBase::Local(local), None) = (&the_place_err.base, base) {\n+                    if let (PlaceBase::Local(local), []) = (&the_place_err.base, proj_base) {\n                         self.body.local_decls[*local].is_ref_for_guard()\n                     } else {\n                         false\n@@ -125,7 +117,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     let source = self.borrowed_content_source(PlaceRef {\n                         base: the_place_err.base,\n-                        projection: base,\n+                        projection: proj_base,\n                     });\n                     let pointer_type = source.describe_for_immutable_place();\n                     opt_source = Some(source);\n@@ -151,7 +143,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         kind: StaticKind::Promoted(..),\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => unreachable!(),\n \n             PlaceRef {\n@@ -161,11 +153,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         def_id,\n                         ..\n                     }),\n-                projection: None,\n+                projection: [],\n             } => {\n                 if let Place {\n                     base: PlaceBase::Static(_),\n-                    projection: None,\n+                    projection: box [],\n                 } = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n@@ -178,33 +170,19 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::Index(_),\n-                    }),\n+                projection: [.., ProjectionElem::Index(_)],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection:\n-                    Some(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::ConstantIndex { .. },\n-                    }),\n+                projection: [.., ProjectionElem::ConstantIndex { .. }],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Subslice { .. },\n-                }),\n+                projection: [.., ProjectionElem::Subslice { .. }],\n             }\n             | PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Downcast(..),\n-                }),\n+                projection: [.., ProjectionElem::Downcast(..)],\n             } => bug!(\"Unexpected immutable place.\"),\n         }\n \n@@ -262,22 +240,17 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // after the field access).\n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: Some(box Projection {\n-                        base: Some(box Projection {\n-                            base: base_proj,\n-                            elem: ProjectionElem::Deref,\n-                        }),\n-                        elem: ProjectionElem::Field(field, _),\n-                    }),\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [proj_base @ ..,\n+                             ProjectionElem::Deref,\n+                             ProjectionElem::Field(field, _),\n+                             ProjectionElem::Deref,\n+                ],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 if let Some((span, message)) = annotate_struct_field(\n                     self.infcx.tcx,\n-                    Place::ty_from(&base, &base_proj, self.body, self.infcx.tcx).ty,\n+                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty,\n                     field,\n                 ) {\n                     err.span_suggestion(\n@@ -292,7 +265,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Suggest removing a `&mut` from the use of a mutable reference.\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } if {\n                 self.body.local_decls.get(*local).map(|local_decl| {\n                     if let ClearCrossCrate::Set(\n@@ -328,7 +301,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // variable) mutations...\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } if self.body.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n@@ -349,13 +322,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // Also suggest adding mut for upvars\n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: proj_base,\n-                    elem: ProjectionElem::Field(upvar_index, _),\n-                }),\n+                projection: [proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             } => {\n                 debug_assert!(is_closure_or_generator(\n-                    Place::ty_from(&base, &proj_base, self.body, self.infcx.tcx).ty\n+                    Place::ty_from(base, proj_base, self.body, self.infcx.tcx).ty\n                 ));\n \n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n@@ -385,7 +355,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // a local variable, then just suggest the user remove it.\n             PlaceRef {\n                 base: PlaceBase::Local(_),\n-                projection: None,\n+                projection: [],\n             } if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n@@ -400,10 +370,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } if {\n                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n                     self.body.local_decls[*local].is_user_variable\n@@ -427,10 +394,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             // arbitrary base for the projection?\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } if self.body.local_decls[*local].is_user_variable.is_some() =>\n             {\n                 let local_decl = &self.body.local_decls[*local];\n@@ -510,10 +474,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base,\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             // FIXME document what is this 1 magic number about\n             } if *base == PlaceBase::Local(Local::new(1)) &&\n                   !self.upvars.is_empty() =>\n@@ -527,10 +488,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n             PlaceRef {\n                 base: _,\n-                projection: Some(box Projection {\n-                    base: _,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [.., ProjectionElem::Deref],\n             } => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n "}, {"sha": "1e5f613aedc233b20a0c3a84c91f6b6e377cf767", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -8,9 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, Projection,\n-    ProjectionElem, Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind,\n-    UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, ProjectionElem, Rvalue,\n+    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, RegionVid, Ty};\n@@ -229,14 +228,11 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             match place {\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } |\n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: Some(box Projection {\n-                        base: None,\n-                        elem: ProjectionElem::Deref,\n-                    }),\n+                    projection: box [ProjectionElem::Deref],\n                 } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n@@ -261,7 +257,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n \n                 Place {\n                     base: PlaceBase::Local(local),\n-                    projection: Some(_),\n+                    projection: box [.., _],\n                 } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!("}, {"sha": "eae2f832ba7918c80ed68a97061100a312ff8073", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -274,7 +274,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n                         if let Place {\n                             base: PlaceBase::Local(borrowed_local),\n-                            projection: None,\n+                            projection: box [],\n                         } = place {\n                              if body.local_decls[*borrowed_local].name.is_some()\n                                 && local != *borrowed_local\n@@ -495,11 +495,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             Operand::Constant(c) => c.span,\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(l),\n-                                projection: None,\n+                                projection: box [],\n                             }) |\n                             Operand::Move(Place {\n                                 base: PlaceBase::Local(l),\n-                                projection: None,\n+                                projection: box [],\n                             }) => {\n                                 let local_decl = &self.body.local_decls[*l];\n                                 if local_decl.name.is_none() {\n@@ -541,10 +541,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(Place {\n+            kind: StatementKind::Assign(box(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n-            }, _),\n+                projection: box [],\n+            }, _)),\n             ..\n         }) = stmt\n         {\n@@ -567,7 +567,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: stmt={:?}\", stmt);\n \n                 // The only kind of statement that we care about is assignments...\n-                if let StatementKind::Assign(place, box rvalue) = &stmt.kind {\n+                if let StatementKind::Assign(box(place, rvalue)) = &stmt.kind {\n                     let into = match place.local_or_deref_local() {\n                         Some(into) => into,\n                         None => {\n@@ -583,11 +583,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Use(operand) => match operand {\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                             | Operand::Move(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                                 if *from == target =>\n                             {\n@@ -602,11 +602,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         ) => match operand {\n                             Operand::Copy(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                             | Operand::Move(Place {\n                                 base: PlaceBase::Local(from),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                                 if *from == target =>\n                             {\n@@ -639,7 +639,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let TerminatorKind::Call {\n                     destination: Some((Place {\n                         base: PlaceBase::Local(dest),\n-                        projection: None,\n+                        projection: box [],\n                     }, block)),\n                     args,\n                     ..\n@@ -653,7 +653,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let found_target = args.iter().any(|arg| {\n                         if let Operand::Move(Place {\n                             base: PlaceBase::Local(potential),\n-                            projection: None,\n+                            projection: box [],\n                         }) = arg {\n                             *potential == target\n                         } else {"}, {"sha": "1d429e3a6dee6c721daa18e3e2b26d6700ccbda8", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -66,7 +66,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match statement.kind {\n-            StatementKind::Assign(ref lhs, ref rhs) => {\n+            StatementKind::Assign(box(ref lhs, ref rhs)) => {\n                 self.consume_rvalue(\n                     location,\n                     rhs,"}, {"sha": "1d17bae559c59773d2e4976beec7c63a04a02609", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 95, "deletions": 103, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -421,107 +421,104 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n \n-        place.iterate(|place_base, place_projection| {\n-            let mut place_ty = match place_base {\n-                PlaceBase::Local(index) =>\n-                    PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-                PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n-                    let sty = self.sanitize_type(place, sty);\n-                    let check_err =\n-                        |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n-                         place: &Place<'tcx>,\n-                         ty,\n-                         sty| {\n-                            if let Err(terr) = verifier.cx.eq_types(\n-                                sty,\n-                                ty,\n-                                location.to_locations(),\n-                                ConstraintCategory::Boring,\n-                            ) {\n-                                span_mirbug!(\n-                                verifier,\n-                                place,\n-                                \"bad promoted type ({:?}: {:?}): {:?}\",\n-                                ty,\n-                                sty,\n-                                terr\n-                            );\n-                            };\n+        let mut place_ty = match &place.base {\n+            PlaceBase::Local(index) =>\n+                PlaceTy::from_ty(self.body.local_decls[*index].ty),\n+            PlaceBase::Static(box Static { kind, ty: sty, def_id }) => {\n+                let sty = self.sanitize_type(place, sty);\n+                let check_err =\n+                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n+                     place: &Place<'tcx>,\n+                     ty,\n+                     sty| {\n+                        if let Err(terr) = verifier.cx.eq_types(\n+                            sty,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Boring,\n+                        ) {\n+                            span_mirbug!(\n+                            verifier,\n+                            place,\n+                            \"bad promoted type ({:?}: {:?}): {:?}\",\n+                            ty,\n+                            sty,\n+                            terr\n+                        );\n                         };\n-                    match kind {\n-                        StaticKind::Promoted(promoted, _) => {\n-                            if !self.errors_reported {\n-                                let promoted_body = &self.promoted[*promoted];\n-                                self.sanitize_promoted(promoted_body, location);\n-\n-                                let promoted_ty = promoted_body.return_ty();\n-                                check_err(self, place, promoted_ty, sty);\n-                            }\n+                    };\n+                match kind {\n+                    StaticKind::Promoted(promoted, _) => {\n+                        if !self.errors_reported {\n+                            let promoted_body = &self.promoted[*promoted];\n+                            self.sanitize_promoted(promoted_body, location);\n+\n+                            let promoted_ty = promoted_body.return_ty();\n+                            check_err(self, place, promoted_ty, sty);\n                         }\n-                        StaticKind::Static => {\n-                            let ty = self.tcx().type_of(*def_id);\n-                            let ty = self.cx.normalize(ty, location);\n+                    }\n+                    StaticKind::Static => {\n+                        let ty = self.tcx().type_of(*def_id);\n+                        let ty = self.cx.normalize(ty, location);\n \n-                            check_err(self, place, ty, sty);\n-                        }\n+                        check_err(self, place, ty, sty);\n                     }\n-                    PlaceTy::from_ty(sty)\n                 }\n-            };\n+                PlaceTy::from_ty(sty)\n+            }\n+        };\n \n-            // FIXME use place_projection.is_empty() when is available\n-            if place.projection.is_none() {\n-                if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                    let is_promoted = match place {\n-                        Place {\n-                            base: PlaceBase::Static(box Static {\n-                                kind: StaticKind::Promoted(..),\n-                                ..\n-                            }),\n-                            projection: None,\n-                        } => true,\n-                        _ => false,\n-                    };\n+        if place.projection.is_empty() {\n+            if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+                let is_promoted = match place {\n+                    Place {\n+                        base: PlaceBase::Static(box Static {\n+                            kind: StaticKind::Promoted(..),\n+                            ..\n+                        }),\n+                        projection: box [],\n+                    } => true,\n+                    _ => false,\n+                };\n \n-                    if !is_promoted {\n-                        let tcx = self.tcx();\n-                        let trait_ref = ty::TraitRef {\n-                            def_id: tcx.lang_items().copy_trait().unwrap(),\n-                            substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-                        };\n+                if !is_promoted {\n+                    let tcx = self.tcx();\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().copy_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    };\n \n-                        // In order to have a Copy operand, the type T of the\n-                        // value must be Copy. Note that we prove that T: Copy,\n-                        // rather than using the `is_copy_modulo_regions`\n-                        // test. This is important because\n-                        // `is_copy_modulo_regions` ignores the resulting region\n-                        // obligations and assumes they pass. This can result in\n-                        // bounds from Copy impls being unsoundly ignored (e.g.,\n-                        // #29149). Note that we decide to use Copy before knowing\n-                        // whether the bounds fully apply: in effect, the rule is\n-                        // that if a value of some type could implement Copy, then\n-                        // it must.\n-                        self.cx.prove_trait_ref(\n-                            trait_ref,\n-                            location.to_locations(),\n-                            ConstraintCategory::CopyBound,\n-                        );\n-                    }\n+                    // To have a `Copy` operand, the type `T` of the\n+                    // value must be `Copy`. Note that we prove that `T: Copy`,\n+                    // rather than using the `is_copy_modulo_regions`\n+                    // test. This is important because\n+                    // `is_copy_modulo_regions` ignores the resulting region\n+                    // obligations and assumes they pass. This can result in\n+                    // bounds from `Copy` impls being unsoundly ignored (e.g.,\n+                    // #29149). Note that we decide to use `Copy` before knowing\n+                    // whether the bounds fully apply: in effect, the rule is\n+                    // that if a value of some type could implement `Copy`, then\n+                    // it must.\n+                    self.cx.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                        ConstraintCategory::CopyBound,\n+                    );\n                 }\n             }\n+        }\n \n-            for proj in place_projection {\n-                if place_ty.variant_index.is_none() {\n-                    if place_ty.ty.references_error() {\n-                        assert!(self.errors_reported);\n-                        return PlaceTy::from_ty(self.tcx().types.err);\n-                    }\n+        for elem in place.projection.iter() {\n+            if place_ty.variant_index.is_none() {\n+                if place_ty.ty.references_error() {\n+                    assert!(self.errors_reported);\n+                    return PlaceTy::from_ty(self.tcx().types.err);\n                 }\n-                place_ty = self.sanitize_projection(place_ty, &proj.elem, place, location)\n             }\n+            place_ty = self.sanitize_projection(place_ty, elem, place, location)\n+        }\n \n-            place_ty\n-        })\n+        place_ty\n     }\n \n     fn sanitize_promoted(&mut self, promoted_body: &'b Body<'tcx>, location: Location) {\n@@ -1346,15 +1343,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n-            StatementKind::Assign(ref place, ref rv) => {\n+            StatementKind::Assign(box(ref place, ref rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: None,\n+                        projection: box [],\n                     } => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n@@ -1373,7 +1370,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     },\n                     Place {\n                         base: PlaceBase::Local(l),\n-                        projection: None,\n+                        projection: box [],\n                     } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -1453,7 +1450,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n+            StatementKind::AscribeUserType(box(ref place, ref projection), variance) => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n@@ -1660,7 +1657,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 let category = match *dest {\n                     Place {\n                         base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: None,\n+                        projection: box [],\n                     } => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n@@ -1682,7 +1679,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                     Place {\n                         base: PlaceBase::Local(l),\n-                        projection: None,\n+                        projection: box [],\n                     } if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n@@ -2416,19 +2413,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // *p`, where the `p` has type `&'b mut Foo`, for example, we\n         // need to ensure that `'b: 'a`.\n \n-        let mut borrowed_projection = &borrowed_place.projection;\n-\n         debug!(\n             \"add_reborrow_constraint({:?}, {:?}, {:?})\",\n             location, borrow_region, borrowed_place\n         );\n-        while let Some(box proj) = borrowed_projection {\n-            debug!(\"add_reborrow_constraint - iteration {:?}\", borrowed_projection);\n+        for (i, elem) in borrowed_place.projection.iter().enumerate().rev() {\n+            debug!(\"add_reborrow_constraint - iteration {:?}\", elem);\n+            let proj_base = &borrowed_place.projection[..i];\n \n-            match proj.elem {\n+            match elem {\n                 ProjectionElem::Deref => {\n                     let tcx = self.infcx.tcx;\n-                    let base_ty = Place::ty_from(&borrowed_place.base, &proj.base, body, tcx).ty;\n+                    let base_ty = Place::ty_from(&borrowed_place.base, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n@@ -2490,10 +2486,6 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // other field access\n                 }\n             }\n-\n-            // The \"propagate\" case. We need to check that our base is valid\n-            // for the borrow's lifetime.\n-            borrowed_projection = &proj.base;\n         }\n     }\n "}, {"sha": "411fa5b59676530dd004a67d12474d1f79c884d7", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 43, "deletions": 44, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -25,55 +25,54 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         body: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n-        self.iterate(|place_base, place_projection| {\n-            let ignore = match place_base {\n-                // If a local variable is immutable, then we only need to track borrows to guard\n-                // against two kinds of errors:\n-                // * The variable being dropped while still borrowed (e.g., because the fn returns\n-                //   a reference to a local variable)\n-                // * The variable being moved while still borrowed\n-                //\n-                // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n-                // so we don't have to worry about mutation while borrowed.\n-                PlaceBase::Local(index) => {\n-                    match locals_state_at_exit {\n-                        LocalsStateAtExit::AllAreInvalidated => false,\n-                        LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n-                            let ignore = !has_storage_dead_or_moved.contains(*index) &&\n-                                body.local_decls[*index].mutability == Mutability::Not;\n-                            debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n-                            ignore\n-                        }\n+        let ignore = match self.base {\n+            // If a local variable is immutable, then we only need to track borrows to guard\n+            // against two kinds of errors:\n+            // * The variable being dropped while still borrowed (e.g., because the fn returns\n+            //   a reference to a local variable)\n+            // * The variable being moved while still borrowed\n+            //\n+            // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n+            // so we don't have to worry about mutation while borrowed.\n+            PlaceBase::Local(index) => {\n+                match locals_state_at_exit {\n+                    LocalsStateAtExit::AllAreInvalidated => false,\n+                    LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n+                        let ignore = !has_storage_dead_or_moved.contains(index) &&\n+                            body.local_decls[index].mutability == Mutability::Not;\n+                        debug!(\"ignore_borrow: local {:?} => {:?}\", index, ignore);\n+                        ignore\n                     }\n                 }\n-                PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n-                    false,\n-                PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n-                    tcx.is_mutable_static(*def_id)\n-                }\n-            };\n+            }\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) =>\n+                false,\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n+                tcx.is_mutable_static(def_id)\n+            }\n+        };\n \n-            for proj in place_projection {\n-                if proj.elem == ProjectionElem::Deref {\n-                    let ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n-                    match ty.sty {\n-                        // For both derefs of raw pointers and `&T`\n-                        // references, the original path is `Copy` and\n-                        // therefore not significant.  In particular,\n-                        // there is nothing the user can do to the\n-                        // original path that would invalidate the\n-                        // newly created reference -- and if there\n-                        // were, then the user could have copied the\n-                        // original path into a new variable and\n-                        // borrowed *that* one, leaving the original\n-                        // path unborrowed.\n-                        ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) => return true,\n-                        _ => {}\n-                    }\n+        for (i, elem) in self.projection.iter().enumerate() {\n+            let proj_base = &self.projection[..i];\n+\n+            if *elem == ProjectionElem::Deref {\n+                let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n+                if let ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) = ty.sty {\n+                    // For both derefs of raw pointers and `&T`\n+                    // references, the original path is `Copy` and\n+                    // therefore not significant.  In particular,\n+                    // there is nothing the user can do to the\n+                    // original path that would invalidate the\n+                    // newly created reference -- and if there\n+                    // were, then the user could have copied the\n+                    // original path into a new variable and\n+                    // borrowed *that* one, leaving the original\n+                    // path unborrowed.\n+                    return true;\n                 }\n             }\n+        }\n \n-            ignore\n-        })\n+        ignore\n     }\n }"}, {"sha": "dafa0b6631fe2cc44fff700a819f50ec361900dd", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 162, "deletions": 156, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -3,8 +3,7 @@ use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{\n-    Body, BorrowKind, Place, PlaceBase, PlaceRef, Projection, ProjectionElem, ProjectionsIter,\n-    StaticKind,\n+    Body, BorrowKind, Place, PlaceBase, PlaceElem, PlaceRef, ProjectionElem, StaticKind,\n };\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n@@ -67,39 +66,35 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n     // it's so common that it's a speed win to check for it first.\n     if let Place {\n         base: PlaceBase::Local(l1),\n-        projection: None,\n+        projection: box [],\n     } = borrow_place {\n         if let PlaceRef {\n             base: PlaceBase::Local(l2),\n-            projection: None,\n+            projection: [],\n         } = access_place {\n             return l1 == l2;\n         }\n     }\n \n-    borrow_place.iterate(|borrow_base, borrow_projections| {\n-        access_place.iterate(|access_base, access_projections| {\n-            place_components_conflict(\n-                tcx,\n-                param_env,\n-                body,\n-                (borrow_base, borrow_projections),\n-                borrow_kind,\n-                (access_base, access_projections),\n-                access,\n-                bias,\n-            )\n-        })\n-    })\n+    place_components_conflict(\n+        tcx,\n+        param_env,\n+        body,\n+        borrow_place,\n+        borrow_kind,\n+        access_place,\n+        access,\n+        bias,\n+    )\n }\n \n fn place_components_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n-    borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n+    borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n-    access_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n+    access_place: PlaceRef<'_, 'tcx>,\n     access: AccessDepth,\n     bias: PlaceConflictBias,\n ) -> bool {\n@@ -145,8 +140,8 @@ fn place_components_conflict<'tcx>(\n     //    and either equal or disjoint.\n     //  - If we did run out of access, the borrow can access a part of it.\n \n-    let borrow_base = borrow_projections.0;\n-    let access_base = access_projections.0;\n+    let borrow_base = &borrow_place.base;\n+    let access_base = access_place.base;\n \n     match place_base_conflict(tcx, param_env, borrow_base, access_base) {\n         Overlap::Arbitrary => {\n@@ -163,147 +158,157 @@ fn place_components_conflict<'tcx>(\n         }\n     }\n \n-    let mut borrow_projections = borrow_projections.1;\n-    let mut access_projections = access_projections.1;\n-\n-    loop {\n-        // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n-        if let Some(borrow_c) = borrow_projections.next() {\n-            debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n+    // loop invariant: borrow_c is always either equal to access_c or disjoint from it.\n+    for (i, (borrow_c, access_c)) in\n+        borrow_place.projection.iter().zip(access_place.projection.iter()).enumerate()\n+    {\n+        debug!(\"borrow_conflicts_with_place: borrow_c = {:?}\", borrow_c);\n+        let borrow_proj_base = &borrow_place.projection[..i];\n \n-            if let Some(access_c) = access_projections.next() {\n-                debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n+        debug!(\"borrow_conflicts_with_place: access_c = {:?}\", access_c);\n \n-                // Borrow and access path both have more components.\n-                //\n-                // Examples:\n-                //\n-                // - borrow of `a.(...)`, access to `a.(...)`\n-                // - borrow of `a.(...)`, access to `b.(...)`\n-                //\n-                // Here we only see the components we have checked so\n-                // far (in our examples, just the first component). We\n-                // check whether the components being borrowed vs\n-                // accessed are disjoint (as in the second example,\n-                // but not the first).\n-                match place_projection_conflict(tcx, body, borrow_base, borrow_c, access_c, bias) {\n-                    Overlap::Arbitrary => {\n-                        // We have encountered different fields of potentially\n-                        // the same union - the borrow now partially overlaps.\n-                        //\n-                        // There is no *easy* way of comparing the fields\n-                        // further on, because they might have different types\n-                        // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n-                        // `.y` come from different structs).\n-                        //\n-                        // We could try to do some things here - e.g., count\n-                        // dereferences - but that's probably not a good\n-                        // idea, at least for now, so just give up and\n-                        // report a conflict. This is unsafe code anyway so\n-                        // the user could always use raw pointers.\n-                        debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n-                        return true;\n-                    }\n-                    Overlap::EqualOrDisjoint => {\n-                        // This is the recursive case - proceed to the next element.\n-                    }\n-                    Overlap::Disjoint => {\n-                        // We have proven the borrow disjoint - further\n-                        // projections will remain disjoint.\n-                        debug!(\"borrow_conflicts_with_place: disjoint\");\n-                        return false;\n-                    }\n-                }\n-            } else {\n-                // Borrow path is longer than the access path. Examples:\n+        // Borrow and access path both have more components.\n+        //\n+        // Examples:\n+        //\n+        // - borrow of `a.(...)`, access to `a.(...)`\n+        // - borrow of `a.(...)`, access to `b.(...)`\n+        //\n+        // Here we only see the components we have checked so\n+        // far (in our examples, just the first component). We\n+        // check whether the components being borrowed vs\n+        // accessed are disjoint (as in the second example,\n+        // but not the first).\n+        match place_projection_conflict(\n+            tcx,\n+            body,\n+            borrow_base,\n+            borrow_proj_base,\n+            borrow_c,\n+            access_c,\n+            bias,\n+        ) {\n+            Overlap::Arbitrary => {\n+                // We have encountered different fields of potentially\n+                // the same union - the borrow now partially overlaps.\n                 //\n-                // - borrow of `a.b.c`, access to `a.b`\n+                // There is no *easy* way of comparing the fields\n+                // further on, because they might have different types\n+                // (e.g., borrows of `u.a.0` and `u.b.y` where `.0` and\n+                // `.y` come from different structs).\n                 //\n-                // Here, we know that the borrow can access a part of\n-                // our place. This is a conflict if that is a part our\n-                // access cares about.\n+                // We could try to do some things here - e.g., count\n+                // dereferences - but that's probably not a good\n+                // idea, at least for now, so just give up and\n+                // report a conflict. This is unsafe code anyway so\n+                // the user could always use raw pointers.\n+                debug!(\"borrow_conflicts_with_place: arbitrary -> conflict\");\n+                return true;\n+            }\n+            Overlap::EqualOrDisjoint => {\n+                // This is the recursive case - proceed to the next element.\n+            }\n+            Overlap::Disjoint => {\n+                // We have proven the borrow disjoint - further\n+                // projections will remain disjoint.\n+                debug!(\"borrow_conflicts_with_place: disjoint\");\n+                return false;\n+            }\n+        }\n+    }\n+\n+    if borrow_place.projection.len() > access_place.projection.len() {\n+        for (i, elem) in borrow_place.projection[access_place.projection.len()..].iter().enumerate()\n+        {\n+            // Borrow path is longer than the access path. Examples:\n+            //\n+            // - borrow of `a.b.c`, access to `a.b`\n+            //\n+            // Here, we know that the borrow can access a part of\n+            // our place. This is a conflict if that is a part our\n+            // access cares about.\n \n-                let base = &borrow_c.base;\n-                let elem = &borrow_c.elem;\n-                let base_ty = Place::ty_from(borrow_base, base, body, tcx).ty;\n+            let proj_base = &borrow_place.projection[..access_place.projection.len() + i];\n+            let base_ty = Place::ty_from(borrow_base, proj_base, body, tcx).ty;\n \n-                match (elem, &base_ty.sty, access) {\n-                    (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n-                    | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n-                        // The array length is like  additional fields on the\n-                        // type; it does not overlap any existing data there.\n-                        // Furthermore, if cannot actually be a prefix of any\n-                        // borrowed place (at least in MIR as it is currently.)\n-                        //\n-                        // e.g., a (mutable) borrow of `a[5]` while we read the\n-                        // array length of `a`.\n-                        debug!(\"borrow_conflicts_with_place: implicit field\");\n-                        return false;\n-                    }\n+            match (elem, &base_ty.sty, access) {\n+                (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n+                | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n+                    // The array length is like  additional fields on the\n+                    // type; it does not overlap any existing data there.\n+                    // Furthermore, if cannot actually be a prefix of any\n+                    // borrowed place (at least in MIR as it is currently.)\n+                    //\n+                    // e.g., a (mutable) borrow of `a[5]` while we read the\n+                    // array length of `a`.\n+                    debug!(\"borrow_conflicts_with_place: implicit field\");\n+                    return false;\n+                }\n \n-                    (ProjectionElem::Deref, _, Shallow(None)) => {\n-                        // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n-                        // prefix thereof - the shallow access can't touch anything behind\n-                        // the pointer.\n-                        debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n-                        return false;\n-                    }\n-                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n-                        // Shouldn't be tracked\n-                        bug!(\"Tracking borrow behind shared reference.\");\n-                    }\n-                    (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n-                        // Values behind a mutable reference are not access either by dropping a\n-                        // value, or by StorageDead\n-                        debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n-                        return false;\n-                    }\n+                (ProjectionElem::Deref, _, Shallow(None)) => {\n+                    // e.g., a borrow of `*x.y` while we shallowly access `x.y` or some\n+                    // prefix thereof - the shallow access can't touch anything behind\n+                    // the pointer.\n+                    debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n+                    return false;\n+                }\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n+                    // Shouldn't be tracked\n+                    bug!(\"Tracking borrow behind shared reference.\");\n+                }\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n+                    // Values behind a mutable reference are not access either by dropping a\n+                    // value, or by StorageDead\n+                    debug!(\"borrow_conflicts_with_place: drop access behind ptr\");\n+                    return false;\n+                }\n \n-                    (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n-                        // Drop can read/write arbitrary projections, so places\n-                        // conflict regardless of further projections.\n-                        if def.has_dtor(tcx) {\n-                            return true;\n-                        }\n+                (ProjectionElem::Field { .. }, ty::Adt(def, _), AccessDepth::Drop) => {\n+                    // Drop can read/write arbitrary projections, so places\n+                    // conflict regardless of further projections.\n+                    if def.has_dtor(tcx) {\n+                        return true;\n                     }\n+                }\n \n-                    (ProjectionElem::Deref, _, Deep)\n-                    | (ProjectionElem::Deref, _, AccessDepth::Drop)\n-                    | (ProjectionElem::Field { .. }, _, _)\n-                    | (ProjectionElem::Index { .. }, _, _)\n-                    | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                    | (ProjectionElem::Subslice { .. }, _, _)\n-                    | (ProjectionElem::Downcast { .. }, _, _) => {\n-                        // Recursive case. This can still be disjoint on a\n-                        // further iteration if this a shallow access and\n-                        // there's a deref later on, e.g., a borrow\n-                        // of `*x.y` while accessing `x`.\n-                    }\n+                (ProjectionElem::Deref, _, Deep)\n+                | (ProjectionElem::Deref, _, AccessDepth::Drop)\n+                | (ProjectionElem::Field { .. }, _, _)\n+                | (ProjectionElem::Index { .. }, _, _)\n+                | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                | (ProjectionElem::Subslice { .. }, _, _)\n+                | (ProjectionElem::Downcast { .. }, _, _) => {\n+                    // Recursive case. This can still be disjoint on a\n+                    // further iteration if this a shallow access and\n+                    // there's a deref later on, e.g., a borrow\n+                    // of `*x.y` while accessing `x`.\n                 }\n             }\n-        } else {\n-            // Borrow path ran out but access path may not\n-            // have. Examples:\n-            //\n-            // - borrow of `a.b`, access to `a.b.c`\n-            // - borrow of `a.b`, access to `a.b`\n-            //\n-            // In the first example, where we didn't run out of\n-            // access, the borrow can access all of our place, so we\n-            // have a conflict.\n-            //\n-            // If the second example, where we did, then we still know\n-            // that the borrow can access a *part* of our place that\n-            // our access cares about, so we still have a conflict.\n-            if borrow_kind == BorrowKind::Shallow && access_projections.next().is_some() {\n-                debug!(\"borrow_conflicts_with_place: shallow borrow\");\n-                return false;\n-            } else {\n-                debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n-                return true;\n-            }\n         }\n     }\n+\n+    // Borrow path ran out but access path may not\n+    // have. Examples:\n+    //\n+    // - borrow of `a.b`, access to `a.b.c`\n+    // - borrow of `a.b`, access to `a.b`\n+    //\n+    // In the first example, where we didn't run out of\n+    // access, the borrow can access all of our place, so we\n+    // have a conflict.\n+    //\n+    // If the second example, where we did, then we still know\n+    // that the borrow can access a *part* of our place that\n+    // our access cares about, so we still have a conflict.\n+    if borrow_kind == BorrowKind::Shallow\n+        && borrow_place.projection.len() < access_place.projection.len()\n+    {\n+        debug!(\"borrow_conflicts_with_place: shallow borrow\");\n+        false\n+    } else {\n+        debug!(\"borrow_conflicts_with_place: full borrow, CONFLICT\");\n+        true\n+    }\n }\n \n // Given that the bases of `elem1` and `elem2` are always either equal\n@@ -381,11 +386,12 @@ fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     pi1_base: &PlaceBase<'tcx>,\n-    pi1: &Projection<'tcx>,\n-    pi2: &Projection<'tcx>,\n+    pi1_proj_base: &[PlaceElem<'tcx>],\n+    pi1_elem: &PlaceElem<'tcx>,\n+    pi2_elem: &PlaceElem<'tcx>,\n     bias: PlaceConflictBias,\n ) -> Overlap {\n-    match (&pi1.elem, &pi2.elem) {\n+    match (pi1_elem, pi2_elem) {\n         (ProjectionElem::Deref, ProjectionElem::Deref) => {\n             // derefs (e.g., `*x` vs. `*x`) - recur.\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n@@ -397,7 +403,7 @@ fn place_projection_conflict<'tcx>(\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-FIELD\");\n                 Overlap::EqualOrDisjoint\n             } else {\n-                let ty = Place::ty_from(pi1_base, &pi1.base, body, tcx).ty;\n+                let ty = Place::ty_from(pi1_base, pi1_proj_base, body, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.is_union() => {\n                         // Different fields of a union, we are basically stuck.\n@@ -493,7 +499,7 @@ fn place_projection_conflict<'tcx>(\n             // element (like -1 in Python) and `min_length` the first.\n             // Therefore, `min_length - offset_from_end` gives the minimal possible\n             // offset from the beginning\n-            if *offset_from_begin >= min_length - offset_from_end {\n+            if *offset_from_begin >= *min_length - *offset_from_end {\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-ARRAY-CONSTANT-INDEX-FE\");\n                 Overlap::EqualOrDisjoint\n             } else {\n@@ -538,8 +544,8 @@ fn place_projection_conflict<'tcx>(\n         | (ProjectionElem::Subslice { .. }, _)\n         | (ProjectionElem::Downcast(..), _) => bug!(\n             \"mismatched projections in place_element_conflict: {:?} and {:?}\",\n-            pi1,\n-            pi2\n+            pi1_elem,\n+            pi2_elem\n         ),\n     }\n }"}, {"sha": "0a268ec1340233ed425159ec283ffab59a9e955c", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 97, "deletions": 104, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -19,17 +19,9 @@ pub trait IsPrefixOf<'cx, 'tcx> {\n \n impl<'cx, 'tcx> IsPrefixOf<'cx, 'tcx> for PlaceRef<'cx, 'tcx> {\n     fn is_prefix_of(&self, other: PlaceRef<'cx, 'tcx>) -> bool {\n-        let mut cursor = other.projection;\n-        loop {\n-            if self.projection == cursor {\n-                return self.base == other.base;\n-            }\n-\n-            match cursor {\n-                None => return false,\n-                Some(proj) => cursor = &proj.base,\n-            }\n-        }\n+        self.base == other.base\n+            && self.projection.len() <= other.projection.len()\n+            && self.projection == &other.projection[..self.projection.len()]\n     }\n }\n \n@@ -81,112 +73,113 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n         // downcasts here, but may return a base of a downcast).\n \n         'cursor: loop {\n-            let proj = match &cursor {\n+            match &cursor {\n                 PlaceRef {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n+                    projection: [],\n                 }\n                 | // search yielded this leaf\n                 PlaceRef {\n                     base: PlaceBase::Static(_),\n-                    projection: None,\n+                    projection: [],\n                 } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n                 PlaceRef {\n                     base: _,\n-                    projection: Some(proj),\n-                } => proj,\n-            };\n-\n-            match proj.elem {\n-                ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n-                    // FIXME: add union handling\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-                ProjectionElem::Downcast(..) |\n-                ProjectionElem::Subslice { .. } |\n-                ProjectionElem::ConstantIndex { .. } |\n-                ProjectionElem::Index(_) => {\n-                    cursor = PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    };\n-                    continue 'cursor;\n-                }\n-                ProjectionElem::Deref => {\n-                    // (handled below)\n-                }\n-            }\n-\n-            assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-            match self.kind {\n-                PrefixSet::Shallow => {\n-                    // shallow prefixes are found by stripping away\n-                    // fields, but stop at *any* dereference.\n-                    // So we can just stop the traversal now.\n-                    self.next = None;\n-                    return Some(cursor);\n-                }\n-                PrefixSet::All => {\n-                    // all prefixes: just blindly enqueue the base\n-                    // of the projection.\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-                PrefixSet::Supporting => {\n-                    // fall through!\n-                }\n-            }\n-\n-            assert_eq!(self.kind, PrefixSet::Supporting);\n-            // supporting prefixes: strip away fields and\n-            // derefs, except we stop at the deref of a shared\n-            // reference.\n-\n-            let ty = Place::ty_from(cursor.base, &proj.base, self.body, self.tcx).ty;\n-            match ty.sty {\n-                ty::RawPtr(_) |\n-                ty::Ref(\n-                    _, /*rgn*/\n-                    _, /*ty*/\n-                    hir::MutImmutable\n-                    ) => {\n-                    // don't continue traversing over derefs of raw pointers or shared borrows.\n-                    self.next = None;\n-                    return Some(cursor);\n-                }\n-\n-                ty::Ref(\n-                    _, /*rgn*/\n-                    _, /*ty*/\n-                    hir::MutMutable,\n-                    ) => {\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n-                }\n-\n-                ty::Adt(..) if ty.is_box() => {\n-                    self.next = Some(PlaceRef {\n-                        base: cursor.base,\n-                        projection: &proj.base,\n-                    });\n-                    return Some(cursor);\n+                    projection: [proj_base @ .., elem],\n+                } => {\n+                    match elem {\n+                        ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(_) => {\n+                            cursor = PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            };\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(*elem, ProjectionElem::Deref);\n+\n+                    match self.kind {\n+                        PrefixSet::Shallow => {\n+                            // Shallow prefixes are found by stripping away\n+                            // fields, but stop at *any* dereference.\n+                            // So we can just stop the traversal now.\n+                            self.next = None;\n+                            return Some(cursor);\n+                        }\n+                        PrefixSet::All => {\n+                            // All prefixes: just blindly enqueue the base\n+                            // of the projection.\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+                        PrefixSet::Supporting => {\n+                            // Fall through!\n+                        }\n+                    }\n+\n+                    assert_eq!(self.kind, PrefixSet::Supporting);\n+                    // Supporting prefixes: strip away fields and\n+                    // derefs, except we stop at the deref of a shared\n+                    // reference.\n+\n+                    let ty = Place::ty_from(cursor.base, proj_base, self.body, self.tcx).ty;\n+                    match ty.sty {\n+                        ty::RawPtr(_) |\n+                        ty::Ref(\n+                            _, /*rgn*/\n+                            _, /*ty*/\n+                            hir::MutImmutable\n+                            ) => {\n+                            // don't continue traversing over derefs of raw pointers or shared\n+                            // borrows.\n+                            self.next = None;\n+                            return Some(cursor);\n+                        }\n+\n+                        ty::Ref(\n+                            _, /*rgn*/\n+                            _, /*ty*/\n+                            hir::MutMutable,\n+                            ) => {\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+\n+                        ty::Adt(..) if ty.is_box() => {\n+                            self.next = Some(PlaceRef {\n+                                base: cursor.base,\n+                                projection: proj_base,\n+                            });\n+                            return Some(cursor);\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n                 }\n-\n-                _ => panic!(\"unknown type fed to Projection Deref.\"),\n             }\n         }\n     }"}, {"sha": "695080dfe23d90e2e41b0d7ef870b576d3e17930", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -89,7 +89,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n         _location: Location,\n     ) {\n         match &statement.kind {\n-            StatementKind::Assign(into, _) => {\n+            StatementKind::Assign(box(into, _)) => {\n                 if let PlaceBase::Local(local) = into.base {\n                     debug!(\n                         \"visit_statement: statement={:?} local={:?} \\\n@@ -120,7 +120,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                 );\n                 if let Place {\n                     base: PlaceBase::Local(user_local),\n-                    projection: None,\n+                    projection: box [],\n                 } = path.place {\n                     self.mbcx.used_mut.insert(user_local);\n                 }"}, {"sha": "3ed6b4ff346784c66e27a4fc17a664ece3acae91", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> CFG<'tcx> {\n                        rvalue: Rvalue<'tcx>) {\n         self.push(block, Statement {\n             source_info,\n-            kind: StatementKind::Assign(place.clone(), box rvalue)\n+            kind: StatementKind::Assign(box(place.clone(), rvalue))\n         });\n     }\n "}, {"sha": "09b33c6654a9db084a0bc431d1ed99bc81e54ec8", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     kind: StaticKind::Static,\n                     def_id: id,\n                 })),\n-                projection: None,\n+                projection: box [],\n             }),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n@@ -147,9 +147,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n-                                place.clone(),\n+                                box(\n+                                    place.clone(),\n+                                    UserTypeProjection { base: annotation_index, projs: vec![], }\n+                                ),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );\n@@ -174,9 +176,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n-                                Place::from(temp.clone()),\n+                                box(\n+                                    Place::from(temp.clone()),\n+                                    UserTypeProjection { base: annotation_index, projs: vec![], },\n+                                ),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );"}, {"sha": "7dfe98cbebfc27f0e09d07d55de1138eaf344c8d", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -500,14 +500,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let mutability = match arg_place {\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             } => this.local_decls[local].mutability,\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                })\n+                projection: box [ProjectionElem::Deref],\n             } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n@@ -517,24 +514,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             Place {\n                 ref base,\n-                projection: Some(box Projection {\n-                    base: ref base_proj,\n-                    elem: ProjectionElem::Field(upvar_index, _),\n-                }),\n+                projection: box [ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n             | Place {\n                 ref base,\n-                projection: Some(box Projection {\n-                    base: Some(box Projection {\n-                        base: ref base_proj,\n-                        elem: ProjectionElem::Field(upvar_index, _),\n-                    }),\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: box [\n+                    ref proj_base @ ..,\n+                    ProjectionElem::Field(upvar_index, _),\n+                    ProjectionElem::Deref\n+                ],\n             } => {\n                 let place = PlaceRef {\n                     base,\n-                    projection: base_proj,\n+                    projection: proj_base,\n                 };\n \n                 // Not projected from the implicit `self` in a closure."}, {"sha": "45f4a1685360624983dceb733a847435e4f11481", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -301,7 +301,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // Create a \"fake\" temporary variable so that we check that the\n                 // value is Sized. Usually, this is caught in type checking, but\n                 // in the case of box expr there is no such check.\n-                if destination.projection.is_some() {\n+                if !destination.projection.is_empty() {\n                     this.local_decls\n                         .push(LocalDecl::new_temp(expr.ty, expr.span));\n                 }"}, {"sha": "aa261f8eb6fb293003a6d9a091be89acd750d862", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             source_info,\n             kind: StatementKind::FakeRead(\n                 FakeReadCause::ForMatchedPlace,\n-                scrutinee_place.clone(),\n+                box(scrutinee_place.clone()),\n             ),\n         });\n \n@@ -320,7 +320,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     block,\n                     Statement {\n                         source_info,\n-                        kind: StatementKind::FakeRead(FakeReadCause::ForLet, place),\n+                        kind: StatementKind::FakeRead(FakeReadCause::ForLet, box(place)),\n                     },\n                 );\n \n@@ -362,12 +362,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     block,\n                     Statement {\n                         source_info: pattern_source_info,\n-                        kind: StatementKind::FakeRead(FakeReadCause::ForLet, place.clone()),\n+                        kind: StatementKind::FakeRead(FakeReadCause::ForLet, box(place.clone())),\n                     },\n                 );\n \n                 let ty_source_info = self.source_info(user_ty_span);\n-                let user_ty = box pat_ascription_ty.user_ty(\n+                let user_ty = pat_ascription_ty.user_ty(\n                     &mut self.canonical_user_type_annotations,\n                     place.ty(&self.local_decls, self.hir.tcx()).ty,\n                     ty_source_info.span,\n@@ -377,7 +377,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Statement {\n                         source_info: ty_source_info,\n                         kind: StatementKind::AscribeUserType(\n-                            place,\n+                            box(\n+                                place,\n+                                user_ty,\n+                            ),\n                             // We always use invariant as the variance here. This is because the\n                             // variance field from the ascription refers to the variance to use\n                             // when applying the type to the value being matched, but this\n@@ -393,7 +396,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             // contrast, is intended to be used to relate `T` to the type of\n                             // `<expr>`.\n                             ty::Variance::Invariant,\n-                            user_ty,\n                         ),\n                     },\n                 );\n@@ -942,16 +944,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for Binding { source, .. }\n                 in matched_candidates.iter().flat_map(|candidate| &candidate.bindings)\n             {\n-                let mut cursor = &source.projection;\n-                while let Some(box Projection { base, elem }) = cursor {\n-                    cursor = base;\n-                    if let ProjectionElem::Deref = elem {\n-                        fake_borrows.insert(Place {\n-                            base: source.base.clone(),\n-                            projection: cursor.clone(),\n-                        });\n-                        break;\n-                    }\n+                if let Some(i) =\n+                    source.projection.iter().rposition(|elem| *elem == ProjectionElem::Deref)\n+                {\n+                    let proj_base = &source.projection[..i];\n+\n+                    fake_borrows.insert(Place {\n+                        base: source.base.clone(),\n+                        projection: proj_base.to_vec().into_boxed_slice(),\n+                    });\n                 }\n             }\n         }\n@@ -1295,18 +1296,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n         for place in fake_borrows\n         {\n-            let mut prefix_cursor = &place.projection;\n-            while let Some(box Projection { base, elem }) = prefix_cursor {\n+            for (i, elem) in place.projection.iter().enumerate().rev() {\n+                let proj_base = &place.projection[..i];\n+\n                 if let ProjectionElem::Deref = elem {\n                     // Insert a shallow borrow after a deref. For other\n                     // projections the borrow of prefix_cursor will\n                     // conflict with any mutation of base.\n                     all_fake_borrows.push(PlaceRef {\n                         base: &place.base,\n-                        projection: base,\n+                        projection: proj_base,\n                     });\n                 }\n-                prefix_cursor = base;\n             }\n \n             all_fake_borrows.push(place.as_ref());\n@@ -1489,7 +1490,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     BorrowKind::Shallow,\n                     Place {\n                         base: place.base.clone(),\n-                        projection: place.projection.clone(),\n+                        projection: place.projection.to_vec().into_boxed_slice(),\n                     },\n                 );\n                 self.cfg.push_assign(\n@@ -1520,7 +1521,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     source_info: guard_end,\n                     kind: StatementKind::FakeRead(\n                         FakeReadCause::ForMatchGuard,\n-                        Place::from(temp),\n+                        box(Place::from(temp)),\n                     ),\n                 });\n             }\n@@ -1570,7 +1571,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     post_guard_block,\n                     Statement {\n                         source_info: guard_end,\n-                        kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, place),\n+                        kind: StatementKind::FakeRead(FakeReadCause::ForGuardBinding, box(place)),\n                     },\n                 );\n             }\n@@ -1603,7 +1604,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription.user_ty,\n             );\n \n-            let user_ty = box ascription.user_ty.clone().user_ty(\n+            let user_ty = ascription.user_ty.clone().user_ty(\n                 &mut self.canonical_user_type_annotations,\n                 ascription.source.ty(&self.local_decls, self.hir.tcx()).ty,\n                 source_info.span\n@@ -1613,9 +1614,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Statement {\n                     source_info,\n                     kind: StatementKind::AscribeUserType(\n-                        ascription.source.clone(),\n+                        box(\n+                            ascription.source.clone(),\n+                            user_ty,\n+                        ),\n                         ascription.variance,\n-                        user_ty,\n                     ),\n                 },\n             );"}, {"sha": "647d7515fe98df36baad06b6f4386c05100fcbe4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -609,7 +609,7 @@ where\n         unpack!(block = builder.in_breakable_scope(\n             None,\n             START_BLOCK,\n-            Place::RETURN_PLACE,\n+            Place::return_place(),\n             |builder| {\n                 builder.in_scope(arg_scope_s, LintLevel::Inherited, |builder| {\n                     builder.args_and_body(block, &arguments, arg_scope, &body.value)\n@@ -670,7 +670,7 @@ fn construct_const<'a, 'tcx>(\n     let mut block = START_BLOCK;\n     let ast_expr = &tcx.hir().body(body_id).value;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Place::RETURN_PLACE, block, expr));\n+    unpack!(block = builder.into_expr(&Place::return_place(), block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -871,7 +871,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::RETURN_PLACE, block, body)\n+        self.into(&Place::return_place(), block, body)\n     }\n \n     fn set_correct_source_scope_for_arg("}, {"sha": "ee6d42de388d9bd0ecbdf122fd1dfd33d45c8d06", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -314,7 +314,7 @@ impl<'tcx> Scopes<'tcx> {\n         match target {\n             BreakableTarget::Return => {\n                 let scope = &self.breakable_scopes[0];\n-                if scope.break_destination != Place::RETURN_PLACE {\n+                if scope.break_destination != Place::return_place() {\n                     span_bug!(span, \"`return` in item with no return scope\");\n                 }\n                 (scope.break_block, scope.region_scope, Some(scope.break_destination.clone()))\n@@ -853,11 +853,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             _ if self.local_scope().is_none() => (),\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(cond_temp),\n-                projection: None,\n+                projection: box [],\n             })\n             | Operand::Move(Place {\n                 base: PlaceBase::Local(cond_temp),\n-                projection: None,\n+                projection: box [],\n             }) => {\n                 // Manually drop the condition on both branches.\n                 let top_scope = self.scopes.scopes.last_mut().unwrap();"}, {"sha": "444cc008ae785432f1ed2165e45c8e7f2dec896b", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -10,19 +10,17 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n                                         path: MovePathIndex,\n                                         mut cond: F)\n                                         -> Option<MovePathIndex>\n-    where F: FnMut(&mir::Projection<'tcx>) -> bool\n+    where F: FnMut(&mir::PlaceElem<'tcx>) -> bool\n {\n     let mut next_child = move_data.move_paths[path].first_child;\n     while let Some(child_index) = next_child {\n-        match move_data.move_paths[child_index].place.projection {\n-            Some(ref proj) => {\n-                if cond(proj) {\n-                    return Some(child_index)\n-                }\n+        let move_path_children = &move_data.move_paths[child_index];\n+        if let Some(elem) = move_path_children.place.projection.last() {\n+            if cond(elem) {\n+                return Some(child_index)\n             }\n-            _ => {}\n         }\n-        next_child = move_data.move_paths[child_index].next_sibling;\n+        next_child = move_path_children.next_sibling;\n     }\n \n     None"}, {"sha": "a86fcb30f4d36ca97bbf7c94fec381eaf69e9834", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             // If the borrowed place is a local with no projections, all other borrows of this\n             // local must conflict. This is purely an optimization so we don't have to call\n             // `places_conflict` for every borrow.\n-            if place.projection.is_none() {\n+            if place.projection.is_empty() {\n                 trans.kill_all(other_borrows_of_local);\n                 return;\n             }\n@@ -268,8 +268,8 @@ impl<'a, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'tcx> {\n \n         debug!(\"Borrows::statement_effect: stmt={:?}\", stmt);\n         match stmt.kind {\n-            mir::StatementKind::Assign(ref lhs, ref rhs) => {\n-                if let mir::Rvalue::Ref(_, _, ref place) = **rhs {\n+            mir::StatementKind::Assign(box(ref lhs, ref rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, ref place) = *rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,"}, {"sha": "0f66b13fdc51af33d7404e3113583334aec274d9", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -119,8 +119,8 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         match stmt.kind {\n             StatementKind::StorageLive(l) => sets.gen(l),\n             StatementKind::StorageDead(l) => sets.kill(l),\n-            StatementKind::Assign(ref place, _)\n-            | StatementKind::SetDiscriminant { ref place, .. } => {\n+            StatementKind::Assign(box(ref place, _))\n+            | StatementKind::SetDiscriminant { box ref place, .. } => {\n                 if let PlaceBase::Local(local) = place.base {\n                     sets.gen(local);\n                 }"}, {"sha": "698c50166270a2bea6b3b5d684df8ded2d746a1b", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 67, "deletions": 68, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -94,72 +94,74 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n     fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n-        place.iterate(|place_base, place_projection| {\n-            let mut base = match place_base {\n-                PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[*local],\n-                PlaceBase::Static(..) => {\n-                    return Err(MoveError::cannot_move_out_of(self.loc, Static));\n-                }\n-            };\n+        let mut base = match place.base {\n+            PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[local],\n+            PlaceBase::Static(..) => {\n+                return Err(MoveError::cannot_move_out_of(self.loc, Static));\n+            }\n+        };\n \n-            for proj in place_projection {\n-                let body = self.builder.body;\n-                let tcx = self.builder.tcx;\n-                let place_ty = Place::ty_from(place_base, &proj.base, body, tcx).ty;\n-                match place_ty.sty {\n-                    ty::Ref(..) | ty::RawPtr(..) => {\n-                        return Err(MoveError::cannot_move_out_of(\n-                            self.loc,\n-                            BorrowedContent {\n-                                target_place: Place {\n-                                    base: place_base.clone(),\n-                                    projection: Some(Box::new(proj.clone())),\n-                                },\n+        for (i, elem) in place.projection.iter().enumerate() {\n+            let proj_base = &place.projection[..i];\n+            let body = self.builder.body;\n+            let tcx = self.builder.tcx;\n+            let place_ty = Place::ty_from(&place.base, proj_base, body, tcx).ty;\n+            match place_ty.sty {\n+                ty::Ref(..) | ty::RawPtr(..) => {\n+                    let proj = &place.projection[..i+1];\n+                    return Err(MoveError::cannot_move_out_of(\n+                        self.loc,\n+                        BorrowedContent {\n+                            target_place: Place {\n+                                base: place.base.clone(),\n+                                projection: proj.to_vec().into_boxed_slice(),\n                             },\n-                        ));\n-                    }\n-                    ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() => {\n+                        },\n+                    ));\n+                }\n+                ty::Adt(adt, _) if adt.has_dtor(tcx) && !adt.is_box() => {\n+                    return Err(MoveError::cannot_move_out_of(\n+                        self.loc,\n+                        InteriorOfTypeWithDestructor { container_ty: place_ty },\n+                    ));\n+                }\n+                // move out of union - always move the entire union\n+                ty::Adt(adt, _) if adt.is_union() => {\n+                    return Err(MoveError::UnionMove { path: base });\n+                }\n+                ty::Slice(_) => {\n+                    return Err(MoveError::cannot_move_out_of(\n+                        self.loc,\n+                        InteriorOfSliceOrArray {\n+                            ty: place_ty,\n+                            is_index: match elem {\n+                                ProjectionElem::Index(..) => true,\n+                                _ => false,\n+                            },\n+                        },\n+                    ));\n+                }\n+                ty::Array(..) => match elem {\n+                    ProjectionElem::Index(..) => {\n                         return Err(MoveError::cannot_move_out_of(\n                             self.loc,\n-                            InteriorOfTypeWithDestructor { container_ty: place_ty },\n+                            InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n                         ));\n                     }\n-                    // move out of union - always move the entire union\n-                    ty::Adt(adt, _) if adt.is_union() => {\n-                        return Err(MoveError::UnionMove { path: base });\n-                    }\n-                    ty::Slice(_) => {\n-                        return Err(MoveError::cannot_move_out_of(\n-                            self.loc,\n-                            InteriorOfSliceOrArray {\n-                                ty: place_ty,\n-                                is_index: match proj.elem {\n-                                    ProjectionElem::Index(..) => true,\n-                                    _ => false,\n-                                },\n-                            },\n-                        ));\n+                    _ => {\n+                        // FIXME: still badly broken\n                     }\n-                    ty::Array(..) => match proj.elem {\n-                        ProjectionElem::Index(..) => {\n-                            return Err(MoveError::cannot_move_out_of(\n-                                self.loc,\n-                                InteriorOfSliceOrArray { ty: place_ty, is_index: true },\n-                            ));\n-                        }\n-                        _ => {\n-                            // FIXME: still badly broken\n-                        }\n-                    },\n-                    _ => {}\n-                };\n+                },\n+                _ => {}\n+            };\n \n-                base = match self\n-                    .builder\n-                    .data\n-                    .rev_lookup\n-                    .projections\n-                    .entry((base, proj.elem.lift()))\n+            let proj = &place.projection[..i+1];\n+            base = match self\n+                .builder\n+                .data\n+                .rev_lookup\n+                .projections\n+                .entry((base, elem.lift()))\n                 {\n                     Entry::Occupied(ent) => *ent.get(),\n                     Entry::Vacant(ent) => {\n@@ -169,18 +171,17 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             &mut self.builder.data.init_path_map,\n                             Some(base),\n                             Place {\n-                                base: place_base.clone(),\n-                                projection: Some(Box::new(proj.clone())),\n+                                base: place.base.clone(),\n+                                projection: proj.to_vec().into_boxed_slice(),\n                             },\n                         );\n                         ent.insert(path);\n                         path\n                     }\n                 };\n-            }\n+        }\n \n-            Ok(base)\n-        })\n+        Ok(base)\n     }\n \n     fn create_move_path(&mut self, place: &Place<'tcx>) {\n@@ -267,7 +268,7 @@ struct Gatherer<'b, 'a, 'tcx> {\n impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n         match stmt.kind {\n-            StatementKind::Assign(ref place, ref rval) => {\n+            StatementKind::Assign(box(ref place, ref rval)) => {\n                 self.create_move_path(place);\n                 if let RvalueInitializationState::Shallow = rval.initialization_state() {\n                     // Box starts out uninitialized - need to create a separate\n@@ -355,7 +356,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Unreachable => {}\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Place::RETURN_PLACE);\n+                self.gather_move(&Place::return_place());\n             }\n \n             TerminatorKind::Assert { ref cond, .. } => {\n@@ -435,9 +436,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n \n         // Check if we are assigning into a field of a union, if so, lookup the place\n         // of the union so it is marked as initialized again.\n-        if let Some(box Projection { base: proj_base, elem: ProjectionElem::Field(_, _) }) =\n-            place.projection\n-        {\n+        if let [proj_base @ .., ProjectionElem::Field(_, _)] = place.projection {\n             if let ty::Adt(def, _) =\n                 Place::ty_from(place.base, proj_base, self.builder.body, self.builder.tcx).ty.sty\n             {"}, {"sha": "156c19c6363e58a74ffd4077f7af571112617979", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -245,23 +245,21 @@ impl MovePathLookup {\n     // alternative will *not* create a MovePath on the fly for an\n     // unknown place, but will rather return the nearest available\n     // parent.\n-    pub fn find(&self, place_ref: PlaceRef<'_, '_>) -> LookupResult {\n-        place_ref.iterate(|place_base, place_projection| {\n-            let mut result = match place_base {\n-                PlaceBase::Local(local) => self.locals[*local],\n-                PlaceBase::Static(..) => return LookupResult::Parent(None),\n-            };\n-\n-            for proj in place_projection {\n-                if let Some(&subpath) = self.projections.get(&(result, proj.elem.lift())) {\n-                    result = subpath;\n-                } else {\n-                    return LookupResult::Parent(Some(result));\n-                }\n+    pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n+        let mut result = match place.base {\n+            PlaceBase::Local(local) => self.locals[*local],\n+            PlaceBase::Static(..) => return LookupResult::Parent(None),\n+        };\n+\n+        for elem in place.projection.iter() {\n+            if let Some(&subpath) = self.projections.get(&(result, elem.lift())) {\n+                result = subpath;\n+            } else {\n+                return LookupResult::Parent(Some(result));\n             }\n+        }\n \n-            LookupResult::Exact(result)\n-        })\n+        LookupResult::Exact(result)\n     }\n \n     pub fn find_local(&self, local: Local) -> MovePathIndex {\n@@ -329,7 +327,7 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place { base: PlaceBase::Local(l), projection: None } = path.place {\n+            if let Place { base: PlaceBase::Local(l), projection: box [] } = path.place {\n                 return Some(l);\n             }\n             if let Some(parent) = path.parent {"}, {"sha": "06b7206f4292c8aca5edbdfd9581d868a98beee6", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -472,39 +472,37 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // avoid allocations.\n     pub(super) fn eval_place_to_op(\n         &self,\n-        mir_place: &mir::Place<'tcx>,\n+        place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::PlaceBase;\n \n-        mir_place.iterate(|place_base, place_projection| {\n-            let mut op = match place_base {\n-                PlaceBase::Local(mir::RETURN_PLACE) =>\n-                    throw_unsup!(ReadFromReturnPointer),\n-                PlaceBase::Local(local) => {\n-                    // Do not use the layout passed in as argument if the base we are looking at\n-                    // here is not the entire place.\n-                    // FIXME use place_projection.is_empty() when is available\n-                    let layout = if mir_place.projection.is_none() {\n-                        layout\n-                    } else {\n-                        None\n-                    };\n-\n-                    self.access_local(self.frame(), *local, layout)?\n-                }\n-                PlaceBase::Static(place_static) => {\n-                    self.eval_static_to_mplace(place_static)?.into()\n-                }\n-            };\n+        let mut op = match &place.base {\n+            PlaceBase::Local(mir::RETURN_PLACE) =>\n+                throw_unsup!(ReadFromReturnPointer),\n+            PlaceBase::Local(local) => {\n+                // Do not use the layout passed in as argument if the base we are looking at\n+                // here is not the entire place.\n+                // FIXME use place_projection.is_empty() when is available\n+                let layout = if place.projection.is_empty() {\n+                    layout\n+                } else {\n+                    None\n+                };\n \n-            for proj in place_projection {\n-                op = self.operand_projection(op, &proj.elem)?\n+                self.access_local(self.frame(), *local, layout)?\n+            }\n+            PlaceBase::Static(place_static) => {\n+                self.eval_static_to_mplace(&place_static)?.into()\n             }\n+        };\n \n-            trace!(\"eval_place_to_op: got {:?}\", *op);\n-            Ok(op)\n-        })\n+        for elem in place.projection.iter() {\n+            op = self.operand_projection(op, elem)?\n+        }\n+\n+        trace!(\"eval_place_to_op: got {:?}\", *op);\n+        Ok(op)\n     }\n \n     /// Evaluate the operand, returning a place where you can then find the data."}, {"sha": "1a28548618206a2afb95d0c6c182e9ff80765e3b", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -629,45 +629,43 @@ where\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n-        mir_place: &mir::Place<'tcx>,\n+        place: &mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::PlaceBase;\n \n-        mir_place.iterate(|place_base, place_projection| {\n-            let mut place = match place_base {\n-                PlaceBase::Local(mir::RETURN_PLACE) => match self.frame().return_place {\n-                    Some(return_place) => {\n-                        // We use our layout to verify our assumption; caller will validate\n-                        // their layout on return.\n-                        PlaceTy {\n-                            place: *return_place,\n-                            layout: self.layout_of(\n-                                self.subst_from_frame_and_normalize_erasing_regions(\n-                                    self.frame().body.return_ty()\n-                                )\n-                            )?,\n-                        }\n+        let mut place_ty = match &place.base {\n+            PlaceBase::Local(mir::RETURN_PLACE) => match self.frame().return_place {\n+                Some(return_place) => {\n+                    // We use our layout to verify our assumption; caller will validate\n+                    // their layout on return.\n+                    PlaceTy {\n+                        place: *return_place,\n+                        layout: self.layout_of(\n+                            self.subst_from_frame_and_normalize_erasing_regions(\n+                                self.frame().body.return_ty()\n+                            )\n+                        )?,\n                     }\n-                    None => throw_unsup!(InvalidNullPointerUsage),\n-                },\n-                PlaceBase::Local(local) => PlaceTy {\n-                    // This works even for dead/uninitialized locals; we check further when writing\n-                    place: Place::Local {\n-                        frame: self.cur_frame(),\n-                        local: *local,\n-                    },\n-                    layout: self.layout_of_local(self.frame(), *local, None)?,\n+                }\n+                None => throw_unsup!(InvalidNullPointerUsage),\n+            },\n+            PlaceBase::Local(local) => PlaceTy {\n+                // This works even for dead/uninitialized locals; we check further when writing\n+                place: Place::Local {\n+                    frame: self.cur_frame(),\n+                    local: *local,\n                 },\n-                PlaceBase::Static(place_static) => self.eval_static_to_mplace(place_static)?.into(),\n-            };\n+                layout: self.layout_of_local(self.frame(), *local, None)?,\n+            },\n+            PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n+        };\n \n-            for proj in place_projection {\n-                place = self.place_projection(place, &proj.elem)?\n-            }\n+        for elem in place.projection.iter() {\n+            place_ty = self.place_projection(place_ty, elem)?\n+        }\n \n-            self.dump_place(place.place);\n-            Ok(place)\n-        })\n+        self.dump_place(place_ty.place);\n+        Ok(place_ty)\n     }\n \n     /// Write a scalar to a place"}, {"sha": "affca10bf5265e01db586b9e71eb60e50185841f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -82,7 +82,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.memory.tcx.span = stmt.source_info.span;\n \n         match stmt.kind {\n-            Assign(ref place, ref rvalue) => self.eval_rvalue_into_place(rvalue, place)?,\n+            Assign(box(ref place, ref rvalue)) => self.eval_rvalue_into_place(rvalue, place)?,\n \n             SetDiscriminant {\n                 ref place,"}, {"sha": "8310ef02f96692798446d5222fe862da2f257f8d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -391,7 +391,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n                         let callee_ret = self.eval_place(\n-                            &mir::Place::RETURN_PLACE\n+                            &mir::Place::return_place()\n                         )?;\n                         if !Self::check_argument_compat(\n                             rust_abi,"}, {"sha": "6daca5e261431f7d4149c79b1945badd4e355f53", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -217,7 +217,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n             // Function arguments should be retagged, and we make this one raw.\n             body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n                 source_info,\n-                kind: StatementKind::Retag(RetagKind::Raw, dropee_ptr.clone()),\n+                kind: StatementKind::Retag(RetagKind::Raw, box(dropee_ptr.clone())),\n             });\n         }\n         let patch = {\n@@ -308,7 +308,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env, builder.span);\n \n-    let dest = Place::RETURN_PLACE;\n+    let dest = Place::return_place();\n     let src = Place::from(Local::new(1+0)).deref();\n \n     match self_ty.sty {\n@@ -415,8 +415,10 @@ impl CloneShimBuilder<'tcx> {\n         let rcvr = Place::from(Local::new(1+0)).deref();\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::RETURN_PLACE,\n-                box Rvalue::Use(Operand::Copy(rcvr))\n+                box(\n+                    Place::return_place(),\n+                    Rvalue::Use(Operand::Copy(rcvr))\n+                )\n             )\n         );\n         self.block(vec![ret_statement], TerminatorKind::Return, false);\n@@ -458,8 +460,10 @@ impl CloneShimBuilder<'tcx> {\n         // `let ref_loc: &ty = &src;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n-                ref_loc.clone(),\n-                box Rvalue::Ref(tcx.lifetimes.re_erased, BorrowKind::Shared, src)\n+                box(\n+                    ref_loc.clone(),\n+                    Rvalue::Ref(tcx.lifetimes.re_erased, BorrowKind::Shared, src)\n+                )\n             )\n         );\n \n@@ -486,8 +490,10 @@ impl CloneShimBuilder<'tcx> {\n         let cond = self.make_place(Mutability::Mut, tcx.types.bool);\n         let compute_cond = self.make_statement(\n             StatementKind::Assign(\n-                cond.clone(),\n-                box Rvalue::BinaryOp(BinOp::Ne, Operand::Copy(end), Operand::Copy(beg))\n+                box(\n+                    cond.clone(),\n+                    Rvalue::BinaryOp(BinOp::Ne, Operand::Copy(end), Operand::Copy(beg))\n+                )\n             )\n         );\n \n@@ -521,14 +527,18 @@ impl CloneShimBuilder<'tcx> {\n         let inits = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Place::from(beg),\n-                    box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                    box(\n+                        Place::from(beg),\n+                        Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                    )\n                 )\n             ),\n             self.make_statement(\n                 StatementKind::Assign(\n-                    end.clone(),\n-                    box Rvalue::Use(Operand::Constant(self.make_usize(len)))\n+                    box(\n+                        end.clone(),\n+                        Rvalue::Use(Operand::Constant(self.make_usize(len)))\n+                    )\n                 )\n             )\n         ];\n@@ -559,11 +569,13 @@ impl CloneShimBuilder<'tcx> {\n         let statements = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Place::from(beg),\n-                    box Rvalue::BinaryOp(\n-                        BinOp::Add,\n-                        Operand::Copy(Place::from(beg)),\n-                        Operand::Constant(self.make_usize(1))\n+                    box(\n+                        Place::from(beg),\n+                        Rvalue::BinaryOp(\n+                            BinOp::Add,\n+                            Operand::Copy(Place::from(beg)),\n+                            Operand::Constant(self.make_usize(1))\n+                        )\n                     )\n                 )\n             )\n@@ -582,8 +594,10 @@ impl CloneShimBuilder<'tcx> {\n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let init = self.make_statement(\n             StatementKind::Assign(\n-                Place::from(beg),\n-                box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                box(\n+                    Place::from(beg),\n+                    Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                )\n             )\n         );\n         self.block(vec![init], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n@@ -609,11 +623,13 @@ impl CloneShimBuilder<'tcx> {\n         // `goto #6;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::from(beg),\n-                box Rvalue::BinaryOp(\n-                    BinOp::Add,\n-                    Operand::Copy(Place::from(beg)),\n-                    Operand::Constant(self.make_usize(1))\n+                box(\n+                    Place::from(beg),\n+                    Rvalue::BinaryOp(\n+                        BinOp::Add,\n+                        Operand::Copy(Place::from(beg)),\n+                        Operand::Constant(self.make_usize(1))\n+                    )\n                 )\n             )\n         );\n@@ -727,8 +743,10 @@ fn build_call_shim<'tcx>(\n             statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(\n-                    Place::from(ref_rcvr),\n-                    box Rvalue::Ref(tcx.lifetimes.re_erased, borrow_kind, rcvr_l)\n+                    box(\n+                        Place::from(ref_rcvr),\n+                        Rvalue::Ref(tcx.lifetimes.re_erased, borrow_kind, rcvr_l)\n+                    )\n                 )\n             });\n             Operand::Move(Place::from(ref_rcvr))\n@@ -773,7 +791,7 @@ fn build_call_shim<'tcx>(\n     block(&mut blocks, statements, TerminatorKind::Call {\n         func: callee,\n         args,\n-        destination: Some((Place::RETURN_PLACE,\n+        destination: Some((Place::return_place(),\n                            BasicBlock::new(1))),\n         cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n             Some(BasicBlock::new(3))\n@@ -868,7 +886,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n     debug!(\"build_ctor: variant_index={:?}\", variant_index);\n \n     let statements = expand_aggregate(\n-        Place::RETURN_PLACE,\n+        Place::return_place(),\n         adt_def\n             .variants[variant_index]\n             .fields"}, {"sha": "833c8b1646bb68d2ec31ad55f5db9a8809c927e2", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -17,12 +17,11 @@ pub struct AddRetag;\n fn is_stable(\n     place: PlaceRef<'_, '_>,\n ) -> bool {\n-    if let Some(proj) = &place.projection {\n-        match proj.elem {\n+    place.projection.iter().all(|elem| {\n+        match elem {\n             // Which place this evaluates to can change with any memory write,\n             // so cannot assume this to be stable.\n-            ProjectionElem::Deref =>\n-                false,\n+            ProjectionElem::Deref => false,\n             // Array indices are intersting, but MIR building generates a *fresh*\n             // temporary for every array access, so the index cannot be changed as\n             // a side-effect.\n@@ -31,15 +30,9 @@ fn is_stable(\n             ProjectionElem::Field { .. } |\n             ProjectionElem::ConstantIndex { .. } |\n             ProjectionElem::Subslice { .. } |\n-            ProjectionElem::Downcast { .. } =>\n-                is_stable(PlaceRef {\n-                    base: place.base,\n-                    projection: &proj.base,\n-                }),\n+            ProjectionElem::Downcast { .. } => true,\n         }\n-    } else {\n-        true\n-    }\n+    })\n }\n \n /// Determine whether this type may be a reference (or box), and thus needs retagging.\n@@ -96,7 +89,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             basic_blocks[START_BLOCK].statements.splice(0..0,\n                 places.into_iter().map(|place| Statement {\n                     source_info,\n-                    kind: StatementKind::Retag(RetagKind::FnEntry, place),\n+                    kind: StatementKind::Retag(RetagKind::FnEntry, box(place)),\n                 })\n             );\n         }\n@@ -132,7 +125,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         for (source_info, dest_place, dest_block) in returns {\n             basic_blocks[dest_block].statements.insert(0, Statement {\n                 source_info,\n-                kind: StatementKind::Retag(RetagKind::Default, dest_place),\n+                kind: StatementKind::Retag(RetagKind::Default, box(dest_place)),\n             });\n         }\n \n@@ -144,11 +137,11 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n                     // If we are casting *from* a reference, we may have to retag-as-raw.\n-                    StatementKind::Assign(ref place, box Rvalue::Cast(\n+                    StatementKind::Assign(box(ref place, Rvalue::Cast(\n                         CastKind::Misc,\n                         ref src,\n                         dest_ty,\n-                    )) => {\n+                    ))) => {\n                         let src_ty = src.ty(&*local_decls, tcx);\n                         if src_ty.is_region_ptr() {\n                             // The only `Misc` casts on references are those creating raw pointers.\n@@ -162,7 +155,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n                     // Assignments of reference or ptr type are the ones where we may have\n                     // to update tags.  This includes `x = &[mut] ...` and hence\n                     // we also retag after taking a reference!\n-                    StatementKind::Assign(ref place, box ref rvalue) if needs_retag(place) => {\n+                    StatementKind::Assign(box(ref place, ref rvalue)) if needs_retag(place) => {\n                         let kind = match rvalue {\n                             Rvalue::Ref(_, borrow_kind, _)\n                                 if borrow_kind.allows_two_phase_borrow()\n@@ -180,7 +173,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n                 let source_info = block_data.statements[i].source_info;\n                 block_data.statements.insert(i+1, Statement {\n                     source_info,\n-                    kind: StatementKind::Retag(retag_kind, place),\n+                    kind: StatementKind::Retag(retag_kind, box(place)),\n                 });\n             }\n         }"}, {"sha": "f8af9b9fcbee0c8da760767172501039a5d2d309", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 113, "deletions": 113, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -200,127 +200,127 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     place: &Place<'tcx>,\n                     context: PlaceContext,\n                     _location: Location) {\n-        place.iterate(|place_base, place_projections| {\n-            match place_base {\n-                PlaceBase::Local(..) => {\n-                    // Locals are safe.\n-                }\n-                PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n-                    bug!(\"unsafety checking should happen before promotion\")\n-                }\n-                PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n-                    if self.tcx.is_mutable_static(*def_id) {\n-                        self.require_unsafe(\"use of mutable static\",\n-                            \"mutable statics can be mutated by multiple threads: aliasing \\\n-                             violations or data races will cause undefined behavior\",\n-                             UnsafetyViolationKind::General);\n-                    } else if self.tcx.is_foreign_item(*def_id) {\n-                        let source_info = self.source_info;\n-                        let lint_root =\n-                            self.source_scope_local_data[source_info.scope].lint_root;\n-                        self.register_violations(&[UnsafetyViolation {\n-                            source_info,\n-                            description: InternedString::intern(\"use of extern static\"),\n-                            details: InternedString::intern(\n-                                \"extern statics are not controlled by the Rust type system: \\\n-                                invalid data, aliasing violations or data races will cause \\\n-                                undefined behavior\"),\n-                            kind: UnsafetyViolationKind::ExternStatic(lint_root)\n-                        }], &[]);\n-                    }\n+        match place.base {\n+            PlaceBase::Local(..) => {\n+                // Locals are safe.\n+            }\n+            PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => {\n+                bug!(\"unsafety checking should happen before promotion\")\n+            }\n+            PlaceBase::Static(box Static { kind: StaticKind::Static, def_id, .. }) => {\n+                if self.tcx.is_mutable_static(def_id) {\n+                    self.require_unsafe(\"use of mutable static\",\n+                        \"mutable statics can be mutated by multiple threads: aliasing \\\n+                         violations or data races will cause undefined behavior\",\n+                         UnsafetyViolationKind::General);\n+                } else if self.tcx.is_foreign_item(def_id) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.source_scope_local_data[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: InternedString::intern(\"use of extern static\"),\n+                        details: InternedString::intern(\n+                            \"extern statics are not controlled by the Rust type system: \\\n+                            invalid data, aliasing violations or data races will cause \\\n+                            undefined behavior\"),\n+                        kind: UnsafetyViolationKind::ExternStatic(lint_root)\n+                    }], &[]);\n                 }\n             }\n+        }\n \n-            for proj in place_projections {\n-                if context.is_borrow() {\n-                    if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n-                        let source_info = self.source_info;\n-                        let lint_root =\n-                            self.source_scope_local_data[source_info.scope].lint_root;\n-                        self.register_violations(&[UnsafetyViolation {\n-                            source_info,\n-                            description: InternedString::intern(\"borrow of packed field\"),\n-                            details: InternedString::intern(\n-                                \"fields of packed structs might be misaligned: dereferencing a \\\n-                                misaligned pointer or even just creating a misaligned reference \\\n-                                is undefined behavior\"),\n-                            kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n-                        }], &[]);\n-                    }\n+        for (i, elem) in place.projection.iter().enumerate() {\n+            let proj_base = &place.projection[..i];\n+\n+            if context.is_borrow() {\n+                if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n+                    let source_info = self.source_info;\n+                    let lint_root =\n+                        self.source_scope_local_data[source_info.scope].lint_root;\n+                    self.register_violations(&[UnsafetyViolation {\n+                        source_info,\n+                        description: InternedString::intern(\"borrow of packed field\"),\n+                        details: InternedString::intern(\n+                            \"fields of packed structs might be misaligned: dereferencing a \\\n+                            misaligned pointer or even just creating a misaligned reference \\\n+                            is undefined behavior\"),\n+                        kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n+                    }], &[]);\n                 }\n-                let is_borrow_of_interior_mut = context.is_borrow() &&\n-                    !Place::ty_from(&place.base, &proj.base, self.body, self.tcx)\n-                    .ty\n-                    .is_freeze(self.tcx, self.param_env, self.source_info.span);\n-                // prevent\n-                // * `&mut x.field`\n-                // * `x.field = y;`\n-                // * `&x.field` if `field`'s type has interior mutability\n-                // because either of these would allow modifying the layout constrained field and\n-                // insert values that violate the layout constraints.\n-                if context.is_mutating_use() || is_borrow_of_interior_mut {\n-                    self.check_mut_borrowing_layout_constrained_field(\n-                        place, context.is_mutating_use(),\n-                    );\n+            }\n+            let is_borrow_of_interior_mut = context.is_borrow() &&\n+                !Place::ty_from(&place.base, proj_base, self.body, self.tcx)\n+                .ty\n+                .is_freeze(self.tcx, self.param_env, self.source_info.span);\n+            // prevent\n+            // * `&mut x.field`\n+            // * `x.field = y;`\n+            // * `&x.field` if `field`'s type has interior mutability\n+            // because either of these would allow modifying the layout constrained field and\n+            // insert values that violate the layout constraints.\n+            if context.is_mutating_use() || is_borrow_of_interior_mut {\n+                self.check_mut_borrowing_layout_constrained_field(\n+                    place, context.is_mutating_use(),\n+                );\n+            }\n+            let old_source_info = self.source_info;\n+            if let (PlaceBase::Local(local), []) = (&place.base, proj_base) {\n+                if self.body.local_decls[*local].internal {\n+                    // Internal locals are used in the `move_val_init` desugaring.\n+                    // We want to check unsafety against the source info of the\n+                    // desugaring, rather than the source info of the RHS.\n+                    self.source_info = self.body.local_decls[*local].source_info;\n                 }\n-                let old_source_info = self.source_info;\n-                if let (PlaceBase::Local(local), None) = (&place.base, &proj.base) {\n-                    if self.body.local_decls[*local].internal {\n-                        // Internal locals are used in the `move_val_init` desugaring.\n-                        // We want to check unsafety against the source info of the\n-                        // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[*local].source_info;\n-                    }\n+            }\n+            let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+            match base_ty.sty {\n+                ty::RawPtr(..) => {\n+                    self.require_unsafe(\"dereference of raw pointer\",\n+                        \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n+                         aliasing rules and cause data races: all of these are undefined \\\n+                         behavior\", UnsafetyViolationKind::General)\n                 }\n-                let base_ty = Place::ty_from(&place.base, &proj.base, self.body, self.tcx).ty;\n-                match base_ty.sty {\n-                    ty::RawPtr(..) => {\n-                        self.require_unsafe(\"dereference of raw pointer\",\n-                            \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n-                             aliasing rules and cause data races: all of these are undefined \\\n-                             behavior\", UnsafetyViolationKind::General)\n-                    }\n-                    ty::Adt(adt, _) => {\n-                        if adt.is_union() {\n-                            if context == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n-                                context == PlaceContext::MutatingUse(MutatingUseContext::Drop) ||\n-                                context == PlaceContext::MutatingUse(\n-                                    MutatingUseContext::AsmOutput\n-                                )\n-                            {\n-                                let elem_ty = match proj.elem {\n-                                    ProjectionElem::Field(_, ty) => ty,\n-                                    _ => span_bug!(\n-                                        self.source_info.span,\n-                                        \"non-field projection {:?} from union?\",\n-                                        place)\n-                                };\n-                                if !elem_ty.is_copy_modulo_regions(\n-                                    self.tcx,\n-                                    self.param_env,\n+                ty::Adt(adt, _) => {\n+                    if adt.is_union() {\n+                        if context == PlaceContext::MutatingUse(MutatingUseContext::Store) ||\n+                            context == PlaceContext::MutatingUse(MutatingUseContext::Drop) ||\n+                            context == PlaceContext::MutatingUse(\n+                                MutatingUseContext::AsmOutput\n+                            )\n+                        {\n+                            let elem_ty = match elem {\n+                                ProjectionElem::Field(_, ty) => ty,\n+                                _ => span_bug!(\n                                     self.source_info.span,\n-                                ) {\n-                                    self.require_unsafe(\n-                                        \"assignment to non-`Copy` union field\",\n-                                        \"the previous content of the field will be dropped, which \\\n-                                         causes undefined behavior if the field was not properly \\\n-                                         initialized\", UnsafetyViolationKind::General)\n-                                } else {\n-                                    // write to non-move union, safe\n-                                }\n+                                    \"non-field projection {:?} from union?\",\n+                                    place)\n+                            };\n+                            if !elem_ty.is_copy_modulo_regions(\n+                                self.tcx,\n+                                self.param_env,\n+                                self.source_info.span,\n+                            ) {\n+                                self.require_unsafe(\n+                                    \"assignment to non-`Copy` union field\",\n+                                    \"the previous content of the field will be dropped, which \\\n+                                     causes undefined behavior if the field was not properly \\\n+                                     initialized\", UnsafetyViolationKind::General)\n                             } else {\n-                                self.require_unsafe(\"access to union field\",\n-                                    \"the field may not be properly initialized: using \\\n-                                     uninitialized data will cause undefined behavior\",\n-                                     UnsafetyViolationKind::General)\n+                                // write to non-move union, safe\n                             }\n+                        } else {\n+                            self.require_unsafe(\"access to union field\",\n+                                \"the field may not be properly initialized: using \\\n+                                 uninitialized data will cause undefined behavior\",\n+                                 UnsafetyViolationKind::General)\n                         }\n                     }\n-                    _ => {}\n                 }\n-                self.source_info = old_source_info;\n+                _ => {}\n             }\n-        });\n+            self.source_info = old_source_info;\n+        }\n     }\n }\n \n@@ -407,12 +407,13 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         place: &Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        let mut projection = &place.projection;\n-        while let Some(proj) = projection {\n-            match proj.elem {\n+        for (i, elem) in place.projection.iter().enumerate().rev() {\n+            let proj_base = &place.projection[..i];\n+\n+            match elem {\n                 ProjectionElem::Field(..) => {\n                     let ty =\n-                        Place::ty_from(&place.base, &proj.base, &self.body.local_decls, self.tcx)\n+                        Place::ty_from(&place.base, proj_base, &self.body.local_decls, self.tcx)\n                             .ty;\n                     match ty.sty {\n                         ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n@@ -447,7 +448,6 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 }\n                 _ => {}\n             }\n-            projection = &proj.base;\n         }\n     }\n }"}, {"sha": "ea173279aa07321604650d5ae7fb19ec33b93895", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -39,7 +39,7 @@ impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements {\n                        location: Location) {\n         match statement.kind {\n             StatementKind::AscribeUserType(..)\n-            | StatementKind::Assign(_, box Rvalue::Ref(_, BorrowKind::Shallow, _))\n+            | StatementKind::Assign(box(_, Rvalue::Ref(_, BorrowKind::Shallow, _)))\n             | StatementKind::FakeRead(..) => statement.make_nop(),\n             _ => (),\n         }"}, {"sha": "614d5d2a4a2fbd5174564b233523934b1274ef63", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -282,53 +282,53 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n-        place.iterate(|place_base, place_projection| {\n-            let mut eval = match place_base {\n-                PlaceBase::Local(loc) => self.get_const(*loc).clone()?,\n-                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted, _), ..}) => {\n-                    let generics = self.tcx.generics_of(self.source.def_id());\n-                    if generics.requires_monomorphization(self.tcx) {\n-                        // FIXME: can't handle code with generics\n-                        return None;\n-                    }\n-                    let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n-                    let instance = Instance::new(self.source.def_id(), substs);\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: Some(*promoted),\n-                    };\n-                    let res = self.use_ecx(source_info, |this| {\n-                        this.ecx.const_eval_raw(cid)\n+        let mut eval = match place.base {\n+            PlaceBase::Local(loc) => self.get_const(loc).clone()?,\n+            PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted, _), ..}) => {\n+                let generics = self.tcx.generics_of(self.source.def_id());\n+                if generics.requires_monomorphization(self.tcx) {\n+                    // FIXME: can't handle code with generics\n+                    return None;\n+                }\n+                let substs = InternalSubsts::identity_for_item(self.tcx, self.source.def_id());\n+                let instance = Instance::new(self.source.def_id(), substs);\n+                let cid = GlobalId {\n+                    instance,\n+                    promoted: Some(promoted),\n+                };\n+                let res = self.use_ecx(source_info, |this| {\n+                    this.ecx.const_eval_raw(cid)\n+                })?;\n+                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                res.into()\n+            }\n+            _ => return None,\n+        };\n+\n+        for (i, elem) in place.projection.iter().enumerate() {\n+            let proj_base = &place.projection[..i];\n+\n+            match elem {\n+                ProjectionElem::Field(field, _) => {\n+                    trace!(\"field proj on {:?}\", proj_base);\n+                    eval = self.use_ecx(source_info, |this| {\n+                        this.ecx.operand_field(eval, field.index() as u64)\n                     })?;\n-                    trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                    res.into()\n+                },\n+                ProjectionElem::Deref => {\n+                    trace!(\"processing deref\");\n+                    eval = self.use_ecx(source_info, |this| {\n+                        this.ecx.deref_operand(eval)\n+                    })?.into();\n                 }\n+                // We could get more projections by using e.g., `operand_projection`,\n+                // but we do not even have the stack frame set up properly so\n+                // an `Index` projection would throw us off-track.\n                 _ => return None,\n-            };\n-\n-            for proj in place_projection {\n-                match proj.elem {\n-                    ProjectionElem::Field(field, _) => {\n-                        trace!(\"field proj on {:?}\", proj.base);\n-                        eval = self.use_ecx(source_info, |this| {\n-                            this.ecx.operand_field(eval, field.index() as u64)\n-                        })?;\n-                    },\n-                    ProjectionElem::Deref => {\n-                        trace!(\"processing deref\");\n-                        eval = self.use_ecx(source_info, |this| {\n-                            this.ecx.deref_operand(eval)\n-                        })?.into();\n-                    }\n-                    // We could get more projections by using e.g., `operand_projection`,\n-                    // but we do not even have the stack frame set up properly so\n-                    // an `Index` projection would throw us off-track.\n-                    _ => return None,\n-                }\n             }\n+        }\n \n-            Some(eval)\n-        })\n+        Some(eval)\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n@@ -665,15 +665,15 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         location: Location,\n     ) {\n         trace!(\"visit_statement: {:?}\", statement);\n-        if let StatementKind::Assign(ref place, ref mut rval) = statement.kind {\n+        if let StatementKind::Assign(box(ref place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place\n                 .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n                     if let Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n+                        projection: box [],\n                     } = *place {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {"}, {"sha": "28f97f41b50cf7027d4d0181f3e6e71fcedab517", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -94,11 +94,13 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     // That use of the source must be an assignment.\n                     match statement.kind {\n                         StatementKind::Assign(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: None,\n-                            },\n-                            box Rvalue::Use(ref operand)\n+                            box(\n+                                Place {\n+                                    base: PlaceBase::Local(local),\n+                                    projection: box [],\n+                                },\n+                                Rvalue::Use(ref operand)\n+                            )\n                         ) if local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Copy(ref src_place) |\n@@ -148,24 +150,28 @@ fn eliminate_self_assignments(\n             if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n                 match stmt.kind {\n                     StatementKind::Assign(\n-                        Place {\n-                            base: PlaceBase::Local(local),\n-                            projection: None,\n-                        },\n-                        box Rvalue::Use(Operand::Copy(Place {\n-                            base: PlaceBase::Local(src_local),\n-                            projection: None,\n-                        })),\n+                        box(\n+                            Place {\n+                                base: PlaceBase::Local(local),\n+                                projection: box [],\n+                            },\n+                            Rvalue::Use(Operand::Copy(Place {\n+                                base: PlaceBase::Local(src_local),\n+                                projection: box [],\n+                            })),\n+                        )\n                     ) |\n                     StatementKind::Assign(\n-                        Place {\n-                            base: PlaceBase::Local(local),\n-                            projection: None,\n-                        },\n-                        box Rvalue::Use(Operand::Move(Place {\n-                            base: PlaceBase::Local(src_local),\n-                            projection: None,\n-                        })),\n+                        box(\n+                            Place {\n+                                base: PlaceBase::Local(local),\n+                                projection: box [],\n+                            },\n+                            Rvalue::Use(Operand::Move(Place {\n+                                base: PlaceBase::Local(src_local),\n+                                projection: box [],\n+                            })),\n+                        )\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n                         continue;\n@@ -194,7 +200,7 @@ impl<'tcx> Action<'tcx> {\n         // The source must be a local.\n         let src_local = if let Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         } = *src_place {\n             local\n         } else {\n@@ -351,11 +357,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         match *operand {\n             Operand::Copy(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) |\n             Operand::Move(Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             }) if local == self.dest_local => {}\n             _ => return,\n         }"}, {"sha": "c1224be6324e20bd58379e882864c0e89420d1e2", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -12,8 +12,8 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n         for bb in basic_blocks {\n             bb.expand_statements(|stmt| {\n                 // FIXME(eddyb) don't match twice on `stmt.kind` (post-NLL).\n-                if let StatementKind::Assign(_, ref rhs) = stmt.kind {\n-                    if let Rvalue::Aggregate(ref kind, _) = **rhs {\n+                if let StatementKind::Assign(box(_, ref rhs)) = stmt.kind {\n+                    if let Rvalue::Aggregate(ref kind, _) = *rhs {\n                         // FIXME(#48193) Deaggregate arrays when it's cheaper to do so.\n                         if let AggregateKind::Array(_) = **kind {\n                             return None;\n@@ -28,7 +28,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n                 let stmt = stmt.replace_nop();\n                 let source_info = stmt.source_info;\n                 let (lhs, kind, operands) = match stmt.kind {\n-                    StatementKind::Assign(lhs, box rvalue) => {\n+                    StatementKind::Assign(box(lhs, rvalue)) => {\n                         match rvalue {\n                             Rvalue::Aggregate(kind, operands) => (lhs, kind, operands),\n                             _ => bug!()"}, {"sha": "a9c66b3c8c6d18dac2a90fa39358599414668692", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 16, "deletions": 29, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -236,47 +236,34 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n     }\n \n     fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection {\n-                    elem: ProjectionElem::Field(idx, _), ..\n-                } => idx == field,\n-                _ => false\n-            }\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n+            ProjectionElem::Field(idx, _) => *idx == field,\n+            _ => false,\n         })\n     }\n \n     fn array_subpath(&self, path: Self::Path, index: u32, size: u32) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection {\n-                    elem: ProjectionElem::ConstantIndex{offset, min_length: _, from_end: false}, ..\n-                } => offset == index,\n-                &Projection {\n-                    elem: ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true}, ..\n-                } => size - offset == index,\n-                _ => false\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: false } => {\n+                *offset == index\n+            }\n+            ProjectionElem::ConstantIndex { offset, min_length: _, from_end: true } => {\n+                size - offset == index\n             }\n+            _ => false,\n         })\n     }\n \n     fn deref_subpath(&self, path: Self::Path) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection { elem: ProjectionElem::Deref, .. } => true,\n-                _ => false\n-            }\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| {\n+            *e == ProjectionElem::Deref\n         })\n     }\n \n     fn downcast_subpath(&self, path: Self::Path, variant: VariantIdx) -> Option<Self::Path> {\n-        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |p| {\n-            match p {\n-                &Projection {\n-                    elem: ProjectionElem::Downcast(_, idx), ..\n-                } => idx == variant,\n-                _ => false\n-            }\n+        dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n+            ProjectionElem::Downcast(_, idx) => *idx == variant,\n+            _ => false\n         })\n     }\n \n@@ -465,7 +452,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         assert!(!data.is_cleanup, \"DropAndReplace in unwind path not supported\");\n \n         let assign = Statement {\n-            kind: StatementKind::Assign(location.clone(), box Rvalue::Use(value.clone())),\n+            kind: StatementKind::Assign(box(location.clone(), Rvalue::Use(value.clone()))),\n             source_info: terminator.source_info\n         };\n "}, {"sha": "0ce2db93c421d0ce99d7e835aa19180e8ce7d783", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -107,10 +107,7 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n         if place.base == PlaceBase::Local(self_arg()) {\n             replace_base(place, Place {\n                 base: PlaceBase::Local(self_arg()),\n-                projection: Some(Box::new(Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                })),\n+                projection: Box::new([ProjectionElem::Deref]),\n             });\n         } else {\n             self.super_place(place, context, location);\n@@ -137,10 +134,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n         if place.base == PlaceBase::Local(self_arg()) {\n             replace_base(place, Place {\n                 base: PlaceBase::Local(self_arg()),\n-                projection: Some(Box::new(Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Field(Field::new(0), self.ref_gen_ty),\n-                })),\n+                projection: Box::new([ProjectionElem::Field(Field::new(0), self.ref_gen_ty)]),\n             });\n         } else {\n             self.super_place(place, context, location);\n@@ -149,13 +143,12 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n }\n \n fn replace_base(place: &mut Place<'tcx>, new_base: Place<'tcx>) {\n-    let mut projection = &mut place.projection;\n-    while let Some(box proj) = projection {\n-        projection = &mut proj.base;\n-    }\n-\n     place.base = new_base.base;\n-    *projection = new_base.projection;\n+\n+    let mut new_projection = new_base.projection.to_vec();\n+    new_projection.append(&mut place.projection.to_vec());\n+\n+    place.projection = new_projection.into_boxed_slice();\n }\n \n fn self_arg() -> Local {\n@@ -210,13 +203,12 @@ impl TransformVisitor<'tcx> {\n     fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n         let self_place = Place::from(self_arg());\n         let base = self_place.downcast_unnamed(variant_index);\n-        let field = Projection {\n-            base: base.projection,\n-            elem: ProjectionElem::Field(Field::new(idx), ty),\n-        };\n+        let mut projection = base.projection.to_vec();\n+        projection.push(ProjectionElem::Field(Field::new(idx), ty));\n+\n         Place {\n             base: base.base,\n-            projection: Some(Box::new(field)),\n+            projection: projection.into_boxed_slice(),\n         }\n     }\n \n@@ -225,7 +217,10 @@ impl TransformVisitor<'tcx> {\n         let self_place = Place::from(self_arg());\n         Statement {\n             source_info,\n-            kind: StatementKind::SetDiscriminant { place: self_place, variant_index: state_disc },\n+            kind: StatementKind::SetDiscriminant {\n+                place: box self_place,\n+                variant_index: state_disc,\n+            },\n         }\n     }\n \n@@ -238,7 +233,7 @@ impl TransformVisitor<'tcx> {\n         let self_place = Place::from(self_arg());\n         let assign = Statement {\n             source_info: source_info(body),\n-            kind: StatementKind::Assign(temp.clone(), box Rvalue::Discriminant(self_place)),\n+            kind: StatementKind::Assign(box(temp.clone(), Rvalue::Discriminant(self_place))),\n         };\n         (assign, temp)\n     }\n@@ -296,8 +291,12 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n             // We must assign the value first in case it gets declared dead below\n             data.statements.push(Statement {\n                 source_info,\n-                kind: StatementKind::Assign(Place::RETURN_PLACE,\n-                                            box self.make_state(state_idx, v)),\n+                kind: StatementKind::Assign(\n+                    box(\n+                        Place::return_place(),\n+                        self.make_state(state_idx, v)\n+                    )\n+                ),\n             });\n             let state = if let Some(resume) = resume { // Yield\n                 let state = 3 + self.suspension_points.len();\n@@ -848,7 +847,7 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n                 kind: TerminatorKind::Drop {\n                     location: Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n+                        projection: box [],\n                     },\n                     target,\n                     unwind\n@@ -937,7 +936,7 @@ fn create_generator_drop_shim<'tcx>(\n         // Alias tracking must know we changed the type\n         body.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n             source_info,\n-            kind: StatementKind::Retag(RetagKind::Raw, Place::from(self_arg())),\n+            kind: StatementKind::Retag(RetagKind::Raw, box Place::from(self_arg())),\n         })\n     }\n "}, {"sha": "5ad026dc143c9574c4dbce509b8371555877eacf", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -425,22 +425,20 @@ impl Inliner<'tcx> {\n                 // writes to `i`. To prevent this we need to create a temporary\n                 // borrow of the place and pass the destination as `*temp` instead.\n                 fn dest_needs_borrow(place: &Place<'_>) -> bool {\n-                    place.iterate(|place_base, place_projection| {\n-                        for proj in place_projection {\n-                            match proj.elem {\n-                                ProjectionElem::Deref |\n-                                ProjectionElem::Index(_) => return true,\n-                                _ => {}\n-                            }\n+                    for elem in place.projection.iter() {\n+                        match elem {\n+                            ProjectionElem::Deref |\n+                            ProjectionElem::Index(_) => return true,\n+                            _ => {}\n                         }\n+                    }\n \n-                        match place_base {\n-                            // Static variables need a borrow because the callee\n-                            // might modify the same static.\n-                            PlaceBase::Static(_) => true,\n-                            _ => false\n-                        }\n-                    })\n+                    match place.base {\n+                        // Static variables need a borrow because the callee\n+                        // might modify the same static.\n+                        PlaceBase::Static(_) => true,\n+                        _ => false\n+                    }\n                 }\n \n                 let dest = if dest_needs_borrow(&destination.0) {\n@@ -459,7 +457,7 @@ impl Inliner<'tcx> {\n \n                     let stmt = Statement {\n                         source_info: callsite.location,\n-                        kind: StatementKind::Assign(tmp.clone(), box dest)\n+                        kind: StatementKind::Assign(box(tmp.clone(), dest))\n                     };\n                     caller_body[callsite.bb]\n                         .statements.push(stmt);\n@@ -591,7 +589,7 @@ impl Inliner<'tcx> {\n \n         if let Operand::Move(Place {\n             base: PlaceBase::Local(local),\n-            projection: None,\n+            projection: box [],\n         }) = arg {\n             if caller_body.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n@@ -610,7 +608,7 @@ impl Inliner<'tcx> {\n \n         let stmt = Statement {\n             source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::from(arg_tmp), box arg),\n+            kind: StatementKind::Assign(box(Place::from(arg_tmp), arg)),\n         };\n         caller_body[callsite.bb].statements.push(stmt);\n         arg_tmp\n@@ -660,7 +658,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             match self.destination {\n                 Place {\n                     base: PlaceBase::Local(l),\n-                    projection: None,\n+                    projection: box [],\n                 } => {\n                     *local = l;\n                     return;\n@@ -684,7 +682,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         match place {\n             Place {\n                 base: PlaceBase::Local(RETURN_PLACE),\n-                projection: None,\n+                projection: box [],\n             } => {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();"}, {"sha": "0e04e63af4522ae1daeed981d59d345cf2e9b341", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -43,12 +43,21 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n             let new_place = match *rvalue {\n                 Rvalue::Ref(_, _, Place {\n                     ref mut base,\n-                    projection: Some(ref mut projection),\n-                }) => Place {\n-                    // Replace with dummy\n-                    base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n-                    projection: projection.base.take(),\n-                },\n+                    projection: ref mut projection @ box [.., _],\n+                }) => {\n+                    if let box [proj_l @ .., proj_r] = projection {\n+                        let place = Place {\n+                            // Replace with dummy\n+                            base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n+                            projection: proj_l.to_vec().into_boxed_slice(),\n+                        };\n+                        *projection = vec![proj_r.clone()].into_boxed_slice();\n+\n+                        place\n+                    } else {\n+                        unreachable!();\n+                    }\n+                }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };\n             *rvalue = Rvalue::Use(Operand::Copy(new_place))\n@@ -83,13 +92,11 @@ impl OptimizationFinder<'b, 'tcx> {\n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Place {\n-            ref base,\n-            projection: Some(ref projection),\n-        }) = *rvalue {\n-            if let ProjectionElem::Deref = projection.elem {\n-                if Place::ty_from(&base, &projection.base, self.body, self.tcx).ty.is_region_ptr() {\n-                    self.optimizations.and_stars.insert(location);\n-                }\n+            base,\n+            projection: box [proj_base @ .., ProjectionElem::Deref],\n+        }) = rvalue {\n+            if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                self.optimizations.and_stars.insert(location);\n             }\n         }\n "}, {"sha": "7d1b96b8be170dc89d11cde8d5194285a88cf723", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            kind: StatementKind::Assign(Place::from(dest), box rvalue)\n+            kind: StatementKind::Assign(box(Place::from(dest), rvalue))\n         });\n     }\n \n@@ -222,10 +222,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n         // First, take the Rvalue or Call out of the source MIR,\n         // or duplicate it, depending on keep_original.\n         if loc.statement_index < no_stmts {\n-            let (rvalue, source_info) = {\n+            let (mut rvalue, source_info) = {\n                 let statement = &mut self.source[loc.block].statements[loc.statement_index];\n                 let rhs = match statement.kind {\n-                    StatementKind::Assign(_, ref mut rhs) => rhs,\n+                    StatementKind::Assign(box(_, ref mut rhs)) => rhs,\n                     _ => {\n                         span_bug!(statement.source_info.span, \"{:?} is not an assignment\",\n                                   statement);\n@@ -235,12 +235,11 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 (if self.keep_original {\n                     rhs.clone()\n                 } else {\n-                    let unit = box Rvalue::Aggregate(box AggregateKind::Tuple, vec![]);\n+                    let unit = Rvalue::Aggregate(box AggregateKind::Tuple, vec![]);\n                     mem::replace(rhs, unit)\n                 }, statement.source_info)\n             };\n \n-            let mut rvalue = *rvalue;\n             self.visit_rvalue(&mut rvalue, loc);\n             self.assign(new_temp, rvalue, source_info.span);\n         } else {\n@@ -318,25 +317,25 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ty,\n                         def_id,\n                     }),\n-                    projection: None,\n+                    projection: box [],\n                 }\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n                 Candidate::Ref(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(_, box Rvalue::Ref(_, _, ref mut place)) => {\n+                        StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref mut place))) => {\n                             // Use the underlying local for this (necessarily interior) borrow.\n                             let ty = place.base.ty(local_decls).ty;\n                             let span = statement.source_info.span;\n \n                             Operand::Move(Place {\n                                 base: mem::replace(\n                                     &mut place.base,\n-                                    promoted_place(ty, span).base\n+                                    promoted_place(ty, span).base,\n                                 ),\n-                                projection: None,\n+                                projection: box [],\n                             })\n                         }\n                         _ => bug!()\n@@ -345,7 +344,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 Candidate::Repeat(loc) => {\n                     let ref mut statement = blocks[loc.block].statements[loc.statement_index];\n                     match statement.kind {\n-                        StatementKind::Assign(_, box Rvalue::Repeat(ref mut operand, _)) => {\n+                        StatementKind::Assign(box(_, Rvalue::Repeat(ref mut operand, _))) => {\n                             let ty = operand.ty(local_decls, self.tcx);\n                             let span = statement.source_info.span;\n                             mem::replace(\n@@ -420,10 +419,10 @@ pub fn promote_candidates<'tcx>(\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n                 match body[block].statements[statement_index].kind {\n-                    StatementKind::Assign(Place {\n+                    StatementKind::Assign(box(Place {\n                         base: PlaceBase::Local(local),\n-                        projection: None,\n-                    }, _) => {\n+                        projection: box [],\n+                    }, _)) => {\n                         if temps[local] == TempState::PromotedOut {\n                             // Already promoted.\n                             continue;\n@@ -473,10 +472,10 @@ pub fn promote_candidates<'tcx>(\n     for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n-                StatementKind::Assign(Place {\n+                StatementKind::Assign(box(Place {\n                     base: PlaceBase::Local(index),\n-                    projection: None,\n-                }, _) |\n+                    projection: box [],\n+                }, _)) |\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n                     !promoted(index)\n@@ -488,7 +487,7 @@ pub fn promote_candidates<'tcx>(\n         match terminator.kind {\n             TerminatorKind::Drop { location: Place {\n                 base: PlaceBase::Local(index),\n-                projection: None,\n+                projection: box [],\n             }, target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {"}, {"sha": "7cc1e634cf812da820c6aa6428d4e134eef85e83", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 130, "deletions": 128, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -187,26 +187,28 @@ trait Qualif {\n         cx: &ConstCx<'_, 'tcx>,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n-        let proj = place.projection.as_ref().unwrap();\n-\n-        let base_qualif = Self::in_place(cx, PlaceRef {\n-            base: place.base,\n-            projection: &proj.base,\n-        });\n-        let qualif = base_qualif && Self::mask_for_ty(\n-            cx,\n-            Place::ty_from(place.base, &proj.base, cx.body, cx.tcx)\n-                .projection_ty(cx.tcx, &proj.elem)\n-                .ty,\n-        );\n-        match proj.elem {\n-            ProjectionElem::Deref |\n-            ProjectionElem::Subslice { .. } |\n-            ProjectionElem::Field(..) |\n-            ProjectionElem::ConstantIndex { .. } |\n-            ProjectionElem::Downcast(..) => qualif,\n-\n-            ProjectionElem::Index(local) => qualif || Self::in_local(cx, local),\n+        if let [proj_base @ .., elem] = place.projection {\n+            let base_qualif = Self::in_place(cx, PlaceRef {\n+                base: place.base,\n+                projection: proj_base,\n+            });\n+            let qualif = base_qualif && Self::mask_for_ty(\n+                cx,\n+                Place::ty_from(place.base, proj_base, cx.body, cx.tcx)\n+                    .projection_ty(cx.tcx, elem)\n+                    .ty,\n+            );\n+            match elem {\n+                ProjectionElem::Deref |\n+                ProjectionElem::Subslice { .. } |\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::ConstantIndex { .. } |\n+                ProjectionElem::Downcast(..) => qualif,\n+\n+                ProjectionElem::Index(local) => qualif || Self::in_local(cx, *local),\n+            }\n+        } else {\n+            bug!(\"This should be called if projection is not empty\");\n         }\n     }\n \n@@ -221,24 +223,24 @@ trait Qualif {\n         match place {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } => Self::in_local(cx, *local),\n             PlaceRef {\n                 base: PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n                     ..\n                 }),\n-                projection: None,\n+                projection: [],\n             } => bug!(\"qualifying already promoted MIR\"),\n             PlaceRef {\n                 base: PlaceBase::Static(static_),\n-                projection: None,\n+                projection: [],\n             } => {\n                 Self::in_static(cx, static_)\n             },\n             PlaceRef {\n                 base: _,\n-                projection: Some(_),\n+                projection: [.., _],\n             } => Self::in_projection(cx, place),\n         }\n     }\n@@ -289,13 +291,13 @@ trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let Some(ref proj) = place.projection {\n-                    if let ProjectionElem::Deref = proj.elem {\n-                        let base_ty = Place::ty_from(&place.base, &proj.base, cx.body, cx.tcx).ty;\n+                if let box [proj_base @ .., elem] = &place.projection {\n+                    if ProjectionElem::Deref == *elem {\n+                        let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.sty {\n                             return Self::in_place(cx, PlaceRef {\n                                 base: &place.base,\n-                                projection: &proj.base,\n+                                projection: proj_base,\n                             });\n                         }\n                     }\n@@ -453,30 +455,32 @@ impl Qualif for IsNotPromotable {\n         cx: &ConstCx<'_, 'tcx>,\n         place: PlaceRef<'_, 'tcx>,\n     ) -> bool {\n-        let proj = place.projection.as_ref().unwrap();\n-\n-        match proj.elem {\n-            ProjectionElem::Deref |\n-            ProjectionElem::Downcast(..) => return true,\n-\n-            ProjectionElem::ConstantIndex {..} |\n-            ProjectionElem::Subslice {..} |\n-            ProjectionElem::Index(_) => {}\n-\n-            ProjectionElem::Field(..) => {\n-                if cx.mode == Mode::NonConstFn {\n-                    let base_ty = Place::ty_from(place.base, &proj.base, cx.body, cx.tcx).ty;\n-                    if let Some(def) = base_ty.ty_adt_def() {\n-                        // No promotion of union field accesses.\n-                        if def.is_union() {\n-                            return true;\n+        if let [proj_base @ .., elem] = place.projection {\n+            match elem {\n+                ProjectionElem::Deref |\n+                ProjectionElem::Downcast(..) => return true,\n+\n+                ProjectionElem::ConstantIndex {..} |\n+                ProjectionElem::Subslice {..} |\n+                ProjectionElem::Index(_) => {}\n+\n+                ProjectionElem::Field(..) => {\n+                    if cx.mode == Mode::NonConstFn {\n+                        let base_ty = Place::ty_from(place.base, proj_base, cx.body, cx.tcx).ty;\n+                        if let Some(def) = base_ty.ty_adt_def() {\n+                            // No promotion of union field accesses.\n+                            if def.is_union() {\n+                                return true;\n+                            }\n                         }\n                     }\n                 }\n             }\n-        }\n \n-        Self::in_projection_structurally(cx, place)\n+            Self::in_projection_structurally(cx, place)\n+        } else {\n+            bug!(\"This should be called if projection is not empty\");\n+        }\n     }\n \n     fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n@@ -806,23 +810,18 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     // We might have a candidate for promotion.\n                     let candidate = Candidate::Ref(location);\n                     // Start by traversing to the \"base\", with non-deref projections removed.\n-                    let mut place_projection = &place.projection;\n-                    while let Some(proj) = place_projection {\n-                        if proj.elem == ProjectionElem::Deref {\n-                            break;\n-                        }\n-                        place_projection = &proj.base;\n-                    }\n+                    let deref_proj =\n+                        place.projection.iter().rev().find(|&elem| *elem == ProjectionElem::Deref);\n \n                     debug!(\n                         \"qualify_consts: promotion candidate: place={:?} {:?}\",\n-                        place.base, place_projection\n+                        place.base, deref_proj\n                     );\n                     // We can only promote interior borrows of promotable temps (non-temps\n                     // don't get promoted anyway).\n                     // (If we bailed out of the loop due to a `Deref` above, we will definitely\n                     // not enter the conditional here.)\n-                    if let (PlaceBase::Local(local), None) = (&place.base, place_projection) {\n+                    if let (PlaceBase::Local(local), None) = (&place.base, deref_proj) {\n                         if self.body.local_kind(*local) == LocalKind::Temp {\n                             debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n                             // The borrowed place doesn't have `HasMutInterior`\n@@ -858,27 +857,27 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             _ => {},\n         }\n \n-        let mut dest_projection = &dest.projection;\n+        let mut dest_projection = &dest.projection[..];\n         let index = loop {\n             match (&dest.base, dest_projection) {\n                 // We treat all locals equal in constants\n-                (&PlaceBase::Local(index), None) => break index,\n+                (&PlaceBase::Local(index), []) => break index,\n                 // projections are transparent for assignments\n                 // we qualify the entire destination at once, even if just a field would have\n                 // stricter qualification\n-                (base, Some(proj)) => {\n+                (base, [proj_base @ .., _]) => {\n                     // Catch more errors in the destination. `visit_place` also checks various\n                     // projection rules like union field access and raw pointer deref\n                     let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n                     self.visit_place_base(base, context, location);\n-                    self.visit_projection(base, proj, context, location);\n-                    dest_projection = &proj.base;\n+                    self.visit_projection(base, dest_projection, context, location);\n+                    dest_projection = proj_base;\n                 },\n                 (&PlaceBase::Static(box Static {\n                     kind: StaticKind::Promoted(..),\n                     ..\n-                }), None) => bug!(\"promoteds don't exist yet during promotion\"),\n-                (&PlaceBase::Static(box Static{ kind: _, .. }), None) => {\n+                }), []) => bug!(\"promoteds don't exist yet during promotion\"),\n+                (&PlaceBase::Static(box Static{ kind: _, .. }), []) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n                     let context = PlaceContext::MutatingUse(MutatingUseContext::Store);\n@@ -983,23 +982,25 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         for candidate in &self.promotion_candidates {\n             match *candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n-                    if let StatementKind::Assign(_, box Rvalue::Repeat(\n+                    if let StatementKind::Assign(box(_, Rvalue::Repeat(\n                         Operand::Move(Place {\n                             base: PlaceBase::Local(index),\n-                            projection: None,\n+                            projection: box [],\n                         }),\n                         _\n-                    )) = self.body[bb].statements[stmt_idx].kind {\n+                    ))) = self.body[bb].statements[stmt_idx].kind {\n                         promoted_temps.insert(index);\n                     }\n                 }\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(\n-                        _,\n-                        box Rvalue::Ref(_, _, Place {\n-                            base: PlaceBase::Local(index),\n-                            projection: None,\n-                        })\n+                        box(\n+                            _,\n+                            Rvalue::Ref(_, _, Place {\n+                                base: PlaceBase::Local(index),\n+                                projection: box [],\n+                            })\n+                        )\n                     ) = self.body[bb].statements[stmt_idx].kind {\n                         promoted_temps.insert(index);\n                     }\n@@ -1084,7 +1085,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     fn visit_projection(\n         &mut self,\n         place_base: &PlaceBase<'tcx>,\n-        proj: &Projection<'tcx>,\n+        proj: &[PlaceElem<'tcx>],\n         context: PlaceContext,\n         location: Location,\n     ) {\n@@ -1093,62 +1094,65 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             proj, context, location,\n         );\n         self.super_projection(place_base, proj, context, location);\n-        match proj.elem {\n-            ProjectionElem::Deref => {\n-                if context.is_mutating_use() {\n-                    // `not_const` errors out in const contexts\n-                    self.not_const()\n-                }\n-                let base_ty = Place::ty_from(place_base, &proj.base, self.body, self.tcx).ty;\n-                match self.mode {\n-                    Mode::NonConstFn => {},\n-                    _ => {\n-                        if let ty::RawPtr(_) = base_ty.sty {\n-                            if !self.tcx.features().const_raw_ptr_deref {\n-                                emit_feature_err(\n-                                    &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n-                                    self.span, GateIssue::Language,\n-                                    &format!(\n-                                        \"dereferencing raw pointers in {}s is unstable\",\n-                                        self.mode,\n-                                    ),\n-                                );\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n \n-            ProjectionElem::ConstantIndex {..} |\n-            ProjectionElem::Subslice {..} |\n-            ProjectionElem::Field(..) |\n-            ProjectionElem::Index(_) => {\n-                let base_ty = Place::ty_from(place_base, &proj.base, self.body, self.tcx).ty;\n-                if let Some(def) = base_ty.ty_adt_def() {\n-                    if def.is_union() {\n-                        match self.mode {\n-                            Mode::ConstFn => {\n-                                if !self.tcx.features().const_fn_union {\n+        if let [proj_base @ .., elem] = proj {\n+            match elem {\n+                ProjectionElem::Deref => {\n+                    if context.is_mutating_use() {\n+                        // `not_const` errors out in const contexts\n+                        self.not_const()\n+                    }\n+                    let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                    match self.mode {\n+                        Mode::NonConstFn => {},\n+                        _ => {\n+                            if let ty::RawPtr(_) = base_ty.sty {\n+                                if !self.tcx.features().const_raw_ptr_deref {\n                                     emit_feature_err(\n-                                        &self.tcx.sess.parse_sess, sym::const_fn_union,\n+                                        &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                         self.span, GateIssue::Language,\n-                                        \"unions in const fn are unstable\",\n+                                        &format!(\n+                                            \"dereferencing raw pointers in {}s is unstable\",\n+                                            self.mode,\n+                                        ),\n                                     );\n                                 }\n-                            },\n+                            }\n+                        }\n+                    }\n+                }\n \n-                            | Mode::NonConstFn\n-                            | Mode::Static\n-                            | Mode::StaticMut\n-                            | Mode::Const\n-                            => {},\n+                ProjectionElem::ConstantIndex {..} |\n+                ProjectionElem::Subslice {..} |\n+                ProjectionElem::Field(..) |\n+                ProjectionElem::Index(_) => {\n+                    let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                    if let Some(def) = base_ty.ty_adt_def() {\n+                        if def.is_union() {\n+                            match self.mode {\n+                                Mode::ConstFn => {\n+                                    if !self.tcx.features().const_fn_union {\n+                                        emit_feature_err(\n+                                            &self.tcx.sess.parse_sess, sym::const_fn_union,\n+                                            self.span, GateIssue::Language,\n+                                            \"unions in const fn are unstable\",\n+                                        );\n+                                    }\n+                                },\n+\n+                                | Mode::NonConstFn\n+                                | Mode::Static\n+                                | Mode::StaticMut\n+                                | Mode::Const\n+                                => {},\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            ProjectionElem::Downcast(..) => {\n-                self.not_const()\n+                ProjectionElem::Downcast(..) => {\n+                    self.not_const()\n+                }\n             }\n         }\n     }\n@@ -1162,7 +1166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // Mark the consumed locals to indicate later drops are noops.\n                 if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = *place {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n@@ -1179,11 +1183,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n             let mut reborrow_place = None;\n-            if let Some(ref proj) = place.projection {\n-                if let ProjectionElem::Deref = proj.elem {\n-                    let base_ty = Place::ty_from(&place.base, &proj.base, self.body, self.tcx).ty;\n+            if let box [proj_base @ .., elem] = &place.projection {\n+                if *elem == ProjectionElem::Deref {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.sty {\n-                        reborrow_place = Some(&proj.base);\n+                        reborrow_place = Some(proj_base);\n                     }\n                 }\n             }\n@@ -1204,9 +1208,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     ),\n                 };\n                 self.visit_place_base(&place.base, ctx, location);\n-                if let Some(proj) = proj {\n-                    self.visit_projection(&place.base, proj, ctx, location);\n-                }\n+                self.visit_projection(&place.base, proj, ctx, location);\n             } else {\n                 self.super_rvalue(rvalue, location);\n             }\n@@ -1477,7 +1479,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place {\n                     base: PlaceBase::Local(local),\n-                    projection: None,\n+                    projection: box [],\n                 } = *place {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.body.local_decls[local].source_info.span)\n@@ -1727,7 +1729,7 @@ fn remove_drop_and_storage_dead_on_promoted_locals(\n             TerminatorKind::Drop {\n                 location: Place {\n                     base: PlaceBase::Local(index),\n-                    projection: None,\n+                    projection: box [],\n                 },\n                 target,\n                 .."}, {"sha": "80e020a9eb7e65b8442040178ddb657c975c554e", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -206,7 +206,7 @@ fn check_statement(\n ) -> McfResult {\n     let span = statement.source_info.span;\n     match &statement.kind {\n-        StatementKind::Assign(place, rval) => {\n+        StatementKind::Assign(box(place, rval)) => {\n             check_place(place, span)?;\n             check_rvalue(tcx, body, rval, span)\n         }\n@@ -249,28 +249,26 @@ fn check_place(\n     place: &Place<'tcx>,\n     span: Span,\n ) -> McfResult {\n-    place.iterate(|place_base, place_projection| {\n-        for proj in place_projection {\n-            match proj.elem {\n-                ProjectionElem::Downcast(..) => {\n-                    return Err((span, \"`match` or `if let` in `const fn` is unstable\".into()));\n-                }\n-                ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Deref\n-                | ProjectionElem::Field(..)\n-                | ProjectionElem::Index(_) => {}\n+    for elem in place.projection.iter() {\n+        match elem {\n+            ProjectionElem::Downcast(..) => {\n+                return Err((span, \"`match` or `if let` in `const fn` is unstable\".into()));\n             }\n+            ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Deref\n+            | ProjectionElem::Field(..)\n+            | ProjectionElem::Index(_) => {}\n         }\n+    }\n \n-        match place_base {\n-            PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n-                Err((span, \"cannot access `static` items in const fn\".into()))\n-            }\n-            PlaceBase::Local(_)\n-            | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n+    match place.base {\n+        PlaceBase::Static(box Static { kind: StaticKind::Static, .. }) => {\n+            Err((span, \"cannot access `static` items in const fn\".into()))\n         }\n-    })\n+        PlaceBase::Local(_)\n+        | PlaceBase::Static(box Static { kind: StaticKind::Promoted(_, _), .. }) => Ok(()),\n+    }\n }\n \n fn check_terminator("}, {"sha": "70b11944e2fbcc463288cf09b745cd47a5121fc1", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -41,10 +41,10 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(Place {\n+                StatementKind::Assign(box(Place {\n                     base: PlaceBase::Local(_),\n-                    projection: None,\n-                }, box Rvalue::Use(_)) => {\n+                    projection: box [],\n+                }, Rvalue::Use(_))) => {\n                     // Writing to a local (e.g., a drop flag) does not\n                     // turn a landing pad to a non-nop\n                 }"}, {"sha": "68fa082d2940786ab737eca0b02c30fcb1b73a17", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -120,11 +120,11 @@ fn each_block<'tcx, O>(\n     let peek_arg_place = match args[0] {\n         mir::Operand::Copy(ref place @ mir::Place {\n             base: mir::PlaceBase::Local(_),\n-            projection: None,\n+            projection: box [],\n         }) |\n         mir::Operand::Move(ref place @ mir::Place {\n             base: mir::PlaceBase::Local(_),\n-            projection: None,\n+            projection: box [],\n         }) => Some(place),\n         _ => None,\n     };\n@@ -150,7 +150,7 @@ fn each_block<'tcx, O>(\n     for (j, stmt) in statements.iter().enumerate() {\n         debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n         let (place, rvalue) = match stmt.kind {\n-            mir::StatementKind::Assign(ref place, ref rvalue) => {\n+            mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n                 (place, rvalue)\n             }\n             mir::StatementKind::FakeRead(..) |\n@@ -166,7 +166,7 @@ fn each_block<'tcx, O>(\n         };\n \n         if place == peek_arg_place {\n-            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = **rvalue {\n+            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = *rvalue {\n                 // Okay, our search is over.\n                 match move_data.rev_lookup.find(peeking_at_place.as_ref()) {\n                     LookupResult::Exact(peek_mpi) => {"}, {"sha": "34ad5cb5dc787d8762262a0b327a54e3a7fb476d", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 102, "deletions": 87, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -61,14 +61,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let Some(ref proj) = src_place.projection {\n+            if let box [proj_base @ .., elem] = &src_place.projection {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n-                                                     from_end: false} = proj.elem {\n+                                                     from_end: false} = elem {\n                     // no need to transformation\n                 } else {\n                     let place_ty =\n-                        Place::ty_from(&src_place.base, &proj.base, self.body, self.tcx).ty;\n+                        Place::ty_from(&src_place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Array(item_ty, const_size) = place_ty.sty {\n                         if let Some(size) = const_size.try_eval_usize(self.tcx, self.param_env) {\n                             assert!(size <= u32::max_value() as u64,\n@@ -78,7 +78,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                 location,\n                                 dst_place,\n                                 &src_place.base,\n-                                proj,\n+                                &src_place.projection,\n                                 item_ty,\n                                 size as u32,\n                             );\n@@ -97,73 +97,76 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                location: Location,\n                dst_place: &Place<'tcx>,\n                base: &PlaceBase<'tcx>,\n-               proj: &Projection<'tcx>,\n+               proj: &[PlaceElem<'tcx>],\n                item_ty: &'tcx ty::TyS<'tcx>,\n                size: u32) {\n-        match proj.elem {\n-            // uniforms statements like_10 = move _2[:-1];\n-            ProjectionElem::Subslice{from, to} => {\n-                self.patch.make_nop(location);\n-                let temps : Vec<_> = (from..(size-to)).map(|i| {\n-                    let temp = self.patch.new_temp(item_ty, self.body.source_info(location).span);\n-                    self.patch.add_statement(location, StatementKind::StorageLive(temp));\n+        if let [proj_base @ .., elem] = proj {\n+            match elem {\n+                // uniforms statements like_10 = move _2[:-1];\n+                ProjectionElem::Subslice{from, to} => {\n+                    self.patch.make_nop(location);\n+                    let temps : Vec<_> = (*from..(size-*to)).map(|i| {\n+                        let temp =\n+                            self.patch.new_temp(item_ty, self.body.source_info(location).span);\n+                        self.patch.add_statement(location, StatementKind::StorageLive(temp));\n+\n+                        let mut projection = proj_base.to_vec();\n+                        projection.push(ProjectionElem::ConstantIndex {\n+                            offset: i,\n+                            min_length: size,\n+                            from_end: false,\n+                        });\n+                        self.patch.add_assign(location,\n+                                              Place::from(temp),\n+                                              Rvalue::Use(\n+                                                  Operand::Move(\n+                                                      Place {\n+                                                          base: base.clone(),\n+                                                          projection: projection.into_boxed_slice(),\n+                                                      }\n+                                                  )\n+                                              )\n+                        );\n+                        temp\n+                    }).collect();\n+                    self.patch.add_assign(\n+                        location,\n+                        dst_place.clone(),\n+                        Rvalue::Aggregate(\n+                            box AggregateKind::Array(item_ty),\n+                            temps.iter().map(\n+                                |x| Operand::Move(Place::from(*x))\n+                            ).collect()\n+                        )\n+                    );\n+                    for temp in temps {\n+                        self.patch.add_statement(location, StatementKind::StorageDead(temp));\n+                    }\n+                }\n+                // uniforms statements like _11 = move _2[-1 of 1];\n+                ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n+                    self.patch.make_nop(location);\n+\n+                    let mut projection = proj_base.to_vec();\n+                    projection.push(ProjectionElem::ConstantIndex {\n+                        offset: size - offset,\n+                        min_length: size,\n+                        from_end: false,\n+                    });\n                     self.patch.add_assign(location,\n-                                          Place::from(temp),\n+                                          dst_place.clone(),\n                                           Rvalue::Use(\n                                               Operand::Move(\n                                                   Place {\n                                                       base: base.clone(),\n-                                                      projection: Some(box Projection {\n-                                                          base: proj.base.clone(),\n-                                                          elem: ProjectionElem::ConstantIndex {\n-                                                              offset: i,\n-                                                              min_length: size,\n-                                                              from_end: false,\n-                                                          }\n-                                                      }),\n+                                                      projection: projection.into_boxed_slice(),\n                                                   }\n                                               )\n                                           )\n                     );\n-                    temp\n-                }).collect();\n-                self.patch.add_assign(\n-                    location,\n-                    dst_place.clone(),\n-                    Rvalue::Aggregate(\n-                        box AggregateKind::Array(item_ty),\n-                        temps.iter().map(\n-                            |x| Operand::Move(Place::from(*x))\n-                        ).collect()\n-                    )\n-                );\n-                for temp in temps {\n-                    self.patch.add_statement(location, StatementKind::StorageDead(temp));\n                 }\n+                _ => {}\n             }\n-            // uniforms statements like _11 = move _2[-1 of 1];\n-            ProjectionElem::ConstantIndex{offset, min_length: _, from_end: true} => {\n-                self.patch.make_nop(location);\n-                self.patch.add_assign(location,\n-                                      dst_place.clone(),\n-                                      Rvalue::Use(\n-                                          Operand::Move(\n-                                              Place {\n-                                                  base: base.clone(),\n-                                                  projection: Some(box Projection {\n-                                                      base: proj.base.clone(),\n-                                                      elem: ProjectionElem::ConstantIndex {\n-                                                          offset: size - offset,\n-                                                          min_length: size,\n-                                                          from_end: false,\n-                                                      },\n-                                                  }),\n-                                              }\n-                                          )\n-                                      )\n-                );\n-            }\n-            _ => {}\n         }\n     }\n }\n@@ -197,12 +200,12 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n \n             for candidate in &visitor.candidates {\n                 let statement = &body[candidate.block].statements[candidate.statement_index];\n-                if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n-                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = **rval {\n+                if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n+                    if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n                             if let Operand::Move(Place {\n                                 base: PlaceBase::Local(local),\n-                                projection: None,\n+                                projection: box [],\n                             }) = item {\n                                 let local_use = &visitor.locals_use[*local];\n                                 let opt_index_and_place =\n@@ -269,16 +272,17 @@ impl RestoreSubsliceArrayMoveOut {\n             }\n             patch.make_nop(candidate);\n             let size = opt_size.unwrap() as u32;\n-            patch.add_assign(candidate,\n-                             dst_place.clone(),\n-                             Rvalue::Use(\n-                                 Operand::Move(\n-                                     Place {\n-                                         base: src_place.base.clone(),\n-                                         projection: Some(box Projection {\n-                                             base: src_place.projection.clone(),\n-                                             elem: ProjectionElem::Subslice{\n-                                                 from: min, to: size - max - 1}})})));\n+\n+            let mut projection = src_place.projection.to_vec();\n+            projection.push(ProjectionElem::Subslice { from: min, to: size - max - 1 });\n+            patch.add_assign(\n+                candidate,\n+                dst_place.clone(),\n+                Rvalue::Use(Operand::Move(Place {\n+                    base: src_place.base.clone(),\n+                    projection: projection.into_boxed_slice(),\n+                })),\n+            );\n         }\n     }\n \n@@ -289,23 +293,34 @@ impl RestoreSubsliceArrayMoveOut {\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n-                    Place {\n-                        base: PlaceBase::Local(_),\n-                        projection: None,\n-                    },\n-                    box Rvalue::Use(Operand::Move(Place {\n-                        base,\n-                        projection: Some(box Projection {\n-                            base: proj_base,\n-                            elem: ProjectionElem::ConstantIndex {\n+                    box(\n+                        Place {\n+                            base: PlaceBase::Local(_),\n+                            projection: box [],\n+                        },\n+                        Rvalue::Use(Operand::Move(Place {\n+                            base: _,\n+                            projection: box [.., ProjectionElem::ConstantIndex {\n                                 offset, min_length: _, from_end: false\n-                            }\n-                        }),\n-                    }))) = &statement.kind {\n-                    return Some((*offset, PlaceRef {\n-                        base,\n-                        projection: proj_base,\n-                    }))\n+                            }],\n+                        })),\n+                    )\n+                ) = &statement.kind {\n+                    // FIXME remove once we can use slices patterns\n+                    if let StatementKind::Assign(\n+                        box(\n+                            _,\n+                            Rvalue::Use(Operand::Move(Place {\n+                                base,\n+                                projection: box [proj_base @ .., _],\n+                            })),\n+                        )\n+                    ) = &statement.kind {\n+                        return Some((*offset, PlaceRef {\n+                            base,\n+                            projection: proj_base,\n+                        }))\n+                    }\n                 }\n             }\n         }"}, {"sha": "b3565d40b8e217e9bdab4f4f2a737adfb3654481", "filename": "src/librustc_mir/util/aggregate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -24,7 +24,7 @@ pub fn expand_aggregate<'tcx>(\n             if adt_def.is_enum() {\n                 set_discriminant = Some(Statement {\n                     kind: StatementKind::SetDiscriminant {\n-                        place: lhs.clone(),\n+                        place: box(lhs.clone()),\n                         variant_index,\n                     },\n                     source_info,\n@@ -39,7 +39,7 @@ pub fn expand_aggregate<'tcx>(\n             let variant_index = VariantIdx::new(0);\n             set_discriminant = Some(Statement {\n                 kind: StatementKind::SetDiscriminant {\n-                    place: lhs.clone(),\n+                    place: box(lhs.clone()),\n                     variant_index,\n                 },\n                 source_info,\n@@ -70,7 +70,7 @@ pub fn expand_aggregate<'tcx>(\n         };\n         Statement {\n             source_info,\n-            kind: StatementKind::Assign(lhs_field, box Rvalue::Use(op)),\n+            kind: StatementKind::Assign(box(lhs_field, Rvalue::Use(op))),\n         }\n     }).chain(set_discriminant)\n }"}, {"sha": "b4c97f91917324e1fdcb9e60587f497e54b595d4", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -38,14 +38,14 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut place_projection = &place.projection;\n+    for (i, elem) in place.projection.iter().enumerate().rev() {\n+        let proj_base = &place.projection[..i];\n \n-    while let Some(proj) = place_projection {\n-        match proj.elem {\n+        match elem {\n             // encountered a Deref, which is ABI-aligned\n             ProjectionElem::Deref => break,\n             ProjectionElem::Field(..) => {\n-                let ty = Place::ty_from(&place.base, &proj.base, local_decls, tcx).ty;\n+                let ty = Place::ty_from(&place.base, proj_base, local_decls, tcx).ty;\n                 match ty.sty {\n                     ty::Adt(def, _) if def.repr.packed() => {\n                         return true\n@@ -55,7 +55,6 @@ where\n             }\n             _ => {}\n         }\n-        place_projection = &proj.base;\n     }\n \n     false"}, {"sha": "52ad97bbde1d7ce6a471d9ccc33d8dcaf22f06d1", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -586,10 +586,7 @@ where\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                 Place {\n                     base: PlaceBase::Local(cur),\n-                    projection: Some(Box::new(Projection {\n-                        base: None,\n-                        elem: ProjectionElem::Deref,\n-                    })),\n+                    projection: Box::new([ProjectionElem::Deref]),\n                 }\n              ),\n              Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n@@ -981,7 +978,7 @@ where\n     fn assign(&self, lhs: &Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n         Statement {\n             source_info: self.source_info,\n-            kind: StatementKind::Assign(lhs.clone(), box rhs)\n+            kind: StatementKind::Assign(box(lhs.clone(), rhs))\n         }\n     }\n }"}, {"sha": "2ea9924af7f28d427ccb150392262f8ce2032056", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6946a817a1345ce739acd8b12255c0a595e9b39/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=a6946a817a1345ce739acd8b12255c0a595e9b39", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn add_assign(&mut self, loc: Location, place: Place<'tcx>, rv: Rvalue<'tcx>) {\n-        self.add_statement(loc, StatementKind::Assign(place, box rv));\n+        self.add_statement(loc, StatementKind::Assign(box(place, rv)));\n     }\n \n     pub fn make_nop(&mut self, loc: Location) {"}]}