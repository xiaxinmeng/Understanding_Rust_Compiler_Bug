{"sha": "169f7911e9852dcd047d0f0c144ce3b18d77f946", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2OWY3OTExZTk4NTJkY2QwNDdkMGYwYzE0NGNlM2IxOGQ3N2Y5NDY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-20T08:12:21Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-20T08:12:21Z"}, "message": "move CTFE engine snapshot state out of miri engine into CTFE machine instance", "tree": {"sha": "1d9c8eafc6f895dd09dab554d70f049abc4bb532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d9c8eafc6f895dd09dab554d70f049abc4bb532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/169f7911e9852dcd047d0f0c144ce3b18d77f946", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/169f7911e9852dcd047d0f0c144ce3b18d77f946", "html_url": "https://github.com/rust-lang/rust/commit/169f7911e9852dcd047d0f0c144ce3b18d77f946", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/169f7911e9852dcd047d0f0c144ce3b18d77f946/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6422d7a392acfc8af28994d65af2bbaecea4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6422d7a392acfc8af28994d65af2bbaecea4f6", "html_url": "https://github.com/rust-lang/rust/commit/ff6422d7a392acfc8af28994d65af2bbaecea4f6"}], "stats": {"total": 548, "additions": 266, "deletions": 282}, "files": [{"sha": "34237a557305c3b571be38793163ad3803123108", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n use syntax::ast::Mutability;\n-use syntax::source_map::Span;\n+use syntax::source_map::{Span, DUMMY_SP};\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n@@ -31,17 +31,18 @@ use rustc::mir::interpret::{\n use interpret::{self,\n     Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n     EvalContext, StackPopCleanup, MemoryKind,\n+    snapshot,\n };\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     span: Span,\n-) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>> {\n+) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n     debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n     let param_env = tcx.param_env(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator::new(), ());\n     // insert a stack frame so any queries have the correct substs\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n@@ -60,10 +61,10 @@ pub fn mk_eval_cx<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, EvalContext<'a, 'tcx, 'tcx, CompileTimeEvaluator>> {\n+) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'tcx, 'tcx>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n     let span = tcx.def_span(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator::new(), ());\n     let mir = ecx.load_mir(instance.def)?;\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n@@ -77,18 +78,17 @@ pub fn mk_eval_cx<'a, 'tcx>(\n }\n \n pub fn eval_promoted<'a, 'mir, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    ecx.with_fresh_body(|ecx| {\n-        eval_body_using_ecx(ecx, cid, Some(mir), param_env)\n-    })\n+    let mut ecx = mk_borrowck_eval_cx(tcx, cid.instance, mir, DUMMY_SP).unwrap();\n+    eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n pub fn op_to_const<'tcx>(\n-    ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n+    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n     normalize: bool,\n ) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n@@ -128,19 +128,19 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, OpTy<'tcx>>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, OpTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n     let span = mir.map(|mir| mir.span).unwrap_or(span);\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator::new(), ());\n     let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n     (r, ecx)\n }\n \n // Returns a pointer to where the result lives\n-fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n+fn eval_body_using_ecx<'mir, 'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -187,17 +187,12 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     Ok(ret.into())\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n-pub struct CompileTimeEvaluator;\n-\n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     fn into(self) -> EvalError<'tcx> {\n         EvalErrorKind::MachineError(self.to_string()).into()\n     }\n }\n \n-impl_stable_hash_for!(struct CompileTimeEvaluator {});\n-\n #[derive(Clone, Debug)]\n enum ConstEvalError {\n     NeedsRfc(String),\n@@ -234,14 +229,39 @@ impl Error for ConstEvalError {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n+// Extra machine state for CTFE, and the Machine instance\n+pub struct CompileTimeEvaluator<'a, 'mir, 'tcx: 'a+'mir> {\n+    /// When this value is negative, it indicates the number of interpreter\n+    /// steps *until* the loop detector is enabled. When it is positive, it is\n+    /// the number of steps after the detector has been enabled modulo the loop\n+    /// detector period.\n+    pub(super) steps_since_detector_enabled: isize,\n+\n+    /// Extra state to detect loops.\n+    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'a, 'mir, 'tcx>,\n+}\n+\n+impl<'a, 'mir, 'tcx> CompileTimeEvaluator<'a, 'mir, 'tcx> {\n+    fn new() -> Self {\n+        CompileTimeEvaluator {\n+            loop_detector: Default::default(),\n+            steps_since_detector_enabled: -snapshot::STEPS_UNTIL_DETECTOR_ENABLED,\n+        }\n+    }\n+}\n+\n+type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n+    EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator<'a, 'mir, 'tcx>>;\n+\n+impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n+    for CompileTimeEvaluator<'a, 'mir, 'tcx>\n+{\n     type MemoryData = ();\n     type MemoryKinds = !;\n \n     const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n-    const DETECT_LOOPS: bool = true;\n \n-    fn find_fn<'a>(\n+    fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -275,7 +295,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         }))\n     }\n \n-    fn call_intrinsic<'a>(\n+    fn call_intrinsic(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -291,7 +311,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         )\n     }\n \n-    fn ptr_op<'a>(\n+    fn ptr_op(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: Scalar,\n@@ -304,21 +324,51 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         )\n     }\n \n-    fn find_foreign_static<'a>(\n+    fn find_foreign_static(\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         _def_id: DefId,\n     ) -> EvalResult<'tcx, &'tcx Allocation> {\n         err!(ReadForeignStatic)\n     }\n \n-    fn box_alloc<'a>(\n+    fn box_alloc(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n+\n+    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n+        {\n+            let steps = &mut ecx.machine.steps_since_detector_enabled;\n+\n+            *steps += 1;\n+            if *steps < 0 {\n+                return Ok(());\n+            }\n+\n+            *steps %= snapshot::DETECTOR_SNAPSHOT_PERIOD;\n+            if *steps != 0 {\n+                return Ok(());\n+            }\n+        }\n+\n+        if ecx.machine.loop_detector.is_empty() {\n+            // First run of the loop detector\n+\n+            // FIXME(#49980): make this warning a lint\n+            ecx.tcx.sess.span_warn(ecx.frame().span,\n+                \"Constant evaluating a complex constant, this might take some time\");\n+        }\n+\n+        ecx.machine.loop_detector.observe_and_analyze(\n+            &ecx.tcx,\n+            &ecx.memory,\n+            &ecx.stack[..],\n+        )\n+    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "c6b527f42294c1134535272da53f0774ca17338b", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -21,7 +21,7 @@ use rustc_apfloat::Float;\n \n use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "91990551b5c9b8d3ca9835e4627d5e75273c0455", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 19, "deletions": 88, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -14,7 +14,6 @@ use std::mem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n-use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n@@ -23,7 +22,6 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc::mir::interpret::{\n     GlobalId, Scalar, FrameInfo, AllocId,\n     EvalResult, EvalErrorKind,\n@@ -38,9 +36,7 @@ use super::{\n     Memory, Machine\n };\n \n-use super::snapshot::InfiniteLoopDetector;\n-\n-pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n@@ -55,19 +51,6 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n-\n-    /// The maximum number of stack frames allowed\n-    pub(super) stack_limit: usize,\n-\n-    /// When this value is negative, it indicates the number of interpreter\n-    /// steps *until* the loop detector is enabled. When it is positive, it is\n-    /// the number of steps after the detector has been enabled modulo the loop\n-    /// detector period.\n-    pub(super) steps_since_detector_enabled: isize,\n-\n-    /// Extra state to detect loops.\n-    /// FIXME: Move this to the CTFE machine's state, out of the general miri engine.\n-    pub(super) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n /// A stack frame.\n@@ -112,29 +95,6 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n-// Not using the macro because that does not support types depending on 'tcx\n-impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>) {\n-\n-        let Frame {\n-            mir,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-        } = self;\n-\n-        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n-        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n-    }\n-}\n-\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n@@ -147,21 +107,6 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n-            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue<Id=AllocId> {\n@@ -189,19 +134,16 @@ impl<'tcx> LocalValue {\n     }\n }\n \n-impl_stable_hash_for!(enum self::LocalValue {\n-    Dead,\n-    Live(x),\n-});\n-\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n+    for &'b EvalContext<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n     for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n@@ -210,24 +152,27 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n+impl<'b, 'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'b EvalContext<'a, 'mir, 'tcx, M>\n+    where M: Machine<'a, 'mir, 'tcx>\n {\n     #[inline]\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+    fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n         *self.tcx\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n         *self.tcx\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for &'a EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n+    for &'b EvalContext<'a, 'mir, 'tcx, M>\n+{\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n@@ -238,8 +183,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for &'a EvalContext<'a, 'm\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n+{\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n@@ -249,9 +195,7 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n     }\n }\n \n-const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n-\n-impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -264,22 +208,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             param_env,\n             memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n-            stack_limit: tcx.sess.const_eval_stack_frame_limit,\n-            loop_detector: Default::default(),\n-            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n         }\n     }\n \n-    pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n-        let stack = mem::replace(&mut self.stack, Vec::new());\n-        let steps = mem::replace(&mut self.steps_since_detector_enabled,\n-                                 -STEPS_UNTIL_DETECTOR_ENABLED);\n-        let r = f(self);\n-        self.stack = stack;\n-        self.steps_since_detector_enabled = steps;\n-        r\n-    }\n-\n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n@@ -553,7 +484,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             self.frame_mut().locals = locals;\n         }\n \n-        if self.stack.len() > self.stack_limit {\n+        if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n             err!(StackFrameLimitReached)\n         } else {\n             Ok(())"}, {"sha": "d2f274231c17049806e69b1ac1a26e4735fc510d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -46,7 +46,7 @@ fn numeric_intrinsic<'tcx>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Returns whether emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "1eb0280409527cec262f2bcf527bfde73c5d829a", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -20,20 +20,22 @@ use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n-/// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'mir, 'tcx>: Clone + Eq {\n+/// and some use case dependent behaviour can instead be applied.\n+/// FIXME: We should be able to get rid of the 'a here if we can get rid of the 'a in\n+/// `snapshot::EvalSnapshot`.\n+pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData: Clone + Eq;\n+    type MemoryData;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq;\n+    type MemoryKinds: ::std::fmt::Debug + Copy + Eq;\n \n     /// The memory kind to use for mutated statics -- or None if those are not supported.\n     const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n-    /// Whether to attempt to detect infinite loops (any kind of infinite\n-    /// execution, really).\n-    const DETECT_LOOPS: bool;\n+    /// Called before a basic block terminator is executed.\n+    /// You can use this to detect endlessly running programs.\n+    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -45,7 +47,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// nor just jump to `ret`, but instead push their own stack frame.)\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n-    fn find_fn<'a>(\n+    fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -55,7 +57,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n \n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n-    fn call_intrinsic<'a>(\n+    fn call_intrinsic(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -66,7 +68,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// This can be called multiple times for the same static item and should return consistent\n     /// results.  Once the item is *written* the first time, as usual for statics a copy is\n     /// made and this function is not called again.\n-    fn find_foreign_static<'a>(\n+    fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n     ) -> EvalResult<'tcx, &'tcx Allocation>;\n@@ -75,7 +77,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n-    fn ptr_op<'a>(\n+    fn ptr_op(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n@@ -87,13 +89,13 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory\n-    fn box_alloc<'a>(\n+    fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx>;\n \n     /// Execute a validation operation\n-    fn validation_op<'a>(\n+    fn validation_op(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,\n         _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,"}, {"sha": "7e843fd1ddea9886a45863e7cdc0fc134573f30e", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -39,8 +39,9 @@ pub enum MemoryKind<T> {\n     Machine(T),\n }\n \n-#[derive(Clone)]\n-pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+// `Memory` has to depend on the `Machine` because some of its operations\n+// (e.g. `get`) call a `Machine` hook.\n+pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n@@ -59,13 +60,15 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n+impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n+    for &'b Memory<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n-impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n     for &'b &'c mut Memory<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n@@ -74,7 +77,23 @@ impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+// FIXME: Really we shouldnt clone memory, ever. Snapshot machinery should instad\n+// carefully copy only the reachable parts.\n+impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n+    Clone for Memory<'a, 'mir, 'tcx, M>\n+    where M::MemoryData: Clone\n+{\n+    fn clone(&self) -> Self {\n+        Memory {\n+            data: self.data.clone(),\n+            alloc_map: self.alloc_map.clone(),\n+            dead_alloc_map: self.dead_alloc_map.clone(),\n+            tcx: self.tcx,\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n@@ -279,7 +298,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Helper function to obtain the global (tcx) allocation for a static\n     fn get_static_alloc(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n@@ -491,7 +510,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Byte accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes.  You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n@@ -564,7 +583,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Reading and writing\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn intern_static(\n         &mut self,\n@@ -877,7 +896,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Relocations\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Return all relocations overlapping with the given ptr-offset pair.\n     fn relocations(\n         &self,\n@@ -950,7 +969,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Undefined bytes\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(\n         &mut self,"}, {"sha": "870ce4574e2973b5f778e614e3ead6a6957a6c6b", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -17,7 +17,7 @@ mod operand;\n mod machine;\n mod memory;\n mod operator;\n-mod snapshot;\n+pub(crate) mod snapshot; // for const_eval\n mod step;\n mod terminator;\n mod traits;"}, {"sha": "fef2f916b415667652fbf123527509fd40d5257a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -82,11 +82,6 @@ impl<'tcx> Value {\n     }\n }\n \n-impl_stable_hash_for!(enum ::interpret::Value {\n-    Scalar(x),\n-    ScalarPair(x, y),\n-});\n-\n // ScalarPair needs a type to interpret, so we often have a value and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n@@ -132,11 +127,6 @@ impl Operand {\n     }\n }\n \n-impl_stable_hash_for!(enum ::interpret::Operand {\n-    Immediate(x),\n-    Indirect(x),\n-});\n-\n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n     crate op: Operand, // ideally we'd make this private, but const_prop needs this\n@@ -206,7 +196,7 @@ fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Try reading a value in memory; this is interesting particularily for ScalarPair.\n     /// Return None if the layout does not permit loading this as a value.\n     pub(super) fn try_read_value_from_mplace("}, {"sha": "dd6ee374c0facc9f4b4370f5577fb62f8c7b6636", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::interpret::{EvalResult, Scalar};\n use super::{EvalContext, PlaceTy, Value, Machine, ValTy};\n \n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -47,7 +47,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "80229f66765f2a2bba1cf9a984a77826b3efe9b8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -13,13 +13,10 @@\n //! All high-level functions to write to memory work on places as destinations.\n \n use std::convert::TryFrom;\n-use std::mem;\n \n-use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n use rustc::mir::interpret::{\n     GlobalId, AllocId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n@@ -39,12 +36,6 @@ pub struct MemPlace<Id=AllocId> {\n     pub extra: Option<Scalar<Id>>,\n }\n \n-impl_stable_hash_for!(struct ::interpret::MemPlace {\n-    ptr,\n-    align,\n-    extra,\n-});\n-\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place<Id=AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n@@ -58,23 +49,6 @@ pub enum Place<Id=AllocId> {\n     },\n }\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for Place {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self, hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n-\n-            Place::Local { frame, local } => {\n-                frame.hash_stable(hcx, hasher);\n-                local.hash_stable(hcx, hasher);\n-            },\n-        }\n-    }\n-}\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx> {\n     place: Place,\n@@ -255,7 +229,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n     pub fn ref_to_mplace("}, {"sha": "89287d5871f24f1d990e68a6bcb36ed5b4b89635", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 113, "deletions": 57, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -2,7 +2,11 @@\n //! during const-evaluation by taking snapshots of the state of the interpreter\n //! at regular intervals.\n \n+// This lives in `interpret` because it needs access to all sots of private state.  However,\n+// it is not used by the general miri engine, just by CTFE.\n+\n use std::hash::{Hash, Hasher};\n+use std::mem;\n \n use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n use rustc::mir;\n@@ -21,9 +25,18 @@ use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n use super::eval_context::{LocalValue, StackPopCleanup};\n-use super::{Frame, Memory, Machine, Operand, MemPlace, Place, Value};\n-\n-pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+use super::{Frame, Memory, Operand, MemPlace, Place, Value};\n+use const_eval::CompileTimeEvaluator;\n+\n+/// Number of steps until the detector even starts doing anything.\n+/// Also, a warning is shown to the user when this number is reached.\n+pub(crate) const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n+/// The number of steps between loop detector snapshots.\n+/// Should be a power of two for performance reasons.\n+pub(crate) const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n+\n+#[derive(Default)]\n+pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n     /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n@@ -35,34 +48,20 @@ pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mi\n     /// An `EvalSnapshot` will only be fully cloned once it has caused a\n     /// collision in `hashes`. As a result, the detector must observe at least\n     /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn default() -> Self {\n-        InfiniteLoopDetector {\n-            hashes: FxHashSet::default(),\n-            snapshots: FxHashSet::default(),\n-        }\n-    }\n+    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n+impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n {\n     /// Returns `true` if the loop detector has not yet observed a snapshot.\n     pub fn is_empty(&self) -> bool {\n         self.hashes.is_empty()\n     }\n \n-    pub fn observe_and_analyze(\n+    pub fn observe_and_analyze<'b>(\n         &mut self,\n         tcx: &TyCtxt<'b, 'tcx, 'tcx>,\n-        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        memory: &Memory<'a, 'mir, 'tcx, CompileTimeEvaluator<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n \n@@ -179,7 +178,7 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n \n impl_snapshot_for!(struct Pointer {\n     alloc_id,\n-    offset -> *offset,\n+    offset -> *offset, // just copy offset verbatim\n });\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n@@ -203,12 +202,34 @@ impl_snapshot_for!(enum ScalarMaybeUndef {\n     Undef,\n });\n \n+impl_stable_hash_for!(struct ::interpret::MemPlace {\n+    ptr,\n+    align,\n+    extra,\n+});\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     extra,\n-    align -> *align,\n+    align -> *align, // just copy alignment verbatim\n });\n \n+// Can't use the macro here because that does not support named enum fields.\n+impl<'a> HashStable<StableHashingContext<'a>> for Place {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self, hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>)\n+    {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n+\n+            Place::Local { frame, local } => {\n+                frame.hash_stable(hcx, hasher);\n+                local.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -226,16 +247,28 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     }\n }\n \n+impl_stable_hash_for!(enum ::interpret::Value {\n+    Scalar(x),\n+    ScalarPair(x, y),\n+});\n impl_snapshot_for!(enum Value {\n     Scalar(s),\n     ScalarPair(s, t),\n });\n \n+impl_stable_hash_for!(enum ::interpret::Operand {\n+    Immediate(x),\n+    Indirect(x),\n+});\n impl_snapshot_for!(enum Operand {\n     Immediate(v),\n     Indirect(m),\n });\n \n+impl_stable_hash_for!(enum ::interpret::LocalValue {\n+    Dead,\n+    Live(x),\n+});\n impl_snapshot_for!(enum LocalValue {\n     Live(v),\n     Dead,\n@@ -280,6 +313,21 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     }\n }\n \n+// Can't use the macro here because that does not support named enum fields.\n+impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>)\n+    {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n+            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx: 'a> {\n     instance: &'a ty::Instance<'tcx>,\n@@ -291,6 +339,28 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     stmt: usize,\n }\n \n+// Not using the macro because that does not support types depending on 'tcx\n+impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>) {\n+\n+        let Frame {\n+            mir,\n+            instance,\n+            span,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n+        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n+    }\n+}\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -320,39 +390,26 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     }\n }\n \n-#[derive(Eq, PartialEq)]\n-struct MemorySnapshot<'a, 'mir: 'a, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx> + 'a> {\n-    data: &'a M::MemoryData,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-{\n-    fn snapshot<'b: 'a>(&'b self) -> MemorySnapshot<'b, 'mir, 'tcx, M> {\n-        let Memory { data, .. } = self;\n-        MemorySnapshot { data }\n-    }\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx, M> SnapshotContext<'b> for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n+    for Memory<'a, 'mir, 'tcx, CompileTimeEvaluator<'a, 'mir, 'tcx>>\n {\n     fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n         self.get(*id).ok()\n     }\n }\n \n /// The virtual machine state during const-evaluation at a given point in time.\n-struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    memory: Memory<'a, 'mir, 'tcx, M>,\n+/// We assume the `CompileTimeEvaluator` has no interesting extra state that\n+/// is worth considering here.\n+struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n+    memory: Memory<'a, 'mir, 'tcx, CompileTimeEvaluator<'a, 'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx: 'a + 'mir> EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn new(\n-        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        memory: &Memory<'a, 'mir, 'tcx, CompileTimeEvaluator<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>]\n     ) -> Self {\n         EvalSnapshot {\n@@ -361,16 +418,17 @@ impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    fn snapshot<'b: 'a>(&'b self)\n-        -> (MemorySnapshot<'b, 'mir, 'tcx, M>, Vec<FrameSnapshot<'a, 'tcx>>)\n+    // Used to compare two snapshots\n+    fn snapshot(&'b self)\n+        -> Vec<FrameSnapshot<'b, 'tcx>>\n     {\n-        let EvalSnapshot{ memory, stack } = self;\n-        (memory.snapshot(), stack.iter().map(|frame| frame.snapshot(memory)).collect())\n+        // Start with the stack, iterate and recursively snapshot\n+        self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n     }\n+\n }\n \n-impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n@@ -383,26 +441,24 @@ impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n \n // Not using the macro because we need special handling for `memory`, which the macro\n // does not support at the same time as the extra bounds on the type.\n-impl<'a, 'b, 'mir, 'tcx, M> HashStable<StableHashingContext<'b>>\n-    for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'b, 'mir, 'tcx> HashStable<StableHashingContext<'b>>\n+    for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'b>,\n         hasher: &mut StableHasher<W>)\n     {\n+        // Not hashing memory: Avoid hashing memory all the time during execution\n         let EvalSnapshot{ memory: _, stack } = self;\n         stack.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> Eq for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n {}\n \n-impl<'a, 'mir, 'tcx, M> PartialEq for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx> PartialEq for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn eq(&self, other: &Self) -> bool {\n         self.snapshot() == other.snapshot()"}, {"sha": "180c8f211a6a05f254954f3bfcd6538ad1c063ba", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -45,45 +45,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn inc_step_counter_and_detect_loops(&mut self) -> EvalResult<'tcx, ()> {\n-        /// The number of steps between loop detector snapshots.\n-        /// Should be a power of two for performance reasons.\n-        const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n-\n-        {\n-            let steps = &mut self.steps_since_detector_enabled;\n-\n-            *steps += 1;\n-            if *steps < 0 {\n-                return Ok(());\n-            }\n-\n-            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n-            if *steps != 0 {\n-                return Ok(());\n-            }\n-        }\n-\n-        if !M::DETECT_LOOPS {\n-            return Ok(());\n-        }\n-\n-        if self.loop_detector.is_empty() {\n-            // First run of the loop detector\n-\n-            // FIXME(#49980): make this warning a lint\n-            self.tcx.sess.span_warn(self.frame().span,\n-                \"Constant evaluating a complex constant, this might take some time\");\n-        }\n-\n-        self.loop_detector.observe_and_analyze(\n-            &self.tcx,\n-            &self.memory,\n-            &self.stack[..],\n-        )\n-    }\n-\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn run(&mut self) -> EvalResult<'tcx> {\n         while self.step()? {}\n         Ok(())\n@@ -108,7 +70,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return Ok(true);\n         }\n \n-        self.inc_step_counter_and_detect_loops()?;\n+        M::before_terminator(self)?;\n \n         let terminator = basic_block.terminator();\n         assert_eq!(old_frames, self.cur_frame());"}, {"sha": "c7ed69e0cb66d882a01ba78fc599b96d9bc675ba", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -20,7 +20,7 @@ use super::{\n     EvalContext, Machine, Value, OpTy, Place, PlaceTy, Operand, StackPopCleanup\n };\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "5ea588b957a4ffed98f4a25d3424e301b2d1f2a4", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -16,7 +16,7 @@ use syntax::ast::Mutability;\n \n use super::{EvalContext, Machine, MemoryKind};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "f816983ab47a2bbb37c0c4cfe972d92d0a411d7e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -95,7 +95,7 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     out\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn validate_scalar(\n         &self,\n         value: ScalarMaybeUndef,"}, {"sha": "e48af71b646b735c1e8e5d102e07856668b6f618", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/169f7911e9852dcd047d0f0c144ce3b18d77f946/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=169f7911e9852dcd047d0f0c144ce3b18d77f946", "patch": "@@ -69,7 +69,7 @@ type Const<'tcx> = (OpTy<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n-    ecx: EvalContext<'a, 'b, 'tcx, CompileTimeEvaluator>,\n+    ecx: EvalContext<'a, 'b, 'tcx, CompileTimeEvaluator<'a, 'b, 'tcx>>,\n     mir: &'b Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource,\n@@ -310,7 +310,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n                 let res = self.use_ecx(source_info, |this| {\n-                    eval_promoted(&mut this.ecx, cid, this.mir, this.param_env)\n+                    eval_promoted(this.tcx, cid, this.mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n                 Some((res, source_info.span))"}]}