{"sha": "6647a3402bf75368de1a692370c558d423f36940", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NDdhMzQwMmJmNzUzNjhkZTFhNjkyMzcwYzU1OGQ0MjNmMzY5NDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-08T00:23:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-08T00:23:59Z"}, "message": "auto merge of #4833 : pcwalton/rust/demuting, r=pcwalton", "tree": {"sha": "f20d5b197e8eb9d86302fb631a4fe18b2634324a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20d5b197e8eb9d86302fb631a4fe18b2634324a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6647a3402bf75368de1a692370c558d423f36940", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6647a3402bf75368de1a692370c558d423f36940", "html_url": "https://github.com/rust-lang/rust/commit/6647a3402bf75368de1a692370c558d423f36940", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6647a3402bf75368de1a692370c558d423f36940/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "html_url": "https://github.com/rust-lang/rust/commit/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616"}, {"sha": "472797b04a3fac95e14368e5f1b149573d3d676c", "url": "https://api.github.com/repos/rust-lang/rust/commits/472797b04a3fac95e14368e5f1b149573d3d676c", "html_url": "https://github.com/rust-lang/rust/commit/472797b04a3fac95e14368e5f1b149573d3d676c"}], "stats": {"total": 4518, "additions": 2433, "deletions": 2085}, "files": [{"sha": "f6e0ebda92508c0b697ce0b4d690539a04119b61", "filename": "src/libcargo/pgp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcargo%2Fpgp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcargo%2Fpgp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fpgp.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -81,9 +81,9 @@ pub fn init(root: &Path) {\n     let p = root.push(\"gpg\");\n     if !os::path_is_dir(&p) {\n         os::make_dir(&p, 0x1c0i32);\n-        let p = run::start_program(~\"gpg\", ~[~\"--homedir\",\n-                                             p.to_str(),\n-                                             ~\"--import\"]);\n+        let mut p = run::start_program(~\"gpg\", ~[~\"--homedir\",\n+                                                 p.to_str(),\n+                                                 ~\"--import\"]);\n         p.input().write_str(signing_key());\n         let s = p.finish();\n         if s != 0 {"}, {"sha": "5f295bdcb83a97e437a6753e494f67148fbfc8cd", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 86, "deletions": 73, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -24,26 +24,26 @@ use option::{None, Option, Some};\n use option;\n use vec;\n \n-pub type DListLink<T> = Option<@DListNode<T>>;\n+pub type DListLink<T> = Option<@mut DListNode<T>>;\n \n pub struct DListNode<T> {\n     data: T,\n-    mut linked: bool, // for assertions\n-    mut prev: DListLink<T>,\n-    mut next: DListLink<T>,\n+    linked: bool, // for assertions\n+    prev: DListLink<T>,\n+    next: DListLink<T>,\n }\n \n pub struct DList<T> {\n-    mut size: uint,\n-    mut hd: DListLink<T>,\n-    mut tl: DListLink<T>,\n+    size: uint,\n+    hd: DListLink<T>,\n+    tl: DListLink<T>,\n }\n \n priv impl<T> DListNode<T> {\n-    pure fn assert_links(@self) {\n+    pure fn assert_links(@mut self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n-              Some(me) => if !managed::ptr_eq(self, me) {\n+              Some(me) => if !managed::mut_ptr_eq(self, me) {\n                   die!(~\"Asymmetric next-link in dlist node.\")\n               },\n               None => die!(~\"One-way next-link in dlist node.\")\n@@ -52,7 +52,7 @@ priv impl<T> DListNode<T> {\n         }\n         match self.prev {\n             Some(neighbour) => match neighbour.next {\n-              Some(me) => if !managed::ptr_eq(me, self) {\n+              Some(me) => if !managed::mut_ptr_eq(me, self) {\n                   die!(~\"Asymmetric prev-link in dlist node.\")\n               },\n               None => die!(~\"One-way prev-link in dlist node.\")\n@@ -64,24 +64,24 @@ priv impl<T> DListNode<T> {\n \n impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link(@self) -> DListLink<T> {\n+    pure fn next_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    pure fn next_node(@self) -> @DListNode<T> {\n+    pure fn next_node(@mut self) -> @mut DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => die!(~\"This dlist node has no next neighbour.\")\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link(@self) -> DListLink<T> {\n+    pure fn prev_link(@mut self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    pure fn prev_node(@self) -> @DListNode<T> {\n+    pure fn prev_node(@mut self) -> @mut DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => die!(~\"This dlist node has no previous neighbour.\")\n@@ -90,23 +90,23 @@ impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pub pure fn new_dlist_node<T>(data: T) -> @DListNode<T> {\n-    @DListNode { data: data, linked: false, prev: None, next: None }\n+pub pure fn new_dlist_node<T>(data: T) -> @mut DListNode<T> {\n+    @mut DListNode { data: data, linked: false, prev: None, next: None }\n }\n \n /// Creates a new, empty dlist.\n-pub pure fn DList<T>() -> @DList<T> {\n-    @DList { size: 0, hd: None, tl: None }\n+pub pure fn DList<T>() -> @mut DList<T> {\n+    @mut DList { size: 0, hd: None, tl: None }\n }\n \n /// Creates a new dlist with a single element\n-pub pure fn from_elem<T>(data: T) -> @DList<T> {\n+pub pure fn from_elem<T>(data: T) -> @mut DList<T> {\n     let list = DList();\n     unsafe { list.push(data); }\n     list\n }\n \n-pub fn from_vec<T: Copy>(vec: &[T]) -> @DList<T> {\n+pub fn from_vec<T: Copy>(vec: &[T]) -> @mut DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -115,7 +115,7 @@ pub fn from_vec<T: Copy>(vec: &[T]) -> @DList<T> {\n \n /// Produce a list from a list of lists, leaving no elements behind in the\n /// input. O(number of sub-lists).\n-pub fn concat<T>(lists: @DList<@DList<T>>) -> @DList<T> {\n+pub fn concat<T>(lists: @mut DList<@mut DList<T>>) -> @mut DList<T> {\n     let result = DList();\n     while !lists.is_empty() {\n         result.append(lists.pop().get());\n@@ -125,25 +125,30 @@ pub fn concat<T>(lists: @DList<@DList<T>>) -> @DList<T> {\n \n priv impl<T> DList<T> {\n     static pure fn new_link(data: T) -> DListLink<T> {\n-        Some(@DListNode { data: data, linked: true, prev: None, next: None })\n-    }\n-    pure fn assert_mine(@self, nobe: @DListNode<T>) {\n+        Some(@mut DListNode {\n+            data: data,\n+            linked: true,\n+            prev: None,\n+            next: None\n+        })\n+    }\n+    pure fn assert_mine(@mut self, nobe: @mut DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n             die!(~\"This dlist is empty; that node can't be on it.\")\n         }\n         if !nobe.linked { die!(~\"That node isn't linked to any dlist.\") }\n         if !((nobe.prev.is_some()\n-              || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+              || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n                                  nobe)) &&\n              (nobe.next.is_some()\n-              || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+              || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n                                  nobe))) {\n             die!(~\"That node isn't on this dlist.\")\n         }\n     }\n-    fn make_mine(nobe: @DListNode<T>) {\n+    fn make_mine(nobe: @mut DListNode<T>) {\n         if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n             die!(~\"Cannot insert node that's already on a dlist!\")\n         }\n@@ -152,7 +157,7 @@ priv impl<T> DList<T> {\n     // Link two nodes together. If either of them are 'none', also sets\n     // the head and/or tail pointers appropriately.\n     #[inline(always)]\n-    fn link(before: DListLink<T>, after: DListLink<T>) {\n+    fn link(&mut self, before: DListLink<T>, after: DListLink<T>) {\n         match before {\n             Some(neighbour) => neighbour.next = after,\n             None            => self.hd        = after\n@@ -163,7 +168,7 @@ priv impl<T> DList<T> {\n         }\n     }\n     // Remove a node from the list.\n-    fn unlink(@self, nobe: @DListNode<T>) {\n+    fn unlink(@mut self, nobe: @mut DListNode<T>) {\n         self.assert_mine(nobe);\n         assert self.size > 0;\n         self.link(nobe.prev, nobe.next);\n@@ -173,24 +178,28 @@ priv impl<T> DList<T> {\n         self.size -= 1;\n     }\n \n-    fn add_head(@self, nobe: DListLink<T>) {\n+    fn add_head(@mut self, nobe: DListLink<T>) {\n         self.link(nobe, self.hd); // Might set tail too.\n         self.hd = nobe;\n         self.size += 1;\n     }\n-    fn add_tail(@self, nobe: DListLink<T>) {\n+    fn add_tail(@mut self, nobe: DListLink<T>) {\n         self.link(self.tl, nobe); // Might set head too.\n         self.tl = nobe;\n         self.size += 1;\n     }\n-    fn insert_left(@self, nobe: DListLink<T>, neighbour: @DListNode<T>) {\n+    fn insert_left(@mut self,\n+                   nobe: DListLink<T>,\n+                   neighbour: @mut DListNode<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, Some(neighbour));\n         self.size += 1;\n     }\n-    fn insert_right(@self, neighbour: @DListNode<T>, nobe: DListLink<T>) {\n+    fn insert_right(@mut self,\n+                    neighbour: @mut DListNode<T>,\n+                    nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(nobe, neighbour.next);\n@@ -201,32 +210,32 @@ priv impl<T> DList<T> {\n \n impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    pure fn len(@self) -> uint { self.size }\n+    pure fn len(@mut self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    pure fn is_empty(@self) -> bool { self.len() == 0 }\n+    pure fn is_empty(@mut self) -> bool { self.len() == 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(@self, data: T) {\n+    fn push_head(@mut self, data: T) {\n         self.add_head(DList::new_link(data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(@self, data: T) -> @DListNode<T> {\n+    fn push_head_n(@mut self, data: T) -> @mut DListNode<T> {\n         let mut nobe = DList::new_link(data);\n         self.add_head(nobe);\n         nobe.get()\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(@self, data: T) {\n+    fn push(@mut self, data: T) {\n         self.add_tail(DList::new_link(data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(@self, data: T) -> @DListNode<T> {\n+    fn push_n(@mut self, data: T) -> @mut DListNode<T> {\n         let mut nobe = DList::new_link(data);\n         self.add_tail(nobe);\n         nobe.get()\n@@ -235,14 +244,16 @@ impl<T> DList<T> {\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(@self, data: T, neighbour: @DListNode<T>) {\n+    fn insert_before(@mut self, data: T, neighbour: @mut DListNode<T>) {\n         self.insert_left(DList::new_link(data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n      * given node. O(1).\n      */\n-    fn insert_n_before(@self, nobe: @DListNode<T>, neighbour: @DListNode<T>) {\n+    fn insert_n_before(@mut self,\n+                       nobe: @mut DListNode<T>,\n+                       neighbour: @mut DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_left(Some(nobe), neighbour);\n     }\n@@ -251,10 +262,10 @@ impl<T> DList<T> {\n      * and get its containing node. O(1).\n      */\n     fn insert_before_n(\n-        @self,\n+        @mut self,\n         data: T,\n-        neighbour: @DListNode<T>\n-    ) -> @DListNode<T> {\n+        neighbour: @mut DListNode<T>\n+    ) -> @mut DListNode<T> {\n         let mut nobe = DList::new_link(data);\n         self.insert_left(nobe, neighbour);\n         nobe.get()\n@@ -263,14 +274,16 @@ impl<T> DList<T> {\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(@self, data: T, neighbour: @DListNode<T>) {\n+    fn insert_after(@mut self, data: T, neighbour: @mut DListNode<T>) {\n         self.insert_right(neighbour, DList::new_link(data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n      * given node. O(1).\n      */\n-    fn insert_n_after(@self, nobe: @DListNode<T>, neighbour: @DListNode<T>) {\n+    fn insert_n_after(@mut self,\n+                      nobe: @mut DListNode<T>,\n+                      neighbour: @mut DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, Some(nobe));\n     }\n@@ -279,42 +292,42 @@ impl<T> DList<T> {\n      * and get its containing node. O(1).\n      */\n     fn insert_after_n(\n-        @self,\n+        @mut self,\n         data: T,\n-        neighbour: @DListNode<T>\n-    ) -> @DListNode<T> {\n+        neighbour: @mut DListNode<T>\n+    ) -> @mut DListNode<T> {\n         let mut nobe = DList::new_link(data);\n         self.insert_right(neighbour, nobe);\n         nobe.get()\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n(@self) -> DListLink<T> {\n+    fn pop_n(@mut self) -> DListLink<T> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n(@self) -> DListLink<T> {\n+    fn pop_tail_n(@mut self) -> DListLink<T> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n(@self) -> DListLink<T> { self.hd }\n+    pure fn peek_n(@mut self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n(@self) -> DListLink<T> { self.tl }\n+    pure fn peek_tail_n(@mut self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    pure fn head_n(@self) -> @DListNode<T> {\n+    pure fn head_n(@mut self) -> @mut DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => die!(\n                 ~\"Attempted to get the head of an empty dlist.\")\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    pure fn tail_n(@self) -> @DListNode<T> {\n+    pure fn tail_n(@mut self) -> @mut DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => die!(\n@@ -323,14 +336,14 @@ impl<T> DList<T> {\n     }\n \n     /// Remove a node from anywhere in the list. O(1).\n-    fn remove(@self, nobe: @DListNode<T>) { self.unlink(nobe); }\n+    fn remove(@mut self, nobe: @mut DListNode<T>) { self.unlink(nobe); }\n \n     /**\n      * Empty another list onto the end of this list, joining this list's tail\n      * to the other list's head. O(1).\n      */\n-    fn append(@self, them: @DList<T>) {\n-        if managed::ptr_eq(self, them) {\n+    fn append(@mut self, them: @mut DList<T>) {\n+        if managed::mut_ptr_eq(self, them) {\n             die!(~\"Cannot append a dlist to itself!\")\n         }\n         if them.len() > 0 {\n@@ -346,8 +359,8 @@ impl<T> DList<T> {\n      * Empty another list onto the start of this list, joining the other\n      * list's tail to this list's head. O(1).\n      */\n-    fn prepend(@self, them: @DList<T>) {\n-        if managed::ptr_eq(self, them) {\n+    fn prepend(@mut self, them: @mut DList<T>) {\n+        if managed::mut_ptr_eq(self, them) {\n             die!(~\"Cannot prepend a dlist to itself!\")\n         }\n         if them.len() > 0 {\n@@ -361,7 +374,7 @@ impl<T> DList<T> {\n     }\n \n     /// Reverse the list's elements in place. O(n).\n-    fn reverse(@self) {\n+    fn reverse(@mut self) {\n         do option::while_some(self.hd) |nobe| {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n@@ -375,7 +388,7 @@ impl<T> DList<T> {\n      * Remove everything from the list. This is important because the cyclic\n      * links won't otherwise be automatically refcounted-collected. O(n).\n      */\n-    fn clear(@self) {\n+    fn clear(@mut self) {\n         // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n         // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n@@ -384,7 +397,7 @@ impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(@self, f: fn(@DListNode<T>) -> bool) {\n+    pure fn each_node(@mut self, f: fn(@mut DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -394,7 +407,7 @@ impl<T> DList<T> {\n     }\n \n     /// Check data structure integrity. O(n).\n-    fn assert_consistent(@self) {\n+    fn assert_consistent(@mut self) {\n         if self.hd.is_none() || self.tl.is_none() {\n             assert self.hd.is_none() && self.tl.is_none();\n         }\n@@ -413,7 +426,7 @@ impl<T> DList<T> {\n                 rabbit = rabbit.get().next;\n             }\n             if rabbit.is_some() {\n-                assert !managed::ptr_eq(rabbit.get(), nobe);\n+                assert !managed::mut_ptr_eq(rabbit.get(), nobe);\n             }\n             // advance\n             link = nobe.next_link();\n@@ -434,7 +447,7 @@ impl<T> DList<T> {\n                 rabbit = rabbit.get().prev;\n             }\n             if rabbit.is_some() {\n-                assert !managed::ptr_eq(rabbit.get(), nobe);\n+                assert !managed::mut_ptr_eq(rabbit.get(), nobe);\n             }\n             // advance\n             link = nobe.prev_link();\n@@ -446,33 +459,33 @@ impl<T> DList<T> {\n \n impl<T: Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n-    fn pop(@self) -> Option<T> {\n+    fn pop(@mut self) -> Option<T> {\n         self.pop_n().map(|nobe| nobe.data)\n     }\n \n     /// Remove data from the tail of the list. O(1).\n-    fn pop_tail(@self) -> Option<T> {\n+    fn pop_tail(@mut self) -> Option<T> {\n         self.pop_tail_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head. O(1).\n-    pure fn peek(@self) -> Option<T> {\n+    pure fn peek(@mut self) -> Option<T> {\n         self.peek_n().map(|nobe| nobe.data)\n     }\n \n     /// Get data at the list's tail. O(1).\n-    pure fn peek_tail(@self) -> Option<T> {\n+    pure fn peek_tail(@mut self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n \n     /// Get data at the list's head, failing if empty. O(1).\n-    pure fn head(@self) -> T { self.head_n().data }\n+    pure fn head(@mut self) -> T { self.head_n().data }\n \n     /// Get data at the list's tail, failing if empty. O(1).\n-    pure fn tail(@self) -> T { self.tail_n().data }\n+    pure fn tail(@mut self) -> T { self.tail_n().data }\n \n     /// Get the elements of the list as a vector. O(n).\n-    pure fn to_vec(@self) -> ~[T] {\n+    pure fn to_vec(@mut self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         unsafe {\n             // Take this out of the unchecked when iter's functions are pure"}, {"sha": "2c2d0938eda2cdcf411f3e81a744c2363f476580", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -9,14 +9,15 @@\n // except according to those terms.\n \n mod inst {\n+    use cast;\n     use dlist;\n     use dlist::DList;\n     use managed;\n     use option::{Option, Some};\n     use option;\n \n     #[allow(non_camel_case_types)]\n-    pub type IMPL_T<A> = @DList<A>;\n+    pub type IMPL_T<A> = @mut DList<A>;\n \n     /**\n     * Iterates through the current contents.\n@@ -30,18 +31,23 @@ mod inst {\n         while option::is_some(&link) {\n             let nobe = option::get(link);\n             assert nobe.linked;\n-            if !f(&nobe.data) { break; }\n+\n+            {\n+                let frozen_nobe = &*nobe;\n+                if !f(&frozen_nobe.data) { break; }\n+            }\n+\n             // Check (weakly) that the user didn't do a remove.\n             if self.size == 0 {\n                 die!(~\"The dlist became empty during iteration??\")\n             }\n             if !nobe.linked ||\n                 (!((nobe.prev.is_some()\n-                    || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n-                                       nobe))\n+                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                           nobe))\n                    && (nobe.next.is_some()\n-                    || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n-                                       nobe)))) {\n+                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                           nobe)))) {\n                 die!(~\"Removing a dlist node during iteration is forbidden!\")\n             }\n             link = nobe.next_link();"}, {"sha": "7cb20f7b44e9ebd3f0f943ad9cb90aebdc6debbd", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -39,6 +39,12 @@ pub pure fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n }\n \n+#[inline(always)]\n+pub pure fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n+    //! Determine if two mutable shared boxes point to the same object\n+    unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n+}\n+\n #[cfg(notest)]\n impl<T:Eq> @const T : Eq {\n     #[inline(always)]"}, {"sha": "e3fe0a1aae25cfd86b921f3baac1f02bf57f3ef1", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -321,8 +321,7 @@ pub fn waitpid(pid: pid_t) -> c_int {\n #[cfg(unix)]\n pub fn pipe() -> {in: c_int, out: c_int} {\n     unsafe {\n-        let fds = {mut in: 0 as c_int,\n-                   mut out: 0 as c_int };\n+        let mut fds = {in: 0 as c_int, out: 0 as c_int};\n         assert (libc::pipe(ptr::mut_addr_of(&(fds.in))) == (0 as c_int));\n         return {in: fds.in, out: fds.out};\n     }\n@@ -338,8 +337,7 @@ pub fn pipe() -> {in: c_int, out: c_int} {\n         // fully understand. Here we explicitly make the pipe non-inheritable,\n         // which means to pass it to a subprocess they need to be duplicated\n         // first, as in rust_run_program.\n-        let fds = { mut in: 0 as c_int,\n-                    mut out: 0 as c_int };\n+        let mut fds = { in: 0 as c_int, out: 0 as c_int };\n         let res = libc::pipe(ptr::mut_addr_of(&(fds.in)),\n                              1024 as c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);"}, {"sha": "c8187fa794d9cdae49b51fa6cc39ec9db3250b8e", "filename": "src/libcore/run.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -11,6 +11,7 @@\n #[allow(structural_records)];\n \n //! Process spawning\n+use cast;\n use io;\n use io::ReaderUtil;\n use libc;\n@@ -36,28 +37,28 @@ extern mod rustrt {\n /// A value representing a child process\n pub trait Program {\n     /// Returns the process id of the program\n-    fn get_id() -> pid_t;\n+    fn get_id(&mut self) -> pid_t;\n \n     /// Returns an io::writer that can be used to write to stdin\n-    fn input() -> io::Writer;\n+    fn input(&mut self) -> io::Writer;\n \n     /// Returns an io::reader that can be used to read from stdout\n-    fn output() -> io::Reader;\n+    fn output(&mut self) -> io::Reader;\n \n     /// Returns an io::reader that can be used to read from stderr\n-    fn err() -> io::Reader;\n+    fn err(&mut self) -> io::Reader;\n \n     /// Closes the handle to the child processes standard input\n-    fn close_input();\n+    fn close_input(&mut self);\n \n     /**\n      * Waits for the child process to terminate. Closes the handle\n      * to stdin if necessary.\n      */\n-    fn finish() -> int;\n+    fn finish(&mut self) -> int;\n \n     /// Closes open handles\n-    fn destroy();\n+    fn destroy(&mut self);\n }\n \n \n@@ -219,13 +220,13 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n \n     struct ProgRepr {\n         pid: pid_t,\n-        mut in_fd: c_int,\n+        in_fd: c_int,\n         out_file: *libc::FILE,\n         err_file: *libc::FILE,\n-        mut finished: bool,\n+        finished: bool,\n     }\n \n-    fn close_repr_input(r: &ProgRepr) {\n+    fn close_repr_input(r: &mut ProgRepr) {\n         let invalid_fd = -1i32;\n         if r.in_fd != invalid_fd {\n             unsafe {\n@@ -234,22 +235,27 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n             r.in_fd = invalid_fd;\n         }\n     }\n-    fn finish_repr(r: &ProgRepr) -> int {\n+    fn finish_repr(r: &mut ProgRepr) -> int {\n         if r.finished { return 0; }\n         r.finished = true;\n-        close_repr_input(r);\n+        close_repr_input(&mut *r);\n         return waitpid(r.pid);\n     }\n-    fn destroy_repr(r: &ProgRepr) {\n+    fn destroy_repr(r: &mut ProgRepr) {\n         unsafe {\n-            finish_repr(r);\n+            finish_repr(&mut *r);\n             libc::fclose(r.out_file);\n             libc::fclose(r.err_file);\n         }\n     }\n     struct ProgRes {\n         r: ProgRepr,\n-        drop { destroy_repr(&self.r); }\n+        drop {\n+            unsafe {\n+                // XXX: This is bad.\n+                destroy_repr(cast::transmute(&self.r));\n+            }\n+        }\n     }\n \n     fn ProgRes(r: ProgRepr) -> ProgRes {\n@@ -259,21 +265,21 @@ pub fn start_program(prog: &str, args: &[~str]) -> Program {\n     }\n \n     impl ProgRes: Program {\n-        fn get_id() -> pid_t { return self.r.pid; }\n-        fn input() -> io::Writer {\n+        fn get_id(&mut self) -> pid_t { return self.r.pid; }\n+        fn input(&mut self) -> io::Writer {\n             io::fd_writer(self.r.in_fd, false)\n         }\n-        fn output() -> io::Reader {\n+        fn output(&mut self) -> io::Reader {\n             io::FILE_reader(self.r.out_file, false)\n         }\n-        fn err() -> io::Reader {\n+        fn err(&mut self) -> io::Reader {\n             io::FILE_reader(self.r.err_file, false)\n         }\n-        fn close_input() { close_repr_input(&self.r); }\n-        fn finish() -> int { finish_repr(&self.r) }\n-        fn destroy() { destroy_repr(&self.r); }\n+        fn close_input(&mut self) { close_repr_input(&mut self.r); }\n+        fn finish(&mut self) -> int { finish_repr(&mut self.r) }\n+        fn destroy(&mut self) { destroy_repr(&mut self.r); }\n     }\n-    let repr = ProgRepr {\n+    let mut repr = ProgRepr {\n         pid: pid,\n         in_fd: pipe_input.out,\n         out_file: os::fdopen(pipe_output.in),"}, {"sha": "2b8e52888f180354708473be200b0a66e226da43", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -523,13 +523,13 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n     }\n \n     fn warn_missing(sess: Session, name: &str, default: &str) {\n-        if !sess.building_library { return; }\n+        if !*sess.building_library { return; }\n         sess.warn(fmt!(\"missing crate link meta `%s`, using `%s` as default\",\n                        name, default));\n     }\n \n     fn crate_meta_name(sess: Session, output: &Path, -opt_name: Option<@str>)\n-        -> @str {\n+                    -> @str {\n         return match opt_name {\n               Some(v) => v,\n               None => {\n@@ -730,7 +730,7 @@ pub fn link_binary(sess: Session,\n         }\n     }\n \n-    let output = if sess.building_library {\n+    let output = if *sess.building_library {\n         let long_libname = output_dll_filename(sess.targ_cfg.os, lm);\n         debug!(\"link_meta.name:  %s\", lm.name);\n         debug!(\"long_libname: %s\", long_libname);\n@@ -806,7 +806,7 @@ pub fn link_binary(sess: Session,\n     let used_libs = cstore::get_used_libraries(cstore);\n     for used_libs.each |l| { cc_args.push(~\"-l\" + *l); }\n \n-    if sess.building_library {\n+    if *sess.building_library {\n         cc_args.push(lib_cmd);\n \n         // On mac we need to tell the linker to let this library"}, {"sha": "5b7dc75bec6108b25e0631301593bd1cd67db43b", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -199,7 +199,7 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n                          || parse_input(sess, copy cfg, input) );\n     if upto == cu_parse { return {crate: crate, tcx: None}; }\n \n-    sess.building_library = session::building_library(\n+    *sess.building_library = session::building_library(\n         sess.opts.crate_type, crate, sess.opts.test);\n \n     crate = time(time_passes, ~\"configuration\", ||\n@@ -335,7 +335,7 @@ pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n \n     let stop_after_codegen =\n         sess.opts.output_type != link::output_type_exe ||\n-        (sess.opts.static && sess.building_library)    ||\n+        (sess.opts.static && *sess.building_library)   ||\n         sess.opts.jit;\n \n     if stop_after_codegen { return {crate: crate, tcx: None}; }\n@@ -466,7 +466,7 @@ pub fn get_arch(triple: ~str) -> Option<session::arch> {\n }\n \n pub fn build_target_config(sopts: @session::options,\n-                           demitter: diagnostic::emitter)\n+                           demitter: diagnostic::Emitter)\n                         -> @session::config {\n     let os = match get_os(sopts.target_triple) {\n       Some(os) => os,\n@@ -512,7 +512,7 @@ pub fn host_triple() -> ~str {\n \n pub fn build_session_options(+binary: ~str,\n                              matches: &getopts::Matches,\n-                             demitter: diagnostic::emitter)\n+                             demitter: diagnostic::Emitter)\n                           -> @session::options {\n     let crate_type = if opt_present(matches, ~\"lib\") {\n         session::lib_crate\n@@ -651,7 +651,7 @@ pub fn build_session_options(+binary: ~str,\n }\n \n pub fn build_session(sopts: @session::options,\n-                     demitter: diagnostic::emitter) -> Session {\n+                     demitter: diagnostic::Emitter) -> Session {\n     let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n         diagnostic::mk_handler(Some(demitter));\n@@ -662,30 +662,32 @@ pub fn build_session(sopts: @session::options,\n \n pub fn build_session_(sopts: @session::options,\n                       cm: @codemap::CodeMap,\n-                      demitter: diagnostic::emitter,\n+                      demitter: diagnostic::Emitter,\n                       span_diagnostic_handler: diagnostic::span_handler)\n                    -> Session {\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n-    let cstore = cstore::mk_cstore(p_s.interner);\n+    let cstore = @mut cstore::mk_cstore(p_s.interner);\n     let filesearch = filesearch::mk_filesearch(\n         sopts.maybe_sysroot,\n         sopts.target_triple,\n         /*bad*/copy sopts.addl_lib_search_paths);\n     let lint_settings = lint::mk_lint_settings();\n-    Session_(@{targ_cfg: target_cfg,\n-               opts: sopts,\n-               cstore: cstore,\n-               parse_sess: p_s,\n-               codemap: cm,\n-               // For a library crate, this is always none\n-               mut main_fn: None,\n-               span_diagnostic: span_diagnostic_handler,\n-               filesearch: filesearch,\n-               mut building_library: false,\n-               working_dir: os::getcwd(),\n-               lint_settings: lint_settings})\n+    @Session_ {\n+        targ_cfg: target_cfg,\n+        opts: sopts,\n+        cstore: cstore,\n+        parse_sess: p_s,\n+        codemap: cm,\n+        // For a library crate, this is always none\n+        main_fn: @mut None,\n+        span_diagnostic: span_diagnostic_handler,\n+        filesearch: filesearch,\n+        building_library: @mut false,\n+        working_dir: os::getcwd(),\n+        lint_settings: lint_settings\n+    }\n }\n \n pub fn parse_pretty(sess: Session, &&name: ~str) -> pp_mode {\n@@ -780,7 +782,7 @@ pub fn build_output_filenames(input: input,\n     let sopts = sess.opts;\n     let stop_after_codegen =\n         sopts.output_type != link::output_type_exe ||\n-            sopts.static && sess.building_library;\n+            sopts.static && *sess.building_library;\n \n \n     let obj_suffix =\n@@ -811,7 +813,7 @@ pub fn build_output_filenames(input: input,\n           str_input(_) => ~\"rust_out\"\n         };\n \n-        if sess.building_library {\n+        if *sess.building_library {\n             out_path = dirpath.push(os::dll_filename(stem));\n             obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n         } else {\n@@ -828,7 +830,7 @@ pub fn build_output_filenames(input: input,\n             (*out_file).with_filetype(obj_suffix)\n         };\n \n-        if sess.building_library {\n+        if *sess.building_library {\n             // FIXME (#2401): We might want to warn here; we're actually not\n             // going to respect the user's choice of library name when it\n             // comes time to link, we'll be linking to\n@@ -844,7 +846,7 @@ pub fn build_output_filenames(input: input,\n              obj_filename: obj_path};\n }\n \n-pub fn early_error(emitter: diagnostic::emitter, msg: ~str) -> ! {\n+pub fn early_error(emitter: diagnostic::Emitter, msg: ~str) -> ! {\n     emitter(None, msg, diagnostic::fatal);\n     die!();\n }"}, {"sha": "ce71ee87c9ed6cad95f3c46f243af5c7e8f1d635", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -149,23 +149,23 @@ pub type options =\n \n pub type crate_metadata = {name: ~str, data: ~[u8]};\n \n-pub type Session_ = {targ_cfg: @config,\n-                     opts: @options,\n-                     cstore: metadata::cstore::CStore,\n-                     parse_sess: parse_sess,\n-                     codemap: @codemap::CodeMap,\n-                     // For a library crate, this is always none\n-                     mut main_fn: Option<(node_id, codemap::span)>,\n-                     span_diagnostic: diagnostic::span_handler,\n-                     filesearch: filesearch::FileSearch,\n-                     mut building_library: bool,\n-                     working_dir: Path,\n-                     lint_settings: lint::lint_settings};\n-\n-pub enum Session {\n-    Session_(@Session_)\n+pub struct Session_ {\n+    targ_cfg: @config,\n+    opts: @options,\n+    cstore: @mut metadata::cstore::CStore,\n+    parse_sess: parse_sess,\n+    codemap: @codemap::CodeMap,\n+    // For a library crate, this is always none\n+    main_fn: @mut Option<(node_id, codemap::span)>,\n+    span_diagnostic: diagnostic::span_handler,\n+    filesearch: filesearch::FileSearch,\n+    building_library: @mut bool,\n+    working_dir: Path,\n+    lint_settings: lint::lint_settings\n }\n \n+pub type Session = @Session_;\n+\n pub impl Session {\n     fn span_fatal(sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n@@ -303,7 +303,8 @@ pub fn expect<T: Copy>(sess: Session,\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n \n-pub fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n+pub fn building_library(req_crate_type: crate_type,\n+                        crate: @ast::crate,\n                         testing: bool) -> bool {\n     match req_crate_type {\n       bin_crate => false,"}, {"sha": "34f0045f3fd4bbf030e9b16c9ba0f054a42c4a4e", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 144, "deletions": 122, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -30,20 +30,25 @@ use syntax::attr::attrs_contains_name;\n \n type node_id_gen = fn@() -> ast::node_id;\n \n-type test = {span: span, path: ~[ast::ident],\n-             ignore: bool, should_fail: bool};\n-\n-type test_ctxt =\n-    @{sess: session::Session,\n-      crate: @ast::crate,\n-      mut path: ~[ast::ident],\n-      testfns: DVec<test>};\n+type test = {\n+    span: span,\n+    path: ~[ast::ident],\n+    ignore: bool,\n+    should_fail: bool\n+};\n+\n+struct TestCtxt {\n+    sess: session::Session,\n+    crate: @ast::crate,\n+    path: ~[ast::ident],\n+    testfns: ~[test]\n+}\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: session::Session,\n-                          crate: @ast::crate) -> @ast::crate {\n-\n+                          crate: @ast::crate)\n+                       -> @ast::crate {\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n@@ -58,12 +63,14 @@ pub fn modify_for_testing(sess: session::Session,\n }\n \n fn generate_test_harness(sess: session::Session,\n-                         crate: @ast::crate) -> @ast::crate {\n-    let cx: test_ctxt =\n-        @{sess: sess,\n-          crate: crate,\n-          mut path: ~[],\n-          testfns: DVec()};\n+                         crate: @ast::crate)\n+                      -> @ast::crate {\n+    let cx: @mut TestCtxt = @mut TestCtxt {\n+        sess: sess,\n+        crate: crate,\n+        path: ~[],\n+        testfns: ~[]\n+    };\n \n     let precursor = @fold::AstFoldFns {\n         fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n@@ -83,13 +90,15 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n     }\n }\n \n-fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n-\n+fn fold_mod(cx: @mut TestCtxt,\n+            m: ast::_mod,\n+            fld: fold::ast_fold)\n+         -> ast::_mod {\n     // Remove any #[main] from the AST so it doesn't clash with\n     // the one we're going to add. Only if compiling an executable.\n \n-    fn nomain(cx: test_ctxt, item: @ast::item) -> @ast::item {\n-        if !cx.sess.building_library {\n+    fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n+        if !*cx.sess.building_library {\n             @ast::item{attrs: item.attrs.filtered(|attr| {\n                                attr::get_attr_name(*attr) != ~\"main\"\n                            }),.. copy *item}\n@@ -104,8 +113,10 @@ fn fold_mod(cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     fold::noop_fold_mod(mod_nomain, fld)\n }\n \n-fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n-   ast::crate_ {\n+fn fold_crate(cx: @mut TestCtxt,\n+              c: ast::crate_,\n+              fld: fold::ast_fold)\n+           -> ast::crate_ {\n     let folded = fold::noop_fold_crate(c, fld);\n \n     // Add a special __test module to the crate that will contain code\n@@ -115,17 +126,17 @@ fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n }\n \n \n-fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n-   Option<@ast::item> {\n-\n+fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: fold::ast_fold)\n+          -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n            ast_util::path_name_i(cx.path, cx.sess.parse_sess.interner));\n \n     if is_test_fn(i) {\n         match i.node {\n           ast::item_fn(_, purity, _, _) if purity == ast::unsafe_fn => {\n-            cx.sess.span_fatal(\n+            let sess = cx.sess;\n+            sess.span_fatal(\n                 i.span,\n                 ~\"unsafe functions cannot be used for tests\");\n           }\n@@ -165,7 +176,7 @@ fn is_test_fn(i: @ast::item) -> bool {\n     return has_test_attr && has_test_signature(i);\n }\n \n-fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n+fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n     return if !ignoreitems.is_empty() {\n@@ -183,7 +194,7 @@ fn should_fail(i: @ast::item) -> bool {\n     vec::len(attr::find_attrs_by_name(i.attrs, ~\"should_fail\")) > 0u\n }\n \n-fn add_test_module(cx: test_ctxt, +m: ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: @mut TestCtxt, +m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n     ast::_mod {\n         items: vec::append_one(/*bad*/copy m.items, testmod),\n@@ -207,7 +218,7 @@ mod __test {\n \n */\n \n-fn mk_test_module(cx: test_ctxt) -> @ast::item {\n+fn mk_test_module(cx: @mut TestCtxt) -> @ast::item {\n     // Link to std\n     let std = mk_std(cx);\n     let view_items = if is_std(cx) { ~[] } else { ~[std] };\n@@ -225,17 +236,18 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n         attr::mk_attr(attr::mk_word_item(~\"!resolve_unexported\"));\n+    let sess = cx.sess;\n     let item = ast::item {\n-        ident: cx.sess.ident_of(~\"__test\"),\n+        ident: sess.ident_of(~\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n-        id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n         node: item_,\n         vis: ast::public,\n         span: dummy_sp(),\n     };\n \n     debug!(\"Synthetic test module:\\n%s\\n\",\n-           pprust::item_to_str(@copy item, cx.sess.intr()));\n+           pprust::item_to_str(@copy item, sess.intr()));\n \n     return @item;\n }\n@@ -260,14 +272,15 @@ fn path_node_global(+ids: ~[ast::ident]) -> @ast::path {\n                  types: ~[] }\n }\n \n-fn mk_std(cx: test_ctxt) -> @ast::view_item {\n+fn mk_std(cx: @mut TestCtxt) -> @ast::view_item {\n     let vers = ast::lit_str(@~\"0.6\");\n     let vers = nospan(vers);\n     let mi = ast::meta_name_value(~\"vers\", vers);\n     let mi = nospan(mi);\n-    let vi = ast::view_item_use(cx.sess.ident_of(~\"std\"),\n+    let sess = cx.sess;\n+    let vi = ast::view_item_use(sess.ident_of(~\"std\"),\n                                 ~[@mi],\n-                                cx.sess.next_node_id());\n+                                sess.next_node_id());\n     let vi = ast::view_item {\n         node: vi,\n         attrs: ~[],\n@@ -278,7 +291,7 @@ fn mk_std(cx: test_ctxt) -> @ast::view_item {\n     return @vi;\n }\n \n-fn mk_tests(cx: test_ctxt) -> @ast::item {\n+fn mk_tests(cx: @mut TestCtxt) -> @ast::item {\n     let ret_ty = mk_test_desc_and_fn_vec_ty(cx);\n \n     let decl = ast::fn_decl {\n@@ -290,23 +303,25 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_and_fn_vec(cx);\n \n-    let body_: ast::blk_ =\n-        default_block(~[], option::Some(test_descs), cx.sess.next_node_id());\n+    let sess = cx.sess;\n+    let body_: ast::blk_ = default_block(~[],\n+                                         option::Some(test_descs),\n+                                         sess.next_node_id());\n     let body = nospan(body_);\n \n     let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item = ast::item {\n-        ident: cx.sess.ident_of(~\"tests\"),\n+        ident: sess.ident_of(~\"tests\"),\n         attrs: ~[],\n-        id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n         node: item_,\n         vis: ast::public,\n         span: dummy_sp(),\n     };\n     return @item;\n }\n \n-fn is_std(cx: test_ctxt) -> bool {\n+fn is_std(cx: @mut TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n@@ -317,133 +332,138 @@ fn is_std(cx: test_ctxt) -> bool {\n     return is_std;\n }\n \n-fn mk_path(cx: test_ctxt, +path: ~[ast::ident]) -> @ast::path {\n+fn mk_path(cx: @mut TestCtxt, +path: ~[ast::ident]) -> @ast::path {\n     // For tests that are inside of std we don't want to prefix\n     // the paths with std::\n-    if is_std(cx) { path_node_global(path) }\n-    else {\n-        path_node(\n-            ~[cx.sess.ident_of(~\"self\"),\n-              cx.sess.ident_of(~\"std\")]\n-            + path)\n+    let sess = cx.sess;\n+    if is_std(cx) {\n+        path_node_global(path)\n+    } else {\n+        path_node(~[ sess.ident_of(~\"self\"), sess.ident_of(~\"std\") ] + path)\n     }\n }\n \n-// The ast::Ty of ~[std::test::TestDescAndFn]\n-fn mk_test_desc_and_fn_vec_ty(cx: test_ctxt) -> @ast::Ty {\n-    let test_desc_and_fn_ty_path =\n-        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                      cx.sess.ident_of(~\"TestDescAndFn\")]);\n+// The ast::Ty of ~[std::test::test_desc]\n+fn mk_test_desc_and_fn_vec_ty(cx: @mut TestCtxt) -> @ast::Ty {\n+    let sess = cx.sess;\n+    let test_desc_and_fn_ty_path = mk_path(cx, ~[\n+        sess.ident_of(~\"test\"),\n+        sess.ident_of(~\"TestDescAndFn\")\n+    ]);\n \n     let test_desc_and_fn_ty = ast::Ty {\n-        id: cx.sess.next_node_id(),\n-        node: ast::ty_path(test_desc_and_fn_ty_path,\n-                           cx.sess.next_node_id()),\n+        id: sess.next_node_id(),\n+        node: ast::ty_path(test_desc_and_fn_ty_path, sess.next_node_id()),\n         span: dummy_sp(),\n     };\n \n     let vec_mt = ast::mt {ty: @test_desc_and_fn_ty,\n                           mutbl: ast::m_imm};\n \n     let inner_ty = @ast::Ty {\n-        id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n         node: ast::ty_vec(vec_mt),\n         span: dummy_sp(),\n     };\n \n     @ast::Ty {\n-        id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n         node: ast::ty_uniq(ast::mt { ty: inner_ty, mutbl: ast::m_imm }),\n         span: dummy_sp(),\n     }\n }\n \n-fn mk_test_desc_and_fn_vec(cx: test_ctxt) -> @ast::expr {\n+fn mk_test_desc_and_fn_vec(cx: @mut TestCtxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n-    for cx.testfns.each |test| {\n-        descs.push(mk_test_desc_and_fn_rec(cx, *test));\n+    {\n+        let testfns = &mut cx.testfns;\n+        for testfns.each |test| {\n+            descs.push(mk_test_desc_and_fn_rec(cx, *test));\n+        }\n     }\n \n+    let sess = cx.sess;\n     let inner_expr = @ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_vec(descs, ast::m_imm),\n         span: dummy_sp(),\n     };\n \n     @ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_vstore(inner_expr, ast::expr_vstore_uniq),\n         span: dummy_sp(),\n     }\n }\n \n-fn mk_test_desc_and_fn_rec(cx: test_ctxt, test: test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: @mut TestCtxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n \n-    debug!(\"encoding %s\", ast_util::path_name_i(path,\n-                                                cx.sess.parse_sess.interner));\n+    let sess = cx.sess;\n+    debug!(\"encoding %s\",\n+           ast_util::path_name_i(path, sess.parse_sess.interner));\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(@ast_util::path_name_i(\n-            path, cx.sess.parse_sess.interner)));\n+            path,\n+            sess.parse_sess.interner)));\n \n     let name_expr_inner = @ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_lit(@name_lit),\n         span: span,\n     };\n \n     let name_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_vstore(name_expr_inner, ast::expr_vstore_uniq),\n         span: dummy_sp(),\n     };\n \n     let name_field = nospan(ast::field_ {\n         mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"name\"),\n+        ident: sess.ident_of(~\"name\"),\n         expr: @name_expr,\n     });\n \n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n     let ignore_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_lit(@ignore_lit),\n         span: span,\n     };\n \n     let ignore_field = nospan(ast::field_ {\n         mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"ignore\"),\n+        ident: sess.ident_of(~\"ignore\"),\n         expr: @ignore_expr,\n     });\n \n     let fail_lit: ast::lit = nospan(ast::lit_bool(test.should_fail));\n \n     let fail_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_lit(@fail_lit),\n         span: span,\n     };\n \n     let fail_field = nospan(ast::field_ {\n         mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"should_fail\"),\n+        ident: sess.ident_of(~\"should_fail\"),\n         expr: @fail_expr,\n     });\n \n     let test_desc_path =\n-        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                      cx.sess.ident_of(~\"TestDesc\")]);\n+        mk_path(cx, ~[ sess.ident_of(~\"test\"), sess.ident_of(~\"TestDesc\") ]);\n \n     let desc_rec_ = ast::expr_struct(\n         test_desc_path,\n@@ -452,40 +472,40 @@ fn mk_test_desc_and_fn_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     );\n \n     let desc_rec = @ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: desc_rec_,\n         span: span,\n     };\n \n     let desc_field = nospan(ast::field_ {\n         mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"desc\"),\n+        ident: sess.ident_of(~\"desc\"),\n         expr: desc_rec\n     });\n \n     let fn_path = path_node_global(path);\n \n     let fn_expr = @ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_path(fn_path),\n         span: span,\n     };\n \n     let fn_field = nospan(ast::field_ {\n         mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"testfn\"),\n+        ident: sess.ident_of(~\"testfn\"),\n         expr: fn_expr,\n     });\n \n     let test_desc_and_fn_path =\n-        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                      cx.sess.ident_of(~\"TestDescAndFn\")]);\n+        mk_path(cx, ~[sess.ident_of(~\"test\"),\n+                      sess.ident_of(~\"TestDescAndFn\")]);\n \n     let desc_and_fn_rec = @ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_struct(test_desc_and_fn_path,\n                                ~[fn_field, desc_field],\n                                option::None),\n@@ -495,9 +515,10 @@ fn mk_test_desc_and_fn_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     return desc_and_fn_rec;\n }\n \n-fn mk_main(cx: test_ctxt) -> @ast::item {\n+fn mk_main(cx: @mut TestCtxt) -> @ast::item {\n+    let sess = cx.sess;\n     let ret_ty = ast::Ty {\n-        id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n         node: ast::ty_nil,\n         span: dummy_sp(),\n     };\n@@ -511,80 +532,81 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let test_main_call_expr = mk_test_main_call(cx);\n \n     let body_: ast::blk_ =\n-        default_block(~[], option::Some(test_main_call_expr),\n-                      cx.sess.next_node_id());\n+        default_block(~[],\n+                      option::Some(test_main_call_expr),\n+                      sess.next_node_id());\n     let body = codemap::spanned { node: body_, span: dummy_sp() };\n \n     let item_ = ast::item_fn(decl, ast::impure_fn, ~[], body);\n     let item = ast::item {\n-        ident: cx.sess.ident_of(~\"main\"),\n+        ident: sess.ident_of(~\"main\"),\n         attrs: ~[attr::mk_attr(attr::mk_word_item(~\"main\"))],\n-        id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n         node: item_,\n         vis: ast::public,\n         span: dummy_sp(),\n     };\n     return @item;\n }\n \n-fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n+fn mk_test_main_call(cx: @mut TestCtxt) -> @ast::expr {\n     // Call os::args to generate the vector of test_descs\n+    let sess = cx.sess;\n     let args_path = path_node_global(~[\n-        cx.sess.ident_of(~\"os\"),\n-        cx.sess.ident_of(~\"args\")\n+        sess.ident_of(~\"os\"),\n+        sess.ident_of(~\"args\")\n     ]);\n \n     let args_path_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_path(args_path),\n         span: dummy_sp(),\n     };\n \n     let args_call_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_call(@args_path_expr, ~[], ast::NoSugar),\n         span: dummy_sp(),\n     };\n \n     // Call __test::test to generate the vector of test_descs\n-    let test_path = path_node(~[cx.sess.ident_of(~\"tests\")]);\n+    let test_path = path_node(~[ sess.ident_of(~\"tests\") ]);\n \n     let test_path_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_path(test_path),\n         span: dummy_sp(),\n     };\n \n     let test_call_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_call(@test_path_expr, ~[], ast::NoSugar),\n         span: dummy_sp(),\n     };\n \n     // Call std::test::test_main\n-    let test_main_path =\n-        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                      cx.sess.ident_of(~\"test_main\")]);\n+    let test_main_path = mk_path(cx, ~[\n+        sess.ident_of(~\"test\"),\n+        sess.ident_of(~\"test_main\")\n+    ]);\n \n     let test_main_path_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n         node: ast::expr_path(test_main_path),\n         span: dummy_sp(),\n     };\n \n     let test_main_call_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(\n-            @test_main_path_expr,\n-            ~[@args_call_expr, @test_call_expr],\n-            ast::NoSugar\n-        ),\n+        id: sess.next_node_id(),\n+        callee_id: sess.next_node_id(),\n+        node: ast::expr_call(@test_main_path_expr,\n+                             ~[@args_call_expr, @test_call_expr],\n+                             ast::NoSugar),\n         span: dummy_sp(),\n     };\n "}, {"sha": "a2203f0a3998a6f1f9a3f30db7c6d1a19960a349", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -19,7 +19,6 @@ use metadata::decoder;\n use metadata::filesearch::FileSearch;\n use metadata::loader;\n \n-use core::dvec::DVec;\n use core::either;\n use core::option;\n use core::vec;\n@@ -36,27 +35,29 @@ use std::oldmap::HashMap;\n // libraries necessary for later resolving, typechecking, linking, etc.\n pub fn read_crates(diag: span_handler,\n                    crate: ast::crate,\n-                   cstore: cstore::CStore,\n+                   cstore: @mut cstore::CStore,\n                    filesearch: FileSearch,\n                    os: loader::os,\n-                   static: bool,\n+                   statik: bool,\n                    intr: @ident_interner) {\n-    let e = @{diag: diag,\n-              filesearch: filesearch,\n-              cstore: cstore,\n-              os: os,\n-              static: static,\n-              crate_cache: DVec(),\n-              mut next_crate_num: 1,\n-              intr: intr};\n+    let e = @mut Env {\n+        diag: diag,\n+        filesearch: filesearch,\n+        cstore: cstore,\n+        os: os,\n+        statik: statik,\n+        crate_cache: @mut ~[],\n+        next_crate_num: 1,\n+        intr: intr\n+    };\n     let v =\n         visit::mk_simple_visitor(@visit::SimpleVisitor {\n             visit_view_item: |a| visit_view_item(e, a),\n             visit_item: |a| visit_item(e, a),\n             .. *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n-    warn_if_multiple_versions(e, diag, e.crate_cache.get());\n+    warn_if_multiple_versions(e, diag, e.crate_cache);\n }\n \n type cache_entry = {\n@@ -66,7 +67,7 @@ type cache_entry = {\n     metas: @~[@ast::meta_item]\n };\n \n-fn dump_crates(crate_cache: DVec<cache_entry>) {\n+fn dump_crates(+crate_cache: @mut ~[cache_entry]) {\n     debug!(\"resolved crates:\");\n     for crate_cache.each |entry| {\n         debug!(\"cnum: %?\", entry.cnum);\n@@ -75,8 +76,9 @@ fn dump_crates(crate_cache: DVec<cache_entry>) {\n     }\n }\n \n-fn warn_if_multiple_versions(e: env, diag: span_handler,\n-                             crate_cache: ~[cache_entry]) {\n+fn warn_if_multiple_versions(e: @mut Env,\n+                             diag: span_handler,\n+                             crate_cache: @mut ~[cache_entry]) {\n     use either::*;\n \n     if crate_cache.len() != 0u {\n@@ -108,20 +110,22 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n             }\n         }\n \n-        warn_if_multiple_versions(e, diag, non_matches);\n+        warn_if_multiple_versions(e, diag, @mut non_matches);\n     }\n }\n \n-type env = @{diag: span_handler,\n-             filesearch: FileSearch,\n-             cstore: cstore::CStore,\n-             os: loader::os,\n-             static: bool,\n-             crate_cache: DVec<cache_entry>,\n-             mut next_crate_num: ast::crate_num,\n-             intr: @ident_interner};\n+struct Env {\n+    diag: span_handler,\n+    filesearch: FileSearch,\n+    cstore: @mut cstore::CStore,\n+    os: loader::os,\n+    statik: bool,\n+    crate_cache: @mut ~[cache_entry],\n+    next_crate_num: ast::crate_num,\n+    intr: @ident_interner\n+}\n \n-fn visit_view_item(e: env, i: @ast::view_item) {\n+fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n     match /*bad*/copy i.node {\n       ast::view_item_use(ident, meta_items, id) => {\n         debug!(\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items);\n@@ -132,7 +136,7 @@ fn visit_view_item(e: env, i: @ast::view_item) {\n     }\n }\n \n-fn visit_item(e: env, i: @ast::item) {\n+fn visit_item(e: @mut Env, i: @ast::item) {\n     match /*bad*/copy i.node {\n       ast::item_foreign_mod(fm) => {\n         match attr::foreign_abi(i.attrs) {\n@@ -202,9 +206,8 @@ fn metas_with_ident(+ident: ~str, +metas: ~[@ast::meta_item])\n     metas_with(ident, ~\"name\", metas)\n }\n \n-fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n-    Option<int> {\n-\n+fn existing_match(e: @mut Env, metas: ~[@ast::meta_item], hash: ~str)\n+               -> Option<int> {\n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n             && (hash.is_empty() || c.hash == hash) {\n@@ -214,8 +217,12 @@ fn existing_match(e: env, metas: ~[@ast::meta_item], hash: ~str) ->\n     return None;\n }\n \n-fn resolve_crate(e: env, ident: ast::ident, +metas: ~[@ast::meta_item],\n-                 +hash: ~str, span: span) -> ast::crate_num {\n+fn resolve_crate(e: @mut Env,\n+                 ident: ast::ident,\n+                 +metas: ~[@ast::meta_item],\n+                 +hash: ~str,\n+                 span: span)\n+              -> ast::crate_num {\n     let metas = metas_with_ident(/*bad*/copy *e.intr.get(ident), metas);\n \n     match existing_match(e, metas, hash) {\n@@ -228,7 +235,7 @@ fn resolve_crate(e: env, ident: ast::ident, +metas: ~[@ast::meta_item],\n             metas: metas,\n             hash: hash,\n             os: e.os,\n-            static: e.static,\n+            static: e.statik,\n             intr: e.intr\n         };\n         let cinfo = loader::load_library_crate(load_ctxt);\n@@ -270,7 +277,7 @@ fn resolve_crate(e: env, ident: ast::ident, +metas: ~[@ast::meta_item],\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "2cb5cfbddd73015a52fa878d740232ab2f866c24", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -42,28 +42,29 @@ pub struct StaticMethodInfo {\n     purity: ast::purity\n }\n \n-pub fn get_symbol(cstore: cstore::CStore, def: ast::def_id) -> ~str {\n+pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::def_id) -> ~str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_symbol(cdata, def.node);\n }\n \n-pub fn get_type_param_count(cstore: cstore::CStore, def: ast::def_id)\n+pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::def_id)\n                          -> uint {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n /// Iterates over all the language items in the given crate.\n-pub fn each_lang_item(cstore: cstore::CStore,\n+pub fn each_lang_item(cstore: @mut cstore::CStore,\n                       cnum: ast::crate_num,\n                       f: &fn(ast::node_id, uint) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     decoder::each_lang_item(crate_data, f)\n }\n \n /// Iterates over all the paths in the given crate.\n-pub fn each_path(cstore: cstore::CStore, cnum: ast::crate_num,\n-                 f: fn(&str, decoder::def_like) -> bool) {\n+pub fn each_path(cstore: @mut cstore::CStore,\n+                 cnum: ast::crate_num,\n+                 f: &fn(&str, decoder::def_like) -> bool) {\n     let crate_data = cstore::get_crate_data(cstore, cnum);\n     let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n         cstore::get_crate_data(cstore, cnum)\n@@ -107,7 +108,7 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_impls_for_mod(cstore: cstore::CStore, def: ast::def_id,\n+pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n                          name: Option<ast::ident>)\n                       -> @~[@decoder::_impl] {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n@@ -138,27 +139,27 @@ pub fn get_supertraits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     decoder::get_supertraits(cdata, def.node, tcx)\n }\n \n-pub fn get_method_names_if_trait(cstore: cstore::CStore, def: ast::def_id)\n-    -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n-\n+pub fn get_method_names_if_trait(cstore: @mut cstore::CStore,\n+                                 def: ast::def_id)\n+                              -> Option<@DVec<(ast::ident, ast::self_ty_)>> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cstore.intr, cdata, def.node);\n }\n \n-pub fn get_type_name_if_impl(cstore: cstore::CStore, def: ast::def_id) ->\n-        Option<ast::ident> {\n+pub fn get_type_name_if_impl(cstore: @mut cstore::CStore, def: ast::def_id)\n+                          -> Option<ast::ident> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_type_name_if_impl(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_static_methods_if_impl(cstore: cstore::CStore,\n+pub fn get_static_methods_if_impl(cstore: @mut cstore::CStore,\n                                   def: ast::def_id)\n                                -> Option<~[StaticMethodInfo]> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::get_static_methods_if_impl(cstore.intr, cdata, def.node)\n }\n \n-pub fn get_item_attrs(cstore: cstore::CStore,\n+pub fn get_item_attrs(cstore: @mut cstore::CStore,\n                       def_id: ast::def_id,\n                       f: fn(~[@ast::meta_item])) {\n     let cdata = cstore::get_crate_data(cstore, def_id.crate);\n@@ -179,7 +180,7 @@ pub fn get_type(tcx: ty::ctxt,\n     decoder::get_type(cdata, def.node, tcx)\n }\n \n-pub fn get_region_param(cstore: metadata::cstore::CStore,\n+pub fn get_region_param(cstore: @mut metadata::cstore::CStore,\n                         def: ast::def_id) -> Option<ty::region_variance> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_region_param(cdata, def.node);\n@@ -216,7 +217,7 @@ pub fn get_impl_traits(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::t] {\n     decoder::get_impl_traits(cdata, def.node, tcx)\n }\n \n-pub fn get_impl_method(cstore: cstore::CStore,\n+pub fn get_impl_method(cstore: @mut cstore::CStore,\n                        def: ast::def_id,\n                        mname: ast::ident)\n                     -> ast::def_id {\n@@ -225,7 +226,7 @@ pub fn get_impl_method(cstore: cstore::CStore,\n }\n \n /* If def names a class with a dtor, return it. Otherwise, return none. */\n-pub fn struct_dtor(cstore: cstore::CStore, def: ast::def_id)\n+pub fn struct_dtor(cstore: @mut cstore::CStore, def: ast::def_id)\n     -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     decoder::struct_dtor(cdata, def.node)"}, {"sha": "c144d2d8804baaf0e316f25fc3596db528f46474", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 67, "deletions": 59, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -38,129 +38,137 @@ pub type crate_metadata = @{name: ~str,\n                             cnum_map: cnum_map,\n                             cnum: ast::crate_num};\n \n-// This is a bit of an experiment at encapsulating the data in cstore. By\n-// keeping all the data in a non-exported enum variant, it's impossible for\n-// other modules to access the cstore's private data. This could also be\n-// achieved with an obj, but at the expense of a vtable. Not sure if this is a\n-// good pattern or not.\n-pub enum CStore { private(cstore_private), }\n-\n-type cstore_private =\n-    @{metas: oldmap::HashMap<ast::crate_num, crate_metadata>,\n-      use_crate_map: use_crate_map,\n-      mut used_crate_files: ~[Path],\n-      mut used_libraries: ~[~str],\n-      mut used_link_args: ~[~str],\n-      intr: @ident_interner};\n+pub struct CStore {\n+    priv metas: oldmap::HashMap<ast::crate_num, crate_metadata>,\n+    priv use_crate_map: use_crate_map,\n+    priv used_crate_files: ~[Path],\n+    priv used_libraries: ~[~str],\n+    priv used_link_args: ~[~str],\n+    intr: @ident_interner\n+}\n \n // Map from node_id's of local use statements to crate numbers\n type use_crate_map = oldmap::HashMap<ast::node_id, ast::crate_num>;\n \n-// Internal method to retrieve the data from the cstore\n-pure fn p(cstore: CStore) -> cstore_private {\n-    match cstore { private(p) => p }\n-}\n-\n pub fn mk_cstore(intr: @ident_interner) -> CStore {\n     let meta_cache = oldmap::HashMap();\n     let crate_map = oldmap::HashMap();\n-    return private(@{metas: meta_cache,\n-                     use_crate_map: crate_map,\n-                     mut used_crate_files: ~[],\n-                     mut used_libraries: ~[],\n-                     mut used_link_args: ~[],\n-                     intr: intr});\n+    return CStore {\n+        metas: meta_cache,\n+        use_crate_map: crate_map,\n+        used_crate_files: ~[],\n+        used_libraries: ~[],\n+        used_link_args: ~[],\n+        intr: intr\n+    };\n }\n \n-pub fn get_crate_data(cstore: CStore, cnum: ast::crate_num)\n+pub fn get_crate_data(cstore: @mut CStore, cnum: ast::crate_num)\n                    -> crate_metadata {\n-    return p(cstore).metas.get(&cnum);\n+    return cstore.metas.get(&cnum);\n }\n \n-pub fn get_crate_hash(cstore: CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_hash(cstore: @mut CStore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_hash(cdata.data);\n }\n \n-pub fn get_crate_vers(cstore: CStore, cnum: ast::crate_num) -> ~str {\n+pub fn get_crate_vers(cstore: @mut CStore, cnum: ast::crate_num) -> ~str {\n     let cdata = get_crate_data(cstore, cnum);\n     return decoder::get_crate_vers(cdata.data);\n }\n \n-pub fn set_crate_data(cstore: CStore,\n+pub fn set_crate_data(cstore: @mut CStore,\n                       cnum: ast::crate_num,\n                       data: crate_metadata) {\n-    p(cstore).metas.insert(cnum, data);\n+    let metas = cstore.metas;\n+    metas.insert(cnum, data);\n }\n \n-pub fn have_crate_data(cstore: CStore, cnum: ast::crate_num) -> bool {\n-    return p(cstore).metas.contains_key_ref(&cnum);\n+pub fn have_crate_data(cstore: @mut CStore, cnum: ast::crate_num) -> bool {\n+    return cstore.metas.contains_key_ref(&cnum);\n }\n \n-pub fn iter_crate_data(cstore: CStore,\n+pub fn iter_crate_data(cstore: @mut CStore,\n                        i: fn(ast::crate_num, crate_metadata)) {\n-    for p(cstore).metas.each_ref |&k, &v| { i(k, v);};\n+    let metas = cstore.metas;\n+    for metas.each_ref |&k, &v| {\n+        i(k, v);\n+    }\n }\n \n-pub fn add_used_crate_file(cstore: CStore, lib: &Path) {\n-    if !vec::contains(p(cstore).used_crate_files, lib) {\n-        p(cstore).used_crate_files.push(copy *lib);\n+pub fn add_used_crate_file(cstore: @mut CStore, lib: &Path) {\n+    if !vec::contains(cstore.used_crate_files, lib) {\n+        cstore.used_crate_files.push(copy *lib);\n     }\n }\n \n-pub fn get_used_crate_files(cstore: CStore) -> ~[Path] {\n-    return /*bad*/copy p(cstore).used_crate_files;\n+pub fn get_used_crate_files(cstore: @mut CStore) -> ~[Path] {\n+    return /*bad*/copy cstore.used_crate_files;\n }\n \n-pub fn add_used_library(cstore: CStore, +lib: ~str) -> bool {\n+pub fn add_used_library(cstore: @mut CStore, +lib: ~str) -> bool {\n     assert lib != ~\"\";\n \n-    if vec::contains(p(cstore).used_libraries, &lib) { return false; }\n-    p(cstore).used_libraries.push(lib);\n+    if vec::contains(cstore.used_libraries, &lib) { return false; }\n+    cstore.used_libraries.push(lib);\n     return true;\n }\n \n-pub fn get_used_libraries(cstore: CStore) -> ~[~str] {\n-    return /*bad*/copy p(cstore).used_libraries;\n+pub fn get_used_libraries(cstore: @mut CStore) -> ~[~str] {\n+    return /*bad*/copy cstore.used_libraries;\n }\n \n-pub fn add_used_link_args(cstore: CStore, args: ~str) {\n-    p(cstore).used_link_args.push_all(str::split_char(args, ' '));\n+pub fn add_used_link_args(cstore: @mut CStore, args: ~str) {\n+    cstore.used_link_args.push_all(str::split_char(args, ' '));\n }\n \n-pub fn get_used_link_args(cstore: CStore) -> ~[~str] {\n-    return /*bad*/copy p(cstore).used_link_args;\n+pub fn get_used_link_args(cstore: @mut CStore) -> ~[~str] {\n+    return /*bad*/copy cstore.used_link_args;\n }\n \n-pub fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n+pub fn add_use_stmt_cnum(cstore: @mut CStore,\n+                         use_id: ast::node_id,\n                          cnum: ast::crate_num) {\n-    p(cstore).use_crate_map.insert(use_id, cnum);\n+    let use_crate_map = cstore.use_crate_map;\n+    use_crate_map.insert(use_id, cnum);\n }\n \n-pub fn find_use_stmt_cnum(cstore: CStore,\n-                          use_id: ast::node_id) -> Option<ast::crate_num> {\n-    p(cstore).use_crate_map.find(&use_id)\n+pub fn find_use_stmt_cnum(cstore: @mut CStore,\n+                          use_id: ast::node_id)\n+                       -> Option<ast::crate_num> {\n+    let use_crate_map = cstore.use_crate_map;\n+    use_crate_map.find(&use_id)\n }\n \n // returns hashes of crates directly used by this crate. Hashes are\n // sorted by crate name.\n-pub fn get_dep_hashes(cstore: CStore) -> ~[~str] {\n+pub fn get_dep_hashes(cstore: @mut CStore) -> ~[~str] {\n     type crate_hash = {name: ~str, hash: ~str};\n     let mut result = ~[];\n \n-    for p(cstore).use_crate_map.each_value_ref |&cnum| {\n+    let use_crate_map = cstore.use_crate_map;\n+    for use_crate_map.each_value_ref |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         debug!(\"Add hash[%s]: %s\", cdata.name, hash);\n         result.push({name: /*bad*/copy cdata.name, hash: hash});\n-    };\n-    pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {a.name <= b.name}\n+    }\n+\n+    pure fn lteq(a: &crate_hash, b: &crate_hash) -> bool {\n+        a.name <= b.name\n+    }\n+\n     let sorted = std::sort::merge_sort(result, lteq);\n     debug!(\"sorted:\");\n     for sorted.each |x| {\n         debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n-    fn mapper(ch: &crate_hash) -> ~str { return /*bad*/copy ch.hash; }\n+\n+    fn mapper(ch: &crate_hash) -> ~str {\n+        return /*bad*/copy ch.hash;\n+    }\n+\n     return vec::map(sorted, mapper);\n }\n "}, {"sha": "89b491a867b9ae3784a4bb36d0304dda10eb7821", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -67,33 +67,33 @@ pub type encode_parms = {\n     item_symbols: HashMap<ast::node_id, ~str>,\n     discrim_symbols: HashMap<ast::node_id, ~str>,\n     link_meta: link_meta,\n-    cstore: cstore::CStore,\n+    cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item\n };\n \n-type stats = {\n-    mut inline_bytes: uint,\n-    mut attr_bytes: uint,\n-    mut dep_bytes: uint,\n-    mut lang_item_bytes: uint,\n-    mut item_bytes: uint,\n-    mut index_bytes: uint,\n-    mut zero_bytes: uint,\n-    mut total_bytes: uint,\n-\n-    mut n_inlines: uint\n-};\n+struct Stats {\n+    inline_bytes: uint,\n+    attr_bytes: uint,\n+    dep_bytes: uint,\n+    lang_item_bytes: uint,\n+    item_bytes: uint,\n+    index_bytes: uint,\n+    zero_bytes: uint,\n+    total_bytes: uint,\n+\n+    n_inlines: uint\n+}\n \n pub enum encode_ctxt = {\n     diag: span_handler,\n     tcx: ty::ctxt,\n-    stats: stats,\n+    stats: @mut Stats,\n     reachable: HashMap<ast::node_id, ()>,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: HashMap<ast::node_id, ~str>,\n     discrim_symbols: HashMap<ast::node_id, ~str>,\n     link_meta: link_meta,\n-    cstore: cstore::CStore,\n+    cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item,\n     type_abbrevs: abbrev_map\n };\n@@ -1067,12 +1067,11 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: &crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n-                     cstore: cstore::CStore) {\n-\n-    fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::CStore)\n-        -> ~[decoder::crate_dep] {\n-\n+fn encode_crate_deps(ecx: @encode_ctxt,\n+                     ebml_w: writer::Encoder,\n+                     cstore: @mut cstore::CStore) {\n+    fn get_ordered_deps(ecx: @encode_ctxt, cstore: @mut cstore::CStore)\n+                     -> ~[decoder::crate_dep] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n         type numdep = decoder::crate_dep;\n \n@@ -1168,20 +1167,21 @@ pub const metadata_encoding_version : &[u8] = &[0x72, //'r' as u8,\n \n pub fn encode_metadata(parms: encode_parms, crate: &crate) -> ~[u8] {\n     let wr = @io::BytesWriter();\n-    let stats =\n-        {mut inline_bytes: 0,\n-         mut attr_bytes: 0,\n-         mut dep_bytes: 0,\n-         mut lang_item_bytes: 0,\n-         mut item_bytes: 0,\n-         mut index_bytes: 0,\n-         mut zero_bytes: 0,\n-         mut total_bytes: 0,\n-         mut n_inlines: 0};\n+    let mut stats = Stats {\n+        inline_bytes: 0,\n+        attr_bytes: 0,\n+        dep_bytes: 0,\n+        lang_item_bytes: 0,\n+        item_bytes: 0,\n+        index_bytes: 0,\n+        zero_bytes: 0,\n+        total_bytes: 0,\n+        n_inlines: 0\n+    };\n     let ecx: @encode_ctxt = @encode_ctxt({\n         diag: parms.diag,\n         tcx: parms.tcx,\n-        stats: move stats,\n+        stats: @mut move stats,\n         reachable: parms.reachable,\n         reexports2: parms.reexports2,\n         item_symbols: parms.item_symbols,"}, {"sha": "c4b3204799559e17e1569d39be9f69636db62451", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -53,30 +53,35 @@ pub enum DefIdSource {\n }\n type conv_did = fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n \n-pub type pstate = {data: @~[u8], crate: int, mut pos: uint, tcx: ty::ctxt};\n+pub struct PState {\n+    data: @~[u8],\n+    crate: int,\n+    pos: uint,\n+    tcx: ty::ctxt\n+}\n \n-fn peek(st: @pstate) -> char {\n+fn peek(st: @mut PState) -> char {\n     st.data[st.pos] as char\n }\n \n-fn next(st: @pstate) -> char {\n+fn next(st: @mut PState) -> char {\n     let ch = st.data[st.pos] as char;\n     st.pos = st.pos + 1u;\n     return ch;\n }\n \n-fn next_byte(st: @pstate) -> u8 {\n+fn next_byte(st: @mut PState) -> u8 {\n     let b = st.data[st.pos];\n     st.pos = st.pos + 1u;\n     return b;\n }\n \n-pub fn parse_ident(st: @pstate, last: char) -> ast::ident {\n+pub fn parse_ident(st: @mut PState, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n-fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n+fn parse_ident_(st: @mut PState, is_last: fn@(char) -> bool) ->\n    ast::ident {\n     let mut rslt = ~\"\";\n     while !is_last(peek(st)) {\n@@ -86,8 +91,13 @@ fn parse_ident_(st: @pstate, is_last: fn@(char) -> bool) ->\n }\n \n pub fn parse_state_from_data(data: @~[u8], crate_num: int,\n-                         pos: uint, tcx: ty::ctxt) -> @pstate {\n-    @{data: data, crate: crate_num, mut pos: pos, tcx: tcx}\n+                             pos: uint, tcx: ty::ctxt) -> @mut PState {\n+    @mut PState {\n+        data: data,\n+        crate: crate_num,\n+        pos: pos,\n+        tcx: tcx\n+    }\n }\n \n pub fn parse_ty_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n@@ -102,7 +112,7 @@ pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n     parse_arg(st, conv)\n }\n \n-fn parse_path(st: @pstate) -> @ast::path {\n+fn parse_path(st: @mut PState) -> @ast::path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     idents.push(parse_ident_(st, is_last));\n@@ -122,7 +132,7 @@ fn parse_path(st: @pstate) -> @ast::path {\n     };\n }\n \n-fn parse_sigil(st: @pstate) -> ast::Sigil {\n+fn parse_sigil(st: @mut PState) -> ast::Sigil {\n     match next(st) {\n         '@' => ast::ManagedSigil,\n         '~' => ast::OwnedSigil,\n@@ -131,7 +141,7 @@ fn parse_sigil(st: @pstate) -> ast::Sigil {\n     }\n }\n \n-fn parse_vstore(st: @pstate) -> ty::vstore {\n+fn parse_vstore(st: @mut PState) -> ty::vstore {\n     assert next(st) == '/';\n \n     let c = peek(st);\n@@ -149,7 +159,7 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n     }\n }\n \n-fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n+fn parse_substs(st: @mut PState, conv: conv_did) -> ty::substs {\n     let self_r = parse_opt(st, || parse_region(st) );\n \n     let self_ty = parse_opt(st, || parse_ty(st, conv) );\n@@ -166,7 +176,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     };\n }\n \n-fn parse_bound_region(st: @pstate) -> ty::bound_region {\n+fn parse_bound_region(st: @mut PState) -> ty::bound_region {\n     match next(st) {\n       's' => ty::br_self,\n       'a' => {\n@@ -184,7 +194,7 @@ fn parse_bound_region(st: @pstate) -> ty::bound_region {\n     }\n }\n \n-fn parse_region(st: @pstate) -> ty::Region {\n+fn parse_region(st: @mut PState) -> ty::Region {\n     match next(st) {\n       'b' => {\n         ty::re_bound(parse_bound_region(st))\n@@ -209,15 +219,15 @@ fn parse_region(st: @pstate) -> ty::Region {\n     }\n }\n \n-fn parse_opt<T>(st: @pstate, f: fn() -> T) -> Option<T> {\n+fn parse_opt<T>(st: @mut PState, f: fn() -> T) -> Option<T> {\n     match next(st) {\n       'n' => None,\n       's' => Some(f()),\n       _ => die!(~\"parse_opt: bad input\")\n     }\n }\n \n-fn parse_str(st: @pstate, term: char) -> ~str {\n+fn parse_str(st: @mut PState, term: char) -> ~str {\n     let mut result = ~\"\";\n     while peek(st) != term {\n         result += str::from_byte(next_byte(st));\n@@ -226,7 +236,7 @@ fn parse_str(st: @pstate, term: char) -> ~str {\n     return result;\n }\n \n-fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n+fn parse_ty(st: @mut PState, conv: conv_did) -> ty::t {\n     match next(st) {\n       'n' => return ty::mk_nil(st.tcx),\n       'z' => return ty::mk_bot(st.tcx),\n@@ -330,7 +340,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         match st.tcx.rcache.find(&key) {\n           Some(tt) => return tt,\n           None => {\n-            let ps = @{pos: pos ,.. copy *st};\n+            let ps = @mut PState {pos: pos ,.. copy *st};\n             let tt = parse_ty(ps, conv);\n             st.tcx.rcache.insert(key, tt);\n             return tt;\n@@ -354,7 +364,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n     }\n }\n \n-fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n+fn parse_mt(st: @mut PState, conv: conv_did) -> ty::mt {\n     let mut m;\n     match peek(st) {\n       'm' => { next(st); m = ast::m_mutbl; }\n@@ -364,15 +374,15 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     ty::mt { ty: parse_ty(st, conv), mutbl: m }\n }\n \n-fn parse_def(st: @pstate, source: DefIdSource,\n+fn parse_def(st: @mut PState, source: DefIdSource,\n              conv: conv_did) -> ast::def_id {\n     let mut def = ~[];\n     while peek(st) != '|' { def.push(next_byte(st)); }\n     st.pos = st.pos + 1u;\n     return conv(source, parse_def_id(def));\n }\n \n-fn parse_int(st: @pstate) -> int {\n+fn parse_int(st: @mut PState) -> int {\n     let mut n = 0;\n     loop {\n         let cur = peek(st);\n@@ -383,7 +393,7 @@ fn parse_int(st: @pstate) -> int {\n     };\n }\n \n-fn parse_hex(st: @pstate) -> uint {\n+fn parse_hex(st: @mut PState) -> uint {\n     let mut n = 0u;\n     loop {\n         let cur = peek(st);\n@@ -421,11 +431,11 @@ fn parse_onceness(c: char) -> ast::Onceness {\n     }\n }\n \n-fn parse_arg(st: @pstate, conv: conv_did) -> ty::arg {\n+fn parse_arg(st: @mut PState, conv: conv_did) -> ty::arg {\n     ty::arg { mode: parse_mode(st), ty: parse_ty(st, conv) }\n }\n \n-fn parse_mode(st: @pstate) -> ast::mode {\n+fn parse_mode(st: @mut PState) -> ast::mode {\n     let m = ast::expl(match next(st) {\n         '+' => ast::by_copy,\n         '=' => ast::by_ref,\n@@ -435,7 +445,7 @@ fn parse_mode(st: @pstate) -> ast::mode {\n     return m;\n }\n \n-fn parse_closure_ty(st: @pstate, conv: conv_did) -> ty::ClosureTy {\n+fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n@@ -450,7 +460,7 @@ fn parse_closure_ty(st: @pstate, conv: conv_did) -> ty::ClosureTy {\n     }\n }\n \n-fn parse_bare_fn_ty(st: @pstate, conv: conv_did) -> ty::BareFnTy {\n+fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n     let purity = parse_purity(next(st));\n     let abi = parse_abi(next(st));\n     let sig = parse_sig(st, conv);\n@@ -461,7 +471,7 @@ fn parse_bare_fn_ty(st: @pstate, conv: conv_did) -> ty::BareFnTy {\n     }\n }\n \n-fn parse_sig(st: @pstate, conv: conv_did) -> ty::FnSig {\n+fn parse_sig(st: @mut PState, conv: conv_did) -> ty::FnSig {\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n@@ -506,7 +516,7 @@ pub fn parse_bounds_data(data: @~[u8], start: uint,\n     parse_bounds(st, conv)\n }\n \n-fn parse_bounds(st: @pstate, conv: conv_did) -> @~[ty::param_bound] {\n+fn parse_bounds(st: @mut PState, conv: conv_did) -> @~[ty::param_bound] {\n     let mut bounds = ~[];\n     loop {\n         bounds.push(match next(st) {"}, {"sha": "72da98be6b09d7a6add9b9ed085546a7a43476dc", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -1274,13 +1274,13 @@ fn test_simplification() {\n     let item_in = ast::ii_item(quote_item!(\n         fn new_int_alist<B: Copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-            return {eq_fn: eq_int, mut data: ~[]};\n+            return {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());\n     let item_out = simplify_ast(item_in);\n     let item_exp = ast::ii_item(quote_item!(\n         fn new_int_alist<B: Copy>() -> alist<int, B> {\n-            return {eq_fn: eq_int, mut data: ~[]};\n+            return {eq_fn: eq_int, data: ~[]};\n         }\n     ).get());\n     match (item_out, item_exp) {"}, {"sha": "8d439f4ee9ff2eb7be0e824404491791e2bf08e4", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 68, "deletions": 58, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -21,7 +21,7 @@ use core::prelude::*;\n \n use middle::moves;\n use middle::borrowck::{Loan, bckerr, BorrowckCtxt, inherent_mutability};\n-use middle::borrowck::{req_maps, root_map_key, save_and_restore};\n+use middle::borrowck::{req_maps, root_map_key, save_and_restore_managed};\n use middle::borrowck::{MoveError, MoveOk, MoveFromIllegalCmt};\n use middle::borrowck::{MoveWhileBorrowed};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_comp, cat_deref};\n@@ -43,15 +43,15 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-enum check_loan_ctxt = @{\n+struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n     req_maps: req_maps,\n \n     reported: HashMap<ast::node_id, ()>,\n \n-    mut declared_purity: ast::purity,\n-    mut fn_args: @~[ast::node_id]\n-};\n+    declared_purity: @mut ast::purity,\n+    fn_args: @mut @~[ast::node_id]\n+}\n \n // if we are enforcing purity, why are we doing so?\n #[deriving_eq]\n@@ -66,13 +66,15 @@ enum purity_cause {\n }\n \n pub fn check_loans(bccx: @BorrowckCtxt,\n-               req_maps: req_maps,\n-               crate: @ast::crate) {\n-    let clcx = check_loan_ctxt(@{bccx: bccx,\n-                                 req_maps: req_maps,\n-                                 reported: HashMap(),\n-                                 mut declared_purity: ast::impure_fn,\n-                                 mut fn_args: @~[]});\n+                   req_maps: req_maps,\n+                   crate: @ast::crate) {\n+    let clcx = @mut CheckLoanCtxt {\n+        bccx: bccx,\n+        req_maps: req_maps,\n+        reported: HashMap(),\n+        declared_purity: @mut ast::impure_fn,\n+        fn_args: @mut @~[]\n+    };\n     let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n                                            visit_local: check_loans_in_local,\n                                            visit_block: check_loans_in_block,\n@@ -104,11 +106,11 @@ impl assignment_type {\n     }\n }\n \n-impl check_loan_ctxt {\n-    fn tcx() -> ty::ctxt { self.bccx.tcx }\n+impl CheckLoanCtxt {\n+    fn tcx(@mut self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(scope_id: ast::node_id) -> Option<purity_cause> {\n-        let default_purity = match self.declared_purity {\n+    fn purity(@mut self, scope_id: ast::node_id) -> Option<purity_cause> {\n+        let default_purity = match *self.declared_purity {\n           // an unsafe declaration overrides all\n           ast::unsafe_fn => return None,\n \n@@ -138,7 +140,9 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn walk_loans(scope_id: ast::node_id, f: fn(v: &Loan) -> bool) {\n+    fn walk_loans(@mut self,\n+                  scope_id: ast::node_id,\n+                  f: &fn(v: &Loan) -> bool) {\n         let mut scope_id = scope_id;\n         let region_map = self.tcx().region_map;\n         let req_loan_map = self.req_maps.req_loan_map;\n@@ -157,9 +161,10 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn walk_loans_of(scope_id: ast::node_id,\n+    fn walk_loans_of(@mut self,\n+                     scope_id: ast::node_id,\n                      lp: @loan_path,\n-                     f: fn(v: &Loan) -> bool) {\n+                     f: &fn(v: &Loan) -> bool) {\n         for self.walk_loans(scope_id) |loan| {\n             if loan.lp == lp {\n                 if !f(loan) { return; }\n@@ -173,7 +178,8 @@ impl check_loan_ctxt {\n     // note: we take opt_expr and expr_id separately because for\n     // overloaded operators the callee has an id but no expr.\n     // annoying.\n-    fn check_pure_callee_or_arg(pc: purity_cause,\n+    fn check_pure_callee_or_arg(@mut self,\n+                                pc: purity_cause,\n                                 opt_expr: Option<@ast::expr>,\n                                 callee_id: ast::node_id,\n                                 callee_span: span) {\n@@ -239,7 +245,7 @@ impl check_loan_ctxt {\n \n     // True if the expression with the given `id` is a stack closure.\n     // The expression must be an expr_fn(*) or expr_fn_block(*)\n-    fn is_stack_closure(id: ast::node_id) -> bool {\n+    fn is_stack_closure(@mut self, id: ast::node_id) -> bool {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n         match ty::get(fn_ty).sty {\n             ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n@@ -248,7 +254,7 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n+    fn is_allowed_pure_arg(@mut self, expr: @ast::expr) -> bool {\n         return match expr.node {\n           ast::expr_path(_) => {\n             let def = self.tcx().def_map.get(&expr.id);\n@@ -263,7 +269,7 @@ impl check_loan_ctxt {\n         };\n     }\n \n-    fn check_for_conflicting_loans(scope_id: ast::node_id) {\n+    fn check_for_conflicting_loans(@mut self, scope_id: ast::node_id) {\n         debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n \n         let new_loans = match self.req_maps.req_loan_map.find(&scope_id) {\n@@ -292,7 +298,7 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn report_error_if_loans_conflict(&self,\n+    fn report_error_if_loans_conflict(@mut self,\n                                       old_loan: &Loan,\n                                       new_loan: &Loan) {\n         if old_loan.lp != new_loan.lp {\n@@ -319,14 +325,14 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn is_local_variable(cmt: cmt) -> bool {\n+    fn is_local_variable(@mut self, cmt: cmt) -> bool {\n         match cmt.cat {\n           cat_local(_) => true,\n           _ => false\n         }\n     }\n \n-    fn check_assignment(at: assignment_type, ex: @ast::expr) {\n+    fn check_assignment(@mut self, at: assignment_type, ex: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n         let cmt = match self.bccx.tcx.adjustments.find(&ex.id) {\n@@ -393,7 +399,7 @@ impl check_loan_ctxt {\n         self.add_write_guards_if_necessary(cmt);\n     }\n \n-    fn add_write_guards_if_necessary(cmt: cmt) {\n+    fn add_write_guards_if_necessary(@mut self, cmt: cmt) {\n         match cmt.cat {\n             cat_deref(base, deref_count, ptr_kind) => {\n                 self.add_write_guards_if_necessary(base);\n@@ -416,12 +422,11 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn check_for_loan_conflicting_with_assignment(\n-        at: assignment_type,\n-        ex: @ast::expr,\n-        cmt: cmt,\n-        lp: @loan_path) {\n-\n+    fn check_for_loan_conflicting_with_assignment(@mut self,\n+                                                  at: assignment_type,\n+                                                  ex: @ast::expr,\n+                                                  cmt: cmt,\n+                                                  lp: @loan_path) {\n         for self.walk_loans_of(ex.id, lp) |loan| {\n             match loan.mutbl {\n               m_const => { /*ok*/ }\n@@ -455,15 +460,16 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn report_purity_error(pc: purity_cause, sp: span, msg: ~str) {\n+    fn report_purity_error(@mut self, pc: purity_cause, sp: span, msg: ~str) {\n         match pc {\n           pc_pure_fn => {\n             self.tcx().sess.span_err(\n                 sp,\n                 fmt!(\"%s prohibited in pure context\", msg));\n           }\n           pc_cmt(ref e) => {\n-            if self.reported.insert((*e).cmt.id, ()) {\n+            let reported = self.reported;\n+            if reported.insert((*e).cmt.id, ()) {\n                 self.tcx().sess.span_err(\n                     (*e).cmt.span,\n                     fmt!(\"illegal borrow unless pure: %s\",\n@@ -477,7 +483,7 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn check_move_out_from_expr(ex: @ast::expr) {\n+    fn check_move_out_from_expr(@mut self, ex: @ast::expr) {\n         match ex.node {\n             ast::expr_paren(*) => {\n                 /* In the case of an expr_paren(), the expression inside\n@@ -510,7 +516,7 @@ impl check_loan_ctxt {\n         }\n     }\n \n-    fn analyze_move_out_from_cmt(cmt: cmt) -> MoveError {\n+    fn analyze_move_out_from_cmt(@mut self, cmt: cmt) -> MoveError {\n         debug!(\"check_move_out_from_cmt(cmt=%s)\",\n                self.bccx.cmt_to_repr(cmt));\n \n@@ -543,7 +549,8 @@ impl check_loan_ctxt {\n         return MoveOk;\n     }\n \n-    fn check_call(expr: @ast::expr,\n+    fn check_call(@mut self,\n+                  expr: @ast::expr,\n                   callee: Option<@ast::expr>,\n                   callee_id: ast::node_id,\n                   callee_span: span,\n@@ -562,10 +569,13 @@ impl check_loan_ctxt {\n     }\n }\n \n-fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n-                     sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n-                     visitor: visit::vt<check_loan_ctxt>)\n-{\n+fn check_loans_in_fn(fk: visit::fn_kind,\n+                     decl: ast::fn_decl,\n+                     body: ast::blk,\n+                     sp: span,\n+                     id: ast::node_id,\n+                     &&self: @mut CheckLoanCtxt,\n+                     visitor: visit::vt<@mut CheckLoanCtxt>) {\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n \n@@ -580,15 +590,16 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n             let fty_sigil = ty::ty_closure_sigil(fty);\n             check_moves_from_captured_variables(self, id, fty_sigil);\n             declared_purity = ty::determine_inherited_purity(\n-                copy self.declared_purity, ty::ty_fn_purity(fty),\n+                *self.declared_purity,\n+                ty::ty_fn_purity(fty),\n                 fty_sigil);\n         }\n     }\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n-    do save_and_restore(&mut(self.declared_purity)) {\n-        do save_and_restore(&mut(self.fn_args)) {\n-            self.declared_purity = declared_purity;\n+    do save_and_restore_managed(self.declared_purity) {\n+        do save_and_restore_managed(self.fn_args) {\n+            *self.declared_purity = declared_purity;\n \n             match fk {\n                 visit::fk_anon(*) |\n@@ -611,7 +622,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                             _ => {} // Ignore this argument.\n                         }\n                     }\n-                    self.fn_args = @move fn_args;\n+                    *self.fn_args = @move fn_args;\n                 }\n             }\n \n@@ -620,10 +631,9 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n     }\n     debug!(\"purity on exit=%?\", copy self.declared_purity);\n \n-    fn check_moves_from_captured_variables(&&self: check_loan_ctxt,\n+    fn check_moves_from_captured_variables(self: @mut CheckLoanCtxt,\n                                            id: ast::node_id,\n-                                           fty_sigil: ast::Sigil)\n-    {\n+                                           fty_sigil: ast::Sigil) {\n         match fty_sigil {\n             ast::ManagedSigil | ast::OwnedSigil => {\n                 let cap_vars = self.bccx.capture_map.get(&id);\n@@ -666,14 +676,14 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n }\n \n fn check_loans_in_local(local: @ast::local,\n-                        &&self: check_loan_ctxt,\n-                        vt: visit::vt<check_loan_ctxt>) {\n+                        &&self: @mut CheckLoanCtxt,\n+                        vt: visit::vt<@mut CheckLoanCtxt>) {\n     visit::visit_local(local, self, vt);\n }\n \n fn check_loans_in_expr(expr: @ast::expr,\n-                       &&self: check_loan_ctxt,\n-                       vt: visit::vt<check_loan_ctxt>) {\n+                       &&self: @mut CheckLoanCtxt,\n+                       vt: visit::vt<@mut CheckLoanCtxt>) {\n     debug!(\"check_loans_in_expr(expr=%?/%s)\",\n            expr.id, pprust::expr_to_str(expr, self.tcx().sess.intr()));\n \n@@ -734,16 +744,16 @@ fn check_loans_in_expr(expr: @ast::expr,\n }\n \n fn check_loans_in_block(blk: ast::blk,\n-                        &&self: check_loan_ctxt,\n-                        vt: visit::vt<check_loan_ctxt>) {\n-    do save_and_restore(&mut(self.declared_purity)) {\n+                        &&self: @mut CheckLoanCtxt,\n+                        vt: visit::vt<@mut CheckLoanCtxt>) {\n+    do save_and_restore_managed(self.declared_purity) {\n         self.check_for_conflicting_loans(blk.node.id);\n \n         match blk.node.rules {\n           ast::default_blk => {\n           }\n           ast::unsafe_blk => {\n-            self.declared_purity = ast::unsafe_fn;\n+            *self.declared_purity = ast::unsafe_fn;\n           }\n         }\n "}, {"sha": "6a61b2e2ee75cfcb29b14da3ad55e752d7dfc417", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -68,19 +68,22 @@ use syntax::visit;\n /// No good.  Instead what will happen is that `root_ub` will be set to the\n /// body of the while loop and we will refuse to root the pointer `&*x`\n /// because it would have to be rooted for a region greater than `root_ub`.\n-enum gather_loan_ctxt = @{bccx: @BorrowckCtxt,\n-                          req_maps: req_maps,\n-                          mut item_ub: ast::node_id,\n-                          mut root_ub: ast::node_id,\n-                          mut ignore_adjustments: LinearSet<ast::node_id>};\n+struct GatherLoanCtxt {\n+    bccx: @BorrowckCtxt,\n+    req_maps: req_maps,\n+    item_ub: ast::node_id,\n+    root_ub: ast::node_id,\n+    ignore_adjustments: LinearSet<ast::node_id>\n+}\n \n pub fn gather_loans(bccx: @BorrowckCtxt, crate: @ast::crate) -> req_maps {\n-    let glcx = gather_loan_ctxt(@{bccx: bccx,\n-                                  req_maps: {req_loan_map: HashMap(),\n-                                             pure_map: HashMap()},\n-                                  mut item_ub: 0,\n-                                  mut root_ub: 0,\n-                                  mut ignore_adjustments: LinearSet::new()});\n+    let glcx = @mut GatherLoanCtxt {\n+        bccx: bccx,\n+        req_maps: {req_loan_map: HashMap(), pure_map: HashMap()},\n+        item_ub: 0,\n+        root_ub: 0,\n+        ignore_adjustments: LinearSet::new()\n+    };\n     let v = visit::mk_vt(@visit::Visitor {visit_expr: req_loans_in_expr,\n                                           visit_fn: req_loans_in_fn,\n                                           visit_stmt: add_stmt_to_map,\n@@ -94,8 +97,8 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n                    body: ast::blk,\n                    sp: span,\n                    id: ast::node_id,\n-                   &&self: gather_loan_ctxt,\n-                   v: visit::vt<gather_loan_ctxt>) {\n+                   &&self: @mut GatherLoanCtxt,\n+                   v: visit::vt<@mut GatherLoanCtxt>) {\n     // see explanation attached to the `root_ub` field:\n     let old_item_id = self.item_ub;\n     let old_root_ub = self.root_ub;\n@@ -115,8 +118,8 @@ fn req_loans_in_fn(fk: visit::fn_kind,\n }\n \n fn req_loans_in_expr(ex: @ast::expr,\n-                     &&self: gather_loan_ctxt,\n-                     vt: visit::vt<gather_loan_ctxt>) {\n+                     &&self: @mut GatherLoanCtxt,\n+                     vt: visit::vt<@mut GatherLoanCtxt>) {\n     let bccx = self.bccx;\n     let tcx = bccx.tcx;\n     let old_root_ub = self.root_ub;\n@@ -283,10 +286,10 @@ fn req_loans_in_expr(ex: @ast::expr,\n     self.root_ub = old_root_ub;\n }\n \n-impl gather_loan_ctxt {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+impl GatherLoanCtxt {\n+    fn tcx(@mut self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn guarantee_adjustments(&self,\n+    fn guarantee_adjustments(@mut self,\n                              expr: @ast::expr,\n                              adjustment: &ty::AutoAdjustment) {\n         debug!(\"guarantee_adjustments(expr=%s, adjustment=%?)\",\n@@ -334,12 +337,12 @@ impl gather_loan_ctxt {\n     // out loans, which will be added to the `req_loan_map`.  This can\n     // also entail \"rooting\" GC'd pointers, which means ensuring\n     // dynamically that they are not freed.\n-    fn guarantee_valid(&self,\n+    fn guarantee_valid(@mut self,\n                        cmt: cmt,\n                        req_mutbl: ast::mutability,\n                        scope_r: ty::Region) {\n \n-        self.bccx.guaranteed_paths += 1;\n+        self.bccx.stats.guaranteed_paths += 1;\n \n         debug!(\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n                self.bccx.cmt_to_repr(cmt),\n@@ -391,7 +394,7 @@ impl gather_loan_ctxt {\n                     // we were able guarantee the validity of the ptr,\n                     // perhaps by rooting or because it is immutably\n                     // rooted.  good.\n-                    self.bccx.stable_paths += 1;\n+                    self.bccx.stats.stable_paths += 1;\n                 }\n                 Ok(PcIfPure(ref e)) => {\n                     debug!(\"result of preserve: %?\", PcIfPure((*e)));\n@@ -403,8 +406,9 @@ impl gather_loan_ctxt {\n                             // if the scope is some block/expr in the\n                             // fn, then just require that this scope\n                             // be pure\n-                            self.req_maps.pure_map.insert(pure_id, (*e));\n-                            self.bccx.req_pure_paths += 1;\n+                            let pure_map = self.req_maps.pure_map;\n+                            pure_map.insert(pure_id, *e);\n+                            self.bccx.stats.req_pure_paths += 1;\n \n                             debug!(\"requiring purity for scope %?\",\n                                    scope_r);\n@@ -441,9 +445,10 @@ impl gather_loan_ctxt {\n     // has type `@mut{f:int}`, this check might fail because `&x.f`\n     // reqires an immutable pointer, but `f` lives in (aliased)\n     // mutable memory.\n-    fn check_mutbl(&self,\n+    fn check_mutbl(@mut self,\n                    req_mutbl: ast::mutability,\n-                   cmt: cmt) -> bckres<PreserveCondition> {\n+                   cmt: cmt)\n+                -> bckres<PreserveCondition> {\n         debug!(\"check_mutbl(req_mutbl=%?, cmt.mutbl=%?)\",\n                req_mutbl, cmt.mutbl);\n \n@@ -469,7 +474,7 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn add_loans(&self,\n+    fn add_loans(@mut self,\n                  cmt: cmt,\n                  req_mutbl: ast::mutability,\n                  scope_r: ty::Region,\n@@ -522,32 +527,35 @@ impl gather_loan_ctxt {\n         self.add_loans_to_scope_id(scope_id, move loans);\n \n         if req_mutbl == m_imm && cmt.mutbl != m_imm {\n-            self.bccx.loaned_paths_imm += 1;\n+            self.bccx.stats.loaned_paths_imm += 1;\n \n             if self.tcx().sess.borrowck_note_loan() {\n                 self.bccx.span_note(\n                     cmt.span,\n                     fmt!(\"immutable loan required\"));\n             }\n         } else {\n-            self.bccx.loaned_paths_same += 1;\n+            self.bccx.stats.loaned_paths_same += 1;\n         }\n     }\n \n-    fn add_loans_to_scope_id(&self, scope_id: ast::node_id, +loans: ~[Loan]) {\n+    fn add_loans_to_scope_id(@mut self,\n+                             scope_id: ast::node_id,\n+                             +loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?\", loans.len(), scope_id);\n         match self.req_maps.req_loan_map.find(&scope_id) {\n             Some(req_loans) => {\n                 req_loans.push_all(loans);\n             }\n             None => {\n                 let dvec = @dvec::from_vec(move loans);\n-                self.req_maps.req_loan_map.insert(scope_id, dvec);\n+                let req_loan_map = self.req_maps.req_loan_map;\n+                req_loan_map.insert(scope_id, dvec);\n             }\n         }\n     }\n \n-    fn gather_pat(&self,\n+    fn gather_pat(@mut self,\n                   discr_cmt: cmt,\n                   root_pat: @ast::pat,\n                   arm_id: ast::node_id,\n@@ -602,10 +610,9 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn vec_slice_info(&self,\n+    fn vec_slice_info(@mut self,\n                       pat: @ast::pat,\n-                      tail_ty: ty::t) -> (ast::mutability, ty::Region)\n-    {\n+                      tail_ty: ty::t) -> (ast::mutability, ty::Region) {\n         /*!\n          *\n          * In a pattern like [a, b, ..c], normally `c` has slice type,\n@@ -631,20 +638,20 @@ impl gather_loan_ctxt {\n         }\n     }\n \n-    fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n+    fn pat_is_variant_or_struct(@mut self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n     }\n \n-    fn pat_is_binding(&self, pat: @ast::pat) -> bool {\n+    fn pat_is_binding(@mut self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }\n }\n \n // Setting up info that preserve needs.\n // This is just the most convenient place to do it.\n fn add_stmt_to_map(stmt: @ast::stmt,\n-                   &&self: gather_loan_ctxt,\n-                   vt: visit::vt<gather_loan_ctxt>) {\n+                   &&self: @mut GatherLoanCtxt,\n+                   vt: visit::vt<@mut GatherLoanCtxt>) {\n     match stmt.node {\n         ast::stmt_expr(_, id) | ast::stmt_semi(_, id) => {\n             self.bccx.stmt_map.insert(id, ());\n@@ -653,3 +660,4 @@ fn add_stmt_to_map(stmt: @ast::stmt,\n     }\n     visit::visit_stmt(stmt, self, vt);\n }\n+"}, {"sha": "da22b20fd1daa524ad1e05ed94d6a8ca73b73ba0", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -62,18 +62,17 @@ impl BorrowckCtxt {\n             cmt: cmt,\n             scope_region: ty::Region,\n             mutbl: ast::mutability) -> bckres<~[Loan]> {\n-        let lc = LoanContext {\n+        let mut lc = LoanContext {\n             bccx: self,\n             scope_region: scope_region,\n             loans: ~[]\n         };\n         match lc.loan(cmt, mutbl, true) {\n-          Err(ref e) => Err((*e)),\n-          Ok(()) => {\n-              let LoanContext {loans, _} = move lc;\n-              Ok(loans)\n-          }\n+            Err(ref e) => return Err((*e)),\n+            Ok(()) => {}\n         }\n+        // XXX: Workaround for borrow check bug.\n+        Ok(copy lc.loans)\n     }\n }\n \n@@ -84,17 +83,16 @@ struct LoanContext {\n     scope_region: ty::Region,\n \n     // accumulated list of loans that will be required\n-    mut loans: ~[Loan]\n+    loans: ~[Loan]\n }\n \n impl LoanContext {\n-    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n+    fn tcx(&mut self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn loan(&self,\n+    fn loan(&mut self,\n             cmt: cmt,\n             req_mutbl: ast::mutability,\n-            owns_lent_data: bool) -> bckres<()>\n-    {\n+            owns_lent_data: bool) -> bckres<()> {\n         /*!\n          *\n          * The main routine.\n@@ -198,7 +196,7 @@ impl LoanContext {\n     // A \"stable component\" is one where assigning the base of the\n     // component cannot cause the component itself to change types.\n     // Example: record fields.\n-    fn loan_stable_comp(&self,\n+    fn loan_stable_comp(&mut self,\n                         cmt: cmt,\n                         cmt_base: cmt,\n                         req_mutbl: ast::mutability,\n@@ -268,12 +266,11 @@ impl LoanContext {\n     // An \"unstable deref\" means a deref of a ptr/comp where, if the\n     // base of the deref is assigned to, pointers into the result of the\n     // deref would be invalidated. Examples: interior of variants, uniques.\n-    fn loan_unstable_deref(&self,\n+    fn loan_unstable_deref(&mut self,\n                            cmt: cmt,\n                            cmt_base: cmt,\n                            req_mutbl: ast::mutability,\n-                           owns_lent_data: bool) -> bckres<()>\n-    {\n+                           owns_lent_data: bool) -> bckres<()> {\n         // Variant components: the base must be immutable, because\n         // if it is overwritten, the types of the embedded data\n         // could change.\n@@ -284,12 +281,11 @@ impl LoanContext {\n         }\n     }\n \n-    fn issue_loan(&self,\n+    fn issue_loan(&mut self,\n                   cmt: cmt,\n                   scope_ub: ty::Region,\n                   req_mutbl: ast::mutability,\n-                  owns_lent_data: bool) -> bckres<()>\n-    {\n+                  owns_lent_data: bool) -> bckres<()> {\n         // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n         // Therefore, if `cmt` owns the data being lent, then the\n         // scope of the loan must be less than `scope_ub`, or else the\n@@ -301,8 +297,8 @@ impl LoanContext {\n         // reborrowed.\n \n         if !owns_lent_data ||\n-            self.bccx.is_subregion_of(self.scope_region, scope_ub)\n-        {\n+            self.bccx.is_subregion_of(/*bad*/copy self.scope_region,\n+                                      scope_ub) {\n             match req_mutbl {\n                 m_mutbl => {\n                     // We do not allow non-mutable data to be loaned\n@@ -340,3 +336,4 @@ impl LoanContext {\n         }\n     }\n }\n+"}, {"sha": "3d45ee461dcb7f1d4b280e493fa5c62ad84a6ccc", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -262,42 +262,46 @@ pub fn check_crate(\n     capture_map: moves::CaptureMap,\n     crate: @ast::crate) -> (root_map, mutbl_map, write_guard_map)\n {\n-    let bccx = @BorrowckCtxt   {tcx: tcx,\n-                                method_map: method_map,\n-                                moves_map: moves_map,\n-                                capture_map: capture_map,\n-                                root_map: root_map(),\n-                                mutbl_map: HashMap(),\n-                                write_guard_map: HashMap(),\n-                                stmt_map: HashMap(),\n-                                mut loaned_paths_same: 0,\n-                                mut loaned_paths_imm: 0,\n-                                mut stable_paths: 0,\n-                                mut req_pure_paths: 0,\n-                                mut guaranteed_paths: 0};\n+    let bccx = @BorrowckCtxt {\n+        tcx: tcx,\n+        method_map: method_map,\n+        moves_map: moves_map,\n+        capture_map: capture_map,\n+        root_map: root_map(),\n+        mutbl_map: HashMap(),\n+        write_guard_map: HashMap(),\n+        stmt_map: HashMap(),\n+        stats: @mut BorrowStats {\n+            loaned_paths_same: 0,\n+            loaned_paths_imm: 0,\n+            stable_paths: 0,\n+            req_pure_paths: 0,\n+            guaranteed_paths: 0,\n+        }\n+    };\n \n     let req_maps = gather_loans::gather_loans(bccx, crate);\n     check_loans::check_loans(bccx, req_maps, crate);\n \n     if tcx.sess.borrowck_stats() {\n         io::println(~\"--- borrowck stats ---\");\n         io::println(fmt!(\"paths requiring guarantees: %u\",\n-                        bccx.guaranteed_paths));\n+                        bccx.stats.guaranteed_paths));\n         io::println(fmt!(\"paths requiring loans     : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_same)));\n+                         make_stat(bccx, bccx.stats.loaned_paths_same)));\n         io::println(fmt!(\"paths requiring imm loans : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_imm)));\n+                         make_stat(bccx, bccx.stats.loaned_paths_imm)));\n         io::println(fmt!(\"stable paths              : %s\",\n-                         make_stat(bccx, bccx.stable_paths)));\n+                         make_stat(bccx, bccx.stats.stable_paths)));\n         io::println(fmt!(\"paths requiring purity    : %s\",\n-                         make_stat(bccx, bccx.req_pure_paths)));\n+                         make_stat(bccx, bccx.stats.req_pure_paths)));\n     }\n \n     return (bccx.root_map, bccx.mutbl_map, bccx.write_guard_map);\n \n     fn make_stat(bccx: &BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n-        let total = bccx.guaranteed_paths as float;\n+        let total = bccx.stats.guaranteed_paths as float;\n         fmt!(\"%u (%.0f%%)\", stat  , stat_f * 100f / total)\n     }\n }\n@@ -316,11 +320,15 @@ pub struct BorrowckCtxt {\n     stmt_map: stmt_set,\n \n     // Statistics:\n-    mut loaned_paths_same: uint,\n-    mut loaned_paths_imm: uint,\n-    mut stable_paths: uint,\n-    mut req_pure_paths: uint,\n-    mut guaranteed_paths: uint\n+    stats: @mut BorrowStats\n+}\n+\n+pub struct BorrowStats {\n+    loaned_paths_same: uint,\n+    loaned_paths_imm: uint,\n+    stable_paths: uint,\n+    req_pure_paths: uint,\n+    guaranteed_paths: uint\n }\n \n pub struct RootInfo {\n@@ -397,7 +405,15 @@ pub type req_maps = {\n };\n \n pub fn save_and_restore<T:Copy,U>(save_and_restore_t: &mut T,\n-                                  f: fn() -> U) -> U {\n+                                  f: &fn() -> U) -> U {\n+    let old_save_and_restore_t = *save_and_restore_t;\n+    let u = f();\n+    *save_and_restore_t = old_save_and_restore_t;\n+    move u\n+}\n+\n+pub fn save_and_restore_managed<T:Copy,U>(save_and_restore_t: @mut T,\n+                                          f: &fn() -> U) -> U {\n     let old_save_and_restore_t = *save_and_restore_t;\n     let u = f();\n     *save_and_restore_t = old_save_and_restore_t;"}, {"sha": "3d105ad551182d14e953ee96260953f600ae6442", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 57, "deletions": 42, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -66,10 +66,10 @@\n  * methods.  It effectively does a reverse walk of the AST; whenever we\n  * reach a loop node, we iterate until a fixed point is reached.\n  *\n- * ## The `users` struct\n+ * ## The `Users` struct\n  *\n  * At each live node `N`, we track three pieces of information for each\n- * variable `V` (these are encapsulated in the `users` struct):\n+ * variable `V` (these are encapsulated in the `Users` struct):\n  *\n  * - `reader`: the `LiveNode` ID of some node which will read the value\n  *    that `V` holds on entry to `N`.  Formally: a node `M` such\n@@ -214,8 +214,11 @@ pub fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = HashMap();\n-    let initial_maps = @IrMaps(tcx, method_map, variable_moves_map,\n-                               capture_map, last_use_map);\n+    let initial_maps = @mut IrMaps(tcx,\n+                                   method_map,\n+                                   variable_moves_map,\n+                                   capture_map,\n+                                   last_use_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n     return last_use_map;\n@@ -300,20 +303,21 @@ struct IrMaps {\n     capture_map: moves::CaptureMap,\n     last_use_map: last_use_map,\n \n-    mut num_live_nodes: uint,\n-    mut num_vars: uint,\n+    num_live_nodes: uint,\n+    num_vars: uint,\n     live_node_map: HashMap<node_id, LiveNode>,\n     variable_map: HashMap<node_id, Variable>,\n     capture_info_map: HashMap<node_id, @~[CaptureInfo]>,\n-    mut var_kinds: ~[VarKind],\n-    mut lnks: ~[LiveNodeKind],\n+    var_kinds: ~[VarKind],\n+    lnks: ~[LiveNodeKind],\n }\n \n fn IrMaps(tcx: ty::ctxt,\n           method_map: typeck::method_map,\n           variable_moves_map: moves::VariableMovesMap,\n           capture_map: moves::CaptureMap,\n-          last_use_map: last_use_map) -> IrMaps {\n+          last_use_map: last_use_map)\n+       -> IrMaps {\n     IrMaps {\n         tcx: tcx,\n         method_map: method_map,\n@@ -331,7 +335,7 @@ fn IrMaps(tcx: ty::ctxt,\n }\n \n impl IrMaps {\n-    fn add_live_node(lnk: LiveNodeKind) -> LiveNode {\n+    fn add_live_node(&mut self, lnk: LiveNodeKind) -> LiveNode {\n         let ln = LiveNode(self.num_live_nodes);\n         self.lnks.push(lnk);\n         self.num_live_nodes += 1;\n@@ -342,14 +346,16 @@ impl IrMaps {\n         ln\n     }\n \n-    fn add_live_node_for_node(node_id: node_id, lnk: LiveNodeKind) {\n+    fn add_live_node_for_node(&mut self,\n+                              node_id: node_id,\n+                              lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n         debug!(\"%s is node %d\", ln.to_str(), node_id);\n     }\n \n-    fn add_variable(vk: VarKind) -> Variable {\n+    fn add_variable(&mut self, vk: VarKind) -> Variable {\n         let v = Variable(self.num_vars);\n         self.var_kinds.push(vk);\n         self.num_vars += 1;\n@@ -367,7 +373,7 @@ impl IrMaps {\n         v\n     }\n \n-    fn variable(node_id: node_id, span: span) -> Variable {\n+    fn variable(&mut self, node_id: node_id, span: span) -> Variable {\n         match self.variable_map.find(&node_id) {\n           Some(var) => var,\n           None => {\n@@ -377,19 +383,19 @@ impl IrMaps {\n         }\n     }\n \n-    fn variable_name(var: Variable) -> ~str {\n+    fn variable_name(&mut self, var: Variable) -> ~str {\n         match copy self.var_kinds[*var] {\n             Local(LocalInfo {ident: nm, _}) |\n             Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n             ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n-    fn set_captures(node_id: node_id, +cs: ~[CaptureInfo]) {\n+    fn set_captures(&mut self, node_id: node_id, +cs: ~[CaptureInfo]) {\n         self.capture_info_map.insert(node_id, @cs);\n     }\n \n-    fn captures(expr: @expr) -> @~[CaptureInfo] {\n+    fn captures(&mut self, expr: @expr) -> @~[CaptureInfo] {\n         match self.capture_info_map.find(&expr.id) {\n           Some(caps) => caps,\n           None => {\n@@ -398,11 +404,11 @@ impl IrMaps {\n         }\n     }\n \n-    fn lnk(ln: LiveNode) -> LiveNodeKind {\n+    fn lnk(&mut self, ln: LiveNode) -> LiveNodeKind {\n         self.lnks[*ln]\n     }\n \n-    fn add_last_use(expr_id: node_id, var: Variable) {\n+    fn add_last_use(&mut self, expr_id: node_id, var: Variable) {\n         let vk = self.var_kinds[*var];\n         debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n         match vk {\n@@ -429,17 +435,22 @@ impl IrMaps {\n     }\n }\n \n-fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-            sp: span, id: node_id, &&self: @IrMaps, v: vt<@IrMaps>) {\n+fn visit_fn(fk: visit::fn_kind,\n+            decl: fn_decl,\n+            body: blk,\n+            sp: span,\n+            id: node_id,\n+            &&self: @mut IrMaps,\n+            v: vt<@mut IrMaps>) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = ::util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @IrMaps(self.tcx,\n-                          self.method_map,\n-                          self.variable_moves_map,\n-                          self.capture_map,\n-                          self.last_use_map);\n+    let fn_maps = @mut IrMaps(self.tcx,\n+                              self.method_map,\n+                              self.variable_moves_map,\n+                              self.capture_map,\n+                              self.last_use_map);\n \n     debug!(\"creating fn_maps: %x\", ptr::addr_of(&(*fn_maps)) as uint);\n \n@@ -449,7 +460,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                 |_bm, arg_id, _x, path| {\n             debug!(\"adding argument %d\", arg_id);\n             let ident = ast_util::path_to_ident(path);\n-            (*fn_maps).add_variable(Arg(arg_id, ident, mode));\n+            fn_maps.add_variable(Arg(arg_id, ident, mode));\n         }\n     };\n \n@@ -486,10 +497,10 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     // - exit_ln represents the end of the fn, either by return or fail\n     // - implicit_ret_var is a pseudo-variable that represents\n     //   an implicit return\n-    let specials = {\n-        exit_ln: (*fn_maps).add_live_node(ExitNode),\n-        fallthrough_ln: (*fn_maps).add_live_node(ExitNode),\n-        no_ret_var: (*fn_maps).add_variable(ImplicitRet)\n+    let specials = Specials {\n+        exit_ln: fn_maps.add_live_node(ExitNode),\n+        fallthrough_ln: fn_maps.add_live_node(ExitNode),\n+        no_ret_var: fn_maps.add_variable(ImplicitRet)\n     };\n \n     // compute liveness\n@@ -509,7 +520,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n+fn visit_local(local: @local, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n@@ -529,7 +540,7 @@ fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn visit_arm(arm: arm, &&self: @IrMaps, vt: vt<@IrMaps>) {\n+fn visit_arm(arm: arm, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     let def_map = self.tcx.def_map;\n     for arm.pats.each |pat| {\n         do pat_util::pat_bindings(def_map, *pat) |bm, p_id, sp, path| {\n@@ -548,7 +559,7 @@ fn visit_arm(arm: arm, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     visit::visit_arm(arm, self, vt);\n }\n \n-fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n+fn visit_expr(expr: @expr, &&self: @mut IrMaps, vt: vt<@mut IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n@@ -626,21 +637,25 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n-type users = {\n+struct Users {\n     reader: LiveNode,\n     writer: LiveNode,\n     used: bool\n-};\n+}\n \n-fn invalid_users() -> users {\n-    {reader: invalid_node(), writer: invalid_node(), used: false}\n+fn invalid_users() -> Users {\n+    Users {\n+        reader: invalid_node(),\n+        writer: invalid_node(),\n+        used: false\n+    }\n }\n \n-type Specials = {\n+struct Specials {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n     no_ret_var: Variable\n-};\n+}\n \n const ACC_READ: uint = 1u;\n const ACC_WRITE: uint = 2u;\n@@ -650,10 +665,10 @@ type LiveNodeMap = HashMap<node_id, LiveNode>;\n \n struct Liveness {\n     tcx: ty::ctxt,\n-    ir: @IrMaps,\n+    ir: @mut IrMaps,\n     s: Specials,\n     successors: ~[mut LiveNode],\n-    users: ~[mut users],\n+    users: ~[mut Users],\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n     loop_scope: DVec<node_id>,\n@@ -664,7 +679,7 @@ struct Liveness {\n     cont_ln: LiveNodeMap\n }\n \n-fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n+fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n     Liveness {\n         ir: ir,\n         tcx: ir.tcx,"}, {"sha": "49b373fe6b1aec8a20781165de93801aa7e0fdf2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 56, "deletions": 49, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -408,28 +408,24 @@ pub struct region_dep {\n \n pub type dep_map = HashMap<ast::node_id, @DVec<region_dep>>;\n \n-pub type determine_rp_ctxt_ = {\n+pub struct DetermineRpCtxt {\n     sess: Session,\n     ast_map: ast_map::map,\n     def_map: resolve::DefMap,\n     region_paramd_items: region_paramd_items,\n     dep_map: dep_map,\n-    worklist: DVec<ast::node_id>,\n+    worklist: ~[ast::node_id],\n \n     // the innermost enclosing item id\n-    mut item_id: ast::node_id,\n+    item_id: ast::node_id,\n \n     // true when we are within an item but not within a method.\n     // see long discussion on region_is_relevant()\n-    mut anon_implies_rp: bool,\n+    anon_implies_rp: bool,\n \n     // encodes the context of the current type; invariant if\n     // mutable, covariant otherwise\n-    mut ambient_variance: region_variance,\n-};\n-\n-pub enum determine_rp_ctxt {\n-    determine_rp_ctxt_(@determine_rp_ctxt_)\n+    ambient_variance: region_variance,\n }\n \n pub fn join_variance(++variance1: region_variance,\n@@ -465,15 +461,15 @@ pub fn add_variance(+ambient_variance: region_variance,\n     }\n }\n \n-pub impl determine_rp_ctxt {\n-    fn add_variance(variance: region_variance) -> region_variance {\n+pub impl DetermineRpCtxt {\n+    fn add_variance(@mut self, variance: region_variance) -> region_variance {\n         add_variance(self.ambient_variance, variance)\n     }\n \n     /// Records that item `id` is region-parameterized with the\n     /// variance `variance`.  If `id` was already parameterized, then\n     /// the new variance is joined with the old variance.\n-    fn add_rp(id: ast::node_id, variance: region_variance) {\n+    fn add_rp(@mut self, id: ast::node_id, variance: region_variance) {\n         assert id != 0;\n         let old_variance = self.region_paramd_items.find(&id);\n         let joined_variance = match old_variance {\n@@ -487,7 +483,8 @@ pub impl determine_rp_ctxt {\n                joined_variance, old_variance, variance);\n \n         if Some(joined_variance) != old_variance {\n-            self.region_paramd_items.insert(id, joined_variance);\n+            let region_paramd_items = self.region_paramd_items;\n+            region_paramd_items.insert(id, joined_variance);\n             self.worklist.push(id);\n         }\n     }\n@@ -497,7 +494,7 @@ pub impl determine_rp_ctxt {\n     /// `from`.  Put another way, it indicates that the current item\n     /// contains a value of type `from`, so if `from` is\n     /// region-parameterized, so is the current item.\n-    fn add_dep(from: ast::node_id) {\n+    fn add_dep(@mut self, from: ast::node_id) {\n         debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n@@ -509,7 +506,8 @@ pub impl determine_rp_ctxt {\n             Some(vec) => vec,\n             None => {\n                 let vec = @DVec();\n-                self.dep_map.insert(from, vec);\n+                let dep_map = self.dep_map;\n+                dep_map.insert(from, vec);\n                 vec\n             }\n         };\n@@ -552,7 +550,7 @@ pub impl determine_rp_ctxt {\n     // case it is bound.  We handle this by setting a flag\n     // (anon_implies_rp) to true when we enter an item and setting\n     // that flag to false when we enter a method.\n-    fn region_is_relevant(r: @ast::region) -> bool {\n+    fn region_is_relevant(@mut self, r: @ast::region) -> bool {\n         match r.node {\n             ast::re_static => false,\n             ast::re_anon => self.anon_implies_rp,\n@@ -567,7 +565,9 @@ pub impl determine_rp_ctxt {\n     //\n     // If the region is explicitly specified, then we follows the\n     // normal rules.\n-    fn opt_region_is_relevant(opt_r: Option<@ast::region>) -> bool {\n+    fn opt_region_is_relevant(@mut self,\n+                              opt_r: Option<@ast::region>)\n+                           -> bool {\n         debug!(\"opt_region_is_relevant: %? (anon_implies_rp=%b)\",\n                opt_r, self.anon_implies_rp);\n         match opt_r {\n@@ -576,9 +576,10 @@ pub impl determine_rp_ctxt {\n         }\n     }\n \n-    fn with(item_id: ast::node_id,\n+    fn with(@mut self,\n+            item_id: ast::node_id,\n             anon_implies_rp: bool,\n-            f: fn()) {\n+            f: &fn()) {\n         let old_item_id = self.item_id;\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n@@ -590,7 +591,7 @@ pub impl determine_rp_ctxt {\n         self.anon_implies_rp = old_anon_implies_rp;\n     }\n \n-    fn with_ambient_variance(variance: region_variance, f: fn()) {\n+    fn with_ambient_variance(@mut self, variance: region_variance, f: &fn()) {\n         let old_ambient_variance = self.ambient_variance;\n         self.ambient_variance = self.add_variance(variance);\n         f();\n@@ -599,8 +600,8 @@ pub impl determine_rp_ctxt {\n }\n \n pub fn determine_rp_in_item(item: @ast::item,\n-                            &&cx: determine_rp_ctxt,\n-                            visitor: visit::vt<determine_rp_ctxt>) {\n+                            &&cx: @mut DetermineRpCtxt,\n+                            visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(item.id, true) {\n         visit::visit_item(item, cx, visitor);\n     }\n@@ -609,10 +610,10 @@ pub fn determine_rp_in_item(item: @ast::item,\n pub fn determine_rp_in_fn(fk: visit::fn_kind,\n                           decl: ast::fn_decl,\n                           body: ast::blk,\n-                          _sp: span,\n-                          _id: ast::node_id,\n-                          &&cx: determine_rp_ctxt,\n-                          visitor: visit::vt<determine_rp_ctxt>) {\n+                          _: span,\n+                          _: ast::node_id,\n+                          &&cx: @mut DetermineRpCtxt,\n+                          visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.each |a| {\n@@ -626,16 +627,16 @@ pub fn determine_rp_in_fn(fk: visit::fn_kind,\n }\n \n pub fn determine_rp_in_ty_method(ty_m: ast::ty_method,\n-                                 &&cx: determine_rp_ctxt,\n-                                 visitor: visit::vt<determine_rp_ctxt>) {\n+                                 &&cx: @mut DetermineRpCtxt,\n+                                 visitor: visit::vt<@mut DetermineRpCtxt>) {\n     do cx.with(cx.item_id, false) {\n         visit::visit_ty_method(ty_m, cx, visitor);\n     }\n }\n \n pub fn determine_rp_in_ty(ty: @ast::Ty,\n-                          &&cx: determine_rp_ctxt,\n-                          visitor: visit::vt<determine_rp_ctxt>) {\n+                          &&cx: @mut DetermineRpCtxt,\n+                          visitor: visit::vt<@mut DetermineRpCtxt>) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -647,10 +648,11 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // respect to &r, because &r/ty can be used whereever a *smaller*\n     // region is expected (and hence is a supertype of those\n     // locations)\n+    let sess = cx.sess;\n     match ty.node {\n         ast::ty_rptr(r, _) => {\n             debug!(\"referenced rptr type %s\",\n-                   pprust::ty_to_str(ty, cx.sess.intr()));\n+                   pprust::ty_to_str(ty, sess.intr()));\n \n             if cx.region_is_relevant(r) {\n                 cx.add_rp(cx.item_id, cx.add_variance(rv_contravariant))\n@@ -659,7 +661,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n \n         ast::ty_closure(ref f) => {\n             debug!(\"referenced fn type: %s\",\n-                   pprust::ty_to_str(ty, cx.sess.intr()));\n+                   pprust::ty_to_str(ty, sess.intr()));\n             match f.region {\n                 Some(r) => {\n                     if cx.region_is_relevant(r) {\n@@ -692,12 +694,12 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                     cx.add_dep(did.node);\n                 }\n             } else {\n-                let cstore = cx.sess.cstore;\n+                let cstore = sess.cstore;\n                 match csearch::get_region_param(cstore, did) {\n                   None => {}\n                   Some(variance) => {\n                     debug!(\"reference to external, rp'd type %s\",\n-                           pprust::ty_to_str(ty, cx.sess.intr()));\n+                           pprust::ty_to_str(ty, sess.intr()));\n                     if cx.opt_region_is_relevant(path.rp) {\n                         cx.add_rp(cx.item_id, cx.add_variance(variance))\n                     }\n@@ -752,8 +754,9 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n       }\n     }\n \n-    fn visit_mt(mt: ast::mt, &&cx: determine_rp_ctxt,\n-                visitor: visit::vt<determine_rp_ctxt>) {\n+    fn visit_mt(mt: ast::mt,\n+                &&cx: @mut DetermineRpCtxt,\n+                visitor: visit::vt<@mut DetermineRpCtxt>) {\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n             do cx.with_ambient_variance(rv_invariant) {\n@@ -765,9 +768,10 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n }\n \n-pub fn determine_rp_in_struct_field(cm: @ast::struct_field,\n-                                    &&cx: determine_rp_ctxt,\n-                                    visitor: visit::vt<determine_rp_ctxt>) {\n+pub fn determine_rp_in_struct_field(\n+        cm: @ast::struct_field,\n+        &&cx: @mut DetermineRpCtxt,\n+        visitor: visit::vt<@mut DetermineRpCtxt>) {\n     match cm.node.kind {\n       ast::named_field(_, ast::struct_mutable, _) => {\n         do cx.with_ambient_variance(rv_invariant) {\n@@ -786,15 +790,17 @@ pub fn determine_rp_in_crate(sess: Session,\n                              def_map: resolve::DefMap,\n                              crate: @ast::crate)\n                           -> region_paramd_items {\n-    let cx = determine_rp_ctxt_(@{sess: sess,\n-                                  ast_map: ast_map,\n-                                  def_map: def_map,\n-                                  region_paramd_items: HashMap(),\n-                                  dep_map: HashMap(),\n-                                  worklist: DVec(),\n-                                  mut item_id: 0,\n-                                  mut anon_implies_rp: false,\n-                                  mut ambient_variance: rv_covariant});\n+    let cx = @mut DetermineRpCtxt {\n+        sess: sess,\n+        ast_map: ast_map,\n+        def_map: def_map,\n+        region_paramd_items: HashMap(),\n+        dep_map: HashMap(),\n+        worklist: ~[],\n+        item_id: 0,\n+        anon_implies_rp: false,\n+        ambient_variance: rv_covariant\n+    };\n \n     // Gather up the base set, worklist and dep_map\n     let visitor = visit::mk_vt(@visit::Visitor {\n@@ -833,7 +839,8 @@ pub fn determine_rp_in_crate(sess: Session,\n \n     debug!(\"%s\", {\n         debug!(\"Region variance results:\");\n-        for cx.region_paramd_items.each_ref |&key, &value| {\n+        let region_paramd_items = cx.region_paramd_items;\n+        for region_paramd_items.each_ref |&key, &value| {\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,"}, {"sha": "51df1d05d9e0ca86f21a0151a41ced2c177f2c8d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 96, "deletions": 90, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -145,7 +145,7 @@ pub enum NamespaceResult {\n     UnboundResult,\n     /// Means that resolve has determined that the name is bound in the Module\n     /// argument, and specified by the NameBindings argument.\n-    BoundResult(@Module, @NameBindings)\n+    BoundResult(@Module, @mut NameBindings)\n }\n \n pub impl NamespaceResult {\n@@ -364,10 +364,10 @@ pub fn ImportDirective(privacy: Privacy,\n /// The item that an import resolves to.\n pub struct Target {\n     target_module: @Module,\n-    bindings: @NameBindings,\n+    bindings: @mut NameBindings,\n }\n \n-pub fn Target(target_module: @Module, bindings: @NameBindings) -> Target {\n+pub fn Target(target_module: @Module, bindings: @mut NameBindings) -> Target {\n     Target {\n         target_module: target_module,\n         bindings: bindings\n@@ -385,18 +385,19 @@ pub struct ImportResolution {\n     // zero, outside modules can count on the targets being correct. Before\n     // then, all bets are off; future imports could override this name.\n \n-    mut outstanding_references: uint,\n+    outstanding_references: uint,\n \n     /// The value that this `use` directive names, if there is one.\n-    mut value_target: Option<Target>,\n+    value_target: Option<Target>,\n     /// The type that this `use` directive names, if there is one.\n-    mut type_target: Option<Target>,\n+    type_target: Option<Target>,\n \n     /// There exists one state per import statement\n     state: @mut ImportState,\n }\n \n-pub fn ImportResolution(privacy: Privacy, span: span,\n+pub fn ImportResolution(privacy: Privacy,\n+                        +span: span,\n                         state: @mut ImportState) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n@@ -447,7 +448,7 @@ pub struct Module {\n     mut def_id: Option<def_id>,\n     kind: ModuleKind,\n \n-    children: HashMap<ident,@NameBindings>,\n+    children: HashMap<ident,@mut NameBindings>,\n     imports: DVec<@ImportDirective>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n@@ -476,7 +477,7 @@ pub struct Module {\n     exported_names: HashMap<ident,node_id>,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: HashMap<ident,@ImportResolution>,\n+    import_resolutions: HashMap<ident,@mut ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     mut glob_count: uint,\n@@ -521,9 +522,9 @@ pub fn unused_import_lint_level(session: Session) -> level {\n \n // Records a possibly-private type definition.\n pub struct TypeNsDef {\n-    mut privacy: Privacy,\n-    mut module_def: Option<@Module>,\n-    mut type_def: Option<def>\n+    privacy: Privacy,\n+    module_def: Option<@Module>,\n+    type_def: Option<def>\n }\n \n // Records a possibly-private value definition.\n@@ -535,18 +536,19 @@ pub struct ValueNsDef {\n // Records the definitions (at most one for each namespace) that a name is\n // bound to.\n pub struct NameBindings {\n-    mut type_def: Option<TypeNsDef>,    //< Meaning in type namespace.\n-    mut value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n+    type_def: Option<TypeNsDef>,    //< Meaning in type namespace.\n+    value_def: Option<ValueNsDef>,  //< Meaning in value namespace.\n \n     // For error reporting\n     // FIXME (#3783): Merge me into TypeNsDef and ValueNsDef.\n-    mut type_span: Option<span>,\n-    mut value_span: Option<span>,\n+    type_span: Option<span>,\n+    value_span: Option<span>,\n }\n \n pub impl NameBindings {\n     /// Creates a new module in this set of name bindings.\n-    fn define_module(privacy: Privacy,\n+    fn define_module(@mut self,\n+                     privacy: Privacy,\n                      parent_link: ParentLink,\n                      def_id: Option<def_id>,\n                      kind: ModuleKind,\n@@ -573,7 +575,7 @@ pub impl NameBindings {\n     }\n \n     /// Records a type definition.\n-    fn define_type(privacy: Privacy, def: def, sp: span) {\n+    fn define_type(@mut self, privacy: Privacy, def: def, sp: span) {\n         // Merges the type with the existing type def or creates a new one.\n         match self.type_def {\n             None => {\n@@ -595,7 +597,7 @@ pub impl NameBindings {\n     }\n \n     /// Records a value definition.\n-    fn define_value(privacy: Privacy, def: def, sp: span) {\n+    fn define_value(@mut self, privacy: Privacy, def: def, sp: span) {\n         self.value_def = Some(ValueNsDef { privacy: privacy, def: def });\n         self.value_span = Some(sp);\n     }\n@@ -612,7 +614,7 @@ pub impl NameBindings {\n      * Returns the module node. Fails if this node does not have a module\n      * definition.\n      */\n-    fn get_module() -> @Module {\n+    fn get_module(@mut self) -> @Module {\n         match self.get_module_if_available() {\n             None => {\n                 die!(~\"get_module called on a node with no module \\\n@@ -750,15 +752,15 @@ pub fn Resolver(session: Session,\n                 lang_items: LanguageItems,\n                 crate: @crate)\n              -> Resolver {\n-    let graph_root = @NameBindings();\n+    let graph_root = @mut NameBindings();\n \n-    (*graph_root).define_module(Public,\n-                                NoParentLink,\n-                                Some(def_id { crate: 0, node: 0 }),\n-                                NormalModuleKind,\n-                                crate.span);\n+    graph_root.define_module(Public,\n+                             NoParentLink,\n+                             Some(def_id { crate: 0, node: 0 }),\n+                             NormalModuleKind,\n+                             crate.span);\n \n-    let current_module = (*graph_root).get_module();\n+    let current_module = graph_root.get_module();\n \n     let self = Resolver {\n         session: session,\n@@ -814,7 +816,7 @@ pub struct Resolver {\n \n     intr: @ident_interner,\n \n-    graph_root: @NameBindings,\n+    graph_root: @mut NameBindings,\n \n     unused_import_lint_level: level,\n \n@@ -894,7 +896,7 @@ pub impl Resolver {\n     /// Constructs the reduced graph for the entire crate.\n     fn build_reduced_graph(this: @Resolver) {\n         let initial_parent =\n-            ModuleReducedGraphParent((*self.graph_root).get_module());\n+            ModuleReducedGraphParent(self.graph_root.get_module());\n         visit_crate(*self.crate, initial_parent, mk_vt(@Visitor {\n             visit_item: |item, context, visitor|\n                 (*this).build_reduced_graph_for_item(item, context, visitor),\n@@ -943,7 +945,7 @@ pub impl Resolver {\n                  duplicate_checking_mode: DuplicateCheckingMode,\n                  // For printing errors\n                  sp: span)\n-              -> (@NameBindings, ReducedGraphParent) {\n+              -> (@mut NameBindings, ReducedGraphParent) {\n \n         // If this is the immediate descendant of a module, then we add the\n         // child name directly. Otherwise, we create or reuse an anonymous\n@@ -960,7 +962,7 @@ pub impl Resolver {\n         let new_parent = ModuleReducedGraphParent(module_);\n         match module_.children.find(&name) {\n             None => {\n-                let child = @NameBindings();\n+                let child = @mut NameBindings();\n                 module_.children.insert(name, child);\n                 return (child, new_parent);\n             }\n@@ -1080,14 +1082,14 @@ pub impl Resolver {\n \n                 let parent_link = self.get_parent_link(new_parent, ident);\n                 let def_id = def_id { crate: 0, node: item.id };\n-                (*name_bindings).define_module(privacy,\n-                                               parent_link,\n-                                               Some(def_id),\n-                                               NormalModuleKind,\n-                                               sp);\n+                name_bindings.define_module(privacy,\n+                                            parent_link,\n+                                            Some(def_id),\n+                                            NormalModuleKind,\n+                                            sp);\n \n                 let new_parent =\n-                    ModuleReducedGraphParent((*name_bindings).get_module());\n+                    ModuleReducedGraphParent(name_bindings.get_module());\n \n                 visit_mod(module_, sp, item.id, new_parent, visitor);\n             }\n@@ -1102,11 +1104,11 @@ pub impl Resolver {\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                ident);\n                         let def_id = def_id { crate: 0, node: item.id };\n-                        (*name_bindings).define_module(privacy,\n-                                                       parent_link,\n-                                                       Some(def_id),\n-                                                       ExternModuleKind,\n-                                                       sp);\n+                        name_bindings.define_module(privacy,\n+                                                    parent_link,\n+                                                    Some(def_id),\n+                                                    ExternModuleKind,\n+                                                    sp);\n \n                         ModuleReducedGraphParent(name_bindings.get_module())\n                     }\n@@ -1124,15 +1126,15 @@ pub impl Resolver {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n-                (*name_bindings).define_value\n+                name_bindings.define_value\n                     (privacy, def_const(local_def(item.id)), sp);\n             }\n             item_fn(_, purity, _, _) => {\n               let (name_bindings, new_parent) =\n                 self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n                 let def = def_fn(local_def(item.id), purity);\n-                (*name_bindings).define_value(privacy, def, sp);\n+                name_bindings.define_value(privacy, def, sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -1141,15 +1143,15 @@ pub impl Resolver {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n-                (*name_bindings).define_type\n+                name_bindings.define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n             }\n \n             item_enum(ref enum_definition, _) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n-                (*name_bindings).define_type\n+                name_bindings.define_type\n                     (privacy, def_ty(local_def(item.id)), sp);\n \n                 for (*enum_definition).variants.each |variant| {\n@@ -1329,10 +1331,7 @@ pub impl Resolver {\n                 let def_id = local_def(item.id);\n                 self.trait_info.insert(def_id, method_names);\n \n-                (*name_bindings).define_type\n-                    (privacy,\n-                     def_ty(def_id),\n-                     sp);\n+                name_bindings.define_type(privacy, def_ty(def_id), sp);\n                 visit_item(item, new_parent, visitor);\n             }\n \n@@ -1363,22 +1362,22 @@ pub impl Resolver {\n \n         match variant.node.kind {\n             tuple_variant_kind(_) => {\n-                (*child).define_value(privacy,\n-                                      def_variant(item_id,\n-                                                  local_def(variant.node.id)),\n-                                      variant.span);\n+                child.define_value(privacy,\n+                                   def_variant(item_id,\n+                                               local_def(variant.node.id)),\n+                                   variant.span);\n             }\n             struct_variant_kind(_) => {\n-                (*child).define_type(privacy,\n-                                     def_variant(item_id,\n-                                                 local_def(variant.node.id)),\n-                                     variant.span);\n+                child.define_type(privacy,\n+                                  def_variant(item_id,\n+                                              local_def(variant.node.id)),\n+                                  variant.span);\n                 self.structs.insert(local_def(variant.node.id), ());\n             }\n             enum_variant_kind(ref enum_definition) => {\n-                (*child).define_type(privacy,\n-                                     def_ty(local_def(variant.node.id)),\n-                                     variant.span);\n+                child.define_type(privacy,\n+                                  def_ty(local_def(variant.node.id)),\n+                                  variant.span);\n                 for (*enum_definition).variants.each |variant| {\n                     self.build_reduced_graph_for_variant(*variant, item_id,\n                                                          parent_privacy,\n@@ -1488,7 +1487,7 @@ pub impl Resolver {\n                                                           NormalModuleKind,\n                                                           view_item.span);\n                         self.build_reduced_graph_for_external_crate\n-                            ((*child_name_bindings).get_module());\n+                            (child_name_bindings.get_module());\n                     }\n                     None => {\n                         /* Ignore. */\n@@ -1512,7 +1511,7 @@ pub impl Resolver {\n         match /*bad*/copy foreign_item.node {\n             foreign_item_fn(_, _, type_parameters) => {\n                 let def = def_fn(local_def(foreign_item.id), unsafe_fn);\n-                (*name_bindings).define_value(Public, def, foreign_item.span);\n+                name_bindings.define_value(Public, def, foreign_item.span);\n \n                 do self.with_type_parameter_rib\n                         (HasTypeParameters(&type_parameters, foreign_item.id,\n@@ -1522,7 +1521,7 @@ pub impl Resolver {\n             }\n             foreign_item_const(*) => {\n                 let def = def_const(local_def(foreign_item.id));\n-                (*name_bindings).define_value(Public, def, foreign_item.span);\n+                name_bindings.define_value(Public, def, foreign_item.span);\n \n                 visit_foreign_item(foreign_item, new_parent, visitor);\n             }\n@@ -1554,10 +1553,12 @@ pub impl Resolver {\n         visit_block(block, new_parent, visitor);\n     }\n \n-    fn handle_external_def(def: def, modules: HashMap<def_id, @Module>,\n-                           child_name_bindings: @NameBindings,\n+    fn handle_external_def(def: def,\n+                           modules: HashMap<def_id, @Module>,\n+                           child_name_bindings: @mut NameBindings,\n                            final_ident: ~str,\n-                           ident: ident, new_parent: ReducedGraphParent) {\n+                           ident: ident,\n+                           new_parent: ReducedGraphParent) {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n             match copy child_name_bindings.type_def {\n@@ -1588,8 +1589,10 @@ pub impl Resolver {\n                     // avoid creating cycles in the\n                     // module graph.\n \n-                    let resolution = @ImportResolution(Public, dummy_sp(),\n-                                                       @mut ImportState());\n+                    let resolution =\n+                        @mut ImportResolution(Public,\n+                                              dummy_sp(),\n+                                              @mut ImportState());\n                     resolution.outstanding_references = 0;\n \n                     match existing_module.parent_link {\n@@ -1618,7 +1621,7 @@ pub impl Resolver {\n           def_variant(*) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value %s\", final_ident);\n-            (*child_name_bindings).define_value(Public, def, dummy_sp());\n+            child_name_bindings.define_value(Public, def, dummy_sp());\n           }\n           def_ty(def_id) => {\n             debug!(\"(building reduced graph for external \\\n@@ -1729,7 +1732,7 @@ pub impl Resolver {\n                     _ => {} // Fall through.\n                 }\n \n-                current_module = (*child_name_bindings).get_module();\n+                current_module = child_name_bindings.get_module();\n             }\n \n             match def_like {\n@@ -1867,8 +1870,9 @@ pub impl Resolver {\n                     }\n                     None => {\n                         debug!(\"(building import directive) creating new\");\n-                        let resolution = @ImportResolution(privacy, span,\n-                                                           state);\n+                        let resolution = @mut ImportResolution(privacy,\n+                                                               span,\n+                                                               state);\n                         let name = self.idents_to_str(module_path.get());\n                         // Don't warn about unused intrinsics because they're\n                         // automatically appended to all files\n@@ -1910,7 +1914,7 @@ pub impl Resolver {\n             debug!(\"(resolving imports) iteration %u, %u imports left\",\n                    i, self.unresolved_imports);\n \n-            let module_root = (*self.graph_root).get_module();\n+            let module_root = self.graph_root.get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n             if self.unresolved_imports == 0 {\n@@ -2191,7 +2195,8 @@ pub impl Resolver {\n                             if import_resolution.outstanding_references\n                                 == 0 => {\n \n-                        fn get_binding(import_resolution: @ImportResolution,\n+                        fn get_binding(import_resolution:\n+                                          @mut ImportResolution,\n                                        namespace: Namespace)\n                                     -> NamespaceResult {\n \n@@ -2469,9 +2474,9 @@ pub impl Resolver {\n                 None => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n-                        @ImportResolution(privacy,\n-                                          target_import_resolution.span,\n-                                          state);\n+                        @mut ImportResolution(privacy,\n+                                              target_import_resolution.span,\n+                                              state);\n                     new_import_resolution.value_target =\n                         copy target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n@@ -2512,8 +2517,9 @@ pub impl Resolver {\n             match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @ImportResolution(privacy, span,\n-                                                               state);\n+                    dest_import_resolution = @mut ImportResolution(privacy,\n+                                                                   span,\n+                                                                   state);\n                     module_.import_resolutions.insert\n                         (ident, dest_import_resolution);\n                 }\n@@ -3202,7 +3208,7 @@ pub impl Resolver {\n     // processing.\n \n     fn record_exports() {\n-        let root_module = (*self.graph_root).get_module();\n+        let root_module = self.graph_root.get_module();\n         self.record_exports_for_module_subtree(root_module);\n     }\n \n@@ -3265,7 +3271,7 @@ pub impl Resolver {\n \n     fn add_exports_of_namebindings(exports2: &mut ~[Export2],\n                                    ident: ident,\n-                                   namebindings: @NameBindings,\n+                                   namebindings: @mut NameBindings,\n                                    ns: Namespace,\n                                    reexport: bool) {\n         match (namebindings.def_for_namespace(ns),\n@@ -3721,7 +3727,7 @@ pub impl Resolver {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 // FIXME #4404 android JNI hacks\n-                if !self.session.building_library ||\n+                if !*self.session.building_library ||\n                     self.session.targ_cfg.os == session::os_android {\n \n                     if self.attr_main_fn.is_none() &&\n@@ -4673,7 +4679,7 @@ pub impl Resolver {\n \n         let module_path_idents = self.intern_module_part_of_path(path);\n \n-        let root_module = (*self.graph_root).get_module();\n+        let root_module = self.graph_root.get_module();\n \n         let mut containing_module;\n         match self.resolve_module_path_from_root(root_module,\n@@ -5172,10 +5178,10 @@ pub impl Resolver {\n                         ~\"multiple 'main' functions\");\n                     i += 1;\n                 }\n-                self.session.main_fn = self.main_fns[0];\n+                *self.session.main_fn = self.main_fns[0];\n             }\n         } else {\n-            self.session.main_fn = self.attr_main_fn;\n+            *self.session.main_fn = self.attr_main_fn;\n         }\n     }\n \n@@ -5191,7 +5197,7 @@ pub impl Resolver {\n             return;\n         }\n \n-        let root_module = (*self.graph_root).get_module();\n+        let root_module = self.graph_root.get_module();\n         self.check_for_unused_imports_in_module_subtree(root_module);\n     }\n \n@@ -5245,15 +5251,15 @@ pub impl Resolver {\n                 import_resolution.state.warned = true;\n                 match self.unused_import_lint_level {\n                     warn => {\n-                        self.session.span_warn(import_resolution.span,\n+                        self.session.span_warn(copy import_resolution.span,\n                                                ~\"unused import\");\n                     }\n                     deny | forbid => {\n-                      self.session.span_err(import_resolution.span,\n+                      self.session.span_err(copy import_resolution.span,\n                                             ~\"unused import\");\n                     }\n                     allow => {\n-                      self.session.span_bug(import_resolution.span,\n+                      self.session.span_bug(copy import_resolution.span,\n                                             ~\"shouldn't be here if lint \\\n                                               is allowed\");\n                     }"}, {"sha": "acf33434b2f8baa69e950a2a1d2dd96079d74a7d", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -370,7 +370,7 @@ pub fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n     get_tydesc(ccx, t).tydesc\n }\n \n-pub fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+pub fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @mut tydesc_info {\n     match ccx.tydescs.find(&t) {\n       Some(inf) => inf,\n       _ => {\n@@ -2159,15 +2159,15 @@ pub fn register_fn_fuller(ccx: @crate_ctxt,\n \n     // FIXME #4404 android JNI hacks\n     let is_main = is_main_fn(&ccx.sess, node_id) &&\n-                     (!ccx.sess.building_library ||\n-                      (ccx.sess.building_library &&\n+                     (!*ccx.sess.building_library ||\n+                      (*ccx.sess.building_library &&\n                        ccx.sess.targ_cfg.os == session::os_android));\n     if is_main { create_main_wrapper(ccx, sp, llfn); }\n     llfn\n }\n \n pub fn is_main_fn(sess: &Session, node_id: ast::node_id) -> bool {\n-    match sess.main_fn {\n+    match *sess.main_fn {\n         Some((main_id, _)) => node_id == main_id,\n         None => false\n     }\n@@ -2210,7 +2210,7 @@ pub fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n         let llfty = T_fn(~[ccx.int_type, ccx.int_type], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n-        let llfn = if ccx.sess.building_library {\n+        let llfn = if *ccx.sess.building_library {\n             decl_cdecl_fn(ccx.llmod, ~\"amain\", llfty)\n         } else {\n             decl_cdecl_fn(ccx.llmod, main_name(), llfty)\n@@ -2230,14 +2230,20 @@ pub fn create_main_wrapper(ccx: @crate_ctxt, _sp: span, main_llfn: ValueRef) {\n         let start = decl_cdecl_fn(ccx.llmod, ~\"rust_start\", start_ty);\n \n         let args = unsafe {\n-            if ccx.sess.building_library {\n-                ~[rust_main,\n-                  llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n-                  llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n-                  crate_map]\n+            if *ccx.sess.building_library {\n+                ~[\n+                    rust_main,\n+                    llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n+                    llvm::LLVMConstInt(T_i32(), 0u as c_ulonglong, False),\n+                    crate_map\n+                ]\n             } else {\n-                ~[rust_main, llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                  llvm::LLVMGetParam(llfn, 1 as c_uint), crate_map]\n+                ~[\n+                    rust_main,\n+                    llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                    llvm::LLVMGetParam(llfn, 1 as c_uint),\n+                    crate_map\n+                ]\n             }\n         };\n \n@@ -2815,10 +2821,12 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: link_meta,\n     let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n-    let mapname = if sess.building_library {\n+    let mapname = if *sess.building_library {\n         mapmeta.name.to_owned() + ~\"_\" + mapmeta.vers.to_owned() + ~\"_\"\n             + mapmeta.extras_hash.to_owned()\n-    } else { ~\"toplevel\" };\n+    } else {\n+        ~\"toplevel\"\n+    };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n     let maptype = T_struct(~[T_i32(), T_ptr(T_i8()), int_type, arrtype]);\n@@ -2891,7 +2899,7 @@ pub fn crate_ctxt_to_encode_parms(cx: @crate_ctxt) -> encoder::encode_parms {\n }\n \n pub fn write_metadata(cx: @crate_ctxt, crate: &ast::crate) {\n-    if !cx.sess.building_library { return; }\n+    if !*cx.sess.building_library { return; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n     let llconst = C_struct(~[llmeta]);\n@@ -3016,18 +3024,19 @@ pub fn trans_crate(sess: session::Session,\n               all_llvm_symbols: HashMap(),\n               tcx: tcx,\n               maps: maps,\n-              stats:\n-                  {mut n_static_tydescs: 0u,\n-                   mut n_glues_created: 0u,\n-                   mut n_null_glues: 0u,\n-                   mut n_real_glues: 0u,\n-                   mut n_fns: 0u,\n-                   mut n_monos: 0u,\n-                   mut n_inlines: 0u,\n-                   mut n_closures: 0u,\n-                   llvm_insn_ctxt: @mut ~[],\n-                   llvm_insns: HashMap(),\n-                   fn_times: @mut ~[]},\n+              stats: @mut Stats {\n+                n_static_tydescs: 0u,\n+                n_glues_created: 0u,\n+                n_null_glues: 0u,\n+                n_real_glues: 0u,\n+                n_fns: 0u,\n+                n_monos: 0u,\n+                n_inlines: 0u,\n+                n_closures: 0u,\n+                llvm_insn_ctxt: @mut ~[],\n+                llvm_insns: HashMap(),\n+                fn_times: @mut ~[]\n+              },\n               upcalls: upcall::declare_upcalls(targ_cfg, llmod),\n               tydesc_type: tydesc_type,\n               int_type: int_type,"}, {"sha": "08bab21daaf92617f60ccf3ad057b425f3561692", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -391,20 +391,20 @@ pub fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n }\n \n pub fn body_contains_ret(body: ast::blk) -> bool {\n-    let cx = {mut found: false};\n+    let cx = @mut false;\n     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_item: |_i, _cx, _v| { },\n-        visit_expr: |e: @ast::expr, cx: {mut found: bool}, v| {\n-            if !cx.found {\n+        visit_expr: |e: @ast::expr, cx: @mut bool, v| {\n+            if !*cx {\n                 match e.node {\n-                  ast::expr_ret(_) => cx.found = true,\n+                  ast::expr_ret(_) => *cx = true,\n                   _ => visit::visit_expr(e, cx, v),\n                 }\n             }\n         },\n         ..*visit::default_visitor()\n     }));\n-    cx.found\n+    *cx\n }\n \n // See [Note-arg-mode]"}, {"sha": "03a91fa15fa08a22b7a1c25b0394cfc7dd537efe", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -87,16 +87,17 @@ pub fn new_addrspace_gen() -> addrspace_gen {\n     return fn@() -> addrspace { *i += 1; *i };\n }\n \n-pub type tydesc_info =\n-    {ty: ty::t,\n-     tydesc: ValueRef,\n-     size: ValueRef,\n-     align: ValueRef,\n-     addrspace: addrspace,\n-     mut take_glue: Option<ValueRef>,\n-     mut drop_glue: Option<ValueRef>,\n-     mut free_glue: Option<ValueRef>,\n-     mut visit_glue: Option<ValueRef>};\n+pub struct tydesc_info {\n+    ty: ty::t,\n+    tydesc: ValueRef,\n+    size: ValueRef,\n+    align: ValueRef,\n+    addrspace: addrspace,\n+    take_glue: Option<ValueRef>,\n+    drop_glue: Option<ValueRef>,\n+    free_glue: Option<ValueRef>,\n+    visit_glue: Option<ValueRef>\n+}\n \n /*\n  * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n@@ -124,18 +125,19 @@ pub type tydesc_info =\n  *\n  */\n \n-pub type stats =\n-    {mut n_static_tydescs: uint,\n-     mut n_glues_created: uint,\n-     mut n_null_glues: uint,\n-     mut n_real_glues: uint,\n-     mut n_fns: uint,\n-     mut n_monos: uint,\n-     mut n_inlines: uint,\n-     mut n_closures: uint,\n-     llvm_insn_ctxt: @mut ~[~str],\n-     llvm_insns: HashMap<~str, uint>,\n-     fn_times: @mut ~[{ident: ~str, time: int}]};\n+pub struct Stats {\n+    n_static_tydescs: uint,\n+    n_glues_created: uint,\n+    n_null_glues: uint,\n+    n_real_glues: uint,\n+    n_fns: uint,\n+    n_monos: uint,\n+    n_inlines: uint,\n+    n_closures: uint,\n+    llvm_insn_ctxt: @mut ~[~str],\n+    llvm_insns: HashMap<~str, uint>,\n+    fn_times: @mut ~[{ident: ~str, time: int}]\n+}\n \n pub struct BuilderRef_res {\n     B: BuilderRef,\n@@ -170,7 +172,7 @@ pub struct crate_ctxt {\n      enum_sizes: HashMap<ty::t, uint>,\n      discrims: HashMap<ast::def_id, ValueRef>,\n      discrim_symbols: HashMap<ast::node_id, ~str>,\n-     tydescs: HashMap<ty::t, @tydesc_info>,\n+     tydescs: HashMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n      mut finished_tydescs: bool,\n@@ -208,15 +210,15 @@ pub struct crate_ctxt {\n      all_llvm_symbols: Set<~str>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n-     stats: stats,\n+     stats: @mut Stats,\n      upcalls: @upcall::upcalls,\n      tydesc_type: TypeRef,\n      int_type: TypeRef,\n      float_type: TypeRef,\n      task_type: TypeRef,\n      opaque_vec_type: TypeRef,\n      builder: BuilderRef_res,\n-     shape_cx: shape::ctxt,\n+     shape_cx: shape::Ctxt,\n      crate_map: ValueRef,\n      // Set when at least one function uses GC. Needed so that\n      // decl_gc_metadata knows whether to link to the module metadata, which"}, {"sha": "8556bee7e8473bb4927f4f4f85ae7a5deaba2805", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -367,16 +367,16 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n     return mdval;\n }\n \n-type struct_ctxt = {\n+struct StructCtxt {\n     file: ValueRef,\n     name: ~str,\n     line: int,\n-    mut members: ~[ValueRef],\n-    mut total_size: int,\n+    members: ~[ValueRef],\n+    total_size: int,\n     align: int\n-};\n+}\n \n-fn finish_structure(cx: @struct_ctxt) -> ValueRef {\n+fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n     return create_composite_type(StructureTypeTag,\n                                  /*bad*/copy cx.name,\n                                  cx.file,\n@@ -389,14 +389,15 @@ fn finish_structure(cx: @struct_ctxt) -> ValueRef {\n }\n \n fn create_structure(file: @metadata<file_md>, +name: ~str, line: int)\n-    -> @struct_ctxt {\n-    let cx = @{file: file.node,\n-               name: name,\n-               line: line,\n-               mut members: ~[],\n-               mut total_size: 0,\n-               align: 64 //XXX different alignment per arch?\n-              };\n+                 -> @mut StructCtxt {\n+    let cx = @mut StructCtxt {\n+        file: file.node,\n+        name: name,\n+        line: line,\n+        members: ~[],\n+        total_size: 0,\n+        align: 64 //XXX different alignment per arch?\n+    };\n     return cx;\n }\n \n@@ -416,7 +417,11 @@ fn create_derived_type(type_tag: int, file: ValueRef, +name: ~str, line: int,\n     return llmdnode(lldata);\n }\n \n-fn add_member(cx: @struct_ctxt, +name: ~str, line: int, size: int, align: int,\n+fn add_member(cx: @mut StructCtxt,\n+              +name: ~str,\n+              line: int,\n+              size: int,\n+              align: int,\n               ty: ValueRef) {\n     cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n                                        size * 8, align * 8, cx.total_size,"}, {"sha": "3cbc575b7c11cd82a330af1419f456047eb2c6c6", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -143,7 +143,7 @@ pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n pub fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n-                                   static_ti: @tydesc_info) {\n+                                   static_ti: @mut tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n@@ -204,7 +204,7 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     return t;\n }\n \n-pub pure fn cast_glue(ccx: @crate_ctxt, ti: @tydesc_info, v: ValueRef)\n+pub pure fn cast_glue(ccx: @crate_ctxt, ti: @mut tydesc_info, v: ValueRef)\n                    -> ValueRef {\n     unsafe {\n         let llfnty = type_of_glue_fn(ccx, ti.ty);\n@@ -214,7 +214,7 @@ pub pure fn cast_glue(ccx: @crate_ctxt, ti: @tydesc_info, v: ValueRef)\n \n pub fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt,\n                                           field: uint,\n-                                          ti: @tydesc_info) -> bool {\n+                                          ti: @mut tydesc_info) -> bool {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n@@ -241,7 +241,7 @@ pub fn lazily_emit_simplified_tydesc_glue(ccx: @crate_ctxt,\n \n pub fn lazily_emit_tydesc_glue(ccx: @crate_ctxt,\n                                field: uint,\n-                               ti: @tydesc_info) {\n+                               ti: @mut tydesc_info) {\n     let _icx = ccx.insn_ctxt(\"lazily_emit_tydesc_glue\");\n     let llfnty = type_of_glue_fn(ccx, ti.ty);\n \n@@ -305,8 +305,11 @@ pub fn lazily_emit_tydesc_glue(ccx: @crate_ctxt,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n-                             field: uint, static_ti: Option<@tydesc_info>) {\n+pub fn call_tydesc_glue_full(++bcx: block,\n+                             v: ValueRef,\n+                             tydesc: ValueRef,\n+                             field: uint,\n+                             static_ti: Option<@mut tydesc_info>) {\n     let _icx = bcx.insn_ctxt(\"call_tydesc_glue_full\");\n     let ccx = bcx.ccx();\n     // NB: Don't short-circuit even if this block is unreachable because\n@@ -647,7 +650,7 @@ pub fn declare_tydesc_addrspace(ccx: @crate_ctxt, t: ty::t) -> addrspace {\n }\n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-pub fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n+pub fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @mut tydesc_info {\n     let _icx = ccx.insn_ctxt(\"declare_tydesc\");\n     // If emit_tydescs already ran, then we shouldn't be creating any new\n     // tydescs.\n@@ -678,16 +681,17 @@ pub fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n         }\n     });\n-    let inf =\n-        @{ty: t,\n-          tydesc: gvar,\n-          size: llsize,\n-          align: llalign,\n-          addrspace: addrspace,\n-          mut take_glue: None,\n-          mut drop_glue: None,\n-          mut free_glue: None,\n-          mut visit_glue: None};\n+    let inf = @mut tydesc_info {\n+        ty: t,\n+        tydesc: gvar,\n+        size: llsize,\n+        align: llalign,\n+        addrspace: addrspace,\n+        take_glue: None,\n+        drop_glue: None,\n+        free_glue: None,\n+        visit_glue: None\n+    };\n     log(debug, ~\"--- declare_tydesc \" + ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }"}, {"sha": "3cd6a5d18364a63d0fe6fbd58e9511cc39af0582", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -28,25 +28,24 @@ use std::oldmap::HashMap;\n use syntax::ast::def_id;\n use syntax::ast;\n \n-pub enum reflector = {\n+pub struct Reflector {\n     visitor_val: ValueRef,\n     visitor_methods: @~[ty::method],\n     final_bcx: block,\n     tydesc_ty: TypeRef,\n-    mut bcx: block\n-};\n-\n-pub impl reflector {\n+    bcx: block\n+}\n \n-    fn c_uint(u: uint) -> ValueRef {\n+pub impl Reflector {\n+    fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n \n-    fn c_int(i: int) -> ValueRef {\n+    fn c_int(&mut self, i: int) -> ValueRef {\n         C_int(self.bcx.ccx(), i)\n     }\n \n-    fn c_slice(+s: ~str) -> ValueRef {\n+    fn c_slice(&mut self, +s: ~str) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n@@ -60,27 +59,27 @@ pub impl reflector {\n         scratch.val\n     }\n \n-    fn c_size_and_align(t: ty::t) -> ~[ValueRef] {\n+    fn c_size_and_align(&mut self, t: ty::t) -> ~[ValueRef] {\n         let tr = type_of::type_of(self.bcx.ccx(), t);\n         let s = machine::llsize_of_real(self.bcx.ccx(), tr);\n         let a = machine::llalign_of_min(self.bcx.ccx(), tr);\n         return ~[self.c_uint(s),\n              self.c_uint(a)];\n     }\n \n-    fn c_tydesc(t: ty::t) -> ValueRef {\n+    fn c_tydesc(&mut self, t: ty::t) -> ValueRef {\n         let bcx = self.bcx;\n         let static_ti = get_tydesc(bcx.ccx(), t);\n         glue::lazily_emit_all_tydesc_glue(bcx.ccx(), static_ti);\n         PointerCast(bcx, static_ti.tydesc, T_ptr(self.tydesc_ty))\n     }\n \n-    fn c_mt(mt: ty::mt) -> ~[ValueRef] {\n+    fn c_mt(&mut self, mt: ty::mt) -> ~[ValueRef] {\n         ~[self.c_uint(mt.mutbl as uint),\n           self.c_tydesc(mt.ty)]\n     }\n \n-    fn visit(ty_name: ~str, args: ~[ValueRef]) {\n+    fn visit(&mut self, ty_name: ~str, args: ~[ValueRef]) {\n         let tcx = self.bcx.tcx();\n         let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n@@ -114,15 +113,18 @@ pub impl reflector {\n         self.bcx = next_bcx\n     }\n \n-    fn bracketed(bracket_name: ~str, +extra: ~[ValueRef],\n-                 inner: fn()) {\n+    fn bracketed(&mut self,\n+                 bracket_name: ~str,\n+                 +extra: ~[ValueRef],\n+                 inner: &fn()) {\n         // XXX: Bad copy.\n         self.visit(~\"enter_\" + bracket_name, copy extra);\n         inner();\n         self.visit(~\"leave_\" + bracket_name, extra);\n     }\n \n-    fn vstore_name_and_extra(t: ty::t,\n+    fn vstore_name_and_extra(&mut self,\n+                             t: ty::t,\n                              vstore: ty::vstore,\n                              f: fn(+s: ~str,+v: ~[ValueRef])) {\n         match vstore {\n@@ -137,13 +139,12 @@ pub impl reflector {\n         }\n     }\n \n-    fn leaf(+name: ~str) {\n+    fn leaf(&mut self, +name: ~str) {\n         self.visit(name, ~[]);\n     }\n \n     // Entrypoint\n-    fn visit_ty(t: ty::t) {\n-\n+    fn visit_ty(&mut self, t: ty::t) {\n         let bcx = self.bcx;\n         debug!(\"reflect::visit_ty %s\",\n                ty_to_str(bcx.ccx().tcx, t));\n@@ -301,7 +302,7 @@ pub impl reflector {\n         }\n     }\n \n-    fn visit_sig(&self, retval: uint, sig: &ty::FnSig) {\n+    fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n         for sig.inputs.eachi |i, arg| {\n             let modeval = match arg.mode {\n                 ast::infer(_) => 0u,\n@@ -333,13 +334,13 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&tydesc);\n     let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n     let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n-    let r = reflector({\n+    let mut r = Reflector {\n         visitor_val: visitor_val,\n         visitor_methods: ty::trait_methods(bcx.tcx(), visitor_trait_id),\n         final_bcx: final,\n         tydesc_ty: tydesc_ty,\n-        mut bcx: bcx\n-    });\n+        bcx: bcx\n+    };\n     r.visit_ty(t);\n     Br(r.bcx, final.llbb);\n     return final;"}, {"sha": "0a64d5c637e4e375382d046c1ef9992dece0b483", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -34,7 +34,11 @@ use syntax::util::interner;\n \n use ty_ctxt = middle::ty::ctxt;\n \n-pub type ctxt = {mut next_tag_id: u16, pad: u16, pad2: u32};\n+pub struct Ctxt {\n+    next_tag_id: u16,\n+    pad: u16,\n+    pad2: u32\n+}\n \n pub fn mk_global(ccx: @crate_ctxt,\n                  name: ~str,\n@@ -57,14 +61,18 @@ pub fn mk_global(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn mk_ctxt(llmod: ModuleRef) -> ctxt {\n+pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n     unsafe {\n         let llshapetablesty = trans::common::T_named_struct(~\"shapes\");\n         let _llshapetables = str::as_c_str(~\"shapes\", |buf| {\n             llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n         });\n \n-        return {mut next_tag_id: 0u16, pad: 0u16, pad2: 0u32};\n+        return Ctxt {\n+            next_tag_id: 0u16,\n+            pad: 0u16,\n+            pad2: 0u32\n+        };\n     }\n }\n "}, {"sha": "6455c5da98d358f335f3d44136d16fa3f96e4cb2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -232,7 +232,7 @@ struct ctxt_ {\n     vecs_implicitly_copyable: bool,\n     legacy_modes: bool,\n     legacy_records: bool,\n-    cstore: metadata::cstore::CStore,\n+    cstore: @mut metadata::cstore::CStore,\n     sess: session::Session,\n     def_map: resolve::DefMap,\n "}, {"sha": "8cd5be85a1a4a015ee2f03d182d83be61cab6955", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 60, "deletions": 52, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -11,16 +11,16 @@\n /*!\n  * Conversion from AST representation of types to the ty.rs\n  * representation.  The main routine here is `ast_ty_to_ty()`: each use\n- * is parameterized by an instance of `ast_conv` and a `region_scope`.\n+ * is parameterized by an instance of `AstConv` and a `region_scope`.\n  *\n  * The parameterization of `ast_ty_to_ty()` is because it behaves\n  * somewhat differently during the collect and check phases, particularly\n  * with respect to looking up the types of top-level items.  In the\n- * collect phase, the crate context is used as the `ast_conv` instance;\n+ * collect phase, the crate context is used as the `AstConv` instance;\n  * in this phase, the `get_item_ty()` function triggers a recursive call\n  * to `ty_of_item()` (note that `ast_ty_to_ty()` will detect recursive\n- * types and report an error).  In the check phase, when the @fn_ctxt is\n- * used as the `ast_conv`, `get_item_ty()` just looks up the item type in\n+ * types and report an error).  In the check phase, when the @FnCtxt is\n+ * used as the `AstConv`, `get_item_ty()` just looks up the item type in\n  * `tcx.tcache`.\n  *\n  * The `region_scope` trait controls how region references are\n@@ -31,7 +31,7 @@\n  * region, or `type_rscope`, which permits the self region if the type in\n  * question is parameterized by a region.\n  *\n- * Unlike the `ast_conv` trait, the region scope can change as we descend\n+ * Unlike the `AstConv` trait, the region scope can change as we descend\n  * the type.  This is to accommodate the fact that (a) fn types are binding\n  * scopes and (b) the default region may change.  To understand case (a),\n  * consider something like:\n@@ -58,12 +58,11 @@ use middle::pat_util::pat_id_map;\n use middle::ty::{arg, field, substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::check::fn_ctxt;\n use middle::typeck::collect;\n use middle::typeck::rscope::{anon_rscope, binding_rscope, empty_rscope};\n use middle::typeck::rscope::{in_anon_rscope, in_binding_rscope};\n use middle::typeck::rscope::{region_scope, type_rscope};\n-use middle::typeck::{crate_ctxt, write_substs_to_tcx, write_ty_to_tcx};\n+use middle::typeck::{CrateCtxt, write_substs_to_tcx, write_ty_to_tcx};\n \n use core::result;\n use core::vec;\n@@ -72,13 +71,13 @@ use syntax::codemap::span;\n use syntax::print::pprust::path_to_str;\n use util::common::indenter;\n \n-pub trait ast_conv {\n-    fn tcx() -> ty::ctxt;\n-    fn ccx() -> @crate_ctxt;\n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+pub trait AstConv {\n+    fn tcx(@mut self) -> ty::ctxt;\n+    fn ccx(@mut self) -> @mut CrateCtxt;\n+    fn get_item_ty(@mut self, id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n \n     // what type should we use when a type is omitted?\n-    fn ty_infer(span: span) -> ty::t;\n+    fn ty_infer(@mut self, span: span) -> ty::t;\n }\n \n pub fn get_region_reporting_err(tcx: ty::ctxt,\n@@ -95,9 +94,12 @@ pub fn get_region_reporting_err(tcx: ty::ctxt,\n     }\n }\n \n-pub fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC, rscope: RS, span: span, a_r: @ast::region) -> ty::Region {\n-\n+pub fn ast_region_to_region<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n+        rscope: RS,\n+        span: span,\n+        a_r: @ast::region)\n+     -> ty::Region {\n     let res = match a_r.node {\n         ast::re_static => Ok(ty::re_static),\n         ast::re_anon => rscope.anon_region(span),\n@@ -108,10 +110,12 @@ pub fn ast_region_to_region<AC: ast_conv, RS: region_scope Copy Durable>(\n     get_region_reporting_err(self.tcx(), span, res)\n }\n \n-pub fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC, rscope: RS, did: ast::def_id,\n-    path: @ast::path) -> ty_param_substs_and_ty {\n-\n+pub fn ast_path_to_substs_and_ty<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n+        rscope: RS,\n+        did: ast::def_id,\n+        path: @ast::path)\n+     -> ty_param_substs_and_ty {\n     let tcx = self.tcx();\n     let {bounds: decl_bounds, region_param: decl_rp, ty: decl_ty} =\n         self.get_item_ty(did);\n@@ -158,13 +162,13 @@ pub fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     {substs: substs, ty: ty}\n }\n \n-pub fn ast_path_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC,\n-    rscope: RS,\n-    did: ast::def_id,\n-    path: @ast::path,\n-    path_id: ast::node_id) -> ty_param_substs_and_ty {\n-\n+pub fn ast_path_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n+        rscope: RS,\n+        did: ast::def_id,\n+        path: @ast::path,\n+        path_id: ast::node_id)\n+     -> ty_param_substs_and_ty {\n     // Look up the polytype of the item and then substitute the provided types\n     // for any type/region parameters.\n     let tcx = self.tcx();\n@@ -181,20 +185,20 @@ pub const NO_TPS: uint = 2;\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC, rscope: RS, &&ast_ty: @ast::Ty) -> ty::t {\n+pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n+    self: @mut AC, rscope: RS, &&ast_ty: @ast::Ty) -> ty::t {\n \n-    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope Copy Durable>(\n-        self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n+    fn ast_mt_to_mt<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC, rscope: RS, mt: ast::mt) -> ty::mt {\n \n         ty::mt {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n     // Handle @, ~, and & being able to mean estrs and evecs.\n     // If a_seq_ty is a str or a vec, make it an estr/evec.\n     // Also handle function sigils and first-class trait types.\n-    fn mk_pointer<AC: ast_conv, RS: region_scope Copy Durable>(\n-        self: AC,\n+    fn mk_pointer<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n         rscope: RS,\n         a_seq_ty: ast::mt,\n         vst: ty::vstore,\n@@ -409,10 +413,12 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n     return typ;\n }\n \n-pub fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC, rscope: RS, a: ast::arg,\n-    expected_ty: Option<ty::arg>) -> ty::arg {\n-\n+pub fn ty_of_arg<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n+        rscope: RS,\n+        a: ast::arg,\n+        expected_ty: Option<ty::arg>)\n+     -> ty::arg {\n     let ty = match a.ty.node {\n       ast::ty_infer if expected_ty.is_some() => expected_ty.get().ty,\n       ast::ty_infer => self.ty_infer(a.ty.span),\n@@ -455,12 +461,13 @@ pub fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n     arg {mode: mode, ty: ty}\n }\n \n-pub fn ty_of_bare_fn<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC, rscope: RS,\n-    purity: ast::purity,\n-    abi: ast::Abi,\n-    decl: ast::fn_decl) -> ty::BareFnTy\n-{\n+pub fn ty_of_bare_fn<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n+        rscope: RS,\n+        purity: ast::purity,\n+        abi: ast::Abi,\n+        decl: ast::fn_decl)\n+     -> ty::BareFnTy {\n     debug!(\"ty_of_fn_decl\");\n \n     // new region names that appear inside of the fn decl are bound to\n@@ -480,16 +487,17 @@ pub fn ty_of_bare_fn<AC: ast_conv, RS: region_scope Copy Durable>(\n     }\n }\n \n-pub fn ty_of_closure<AC: ast_conv, RS: region_scope Copy Durable>(\n-    self: AC, rscope: RS,\n-    sigil: ast::Sigil,\n-    purity: ast::purity,\n-    onceness: ast::Onceness,\n-    opt_region: Option<@ast::region>,\n-    decl: ast::fn_decl,\n-    expected_tys: Option<ty::FnSig>,\n-    span: span) -> ty::ClosureTy\n-{\n+pub fn ty_of_closure<AC: AstConv, RS: region_scope Copy Durable>(\n+        self: @mut AC,\n+        rscope: RS,\n+        sigil: ast::Sigil,\n+        purity: ast::purity,\n+        onceness: ast::Onceness,\n+        opt_region: Option<@ast::region>,\n+        decl: ast::fn_decl,\n+        expected_tys: Option<ty::FnSig>,\n+        span: span)\n+     -> ty::ClosureTy {\n     debug!(\"ty_of_fn_decl\");\n     let _i = indenter();\n "}, {"sha": "3cd2be6450de9b7d49e9a4d389353510d6d8a905", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -14,7 +14,7 @@ use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::pat_util::{pat_is_variant_or_struct};\n use middle::ty;\n use middle::typeck::check::demand;\n-use middle::typeck::check::{check_block, check_expr_has_type, fn_ctxt};\n+use middle::typeck::check::{check_block, check_expr_has_type, FnCtxt};\n use middle::typeck::check::{instantiate_path, lookup_def};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n@@ -27,7 +27,7 @@ use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust;\n \n-pub fn check_match(fcx: @fn_ctxt,\n+pub fn check_match(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    discrim: @ast::expr,\n                    arms: ~[ast::arm]) -> bool {\n@@ -69,7 +69,7 @@ pub fn check_match(fcx: @fn_ctxt,\n }\n \n pub struct pat_ctxt {\n-    fcx: @fn_ctxt,\n+    fcx: @mut FnCtxt,\n     map: PatIdMap,\n     match_region: ty::Region, // Region for the match as a whole\n     block_region: ty::Region, // Region for the block of the arm"}, {"sha": "5f1a3b5c17c4acd8637f0eaf5f79a46d9b6164fd", "filename": "src/librustc/middle/typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fdemand.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -10,7 +10,7 @@\n \n \n use middle::ty;\n-use middle::typeck::check::fn_ctxt;\n+use middle::typeck::check::FnCtxt;\n use middle::typeck::infer;\n \n use core::result::{Err, Ok};\n@@ -20,13 +20,12 @@ use syntax::codemap::span;\n \n // Requires that the two types unify, and prints an error message if they\n // don't.\n-pub fn suptype(fcx: @fn_ctxt, sp: span,\n-               expected: ty::t, actual: ty::t) {\n+pub fn suptype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n     suptype_with_fn(fcx, sp, expected, actual,\n         |sp, e, a, s| { fcx.report_mismatched_types(sp, e, a, s) })\n }\n \n-pub fn suptype_with_fn(fcx: @fn_ctxt,\n+pub fn suptype_with_fn(fcx: @mut FnCtxt,\n                        sp: span,\n                        expected: ty::t, actual: ty::t,\n                        handle_err: fn(span, ty::t, ty::t, &ty::type_err)) {\n@@ -40,7 +39,7 @@ pub fn suptype_with_fn(fcx: @fn_ctxt,\n     }\n }\n \n-pub fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n+pub fn eqtype(fcx: @mut FnCtxt, sp: span, expected: ty::t, actual: ty::t) {\n     match infer::mk_eqty(fcx.infcx(), false, sp, actual, expected) {\n         Ok(()) => { /* ok */ }\n         Err(ref err) => {\n@@ -50,7 +49,7 @@ pub fn eqtype(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) {\n }\n \n // Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce(fcx: @fn_ctxt,\n+pub fn coerce(fcx: @mut FnCtxt,\n               sp: span,\n               expected: ty::t,\n               expr: @ast::expr) {"}, {"sha": "12e3778020a7c429d9a37263bb217d2ca3d4940d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -85,7 +85,7 @@ use middle::resolve::{Impl, MethodInfo};\n use middle::resolve;\n use middle::ty::*;\n use middle::ty;\n-use middle::typeck::check::{fn_ctxt, impl_self_ty};\n+use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::check::vtable;\n@@ -112,7 +112,7 @@ use syntax::codemap::dummy_sp;\n use syntax::codemap::span;\n \n pub fn lookup(\n-    fcx: @fn_ctxt,\n+    fcx: @mut FnCtxt,\n \n     // In a call `a.b::<X, Y, ...>(...)`:\n     expr: @ast::expr,        // The expression `a.b`.\n@@ -143,7 +143,7 @@ pub fn lookup(\n }\n \n pub struct LookupContext {\n-    fcx: @fn_ctxt,\n+    fcx: @mut FnCtxt,\n     expr: @ast::expr,\n     self_expr: @ast::expr,\n     callee_id: node_id,\n@@ -1264,7 +1264,7 @@ pub impl LookupContext {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&self) -> @infer::InferCtxt {\n+    fn infcx(&self) -> @mut infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n "}, {"sha": "80be81a33b389ec7aa41536e762c129cc0ff8aad", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 282, "deletions": 178, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -85,14 +85,14 @@ use middle::ty::{TyVid, Vid, FnSig, VariantInfo_, field};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{re_bound, br_cap_avoid, substs, arg, param_ty};\n use middle::ty;\n-use middle::typeck::astconv::{ast_conv, ast_path_to_ty};\n+use middle::typeck::astconv::{AstConv, ast_path_to_ty};\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::TransformTypeNormally;\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n-use middle::typeck::crate_ctxt;\n+use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n use middle::typeck::rscope::{anon_rscope, binding_rscope, bound_self_region};\n@@ -144,18 +144,18 @@ pub type self_info = {\n     explicit_self: ast::self_ty\n };\n \n-/// Fields that are part of a `fn_ctxt` which are inherited by\n+/// Fields that are part of a `FnCtxt` which are inherited by\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n ///         do bar() { ... }\n ///     }\n ///\n /// Here, the function `foo()` and the closure passed to\n-/// `bar()` will each have their own `fn_ctxt`, but they will\n+/// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct inherited {\n-    infcx: @infer::InferCtxt,\n+    infcx: @mut infer::InferCtxt,\n     locals: HashMap<ast::node_id, ty::t>,\n     node_types: HashMap<ast::node_id, ty::t>,\n     node_type_substs: HashMap<ast::node_id, ty::substs>,\n@@ -164,12 +164,12 @@ pub struct inherited {\n \n pub enum FnKind { ForLoop, DoBlock, Vanilla }\n \n-pub struct fn_ctxt {\n+pub struct FnCtxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n     // (and with any functions whose environment is being captured).\n \n-    // Refers to whichever `self` is in scope, even this fn_ctxt is\n+    // Refers to whichever `self` is in scope, even this FnCtxt is\n     // for a nested closure that captures `self`\n     self_info: Option<self_info>,\n     ret_ty: ty::t,\n@@ -190,7 +190,7 @@ pub struct fn_ctxt {\n     // inference selects the ultimate value.  Finally, borrowck is\n     // charged with guaranteeing that the value whose address was taken\n     // can actually be made to live as long as it needs to live.\n-    mut region_lb: ast::node_id,\n+    region_lb: ast::node_id,\n \n     // Says whether we're inside a for loop, in a do block\n     // or neither. Helps with error messages involving the\n@@ -201,10 +201,10 @@ pub struct fn_ctxt {\n \n     inh: @inherited,\n \n-    ccx: @crate_ctxt,\n+    ccx: @mut CrateCtxt,\n }\n \n-pub fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n+pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n     @inherited {\n         infcx: infer::new_infer_ctxt(ccx.tcx),\n         locals: HashMap(),\n@@ -215,32 +215,34 @@ pub fn blank_inherited(ccx: @crate_ctxt) -> @inherited {\n }\n \n // Used by check_const and check_enum_variants\n-pub fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n-                     region_bnd: ast::node_id) -> @fn_ctxt {\n+pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n+                     rty: ty::t,\n+                     region_bnd: ast::node_id)\n+                  -> @mut FnCtxt {\n // It's kind of a kludge to manufacture a fake function context\n // and statement context, but we might as well do write the code only once\n-    @fn_ctxt {\n+    @mut FnCtxt {\n         self_info: None,\n         ret_ty: rty,\n         indirect_ret_ty: None,\n         purity: ast::pure_fn,\n-        mut region_lb: region_bnd,\n+        region_lb: region_bnd,\n         in_scope_regions: @Nil,\n         fn_kind: Vanilla,\n         inh: blank_inherited(ccx),\n         ccx: ccx\n     }\n }\n \n-pub fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n+pub fn check_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n     let visit = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);\n }\n \n-pub fn check_bare_fn(ccx: @crate_ctxt,\n+pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n                      id: ast::node_id,\n@@ -256,16 +258,15 @@ pub fn check_bare_fn(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn check_fn(ccx: @crate_ctxt,\n-                self_info: Option<self_info>,\n+pub fn check_fn(ccx: @mut CrateCtxt,\n+                +self_info: Option<self_info>,\n                 purity: ast::purity,\n                 sigil: Option<ast::Sigil>,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 body: ast::blk,\n                 fn_kind: FnKind,\n-                old_fcx: Option<@fn_ctxt>)\n-{\n+                old_fcx: Option<@mut FnCtxt>) {\n     let tcx = ccx.tcx;\n     let indirect_ret = match fn_kind {\n         ForLoop => true, _ => false\n@@ -294,7 +295,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx: @fn_ctxt = {\n+    let fcx: @mut FnCtxt = {\n         let (purity, inherited) = match old_fcx {\n             None => (purity, blank_inherited(ccx)),\n             Some(fcx) => {\n@@ -312,12 +313,12 @@ pub fn check_fn(ccx: @crate_ctxt,\n             }\n         } else { None };\n \n-        @fn_ctxt {\n+        @mut FnCtxt {\n             self_info: self_info,\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n             purity: purity,\n-            mut region_lb: body.node.id,\n+            region_lb: body.node.id,\n             in_scope_regions: isr,\n             fn_kind: fn_kind,\n             inh: inherited,\n@@ -332,7 +333,8 @@ pub fn check_fn(ccx: @crate_ctxt,\n         if self_info.explicit_self.node == ast::sty_static {\n             None\n         } else  {\n-            let self_region = fcx.in_scope_regions.find(ty::br_self);\n+            let in_scope_regions = fcx.in_scope_regions;\n+            let self_region = in_scope_regions.find(ty::br_self);\n             let ty = method::transform_self_type_for_method(\n                 fcx.tcx(),\n                 self_region,\n@@ -377,7 +379,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n         writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n     }\n \n-    fn gather_locals(fcx: @fn_ctxt,\n+    fn gather_locals(fcx: @mut FnCtxt,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n                      arg_tys: &[ty::t],\n@@ -485,8 +487,10 @@ pub fn check_fn(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn check_method(ccx: @crate_ctxt, method: @ast::method,\n-                    self_ty: ty::t, self_impl_def_id: ast::def_id) {\n+pub fn check_method(ccx: @mut CrateCtxt,\n+                    method: @ast::method,\n+                    self_ty: ty::t,\n+                    self_impl_def_id: ast::def_id) {\n     let self_info = {self_ty: self_ty,\n                      self_id: method.self_id,\n                      def_id: self_impl_def_id,\n@@ -516,8 +520,10 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n-                    id: ast::node_id, span: span) {\n+pub fn check_struct(ccx: @mut CrateCtxt,\n+                    struct_def: @ast::struct_def,\n+                    id: ast::node_id,\n+                    span: span) {\n     let tcx = ccx.tcx;\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n@@ -539,7 +545,7 @@ pub fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     check_instantiable(ccx.tcx, span, id);\n }\n \n-pub fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n+pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n     debug!(\"check_item(it.id=%d, it.ident=%s)\",\n            it.id,\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n@@ -614,25 +620,26 @@ pub fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-pub impl @fn_ctxt: ast_conv {\n-    fn tcx() -> ty::ctxt { self.ccx.tcx }\n-    fn ccx() -> @crate_ctxt { self.ccx }\n+pub impl FnCtxt: AstConv {\n+    fn tcx(@mut self) -> ty::ctxt { self.ccx.tcx }\n+    fn ccx(@mut self) -> @mut CrateCtxt { self.ccx }\n \n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(@mut self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn ty_infer(_span: span) -> ty::t {\n+    fn ty_infer(@mut self, _span: span) -> ty::t {\n         self.infcx().next_ty_var()\n     }\n }\n \n-pub impl @fn_ctxt {\n-    fn infcx() -> @infer::InferCtxt { self.inh.infcx }\n-    fn search_in_scope_regions(br: ty::bound_region)\n-        -> Result<ty::Region, ~str>\n-    {\n-        match self.in_scope_regions.find(br) {\n+pub impl FnCtxt {\n+    fn infcx(@mut self) -> @mut infer::InferCtxt { self.inh.infcx }\n+    fn search_in_scope_regions(@mut self,\n+                               br: ty::bound_region)\n+                            -> Result<ty::Region, ~str> {\n+        let in_scope_regions = self.in_scope_regions;\n+        match in_scope_regions.find(br) {\n             Some(r) => result::Ok(r),\n             None => {\n                 let blk_br = ty::br_named(special_idents::blk);\n@@ -647,22 +654,32 @@ pub impl @fn_ctxt {\n     }\n }\n \n-pub impl @fn_ctxt: region_scope {\n-    fn anon_region(span: span) -> Result<ty::Region, ~str> {\n-        result::Ok(self.infcx().next_region_var_nb(span))\n+pub impl @mut FnCtxt: region_scope {\n+    pure fn anon_region(span: span) -> Result<ty::Region, ~str> {\n+        // XXX: Unsafe to work around purity\n+        unsafe {\n+            result::Ok(self.infcx().next_region_var_nb(span))\n+        }\n     }\n-    fn self_region(_span: span) -> Result<ty::Region, ~str> {\n-        self.search_in_scope_regions(ty::br_self)\n+    pure fn self_region(_span: span) -> Result<ty::Region, ~str> {\n+        // XXX: Unsafe to work around purity\n+        unsafe {\n+            self.search_in_scope_regions(ty::br_self)\n+        }\n     }\n-    fn named_region(_span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n-        self.search_in_scope_regions(ty::br_named(id))\n+    pure fn named_region(_span: span, id: ast::ident)\n+                      -> Result<ty::Region, ~str> {\n+        // XXX: Unsafe to work around purity\n+        unsafe {\n+            self.search_in_scope_regions(ty::br_named(id))\n+        }\n     }\n }\n \n-pub impl @fn_ctxt {\n-    fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n+pub impl FnCtxt {\n+    fn tag(@mut self) -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n \n-    fn local_ty(span: span, nid: ast::node_id) -> ty::t {\n+    fn local_ty(@mut self, span: span, nid: ast::node_id) -> ty::t {\n         match self.inh.locals.find(&nid) {\n             Some(t) => t,\n             None => {\n@@ -673,23 +690,23 @@ pub impl @fn_ctxt {\n         }\n     }\n \n-    fn expr_to_str(expr: @ast::expr) -> ~str {\n+    fn expr_to_str(@mut self, expr: @ast::expr) -> ~str {\n         fmt!(\"expr(%?:%s)\", expr.id,\n              pprust::expr_to_str(expr, self.tcx().sess.intr()))\n     }\n \n-    fn block_region() -> ty::Region {\n+    fn block_region(@mut self) -> ty::Region {\n         ty::re_scope(self.region_lb)\n     }\n \n     #[inline(always)]\n-    fn write_ty(node_id: ast::node_id, ty: ty::t) {\n+    fn write_ty(@mut self, node_id: ast::node_id, ty: ty::t) {\n         debug!(\"write_ty(%d, %s) in fcx %s\",\n                node_id, ppaux::ty_to_str(self.tcx(), ty), self.tag());\n         self.inh.node_types.insert(node_id, ty);\n     }\n \n-    fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n+    fn write_substs(@mut self, node_id: ast::node_id, +substs: ty::substs) {\n         if !ty::substs_is_noop(&substs) {\n             debug!(\"write_substs(%d, %s) in fcx %s\",\n                    node_id,\n@@ -699,46 +716,52 @@ pub impl @fn_ctxt {\n         }\n     }\n \n-    fn write_ty_substs(node_id: ast::node_id, ty: ty::t,\n+    fn write_ty_substs(@mut self,\n+                       node_id: ast::node_id,\n+                       ty: ty::t,\n                        +substs: ty::substs) {\n         let ty = ty::subst(self.tcx(), &substs, ty);\n         self.write_ty(node_id, ty);\n         self.write_substs(node_id, substs);\n     }\n \n-    fn write_autoderef_adjustment(node_id: ast::node_id, derefs: uint) {\n+    fn write_autoderef_adjustment(@mut self,\n+                                  node_id: ast::node_id,\n+                                  derefs: uint) {\n         if derefs == 0 { return; }\n         self.write_adjustment(\n             node_id,\n             @ty::AutoAdjustment { autoderefs: derefs, autoref: None }\n         );\n     }\n \n-    fn write_adjustment(node_id: ast::node_id, adj: @ty::AutoAdjustment) {\n+    fn write_adjustment(@mut self,\n+                        node_id: ast::node_id,\n+                        adj: @ty::AutoAdjustment) {\n         debug!(\"write_adjustment(node_id=%?, adj=%?)\", node_id, adj);\n         self.inh.adjustments.insert(node_id, adj);\n     }\n \n-    fn write_nil(node_id: ast::node_id) {\n+    fn write_nil(@mut self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n-    fn write_bot(node_id: ast::node_id) {\n+    fn write_bot(@mut self, node_id: ast::node_id) {\n         self.write_ty(node_id, ty::mk_bot(self.tcx()));\n     }\n \n-    fn to_ty(ast_t: @ast::Ty) -> ty::t {\n+    fn to_ty(@mut self, ast_t: @ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n-    fn expr_to_str(expr: @ast::expr) -> ~str {\n+    fn expr_to_str(@mut self, expr: @ast::expr) -> ~str {\n         expr_repr(self.tcx(), expr)\n     }\n \n-    fn pat_to_str(pat: @ast::pat) -> ~str {\n+    fn pat_to_str(@mut self, pat: @ast::pat) -> ~str {\n         pat_repr(self.tcx(), pat)\n     }\n \n-    fn expr_ty(ex: @ast::expr) -> ty::t {\n+    fn expr_ty(@mut self, ex: @ast::expr) -> ty::t {\n         match self.inh.node_types.find(&ex.id) {\n             Some(t) => t,\n             None => {\n@@ -748,7 +771,7 @@ pub impl @fn_ctxt {\n             }\n         }\n     }\n-    fn node_ty(id: ast::node_id) -> ty::t {\n+    fn node_ty(@mut self, id: ast::node_id) -> ty::t {\n         match self.inh.node_types.find(&id) {\n             Some(t) => t,\n             None => {\n@@ -761,7 +784,7 @@ pub impl @fn_ctxt {\n             }\n         }\n     }\n-    fn node_ty_substs(id: ast::node_id) -> ty::substs {\n+    fn node_ty_substs(@mut self, id: ast::node_id) -> ty::substs {\n         match self.inh.node_type_substs.find(&id) {\n             Some(ref ts) => (/*bad*/copy *ts),\n             None => {\n@@ -774,23 +797,29 @@ pub impl @fn_ctxt {\n             }\n         }\n     }\n-    fn opt_node_ty_substs(id: ast::node_id) -> Option<ty::substs> {\n+    fn opt_node_ty_substs(@mut self, id: ast::node_id) -> Option<ty::substs> {\n         self.inh.node_type_substs.find(&id)\n     }\n \n \n-    fn mk_subty(a_is_expected: bool, span: span,\n-                sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n+    fn mk_subty(@mut self,\n+                a_is_expected: bool,\n+                span: span,\n+                sub: ty::t,\n+                sup: ty::t)\n+             -> Result<(), ty::type_err> {\n         infer::mk_subty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn can_mk_subty(sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n+    fn can_mk_subty(@mut self,\n+                    sub: ty::t,\n+                    sup: ty::t)\n+                 -> Result<(), ty::type_err> {\n         infer::can_mk_subty(self.infcx(), sub, sup)\n     }\n \n-    fn mk_assignty(expr: @ast::expr, sub: ty::t, sup: ty::t)\n-        -> Result<(), ty::type_err>\n-    {\n+    fn mk_assignty(@mut self, expr: @ast::expr, sub: ty::t, sup: ty::t)\n+                -> Result<(), ty::type_err> {\n         match infer::mk_coercety(self.infcx(), false, expr.span, sub, sup) {\n             Ok(None) => result::Ok(()),\n             Err(ref e) => result::Err((*e)),\n@@ -801,21 +830,32 @@ pub impl @fn_ctxt {\n         }\n     }\n \n-    fn can_mk_assignty(sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n+    fn can_mk_assignty(@mut self,\n+                       sub: ty::t,\n+                       sup: ty::t)\n+                    -> Result<(), ty::type_err> {\n         infer::can_mk_coercety(self.infcx(), sub, sup)\n     }\n \n-    fn mk_eqty(a_is_expected: bool, span: span,\n-               sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n+    fn mk_eqty(@mut self,\n+               a_is_expected: bool,\n+               span: span,\n+               sub: ty::t,\n+               sup: ty::t)\n+            -> Result<(), ty::type_err> {\n         infer::mk_eqty(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn mk_subr(a_is_expected: bool, span: span,\n-               sub: ty::Region, sup: ty::Region) -> Result<(), ty::type_err> {\n+    fn mk_subr(@mut self,\n+               a_is_expected: bool,\n+               span: span,\n+               sub: ty::Region,\n+               sup: ty::Region)\n+            -> Result<(), ty::type_err> {\n         infer::mk_subr(self.infcx(), a_is_expected, span, sub, sup)\n     }\n \n-    fn require_unsafe(sp: span, op: ~str) {\n+    fn require_unsafe(@mut self, sp: span, op: ~str) {\n         match self.purity {\n           ast::unsafe_fn => {/*ok*/}\n           _ => {\n@@ -825,30 +865,36 @@ pub impl @fn_ctxt {\n           }\n         }\n     }\n-    fn with_region_lb<R>(lb: ast::node_id, f: fn() -> R) -> R {\n+    fn with_region_lb<R>(@mut self, lb: ast::node_id, f: fn() -> R) -> R {\n         let old_region_lb = self.region_lb;\n         self.region_lb = lb;\n         let v = f();\n         self.region_lb = old_region_lb;\n         move v\n     }\n \n-    fn region_var_if_parameterized(rp: Option<ty::region_variance>,\n+    fn region_var_if_parameterized(@mut self,\n+                                   rp: Option<ty::region_variance>,\n                                    span: span,\n                                    lower_bound: ty::Region)\n-        -> Option<ty::Region>\n-    {\n+                                -> Option<ty::Region> {\n         rp.map(\n             |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n     }\n \n-    fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n-                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n+    fn type_error_message(@mut self,\n+                          sp: span,\n+                          mk_msg: &fn(~str) -> ~str,\n+                          actual_ty: ty::t,\n+                          err: Option<&ty::type_err>) {\n         self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n     }\n \n-    fn report_mismatched_return_types(sp: span, e: ty::t, a: ty::t,\n-                               err: &ty::type_err) {\n+    fn report_mismatched_return_types(@mut self,\n+                                      sp: span,\n+                                      e: ty::t,\n+                                      a: ty::t,\n+                                      err: &ty::type_err) {\n         match self.fn_kind {\n             ForLoop if !ty::type_is_bool(e) && !ty::type_is_nil(a) =>\n                     self.tcx().sess.span_err(sp, fmt!(\"A for-loop body must \\\n@@ -865,13 +911,16 @@ pub impl @fn_ctxt {\n         }\n     }\n \n-    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+    fn report_mismatched_types(@mut self,\n+                               sp: span,\n+                               e: ty::t,\n+                               a: ty::t,\n                                err: &ty::type_err) {\n             self.infcx().report_mismatched_types(sp, e, a, err)\n     }\n }\n \n-pub fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n+pub fn do_autoderef(fcx: @mut FnCtxt, sp: span, t: ty::t) -> (ty::t, uint) {\n     /*!\n      *\n      * Autoderefs the type `t` as many times as possible, returning\n@@ -928,7 +977,7 @@ pub fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n }\n \n // AST fragment checking\n-pub fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n+pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n@@ -951,40 +1000,42 @@ pub fn check_lit(fcx: @fn_ctxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n-pub fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n-    -> bool {\n+pub fn valid_range_bounds(ccx: @mut CrateCtxt,\n+                          from: @ast::expr,\n+                          to: @ast::expr)\n+                       -> bool {\n     const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n }\n \n pub fn check_expr_has_type(\n-    fcx: @fn_ctxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::expr,\n     expected: ty::t) -> bool {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n     }\n }\n \n pub fn check_expr_coercable_to_type(\n-    fcx: @fn_ctxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::expr,\n     expected: ty::t) -> bool {\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::coerce(fcx, expr.span, expected, expr)\n     }\n }\n \n pub fn check_expr_with_hint(\n-    fcx: @fn_ctxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::expr,\n     expected: ty::t) -> bool {\n     check_expr_with_unifier(fcx, expr, Some(expected), || ())\n }\n \n pub fn check_expr_with_opt_hint(\n-    fcx: @fn_ctxt, expr: @ast::expr,\n+    fcx: @mut FnCtxt, expr: @ast::expr,\n     expected: Option<ty::t>) -> bool {\n     check_expr_with_unifier(fcx, expr, expected, || ())\n }\n \n-pub fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n+pub fn check_expr(fcx: @mut FnCtxt, expr: @ast::expr) -> bool {\n     check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n@@ -1076,7 +1127,7 @@ pub fn break_here() {\n     debug!(\"break here!\");\n }\n \n-pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n+pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::expr,\n                                expected: Option<ty::t>,\n                                unifier: fn()) -> bool {\n@@ -1085,7 +1136,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // A generic function to factor out common logic from call and\n     // overloaded operations\n     fn check_call_inner(\n-        fcx: @fn_ctxt,\n+        fcx: @mut FnCtxt,\n         sp: span,\n         call_expr_id: ast::node_id,\n         in_fty: ty::t,\n@@ -1223,7 +1274,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(fcx: @fn_ctxt,\n+    fn check_assignment(fcx: @mut FnCtxt,\n                         lhs: @ast::expr,\n                         rhs: @ast::expr,\n                         id: ast::node_id)\n@@ -1237,7 +1288,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     // A generic function for doing all of the checking for call or\n     // method expressions\n-    fn check_call_or_method(fcx: @fn_ctxt,\n+    fn check_call_or_method(fcx: @mut FnCtxt,\n                             sp: span,\n                             call_expr_id: ast::node_id,\n                             fn_ty: ty::t,\n@@ -1260,9 +1311,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n-                  f: @ast::expr, +args: ~[@ast::expr],\n-                  sugar: ast::CallSugar) -> bool {\n+    fn check_call(fcx: @mut FnCtxt,\n+                  sp: span,\n+                  call_expr_id: ast::node_id,\n+                  f: @ast::expr,\n+                  +args: ~[@ast::expr],\n+                  sugar: ast::CallSugar)\n+               -> bool {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n         let mut bot = match /*bad*/copy f.node {\n@@ -1283,7 +1338,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n \n     // Checks a method call.\n-    fn check_method_call(fcx: @fn_ctxt,\n+    fn check_method_call(fcx: @mut FnCtxt,\n                          expr: @ast::expr,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n@@ -1306,7 +1361,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              tps,\n                              DontDerefArgs) {\n             Some(ref entry) => {\n-                fcx.ccx.method_map.insert(expr.id, (*entry));\n+                let method_map = fcx.ccx.method_map;\n+                method_map.insert(expr.id, (*entry));\n             }\n             None => {\n                 fcx.type_error_message(expr.span,\n@@ -1336,9 +1392,12 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n \n     // A generic function for checking for or for-each loops\n-    fn check_for(fcx: @fn_ctxt, local: @ast::local,\n-                 element_ty: ty::t, body: ast::blk,\n-                 node_id: ast::node_id) -> bool {\n+    fn check_for(fcx: @mut FnCtxt,\n+                 local: @ast::local,\n+                 element_ty: ty::t,\n+                 body: ast::blk,\n+                 node_id: ast::node_id)\n+              -> bool {\n         let local_ty = fcx.local_ty(local.span, local.node.id);\n         demand::suptype(fcx, local.span, local_ty, element_ty);\n         let bot = check_decl_local(fcx, local);\n@@ -1349,9 +1408,12 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: @fn_ctxt, thn: ast::blk,\n-                       elsopt: Option<@ast::expr>, id: ast::node_id,\n-                       _sp: span) -> bool {\n+    fn check_then_else(fcx: @mut FnCtxt,\n+                       thn: ast::blk,\n+                       elsopt: Option<@ast::expr>,\n+                       id: ast::node_id,\n+                       _sp: span)\n+                    -> bool {\n         let (if_t, if_bot) =\n             match elsopt {\n                 Some(els) => {\n@@ -1371,31 +1433,41 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return if_bot;\n     }\n \n-    fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr,\n-                        self_ex: @ast::expr, self_t: ty::t,\n-                        opname: ast::ident, +args: ~[@ast::expr],\n+    fn lookup_op_method(fcx: @mut FnCtxt,\n+                        op_ex: @ast::expr,\n+                        self_ex: @ast::expr,\n+                        self_t: ty::t,\n+                        opname: ast::ident,\n+                        +args: ~[@ast::expr],\n                         +deref_args: DerefArgs)\n-        -> Option<(ty::t, bool)>\n-    {\n+                     -> Option<(ty::t, bool)> {\n         match method::lookup(fcx, op_ex, self_ex,\n                              op_ex.callee_id, opname, self_t, ~[],\n                              deref_args) {\n           Some(ref origin) => {\n               let method_ty = fcx.node_ty(op_ex.callee_id);\n-              fcx.ccx.method_map.insert(op_ex.id, *origin);\n-              Some(check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                    method_ty, op_ex, args,\n-                                    ast::NoSugar, deref_args))\n+              let method_map = fcx.ccx.method_map;\n+              method_map.insert(op_ex.id, *origin);\n+              Some(check_call_inner(fcx,\n+                                    op_ex.span,\n+                                    op_ex.id,\n+                                    method_ty,\n+                                    op_ex,\n+                                    args,\n+                                    ast::NoSugar,\n+                                    deref_args))\n           }\n           _ => None\n         }\n     }\n \n     // could be either a expr_binop or an expr_assign_binop\n-    fn check_binop(fcx: @fn_ctxt, expr: @ast::expr,\n+    fn check_binop(fcx: @mut FnCtxt,\n+                   expr: @ast::expr,\n                    op: ast::binop,\n                    lhs: @ast::expr,\n-                   rhs: @ast::expr) -> bool {\n+                   rhs: @ast::expr)\n+                -> bool {\n         let tcx = fcx.ccx.tcx;\n \n         let lhs_bot = check_expr(fcx, lhs);\n@@ -1446,10 +1518,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return lhs_bot | rhs_bot;\n     }\n \n-    fn check_user_binop(fcx: @fn_ctxt, ex: @ast::expr,\n-                        lhs_expr: @ast::expr, lhs_resolved_t: ty::t,\n-                        op: ast::binop, rhs: @ast::expr) -> (ty::t, bool)\n-    {\n+    fn check_user_binop(fcx: @mut FnCtxt,\n+                        ex: @ast::expr,\n+                        lhs_expr: @ast::expr,\n+                        lhs_resolved_t: ty::t,\n+                        op: ast::binop,\n+                        rhs: @ast::expr)\n+                     -> (ty::t, bool) {\n         let tcx = fcx.ccx.tcx;\n         match ast_util::binop_to_method_name(op) {\n           Some(ref name) => {\n@@ -1486,9 +1561,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         (lhs_resolved_t, false)\n     }\n \n-    fn check_user_unop(fcx: @fn_ctxt, op_str: ~str, mname: ~str,\n+    fn check_user_unop(fcx: @mut FnCtxt,\n+                       op_str: ~str,\n+                       mname: ~str,\n                        ex: @ast::expr,\n-                       rhs_expr: @ast::expr, rhs_t: ty::t) -> ty::t {\n+                       rhs_expr: @ast::expr,\n+                       rhs_t: ty::t)\n+                    -> ty::t {\n         match lookup_op_method(\n             fcx, ex, rhs_expr, rhs_t,\n             fcx.tcx().sess.ident_of(/*bad*/ copy mname), ~[],\n@@ -1509,9 +1588,10 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     // through the `unpack` function.  It there is no expected type or\n     // resolution is not possible (e.g., no constraints yet present), just\n     // returns `none`.\n-    fn unpack_expected<O: Copy>(fcx: @fn_ctxt, expected: Option<ty::t>,\n+    fn unpack_expected<O: Copy>(fcx: @mut FnCtxt,\n+                                expected: Option<ty::t>,\n                                 unpack: fn(&ty::sty) -> Option<O>)\n-        -> Option<O> {\n+                             -> Option<O> {\n         match expected {\n             Some(t) => {\n                 match resolve_type(fcx.infcx(), t, force_tvar) {\n@@ -1523,7 +1603,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n     }\n \n-    fn check_expr_fn(fcx: @fn_ctxt,\n+    fn check_expr_fn(fcx: @mut FnCtxt,\n                      expr: @ast::expr,\n                      ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n@@ -1589,10 +1669,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n \n     // Check field access expressions\n-    fn check_field(fcx: @fn_ctxt, expr: @ast::expr, is_callee: bool,\n-                   base: @ast::expr, field: ast::ident, tys: ~[@ast::Ty])\n-        -> bool\n-    {\n+    fn check_field(fcx: @mut FnCtxt,\n+                   expr: @ast::expr,\n+                   is_callee: bool,\n+                   base: @ast::expr,\n+                   field: ast::ident,\n+                   tys: ~[@ast::Ty])\n+                -> bool {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -1641,10 +1724,17 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         let tps = vec::map(tys, |ty| fcx.to_ty(*ty));\n \n-        match method::lookup(fcx, expr, base, expr.id,\n-                             field, expr_t, tps, DontDerefArgs) {\n+        match method::lookup(fcx,\n+                             expr,\n+                             base,\n+                             expr.id,\n+                             field,\n+                             expr_t,\n+                             tps,\n+                             DontDerefArgs) {\n             Some(ref entry) => {\n-                fcx.ccx.method_map.insert(expr.id, (*entry));\n+                let method_map = fcx.ccx.method_map;\n+                method_map.insert(expr.id, (*entry));\n \n                 // If we have resolved to a method but this is not in\n                 // a callee position, error\n@@ -1673,13 +1763,14 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n-    fn check_struct_or_variant_fields(fcx: @fn_ctxt,\n+    fn check_struct_or_variant_fields(fcx: @mut FnCtxt,\n                                       span: span,\n                                       class_id: ast::def_id,\n                                       substitutions: &ty::substs,\n                                       field_types: ~[ty::field_ty],\n                                       ast_fields: ~[ast::field],\n-                                      check_completeness: bool) -> bool {\n+                                      check_completeness: bool)\n+                                   -> bool {\n         let tcx = fcx.ccx.tcx;\n         let mut bot = false;\n \n@@ -1751,12 +1842,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n-    fn check_struct_constructor(fcx: @fn_ctxt,\n+    fn check_struct_constructor(fcx: @mut FnCtxt,\n                                 id: ast::node_id,\n                                 span: codemap::span,\n                                 class_id: ast::def_id,\n                                 fields: ~[ast::field],\n-                                base_expr: Option<@ast::expr>) -> bool {\n+                                base_expr: Option<@ast::expr>)\n+                             -> bool {\n         let mut bot = false;\n         let tcx = fcx.ccx.tcx;\n \n@@ -1834,12 +1926,13 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n-    fn check_struct_enum_variant(fcx: @fn_ctxt,\n+    fn check_struct_enum_variant(fcx: @mut FnCtxt,\n                                  id: ast::node_id,\n                                  span: codemap::span,\n                                  enum_id: ast::def_id,\n                                  variant_id: ast::def_id,\n-                                 fields: ~[ast::field]) -> bool {\n+                                 fields: ~[ast::field])\n+                              -> bool {\n         let mut bot = false;\n         let tcx = fcx.ccx.tcx;\n \n@@ -1909,11 +2002,10 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n-    fn check_loop_body(fcx: @fn_ctxt,\n+    fn check_loop_body(fcx: @mut FnCtxt,\n                        expr: @ast::expr,\n                        expected: Option<ty::t>,\n-                       loop_body: @ast::expr)\n-    {\n+                       loop_body: @ast::expr) {\n         // a loop body is the special argument to a `for` loop.  We know that\n         // there will be an expected type in this context because it can only\n         // appear in the context of a call, so we get the expected type of the\n@@ -2528,7 +2620,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n     return bot;\n }\n \n-pub fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n+pub fn require_integral(fcx: @mut FnCtxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.type_error_message(sp, |actual| {\n             fmt!(\"mismatched types: expected integral type but found `%s`\",\n@@ -2537,13 +2629,15 @@ pub fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     }\n }\n \n-pub fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n-                              init: @ast::expr) -> bool {\n+pub fn check_decl_initializer(fcx: @mut FnCtxt,\n+                              nid: ast::node_id,\n+                              init: @ast::expr)\n+                           -> bool {\n     let local_ty = fcx.local_ty(init.span, nid);\n     return check_expr_coercable_to_type(fcx, init, local_ty);\n }\n \n-pub fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n+pub fn check_decl_local(fcx: @mut FnCtxt, local: @ast::local) -> bool {\n     let mut bot = false;\n     let tcx = fcx.ccx.tcx;\n \n@@ -2569,7 +2663,7 @@ pub fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     return bot;\n }\n \n-pub fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n+pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt) -> bool {\n     let mut node_id;\n     let mut bot = false;\n     match stmt.node {\n@@ -2596,7 +2690,7 @@ pub fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     return bot;\n }\n \n-pub fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n+pub fn check_block_no_value(fcx: @mut FnCtxt, blk: ast::blk) -> bool {\n     let bot = check_block(fcx, blk);\n     if !bot {\n         let blkty = fcx.node_ty(blk.node.id);\n@@ -2606,15 +2700,16 @@ pub fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     return bot;\n }\n \n-pub fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n+pub fn check_block(fcx0: @mut FnCtxt, blk: ast::blk) -> bool {\n     check_block_with_expected(fcx0, blk, None)\n }\n \n-pub fn check_block_with_expected(fcx0: @fn_ctxt,\n+pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n                                  blk: ast::blk,\n-                                 expected: Option<ty::t>) -> bool {\n+                                 expected: Option<ty::t>)\n+                              -> bool {\n     let fcx = match blk.node.rules {\n-      ast::unsafe_blk => @fn_ctxt {purity: ast::unsafe_fn,.. copy *fcx0},\n+      ast::unsafe_blk => @mut FnCtxt {purity: ast::unsafe_fn,.. copy *fcx0},\n       ast::default_blk => fcx0\n     };\n     do fcx.with_region_lb(blk.node.id) {\n@@ -2653,17 +2748,19 @@ pub fn check_block_with_expected(fcx0: @fn_ctxt,\n     }\n }\n \n-pub fn check_const(ccx: @crate_ctxt,\n-                   _sp: span,\n+pub fn check_const(ccx: @mut CrateCtxt,\n+                   sp: span,\n                    e: @ast::expr,\n                    id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n     let declty = fcx.ccx.tcx.tcache.get(&local_def(id)).ty;\n-    check_const_with_ty(fcx, _sp, e, declty);\n+    check_const_with_ty(fcx, sp, e, declty);\n }\n \n-pub fn check_const_with_ty(fcx: @fn_ctxt, _sp: span, e: @ast::expr,\n+pub fn check_const_with_ty(fcx: @mut FnCtxt,\n+                           _: span,\n+                           e: @ast::expr,\n                            declty: ty::t) {\n     check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n@@ -2695,12 +2792,16 @@ pub fn check_instantiable(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_enum_variants(ccx: @crate_ctxt,\n+pub fn check_enum_variants(ccx: @mut CrateCtxt,\n                            sp: span,\n                            +vs: ~[ast::variant],\n                            id: ast::node_id) {\n-    fn do_check(ccx: @crate_ctxt, sp: span, vs: ~[ast::variant],\n-                id: ast::node_id, disr_vals: &mut ~[int], disr_val: &mut int,\n+    fn do_check(ccx: @mut CrateCtxt,\n+                sp: span,\n+                vs: ~[ast::variant],\n+                id: ast::node_id,\n+                disr_vals: &mut ~[int],\n+                disr_val: &mut int,\n                 variants: &mut ~[ty::VariantInfo]) {\n         let rty = ty::node_id_to_type(ccx.tcx, id);\n         for vs.each |v| {\n@@ -2810,12 +2911,12 @@ pub fn check_enum_variants(ccx: @crate_ctxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-pub fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n+pub fn lookup_def(fcx: @mut FnCtxt, sp: span, id: ast::node_id) -> ast::def {\n     lookup_def_ccx(fcx.ccx, sp, id)\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt,\n+pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n                                       sp: span,\n                                       defn: ast::def)\n                                    -> ty_param_bounds_and_ty {\n@@ -2882,7 +2983,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt,\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-pub fn instantiate_path(fcx: @fn_ctxt,\n+pub fn instantiate_path(fcx: @mut FnCtxt,\n                         pth: @ast::path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n@@ -2942,7 +3043,7 @@ pub fn instantiate_path(fcx: @fn_ctxt,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t)\n+pub fn structurally_resolved_type(fcx: @mut FnCtxt, sp: span, tp: ty::t)\n                                -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => return t_s,\n@@ -2956,27 +3057,30 @@ pub fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t)\n }\n \n // Returns the one-level-deep structure of the given type.\n-pub fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n+pub fn structure_of(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> ty::sty {\n     /*bad*/copy ty::get(structurally_resolved_type(fcx, sp, typ)).sty\n }\n \n-pub fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_integral(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_integral(typ_s);\n }\n \n-pub fn type_is_scalar(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_scalar(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_scalar(typ_s);\n }\n \n-pub fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n+pub fn type_is_c_like_enum(fcx: @mut FnCtxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     return ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-pub fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n-                                 v: ast::expr_vstore) -> ty::vstore {\n+pub fn ast_expr_vstore_to_vstore(fcx: @mut FnCtxt,\n+                                 e: @ast::expr,\n+                                 n: uint,\n+                                 v: ast::expr_vstore)\n+                              -> ty::vstore {\n     match v {\n         ast::expr_vstore_fixed(None) => ty::vstore_fixed(n),\n         ast::expr_vstore_fixed(Some(u)) => {\n@@ -3018,7 +3122,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n         }}))\n }\n \n-pub fn check_bounds_are_used(ccx: @crate_ctxt,\n+pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n                              span: span,\n                              tps: ~[ast::ty_param],\n                              ty: ty::t) {\n@@ -3052,8 +3156,8 @@ pub fn check_bounds_are_used(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n-    fn param(ccx: @crate_ctxt, n: uint) -> ty::t {\n+pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n+    fn param(ccx: @mut CrateCtxt, n: uint) -> ty::t {\n         ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n     fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {"}, {"sha": "9ceace0038591210c40af8d1b8379498547a6a53", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -35,7 +35,7 @@ use middle::ty::{encl_region, re_scope};\n use middle::ty::{vstore_box, vstore_fixed, vstore_slice};\n use middle::ty::{vstore_uniq};\n use middle::ty;\n-use middle::typeck::check::fn_ctxt;\n+use middle::typeck::check::FnCtxt;\n use middle::typeck::check::lookup_def;\n use middle::typeck::infer::{fres, resolve_and_force_all_but_regions};\n use middle::typeck::infer::{resolve_type};\n@@ -49,10 +49,14 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n-pub enum rcx { rcx_({fcx: @fn_ctxt, mut errors_reported: uint}) }\n-pub type rvt = visit::vt<@rcx>;\n+pub struct Rcx {\n+    fcx: @mut FnCtxt,\n+    errors_reported: uint\n+}\n+\n+pub type rvt = visit::vt<@mut Rcx>;\n \n-pub fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n+pub fn encl_region_of_def(fcx: @mut FnCtxt, def: ast::def) -> ty::Region {\n     let tcx = fcx.tcx();\n     match def {\n         def_local(node_id, _) | def_arg(node_id, _, _) |\n@@ -71,8 +75,8 @@ pub fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n     }\n }\n \n-pub impl @rcx {\n-    fn resolve_type(unresolved_ty: ty::t) -> ty::t {\n+pub impl Rcx {\n+    fn resolve_type(@mut self, unresolved_ty: ty::t) -> ty::t {\n         /*!\n          * Try to resolve the type for the given node, returning\n          * t_err if an error results.  Note that we never care\n@@ -109,23 +113,22 @@ pub impl @rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(id: ast::node_id) -> ty::t {\n+    fn resolve_node_type(@mut self, id: ast::node_id) -> ty::t {\n         self.resolve_type(self.fcx.node_ty(id))\n     }\n }\n \n-pub fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n-    let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n+pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::expr) {\n+    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n     let v = regionck_visitor();\n-    (v.visit_expr)(e, @(move rcx), v);\n+    (v.visit_expr)(e, rcx, v);\n     fcx.infcx().resolve_regions();\n }\n \n-pub fn regionck_fn(fcx: @fn_ctxt,\n-                   blk: ast::blk) {\n-    let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n+pub fn regionck_fn(fcx: @mut FnCtxt, blk: ast::blk) {\n+    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0 };\n     let v = regionck_visitor();\n-    (v.visit_block)(blk, @(move rcx), v);\n+    (v.visit_block)(blk, rcx, v);\n     fcx.infcx().resolve_regions();\n }\n \n@@ -138,11 +141,11 @@ pub fn regionck_visitor() -> rvt {\n                                   .. *visit::default_visitor()})\n }\n \n-pub fn visit_item(_item: @ast::item, &&_rcx: @rcx, _v: rvt) {\n+pub fn visit_item(_item: @ast::item, &&_rcx: @mut Rcx, _v: rvt) {\n     // Ignore items\n }\n \n-pub fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n+pub fn visit_local(l: @ast::local, &&rcx: @mut Rcx, v: rvt) {\n     // Check to make sure that the regions in all local variables are\n     // within scope.\n     //\n@@ -173,11 +176,11 @@ pub fn visit_local(l: @ast::local, &&rcx: @rcx, v: rvt) {\n     }\n }\n \n-pub fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n+pub fn visit_block(b: ast::blk, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_block(b, rcx, v);\n }\n \n-pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n+pub fn visit_expr(expr: @ast::expr, &&rcx: @mut Rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n     for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n@@ -292,11 +295,11 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     visit::visit_expr(expr, rcx, v);\n }\n \n-pub fn visit_stmt(s: @ast::stmt, &&rcx: @rcx, v: rvt) {\n+pub fn visit_stmt(s: @ast::stmt, &&rcx: @mut Rcx, v: rvt) {\n     visit::visit_stmt(s, rcx, v);\n }\n \n-pub fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n+pub fn visit_node(id: ast::node_id, span: span, rcx: @mut Rcx) -> bool {\n     /*!\n      *\n      * checks the type of the node `id` and reports an error if it\n@@ -315,7 +318,7 @@ pub fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     constrain_regions_in_type_of_node(rcx, id, encl_region, span)\n }\n \n-pub fn constrain_auto_ref(rcx: @rcx, expr: @ast::expr) {\n+pub fn constrain_auto_ref(rcx: @mut Rcx, expr: @ast::expr) {\n     /*!\n      *\n      * If `expr` is auto-ref'd (e.g., as part of a borrow), then this\n@@ -360,7 +363,7 @@ pub fn constrain_auto_ref(rcx: @rcx, expr: @ast::expr) {\n }\n \n pub fn constrain_free_variables(\n-    rcx: @rcx,\n+    rcx: @mut Rcx,\n     region: ty::Region,\n     expr: @ast::expr) {\n     /*!\n@@ -396,7 +399,7 @@ pub fn constrain_free_variables(\n }\n \n pub fn constrain_regions_in_type_of_node(\n-    rcx: @rcx,\n+    rcx: @mut Rcx,\n     id: ast::node_id,\n     encl_region: ty::Region,\n     span: span) -> bool {\n@@ -413,7 +416,7 @@ pub fn constrain_regions_in_type_of_node(\n }\n \n pub fn constrain_regions_in_type(\n-    rcx: @rcx,\n+    rcx: @mut Rcx,\n     encl_region: ty::Region,\n     span: span,\n     ty: ty::t) -> bool {\n@@ -434,7 +437,7 @@ pub fn constrain_regions_in_type(\n         |t| ty::type_has_regions(t));\n     return (e == rcx.errors_reported);\n \n-    fn constrain_region(rcx: @rcx,\n+    fn constrain_region(rcx: @mut Rcx,\n                         encl_region: ty::Region,\n                         span: span,\n                         region: ty::Region) {\n@@ -521,13 +524,13 @@ pub mod guarantor {\n      */\n \n     use core::prelude::*;\n-    use middle::typeck::check::regionck::{rcx, infallibly_mk_subr};\n+    use middle::typeck::check::regionck::{Rcx, infallibly_mk_subr};\n     use middle::ty;\n     use syntax::ast;\n     use syntax::codemap::span;\n     use util::ppaux::{ty_to_str};\n \n-    pub fn for_addr_of(rcx: @rcx, expr: @ast::expr, base: @ast::expr) {\n+    pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::expr, base: @ast::expr) {\n         /*!\n          *\n          * Computes the guarantor for an expression `&base` and then\n@@ -542,7 +545,7 @@ pub mod guarantor {\n         link(rcx, expr.span, expr.id, guarantor);\n     }\n \n-    pub fn for_match(rcx: @rcx, discr: @ast::expr, arms: &[ast::arm]) {\n+    pub fn for_match(rcx: @mut Rcx, discr: @ast::expr, arms: &[ast::arm]) {\n         /*!\n          *\n          * Computes the guarantors for any ref bindings in a match and\n@@ -558,11 +561,10 @@ pub mod guarantor {\n         }\n     }\n \n-    pub fn for_autoref(rcx: @rcx,\n+    pub fn for_autoref(rcx: @mut Rcx,\n                        expr: @ast::expr,\n                        adjustment: &ty::AutoAdjustment,\n-                       autoref: &ty::AutoRef)\n-    {\n+                       autoref: &ty::AutoRef) {\n         /*!\n          *\n          * Computes the guarantor for an expression that has an\n@@ -583,11 +585,10 @@ pub mod guarantor {\n     }\n \n     fn link(\n-        rcx: @rcx,\n+        rcx: @mut Rcx,\n         span: span,\n         id: ast::node_id,\n-        guarantor: Option<ty::Region>)\n-    {\n+        guarantor: Option<ty::Region>) {\n         /*!\n          *\n          * Links the lifetime of the borrowed pointer resulting from a borrow\n@@ -640,7 +641,7 @@ pub mod guarantor {\n         ty: ty::t\n     }\n \n-    fn guarantor(rcx: @rcx, expr: @ast::expr) -> Option<ty::Region> {\n+    fn guarantor(rcx: @mut Rcx, expr: @ast::expr) -> Option<ty::Region> {\n         /*!\n          *\n          * Computes the guarantor of `expr`, or None if `expr` is\n@@ -715,7 +716,7 @@ pub mod guarantor {\n         }\n     }\n \n-    fn categorize(rcx: @rcx, expr: @ast::expr) -> ExprCategorization {\n+    fn categorize(rcx: @mut Rcx, expr: @ast::expr) -> ExprCategorization {\n         debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         let _i = ::util::common::indenter();\n \n@@ -741,8 +742,9 @@ pub mod guarantor {\n         return expr_ct.cat;\n     }\n \n-    fn categorize_unadjusted(rcx: @rcx,\n-                             expr: @ast::expr) -> ExprCategorizationType {\n+    fn categorize_unadjusted(rcx: @mut Rcx,\n+                             expr: @ast::expr)\n+                          -> ExprCategorizationType {\n         debug!(\"categorize_unadjusted(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         let _i = ::util::common::indenter();\n \n@@ -765,11 +767,11 @@ pub mod guarantor {\n     }\n \n     fn apply_autoderefs(\n-        +rcx: @rcx,\n+        +rcx: @mut Rcx,\n         +expr: @ast::expr,\n         +autoderefs: uint,\n-        +ct: ExprCategorizationType) -> ExprCategorizationType\n-    {\n+        +ct: ExprCategorizationType)\n+     -> ExprCategorizationType {\n         let mut ct = ct;\n         let tcx = rcx.fcx.ccx.tcx;\n         for uint::range(0, autoderefs) |_| {\n@@ -824,10 +826,9 @@ pub mod guarantor {\n     }\n \n     fn link_ref_bindings_in_pat(\n-        rcx: @rcx,\n+        rcx: @mut Rcx,\n         pat: @ast::pat,\n-        guarantor: Option<ty::Region>)\n-    {\n+        guarantor: Option<ty::Region>) {\n         /*!\n          *\n          * Descends through the pattern, tracking the guarantor\n@@ -901,22 +902,21 @@ pub mod guarantor {\n         }\n     }\n \n-    fn link_ref_bindings_in_pats(rcx: @rcx,\n+    fn link_ref_bindings_in_pats(rcx: @mut Rcx,\n                                  pats: &~[@ast::pat],\n-                                 guarantor: Option<ty::Region>)\n-    {\n+                                 guarantor: Option<ty::Region>) {\n         for pats.each |pat| {\n             link_ref_bindings_in_pat(rcx, *pat, guarantor);\n         }\n     }\n \n }\n \n-pub fn infallibly_mk_subr(rcx: @rcx,\n+pub fn infallibly_mk_subr(rcx: @mut Rcx,\n                           a_is_expected: bool,\n-                         span: span,\n-                         a: ty::Region,\n-                         b: ty::Region) {\n+                          span: span,\n+                          a: ty::Region,\n+                          b: ty::Region) {\n     /*!\n      *\n      * Constrains `a` to be a subregion of `b`.  In many cases, we"}, {"sha": "b72c42f6af73d650b0d9a96a5e2e734d0eb95786", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -13,12 +13,12 @@ use core::prelude::*;\n use middle::resolve;\n use middle::ty::{param_ty, substs};\n use middle::ty;\n-use middle::typeck::check::{fn_ctxt, impl_self_ty};\n+use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::{fixup_err_to_str, InferCtxt};\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::{crate_ctxt, vtable_origin, vtable_param, vtable_res};\n+use middle::typeck::{CrateCtxt, vtable_origin, vtable_param, vtable_res};\n use middle::typeck::{vtable_static, vtable_trait};\n use util::common::indenter;\n use util::ppaux::tys_to_str;\n@@ -63,8 +63,8 @@ pub struct LocationInfo {\n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n pub struct VtableContext {\n-    ccx: @crate_ctxt,\n-    infcx: @infer::InferCtxt\n+    ccx: @mut CrateCtxt,\n+    infcx: @mut infer::InferCtxt\n }\n \n pub impl VtableContext {\n@@ -501,11 +501,13 @@ pub fn connect_trait_tps(vcx: &VtableContext,\n     }\n }\n \n-pub fn insert_vtables(ccx: @crate_ctxt, callee_id: ast::node_id,\n+pub fn insert_vtables(ccx: @mut CrateCtxt,\n+                      callee_id: ast::node_id,\n                       vtables: vtable_res) {\n     debug!(\"insert_vtables(callee_id=%d, vtables=%?)\",\n            callee_id, vtables.map(|v| v.to_str(ccx.tcx)));\n-    ccx.vtable_map.insert(callee_id, vtables);\n+    let vtable_map = ccx.vtable_map;\n+    vtable_map.insert(callee_id, vtables);\n }\n \n pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n@@ -515,7 +517,9 @@ pub fn location_info_for_expr(expr: @ast::expr) -> LocationInfo {\n     }\n }\n \n-pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n+pub fn early_resolve_expr(ex: @ast::expr,\n+                          &&fcx: @mut FnCtxt,\n+                          is_early: bool) {\n     debug!(\"vtable: early_resolve_expr() ex with id %? (early: %b): %s\",\n            ex.id, is_early, expr_to_str(ex, fcx.tcx().sess.intr()));\n     let _indent = indenter();\n@@ -540,7 +544,10 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            item_ty.bounds, substs, false,\n                                            is_early);\n-                if !is_early { cx.vtable_map.insert(ex.id, vtbls); }\n+                if !is_early {\n+                    let vtable_map = cx.vtable_map;\n+                    vtable_map.insert(ex.id, vtbls);\n+                }\n             }\n           }\n           _ => ()\n@@ -625,8 +632,10 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                                             // vtable (that is: \"ex has vtable\n                                             // <vtable>\")\n                                             if !is_early {\n-                                                cx.vtable_map.insert(\n-                                                    ex.id, @~[vtable]);\n+                                                let vtable_map =\n+                                                    cx.vtable_map;\n+                                                vtable_map.insert(ex.id,\n+                                                                  @~[vtable]);\n                                             }\n                                         }\n                                         None => err = true\n@@ -696,7 +705,10 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                     Map this expression to that vtable (that is: \"ex has\n                     vtable <vtable>\")\n                     */\n-                    if !is_early { cx.vtable_map.insert(ex.id, @~[vtable]); }\n+                    if !is_early {\n+                        let vtable_map = cx.vtable_map;\n+                        vtable_map.insert(ex.id, @~[vtable]);\n+                    }\n                     fcx.tcx().legacy_boxed_traits.insert(ex.id, ());\n                 }\n             }\n@@ -709,19 +721,18 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n }\n \n pub fn resolve_expr(ex: @ast::expr,\n-                    &&fcx: @fn_ctxt,\n-                    v: visit::vt<@fn_ctxt>) {\n+                    &&fcx: @mut FnCtxt,\n+                    v: visit::vt<@mut FnCtxt>) {\n     early_resolve_expr(ex, fcx, false);\n     visit::visit_expr(ex, fcx, v);\n }\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n-pub fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n+pub fn resolve_in_block(fcx: @mut FnCtxt, bl: ast::blk) {\n     visit::visit_block(bl, fcx, visit::mk_vt(@visit::Visitor {\n         visit_expr: resolve_expr,\n-        visit_item: fn@(_i: @ast::item, &&_e: @fn_ctxt,\n-                        _v: visit::vt<@fn_ctxt>) {},\n+        visit_item: |_,_,_| {},\n         .. *visit::default_visitor()\n     }));\n }"}, {"sha": "835e0557e2ec9e1566b9e13a679a5c7e1f159a7b", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -17,7 +17,7 @@ use core::prelude::*;\n use middle::pat_util;\n use middle::ty::arg;\n use middle::ty;\n-use middle::typeck::check::{fn_ctxt, self_info};\n+use middle::typeck::check::{FnCtxt, self_info};\n use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::{resolve_type};\n use middle::typeck::infer;\n@@ -34,8 +34,8 @@ use syntax::codemap::span;\n use syntax::print::pprust::pat_to_str;\n use syntax::visit;\n \n-fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n-    -> Option<ty::t> {\n+fn resolve_type_vars_in_type(fcx: @mut FnCtxt, sp: span, typ: ty::t)\n+                          -> Option<ty::t> {\n     if !ty::type_needs_infer(typ) { return Some(typ); }\n     match resolve_type(fcx.infcx(), typ, resolve_all | force_all) {\n         Ok(new_type) => return Some(new_type),\n@@ -52,28 +52,28 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n     }\n }\n \n-fn resolve_method_map_entry(fcx: @fn_ctxt, sp: span, id: ast::node_id)\n-{\n+fn resolve_method_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n     // Resolve any method map entry\n     match fcx.ccx.method_map.find(&id) {\n         None => {}\n         Some(ref mme) => {\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n-                fcx.ccx.method_map.insert(\n-                    id,\n-                    method_map_entry {\n-                        self_arg: arg {mode: mme.self_arg.mode, ty: *t},\n-                        .. *mme\n-                    }\n-                );\n+                let method_map = fcx.ccx.method_map;\n+                method_map.insert(id,\n+                                  method_map_entry {\n+                                    self_arg: arg {\n+                                        mode: mme.self_arg.mode,\n+                                        ty: *t\n+                                    },\n+                                    .. *mme\n+                                  });\n             }\n         }\n     }\n }\n \n-fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n-    -> Option<ty::t>\n-{\n+fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: span, id: ast::node_id)\n+                           -> Option<ty::t> {\n     let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n@@ -137,29 +137,33 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n     }\n }\n \n-fn maybe_resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span,\n+fn maybe_resolve_type_vars_for_node(wbcx: @mut WbCtxt,\n+                                    sp: span,\n                                     id: ast::node_id)\n-    -> Option<ty::t>\n-{\n+                                 -> Option<ty::t> {\n     if wbcx.fcx.inh.node_types.contains_key_ref(&id) {\n         resolve_type_vars_for_node(wbcx, sp, id)\n     } else {\n         None\n     }\n }\n \n-type wb_ctxt =\n+struct WbCtxt {\n+    fcx: @mut FnCtxt,\n+\n     // As soon as we hit an error we have to stop resolving\n-    // the entire function\n-    {fcx: @fn_ctxt, mut success: bool};\n-type wb_vt = visit::vt<wb_ctxt>;\n+    // the entire function.\n+    success: bool,\n+}\n+\n+type wb_vt = visit::vt<@mut WbCtxt>;\n \n-fn visit_stmt(s: @ast::stmt, wbcx: wb_ctxt, v: wb_vt) {\n+fn visit_stmt(s: @ast::stmt, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n     visit::visit_stmt(s, wbcx, v);\n }\n-fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n+fn visit_expr(e: @ast::expr, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n@@ -196,12 +200,12 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     }\n     visit::visit_expr(e, wbcx, v);\n }\n-fn visit_block(b: ast::blk, wbcx: wb_ctxt, v: wb_vt) {\n+fn visit_block(b: ast::blk, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n     visit::visit_block(b, wbcx, v);\n }\n-fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n+fn visit_pat(p: @ast::pat, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     debug!(\"Type for pattern binding %s (id %d) resolved to %s\",\n@@ -211,7 +215,7 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n                                    p.id)));\n     visit::visit_pat(p, wbcx, v);\n }\n-fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n+fn visit_local(l: @ast::local, &&wbcx: @mut WbCtxt, v: wb_vt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.node.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n@@ -233,11 +237,11 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     }\n     visit::visit_local(l, wbcx, v);\n }\n-fn visit_item(_item: @ast::item, _wbcx: wb_ctxt, _v: wb_vt) {\n+fn visit_item(_item: @ast::item, &&_wbcx: @mut WbCtxt, _v: wb_vt) {\n     // Ignore items\n }\n \n-fn mk_visitor() -> visit::vt<wb_ctxt> {\n+fn mk_visitor() -> visit::vt<@mut WbCtxt> {\n     visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n                                   visit_stmt: visit_stmt,\n                                   visit_expr: visit_expr,\n@@ -247,18 +251,18 @@ fn mk_visitor() -> visit::vt<wb_ctxt> {\n                                   .. *visit::default_visitor()})\n }\n \n-pub fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n-    let wbcx = {fcx: fcx, mut success: true};\n+pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::expr) -> bool {\n+    let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_expr)(e, wbcx, visit);\n     return wbcx.success;\n }\n \n-pub fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n+pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                decl: &ast::fn_decl,\n                                blk: ast::blk,\n                                self_info: Option<self_info>) -> bool {\n-    let wbcx = {fcx: fcx, mut success: true};\n+    let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n     let visit = mk_visitor();\n     (visit.visit_block)(blk, wbcx, visit);\n     for self_info.each |self_info| {"}, {"sha": "9f28cb6152037a7be329a47d9de8ada1dbb771ea", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -33,7 +33,7 @@ use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n use middle::ty::{type_is_ty_var};\n use middle::ty;\n-use middle::typeck::crate_ctxt;\n+use middle::typeck::CrateCtxt;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer::{InferCtxt, can_mk_subty};\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n@@ -71,7 +71,7 @@ pub struct UniversalQuantificationResult {\n     bounds: @~[param_bounds]\n }\n \n-pub fn get_base_type(inference_context: @InferCtxt,\n+pub fn get_base_type(inference_context: @mut InferCtxt,\n                      span: span,\n                      original_type: t)\n                   -> Option<t> {\n@@ -119,7 +119,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n }\n \n // Returns the def ID of the base type, if there is one.\n-pub fn get_base_type_def_id(inference_context: @InferCtxt,\n+pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                             span: span,\n                             original_type: t)\n                          -> Option<def_id> {\n@@ -171,7 +171,7 @@ pub fn CoherenceInfo() -> CoherenceInfo {\n     }\n }\n \n-pub fn CoherenceChecker(crate_context: @crate_ctxt) -> CoherenceChecker {\n+pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n@@ -182,8 +182,8 @@ pub fn CoherenceChecker(crate_context: @crate_ctxt) -> CoherenceChecker {\n }\n \n pub struct CoherenceChecker {\n-    crate_context: @crate_ctxt,\n-    inference_context: @InferCtxt,\n+    crate_context: @mut CrateCtxt,\n+    inference_context: @mut InferCtxt,\n \n     // A mapping from implementations to the corresponding base type\n     // definition ID.\n@@ -415,7 +415,7 @@ pub impl CoherenceChecker {\n     }\n \n     fn check_implementation_coherence() {\n-        let coherence_info = &self.crate_context.coherence_info;\n+        let coherence_info = &mut self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n         for extension_methods.each_key_ref |&trait_id| {\n@@ -478,7 +478,7 @@ pub impl CoherenceChecker {\n     fn iter_impls_of_trait(trait_def_id: def_id,\n                            f: &fn(@Impl)) {\n \n-        let coherence_info = &self.crate_context.coherence_info;\n+        let coherence_info = &mut self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n         match extension_methods.find(&trait_def_id) {\n@@ -824,9 +824,8 @@ pub impl CoherenceChecker {\n     // External crate handling\n \n     fn add_impls_for_module(impls_seen: HashMap<def_id,()>,\n-                            crate_store: CStore,\n+                            crate_store: @mut CStore,\n                             module_def_id: def_id) {\n-\n         let implementations = get_impls_for_mod(crate_store,\n                                                 module_def_id,\n                                                 None);\n@@ -986,7 +985,7 @@ pub impl CoherenceChecker {\n     //\n \n     fn populate_destructor_table() {\n-        let coherence_info = &self.crate_context.coherence_info;\n+        let coherence_info = &mut self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();\n         let impls_opt = coherence_info.extension_methods.find(&drop_trait);\n@@ -1035,8 +1034,8 @@ pub impl CoherenceChecker {\n     }\n }\n \n-pub fn check_coherence(crate_context: @crate_ctxt, crate: @crate) {\n+pub fn check_coherence(crate_context: @mut CrateCtxt, crate: @crate) {\n     let coherence_checker = @CoherenceChecker(crate_context);\n-    (*coherence_checker).check_coherence(crate);\n+    coherence_checker.check_coherence(crate);\n }\n "}, {"sha": "68a0ca3890ee8c99da79d27744d2a1b24ede44e3", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 50, "deletions": 45, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -36,13 +36,13 @@ use metadata::csearch;\n use middle::ty::{InstantiatedTraitRef, arg};\n use middle::ty::{substs, ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::astconv::{ast_conv, ty_of_arg};\n+use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::infer;\n use middle::typeck::rscope::*;\n use middle::typeck::rscope;\n-use middle::typeck::{crate_ctxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n+use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n use util::common::{indenter, pluralize};\n use util::ppaux;\n use util::ppaux::bound_to_str;\n@@ -61,7 +61,7 @@ use syntax::codemap;\n use syntax::print::pprust::path_to_str;\n use syntax::visit;\n \n-pub fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n+pub fn collect_item_types(ccx: @mut CrateCtxt, crate: @ast::crate) {\n \n     // FIXME (#2592): hooking into the \"intrinsic\" root module is crude.\n     // There ought to be a better approach. Attributes?\n@@ -114,19 +114,18 @@ pub fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n         }));\n }\n \n-pub impl @crate_ctxt {\n-    fn to_ty<RS: region_scope Copy Durable>(\n-        rs: RS, ast_ty: @ast::Ty) -> ty::t {\n-\n+pub impl @mut CrateCtxt {\n+    fn to_ty<RS: region_scope Copy Durable>(rs: RS, ast_ty: @ast::Ty)\n+                                         -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n \n-pub impl @crate_ctxt: ast_conv {\n-    fn tcx() -> ty::ctxt { self.tcx }\n-    fn ccx() -> @crate_ctxt { self }\n+pub impl CrateCtxt: AstConv {\n+    fn tcx(@mut self) -> ty::ctxt { self.tcx }\n+    fn ccx(@mut self) -> @mut CrateCtxt { self }\n \n-    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+    fn get_item_ty(@mut self, id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n         if id.crate != ast::local_crate {\n             csearch::get_type(self.tcx, id)\n         } else {\n@@ -145,18 +144,17 @@ pub impl @crate_ctxt: ast_conv {\n         }\n     }\n \n-    fn ty_infer(span: span) -> ty::t {\n+    fn ty_infer(@mut self, span: span) -> ty::t {\n         self.tcx.sess.span_bug(span,\n                                ~\"found `ty_infer` in unexpected place\");\n     }\n }\n \n-pub fn get_enum_variant_types(ccx: @crate_ctxt,\n+pub fn get_enum_variant_types(ccx: @mut CrateCtxt,\n                               enum_ty: ty::t,\n                               variants: &[ast::variant],\n-                              ty_params: &[ast::ty_param],\n-                              rp: Option<ty::region_variance>)\n-{\n+                              +ty_params: ~[ast::ty_param],\n+                              rp: Option<ty::region_variance>) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -193,9 +191,11 @@ pub fn get_enum_variant_types(ccx: @crate_ctxt,\n             }\n \n             ast::enum_variant_kind(ref enum_definition) => {\n-                get_enum_variant_types(ccx, enum_ty,\n+                get_enum_variant_types(ccx,\n+                                       enum_ty,\n                                        enum_definition.variants,\n-                                       ty_params, rp);\n+                                       copy ty_params,\n+                                       rp);\n                 result_ty = None;\n             }\n         };\n@@ -213,15 +213,17 @@ pub fn get_enum_variant_types(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn ensure_trait_methods(ccx: @crate_ctxt,\n+pub fn ensure_trait_methods(ccx: @mut CrateCtxt,\n                             id: ast::node_id,\n                             trait_ty: ty::t) {\n-    fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n-                        stuff: ~[T], f: &fn(v: &T) -> ty::method) {\n+    fn store_methods<T>(ccx: @mut CrateCtxt,\n+                        id: ast::node_id,\n+                        stuff: ~[T],\n+                        f: &fn(v: &T) -> ty::method) {\n         ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n     }\n \n-    fn make_static_method_ty(ccx: @crate_ctxt,\n+    fn make_static_method_ty(ccx: @mut CrateCtxt,\n                              am: ast::ty_method,\n                              rp: Option<ty::region_variance>,\n                              m: ty::method,\n@@ -296,7 +298,7 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn ensure_supertraits(ccx: @crate_ctxt,\n+pub fn ensure_supertraits(ccx: @mut CrateCtxt,\n                           id: ast::node_id,\n                           sp: codemap::span,\n                           rp: Option<ty::region_variance>,\n@@ -480,7 +482,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     }\n }\n \n-pub fn check_methods_against_trait(ccx: @crate_ctxt,\n+pub fn check_methods_against_trait(ccx: @mut CrateCtxt,\n                                    tps: ~[ast::ty_param],\n                                    rp: Option<ty::region_variance>,\n                                    selfty: ty::t,\n@@ -531,7 +533,7 @@ pub fn check_methods_against_trait(ccx: @crate_ctxt,\n     }\n } // fn\n \n-pub fn convert_field(ccx: @crate_ctxt,\n+pub fn convert_field(ccx: @mut CrateCtxt,\n                      rp: Option<ty::region_variance>,\n                      bounds: @~[ty::param_bounds],\n                      v: @ast::struct_field) {\n@@ -551,7 +553,7 @@ pub struct ConvertedMethod {\n     body_id: ast::node_id\n }\n \n-pub fn convert_methods(ccx: @crate_ctxt,\n+pub fn convert_methods(ccx: @mut CrateCtxt,\n                        ms: ~[@ast::method],\n                        rp: Option<ty::region_variance>,\n                        rcvr_bounds: @~[ty::param_bounds])\n@@ -576,7 +578,7 @@ pub fn convert_methods(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n+pub fn ensure_no_ty_param_bounds(ccx: @mut CrateCtxt,\n                                  span: span,\n                                  ty_params: &[ast::ty_param],\n                                  thing: &static/str) {\n@@ -590,7 +592,7 @@ pub fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n+pub fn convert(ccx: @mut CrateCtxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n@@ -602,8 +604,11 @@ pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"enumeration\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx, tpt.ty, enum_definition.variants,\n-                               *ty_params, rp);\n+        get_enum_variant_types(ccx,\n+                               tpt.ty,\n+                               enum_definition.variants,\n+                               copy *ty_params,\n+                               rp);\n       }\n       ast::item_impl(ref tps, trait_ref, selfty, ref ms) => {\n         let i_bounds = ty_param_bounds(ccx, *tps);\n@@ -659,7 +664,7 @@ pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     }\n }\n \n-pub fn convert_struct(ccx: @crate_ctxt,\n+pub fn convert_struct(ccx: @mut CrateCtxt,\n                       rp: Option<ty::region_variance>,\n                       struct_def: @ast::struct_def,\n                       +tps: ~[ast::ty_param],\n@@ -716,7 +721,7 @@ pub fn convert_struct(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n+pub fn convert_foreign(ccx: @mut CrateCtxt, i: @ast::foreign_item) {\n     // As above, this call populates the type table with the converted\n     // type of the foreign item. We simply write it into the node type\n     // table.\n@@ -725,7 +730,7 @@ pub fn convert_foreign(ccx: @crate_ctxt, i: @ast::foreign_item) {\n     ccx.tcx.tcache.insert(local_def(i.id), tpt);\n }\n \n-pub fn ty_of_method(ccx: @crate_ctxt,\n+pub fn ty_of_method(ccx: @mut CrateCtxt,\n                     m: @ast::method,\n                     rp: Option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n@@ -737,7 +742,7 @@ pub fn ty_of_method(ccx: @crate_ctxt,\n      def_id: local_def(m.id)}\n }\n \n-pub fn ty_of_ty_method(self: @crate_ctxt,\n+pub fn ty_of_ty_method(self: @mut CrateCtxt,\n                        m: ast::ty_method,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n@@ -756,7 +761,7 @@ pub fn ty_of_ty_method(self: @crate_ctxt,\n   it's bound to a valid trait type. Returns the def_id for the defining\n   trait. Fails if the type is a type other than an trait type.\n  */\n-pub fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n+pub fn instantiate_trait_ref(ccx: @mut CrateCtxt, t: @ast::trait_ref,\n                              rp: Option<ty::region_variance>)\n     -> (ast::def_id, ty_param_substs_and_ty) {\n \n@@ -780,9 +785,8 @@ pub fn instantiate_trait_ref(ccx: @crate_ctxt, t: @ast::trait_ref,\n     }\n }\n \n-pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n-    -> ty::ty_param_bounds_and_ty {\n-\n+pub fn ty_of_item(ccx: @mut CrateCtxt, it: @ast::item)\n+               -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.find(&def_id) {\n@@ -871,7 +875,7 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n     }\n }\n \n-pub fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n+pub fn ty_of_foreign_item(ccx: @mut CrateCtxt, it: @ast::foreign_item)\n     -> ty::ty_param_bounds_and_ty {\n     match /*bad*/copy it.node {\n       ast::foreign_item_fn(fn_decl, _, params) => {\n@@ -892,7 +896,7 @@ pub fn ty_of_foreign_item(ccx: @crate_ctxt, it: @ast::foreign_item)\n // of a newtyped Ty or a region) to ty's notion of ty param bounds, which can\n // either be user-defined traits, or one of the four built-in traits (formerly\n // known as kinds): Const, Copy, Durable, and Send.\n-pub fn compute_bounds(ccx: @crate_ctxt,\n+pub fn compute_bounds(ccx: @mut CrateCtxt,\n                       ast_bounds: @~[ast::ty_param_bound])\n                    -> ty::param_bounds {\n     @do vec::flat_map(*ast_bounds) |b| {\n@@ -928,8 +932,9 @@ pub fn compute_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn ty_param_bounds(ccx: @crate_ctxt,\n-                       params: &[ast::ty_param]) -> @~[ty::param_bounds] {\n+pub fn ty_param_bounds(ccx: @mut CrateCtxt,\n+                       params: ~[ast::ty_param])\n+                    -> @~[ty::param_bounds] {\n     @do params.map |param| {\n         match ccx.tcx.ty_param_bounds.find(&param.id) {\n           Some(bs) => bs,\n@@ -942,7 +947,7 @@ pub fn ty_param_bounds(ccx: @crate_ctxt,\n     }\n }\n \n-pub fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n+pub fn ty_of_foreign_fn_decl(ccx: @mut CrateCtxt,\n                              decl: ast::fn_decl,\n                              +ty_params: ~[ast::ty_param],\n                              def_id: ast::def_id)\n@@ -964,7 +969,7 @@ pub fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n     return tpt;\n }\n \n-pub fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n+pub fn mk_ty_params(ccx: @mut CrateCtxt, atps: ~[ast::ty_param])\n     -> {bounds: @~[ty::param_bounds], params: ~[ty::t]} {\n \n     let mut i = 0u;\n@@ -977,7 +982,7 @@ pub fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n      })}\n }\n \n-pub fn mk_substs(ccx: @crate_ctxt,\n+pub fn mk_substs(ccx: @mut CrateCtxt,\n                  +atps: ~[ast::ty_param],\n                  rp: Option<ty::region_variance>)\n               -> {bounds: @~[ty::param_bounds], substs: ty::substs} {"}, {"sha": "54b5867bfa239b638159eef8b0c359982b8fe069", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -78,7 +78,7 @@ pub fn macros() {\n }\n \n pub trait Combine {\n-    fn infcx() -> @InferCtxt;\n+    fn infcx() -> @mut InferCtxt;\n     fn tag() -> ~str;\n     fn a_is_expected() -> bool;\n     fn span() -> span;\n@@ -113,7 +113,7 @@ pub trait Combine {\n }\n \n pub struct CombineFields {\n-    infcx: @InferCtxt,\n+    infcx: @mut InferCtxt,\n     a_is_expected: bool,\n     span: span,\n }"}, {"sha": "9778ac670c84916e6044480fa97359e6a5ec1924", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -28,7 +28,7 @@ use std::list;\n pub enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n \n pub impl Glb: Combine {\n-    fn infcx() -> @InferCtxt { self.infcx }\n+    fn infcx() -> @mut InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"glb\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n     fn span() -> span { self.span }"}, {"sha": "e19d5b3f47bed006f492d3c55af2c3d64e2fd971", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -37,7 +37,7 @@ pub impl Lub {\n }\n \n pub impl Lub: Combine {\n-    fn infcx() -> @InferCtxt { self.infcx }\n+    fn infcx() -> @mut InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"lub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n     fn span() -> span { self.span }"}, {"sha": "fd967956b488ffb045a15bc6e0f5c59d1ba3a374", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -313,15 +313,15 @@ pub struct InferCtxt {\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n     ty_var_bindings: ValsAndBindings<ty::TyVid, Bounds<ty::t>>,\n-    mut ty_var_counter: uint,\n+    ty_var_counter: uint,\n \n     // Map from integral variable to the kind of integer it represents\n     int_var_bindings: ValsAndBindings<ty::IntVid, Option<IntVarValue>>,\n-    mut int_var_counter: uint,\n+    int_var_counter: uint,\n \n     // Map from floating variable to the kind of float it represents\n     float_var_bindings: ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>,\n-    mut float_var_counter: uint,\n+    float_var_counter: uint,\n \n     // For region variables.\n     region_vars: RegionVarBindings,\n@@ -351,12 +351,12 @@ pub fn fixup_err_to_str(f: fixup_err) -> ~str {\n fn new_ValsAndBindings<V:Copy, T:Copy>() -> ValsAndBindings<V, T> {\n     ValsAndBindings {\n         vals: oldsmallintmap::mk(),\n-        mut bindings: ~[]\n+        bindings: ~[]\n     }\n }\n \n-pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n-    @InferCtxt {\n+pub fn new_infer_ctxt(tcx: ty::ctxt) -> @mut InferCtxt {\n+    @mut InferCtxt {\n         tcx: tcx,\n \n         ty_var_bindings: new_ValsAndBindings(),\n@@ -372,8 +372,12 @@ pub fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n     }\n }\n \n-pub fn mk_subty(cx: @InferCtxt, a_is_expected: bool, span: span,\n-                a: ty::t, b: ty::t) -> ures {\n+pub fn mk_subty(cx: @mut InferCtxt,\n+                a_is_expected: bool,\n+                span: span,\n+                a: ty::t,\n+                b: ty::t)\n+             -> ures {\n     debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -382,7 +386,7 @@ pub fn mk_subty(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_subty(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n@@ -391,8 +395,12 @@ pub fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n     }.to_ures()\n }\n \n-pub fn mk_subr(cx: @InferCtxt, a_is_expected: bool, span: span,\n-               a: ty::Region, b: ty::Region) -> ures {\n+pub fn mk_subr(cx: @mut InferCtxt,\n+               a_is_expected: bool,\n+               span: span,\n+               a: ty::Region,\n+               b: ty::Region)\n+            -> ures {\n     debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -401,8 +409,12 @@ pub fn mk_subr(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-pub fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n-               a: ty::t, b: ty::t) -> ures {\n+pub fn mk_eqty(cx: @mut InferCtxt,\n+               a_is_expected: bool,\n+               span: span,\n+               a: ty::t,\n+               b: ty::t)\n+            -> ures {\n     debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -412,8 +424,12 @@ pub fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-pub fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n-                   a: ty::t, b: ty::t) -> CoerceResult {\n+pub fn mk_coercety(cx: @mut InferCtxt,\n+                   a_is_expected: bool,\n+                   span: span,\n+                   a: ty::t,\n+                   b: ty::t)\n+                -> CoerceResult {\n     debug!(\"mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n@@ -422,7 +438,7 @@ pub fn mk_coercety(cx: @InferCtxt, a_is_expected: bool, span: span,\n     }\n }\n \n-pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+pub fn can_mk_coercety(cx: @mut InferCtxt, a: ty::t, b: ty::t) -> ures {\n     debug!(\"can_mk_coercety(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n@@ -433,17 +449,22 @@ pub fn can_mk_coercety(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n }\n \n // See comment on the type `resolve_state` below\n-pub fn resolve_type(cx: @InferCtxt, a: ty::t, modes: uint) -> fres<ty::t> {\n-    resolver(cx, modes).resolve_type_chk(a)\n+pub fn resolve_type(cx: @mut InferCtxt,\n+                    a: ty::t,\n+                    modes: uint)\n+                 -> fres<ty::t> {\n+    let mut resolver = resolver(cx, modes);\n+    resolver.resolve_type_chk(a)\n }\n \n-pub fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n+pub fn resolve_region(cx: @mut InferCtxt, r: ty::Region, modes: uint)\n                    -> fres<ty::Region> {\n-    resolver(cx, modes).resolve_region_chk(r)\n+    let mut resolver = resolver(cx, modes);\n+    resolver.resolve_region_chk(r)\n }\n \n /*\n-fn resolve_borrowings(cx: @InferCtxt) {\n+fn resolve_borrowings(cx: @mut InferCtxt) {\n     for cx.borrowings.each |item| {\n         match resolve_region(cx, item.scope, resolve_all|force_all) {\n           Ok(region) => {\n@@ -510,7 +531,7 @@ pub fn uok() -> ures {\n }\n \n fn rollback_to<V:Copy Vid, T:Copy>(\n-    vb: &ValsAndBindings<V, T>,\n+    vb: &mut ValsAndBindings<V, T>,\n     len: uint)\n {\n     while vb.bindings.len() != len {\n@@ -526,7 +547,7 @@ struct Snapshot {\n     region_vars_snapshot: uint,\n }\n \n-impl @InferCtxt {\n+impl @mut InferCtxt {\n     fn combine_fields(a_is_expected: bool,\n                       span: span) -> CombineFields {\n         CombineFields {infcx: self,\n@@ -557,11 +578,11 @@ impl @InferCtxt {\n \n     fn rollback_to(snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n-        rollback_to(&self.ty_var_bindings, snapshot.ty_var_bindings_len);\n+        rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n-        rollback_to(&self.int_var_bindings,\n+        rollback_to(&mut self.int_var_bindings,\n                     snapshot.int_var_bindings_len);\n-        rollback_to(&self.float_var_bindings,\n+        rollback_to(&mut self.float_var_bindings,\n                     snapshot.float_var_bindings_len);\n \n         self.region_vars.rollback_to(snapshot.region_vars_snapshot);\n@@ -609,21 +630,21 @@ impl @InferCtxt {\n }\n \n fn next_simple_var<V: Copy,T: Copy>(\n-    +counter: &mut uint,\n-    +bindings: &ValsAndBindings<V,Option<T>>) -> uint\n-{\n+        +counter: &mut uint,\n+        +bindings: &mut ValsAndBindings<V,Option<T>>)\n+     -> uint {\n     let id = *counter;\n     *counter += 1;\n     bindings.vals.insert(id, Root(None, 0));\n     return id;\n }\n \n-impl @InferCtxt {\n+impl @mut InferCtxt {\n     fn next_ty_var_id() -> TyVid {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n-        self.ty_var_bindings.vals.insert(id,\n-                                         Root({lb: None, ub: None}, 0u));\n+        let vals = self.ty_var_bindings.vals;\n+        vals.insert(id, Root({lb: None, ub: None}, 0u));\n         return TyVid(id);\n     }\n \n@@ -637,7 +658,7 @@ impl @InferCtxt {\n \n     fn next_int_var_id() -> IntVid {\n         IntVid(next_simple_var(&mut self.int_var_counter,\n-                               &self.int_var_bindings))\n+                               &mut self.int_var_bindings))\n     }\n \n     fn next_int_var() -> ty::t {\n@@ -646,7 +667,7 @@ impl @InferCtxt {\n \n     fn next_float_var_id() -> FloatVid {\n         FloatVid(next_simple_var(&mut self.float_var_counter,\n-                                 &self.float_var_bindings))\n+                                 &mut self.float_var_bindings))\n     }\n \n     fn next_float_var() -> ty::t {\n@@ -726,9 +747,9 @@ impl @InferCtxt {\n     }\n \n     fn replace_bound_regions_with_fresh_regions(\n-        &self, span: span,\n-        fsig: &ty::FnSig) -> (ty::FnSig, isr_alist)\n-    {\n+            span: span,\n+            fsig: &ty::FnSig)\n+         -> (ty::FnSig, isr_alist) {\n         let {fn_sig: fn_sig, isr: isr, _} =\n             replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 // N.B.: The name of the bound region doesn't have anything to"}, {"sha": "60f5f4406588ce9ecea169a875125b16ac0a0f36", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 97, "deletions": 92, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -636,8 +636,8 @@ pub struct RegionVarBindings {\n     constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n-    mut skolemization_count: uint,\n-    mut bound_count: uint,\n+    skolemization_count: uint,\n+    bound_count: uint,\n \n     // The undo log records actions that might later be undone.\n     //\n@@ -647,7 +647,7 @@ pub struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    mut undo_log: ~[UndoLogEntry],\n+    undo_log: ~[UndoLogEntry],\n \n     // This contains the results of inference.  It begins as an empty\n     // cell and only acquires a value after inference is complete.\n@@ -677,11 +677,11 @@ fn CombineMap() -> CombineMap {\n }\n \n pub impl RegionVarBindings {\n-    fn in_snapshot(&self) -> bool {\n+    fn in_snapshot(&mut self) -> bool {\n         self.undo_log.len() > 0\n     }\n \n-    fn start_snapshot(&self) -> uint {\n+    fn start_snapshot(&mut self) -> uint {\n         debug!(\"RegionVarBindings: snapshot()=%u\", self.undo_log.len());\n         if self.in_snapshot() {\n             self.undo_log.len()\n@@ -691,14 +691,14 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn commit(&self) {\n+    fn commit(&mut self) {\n         debug!(\"RegionVarBindings: commit()\");\n         while self.undo_log.len() > 0 {\n             self.undo_log.pop();\n         }\n     }\n \n-    fn rollback_to(&self, snapshot: uint) {\n+    fn rollback_to(&mut self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to(%u)\", snapshot);\n         while self.undo_log.len() > snapshot {\n             let undo_item = self.undo_log.pop();\n@@ -719,11 +719,11 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn num_vars(&self) -> uint {\n+    fn num_vars(&mut self) -> uint {\n         self.var_spans.len()\n     }\n \n-    fn new_region_var(&self, span: span) -> RegionVid {\n+    fn new_region_var(&mut self, span: span) -> RegionVid {\n         let id = self.num_vars();\n         self.var_spans.push(span);\n         let vid = RegionVid(id);\n@@ -735,13 +735,13 @@ pub impl RegionVarBindings {\n         return vid;\n     }\n \n-    fn new_skolemized(&self, br: ty::bound_region) -> Region {\n+    fn new_skolemized(&mut self, br: ty::bound_region) -> Region {\n         let sc = self.skolemization_count;\n         self.skolemization_count += 1;\n         re_infer(ReSkolemized(sc, br))\n     }\n \n-    fn new_bound(&self) -> Region {\n+    fn new_bound(&mut self) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -761,7 +761,7 @@ pub impl RegionVarBindings {\n         re_bound(br_fresh(sc))\n     }\n \n-    fn add_constraint(&self, +constraint: Constraint, span: span) {\n+    fn add_constraint(&mut self, +constraint: Constraint, span: span) {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -774,8 +774,10 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn make_subregion(&self, span: span,\n-                      sub: Region, sup: Region) -> cres<()> {\n+    fn make_subregion(&mut self,\n+                      span: span,\n+                      sub: Region,\n+                      sup: Region) -> cres<()> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -813,7 +815,11 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn lub_regions(&self, span: span, a: Region, b: Region) -> cres<Region> {\n+    fn lub_regions(&mut self,\n+                   span: span,\n+                   a: Region,\n+                   b: Region)\n+                -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -835,7 +841,11 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn glb_regions(&self, span: span, a: Region, b: Region) -> cres<Region> {\n+    fn glb_regions(&mut self,\n+                   span: span,\n+                   a: Region,\n+                   b: Region)\n+                -> cres<Region> {\n         // cannot add constraints once regions are resolved\n         assert self.values.is_empty();\n \n@@ -858,7 +868,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n+    fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n         debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, *rid);\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n@@ -900,14 +910,13 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn combine_vars(&self,\n+    fn combine_vars(&mut self,\n                     combines: CombineMap,\n                     a: Region,\n                     b: Region,\n                     span: span,\n-                    relate: fn(old_r: Region, new_r: Region) -> cres<()>)\n-        -> cres<Region> {\n-\n+                    relate: &fn(old_r: Region, new_r: Region) -> cres<()>)\n+                 -> cres<Region> {\n         let vars = TwoRegions { a: a, b: b };\n         match combines.find(&vars) {\n           Some(c) => Ok(re_infer(ReVar(c))),\n@@ -927,7 +936,9 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn vars_created_since_snapshot(&self, snapshot: uint) -> ~[RegionVid] {\n+    fn vars_created_since_snapshot(&mut self,\n+                                   snapshot: uint)\n+                                -> ~[RegionVid] {\n         do vec::build |push| {\n             for uint::range(snapshot, self.undo_log.len()) |i| {\n                 match self.undo_log[i] {\n@@ -938,7 +949,7 @@ pub impl RegionVarBindings {\n         }\n     }\n \n-    fn tainted(&self, snapshot: uint, r0: Region) -> ~[Region] {\n+    fn tainted(&mut self, snapshot: uint, r0: Region) -> ~[Region] {\n         /*!\n          *\n          * Computes all regions that have been related to `r0` in any\n@@ -1022,18 +1033,18 @@ pub impl RegionVarBindings {\n     constraints, assuming such values can be found; if they cannot,\n     errors are reported.\n     */\n-    fn resolve_regions(&self) {\n+    fn resolve_regions(&mut self) {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         self.values.put_back(self.infer_variable_values());\n     }\n }\n \n priv impl RegionVarBindings {\n-    fn is_subregion_of(&self, sub: Region, sup: Region) -> bool {\n+    fn is_subregion_of(&mut self, sub: Region, sup: Region) -> bool {\n         is_subregion_of(self.tcx.region_map, sub, sup)\n     }\n \n-    fn lub_concrete_regions(&self, +a: Region, +b: Region) -> Region {\n+    fn lub_concrete_regions(&mut self, +a: Region, +b: Region) -> Region {\n         match (a, b) {\n           (re_static, _) | (_, re_static) => {\n             re_static // nothing lives longer than static\n@@ -1090,7 +1101,10 @@ priv impl RegionVarBindings {\n         }\n     }\n \n-    fn glb_concrete_regions(&self, +a: Region, +b: Region) -> cres<Region> {\n+    fn glb_concrete_regions(&mut self,\n+                            +a: Region,\n+                            +b: Region)\n+                         -> cres<Region> {\n         match (a, b) {\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n@@ -1156,43 +1170,31 @@ priv impl RegionVarBindings {\n         }\n     }\n \n-    fn report_type_error(&self, span: span, terr: &ty::type_err) {\n+    fn report_type_error(&mut self, span: span, terr: &ty::type_err) {\n         let terr_str = ty::type_err_to_str(self.tcx, terr);\n         self.tcx.sess.span_err(span, terr_str);\n     }\n }\n \n // ______________________________________________________________________\n \n+#[deriving_eq]\n enum Direction { Incoming = 0, Outgoing = 1 }\n \n-impl Direction : cmp::Eq {\n-    pure fn eq(&self, other: &Direction) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Direction) -> bool { !(*self).eq(other) }\n-}\n-\n+#[deriving_eq]\n enum Classification { Expanding, Contracting }\n \n-impl Classification : cmp::Eq {\n-    pure fn eq(&self, other: &Classification) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Classification) -> bool { !(*self).eq(other) }\n-}\n-\n enum GraphNodeValue { NoValue, Value(Region), ErrorValue }\n \n struct GraphNode {\n     span: span,\n-    mut classification: Classification,\n-    mut value: GraphNodeValue,\n-    head_edge: [mut uint * 2], // FIXME(#3226)--should not need mut\n+    classification: Classification,\n+    value: GraphNodeValue,\n+    head_edge: [uint * 2],\n }\n \n struct GraphEdge {\n-    next_edge: [mut uint * 2], // FIXME(#3226)--should not need mut\n+    next_edge: [uint * 2],\n     constraint: Constraint,\n     span: span,\n }\n@@ -1214,14 +1216,14 @@ fn TwoRegionsMap() -> TwoRegionsMap {\n }\n \n impl RegionVarBindings {\n-    fn infer_variable_values(&self) -> ~[GraphNodeValue] {\n-        let graph = self.construct_graph();\n-        self.expansion(&graph);\n-        self.contraction(&graph);\n-        self.extract_values_and_report_conflicts(&graph)\n+    fn infer_variable_values(&mut self) -> ~[GraphNodeValue] {\n+        let mut graph = self.construct_graph();\n+        self.expansion(&mut graph);\n+        self.contraction(&mut graph);\n+        self.extract_values_and_report_conflicts(&mut graph)\n     }\n \n-    fn construct_graph(&self) -> Graph {\n+    fn construct_graph(&mut self) -> Graph {\n         let num_vars = self.num_vars();\n         let num_edges = self.constraints.len();\n \n@@ -1234,15 +1236,15 @@ impl RegionVarBindings {\n                 classification: Contracting,\n                 span: self.var_spans[var_idx],\n                 value: NoValue,\n-                head_edge: [mut uint::max_value, uint::max_value]\n+                head_edge: [uint::max_value, uint::max_value]\n             }\n         });\n \n         // It would be nice to write this using map():\n         let mut edges = vec::with_capacity(num_edges);\n         for self.constraints.each_ref |constraint, span| {\n             edges.push(GraphEdge {\n-                next_edge: [mut uint::max_value, uint::max_value],\n+                next_edge: [uint::max_value, uint::max_value],\n                 constraint: *constraint,\n                 span: *span\n             });\n@@ -1282,18 +1284,18 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expansion(&self, graph: &Graph) {\n+    fn expansion(&mut self, graph: &mut Graph) {\n         do self.iterate_until_fixed_point(~\"Expansion\", graph) |edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(copy a_region, copy b_vid) => {\n-                let b_node = &graph.nodes[*b_vid];\n+                let b_node = &mut graph.nodes[*b_vid];\n                 self.expand_node(a_region, b_vid, b_node)\n               }\n               ConstrainVarSubVar(copy a_vid, copy b_vid) => {\n                 match graph.nodes[*a_vid].value {\n                   NoValue | ErrorValue => false,\n                   Value(copy a_region) => {\n-                    let b_node = &graph.nodes[*b_vid];\n+                    let b_node = &mut graph.nodes[*b_vid];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1306,10 +1308,11 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn expand_node(&self,\n+    fn expand_node(&mut self,\n                    a_region: Region,\n                    b_vid: RegionVid,\n-                   b_node: &GraphNode) -> bool {\n+                   b_node: &mut GraphNode)\n+                -> bool {\n         debug!(\"expand_node(%?, %? == %?)\",\n                a_region, b_vid, b_node.value);\n \n@@ -1341,7 +1344,7 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn contraction(&self, graph: &Graph) {\n+    fn contraction(&mut self, graph: &mut Graph) {\n         do self.iterate_until_fixed_point(~\"Contraction\", graph) |edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(*) => {\n@@ -1352,23 +1355,24 @@ impl RegionVarBindings {\n                 match graph.nodes[*b_vid].value {\n                   NoValue | ErrorValue => false,\n                   Value(copy b_region) => {\n-                    let a_node = &graph.nodes[*a_vid];\n+                    let a_node = &mut graph.nodes[*a_vid];\n                     self.contract_node(a_vid, a_node, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(copy a_vid, copy b_region) => {\n-                let a_node = &graph.nodes[*a_vid];\n+                let a_node = &mut graph.nodes[*a_vid];\n                 self.contract_node(a_vid, a_node, b_region)\n               }\n             }\n         }\n     }\n \n-    fn contract_node(&self,\n+    fn contract_node(&mut self,\n                      a_vid: RegionVid,\n-                     a_node: &GraphNode,\n-                     b_region: Region) -> bool {\n+                     a_node: &mut GraphNode,\n+                     b_region: Region)\n+                  -> bool {\n         debug!(\"contract_node(%? == %?/%?, %?)\",\n                a_vid, a_node.value, a_node.classification, b_region);\n \n@@ -1395,11 +1399,12 @@ impl RegionVarBindings {\n             }\n         };\n \n-        fn check_node(self: &RegionVarBindings,\n+        fn check_node(+self: &mut RegionVarBindings,\n                       a_vid: RegionVid,\n-                      a_node: &GraphNode,\n+                      +a_node: &mut GraphNode,\n                       a_region: Region,\n-                      b_region: Region) -> bool {\n+                      b_region: Region)\n+                   -> bool {\n             if !self.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting %? to ErrorValue: %? not subregion of %?\",\n                        a_vid, a_region, b_region);\n@@ -1408,11 +1413,12 @@ impl RegionVarBindings {\n             false\n         }\n \n-        fn adjust_node(self: &RegionVarBindings,\n+        fn adjust_node(+self: &mut RegionVarBindings,\n                        a_vid: RegionVid,\n-                       a_node: &GraphNode,\n+                       +a_node: &mut GraphNode,\n                        a_region: Region,\n-                       b_region: Region) -> bool {\n+                       b_region: Region)\n+                    -> bool {\n             match self.glb_concrete_regions(a_region, b_region) {\n                 Ok(glb) => {\n                     if glb == a_region {\n@@ -1432,12 +1438,10 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn iterate_until_fixed_point(\n-        &self,\n-        tag: ~str,\n-        graph: &Graph,\n-        body: fn(edge: &GraphEdge) -> bool)\n-    {\n+    fn iterate_until_fixed_point(&mut self,\n+                                 tag: ~str,\n+                                 graph: &mut Graph,\n+                                 body: &fn(edge: &GraphEdge) -> bool) {\n         let mut iteration = 0;\n         let mut changed = true;\n         let num_edges = graph.edges.len();\n@@ -1454,10 +1458,9 @@ impl RegionVarBindings {\n         debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n     }\n \n-    fn extract_values_and_report_conflicts(\n-        &self,\n-        graph: &Graph) -> ~[GraphNodeValue]\n-    {\n+    fn extract_values_and_report_conflicts(&mut self,\n+                                           graph: &mut Graph)\n+                                        -> ~[GraphNodeValue] {\n         let dup_map = TwoRegionsMap();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n@@ -1512,16 +1515,17 @@ impl RegionVarBindings {\n     }\n \n     // Used to suppress reporting the same basic error over and over\n-    fn is_reported(&self,\n+    fn is_reported(&mut self,\n                    dup_map: TwoRegionsMap,\n                    r_a: Region,\n-                   r_b: Region) -> bool {\n+                   r_b: Region)\n+                -> bool {\n         let key = TwoRegions { a: r_a, b: r_b };\n         !dup_map.insert(key, ())\n     }\n \n-    fn report_error_for_expanding_node(&self,\n-                                       graph: &Graph,\n+    fn report_error_for_expanding_node(&mut self,\n+                                       graph: &mut Graph,\n                                        dup_map: TwoRegionsMap,\n                                        node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n@@ -1573,8 +1577,8 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn report_error_for_contracting_node(&self,\n-                                         graph: &Graph,\n+    fn report_error_for_contracting_node(&mut self,\n+                                         graph: &mut Graph,\n                                          dup_map: TwoRegionsMap,\n                                          node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n@@ -1627,10 +1631,11 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn collect_concrete_regions(&self,\n-                                graph: &Graph,\n+    fn collect_concrete_regions(&mut self,\n+                                graph: &mut Graph,\n                                 orig_node_idx: RegionVid,\n-                                dir: Direction) -> ~[SpannedRegion] {\n+                                dir: Direction)\n+                             -> ~[SpannedRegion] {\n         let set = HashMap();\n         let mut stack = ~[orig_node_idx];\n         set.insert(*orig_node_idx, ());\n@@ -1670,8 +1675,8 @@ impl RegionVarBindings {\n         return result;\n     }\n \n-    fn each_edge(&self,\n-                 graph: &Graph,\n+    fn each_edge(&mut self,\n+                 graph: &mut Graph,\n                  node_idx: RegionVid,\n                  dir: Direction,\n                  op: fn(edge: &GraphEdge) -> bool) {"}, {"sha": "7c5e3f715c3a8f237e94ae0003004d9dc5516fed", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -83,14 +83,14 @@ pub const resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n pub struct ResolveState {\n-    infcx: @InferCtxt,\n+    infcx: @mut InferCtxt,\n     modes: uint,\n-    mut err: Option<fixup_err>,\n-    mut v_seen: ~[TyVid],\n-    mut type_depth: uint\n+    err: Option<fixup_err>,\n+    v_seen: ~[TyVid],\n+    type_depth: uint\n }\n \n-pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n+pub fn resolver(infcx: @mut InferCtxt, modes: uint) -> ResolveState {\n     ResolveState {\n         infcx: infcx,\n         modes: modes,\n@@ -101,11 +101,11 @@ pub fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n }\n \n pub impl ResolveState {\n-    fn should(&self, mode: uint) -> bool {\n+    fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }\n \n-    fn resolve_type_chk(&self, typ: ty::t) -> fres<ty::t> {\n+    fn resolve_type_chk(&mut self, typ: ty::t) -> fres<ty::t> {\n         self.err = None;\n \n         debug!(\"Resolving %s (modes=%x)\",\n@@ -130,7 +130,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_region_chk(&self, orig: ty::Region) -> fres<ty::Region> {\n+    fn resolve_region_chk(&mut self, orig: ty::Region) -> fres<ty::Region> {\n         self.err = None;\n         let resolved = indent(|| self.resolve_region(orig) );\n         match self.err {\n@@ -139,7 +139,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_type(&self, typ: ty::t) -> ty::t {\n+    fn resolve_type(&mut self, typ: ty::t) -> ty::t {\n         debug!(\"resolve_type(%s)\", typ.inf_str(self.infcx));\n         let _i = indenter();\n \n@@ -181,22 +181,22 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_region(&self, orig: ty::Region) -> ty::Region {\n+    fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n         debug!(\"Resolve_region(%s)\", orig.inf_str(self.infcx));\n         match orig {\n           ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n-    fn resolve_region_var(&self, rid: RegionVid) -> ty::Region {\n+    fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n             return ty::re_infer(ty::ReVar(rid));\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    fn assert_not_rvar(&self, rid: RegionVid, r: ty::Region) {\n+    fn assert_not_rvar(&mut self, rid: RegionVid, r: ty::Region) {\n         match r {\n           ty::re_infer(ty::ReVar(rid2)) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n@@ -205,7 +205,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_ty_var(&self, vid: TyVid) -> ty::t {\n+    fn resolve_ty_var(&mut self, vid: TyVid) -> ty::t {\n         if vec::contains(self.v_seen, &vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n@@ -238,7 +238,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_int_var(&self, vid: IntVid) -> ty::t {\n+    fn resolve_int_var(&mut self, vid: IntVid) -> ty::t {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n@@ -261,7 +261,7 @@ pub impl ResolveState {\n         }\n     }\n \n-    fn resolve_float_var(&self, vid: FloatVid) -> ty::t {\n+    fn resolve_float_var(&mut self, vid: FloatVid) -> ty::t {\n         if !self.should(resolve_fvar) {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }"}, {"sha": "33a3220f68a3164d44479fd218078402f512f22a", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -33,7 +33,7 @@ pub fn macros() {\n pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n \n pub impl Sub: Combine {\n-    fn infcx() -> @InferCtxt { self.infcx }\n+    fn infcx() -> @mut InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"sub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n     fn span() -> span { self.span }"}, {"sha": "7668388e323a8db012b80a3f83d6831ef8d8e143", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -28,7 +28,7 @@ pub enum VarValue<V, T> {\n \n pub struct ValsAndBindings<V, T> {\n     vals: SmallIntMap<VarValue<V, T>>,\n-    mut bindings: ~[(V, VarValue<V, T>)],\n+    bindings: ~[(V, VarValue<V, T>)],\n }\n \n pub struct Node<V, T> {\n@@ -38,15 +38,14 @@ pub struct Node<V, T> {\n }\n \n pub trait UnifyVid<T> {\n-    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n-        -> &v/ValsAndBindings<Self, T>;\n+    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+        -> &v/mut ValsAndBindings<Self, T>;\n }\n \n pub impl InferCtxt {\n-    fn get<T:Copy, V:Copy Eq Vid UnifyVid<T>>(\n-        &self,\n-        +vid: V) -> Node<V, T>\n-    {\n+    fn get<T:Copy, V:Copy Eq Vid UnifyVid<T>>(&mut self,\n+                                              +vid: V)\n+                                           -> Node<V, T> {\n         /*!\n          *\n          * Find the root node for `vid`. This uses the standard\n@@ -79,10 +78,9 @@ pub impl InferCtxt {\n     }\n \n     fn set<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>>(\n-        &self,\n-        +vid: V,\n-        +new_v: VarValue<V, T>)\n-    {\n+            &mut self,\n+            +vid: V,\n+            +new_v: VarValue<V, T>) {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n@@ -98,10 +96,10 @@ pub impl InferCtxt {\n     }\n \n     fn unify<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>, R>(\n-        &self,\n-        node_a: &Node<V, T>,\n-        node_b: &Node<V, T>,\n-        op: &fn(new_root: V, new_rank: uint) -> R\n+            &mut self,\n+            node_a: &Node<V, T>,\n+            node_b: &Node<V, T>,\n+            op: &fn(new_root: V, new_rank: uint) -> R\n     ) -> R {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n@@ -154,11 +152,11 @@ pub fn mk_err<T: SimplyUnifiable>(+a_is_expected: bool,\n pub impl InferCtxt {\n     fn simple_vars<T:Copy Eq InferStr SimplyUnifiable,\n                    V:Copy Eq Vid ToStr UnifyVid<Option<T>>>(\n-        &self,\n-        +a_is_expected: bool,\n-        +a_id: V,\n-        +b_id: V) -> ures\n-    {\n+            &mut self,\n+            +a_is_expected: bool,\n+            +a_id: V,\n+            +b_id: V)\n+         -> ures {\n         /*!\n          *\n          * Unifies two simple variables.  Because simple variables do\n@@ -193,10 +191,11 @@ pub impl InferCtxt {\n \n     fn simple_var_t<T:Copy Eq InferStr SimplyUnifiable,\n                     V:Copy Eq Vid ToStr UnifyVid<Option<T>>>(\n-        +a_is_expected: bool,\n-        +a_id: V,\n-        +b: T) -> ures\n-    {\n+            &mut self,\n+            +a_is_expected: bool,\n+            +a_id: V,\n+            +b: T)\n+         -> ures {\n         /*!\n          *\n          * Sets the value of the variable `a_id` to `b`.  Because\n@@ -227,41 +226,36 @@ pub impl InferCtxt {\n // ______________________________________________________________________\n \n pub impl ty::TyVid : UnifyVid<Bounds<ty::t>> {\n-    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n-        -> &v/ValsAndBindings<ty::TyVid, Bounds<ty::t>>\n-    {\n-        return &infcx.ty_var_bindings;\n+    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+        -> &v/mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n+        return &mut infcx.ty_var_bindings;\n     }\n }\n \n pub impl ty::IntVid : UnifyVid<Option<IntVarValue>> {\n-    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n-        -> &v/ValsAndBindings<ty::IntVid, Option<IntVarValue>>\n-    {\n-        return &infcx.int_var_bindings;\n+    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+        -> &v/mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n+        return &mut infcx.int_var_bindings;\n     }\n }\n \n pub impl IntVarValue : SimplyUnifiable {\n     static fn to_type_err(err: expected_found<IntVarValue>)\n-        -> ty::type_err\n-    {\n+        -> ty::type_err {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n pub impl ty::FloatVid : UnifyVid<Option<ast::float_ty>> {\n-    static fn appropriate_vals_and_bindings(infcx: &v/InferCtxt)\n-        -> &v/ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>\n-    {\n-        return &infcx.float_var_bindings;\n+    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+        -> &v/mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n+        return &mut infcx.float_var_bindings;\n     }\n }\n \n pub impl ast::float_ty : SimplyUnifiable {\n     static fn to_type_err(err: expected_found<ast::float_ty>)\n-        -> ty::type_err\n-    {\n+        -> ty::type_err {\n         return ty::terr_float_mismatch(err);\n     }\n }"}, {"sha": "caa02da2858bcf965a7cb8532e5a9797cc942020", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -196,7 +196,7 @@ pub impl vtable_origin {\n \n pub type vtable_map = HashMap<ast::node_id, vtable_res>;\n \n-struct crate_ctxt__ {\n+pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,\n     method_map: method_map,\n@@ -205,10 +205,6 @@ struct crate_ctxt__ {\n     tcx: ty::ctxt\n }\n \n-pub enum crate_ctxt {\n-    crate_ctxt_(crate_ctxt__)\n-}\n-\n // Functions that write types into the node type table\n pub fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n     debug!(\"write_ty_to_tcx(%d, %s)\", node_id, ppaux::ty_to_str(tcx, ty));\n@@ -233,7 +229,7 @@ pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n     }\n }\n \n-pub fn lookup_def_ccx(ccx: @crate_ctxt, sp: span, id: ast::node_id)\n+pub fn lookup_def_ccx(ccx: @mut CrateCtxt, sp: span, id: ast::node_id)\n                    -> ast::def {\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n@@ -244,7 +240,7 @@ pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n \n pub fn require_same_types(\n     tcx: ty::ctxt,\n-    maybe_infcx: Option<@infer::InferCtxt>,\n+    maybe_infcx: Option<@mut infer::InferCtxt>,\n     t1_is_expected: bool,\n     span: span,\n     t1: ty::t,\n@@ -317,10 +313,9 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     }\n }\n \n-fn check_main_fn_ty(ccx: @crate_ctxt,\n+fn check_main_fn_ty(ccx: @mut CrateCtxt,\n                     main_id: ast::node_id,\n                     main_span: span) {\n-\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n@@ -360,10 +355,10 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     }\n }\n \n-fn check_for_main_fn(ccx: @crate_ctxt) {\n+fn check_for_main_fn(ccx: @mut CrateCtxt) {\n     let tcx = ccx.tcx;\n-    if !tcx.sess.building_library {\n-        match copy tcx.sess.main_fn {\n+    if !*tcx.sess.building_library {\n+        match *tcx.sess.main_fn {\n           Some((id, sp)) => check_main_fn_ty(ccx, id, sp),\n           None => tcx.sess.err(~\"main function not found\")\n         }\n@@ -374,14 +369,13 @@ pub fn check_crate(tcx: ty::ctxt,\n                    trait_map: resolve::TraitMap,\n                    crate: @ast::crate)\n                 -> (method_map, vtable_map) {\n-\n-    let ccx = @crate_ctxt_(crate_ctxt__ {\n+    let ccx = @mut CrateCtxt {\n         trait_map: trait_map,\n         method_map: oldmap::HashMap(),\n         vtable_map: oldmap::HashMap(),\n         coherence_info: @coherence::CoherenceInfo(),\n         tcx: tcx\n-    });\n+    };\n     collect::collect_item_types(ccx, crate);\n     coherence::check_coherence(ccx, crate);\n "}, {"sha": "fab86ef69fe11b4a79ab3674329ad0ba509a7cee", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -19,39 +19,40 @@ use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n \n pub trait region_scope {\n-    fn anon_region(span: span) -> Result<ty::Region, ~str>;\n-    fn self_region(span: span) -> Result<ty::Region, ~str>;\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str>;\n+    pure fn anon_region(span: span) -> Result<ty::Region, ~str>;\n+    pure fn self_region(span: span) -> Result<ty::Region, ~str>;\n+    pure fn named_region(span: span, id: ast::ident)\n+                      -> Result<ty::Region, ~str>;\n }\n \n pub enum empty_rscope { empty_rscope }\n pub impl empty_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Ok(ty::re_static)\n     }\n-    fn self_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n-    fn named_region(_span: span, _id: ast::ident)\n-        -> Result<ty::Region, ~str>\n-    {\n+    pure fn named_region(_span: span, _id: ast::ident)\n+        -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n }\n \n pub enum type_rscope = Option<ty::region_variance>;\n pub impl type_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         match *self {\n           Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n           None => result::Err(~\"to use region types here, the containing \\\n                                 type must be declared with a region bound\")\n         }\n     }\n-    fn self_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(span: span) -> Result<ty::Region, ~str> {\n         self.anon_region(span)\n     }\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n+    pure fn named_region(span: span, id: ast::ident)\n+                      -> Result<ty::Region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             result::Err(~\"named regions other than `self` are not \\\n                           allowed as part of a type declaration\")\n@@ -73,36 +74,42 @@ pub fn in_anon_rscope<RS: region_scope Copy Durable>(self: RS, r: ty::Region)\n     @anon_rscope({anon: r, base: self as region_scope})\n }\n pub impl @anon_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.anon)\n     }\n-    fn self_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n+    pure fn named_region(span: span, id: ast::ident)\n+                      -> Result<ty::Region, ~str> {\n         self.base.named_region(span, id)\n     }\n }\n \n pub struct binding_rscope {\n     base: region_scope,\n-    mut anon_bindings: uint,\n+    anon_bindings: uint,\n }\n+\n pub fn in_binding_rscope<RS: region_scope Copy Durable>(self: RS)\n-    -> @binding_rscope {\n+    -> @mut binding_rscope {\n     let base = self as region_scope;\n-    @binding_rscope { base: base, anon_bindings: 0 }\n+    @mut binding_rscope { base: base, anon_bindings: 0 }\n }\n-pub impl @binding_rscope: region_scope {\n-    fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n-        let idx = self.anon_bindings;\n-        self.anon_bindings += 1;\n-        result::Ok(ty::re_bound(ty::br_anon(idx)))\n+pub impl @mut binding_rscope: region_scope {\n+    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+        // XXX: Unsafe to work around purity\n+        unsafe {\n+            let idx = self.anon_bindings;\n+            self.anon_bindings += 1;\n+            result::Ok(ty::re_bound(ty::br_anon(idx)))\n+        }\n     }\n-    fn self_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    fn named_region(span: span, id: ast::ident) -> Result<ty::Region, ~str> {\n+    pure fn named_region(span: span, id: ast::ident)\n+                      -> Result<ty::Region, ~str> {\n         do self.base.named_region(span, id).chain_err |_e| {\n             result::Ok(ty::re_bound(ty::br_named(id)))\n         }"}, {"sha": "e91fd1c31ca0af1438a519a38d3d4884d3f5dca6", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -209,7 +209,7 @@ pub fn describe_debug_flags() {\n     }\n }\n \n-pub fn run_compiler(args: &~[~str], demitter: diagnostic::emitter) {\n+pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     // Don't display log spew by default. Can override with RUST_LOG.\n     logging::console_off();\n \n@@ -320,7 +320,7 @@ diagnostic emitter which records when we hit a fatal error. If the task\n fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n-pub fn monitor(+f: fn~(diagnostic::emitter)) {\n+pub fn monitor(+f: fn~(diagnostic::Emitter)) {\n     use core::pipes::*;\n     use std::cell::Cell;\n     let (p, ch) = stream();"}, {"sha": "062d784116039c9f866197aabfa3f1ea78648590", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -64,7 +64,7 @@ enum CmdAction {\n \n /// A utility function that hands off a pretty printer to a callback.\n fn with_pp(intr: @token::ident_interner,\n-           cb: fn(pprust::ps, io::Writer)) -> ~str {\n+           cb: fn(@pprust::ps, io::Writer)) -> ~str {\n     do io::with_str_writer |writer| {\n         let pp = pprust::rust_printer(writer, intr);\n \n@@ -203,7 +203,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         };\n         let input = driver::file_input(src_path);\n         let sess = driver::build_session(options, diagnostic::emit);\n-        sess.building_library = true;\n+        *sess.building_library = true;\n         let cfg = driver::build_configuration(sess, binary, input);\n         let outputs = driver::build_output_filenames(\n             input, &None, &None, sess);"}, {"sha": "a3e02ca7070665c7c81c5ab49d5ec0abd242eede", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -72,7 +72,7 @@ pub struct uv_handle_fields {\n    loop_handle: *libc::c_void,\n    type_: handle_type,\n    close_cb: *u8,\n-   mut data: *libc::c_void,\n+   data: *libc::c_void,\n }\n \n // unix size: 8\n@@ -240,10 +240,10 @@ pub struct uv_timer_t {\n \n // unix size: 16\n pub struct sockaddr_in {\n-    mut sin_family: u16,\n-    mut sin_port: u16,\n-    mut sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n-    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8),\n+    sin_family: u16,\n+    sin_port: u16,\n+    sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n+    sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8),\n }\n \n // unix size: 28 .. FIXME #1645"}, {"sha": "8be4b219ded82405fc2aa3f82a5dc40c41bcc137", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -107,15 +107,17 @@ pub enum ast_node {\n }\n \n pub type map = std::oldmap::HashMap<node_id, ast_node>;\n-pub struct ctx {\n-    map: map,\n-    mut path: path,\n-    mut local_id: uint,\n+\n+pub struct Ctx {\n+    map: @map,\n+    path: path,\n+    local_id: uint,\n     diag: span_handler,\n }\n-pub type vt = visit::vt<ctx>;\n \n-pub fn extend(cx: ctx, +elt: ident) -> @path {\n+pub type vt = visit::vt<@mut Ctx>;\n+\n+pub fn extend(cx: @mut Ctx, +elt: ident) -> @path {\n     @(vec::append(cx.path, ~[path_name(elt)]))\n }\n \n@@ -133,31 +135,33 @@ pub fn mk_ast_map_visitor() -> vt {\n }\n \n pub fn map_crate(diag: span_handler, c: crate) -> map {\n-    let cx = ctx {\n-        map: std::oldmap::HashMap(),\n-        mut path: ~[],\n-        mut local_id: 0u,\n+    let cx = @mut Ctx {\n+        map: @std::oldmap::HashMap(),\n+        path: ~[],\n+        local_id: 0u,\n         diag: diag,\n     };\n     visit::visit_crate(c, cx, mk_ast_map_visitor());\n-    cx.map\n+    *cx.map\n }\n \n // Used for items loaded from external crate that are being inlined into this\n // crate.  The `path` should be the path to the item but should not include\n // the item itself.\n pub fn map_decoded_item(diag: span_handler,\n-                        map: map, path: path, ii: inlined_item) {\n+                        map: map,\n+                        path: path,\n+                        ii: inlined_item) {\n     // I believe it is ok for the local IDs of inlined items from other crates\n     // to overlap with the local ids from this crate, so just generate the ids\n     // starting from 0.  (In particular, I think these ids are only used in\n     // alias analysis, which we will not be running on the inlined items, and\n     // even if we did I think it only needs an ordering between local\n     // variables that are simultaneously in scope).\n-    let cx = ctx {\n-        map: map,\n-        mut path: path,\n-        mut local_id: 0,\n+    let cx = @mut Ctx {\n+        map: @map,\n+        path: path,\n+        local_id: 0,\n         diag: diag,\n     };\n     let v = mk_ast_map_visitor();\n@@ -181,7 +185,7 @@ pub fn map_decoded_item(diag: span_handler,\n }\n \n pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-              sp: codemap::span, id: node_id, cx: ctx, v: vt) {\n+              sp: codemap::span, id: node_id, &&cx: @mut Ctx, v: vt) {\n     for decl.inputs.each |a| {\n         cx.map.insert(a.id,\n                       node_arg(/* FIXME (#2543) */\n@@ -208,12 +212,12 @@ pub fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n-pub fn map_block(b: blk, cx: ctx, v: vt) {\n+pub fn map_block(b: blk, &&cx: @mut Ctx, v: vt) {\n     cx.map.insert(b.node.id, node_block(/* FIXME (#2543) */ copy b));\n     visit::visit_block(b, cx, v);\n }\n \n-pub fn number_pat(cx: ctx, pat: @pat) {\n+pub fn number_pat(cx: @mut Ctx, pat: @pat) {\n     do ast_util::walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(*) => {\n@@ -225,24 +229,24 @@ pub fn number_pat(cx: ctx, pat: @pat) {\n     };\n }\n \n-pub fn map_local(loc: @local, cx: ctx, v: vt) {\n+pub fn map_local(loc: @local, &&cx: @mut Ctx, v: vt) {\n     number_pat(cx, loc.node.pat);\n     visit::visit_local(loc, cx, v);\n }\n \n-pub fn map_arm(arm: arm, cx: ctx, v: vt) {\n+pub fn map_arm(arm: arm, &&cx: @mut Ctx, v: vt) {\n     number_pat(cx, arm.pats[0]);\n     visit::visit_arm(arm, cx, v);\n }\n \n pub fn map_method(impl_did: def_id, impl_path: @path,\n-                  m: @method, cx: ctx) {\n+                  m: @method, &&cx: @mut Ctx) {\n     cx.map.insert(m.id, node_method(m, impl_did, impl_path));\n     cx.map.insert(m.self_id, node_local(cx.local_id));\n     cx.local_id += 1u;\n }\n \n-pub fn map_item(i: @item, cx: ctx, v: vt) {\n+pub fn map_item(i: @item, &&cx: @mut Ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n@@ -305,7 +309,7 @@ pub fn map_item(i: @item, cx: ctx, v: vt) {\n }\n \n pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n-                      ident: ast::ident, cx: ctx, _v: vt) {\n+                      ident: ast::ident, cx: @mut Ctx, _v: vt) {\n     let p = extend(cx, ident);\n     // If this is a tuple-like struct, register the constructor.\n     match struct_def.ctor_id {\n@@ -322,12 +326,12 @@ pub fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n     }\n }\n \n-pub fn map_expr(ex: @expr, cx: ctx, v: vt) {\n+pub fn map_expr(ex: @expr, &&cx: @mut Ctx, v: vt) {\n     cx.map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, cx, v);\n }\n \n-pub fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n+pub fn map_stmt(stmt: @stmt, &&cx: @mut Ctx, v: vt) {\n     cx.map.insert(stmt_id(*stmt), node_stmt(stmt));\n     visit::visit_stmt(stmt, cx, v);\n }"}, {"sha": "cd42fc7a953359307226d386939868f652405087", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 69, "deletions": 71, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -23,83 +23,86 @@ use core::dvec::DVec;\n \n use std::term;\n \n-pub type emitter = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n+pub type Emitter = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n                    msg: &str, lvl: level);\n \n \n pub trait span_handler {\n-    fn span_fatal(sp: span, msg: &str) -> !;\n-    fn span_err(sp: span, msg: &str);\n-    fn span_warn(sp: span, msg: &str);\n-    fn span_note(sp: span, msg: &str);\n-    fn span_bug(sp: span, msg: &str) -> !;\n-    fn span_unimpl(sp: span, msg: &str) -> !;\n-    fn handler() -> handler;\n+    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n+    fn span_err(@mut self, sp: span, msg: &str);\n+    fn span_warn(@mut self, sp: span, msg: &str);\n+    fn span_note(@mut self, sp: span, msg: &str);\n+    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n+    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n+    fn handler(@mut self) -> handler;\n }\n \n pub trait handler {\n-    fn fatal(msg: &str) -> !;\n-    fn err(msg: &str);\n-    fn bump_err_count();\n-    fn has_errors() -> bool;\n-    fn abort_if_errors();\n-    fn warn(msg: &str);\n-    fn note(msg: &str);\n-    fn bug(msg: &str) -> !;\n-    fn unimpl(msg: &str) -> !;\n-    fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level);\n+    fn fatal(@mut self, msg: &str) -> !;\n+    fn err(@mut self, msg: &str);\n+    fn bump_err_count(@mut self);\n+    fn has_errors(@mut self) -> bool;\n+    fn abort_if_errors(@mut self);\n+    fn warn(@mut self, msg: &str);\n+    fn note(@mut self, msg: &str);\n+    fn bug(@mut self, msg: &str) -> !;\n+    fn unimpl(@mut self, msg: &str) -> !;\n+    fn emit(@mut self,\n+            cmsp: Option<(@codemap::CodeMap, span)>,\n+            msg: &str,\n+            lvl: level);\n }\n \n-struct handler_t {\n-    mut err_count: uint,\n-    emit: emitter,\n+struct HandlerT {\n+    err_count: uint,\n+    emit: Emitter,\n }\n \n-struct codemap_t {\n+struct CodemapT {\n     handler: handler,\n     cm: @codemap::CodeMap,\n }\n \n-impl codemap_t: span_handler {\n-    fn span_fatal(sp: span, msg: &str) -> ! {\n+impl CodemapT: span_handler {\n+    fn span_fatal(@mut self, sp: span, msg: &str) -> ! {\n         self.handler.emit(Some((self.cm, sp)), msg, fatal);\n         die!();\n     }\n-    fn span_err(sp: span, msg: &str) {\n+    fn span_err(@mut self, sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, error);\n         self.handler.bump_err_count();\n     }\n-    fn span_warn(sp: span, msg: &str) {\n+    fn span_warn(@mut self, sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, warning);\n     }\n-    fn span_note(sp: span, msg: &str) {\n+    fn span_note(@mut self, sp: span, msg: &str) {\n         self.handler.emit(Some((self.cm, sp)), msg, note);\n     }\n-    fn span_bug(sp: span, msg: &str) -> ! {\n+    fn span_bug(@mut self, sp: span, msg: &str) -> ! {\n         self.span_fatal(sp, ice_msg(msg));\n     }\n-    fn span_unimpl(sp: span, msg: &str) -> ! {\n+    fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, ~\"unimplemented \" + msg);\n     }\n-    fn handler() -> handler {\n+    fn handler(@mut self) -> handler {\n         self.handler\n     }\n }\n \n-impl handler_t: handler {\n-    fn fatal(msg: &str) -> ! {\n+impl HandlerT: handler {\n+    fn fatal(@mut self, msg: &str) -> ! {\n         (self.emit)(None, msg, fatal);\n         die!();\n     }\n-    fn err(msg: &str) {\n+    fn err(@mut self, msg: &str) {\n         (self.emit)(None, msg, error);\n         self.bump_err_count();\n     }\n-    fn bump_err_count() {\n+    fn bump_err_count(@mut self) {\n         self.err_count += 1u;\n     }\n-    fn has_errors() -> bool { self.err_count > 0u }\n-    fn abort_if_errors() {\n+    fn has_errors(@mut self) -> bool { self.err_count > 0u }\n+    fn abort_if_errors(@mut self) {\n         let s;\n         match self.err_count {\n           0u => return,\n@@ -111,17 +114,22 @@ impl handler_t: handler {\n         }\n         self.fatal(s);\n     }\n-    fn warn(msg: &str) {\n+    fn warn(@mut self, msg: &str) {\n         (self.emit)(None, msg, warning);\n     }\n-    fn note(msg: &str) {\n+    fn note(@mut self, msg: &str) {\n         (self.emit)(None, msg, note);\n     }\n-    fn bug(msg: &str) -> ! {\n+    fn bug(@mut self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n     }\n-    fn unimpl(msg: &str) -> ! { self.bug(~\"unimplemented \" + msg); }\n-    fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n+    fn unimpl(@mut self, msg: &str) -> ! {\n+        self.bug(~\"unimplemented \" + msg);\n+    }\n+    fn emit(@mut self,\n+            cmsp: Option<(@codemap::CodeMap, span)>,\n+            msg: &str,\n+            lvl: level) {\n         (self.emit)(cmsp, msg, lvl);\n     }\n }\n@@ -132,54 +140,44 @@ pub fn ice_msg(msg: &str) -> ~str {\n \n pub fn mk_span_handler(handler: handler, cm: @codemap::CodeMap)\n                     -> span_handler {\n-    @codemap_t { handler: handler, cm: cm } as span_handler\n+    @mut CodemapT { handler: handler, cm: cm } as @span_handler\n }\n \n-pub fn mk_handler(emitter: Option<emitter>) -> handler {\n-\n-    let emit = match emitter {\n-      Some(e) => e,\n-      None => {\n-        let f = fn@(cmsp: Option<(@codemap::CodeMap, span)>,\n-                    msg: &str, t: level) {\n-            emit(cmsp, msg, t);\n-        };\n-        f\n-      }\n+pub fn mk_handler(emitter: Option<Emitter>) -> @handler {\n+    let emit: Emitter = match emitter {\n+        Some(e) => e,\n+        None => {\n+            let emit: Emitter = |cmsp, msg, t| emit(cmsp, msg, t);\n+            emit\n+        }\n     };\n \n-    @handler_t { mut err_count: 0, emit: emit } as handler\n+    @mut HandlerT { mut err_count: 0, emit: emit } as @handler\n }\n \n+#[deriving_eq]\n pub enum level {\n     fatal,\n     error,\n     warning,\n     note,\n }\n \n-impl level : cmp::Eq {\n-    pure fn eq(&self, other: &level) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &level) -> bool { !(*self).eq(other) }\n-}\n-\n fn diagnosticstr(lvl: level) -> ~str {\n     match lvl {\n-      fatal => ~\"error\",\n-      error => ~\"error\",\n-      warning => ~\"warning\",\n-      note => ~\"note\"\n+        fatal => ~\"error\",\n+        error => ~\"error\",\n+        warning => ~\"warning\",\n+        note => ~\"note\"\n     }\n }\n \n fn diagnosticcolor(lvl: level) -> u8 {\n     match lvl {\n-      fatal => term::color_bright_red,\n-      error => term::color_bright_red,\n-      warning => term::color_bright_yellow,\n-      note => term::color_bright_green\n+        fatal => term::color_bright_red,\n+        error => term::color_bright_red,\n+        warning => term::color_bright_yellow,\n+        note => term::color_bright_green\n     }\n }\n \n@@ -223,9 +221,9 @@ pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n     }\n }\n \n-fn highlight_lines(cm: @codemap::CodeMap, sp: span,\n+fn highlight_lines(cm: @codemap::CodeMap,\n+                   sp: span,\n                    lines: @codemap::FileLines) {\n-\n     let fm = lines.file;\n \n     // arbitrarily only print up to six lines of the error"}, {"sha": "8c3db21f4ea47e146188844a6adb3da7e70cf6b8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -161,54 +161,56 @@ pub fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n // when a macro expansion occurs, the resulting nodes have the backtrace()\n // -> expn_info of their expansion context stored into their span.\n pub trait ext_ctxt {\n-    fn codemap() -> @CodeMap;\n-    fn parse_sess() -> parse::parse_sess;\n-    fn cfg() -> ast::crate_cfg;\n-    fn call_site() -> span;\n-    fn print_backtrace();\n-    fn backtrace() -> Option<@ExpnInfo>;\n-    fn mod_push(mod_name: ast::ident);\n-    fn mod_pop();\n-    fn mod_path() -> ~[ast::ident];\n-    fn bt_push(ei: codemap::ExpnInfo);\n-    fn bt_pop();\n-    fn span_fatal(sp: span, msg: &str) -> !;\n-    fn span_err(sp: span, msg: &str);\n-    fn span_warn(sp: span, msg: &str);\n-    fn span_unimpl(sp: span, msg: &str) -> !;\n-    fn span_bug(sp: span, msg: &str) -> !;\n-    fn bug(msg: &str) -> !;\n-    fn next_id() -> ast::node_id;\n-    pure fn trace_macros() -> bool;\n-    fn set_trace_macros(x: bool);\n+    fn codemap(@mut self) -> @CodeMap;\n+    fn parse_sess(@mut self) -> parse::parse_sess;\n+    fn cfg(@mut self) -> ast::crate_cfg;\n+    fn call_site(@mut self) -> span;\n+    fn print_backtrace(@mut self);\n+    fn backtrace(@mut self) -> Option<@ExpnInfo>;\n+    fn mod_push(@mut self, mod_name: ast::ident);\n+    fn mod_pop(@mut self);\n+    fn mod_path(@mut self) -> ~[ast::ident];\n+    fn bt_push(@mut self, ei: codemap::ExpnInfo);\n+    fn bt_pop(@mut self);\n+    fn span_fatal(@mut self, sp: span, msg: &str) -> !;\n+    fn span_err(@mut self, sp: span, msg: &str);\n+    fn span_warn(@mut self, sp: span, msg: &str);\n+    fn span_unimpl(@mut self, sp: span, msg: &str) -> !;\n+    fn span_bug(@mut self, sp: span, msg: &str) -> !;\n+    fn bug(@mut self, msg: &str) -> !;\n+    fn next_id(@mut self) -> ast::node_id;\n+    pure fn trace_macros(@mut self) -> bool;\n+    fn set_trace_macros(@mut self, x: bool);\n     /* for unhygienic identifier transformation */\n-    fn str_of(id: ast::ident) -> ~str;\n-    fn ident_of(st: ~str) -> ast::ident;\n+    fn str_of(@mut self, id: ast::ident) -> ~str;\n+    fn ident_of(@mut self, st: ~str) -> ast::ident;\n }\n \n pub fn mk_ctxt(parse_sess: parse::parse_sess,\n                cfg: ast::crate_cfg) -> ext_ctxt {\n-    type ctxt_repr = {parse_sess: parse::parse_sess,\n-                      cfg: ast::crate_cfg,\n-                      mut backtrace: Option<@ExpnInfo>,\n-                      mut mod_path: ~[ast::ident],\n-                      mut trace_mac: bool};\n-    impl ctxt_repr: ext_ctxt {\n-        fn codemap() -> @CodeMap { self.parse_sess.cm }\n-        fn parse_sess() -> parse::parse_sess { self.parse_sess }\n-        fn cfg() -> ast::crate_cfg { self.cfg }\n-        fn call_site() -> span {\n+    struct CtxtRepr {\n+        parse_sess: parse::parse_sess,\n+        cfg: ast::crate_cfg,\n+        backtrace: Option<@ExpnInfo>,\n+        mod_path: ~[ast::ident],\n+        trace_mac: bool\n+    }\n+    impl CtxtRepr: ext_ctxt {\n+        fn codemap(@mut self) -> @CodeMap { self.parse_sess.cm }\n+        fn parse_sess(@mut self) -> parse::parse_sess { self.parse_sess }\n+        fn cfg(@mut self) -> ast::crate_cfg { self.cfg }\n+        fn call_site(@mut self) -> span {\n             match self.backtrace {\n                 Some(@ExpandedFrom({call_site: cs, _})) => cs,\n                 None => self.bug(~\"missing top span\")\n             }\n         }\n-        fn print_backtrace() { }\n-        fn backtrace() -> Option<@ExpnInfo> { self.backtrace }\n-        fn mod_push(i: ast::ident) { self.mod_path.push(i); }\n-        fn mod_pop() { self.mod_path.pop(); }\n-        fn mod_path() -> ~[ast::ident] { return self.mod_path; }\n-        fn bt_push(ei: codemap::ExpnInfo) {\n+        fn print_backtrace(@mut self) { }\n+        fn backtrace(@mut self) -> Option<@ExpnInfo> { self.backtrace }\n+        fn mod_push(@mut self, i: ast::ident) { self.mod_path.push(i); }\n+        fn mod_pop(@mut self) { self.mod_path.pop(); }\n+        fn mod_path(@mut self) -> ~[ast::ident] { return self.mod_path; }\n+        fn bt_push(@mut self, ei: codemap::ExpnInfo) {\n             match ei {\n               ExpandedFrom({call_site: cs, callie: ref callie}) => {\n                 self.backtrace =\n@@ -219,7 +221,7 @@ pub fn mk_ctxt(parse_sess: parse::parse_sess,\n               }\n             }\n         }\n-        fn bt_pop() {\n+        fn bt_pop(@mut self) {\n             match self.backtrace {\n               Some(@ExpandedFrom({\n                   call_site: span {expn_info: prev, _}, _\n@@ -229,55 +231,55 @@ pub fn mk_ctxt(parse_sess: parse::parse_sess,\n               _ => self.bug(~\"tried to pop without a push\")\n             }\n         }\n-        fn span_fatal(sp: span, msg: &str) -> ! {\n+        fn span_fatal(@mut self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_fatal(sp, msg);\n         }\n-        fn span_err(sp: span, msg: &str) {\n+        fn span_err(@mut self, sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_err(sp, msg);\n         }\n-        fn span_warn(sp: span, msg: &str) {\n+        fn span_warn(@mut self, sp: span, msg: &str) {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_warn(sp, msg);\n         }\n-        fn span_unimpl(sp: span, msg: &str) -> ! {\n+        fn span_unimpl(@mut self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n         }\n-        fn span_bug(sp: span, msg: &str) -> ! {\n+        fn span_bug(@mut self, sp: span, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.span_bug(sp, msg);\n         }\n-        fn bug(msg: &str) -> ! {\n+        fn bug(@mut self, msg: &str) -> ! {\n             self.print_backtrace();\n             self.parse_sess.span_diagnostic.handler().bug(msg);\n         }\n-        fn next_id() -> ast::node_id {\n+        fn next_id(@mut self) -> ast::node_id {\n             return parse::next_node_id(self.parse_sess);\n         }\n-        pure fn trace_macros() -> bool {\n+        pure fn trace_macros(@mut self) -> bool {\n             self.trace_mac\n         }\n-        fn set_trace_macros(x: bool) {\n+        fn set_trace_macros(@mut self, x: bool) {\n             self.trace_mac = x\n         }\n \n-        fn str_of(id: ast::ident) -> ~str {\n+        fn str_of(@mut self, id: ast::ident) -> ~str {\n             *self.parse_sess.interner.get(id)\n         }\n-        fn ident_of(st: ~str) -> ast::ident {\n+        fn ident_of(@mut self, st: ~str) -> ast::ident {\n             self.parse_sess.interner.intern(@st)\n         }\n     }\n-    let imp: ctxt_repr = {\n+    let imp: @mut CtxtRepr = @mut CtxtRepr {\n         parse_sess: parse_sess,\n         cfg: cfg,\n-        mut backtrace: None,\n-        mut mod_path: ~[],\n-        mut trace_mac: false\n+        backtrace: None,\n+        mod_path: ~[],\n+        trace_mac: false\n     };\n-    move ((move imp) as ext_ctxt)\n+    move ((move imp) as @ext_ctxt)\n }\n \n pub fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, err_msg: ~str) -> ~str {"}, {"sha": "aa9036d295e538f5600b3c1e660538d0f3020e89", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 83, "deletions": 68, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -24,80 +24,90 @@ use core::vec;\n use std;\n use std::oldmap::HashMap;\n \n-enum tt_frame_up { /* to break a circularity */\n-    tt_frame_up(Option<tt_frame>)\n-}\n-\n /* FIXME #2811: figure out how to have a uniquely linked stack, and change to\n    `~` */\n ///an unzipping of `token_tree`s\n-type tt_frame = @{\n+struct TtFrame {\n     readme: ~[ast::token_tree],\n-    mut idx: uint,\n+    idx: uint,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n-    up: tt_frame_up,\n-};\n+    up: Option<@mut TtFrame>,\n+}\n \n-pub type tt_reader = @tt_reader_;\n-pub type tt_reader_ = {\n+pub struct TtReader {\n     sp_diag: span_handler,\n     interner: @ident_interner,\n-    mut cur: tt_frame,\n+    cur: @mut TtFrame,\n     /* for MBE-style macro transcription */\n     interpolations: std::oldmap::HashMap<ident, @named_match>,\n-    mut repeat_idx: ~[uint],\n-    mut repeat_len: ~[uint],\n+    repeat_idx: ~[uint],\n+    repeat_len: ~[uint],\n     /* cached: */\n-    mut cur_tok: Token,\n-    mut cur_span: span\n-};\n+    cur_tok: Token,\n+    cur_span: span\n+}\n \n /** This can do Macro-By-Example transcription. On the other hand, if\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n-pub fn new_tt_reader(sp_diag: span_handler, itr: @ident_interner,\n+pub fn new_tt_reader(sp_diag: span_handler,\n+                     itr: @ident_interner,\n                      interp: Option<std::oldmap::HashMap<ident,@named_match>>,\n                      src: ~[ast::token_tree])\n-                  -> tt_reader {\n-    let r = @{sp_diag: sp_diag, interner: itr,\n-              mut cur: @{readme: src, mut idx: 0u, dotdotdoted: false,\n-                         sep: None, up: tt_frame_up(option::None)},\n-              interpolations: match interp { /* just a convienience */\n-                None => std::oldmap::HashMap(),\n-                Some(x) => x\n-              },\n-              mut repeat_idx: ~[],\n-              mut repeat_len: ~[],\n-              /* dummy values, never read: */\n-              mut cur_tok: EOF,\n-              mut cur_span: dummy_sp()\n-             };\n+                  -> @mut TtReader {\n+    let r = @mut TtReader {\n+        sp_diag: sp_diag,\n+        interner: itr,\n+        mut cur: @mut TtFrame {\n+            readme: src,\n+            idx: 0u,\n+            dotdotdoted: false,\n+            sep: None,\n+            up: option::None\n+        },\n+        interpolations: match interp { /* just a convienience */\n+            None => std::oldmap::HashMap(),\n+            Some(x) => x\n+        },\n+        repeat_idx: ~[],\n+        repeat_len: ~[],\n+        /* dummy values, never read: */\n+        cur_tok: EOF,\n+        cur_span: dummy_sp()\n+    };\n     tt_next_token(r); /* get cur_tok and cur_span set up */\n     return r;\n }\n \n-pure fn dup_tt_frame(&&f: tt_frame) -> tt_frame {\n-    @{readme: f.readme, mut idx: f.idx, dotdotdoted: f.dotdotdoted,\n-      sep: f.sep, up: match f.up {\n-        tt_frame_up(Some(up_frame)) => {\n-          tt_frame_up(Some(dup_tt_frame(up_frame)))\n+pure fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n+    @mut TtFrame {\n+        readme: f.readme,\n+        idx: f.idx,\n+        dotdotdoted: f.dotdotdoted,\n+        sep: f.sep,\n+        up: match f.up {\n+            Some(up_frame) => Some(dup_tt_frame(up_frame)),\n+            None => None\n         }\n-        tt_frame_up(none) => tt_frame_up(none)\n-      }\n-     }\n+    }\n }\n \n-pub pure fn dup_tt_reader(r: &tt_reader_) -> tt_reader {\n-    @{sp_diag: r.sp_diag, interner: r.interner,\n-      mut cur: dup_tt_frame(r.cur),\n-      interpolations: r.interpolations,\n-      mut repeat_idx: copy r.repeat_idx, mut repeat_len: copy r.repeat_len,\n-      mut cur_tok: r.cur_tok, mut cur_span: r.cur_span}\n+pub pure fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n+    @mut TtReader {\n+        sp_diag: r.sp_diag,\n+        interner: r.interner,\n+        cur: dup_tt_frame(r.cur),\n+        interpolations: r.interpolations,\n+        repeat_idx: copy r.repeat_idx,\n+        repeat_len: copy r.repeat_len,\n+        cur_tok: r.cur_tok,\n+        cur_span: r.cur_span\n+    }\n }\n \n \n-pure fn lookup_cur_matched_by_matched(r: &tt_reader_,\n+pure fn lookup_cur_matched_by_matched(r: @mut TtReader,\n                                       start: @named_match) -> @named_match {\n     pure fn red(+ad: @named_match, idx: &uint) -> @named_match {\n         match *ad {\n@@ -111,15 +121,15 @@ pure fn lookup_cur_matched_by_matched(r: &tt_reader_,\n     vec::foldl(start, r.repeat_idx, red)\n }\n \n-fn lookup_cur_matched(r: &tt_reader_, name: ident) -> @named_match {\n+fn lookup_cur_matched(r: @mut TtReader, name: ident) -> @named_match {\n     lookup_cur_matched_by_matched(r, r.interpolations.get(&name))\n }\n enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n-fn lockstep_iter_size(t: token_tree, r: &tt_reader_) -> lis {\n-    fn lis_merge(lhs: lis, rhs: lis, r: &tt_reader_) -> lis {\n+fn lockstep_iter_size(t: token_tree, r: @mut TtReader) -> lis {\n+    fn lis_merge(lhs: lis, rhs: lis, r: @mut TtReader) -> lis {\n         match lhs {\n           lis_unconstrained => rhs,\n           lis_contradiction(_) => lhs,\n@@ -151,19 +161,19 @@ fn lockstep_iter_size(t: token_tree, r: &tt_reader_) -> lis {\n }\n \n \n-pub fn tt_next_token(r: &tt_reader_) -> TokenAndSpan {\n+pub fn tt_next_token(r: @mut TtReader) -> TokenAndSpan {\n     let ret_val = TokenAndSpan { tok: r.cur_tok, sp: r.cur_span };\n     while r.cur.idx >= r.cur.readme.len() {\n         /* done with this set; pop or repeat? */\n         if ! r.cur.dotdotdoted\n             || r.repeat_idx.last() == r.repeat_len.last() - 1 {\n \n             match r.cur.up {\n-              tt_frame_up(None) => {\n+              None => {\n                 r.cur_tok = EOF;\n                 return ret_val;\n               }\n-              tt_frame_up(Some(tt_f)) => {\n+              Some(tt_f) => {\n                 if r.cur.dotdotdoted {\n                     r.repeat_idx.pop();\n                     r.repeat_len.pop();\n@@ -178,8 +188,8 @@ pub fn tt_next_token(r: &tt_reader_) -> TokenAndSpan {\n             r.cur.idx = 0u;\n             r.repeat_idx[r.repeat_idx.len() - 1u] += 1u;\n             match r.cur.sep {\n-              Some(ref tk) => {\n-                r.cur_tok = (*tk); /* repeat same span, I guess */\n+              Some(tk) => {\n+                r.cur_tok = tk; /* repeat same span, I guess */\n                 return ret_val;\n               }\n               None => ()\n@@ -189,20 +199,25 @@ pub fn tt_next_token(r: &tt_reader_) -> TokenAndSpan {\n     loop { /* because it's easiest, this handles `tt_delim` not starting\n     with a `tt_tok`, even though it won't happen */\n         match r.cur.readme[r.cur.idx] {\n-          tt_delim(ref tts) => {\n-            r.cur = @{readme: (*tts), mut idx: 0u, dotdotdoted: false,\n-                      sep: None, up: tt_frame_up(option::Some(r.cur)) };\n+          tt_delim(copy tts) => {\n+            r.cur = @mut TtFrame {\n+                readme: tts,\n+                idx: 0u,\n+                dotdotdoted: false,\n+                sep: None,\n+                up: option::Some(r.cur)\n+            };\n             // if this could be 0-length, we'd need to potentially recur here\n           }\n-          tt_tok(sp, ref tok) => {\n-            r.cur_span = sp; r.cur_tok = (*tok);\n+          tt_tok(sp, copy tok) => {\n+            r.cur_span = sp; r.cur_tok = tok;\n             r.cur.idx += 1u;\n             return ret_val;\n           }\n-          tt_seq(sp, ref tts, ref sep, zerok) => {\n-              match lockstep_iter_size(tt_seq(sp, (*tts), (*sep), zerok), r) {\n-                lis_unconstrained => {\n-                  r.sp_diag.span_fatal(\n+          tt_seq(sp, copy tts, copy sep, zerok) => {\n+            match lockstep_iter_size(tt_seq(sp, tts, sep, zerok), r) {\n+              lis_unconstrained => {\n+                r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n                       ~\"attempted to repeat an expression \\\n                         containing no syntax \\\n@@ -226,12 +241,12 @@ pub fn tt_next_token(r: &tt_reader_) -> TokenAndSpan {\n                 } else {\n                     r.repeat_len.push(len);\n                     r.repeat_idx.push(0u);\n-                    r.cur = @{\n-                        readme: (*tts),\n-                        mut idx: 0u,\n+                    r.cur = @mut TtFrame {\n+                        readme: tts,\n+                        idx: 0u,\n                         dotdotdoted: true,\n-                        sep: (*sep),\n-                        up: tt_frame_up(option::Some(r.cur))\n+                        sep: sep,\n+                        up: option::Some(r.cur)\n                     };\n                 }\n               }"}, {"sha": "a8db06fe08546e71384ddeed46779db9aba32e1c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -14,7 +14,7 @@ use ast;\n use codemap::{BytePos, CharPos, CodeMap, FileMap, Pos};\n use diagnostic;\n use parse::lexer::{is_whitespace, get_str_from, reader};\n-use parse::lexer::{string_reader, bump, is_eof, nextch, TokenAndSpan};\n+use parse::lexer::{StringReader, bump, is_eof, nextch, TokenAndSpan};\n use parse::lexer;\n use parse::token;\n use parse;\n@@ -120,7 +120,7 @@ pub fn strip_doc_comment_decoration(comment: ~str) -> ~str {\n     die!(~\"not a doc-comment: \" + comment);\n }\n \n-fn read_to_eol(rdr: string_reader) -> ~str {\n+fn read_to_eol(rdr: @mut StringReader) -> ~str {\n     let mut val = ~\"\";\n     while rdr.curr != '\\n' && !is_eof(rdr) {\n         str::push_char(&mut val, rdr.curr);\n@@ -130,26 +130,26 @@ fn read_to_eol(rdr: string_reader) -> ~str {\n     return val;\n }\n \n-fn read_one_line_comment(rdr: string_reader) -> ~str {\n+fn read_one_line_comment(rdr: @mut StringReader) -> ~str {\n     let val = read_to_eol(rdr);\n     assert ((val[0] == '/' as u8 && val[1] == '/' as u8) ||\n             (val[0] == '#' as u8 && val[1] == '!' as u8));\n     return val;\n }\n \n-fn consume_non_eol_whitespace(rdr: string_reader) {\n+fn consume_non_eol_whitespace(rdr: @mut StringReader) {\n     while is_whitespace(rdr.curr) && rdr.curr != '\\n' && !is_eof(rdr) {\n         bump(rdr);\n     }\n }\n \n-fn push_blank_line_comment(rdr: string_reader, comments: &mut ~[cmnt]) {\n+fn push_blank_line_comment(rdr: @mut StringReader, comments: &mut ~[cmnt]) {\n     debug!(\">>> blank-line comment\");\n     let v: ~[~str] = ~[];\n     comments.push({style: blank_line, lines: v, pos: rdr.last_pos});\n }\n \n-fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n+fn consume_whitespace_counting_blank_lines(rdr: @mut StringReader,\n                                            comments: &mut ~[cmnt]) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) {\n         if rdr.col == CharPos(0u) && rdr.curr == '\\n' {\n@@ -160,7 +160,7 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n }\n \n \n-fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n+fn read_shebang_comment(rdr: @mut StringReader, code_to_the_left: bool,\n                                             comments: &mut ~[cmnt]) {\n     debug!(\">>> shebang comment\");\n     let p = rdr.last_pos;\n@@ -172,7 +172,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n     });\n }\n \n-fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n+fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n                                           comments: &mut ~[cmnt]) {\n     debug!(\">>> line comments\");\n     let p = rdr.last_pos;\n@@ -221,8 +221,9 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     lines.push(s1);\n }\n \n-fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n-                                          comments: &mut ~[cmnt]) {\n+fn read_block_comment(rdr: @mut StringReader,\n+                      code_to_the_left: bool,\n+                      comments: &mut ~[cmnt]) {\n     debug!(\">>> block comment\");\n     let p = rdr.last_pos;\n     let mut lines: ~[~str] = ~[];\n@@ -280,13 +281,14 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n     comments.push({style: style, lines: lines, pos: p});\n }\n \n-fn peeking_at_comment(rdr: string_reader) -> bool {\n+fn peeking_at_comment(rdr: @mut StringReader) -> bool {\n     return ((rdr.curr == '/' && nextch(rdr) == '/') ||\n          (rdr.curr == '/' && nextch(rdr) == '*')) ||\n          (rdr.curr == '#' && nextch(rdr) == '!');\n }\n \n-fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n+fn consume_comment(rdr: @mut StringReader,\n+                   code_to_the_left: bool,\n                    comments: &mut ~[cmnt]) {\n     debug!(\">>> consume comment\");\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n@@ -309,8 +311,9 @@ pub fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n     let itr = parse::token::mk_fake_ident_interner();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n-    let rdr = lexer::new_low_level_string_reader(\n-        span_diagnostic, filemap, itr);\n+    let rdr = lexer::new_low_level_string_reader(span_diagnostic,\n+                                                 filemap,\n+                                                 itr);\n \n     let mut comments: ~[cmnt] = ~[];\n     let mut literals: ~[lit] = ~[];"}, {"sha": "9ac0093eda64aa03f5dfe9f264dfc51ad1e8ffb7", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 78, "deletions": 79, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -24,45 +24,45 @@ use core::either;\n use core::str;\n use core::u64;\n \n-pub use ext::tt::transcribe::{tt_reader, tt_reader_, new_tt_reader};\n+pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n //use std;\n \n pub trait reader {\n-    fn is_eof(&self) -> bool;\n-    fn next_token(&self) -> TokenAndSpan;\n-    fn fatal(&self,~str) -> !;\n-    fn span_diag(&self) -> span_handler;\n-    pure fn interner(&self) -> @token::ident_interner;\n-    fn peek(&self) -> TokenAndSpan;\n-    fn dup(&self) -> reader;\n+    fn is_eof(@mut self) -> bool;\n+    fn next_token(@mut self) -> TokenAndSpan;\n+    fn fatal(@mut self, ~str) -> !;\n+    fn span_diag(@mut self) -> span_handler;\n+    pure fn interner(@mut self) -> @token::ident_interner;\n+    fn peek(@mut self) -> TokenAndSpan;\n+    fn dup(@mut self) -> reader;\n }\n \n #[deriving_eq]\n pub struct TokenAndSpan {tok: token::Token, sp: span}\n \n-pub type string_reader = @string_reader_;\n-pub type string_reader_ = {\n+pub struct StringReader {\n     span_diagnostic: span_handler,\n     src: @~str,\n     // The absolute offset within the codemap of the next character to read\n-    mut pos: BytePos,\n+    pos: BytePos,\n     // The absolute offset within the codemap of the last character read(curr)\n-    mut last_pos: BytePos,\n+    last_pos: BytePos,\n     // The column of the next character to read\n-    mut col: CharPos,\n+    col: CharPos,\n     // The last character to be read\n-    mut curr: char,\n+    curr: char,\n     filemap: @codemap::FileMap,\n     interner: @token::ident_interner,\n     /* cached: */\n-    mut peek_tok: token::Token,\n-    mut peek_span: span\n-};\n+    peek_tok: token::Token,\n+    peek_span: span\n+}\n \n pub fn new_string_reader(span_diagnostic: span_handler,\n                          filemap: @codemap::FileMap,\n-                         itr: @token::ident_interner) -> string_reader {\n+                         itr: @token::ident_interner)\n+                      -> @mut StringReader {\n     let r = new_low_level_string_reader(span_diagnostic, filemap, itr);\n     string_advance_token(r); /* fill in peek_* */\n     return r;\n@@ -72,77 +72,77 @@ pub fn new_string_reader(span_diagnostic: span_handler,\n pub fn new_low_level_string_reader(span_diagnostic: span_handler,\n                                    filemap: @codemap::FileMap,\n                                    itr: @token::ident_interner)\n-    -> string_reader {\n+                                -> @mut StringReader {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n-    let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n-              mut pos: filemap.start_pos,\n-              mut last_pos: filemap.start_pos,\n-              mut col: CharPos(0),\n-              mut curr: initial_char,\n-              filemap: filemap, interner: itr,\n-              /* dummy values; not read */\n-              mut peek_tok: token::EOF,\n-              mut peek_span: codemap::dummy_sp()};\n+    let r = @mut StringReader {\n+        span_diagnostic: span_diagnostic, src: filemap.src,\n+        pos: filemap.start_pos,\n+        last_pos: filemap.start_pos,\n+        col: CharPos(0),\n+        curr: initial_char,\n+        filemap: filemap, interner: itr,\n+        /* dummy values; not read */\n+        peek_tok: token::EOF,\n+        peek_span: codemap::dummy_sp()\n+    };\n     bump(r);\n     return r;\n }\n \n // duplicating the string reader is probably a bad idea, in\n // that using them will cause interleaved pushes of line\n // offsets to the underlying filemap...\n-fn dup_string_reader(r: &string_reader_) -> string_reader {\n-    @{span_diagnostic: r.span_diagnostic, src: r.src,\n-      mut pos: r.pos,\n-      mut last_pos: r.last_pos,\n-      mut col: r.col, mut curr: r.curr,\n-      filemap: r.filemap, interner: r.interner,\n-      mut peek_tok: r.peek_tok, mut peek_span: r.peek_span}\n+fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n+    @mut StringReader {\n+        span_diagnostic: r.span_diagnostic,\n+        src: r.src,\n+        pos: r.pos,\n+        last_pos: r.last_pos,\n+        col: r.col,\n+        curr: r.curr,\n+        filemap: r.filemap,\n+        interner: r.interner,\n+        peek_tok: r.peek_tok,\n+        peek_span: r.peek_span\n+    }\n }\n \n-impl string_reader_: reader {\n-    fn is_eof(&self) -> bool { is_eof(self) }\n+impl StringReader: reader {\n+    fn is_eof(@mut self) -> bool { is_eof(self) }\n     // return the next token. EFFECT: advances the string_reader.\n-    fn next_token(&self) -> TokenAndSpan {\n+    fn next_token(@mut self) -> TokenAndSpan {\n         let ret_val = TokenAndSpan {tok: self.peek_tok, sp: self.peek_span};\n         string_advance_token(self);\n         return ret_val;\n     }\n-    fn fatal(&self, m: ~str) -> ! {\n+    fn fatal(@mut self, m: ~str) -> ! {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n-    fn span_diag(&self) -> span_handler { self.span_diagnostic }\n-    pure fn interner(&self) -> @token::ident_interner { self.interner }\n-    fn peek(&self) -> TokenAndSpan {\n+    fn span_diag(@mut self) -> span_handler { self.span_diagnostic }\n+    pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {tok: self.peek_tok, sp: self.peek_span}\n     }\n-    fn dup(&self) -> reader { dup_string_reader(self) as reader }\n+    fn dup(@mut self) -> reader { dup_string_reader(self) as reader }\n }\n \n-pub impl tt_reader_: reader {\n-    fn is_eof(&self) -> bool { self.cur_tok == token::EOF }\n-    fn next_token(&self) -> TokenAndSpan {\n-        /* weird resolve bug: if the following `if`, or any of its\n-        statements are removed, we get resolution errors */\n-        if false {\n-            let _ignore_me = 0;\n-            let _me_too = self.cur.readme[self.cur.idx];\n-        }\n-        tt_next_token(self)\n-    }\n-    fn fatal(&self, m: ~str) -> ! {\n+pub impl TtReader: reader {\n+    fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n+    fn next_token(@mut self) -> TokenAndSpan { tt_next_token(self) }\n+    fn fatal(@mut self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n-    fn span_diag(&self) -> span_handler { self.sp_diag }\n-    pure fn interner(&self) -> @token::ident_interner { self.interner }\n-    fn peek(&self) -> TokenAndSpan {\n+    fn span_diag(@mut self) -> span_handler { self.sp_diag }\n+    pure fn interner(@mut self) -> @token::ident_interner { self.interner }\n+    fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan { tok: self.cur_tok, sp: self.cur_span }\n     }\n-    fn dup(&self) -> reader { dup_tt_reader(self) as reader }\n+    fn dup(@mut self) -> reader { dup_tt_reader(self) as reader }\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n-fn string_advance_token(r: &string_reader_) {\n+fn string_advance_token(r: @mut StringReader) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n             r.peek_tok = comment.tok;\n@@ -160,11 +160,11 @@ fn string_advance_token(r: &string_reader_) {\n     }\n }\n \n-fn byte_offset(rdr: &string_reader_) -> BytePos {\n+fn byte_offset(rdr: @mut StringReader) -> BytePos {\n     (rdr.pos - rdr.filemap.start_pos)\n }\n \n-pub fn get_str_from(rdr: &string_reader_, start: BytePos) -> ~str {\n+pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n     unsafe {\n         // I'm pretty skeptical about this subtraction. What if there's a\n         // multi-byte character before the mark?\n@@ -175,7 +175,7 @@ pub fn get_str_from(rdr: &string_reader_, start: BytePos) -> ~str {\n \n // EFFECT: advance the StringReader by one character. If a newline is\n // discovered, add it to the FileMap's list of line start offsets.\n-pub fn bump(rdr: &string_reader_) {\n+pub fn bump(rdr: @mut StringReader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr).to_uint();;\n     if current_byte_offset < (*rdr.src).len() {\n@@ -199,10 +199,10 @@ pub fn bump(rdr: &string_reader_) {\n         rdr.curr = -1 as char;\n     }\n }\n-pub fn is_eof(rdr: &string_reader_) -> bool {\n+pub fn is_eof(rdr: @mut StringReader) -> bool {\n     rdr.curr == -1 as char\n }\n-pub fn nextch(rdr: &string_reader_) -> char {\n+pub fn nextch(rdr: @mut StringReader) -> char {\n     let offset = byte_offset(rdr).to_uint();\n     if offset < (*rdr.src).len() {\n         return str::char_at(*rdr.src, offset);\n@@ -247,17 +247,17 @@ fn is_bin_digit(c: char) -> bool { return c == '0' || c == '1'; }\n \n // EFFECT: eats whitespace and comments.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise.\n-fn consume_whitespace_and_comments(rdr: &string_reader_)\n-    -> Option<TokenAndSpan> {\n+fn consume_whitespace_and_comments(rdr: @mut StringReader)\n+                                -> Option<TokenAndSpan> {\n     while is_whitespace(rdr.curr) { bump(rdr); }\n     return consume_any_line_comment(rdr);\n }\n \n // PRECONDITION: rdr.curr is not whitespace\n // EFFECT: eats any kind of comment.\n // returns a Some(sugared-doc-attr) if one exists, None otherwise\n-fn consume_any_line_comment(rdr: &string_reader_)\n-                                -> Option<TokenAndSpan> {\n+fn consume_any_line_comment(rdr: @mut StringReader)\n+                         -> Option<TokenAndSpan> {\n     if rdr.curr == '/' {\n         match nextch(rdr) {\n           '/' => {\n@@ -299,9 +299,8 @@ fn consume_any_line_comment(rdr: &string_reader_)\n }\n \n // might return a sugared-doc-attr\n-fn consume_block_comment(rdr: &string_reader_)\n-                                -> Option<TokenAndSpan> {\n-\n+fn consume_block_comment(rdr: @mut StringReader)\n+                      -> Option<TokenAndSpan> {\n     // block comments starting with \"/**\" or \"/*!\" are doc-comments\n     if rdr.curr == '*' || rdr.curr == '!' {\n         let start_bpos = rdr.pos - BytePos(2u);\n@@ -338,7 +337,7 @@ fn consume_block_comment(rdr: &string_reader_)\n     return consume_whitespace_and_comments(rdr);\n }\n \n-fn scan_exponent(rdr: &string_reader_) -> Option<~str> {\n+fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n@@ -356,7 +355,7 @@ fn scan_exponent(rdr: &string_reader_) -> Option<~str> {\n     } else { return None::<~str>; }\n }\n \n-fn scan_digits(rdr: &string_reader_, radix: uint) -> ~str {\n+fn scan_digits(rdr: @mut StringReader, radix: uint) -> ~str {\n     let mut rslt = ~\"\";\n     loop {\n         let c = rdr.curr;\n@@ -371,7 +370,7 @@ fn scan_digits(rdr: &string_reader_, radix: uint) -> ~str {\n     };\n }\n \n-fn scan_number(c: char, rdr: &string_reader_) -> token::Token {\n+fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     let mut num_str, base = 10u, c = c, n = nextch(rdr);\n     if c == '0' && n == 'x' {\n         bump(rdr);\n@@ -487,7 +486,7 @@ fn scan_number(c: char, rdr: &string_reader_) -> token::Token {\n     }\n }\n \n-fn scan_numeric_escape(rdr: &string_reader_, n_hex_digits: uint) -> char {\n+fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0, i = n_hex_digits;\n     while i != 0u {\n         let n = rdr.curr;\n@@ -502,7 +501,7 @@ fn scan_numeric_escape(rdr: &string_reader_, n_hex_digits: uint) -> char {\n     return accum_int as char;\n }\n \n-fn next_token_inner(rdr: &string_reader_) -> token::Token {\n+fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n     let mut accum_str = ~\"\";\n     let mut c = rdr.curr;\n     if (c >= 'a' && c <= 'z')\n@@ -527,7 +526,7 @@ fn next_token_inner(rdr: &string_reader_) -> token::Token {\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n     }\n-    fn binop(rdr: &string_reader_, op: token::binop) -> token::Token {\n+    fn binop(rdr: @mut StringReader, op: token::binop) -> token::Token {\n         bump(rdr);\n         if rdr.curr == '=' {\n             bump(rdr);\n@@ -720,7 +719,7 @@ fn next_token_inner(rdr: &string_reader_) -> token::Token {\n     }\n }\n \n-fn consume_whitespace(rdr: &string_reader_) {\n+fn consume_whitespace(rdr: @mut StringReader) {\n     while is_whitespace(rdr.curr) && !is_eof(rdr) { bump(rdr); }\n }\n "}, {"sha": "b8e671b32659e57be9c75aad1270a88eb090cd47", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -15,9 +15,9 @@ use ast::node_id;\n use ast;\n use codemap::{span, CodeMap, FileMap, CharPos, BytePos};\n use codemap;\n-use diagnostic::{span_handler, mk_span_handler, mk_handler, emitter};\n+use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::parser_attr;\n-use parse::lexer::{reader, string_reader};\n+use parse::lexer::{reader, StringReader};\n use parse::parser::Parser;\n use parse::token::{ident_interner, mk_ident_interner};\n use util::interner;\n@@ -54,7 +54,7 @@ pub type parse_sess = @{\n     interner: @ident_interner,\n };\n \n-pub fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n+pub fn new_parse_sess(demitter: Option<Emitter>) -> parse_sess {\n     let cm = @CodeMap::new();\n     return @{cm: cm,\n              mut next_id: 1,\n@@ -166,18 +166,22 @@ pub fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                               +name: ~str, +ss: codemap::FileSubstr,\n                               source: @~str) -> Parser {\n     let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n-    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n+    let srdr = lexer::new_string_reader(sess.span_diagnostic,\n+                                        filemap,\n                                         sess.interner);\n     return Parser(sess, cfg, srdr as reader);\n }\n \n-pub fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                        path: &Path) -> Result<Parser, ~str> {\n+pub fn new_parser_from_file(sess: parse_sess,\n+                            cfg: ast::crate_cfg,\n+                            path: &Path)\n+                         -> Result<Parser, ~str> {\n     match io::read_whole_file_str(path) {\n       result::Ok(move src) => {\n \n           let filemap = sess.cm.new_filemap(path.to_str(), @move src);\n-          let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n+          let srdr = lexer::new_string_reader(sess.span_diagnostic,\n+                                              filemap,\n                                               sess.interner);\n \n           Ok(Parser(sess, cfg, srdr as reader))"}, {"sha": "4b9767ca6c84bd284d3c1e578d81f5216557c658", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 81, "deletions": 92, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -32,7 +32,7 @@ use core::vec;\n  * I am implementing this algorithm because it comes with 20 pages of\n  * documentation explaining its theory, and because it addresses the set of\n  * concerns I've seen other pretty-printers fall down on. Weirdly. Even though\n- * it's 32 years old and not written in Haskell. What can I say?\n+ * it's 32 years old. What can I say?\n  *\n  * Despite some redundancies and quirks in the way it's implemented in that\n  * paper, I've opted to keep the implementation here as similar as I can,\n@@ -69,20 +69,9 @@ use core::vec;\n  * line (which it can't) and so naturally place the content on its own line to\n  * avoid combining it with other lines and making matters even worse.\n  */\n+#[deriving_eq]\n pub enum breaks { consistent, inconsistent, }\n \n-pub impl breaks : cmp::Eq {\n-    pure fn eq(&self, other: &breaks) -> bool {\n-        match ((*self), (*other)) {\n-            (consistent, consistent) => true,\n-            (inconsistent, inconsistent) => true,\n-            (consistent, _) => false,\n-            (inconsistent, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &breaks) -> bool { !(*self).eq(other) }\n-}\n-\n pub type break_t = {offset: int, blank_space: int};\n \n pub type begin_t = {offset: int, breaks: breaks};\n@@ -96,11 +85,11 @@ pub enum token {\n }\n \n pub impl token {\n-    fn is_eof() -> bool {\n-        match self { EOF => true, _ => false }\n+    fn is_eof(&self) -> bool {\n+        match *self { EOF => true, _ => false }\n     }\n-    fn is_hardbreak_tok() -> bool {\n-        match self {\n+    fn is_hardbreak_tok(&self) -> bool {\n+        match *self {\n             BREAK({offset: 0, blank_space: bs }) if bs == size_infinity =>\n                 true,\n             _ =>\n@@ -111,11 +100,11 @@ pub impl token {\n \n pub fn tok_str(++t: token) -> ~str {\n     match t {\n-      STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n-      BREAK(_) => return ~\"BREAK\",\n-      BEGIN(_) => return ~\"BEGIN\",\n-      END => return ~\"END\",\n-      EOF => return ~\"EOF\"\n+        STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n+        BREAK(_) => return ~\"BREAK\",\n+        BEGIN(_) => return ~\"BEGIN\",\n+        END => return ~\"END\",\n+        EOF => return ~\"EOF\"\n     }\n }\n \n@@ -143,30 +132,32 @@ pub type print_stack_elt = {offset: int, pbreak: print_stack_break};\n \n pub const size_infinity: int = 0xffff;\n \n-pub fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n+pub fn mk_printer(out: @io::Writer, linewidth: uint) -> @mut Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer %u\", linewidth);\n     let mut token: ~[token] = vec::from_elem(n, EOF);\n     let mut size: ~[int] = vec::from_elem(n, 0);\n     let mut scan_stack: ~[uint] = vec::from_elem(n, 0u);\n-    printer_(@{out: out,\n-               buf_len: n,\n-               mut margin: linewidth as int,\n-               mut space: linewidth as int,\n-               mut left: 0,\n-               mut right: 0,\n-               mut token: move token,\n-               mut size: move size,\n-               mut left_total: 0,\n-               mut right_total: 0,\n-               mut scan_stack: move scan_stack,\n-               mut scan_stack_empty: true,\n-               mut top: 0,\n-               mut bottom: 0,\n-               print_stack: DVec(),\n-               mut pending_indentation: 0 })\n+    @mut Printer {\n+        out: @out,\n+        buf_len: n,\n+        margin: linewidth as int,\n+        space: linewidth as int,\n+        left: 0,\n+        right: 0,\n+        token: move token,\n+        size: move size,\n+        left_total: 0,\n+        right_total: 0,\n+        scan_stack: move scan_stack,\n+        scan_stack_empty: true,\n+        top: 0,\n+        bottom: 0,\n+        print_stack: @mut ~[],\n+        pending_indentation: 0\n+    }\n }\n \n \n@@ -247,42 +238,38 @@ pub fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n  * the method called 'pretty_print', and the 'PRINT' process is the method\n  * called 'print'.\n  */\n-pub type printer_ = {\n-    out: io::Writer,\n+pub struct Printer {\n+    out: @@io::Writer,\n     buf_len: uint,\n-    mut margin: int, // width of lines we're constrained to\n-    mut space: int, // number of spaces left on line\n-    mut left: uint, // index of left side of input stream\n-    mut right: uint, // index of right side of input stream\n-    mut token: ~[token], // ring-buffr stream goes through\n-    mut size: ~[int], // ring-buffer of calculated sizes\n-    mut left_total: int, // running size of stream \"...left\"\n-    mut right_total: int, // running size of stream \"...right\"\n+    margin: int, // width of lines we're constrained to\n+    space: int, // number of spaces left on line\n+    left: uint, // index of left side of input stream\n+    right: uint, // index of right side of input stream\n+    token: ~[token], // ring-buffr stream goes through\n+    size: ~[int], // ring-buffer of calculated sizes\n+    left_total: int, // running size of stream \"...left\"\n+    right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n     // primary-ring-buffers index of the BEGIN that started the\n     // current block, possibly with the most recent BREAK after that\n     // BEGIN (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    mut scan_stack: ~[uint],\n-    mut scan_stack_empty: bool, // top==bottom disambiguator\n-    mut top: uint, // index of top of scan_stack\n-    mut bottom: uint, // index of bottom of scan_stack\n+    scan_stack: ~[uint],\n+    scan_stack_empty: bool, // top==bottom disambiguator\n+    top: uint, // index of top of scan_stack\n+    bottom: uint, // index of bottom of scan_stack\n     // stack of blocks-in-progress being flushed by print\n-    print_stack: DVec<print_stack_elt>,\n+    print_stack: @mut ~[print_stack_elt],\n     // buffered indentation to avoid writing trailing whitespace\n-    mut pending_indentation: int,\n-};\n-\n-pub enum printer {\n-    printer_(@printer_)\n+    pending_indentation: int,\n }\n \n-pub impl printer {\n-    fn last_token() -> token { self.token[self.right] }\n+pub impl Printer {\n+    fn last_token(&mut self) -> token { self.token[self.right] }\n     // be very careful with this!\n-    fn replace_last_token(t: token) { self.token[self.right] = t; }\n-    fn pretty_print(t: token) {\n+    fn replace_last_token(&mut self, t: token) { self.token[self.right] = t; }\n+    fn pretty_print(&mut self, t: token) {\n         debug!(\"pp ~[%u,%u]\", self.left, self.right);\n         match t {\n           EOF => {\n@@ -350,7 +337,7 @@ pub impl printer {\n           }\n         }\n     }\n-    fn check_stream() {\n+    fn check_stream(&mut self) {\n         debug!(\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n                self.left, self.right, self.left_total, self.right_total);\n         if self.right_total - self.left_total > self.space {\n@@ -366,7 +353,7 @@ pub impl printer {\n             if self.left != self.right { self.check_stream(); }\n         }\n     }\n-    fn scan_push(x: uint) {\n+    fn scan_push(&mut self, x: uint) {\n         debug!(\"scan_push %u\", x);\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n@@ -377,32 +364,32 @@ pub impl printer {\n         }\n         self.scan_stack[self.top] = x;\n     }\n-    fn scan_pop() -> uint {\n+    fn scan_pop(&mut self) -> uint {\n         assert (!self.scan_stack_empty);\n         let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.top += self.buf_len - 1u; self.top %= self.buf_len; }\n         return x;\n     }\n-    fn scan_top() -> uint {\n+    fn scan_top(&mut self) -> uint {\n         assert (!self.scan_stack_empty);\n         return self.scan_stack[self.top];\n     }\n-    fn scan_pop_bottom() -> uint {\n+    fn scan_pop_bottom(&mut self) -> uint {\n         assert (!self.scan_stack_empty);\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else { self.bottom += 1u; self.bottom %= self.buf_len; }\n         return x;\n     }\n-    fn advance_right() {\n+    fn advance_right(&mut self) {\n         self.right += 1u;\n         self.right %= self.buf_len;\n         assert (self.right != self.left);\n     }\n-    fn advance_left(++x: token, L: int) {\n+    fn advance_left(&mut self, ++x: token, L: int) {\n         debug!(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n@@ -420,7 +407,7 @@ pub impl printer {\n             }\n         }\n     }\n-    fn check_stack(k: int) {\n+    fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n             match copy self.token[x] {\n@@ -443,32 +430,32 @@ pub impl printer {\n             }\n         }\n     }\n-    fn print_newline(amount: int) {\n+    fn print_newline(&mut self, amount: int) {\n         debug!(\"NEWLINE %d\", amount);\n-        self.out.write_str(~\"\\n\");\n+        (*self.out).write_str(~\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n-    fn indent(amount: int) {\n+    fn indent(&mut self, amount: int) {\n         debug!(\"INDENT %d\", amount);\n         self.pending_indentation += amount;\n     }\n-    fn get_top() -> print_stack_elt {\n+    fn get_top(&mut self) -> print_stack_elt {\n         let n = self.print_stack.len();\n         if n != 0u {\n             self.print_stack[n - 1u]\n         } else {\n             {offset: 0, pbreak: broken(inconsistent)}\n         }\n     }\n-    fn print_str(s: ~str) {\n+    fn print_str(&mut self, s: ~str) {\n         while self.pending_indentation > 0 {\n-            self.out.write_str(~\" \");\n+            (*self.out).write_str(~\" \");\n             self.pending_indentation -= 1;\n         }\n-        self.out.write_str(s);\n+        (*self.out).write_str(s);\n     }\n-    fn print(x: token, L: int) {\n+    fn print(&mut self, x: token, L: int) {\n         debug!(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n                self.space);\n         log(debug, buf_str(copy self.token,\n@@ -539,39 +526,41 @@ pub impl printer {\n }\n \n // Convenience functions to talk to the printer.\n-pub fn box(p: printer, indent: uint, b: breaks) {\n+pub fn box(p: @mut Printer, indent: uint, b: breaks) {\n     p.pretty_print(BEGIN({offset: indent as int, breaks: b}));\n }\n \n-pub fn ibox(p: printer, indent: uint) { box(p, indent, inconsistent); }\n+pub fn ibox(p: @mut Printer, indent: uint) { box(p, indent, inconsistent); }\n \n-pub fn cbox(p: printer, indent: uint) { box(p, indent, consistent); }\n+pub fn cbox(p: @mut Printer, indent: uint) { box(p, indent, consistent); }\n \n-pub fn break_offset(p: printer, n: uint, off: int) {\n+pub fn break_offset(p: @mut Printer, n: uint, off: int) {\n     p.pretty_print(BREAK({offset: off, blank_space: n as int}));\n }\n \n-pub fn end(p: printer) { p.pretty_print(END); }\n+pub fn end(p: @mut Printer) { p.pretty_print(END); }\n \n-pub fn eof(p: printer) { p.pretty_print(EOF); }\n+pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n \n-pub fn word(p: printer, wrd: ~str) {\n+pub fn word(p: @mut Printer, wrd: ~str) {\n     p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n }\n \n-pub fn huge_word(p: printer, wrd: ~str) {\n+pub fn huge_word(p: @mut Printer, wrd: ~str) {\n     p.pretty_print(STRING(@wrd, size_infinity));\n }\n \n-pub fn zero_word(p: printer, wrd: ~str) { p.pretty_print(STRING(@wrd, 0)); }\n+pub fn zero_word(p: @mut Printer, wrd: ~str) {\n+    p.pretty_print(STRING(@wrd, 0));\n+}\n \n-pub fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n+pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }\n \n-pub fn zerobreak(p: printer) { spaces(p, 0u); }\n+pub fn zerobreak(p: @mut Printer) { spaces(p, 0u); }\n \n-pub fn space(p: printer) { spaces(p, 1u); }\n+pub fn space(p: @mut Printer) { spaces(p, 1u); }\n \n-pub fn hardbreak(p: printer) { spaces(p, size_infinity as uint); }\n+pub fn hardbreak(p: @mut Printer) { spaces(p, size_infinity as uint); }\n \n pub fn hardbreak_tok_offset(off: int) -> token {\n     return BREAK({offset: off, blank_space: size_infinity});"}, {"sha": "dec9f5abd6ab32f810542cb880198d8a47cb6d42", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 170, "deletions": 155, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6647a3402bf75368de1a692370c558d423f36940/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6647a3402bf75368de1a692370c558d423f36940", "patch": "@@ -23,7 +23,7 @@ use parse::classify::{stmt_ends_with_semi};\n use parse::token::ident_interner;\n use parse::{comments, lexer, token};\n use parse;\n-use print::pp::{break_offset, word, printer, space, zerobreak, hardbreak};\n+use print::pp::{break_offset, word, Printer, space, zerobreak, hardbreak};\n use print::pp::{breaks, consistent, inconsistent, eof};\n use print::pp;\n use print::pprust;\n@@ -37,12 +37,12 @@ use core::str;\n use core::u64;\n use core::vec;\n \n-// The ps is stored here to prevent recursive type.\n+// The @ps is stored here to prevent recursive type.\n pub enum ann_node {\n-    node_block(ps, ast::blk),\n-    node_item(ps, @ast::item),\n-    node_expr(ps, @ast::expr),\n-    node_pat(ps, @ast::pat),\n+    node_block(@ps, ast::blk),\n+    node_item(@ps, @ast::item),\n+    node_expr(@ps, @ast::expr),\n+    node_pat(@ps, @ast::pat),\n }\n pub struct pp_ann {\n     pre: fn@(ann_node),\n@@ -54,37 +54,46 @@ pub fn no_ann() -> pp_ann {\n     return pp_ann {pre: ignore, post: ignore};\n }\n \n-pub type ps =\n-    @{s: pp::printer,\n-      cm: Option<@CodeMap>,\n-      intr: @token::ident_interner,\n-      comments: Option<~[comments::cmnt]>,\n-      literals: Option<~[comments::lit]>,\n-      mut cur_cmnt: uint,\n-      mut cur_lit: uint,\n-      boxes: DVec<pp::breaks>,\n-      ann: pp_ann};\n+pub struct CurrentCommentAndLiteral {\n+    cur_cmnt: uint,\n+    cur_lit: uint,\n+}\n+\n+pub struct ps {\n+    s: @mut pp::Printer,\n+    cm: Option<@CodeMap>,\n+    intr: @token::ident_interner,\n+    comments: Option<~[comments::cmnt]>,\n+    literals: Option<~[comments::lit]>,\n+    cur_cmnt_and_lit: @mut CurrentCommentAndLiteral,\n+    boxes: DVec<pp::breaks>,\n+    ann: pp_ann\n+}\n \n-pub fn ibox(s: ps, u: uint) {\n+pub fn ibox(s: @ps, u: uint) {\n     s.boxes.push(pp::inconsistent);\n     pp::ibox(s.s, u);\n }\n \n-pub fn end(s: ps) {\n+pub fn end(s: @ps) {\n     s.boxes.pop();\n     pp::end(s.s);\n }\n \n-pub fn rust_printer(writer: io::Writer, intr: @ident_interner) -> ps {\n-    return @{s: pp::mk_printer(writer, default_columns),\n-             cm: None::<@CodeMap>,\n-             intr: intr,\n-             comments: None::<~[comments::cmnt]>,\n-             literals: None::<~[comments::lit]>,\n-             mut cur_cmnt: 0u,\n-             mut cur_lit: 0u,\n-             boxes: DVec(),\n-             ann: no_ann()};\n+pub fn rust_printer(writer: io::Writer, intr: @ident_interner) -> @ps {\n+    return @ps {\n+        s: pp::mk_printer(writer, default_columns),\n+        cm: None::<@CodeMap>,\n+        intr: intr,\n+        comments: None::<~[comments::cmnt]>,\n+        literals: None::<~[comments::lit]>,\n+        cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n+            cur_cmnt: 0,\n+            cur_lit: 0\n+        },\n+        boxes: DVec(),\n+        ann: no_ann()\n+    };\n }\n \n pub const indent_unit: uint = 4u;\n@@ -101,23 +110,26 @@ pub fn print_crate(cm: @CodeMap, intr: @ident_interner,\n                    out: io::Writer, ann: pp_ann, is_expanded: bool) {\n     let r = comments::gather_comments_and_literals(span_diagnostic,\n                                                    filename, in);\n-    let s =\n-        @{s: pp::mk_printer(out, default_columns),\n-          cm: Some(cm),\n-          intr: intr,\n-          comments: Some(r.cmnts),\n-          // If the code is post expansion, don't use the table of\n-          // literals, since it doesn't correspond with the literals\n-          // in the AST anymore.\n-          literals: if is_expanded { None } else { Some(r.lits) },\n-          mut cur_cmnt: 0u,\n-          mut cur_lit: 0u,\n-          boxes: DVec(),\n-          ann: ann};\n+    let s = @ps {\n+        s: pp::mk_printer(out, default_columns),\n+        cm: Some(cm),\n+        intr: intr,\n+        comments: Some(r.cmnts),\n+        // If the code is post expansion, don't use the table of\n+        // literals, since it doesn't correspond with the literals\n+        // in the AST anymore.\n+        literals: if is_expanded { None } else { Some(r.lits) },\n+        cur_cmnt_and_lit: @mut CurrentCommentAndLiteral {\n+            cur_cmnt: 0,\n+            cur_lit: 0\n+        },\n+        boxes: DVec(),\n+        ann: ann\n+    };\n     print_crate_(s, crate);\n }\n \n-pub fn print_crate_(s: ps, &&crate: @ast::crate) {\n+pub fn print_crate_(s: @ps, &&crate: @ast::crate) {\n     print_mod(s, crate.node.module, crate.node.attrs);\n     print_remaining_comments(s);\n     eof(s.s);\n@@ -194,27 +206,27 @@ pub fn variant_to_str(var: ast::variant, intr: @ident_interner) -> ~str {\n     to_str(var, print_variant, intr)\n }\n \n-pub fn cbox(s: ps, u: uint) {\n+pub fn cbox(s: @ps, u: uint) {\n     s.boxes.push(pp::consistent);\n     pp::cbox(s.s, u);\n }\n \n-pub fn box(s: ps, u: uint, b: pp::breaks) {\n+pub fn box(s: @ps, u: uint, b: pp::breaks) {\n     s.boxes.push(b);\n     pp::box(s.s, u, b);\n }\n \n-pub fn nbsp(s: ps) { word(s.s, ~\" \"); }\n+pub fn nbsp(s: @ps) { word(s.s, ~\" \"); }\n \n-pub fn word_nbsp(s: ps, w: ~str) { word(s.s, w); nbsp(s); }\n+pub fn word_nbsp(s: @ps, w: ~str) { word(s.s, w); nbsp(s); }\n \n-pub fn word_space(s: ps, w: ~str) { word(s.s, w); space(s.s); }\n+pub fn word_space(s: @ps, w: ~str) { word(s.s, w); space(s.s); }\n \n-pub fn popen(s: ps) { word(s.s, ~\"(\"); }\n+pub fn popen(s: @ps) { word(s.s, ~\"(\"); }\n \n-pub fn pclose(s: ps) { word(s.s, ~\")\"); }\n+pub fn pclose(s: @ps) { word(s.s, ~\")\"); }\n \n-pub fn head(s: ps, w: ~str) {\n+pub fn head(s: @ps, w: ~str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -225,15 +237,15 @@ pub fn head(s: ps, w: ~str) {\n     }\n }\n \n-pub fn bopen(s: ps) {\n+pub fn bopen(s: @ps) {\n     word(s.s, ~\"{\");\n     end(s); // close the head-box\n }\n \n-pub fn bclose_(s: ps, span: codemap::span, indented: uint) {\n+pub fn bclose_(s: @ps, span: codemap::span, indented: uint) {\n     bclose_maybe_open(s, span, indented, true);\n }\n-pub fn bclose_maybe_open (s: ps, span: codemap::span, indented: uint,\n+pub fn bclose_maybe_open (s: @ps, span: codemap::span, indented: uint,\n                           close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n@@ -242,29 +254,29 @@ pub fn bclose_maybe_open (s: ps, span: codemap::span, indented: uint,\n         end(s); // close the outer-box\n     }\n }\n-pub fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n+pub fn bclose(s: @ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n-pub fn is_begin(s: ps) -> bool {\n+pub fn is_begin(s: @ps) -> bool {\n     match s.s.last_token() { pp::BEGIN(_) => true, _ => false }\n }\n \n-pub fn is_end(s: ps) -> bool {\n+pub fn is_end(s: @ps) -> bool {\n     match s.s.last_token() { pp::END => true, _ => false }\n }\n \n-pub fn is_bol(s: ps) -> bool {\n+pub fn is_bol(s: @ps) -> bool {\n     return s.s.last_token().is_eof() || s.s.last_token().is_hardbreak_tok();\n }\n \n-pub fn in_cbox(s: ps) -> bool {\n+pub fn in_cbox(s: @ps) -> bool {\n     let len = s.boxes.len();\n     if len == 0u { return false; }\n     return s.boxes[len - 1u] == pp::consistent;\n }\n \n-pub fn hardbreak_if_not_bol(s: ps) { if !is_bol(s) { hardbreak(s.s); } }\n-pub fn space_if_not_bol(s: ps) { if !is_bol(s) { space(s.s); } }\n-pub fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n+pub fn hardbreak_if_not_bol(s: @ps) { if !is_bol(s) { hardbreak(s.s); } }\n+pub fn space_if_not_bol(s: @ps) { if !is_bol(s) { space(s.s); } }\n+pub fn break_offset_if_not_bol(s: @ps, n: uint, off: int) {\n     if !is_bol(s) {\n         break_offset(s.s, n, off);\n     } else {\n@@ -279,15 +291,15 @@ pub fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-pub fn synth_comment(s: ps, text: ~str) {\n+pub fn synth_comment(s: @ps, text: ~str) {\n     word(s.s, ~\"/*\");\n     space(s.s);\n     word(s.s, text);\n     space(s.s);\n     word(s.s, ~\"*/\");\n }\n \n-pub fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n+pub fn commasep<IN>(s: @ps, b: breaks, elts: ~[IN], op: fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n@@ -298,7 +310,7 @@ pub fn commasep<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN)) {\n }\n \n \n-pub fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n+pub fn commasep_cmnt<IN>(s: @ps, b: breaks, elts: ~[IN], op: fn(@ps, IN),\n                          get_span: fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n@@ -317,20 +329,20 @@ pub fn commasep_cmnt<IN>(s: ps, b: breaks, elts: ~[IN], op: fn(ps, IN),\n     end(s);\n }\n \n-pub fn commasep_exprs(s: ps, b: breaks, exprs: ~[@ast::expr]) {\n+pub fn commasep_exprs(s: @ps, b: breaks, exprs: ~[@ast::expr]) {\n     fn expr_span(&&expr: @ast::expr) -> codemap::span { return expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-pub fn print_mod(s: ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n+pub fn print_mod(s: @ps, _mod: ast::_mod, attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n     }\n     for _mod.items.each |item| { print_item(s, *item); }\n }\n \n-pub fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n+pub fn print_foreign_mod(s: @ps, nmod: ast::foreign_mod,\n                          attrs: ~[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n@@ -339,7 +351,7 @@ pub fn print_foreign_mod(s: ps, nmod: ast::foreign_mod,\n     for nmod.items.each |item| { print_foreign_item(s, *item); }\n }\n \n-pub fn print_region(s: ps, prefix: ~str, region: @ast::region, sep: ~str) {\n+pub fn print_region(s: @ps, prefix: ~str, region: @ast::region, sep: ~str) {\n     word(s.s, prefix);\n     match region.node {\n         ast::re_anon => {\n@@ -358,11 +370,11 @@ pub fn print_region(s: ps, prefix: ~str, region: @ast::region, sep: ~str) {\n     word(s.s, sep);\n }\n \n-pub fn print_type(s: ps, &&ty: @ast::Ty) {\n+pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n     print_type_ex(s, ty, false);\n }\n \n-pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n+pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n@@ -387,7 +399,7 @@ pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n       }\n       ast::ty_rec(ref fields) => {\n         word(s.s, ~\"{\");\n-        fn print_field(s: ps, f: ast::ty_field) {\n+        fn print_field(s: @ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mutbl);\n             print_ident(s, f.node.ident);\n@@ -438,7 +450,7 @@ pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n     end(s);\n }\n \n-pub fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n+pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -462,7 +474,7 @@ pub fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     }\n }\n \n-pub fn print_item(s: ps, &&item: @ast::item) {\n+pub fn print_item(s: @ps, &&item: @ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -597,7 +609,7 @@ pub fn print_item(s: ps, &&item: @ast::item) {\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n+pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n                       params: ~[ast::ty_param], ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n     let mut newtype =\n@@ -632,7 +644,7 @@ pub fn print_enum_def(s: ps, enum_definition: ast::enum_def,\n     }\n }\n \n-pub fn print_variants(s: ps,\n+pub fn print_variants(s: @ps,\n                       variants: ~[ast::variant],\n                       span: codemap::span) {\n     bopen(s);\n@@ -665,15 +677,15 @@ pub fn visibility_qualified(vis: ast::visibility, s: ~str) -> ~str {\n     }\n }\n \n-pub fn print_visibility(s: ps, vis: ast::visibility) {\n+pub fn print_visibility(s: @ps, vis: ast::visibility) {\n     match vis {\n         ast::private | ast::public =>\n         word_nbsp(s, visibility_to_str(vis)),\n         ast::inherited => ()\n     }\n }\n \n-pub fn print_struct(s: ps,\n+pub fn print_struct(s: @ps,\n                     struct_def: @ast::struct_def,\n                     tps: ~[ast::ty_param],\n                     ident: ast::ident,\n@@ -742,7 +754,7 @@ pub fn print_struct(s: ps,\n /// appropriate macro, transcribe back into the grammar we just parsed from,\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n-pub fn print_tt(s: ps, tt: ast::token_tree) {\n+pub fn print_tt(s: @ps, tt: ast::token_tree) {\n     match tt {\n       ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n@@ -765,7 +777,7 @@ pub fn print_tt(s: ps, tt: ast::token_tree) {\n     }\n }\n \n-pub fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n+pub fn print_tts(s: @ps, &&tts: &[ast::token_tree]) {\n     ibox(s, 0);\n     for tts.eachi |i, tt| {\n         if i != 0 {\n@@ -776,14 +788,14 @@ pub fn print_tts(s: ps, &&tts: &[ast::token_tree]) {\n     end(s);\n }\n \n-pub fn print_variant(s: ps, v: ast::variant) {\n+pub fn print_variant(s: @ps, v: ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n         ast::tuple_variant_kind(args) => {\n             print_ident(s, v.node.name);\n             if !args.is_empty() {\n                 popen(s);\n-                fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n+                fn print_variant_arg(s: @ps, arg: ast::variant_arg) {\n                     print_type(s, arg.ty);\n                 }\n                 commasep(s, consistent, args, print_variant_arg);\n@@ -808,7 +820,7 @@ pub fn print_variant(s: ps, v: ast::variant) {\n     }\n }\n \n-pub fn print_ty_method(s: ps, m: ast::ty_method) {\n+pub fn print_ty_method(s: @ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n@@ -818,14 +830,14 @@ pub fn print_ty_method(s: ps, m: ast::ty_method) {\n     word(s.s, ~\";\");\n }\n \n-pub fn print_trait_method(s: ps, m: ast::trait_method) {\n+pub fn print_trait_method(s: @ps, m: ast::trait_method) {\n     match m {\n       required(ref ty_m) => print_ty_method(s, (*ty_m)),\n       provided(m)    => print_method(s, m)\n     }\n }\n \n-pub fn print_method(s: ps, meth: @ast::method) {\n+pub fn print_method(s: @ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n@@ -836,7 +848,7 @@ pub fn print_method(s: ps, meth: @ast::method) {\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n \n-pub fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n+pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -847,7 +859,7 @@ pub fn print_outer_attributes(s: ps, attrs: ~[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n+pub fn print_inner_attributes(s: @ps, attrs: ~[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -864,7 +876,7 @@ pub fn print_inner_attributes(s: ps, attrs: ~[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_attribute(s: ps, attr: ast::attribute) {\n+pub fn print_attribute(s: @ps, attr: ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     if attr.node.is_sugared_doc {\n@@ -879,7 +891,7 @@ pub fn print_attribute(s: ps, attr: ast::attribute) {\n }\n \n \n-pub fn print_stmt(s: ps, st: ast::stmt) {\n+pub fn print_stmt(s: @ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     match st.node {\n       ast::stmt_decl(decl, _) => {\n@@ -904,21 +916,21 @@ pub fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n-pub fn print_block(s: ps, blk: ast::blk) {\n+pub fn print_block(s: @ps, blk: ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n-pub fn print_block_unclosed(s: ps, blk: ast::blk) {\n+pub fn print_block_unclosed(s: @ps, blk: ast::blk) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n                                  false);\n }\n \n-pub fn print_block_unclosed_indent(s: ps, blk: ast::blk, indented: uint) {\n+pub fn print_block_unclosed_indent(s: @ps, blk: ast::blk, indented: uint) {\n     print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n                                    false);\n }\n \n-pub fn print_block_with_attrs(s: ps,\n+pub fn print_block_with_attrs(s: @ps,\n                               blk: ast::blk,\n                               attrs: ~[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n@@ -927,15 +939,15 @@ pub fn print_block_with_attrs(s: ps,\n \n pub enum embed_type { block_block_fn, block_normal, }\n \n-pub fn print_possibly_embedded_block(s: ps,\n+pub fn print_possibly_embedded_block(s: @ps,\n                                      blk: ast::blk,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n         s, blk, embedded, indented, ~[], true);\n }\n \n-pub fn print_possibly_embedded_block_(s: ps,\n+pub fn print_possibly_embedded_block_(s: @ps,\n                                       blk: ast::blk,\n                                       embedded: embed_type,\n                                       indented: uint,\n@@ -971,14 +983,14 @@ pub fn print_possibly_embedded_block_(s: ps,\n     (s.ann.post)(ann_node);\n }\n \n-pub fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n+pub fn print_if(s: @ps, test: @ast::expr, blk: ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n     head(s, ~\"if\");\n     if chk { word_nbsp(s, ~\"check\"); }\n     print_expr(s, test);\n     space(s.s);\n     print_block(s, blk);\n-    fn do_else(s: ps, els: Option<@ast::expr>) {\n+    fn do_else(s: @ps, els: Option<@ast::expr>) {\n         match els {\n           Some(_else) => {\n             match _else.node {\n@@ -1011,7 +1023,7 @@ pub fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n     do_else(s, elseopt);\n }\n \n-pub fn print_mac(s: ps, m: ast::mac) {\n+pub fn print_mac(s: @ps, m: ast::mac) {\n     match m.node {\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n@@ -1023,7 +1035,7 @@ pub fn print_mac(s: ps, m: ast::mac) {\n     }\n }\n \n-pub fn print_vstore(s: ps, t: ast::vstore) {\n+pub fn print_vstore(s: @ps, t: ast::vstore) {\n     match t {\n         ast::vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n         ast::vstore_fixed(None) => word(s.s, ~\"_\"),\n@@ -1033,7 +1045,7 @@ pub fn print_vstore(s: ps, t: ast::vstore) {\n     }\n }\n \n-pub fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n+pub fn print_expr_vstore(s: @ps, t: ast::expr_vstore) {\n     match t {\n       ast::expr_vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n       ast::expr_vstore_fixed(None) => word(s.s, ~\"_\"),\n@@ -1051,7 +1063,7 @@ pub fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n     }\n }\n \n-pub fn print_call_pre(s: ps,\n+pub fn print_call_pre(s: @ps,\n                       sugar: ast::CallSugar,\n                       base_args: &mut ~[@ast::expr])\n                    -> Option<@ast::expr> {\n@@ -1068,7 +1080,7 @@ pub fn print_call_pre(s: ps,\n     }\n }\n \n-pub fn print_call_post(s: ps,\n+pub fn print_call_post(s: @ps,\n                        sugar: ast::CallSugar,\n                        blk: &Option<@ast::expr>,\n                        base_args: &mut ~[@ast::expr]) {\n@@ -1095,8 +1107,8 @@ pub fn print_call_post(s: ps,\n     }\n }\n \n-pub fn print_expr(s: ps, &&expr: @ast::expr) {\n-    fn print_field(s: ps, field: ast::field) {\n+pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n+    fn print_field(s: @ps, field: ast::field) {\n         ibox(s, indent_unit);\n         if field.node.mutbl == ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n         print_ident(s, field.node.ident);\n@@ -1446,15 +1458,15 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n     end(s);\n }\n \n-pub fn print_local_decl(s: ps, loc: @ast::local) {\n+pub fn print_local_decl(s: @ps, loc: @ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n       _ => { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n-pub fn print_decl(s: ps, decl: @ast::decl) {\n+pub fn print_decl(s: @ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     match decl.node {\n       ast::decl_local(locs) => {\n@@ -1468,7 +1480,7 @@ pub fn print_decl(s: ps, decl: @ast::decl) {\n             word_nbsp(s, ~\"mut\");\n         }\n \n-        fn print_local(s: ps, &&loc: @ast::local) {\n+        fn print_local(s: @ps, &&loc: @ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1488,18 +1500,18 @@ pub fn print_decl(s: ps, decl: @ast::decl) {\n     }\n }\n \n-pub fn print_ident(s: ps, ident: ast::ident) {\n+pub fn print_ident(s: @ps, ident: ast::ident) {\n     word(s.s, *s.intr.get(ident));\n }\n \n-pub fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n+pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n     word_space(s, ~\"in\");\n     print_expr(s, coll);\n }\n \n-pub fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, &&path: @ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, ~\"::\"); }\n     let mut first = true;\n@@ -1526,15 +1538,15 @@ pub fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     }\n }\n \n-pub fn print_irrefutable_pat(s: ps, &&pat: @ast::pat) {\n+pub fn print_irrefutable_pat(s: @ps, &&pat: @ast::pat) {\n     print_pat(s, pat, false)\n }\n \n-pub fn print_refutable_pat(s: ps, &&pat: @ast::pat) {\n+pub fn print_refutable_pat(s: @ps, &&pat: @ast::pat) {\n     print_pat(s, pat, true)\n }\n \n-pub fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n+pub fn print_pat(s: @ps, &&pat: @ast::pat, refutable: bool) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     (s.ann.pre)(ann_node);\n@@ -1580,7 +1592,7 @@ pub fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_rec(fields, etc) => {\n         word(s.s, ~\"{\");\n-        fn print_field(s: ps, f: ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, ~\":\");\n@@ -1600,7 +1612,7 @@ pub fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n       ast::pat_struct(path, fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");\n-        fn print_field(s: ps, f: ast::field_pat, refutable: bool) {\n+        fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n             word_space(s, ~\":\");\n@@ -1656,7 +1668,7 @@ pub fn print_pat(s: ps, &&pat: @ast::pat, refutable: bool) {\n }\n \n // Returns whether it printed anything\n-pub fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n+pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n     match self_ty {\n       ast::sty_static | ast::sty_by_ref => { return false; }\n       ast::sty_value => { word(s.s, ~\"self\"); }\n@@ -1673,7 +1685,7 @@ pub fn print_self_ty(s: ps, self_ty: ast::self_ty_) -> bool {\n     return true;\n }\n \n-pub fn print_fn(s: ps,\n+pub fn print_fn(s: @ps,\n                 decl: ast::fn_decl,\n                 purity: Option<ast::purity>,\n                 name: ast::ident,\n@@ -1688,7 +1700,7 @@ pub fn print_fn(s: ps,\n     print_fn_args_and_ret(s, decl, opt_self_ty);\n }\n \n-pub fn print_fn_args(s: ps, decl: ast::fn_decl,\n+pub fn print_fn_args(s: @ps, decl: ast::fn_decl,\n                  opt_self_ty: Option<ast::self_ty_>) {\n     // It is unfortunate to duplicate the commasep logic, but we we want the\n     // self type and the args all in the same box.\n@@ -1706,7 +1718,7 @@ pub fn print_fn_args(s: ps, decl: ast::fn_decl,\n     end(s);\n }\n \n-pub fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n+pub fn print_fn_args_and_ret(s: @ps, decl: ast::fn_decl,\n                              opt_self_ty: Option<ast::self_ty_>) {\n     popen(s);\n     print_fn_args(s, decl, opt_self_ty);\n@@ -1723,7 +1735,7 @@ pub fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n     }\n }\n \n-pub fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n+pub fn print_fn_block_args(s: @ps, decl: ast::fn_decl) {\n     word(s.s, ~\"|\");\n     print_fn_args(s, decl, None);\n     word(s.s, ~\"|\");\n@@ -1749,12 +1761,12 @@ pub fn mode_to_str(m: ast::mode) -> ~str {\n     }\n }\n \n-pub fn print_arg_mode(s: ps, m: ast::mode) {\n+pub fn print_arg_mode(s: @ps, m: ast::mode) {\n     let ms = mode_to_str(m);\n     if ms != ~\"\" { word(s.s, ms); }\n }\n \n-pub fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n+pub fn print_bounds(s: @ps, bounds: @~[ast::ty_param_bound]) {\n     if !bounds.is_empty() {\n         word(s.s, ~\":\");\n         let mut first = true;\n@@ -1774,10 +1786,10 @@ pub fn print_bounds(s: ps, bounds: @~[ast::ty_param_bound]) {\n     }\n }\n \n-pub fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n+pub fn print_type_params(s: @ps, &&params: ~[ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, ~\"<\");\n-        fn printParam(s: ps, param: ast::ty_param) {\n+        fn printParam(s: @ps, param: ast::ty_param) {\n             print_ident(s, param.ident);\n             print_bounds(s, param.bounds);\n         }\n@@ -1786,7 +1798,7 @@ pub fn print_type_params(s: ps, &&params: ~[ast::ty_param]) {\n     }\n }\n \n-pub fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n+pub fn print_meta_item(s: @ps, &&item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n       ast::meta_word(ref name) => word(s.s, (*name)),\n@@ -1805,7 +1817,7 @@ pub fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n     end(s);\n }\n \n-pub fn print_view_path(s: ps, &&vp: @ast::view_path) {\n+pub fn print_view_path(s: @ps, &&vp: @ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, path, namespace, _) => {\n         if namespace == ast::module_ns {\n@@ -1835,11 +1847,11 @@ pub fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     }\n }\n \n-pub fn print_view_paths(s: ps, vps: ~[@ast::view_path]) {\n+pub fn print_view_paths(s: @ps, vps: ~[@ast::view_path]) {\n     commasep(s, inconsistent, vps, print_view_path);\n }\n \n-pub fn print_view_item(s: ps, item: @ast::view_item) {\n+pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -1865,20 +1877,20 @@ pub fn print_view_item(s: ps, item: @ast::view_item) {\n     end(s); // end outer head-block\n }\n \n-pub fn print_mutability(s: ps, mutbl: ast::mutability) {\n+pub fn print_mutability(s: @ps, mutbl: ast::mutability) {\n     match mutbl {\n       ast::m_mutbl => word_nbsp(s, ~\"mut\"),\n       ast::m_const => word_nbsp(s, ~\"const\"),\n       ast::m_imm => {/* nothing */ }\n     }\n }\n \n-pub fn print_mt(s: ps, mt: ast::mt) {\n+pub fn print_mt(s: @ps, mt: ast::mt) {\n     print_mutability(s, mt.mutbl);\n     print_type(s, mt.ty);\n }\n \n-pub fn print_arg(s: ps, input: ast::arg) {\n+pub fn print_arg(s: @ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     print_arg_mode(s, input.mode);\n     if input.is_mutbl {\n@@ -1905,7 +1917,7 @@ pub fn print_arg(s: ps, input: ast::arg) {\n     end(s);\n }\n \n-pub fn print_ty_fn(s: ps,\n+pub fn print_ty_fn(s: @ps,\n                    opt_abi: Option<ast::Abi>,\n                    opt_sigil: Option<ast::Sigil>,\n                    opt_region: Option<@ast::region>,\n@@ -1961,7 +1973,7 @@ pub fn print_ty_fn(s: ps,\n     end(s);\n }\n \n-pub fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n+pub fn maybe_print_trailing_comment(s: @ps, span: codemap::span,\n                                     next_pos: Option<BytePos>) {\n     let mut cm;\n     match s.cm { Some(ccm) => cm = ccm, _ => return }\n@@ -1975,26 +1987,29 @@ pub fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n         if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                span_line.line == comment_line.line {\n             print_comment(s, (*cmnt));\n-            s.cur_cmnt += 1u;\n+            s.cur_cmnt_and_lit.cur_cmnt += 1u;\n         }\n       }\n       _ => ()\n     }\n }\n \n-pub fn print_remaining_comments(s: ps) {\n+pub fn print_remaining_comments(s: @ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n     if next_comment(s).is_none() { hardbreak(s.s); }\n     loop {\n         match next_comment(s) {\n-          Some(ref cmnt) => { print_comment(s, (*cmnt)); s.cur_cmnt += 1u; }\n+          Some(ref cmnt) => {\n+            print_comment(s, (*cmnt));\n+            s.cur_cmnt_and_lit.cur_cmnt += 1u;\n+          }\n           _ => break\n         }\n     }\n }\n \n-pub fn print_literal(s: ps, &&lit: @ast::lit) {\n+pub fn print_literal(s: @ps, &&lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     match next_lit(s, lit.span.lo) {\n       Some(ref ltrl) => {\n@@ -2046,13 +2061,13 @@ pub fn lit_to_str(l: @ast::lit) -> ~str {\n     return to_str(l, print_literal, parse::token::mk_fake_ident_interner());\n }\n \n-pub fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n+pub fn next_lit(s: @ps, pos: BytePos) -> Option<comments::lit> {\n     match s.literals {\n       Some(ref lits) => {\n-        while s.cur_lit < vec::len((*lits)) {\n-            let ltrl = (*lits)[s.cur_lit];\n+        while s.cur_cmnt_and_lit.cur_lit < vec::len((*lits)) {\n+            let ltrl = (*lits)[s.cur_cmnt_and_lit.cur_lit];\n             if ltrl.pos > pos { return None; }\n-            s.cur_lit += 1u;\n+            s.cur_cmnt_and_lit.cur_lit += 1u;\n             if ltrl.pos == pos { return Some(ltrl); }\n         }\n         return None;\n@@ -2061,21 +2076,21 @@ pub fn next_lit(s: ps, pos: BytePos) -> Option<comments::lit> {\n     }\n }\n \n-pub fn maybe_print_comment(s: ps, pos: BytePos) {\n+pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n             if (*cmnt).pos < pos {\n                 print_comment(s, (*cmnt));\n-                s.cur_cmnt += 1u;\n+                s.cur_cmnt_and_lit.cur_cmnt += 1u;\n             } else { break; }\n           }\n           _ => break\n         }\n     }\n }\n \n-pub fn print_comment(s: ps, cmnt: comments::cmnt) {\n+pub fn print_comment(s: @ps, cmnt: comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n         assert (vec::len(cmnt.lines) == 1u);\n@@ -2119,40 +2134,40 @@ pub fn print_comment(s: ps, cmnt: comments::cmnt) {\n     }\n }\n \n-pub fn print_string(s: ps, st: ~str) {\n+pub fn print_string(s: @ps, st: ~str) {\n     word(s.s, ~\"\\\"\");\n     word(s.s, str::escape_default(st));\n     word(s.s, ~\"\\\"\");\n }\n \n-pub fn to_str<T>(t: T, f: fn@(ps, T), intr: @ident_interner) -> ~str {\n+pub fn to_str<T>(t: T, f: fn@(@ps, T), intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n         f(s, t);\n         eof(s.s);\n     }\n }\n \n-pub fn next_comment(s: ps) -> Option<comments::cmnt> {\n+pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     match s.comments {\n       Some(ref cmnts) => {\n-        if s.cur_cmnt < vec::len((*cmnts)) {\n-            return Some((*cmnts)[s.cur_cmnt]);\n+        if s.cur_cmnt_and_lit.cur_cmnt < vec::len((*cmnts)) {\n+            return Some((*cmnts)[s.cur_cmnt_and_lit.cur_cmnt]);\n         } else { return None::<comments::cmnt>; }\n       }\n       _ => return None::<comments::cmnt>\n     }\n }\n \n-pub fn print_self_ty_if_static(s: ps,\n+pub fn print_self_ty_if_static(s: @ps,\n                                opt_self_ty: Option<ast::self_ty_>) {\n     match opt_self_ty {\n         Some(ast::sty_static) => { word(s.s, ~\"static \"); }\n         _ => {}\n     }\n }\n \n-pub fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n+pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n     match opt_purity {\n         Some(ast::impure_fn) => { }\n         Some(purity) => {\n@@ -2162,14 +2177,14 @@ pub fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n-pub fn print_opt_abi(s: ps, opt_abi: Option<ast::Abi>) {\n+pub fn print_opt_abi(s: @ps, opt_abi: Option<ast::Abi>) {\n     match opt_abi {\n         Some(ast::RustAbi) => { word_nbsp(s, ~\"extern\"); }\n         None => {}\n     };\n }\n \n-pub fn print_opt_sigil(s: ps, opt_sigil: Option<ast::Sigil>) {\n+pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n     match opt_sigil {\n         Some(ast::BorrowedSigil) => { word(s.s, ~\"&\"); }\n         Some(ast::OwnedSigil) => { word(s.s, ~\"~\"); }\n@@ -2178,7 +2193,7 @@ pub fn print_opt_sigil(s: ps, opt_sigil: Option<ast::Sigil>) {\n     };\n }\n \n-pub fn print_fn_header_info(s: ps,\n+pub fn print_fn_header_info(s: @ps,\n                             opt_sty: Option<ast::self_ty_>,\n                             opt_purity: Option<ast::purity>,\n                             onceness: ast::Onceness,\n@@ -2215,14 +2230,14 @@ pub pure fn onceness_to_str(o: ast::Onceness) -> ~str {\n     }\n }\n \n-pub fn print_purity(s: ps, p: ast::purity) {\n+pub fn print_purity(s: @ps, p: ast::purity) {\n     match p {\n       ast::impure_fn => (),\n       _ => word_nbsp(s, purity_to_str(p))\n     }\n }\n \n-pub fn print_onceness(s: ps, o: ast::Onceness) {\n+pub fn print_onceness(s: @ps, o: ast::Onceness) {\n     match o {\n         ast::Once => { word_nbsp(s, ~\"once\"); }\n         ast::Many => {}"}]}