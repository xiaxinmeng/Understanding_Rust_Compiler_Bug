{"sha": "a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4MjcxY2IzMWYzYjE2ZjY0YTU3MjBmMGNjMzE3YjhkMWNiOGZjZDg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T10:14:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-17T10:14:17Z"}, "message": "simplify parsing blocks a bit", "tree": {"sha": "ad0b025ab9385578ee0fb8d0a7bacf9b80967f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad0b025ab9385578ee0fb8d0a7bacf9b80967f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "html_url": "https://github.com/rust-lang/rust/commit/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d3f48cdaf20d718e711f999573adf3303e9396a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3f48cdaf20d718e711f999573adf3303e9396a", "html_url": "https://github.com/rust-lang/rust/commit/7d3f48cdaf20d718e711f999573adf3303e9396a"}], "stats": {"total": 113, "additions": 56, "deletions": 57}, "files": [{"sha": "d1f27dadf0053c9db3ea06fbee6888b226c70600", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 56, "deletions": 57, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=a8271cb31f3b16f64a5720f0cc317b8d1cb8fcd8", "patch": "@@ -43,65 +43,64 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n     attributes::inner_attributes(p);\n \n     while !p.at(EOF) && !p.at(R_CURLY) {\n-        match p.current() {\n-            // test nocontentexpr\n-            // fn foo(){\n-            //     ;;;some_expr();;;;{;;;};;;;Ok(())\n-            // }\n-            SEMI => p.bump(),\n-            _ => {\n-                // test block_items\n-                // fn a() { fn b() {} }\n-                let m = p.start();\n-                let has_attrs = p.at(POUND);\n-                attributes::outer_attributes(p);\n-                if p.at(LET_KW) {\n-                    let_stmt(p, m);\n+        // test nocontentexpr\n+        // fn foo(){\n+        //     ;;;some_expr();;;;{;;;};;;;Ok(())\n+        // }\n+        if p.current() == SEMI {\n+            p.bump();\n+            continue;\n+        }\n+\n+        // test block_items\n+        // fn a() { fn b() {} }\n+        let m = p.start();\n+        let has_attrs = p.at(POUND);\n+        attributes::outer_attributes(p);\n+        if p.at(LET_KW) {\n+            let_stmt(p, m);\n+            continue;\n+        }\n+\n+        match items::maybe_item(p, items::ItemFlavor::Mod) {\n+            items::MaybeItem::Item(kind) => {\n+                m.complete(p, kind);\n+            }\n+            items::MaybeItem::Modifiers => {\n+                m.abandon(p);\n+                p.error(\"expected an item\");\n+            }\n+            // test pub_expr\n+            // fn foo() { pub 92; } //FIXME\n+            items::MaybeItem::None => {\n+                if has_attrs {\n+                    m.abandon(p);\n+                    p.error(\"expected a let statement or an item after attributes in block\");\n                 } else {\n-                    match items::maybe_item(p, items::ItemFlavor::Mod) {\n-                        items::MaybeItem::Item(kind) => {\n-                            m.complete(p, kind);\n-                        }\n-                        items::MaybeItem::Modifiers => {\n-                            m.abandon(p);\n-                            p.error(\"expected an item\");\n-                        }\n-                        // test pub_expr\n-                        // fn foo() { pub 92; } //FIXME\n-                        items::MaybeItem::None => {\n-                            if has_attrs {\n-                                m.abandon(p);\n-                                p.error(\n-                                    \"expected a let statement or an item after attributes in block\",\n-                                );\n-                            } else {\n-                                let is_blocklike = expressions::expr_stmt(p) == BlockLike::Block;\n-                                if p.at(R_CURLY) {\n-                                    m.abandon(p);\n-                                } else {\n-                                    // test no_semi_after_block\n-                                    // fn foo() {\n-                                    //     if true {}\n-                                    //     loop {}\n-                                    //     match () {}\n-                                    //     while true {}\n-                                    //     for _ in () {}\n-                                    //     {}\n-                                    //     {}\n-                                    //     macro_rules! test {\n-                                    //          () => {}\n-                                    //     }\n-                                    //     test!{}\n-                                    // }\n-                                    if is_blocklike {\n-                                        p.eat(SEMI);\n-                                    } else {\n-                                        p.expect(SEMI);\n-                                    }\n-                                    m.complete(p, EXPR_STMT);\n-                                }\n-                            }\n+                    let is_blocklike = expressions::expr_stmt(p) == BlockLike::Block;\n+                    if p.at(R_CURLY) {\n+                        m.abandon(p);\n+                    } else {\n+                        // test no_semi_after_block\n+                        // fn foo() {\n+                        //     if true {}\n+                        //     loop {}\n+                        //     match () {}\n+                        //     while true {}\n+                        //     for _ in () {}\n+                        //     {}\n+                        //     {}\n+                        //     macro_rules! test {\n+                        //          () => {}\n+                        //     }\n+                        //     test!{}\n+                        // }\n+                        if is_blocklike {\n+                            p.eat(SEMI);\n+                        } else {\n+                            p.expect(SEMI);\n                         }\n+                        m.complete(p, EXPR_STMT);\n                     }\n                 }\n             }"}]}