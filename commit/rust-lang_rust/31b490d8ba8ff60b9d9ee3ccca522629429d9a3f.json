{"sha": "31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "node_id": "C_kwDOAAsO6NoAKDMxYjQ5MGQ4YmE4ZmY2MGI5ZDllZTNjY2NhNTIyNjI5NDI5ZDlhM2Y", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-27T22:00:03Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-28T16:43:35Z"}, "message": "Add enum for `find_width_map_from_snippet`\n\nThis makes the relationship between the vec and the boolean clearer.", "tree": {"sha": "2c71ce5854c7c5669a4a76f0c0ee698f975abbda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c71ce5854c7c5669a4a76f0c0ee698f975abbda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "html_url": "https://github.com/rust-lang/rust/commit/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6c02aad9345925cfed74f86b414c4d0715d381b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c02aad9345925cfed74f86b414c4d0715d381b", "html_url": "https://github.com/rust-lang/rust/commit/e6c02aad9345925cfed74f86b414c4d0715d381b"}], "stats": {"total": 25, "additions": 18, "deletions": 7}, "files": [{"sha": "9f2aaca0acffeb51918141703183caf02e4f6e77", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "patch": "@@ -57,6 +57,13 @@ impl InnerWidthMapping {\n     }\n }\n \n+/// Whether the input string is a literal. If yes, it contains the inner width mappings.\n+#[derive(Clone, PartialEq, Eq)]\n+enum InputStringKind {\n+    NotALiteral,\n+    Literal { width_mappings: Vec<InnerWidthMapping> },\n+}\n+\n /// The type of format string that we are parsing.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum ParseMode {\n@@ -307,7 +314,11 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let (width_map, is_literal) = find_width_map_from_snippet(s, snippet, style);\n+        let input_string_kind = find_width_map_from_snippet(s, snippet, style);\n+        let (width_map, is_literal) = match input_string_kind {\n+            InputStringKind::Literal { width_mappings } => (width_mappings, true),\n+            InputStringKind::NotALiteral => (Vec::new(), false),\n+        };\n         Parser {\n             mode,\n             input: s,\n@@ -848,14 +859,14 @@ fn find_width_map_from_snippet(\n     input: &str,\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n-) -> (Vec<InnerWidthMapping>, bool) {\n+) -> InputStringKind {\n     let snippet = match snippet {\n         Some(ref s) if s.starts_with('\"') || s.starts_with(\"r\\\"\") || s.starts_with(\"r#\") => s,\n-        _ => return (vec![], false),\n+        _ => return InputStringKind::NotALiteral,\n     };\n \n     if str_style.is_some() {\n-        return (vec![], true);\n+        return InputStringKind::Literal { width_mappings: Vec::new() };\n     }\n \n     // Strip quotes.\n@@ -868,15 +879,15 @@ fn find_width_map_from_snippet(\n     // Alternatively, we could just count the trailing newlines and only trim one from the input if they don't match up.\n     let input_no_nl = input.trim_end_matches('\\n');\n     let Ok(unescaped) = unescape_string(snippet) else {\n-        return (vec![], false);\n+        return InputStringKind::NotALiteral;\n     };\n \n     let unescaped_no_nl = unescaped.trim_end_matches('\\n');\n \n     if unescaped_no_nl != input_no_nl {\n         // The source string that we're pointing at isn't our input, so spans pointing at it will be incorrect.\n         // This can for example happen with proc macros that respan generated literals.\n-        return (vec![], false);\n+        return InputStringKind::NotALiteral;\n     }\n \n     let mut s = snippet.char_indices();\n@@ -958,7 +969,7 @@ fn find_width_map_from_snippet(\n         }\n     }\n \n-    (width_mappings, true)\n+    InputStringKind::Literal { width_mappings }\n }\n \n fn unescape_string(string: &str) -> Result<string::String, unescape::EscapeError> {"}]}