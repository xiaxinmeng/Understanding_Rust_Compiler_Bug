{"sha": "16a7d8cc850002b427fdc8d21ccde81caaed7902", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YTdkOGNjODUwMDAyYjQyN2ZkYzhkMjFjY2RlODFjYWFlZDc5MDI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-13T21:09:08Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-22T17:33:00Z"}, "message": "Add `impl Trait` and `dyn Trait` types\n\n - refactor bounds handling in the AST a bit\n - add HIR for bounds\n - add `Ty::Dyn` and `Ty::Opaque` variants and lower `dyn Trait` / `impl Trait`\n   syntax to them", "tree": {"sha": "7f3c43cf9e83d479edc7f9b4849dae5fbd0f356d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f3c43cf9e83d479edc7f9b4849dae5fbd0f356d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16a7d8cc850002b427fdc8d21ccde81caaed7902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16a7d8cc850002b427fdc8d21ccde81caaed7902", "html_url": "https://github.com/rust-lang/rust/commit/16a7d8cc850002b427fdc8d21ccde81caaed7902", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16a7d8cc850002b427fdc8d21ccde81caaed7902/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08e5d394dfbca28b15ed5dc772d55d48f87c3f54", "url": "https://api.github.com/repos/rust-lang/rust/commits/08e5d394dfbca28b15ed5dc772d55d48f87c3f54", "html_url": "https://github.com/rust-lang/rust/commit/08e5d394dfbca28b15ed5dc772d55d48f87c3f54"}], "stats": {"total": 408, "additions": 366, "deletions": 42}, "files": [{"sha": "d6728cc9f4fd6c2bd53efd16f8f7ad081bbe2ea5", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -11,7 +11,7 @@ use crate::{\n     db::{AstDatabase, DefDatabase, HirDatabase},\n     name::SELF_TYPE,\n     path::Path,\n-    type_ref::TypeRef,\n+    type_ref::{TypeBound, TypeRef},\n     AdtDef, AsName, Container, Enum, EnumVariant, Function, HasSource, ImplBlock, Name, Struct,\n     Trait, TypeAlias, Union,\n };\n@@ -35,10 +35,12 @@ pub struct GenericParams {\n \n /// A single predicate from a where clause, i.e. `where Type: Trait`. Combined\n /// where clauses like `where T: Foo + Bar` are turned into multiple of these.\n+/// It might still result in multiple actual predicates though, because of\n+/// associated type bindings like `Iterator<Item = u32>`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n     pub(crate) type_ref: TypeRef,\n-    pub(crate) trait_ref: Path,\n+    pub(crate) bound: TypeBound,\n }\n \n // FIXME: consts can have type parameters from their parents (i.e. associated consts of traits)\n@@ -143,18 +145,8 @@ impl GenericParams {\n             // FIXME: remove this bound\n             return;\n         }\n-        let path = bound\n-            .type_ref()\n-            .and_then(|tr| match tr {\n-                ast::TypeRef::PathType(path) => path.path(),\n-                _ => None,\n-            })\n-            .and_then(Path::from_ast);\n-        let path = match path {\n-            Some(p) => p,\n-            None => return,\n-        };\n-        self.where_predicates.push(WherePredicate { type_ref, trait_ref: path });\n+        let bound = TypeBound::from_ast(bound);\n+        self.where_predicates.push(WherePredicate { type_ref, bound });\n     }\n \n     pub(crate) fn find_by_name(&self, name: &Name) -> Option<&GenericParam> {"}, {"sha": "4e5bdbae46272b59205ede1fcc9a47b7f2a3062e", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -161,14 +161,28 @@ pub enum Ty {\n         name: Name,\n     },\n \n-    /// A bound type variable. Only used during trait resolution to represent\n-    /// Chalk variables.\n+    /// A bound type variable. Used during trait resolution to represent Chalk\n+    /// variables, and in `Dyn` and `Opaque` bounds to represent the `Self` type.\n     Bound(u32),\n \n     /// A type variable used during type checking. Not to be confused with a\n     /// type parameter.\n     Infer(InferTy),\n \n+    /// A trait object (`dyn Trait` or bare `Trait` in pre-2018 Rust).\n+    ///\n+    /// The predicates are quantified over the `Self` type, i.e. `Ty::Bound(0)`\n+    /// represents the `Self` type inside the bounds. This is currently\n+    /// implicit; Chalk has the `Binders` struct to make it explicit, but it\n+    /// didn't seem worth the overhead yet.\n+    Dyn(Arc<[GenericPredicate]>),\n+\n+    /// An opaque type (`impl Trait`).\n+    ///\n+    /// The predicates are quantified over the `Self` type; see `Ty::Dyn` for\n+    /// more.\n+    Opaque(Arc<[GenericPredicate]>),\n+\n     /// A placeholder for a type which could not be computed; this is propagated\n     /// to avoid useless error messages. Doubles as a placeholder where type\n     /// variables are inserted before type checking, since we want to try to\n@@ -194,6 +208,12 @@ impl Substs {\n         Substs(self.0.iter().cloned().take(n).collect::<Vec<_>>().into())\n     }\n \n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        for t in self.0.iter() {\n+            t.walk(f);\n+        }\n+    }\n+\n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n         // Without an Arc::make_mut_slice, we can't avoid the clone here:\n         let mut v: Vec<_> = self.0.iter().cloned().collect();\n@@ -270,6 +290,14 @@ impl TraitRef {\n         });\n         self\n     }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        self.substs.walk(f);\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        self.substs.walk_mut(f);\n+    }\n }\n \n /// Like `generics::WherePredicate`, but with resolved types: A condition on the\n@@ -299,6 +327,20 @@ impl GenericPredicate {\n             GenericPredicate::Error => self,\n         }\n     }\n+\n+    pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk(f),\n+            GenericPredicate::Error => {}\n+        }\n+    }\n+\n+    pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.walk_mut(f),\n+            GenericPredicate::Error => {}\n+        }\n+    }\n }\n \n /// Basically a claim (currently not validated / checked) that the contained\n@@ -386,6 +428,11 @@ impl Ty {\n                     t.walk(f);\n                 }\n             }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                for p in predicates.iter() {\n+                    p.walk(f);\n+                }\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -402,6 +449,13 @@ impl Ty {\n             Ty::UnselectedProjection(p_ty) => {\n                 p_ty.parameters.walk_mut(f);\n             }\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                let mut v: Vec<_> = predicates.iter().cloned().collect();\n+                for p in &mut v {\n+                    p.walk_mut(f);\n+                }\n+                *predicates = v.into();\n+            }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }\n         f(self);\n@@ -669,21 +723,45 @@ impl HirDisplay for Ty {\n             Ty::UnselectedProjection(p_ty) => p_ty.hir_fmt(f)?,\n             Ty::Param { name, .. } => write!(f, \"{}\", name)?,\n             Ty::Bound(idx) => write!(f, \"?{}\", idx)?,\n+            Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n+                match self {\n+                    Ty::Dyn(_) => write!(f, \"dyn \")?,\n+                    Ty::Opaque(_) => write!(f, \"impl \")?,\n+                    _ => unreachable!(),\n+                };\n+                // looping by hand here just to format the bounds in a slightly nicer way\n+                let mut first = true;\n+                for p in predicates.iter() {\n+                    if !first {\n+                        write!(f, \" + \")?;\n+                    }\n+                    first = false;\n+                    match p {\n+                        // don't show the $0 self type\n+                        GenericPredicate::Implemented(trait_ref) => {\n+                            trait_ref.hir_fmt_ext(f, false)?\n+                        }\n+                        GenericPredicate::Error => p.hir_fmt(f)?,\n+                    }\n+                }\n+            }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n             Ty::Infer(..) => write!(f, \"_\")?,\n         }\n         Ok(())\n     }\n }\n \n-impl HirDisplay for TraitRef {\n-    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"{}: {}\",\n-            self.substs[0].display(f.db),\n-            self.trait_.name(f.db).unwrap_or_else(Name::missing)\n-        )?;\n+impl TraitRef {\n+    fn hir_fmt_ext(\n+        &self,\n+        f: &mut HirFormatter<impl HirDatabase>,\n+        with_self_ty: bool,\n+    ) -> fmt::Result {\n+        if with_self_ty {\n+            write!(f, \"{}: \", self.substs[0].display(f.db),)?;\n+        }\n+        write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n         if self.substs.len() > 1 {\n             write!(f, \"<\")?;\n             f.write_joined(&self.substs[1..], \", \")?;\n@@ -693,6 +771,28 @@ impl HirDisplay for TraitRef {\n     }\n }\n \n+impl HirDisplay for TraitRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        self.hir_fmt_ext(f, true)\n+    }\n+}\n+\n+impl HirDisplay for &GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        HirDisplay::hir_fmt(*self, f)\n+    }\n+}\n+\n+impl HirDisplay for GenericPredicate {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n+        match self {\n+            GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n+            GenericPredicate::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl HirDisplay for Obligation {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n         match self {"}, {"sha": "47d1612770c8bd7f847db00eb0fe435695b73e58", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     path::{GenericArg, PathSegment},\n     resolve::{Resolution, Resolver},\n     ty::AdtDef,\n-    type_ref::TypeRef,\n+    type_ref::{TypeBound, TypeRef},\n     BuiltinType, Const, Enum, EnumVariant, Function, HirDatabase, ModuleDef, Path, Static, Struct,\n     StructField, Trait, TypeAlias, Union,\n };\n@@ -58,6 +58,22 @@ impl Ty {\n                 let sig = Substs(inner_tys.into());\n                 Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n+            TypeRef::DynTrait(bounds) => {\n+                let self_ty = Ty::Bound(0);\n+                let predicates = bounds\n+                    .iter()\n+                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .collect::<Vec<_>>();\n+                Ty::Dyn(predicates.into())\n+            }\n+            TypeRef::ImplTrait(bounds) => {\n+                let self_ty = Ty::Bound(0);\n+                let predicates = bounds\n+                    .iter()\n+                    .map(|b| GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone()))\n+                    .collect::<Vec<_>>();\n+                Ty::Opaque(predicates.into())\n+            }\n             TypeRef::Error => Ty::Unknown,\n         }\n     }\n@@ -310,13 +326,46 @@ impl TraitRef {\n         TraitRef { trait_, substs }\n     }\n \n-    pub(crate) fn for_where_predicate(\n+    pub(crate) fn from_where_predicate(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n         pred: &WherePredicate,\n     ) -> Option<TraitRef> {\n         let self_ty = Ty::from_hir(db, resolver, &pred.type_ref);\n-        TraitRef::from_path(db, resolver, &pred.trait_ref, Some(self_ty))\n+        TraitRef::from_type_bound(db, resolver, &pred.bound, self_ty)\n+    }\n+\n+    pub(crate) fn from_type_bound(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        bound: &TypeBound,\n+        self_ty: Ty,\n+    ) -> Option<TraitRef> {\n+        match bound {\n+            TypeBound::Path(path) => TraitRef::from_path(db, resolver, path, Some(self_ty)),\n+            TypeBound::Error => None,\n+        }\n+    }\n+}\n+\n+impl GenericPredicate {\n+    pub(crate) fn from_where_predicate(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        where_predicate: &WherePredicate,\n+    ) -> GenericPredicate {\n+        TraitRef::from_where_predicate(db, &resolver, where_predicate)\n+            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+    }\n+\n+    pub(crate) fn from_type_bound(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        bound: &TypeBound,\n+        self_ty: Ty,\n+    ) -> GenericPredicate {\n+        TraitRef::from_type_bound(db, &resolver, bound, self_ty)\n+            .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n     }\n }\n \n@@ -376,10 +425,7 @@ pub(crate) fn trait_env(\n ) -> Arc<super::TraitEnvironment> {\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| {\n-            TraitRef::for_where_predicate(db, &resolver, pred)\n-                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n-        })\n+        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n \n     Arc::new(super::TraitEnvironment { predicates })\n@@ -393,10 +439,7 @@ pub(crate) fn generic_predicates_query(\n     let resolver = def.resolver(db);\n     let predicates = resolver\n         .where_predicates_in_scope()\n-        .map(|pred| {\n-            TraitRef::for_where_predicate(db, &resolver, pred)\n-                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n-        })\n+        .map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n         .collect::<Vec<_>>();\n     predicates.into()\n }"}, {"sha": "93c62b0d40241195a772534a6cd040742d1b4bd0", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -3273,6 +3273,126 @@ fn test<T: ApplyL>(t: T) {\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+fn impl_trait() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> impl Trait<u64> {}\n+\n+fn test(x: impl Trait<u64>, y: &impl Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[30; 34) 'self': &Self\n+   \u22ee[72; 74) '{}': ()\n+   \u22ee[84; 85) 'x': impl Trait<u64>\n+   \u22ee[104; 105) 'y': &impl Trait<u64>\n+   \u22ee[125; 200) '{     ...o(); }': ()\n+   \u22ee[131; 132) 'x': impl Trait<u64>\n+   \u22ee[138; 139) 'y': &impl Trait<u64>\n+   \u22ee[149; 150) 'z': impl Trait<u64>\n+   \u22ee[153; 156) 'bar': fn bar() -> impl Trait<u64>\n+   \u22ee[153; 158) 'bar()': impl Trait<u64>\n+   \u22ee[164; 165) 'x': impl Trait<u64>\n+   \u22ee[164; 171) 'x.foo()': {unknown}\n+   \u22ee[177; 178) 'y': &impl Trait<u64>\n+   \u22ee[177; 184) 'y.foo()': {unknown}\n+   \u22ee[190; 191) 'z': impl Trait<u64>\n+   \u22ee[190; 197) 'z.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait<T> {\n+    fn foo(&self) -> T;\n+}\n+fn bar() -> dyn Trait<u64> {}\n+\n+fn test(x: dyn Trait<u64>, y: &dyn Trait<u64>) {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[30; 34) 'self': &Self\n+   \u22ee[71; 73) '{}': ()\n+   \u22ee[83; 84) 'x': dyn Trait<u64>\n+   \u22ee[102; 103) 'y': &dyn Trait<u64>\n+   \u22ee[122; 197) '{     ...o(); }': ()\n+   \u22ee[128; 129) 'x': dyn Trait<u64>\n+   \u22ee[135; 136) 'y': &dyn Trait<u64>\n+   \u22ee[146; 147) 'z': dyn Trait<u64>\n+   \u22ee[150; 153) 'bar': fn bar() -> dyn Trait<u64>\n+   \u22ee[150; 155) 'bar()': dyn Trait<u64>\n+   \u22ee[161; 162) 'x': dyn Trait<u64>\n+   \u22ee[161; 168) 'x.foo()': {unknown}\n+   \u22ee[174; 175) 'y': &dyn Trait<u64>\n+   \u22ee[174; 181) 'y.foo()': {unknown}\n+   \u22ee[187; 188) 'z': dyn Trait<u64>\n+   \u22ee[187; 194) 'z.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn dyn_trait_bare() {\n+    assert_snapshot_matches!(\n+        infer(r#\"\n+trait Trait {\n+    fn foo(&self) -> u64;\n+}\n+fn bar() -> Trait {}\n+\n+fn test(x: Trait, y: &Trait) -> u64 {\n+    x;\n+    y;\n+    let z = bar();\n+    x.foo();\n+    y.foo();\n+    z.foo();\n+}\n+\"#),\n+        @r###\"\n+   \u22ee\n+   \u22ee[27; 31) 'self': &Self\n+   \u22ee[61; 63) '{}': ()\n+   \u22ee[73; 74) 'x': {unknown}\n+   \u22ee[83; 84) 'y': &{unknown}\n+   \u22ee[101; 176) '{     ...o(); }': ()\n+   \u22ee[107; 108) 'x': {unknown}\n+   \u22ee[114; 115) 'y': &{unknown}\n+   \u22ee[125; 126) 'z': {unknown}\n+   \u22ee[129; 132) 'bar': fn bar() -> {unknown}\n+   \u22ee[129; 134) 'bar()': {unknown}\n+   \u22ee[140; 141) 'x': {unknown}\n+   \u22ee[140; 147) 'x.foo()': {unknown}\n+   \u22ee[153; 154) 'y': &{unknown}\n+   \u22ee[153; 160) 'y.foo()': {unknown}\n+   \u22ee[166; 167) 'z': {unknown}\n+   \u22ee[166; 173) 'z.foo()': {unknown}\n+    \"###\n+    );\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "2ebc06135a13bd3fa2e286f5ef53671042e5261d", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -80,7 +80,9 @@ impl ToChalk for Ty {\n             // FIXME this is clearly incorrect, but probably not too incorrect\n             // and I'm not sure what to actually do with Ty::Unknown\n             // maybe an alternative would be `for<T> T`? (meaningless in rust, but expressible in chalk's Ty)\n-            Ty::Unknown => {\n+            //\n+            // FIXME also dyn and impl Trait are currently handled like Unknown because Chalk doesn't have them yet\n+            Ty::Unknown | Ty::Dyn(_) | Ty::Opaque(_) => {\n                 PlaceholderIndex { ui: UniverseIndex::ROOT, idx: usize::max_value() }.to_ty()\n             }\n         }"}, {"sha": "949fa7a2c7fba371e1d344e27dca0fa900e5ce6b", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -1,7 +1,7 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n-use ra_syntax::ast::{self, TypeAscriptionOwner};\n+use ra_syntax::ast::{self, TypeAscriptionOwner, TypeBoundsOwner};\n \n use crate::Path;\n \n@@ -49,8 +49,16 @@ pub enum TypeRef {\n     /// A fn pointer. Last element of the vector is the return type.\n     Fn(Vec<TypeRef>),\n     // For\n-    // ImplTrait,\n-    // DynTrait,\n+    ImplTrait(Vec<TypeBound>),\n+    DynTrait(Vec<TypeBound>),\n+    Error,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeBound {\n+    Path(Path),\n+    // also for<> bounds\n+    // also Lifetimes\n     Error,\n }\n \n@@ -95,8 +103,12 @@ impl TypeRef {\n             }\n             // for types are close enough for our purposes to the inner type for now...\n             ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n-            ast::TypeRef::ImplTraitType(_inner) => TypeRef::Error,\n-            ast::TypeRef::DynTraitType(_inner) => TypeRef::Error,\n+            ast::TypeRef::ImplTraitType(inner) => {\n+                TypeRef::ImplTrait(type_bounds_from_ast(inner.type_bound_list()))\n+            }\n+            ast::TypeRef::DynTraitType(inner) => {\n+                TypeRef::DynTrait(type_bounds_from_ast(inner.type_bound_list()))\n+            }\n         }\n     }\n \n@@ -112,3 +124,32 @@ impl TypeRef {\n         TypeRef::Tuple(Vec::new())\n     }\n }\n+\n+pub(crate) fn type_bounds_from_ast(type_bounds_opt: Option<ast::TypeBoundList>) -> Vec<TypeBound> {\n+    if let Some(type_bounds) = type_bounds_opt {\n+        type_bounds.bounds().map(TypeBound::from_ast).collect()\n+    } else {\n+        vec![]\n+    }\n+}\n+\n+impl TypeBound {\n+    pub(crate) fn from_ast(node: ast::TypeBound) -> Self {\n+        match node.kind() {\n+            Some(ast::TypeBoundKind::PathType(path_type)) => {\n+                let path = match path_type.path() {\n+                    Some(p) => p,\n+                    None => return TypeBound::Error,\n+                };\n+                let path = match Path::from_ast(path) {\n+                    Some(p) => p,\n+                    None => return TypeBound::Error,\n+                };\n+                TypeBound::Path(path)\n+            }\n+            Some(ast::TypeBoundKind::ForType(_)) | Some(ast::TypeBoundKind::Lifetime(_)) | None => {\n+                TypeBound::Error\n+            }\n+        }\n+    }\n+}"}, {"sha": "afdfca66e310683dd1f93802d51a4152a4bab4c8", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -15,7 +15,7 @@ use crate::{\n \n pub use self::{\n     expr_extensions::{ArrayExprKind, BinOp, ElseBranch, LiteralKind, PrefixOp},\n-    extensions::{FieldKind, PathSegmentKind, SelfParamKind, StructKind},\n+    extensions::{FieldKind, PathSegmentKind, SelfParamKind, StructKind, TypeBoundKind},\n     generated::*,\n     tokens::*,\n     traits::*,"}, {"sha": "8de979ca206395b6320b0024ed4179972a7e4882", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16a7d8cc850002b427fdc8d21ccde81caaed7902/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=16a7d8cc850002b427fdc8d21ccde81caaed7902", "patch": "@@ -399,3 +399,29 @@ impl ast::TraitDef {\n         self.syntax().children_with_tokens().any(|t| t.kind() == T![auto])\n     }\n }\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum TypeBoundKind {\n+    /// Trait\n+    PathType(ast::PathType),\n+    /// for<'a> ...\n+    ForType(ast::ForType),\n+    /// 'a\n+    Lifetime(ast::SyntaxToken),\n+}\n+\n+impl ast::TypeBound {\n+    pub fn kind(&self) -> Option<TypeBoundKind> {\n+        let child = self.syntax.first_child_or_token()?;\n+        match child.kind() {\n+            PATH_TYPE => Some(TypeBoundKind::PathType(\n+                ast::PathType::cast(child.into_node().unwrap()).unwrap(),\n+            )),\n+            FOR_TYPE => Some(TypeBoundKind::ForType(\n+                ast::ForType::cast(child.into_node().unwrap()).unwrap(),\n+            )),\n+            LIFETIME => Some(TypeBoundKind::Lifetime(child.into_token().unwrap())),\n+            _ => unreachable!(),\n+        }\n+    }\n+}"}]}