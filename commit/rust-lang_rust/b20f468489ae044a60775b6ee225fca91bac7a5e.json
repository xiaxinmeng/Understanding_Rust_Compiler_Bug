{"sha": "b20f468489ae044a60775b6ee225fca91bac7a5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMGY0Njg0ODlhZTA0NGE2MDc3NWI2ZWUyMjVmY2E5MWJhYzdhNWU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-18T12:04:12Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-01-24T16:51:35Z"}, "message": "BTreeMap: lightly refactor the split_off implementation", "tree": {"sha": "c49747129f4c60f107437f57c931348d43bf13d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c49747129f4c60f107437f57c931348d43bf13d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b20f468489ae044a60775b6ee225fca91bac7a5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b20f468489ae044a60775b6ee225fca91bac7a5e", "html_url": "https://github.com/rust-lang/rust/commit/b20f468489ae044a60775b6ee225fca91bac7a5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b20f468489ae044a60775b6ee225fca91bac7a5e/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85e355ea9bd86ac6580a5d422a65dbf689845808", "url": "https://api.github.com/repos/rust-lang/rust/commits/85e355ea9bd86ac6580a5d422a65dbf689845808", "html_url": "https://github.com/rust-lang/rust/commit/85e355ea9bd86ac6580a5d422a65dbf689845808"}], "stats": {"total": 109, "additions": 67, "deletions": 42}, "files": [{"sha": "1a62fc682e62ebc887f3f549dcc91875c19c3837", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b20f468489ae044a60775b6ee225fca91bac7a5e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20f468489ae044a60775b6ee225fca91bac7a5e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=b20f468489ae044a60775b6ee225fca91bac7a5e", "patch": "@@ -21,6 +21,14 @@ use Entry::*;\n /// We might temporarily have fewer elements during methods.\n pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n \n+// A tree in a `BTreeMap` is a tree in the `node` module with addtional invariants:\n+// - Keys must appear in ascending order (according to the key's type).\n+// - If the root node is internal, it must contain at least 1 element.\n+// - Every non-root node contains at least MIN_LEN elements.\n+//\n+// An empty map may be represented both by the absense of a root node or by a\n+// root node that is an empty leaf.\n+\n /// A map based on a B-Tree.\n ///\n /// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n@@ -1100,20 +1108,12 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let total_num = self.len();\n         let left_root = self.root.as_mut().unwrap(); // unwrap succeeds because not empty\n \n-        let mut right = Self::new();\n-        let right_root = Self::ensure_is_owned(&mut right.root);\n-\n-        left_root.split_off(right_root, key);\n+        let right_root = left_root.split_off(key);\n \n-        if left_root.height() < right_root.height() {\n-            self.length = left_root.reborrow().calc_length();\n-            right.length = total_num - self.len();\n-        } else {\n-            right.length = right_root.reborrow().calc_length();\n-            self.length = total_num - right.len();\n-        }\n+        let (new_left_len, right_len) = Root::calc_split_length(total_num, &left_root, &right_root);\n+        self.length = new_left_len;\n \n-        right\n+        BTreeMap { root: Some(right_root), length: right_len }\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element should be removed."}, {"sha": "1921982464ae460b0da06227bbae7ac20a8c194e", "filename": "library/alloc/src/collections/btree/split.rs", "status": "modified", "additions": 55, "deletions": 30, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b20f468489ae044a60775b6ee225fca91bac7a5e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b20f468489ae044a60775b6ee225fca91bac7a5e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=b20f468489ae044a60775b6ee225fca91bac7a5e", "patch": "@@ -4,46 +4,71 @@ use super::search::SearchResult::*;\n use core::borrow::Borrow;\n \n impl<K, V> Root<K, V> {\n-    pub fn split_off<Q: ?Sized + Ord>(&mut self, right_root: &mut Self, key: &Q)\n+    /// Calculates the length of both trees that result from splitting up\n+    /// a given number of distinct key-value pairs.\n+    pub fn calc_split_length(\n+        total_num: usize,\n+        root_a: &Root<K, V>,\n+        root_b: &Root<K, V>,\n+    ) -> (usize, usize) {\n+        let (length_a, length_b);\n+        if root_a.height() < root_b.height() {\n+            length_a = root_a.reborrow().calc_length();\n+            length_b = total_num - length_a;\n+            debug_assert_eq!(length_b, root_b.reborrow().calc_length());\n+        } else {\n+            length_b = root_b.reborrow().calc_length();\n+            length_a = total_num - length_b;\n+            debug_assert_eq!(length_a, root_a.reborrow().calc_length());\n+        }\n+        (length_a, length_b)\n+    }\n+\n+    /// Split off a tree with key-value pairs at and after the given key.\n+    /// The result is meaningful only if the tree is ordered by key,\n+    /// and if the ordering of `Q` corresponds to that of `K`.\n+    /// If `self` respects all `BTreeMap` tree invariants, then both\n+    /// `self` and the returned tree will respect those invariants.\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n         K: Borrow<Q>,\n     {\n-        debug_assert!(right_root.height() == 0);\n-        debug_assert!(right_root.len() == 0);\n-\n         let left_root = self;\n-        for _ in 0..left_root.height() {\n-            right_root.push_internal_level();\n-        }\n-\n-        {\n-            let mut left_node = left_root.borrow_mut();\n-            let mut right_node = right_root.borrow_mut();\n-\n-            loop {\n-                let mut split_edge = match left_node.search_node(key) {\n-                    // key is going to the right tree\n-                    Found(kv) => kv.left_edge(),\n-                    GoDown(edge) => edge,\n-                };\n-\n-                split_edge.move_suffix(&mut right_node);\n-\n-                match (split_edge.force(), right_node.force()) {\n-                    (Internal(edge), Internal(node)) => {\n-                        left_node = edge.descend();\n-                        right_node = node.first_edge().descend();\n-                    }\n-                    (Leaf(_), Leaf(_)) => {\n-                        break;\n-                    }\n-                    _ => unreachable!(),\n+        let mut right_root = Root::new_pillar(left_root.height());\n+        let mut left_node = left_root.borrow_mut();\n+        let mut right_node = right_root.borrow_mut();\n+\n+        loop {\n+            let mut split_edge = match left_node.search_node(key) {\n+                // key is going to the right tree\n+                Found(kv) => kv.left_edge(),\n+                GoDown(edge) => edge,\n+            };\n+\n+            split_edge.move_suffix(&mut right_node);\n+\n+            match (split_edge.force(), right_node.force()) {\n+                (Internal(edge), Internal(node)) => {\n+                    left_node = edge.descend();\n+                    right_node = node.first_edge().descend();\n                 }\n+                (Leaf(_), Leaf(_)) => break,\n+                _ => unreachable!(),\n             }\n         }\n \n         left_root.fix_right_border();\n         right_root.fix_left_border();\n+        right_root\n+    }\n+\n+    /// Creates a tree consisting of empty nodes.\n+    fn new_pillar(height: usize) -> Self {\n+        let mut root = Root::new();\n+        for _ in 0..height {\n+            root.push_internal_level();\n+        }\n+        root\n     }\n \n     /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty."}]}