{"sha": "226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNmVlN2Q4NmYyZDhlYWIxNzUzN2I1YmEzYTM5M2RmYWUxY2YxNGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T19:46:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:58Z"}, "message": "libcore: Remove mutable fields from task::spawn", "tree": {"sha": "212d8bada0fb0504d2b105a9237ba6cab3c45728", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/212d8bada0fb0504d2b105a9237ba6cab3c45728"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "html_url": "https://github.com/rust-lang/rust/commit/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dc1c2976d03b6e0fc114019341be51593ef49b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dc1c2976d03b6e0fc114019341be51593ef49b2", "html_url": "https://github.com/rust-lang/rust/commit/4dc1c2976d03b6e0fc114019341be51593ef49b2"}], "stats": {"total": 131, "additions": 85, "deletions": 46}, "files": [{"sha": "63959edb42761218a67cec7b99836cdec6b6855a", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 68, "deletions": 42, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "patch": "@@ -72,6 +72,7 @@\n \n #[doc(hidden)]; // FIXME #3538\n \n+use cast::transmute;\n use cast;\n use cell::Cell;\n use container::Map;\n@@ -117,10 +118,10 @@ pub fn taskset_each(tasks: &TaskSet, blk: &fn(v: *rust_task) -> bool) {\n struct TaskGroupData {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n-    mut members:     TaskSet,\n+    members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n-    mut descendants: TaskSet,\n+    descendants: TaskSet,\n }\n type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n \n@@ -145,11 +146,11 @@ struct AncestorNode {\n     // Hence we assert that this counter monotonically decreases as we\n     // approach the tail of the list.\n     // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n-    generation:       uint,\n-    // Should really be an immutable non-option. This way appeases borrowck.\n-    mut parent_group: Option<TaskGroupArc>,\n+    generation:     uint,\n+    // Should really be a non-option. This way appeases borrowck.\n+    parent_group:   Option<TaskGroupArc>,\n     // Recursive rest of the list.\n-    mut ancestors:    AncestorList,\n+    ancestors:      AncestorList,\n }\n \n struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n@@ -301,22 +302,26 @@ fn each_ancestor(list:        &mut AncestorList,\n \n // One of these per task.\n struct TCB {\n-    me:            *rust_task,\n+    me:         *rust_task,\n     // List of tasks with whose fates this one's is intertwined.\n-    tasks:         TaskGroupArc, // 'none' means the group has failed.\n+    tasks:      TaskGroupArc, // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    mut ancestors: AncestorList,\n-    is_main:       bool,\n-    notifier:      Option<AutoNotify>,\n+    ancestors:  AncestorList,\n+    is_main:    bool,\n+    notifier:   Option<AutoNotify>,\n }\n \n impl Drop for TCB {\n     // Runs on task exit.\n     fn finalize(&self) {\n         unsafe {\n+            let this: &mut TCB = transmute(self);\n+\n             // If we are failing, the whole taskgroup needs to die.\n             if rt::rust_task_is_unwinding(self.me) {\n-                for self.notifier.each |x| { x.failed = true; }\n+                for this.notifier.each_mut |x| {\n+                    x.failed = true;\n+                }\n                 // Take everybody down with us.\n                 do access_group(&self.tasks) |tg| {\n                     kill_taskgroup(tg, self.me, self.is_main);\n@@ -331,16 +336,21 @@ impl Drop for TCB {\n             // with our own taskgroup, so long as both happen before we die.\n             // We remove ourself from every ancestor we can, so no cleanup; no\n             // break.\n-            for each_ancestor(&mut self.ancestors, None) |ancestor_group| {\n+            for each_ancestor(&mut this.ancestors, None) |ancestor_group| {\n                 leave_taskgroup(ancestor_group, self.me, false);\n             };\n         }\n     }\n }\n \n-fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n-       is_main: bool, notifier: Option<AutoNotify>) -> TCB {\n-    for notifier.each |x| { x.failed = false; }\n+fn TCB(me: *rust_task,\n+       tasks: TaskGroupArc,\n+       ancestors: AncestorList,\n+       is_main: bool,\n+       mut notifier: Option<AutoNotify>) -> TCB {\n+    for notifier.each_mut |x| {\n+        x.failed = false;\n+    }\n \n     TCB {\n         me: me,\n@@ -353,7 +363,7 @@ fn TCB(me: *rust_task, tasks: TaskGroupArc, ancestors: AncestorList,\n \n struct AutoNotify {\n     notify_chan: Chan<TaskResult>,\n-    mut failed:  bool,\n+    failed: bool,\n }\n \n impl Drop for AutoNotify {\n@@ -375,9 +385,12 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n-        let group = newstate.unwrap();\n-        taskset_insert(if is_member { &mut group.members }\n-                       else         { &mut group.descendants }, me);\n+        let mut group = newstate.unwrap();\n+        taskset_insert(if is_member {\n+            &mut group.members\n+        } else {\n+            &mut group.descendants\n+        }, me);\n         *state = Some(group);\n         true\n     } else {\n@@ -391,9 +404,12 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n-        let group = newstate.unwrap();\n-        taskset_remove(if is_member { &mut group.members }\n-                       else         { &mut group.descendants }, me);\n+        let mut group = newstate.unwrap();\n+        taskset_remove(if is_member {\n+            &mut group.members\n+        } else {\n+            &mut group.descendants\n+        }, me);\n         *state = Some(group);\n     }\n }\n@@ -451,23 +467,30 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         /*##################################################################*\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n-        let spawner_group = match local_get(OldHandle(spawner), taskgroup_key!()) {\n-            None => {\n-                // Main task, doing first spawn ever. Lazily initialise here.\n-                let mut members = new_taskset();\n-                taskset_insert(&mut members, spawner);\n-                let tasks = unstable::exclusive(Some(TaskGroupData {\n-                    members: members,\n-                    descendants: new_taskset(),\n-                }));\n-                // Main task/group has no ancestors, no notifier, etc.\n-                let group =\n-                    @TCB(spawner, tasks, AncestorList(None), true, None);\n-                local_set(OldHandle(spawner), taskgroup_key!(), group);\n-                group\n-            }\n-            Some(group) => group\n-        };\n+        let mut spawner_group: @@mut TCB =\n+            match local_get(OldHandle(spawner), taskgroup_key!()) {\n+                None => {\n+                    // Main task, doing first spawn ever. Lazily initialise\n+                    // here.\n+                    let mut members = new_taskset();\n+                    taskset_insert(&mut members, spawner);\n+                    let tasks = unstable::exclusive(Some(TaskGroupData {\n+                        members: members,\n+                        descendants: new_taskset(),\n+                    }));\n+                    // Main task/group has no ancestors, no notifier, etc.\n+                    let group = @@mut TCB(spawner,\n+                                          tasks,\n+                                          AncestorList(None),\n+                                          true,\n+                                          None);\n+                    local_set(OldHandle(spawner), taskgroup_key!(), group);\n+                    group\n+                }\n+                Some(group) => group\n+            };\n+        let spawner_group: &mut TCB = *spawner_group;\n+\n         /*##################################################################*\n          * Step 2. Process spawn options for child.\n          *##################################################################*/\n@@ -624,8 +647,11 @@ fn spawn_raw_oldsched(opts: TaskOpts, f: ~fn()) {\n             };\n \n             if enlist_many(child, &child_arc, &mut ancestors) {\n-                let group = @TCB(child, child_arc, ancestors,\n-                                 is_main, notifier);\n+                let group = @@mut TCB(child,\n+                                      child_arc,\n+                                      ancestors,\n+                                      is_main,\n+                                      notifier);\n                 unsafe {\n                     local_set(OldHandle(child), taskgroup_key!(), group);\n                 }"}, {"sha": "7f42507bfd5f46b293dc8c8c6d17d8d3f6750e1c", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226ee7d86f2d8eab17537b5ba3a393dfae1cf14e/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=226ee7d86f2d8eab17537b5ba3a393dfae1cf14e", "patch": "@@ -235,17 +235,30 @@ pub impl LittleLock {\n     }\n }\n \n-struct ExData<T> { lock: LittleLock, failed: bool, data: T, }\n+struct ExData<T> {\n+    lock: LittleLock,\n+    failed: bool,\n+    data: T,\n+}\n+\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n-pub struct Exclusive<T> { x: SharedMutableState<ExData<T>> }\n+pub struct Exclusive<T> {\n+    x: SharedMutableState<ExData<T>>\n+}\n \n pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n-        lock: LittleLock(), failed: false, data: user_data\n+        lock: LittleLock(),\n+        failed: false,\n+        data: user_data\n     };\n-    Exclusive { x: unsafe { shared_mutable_state(data) } }\n+    Exclusive {\n+        x: unsafe {\n+            shared_mutable_state(data)\n+        }\n+    }\n }\n \n impl<T:Owned> Clone for Exclusive<T> {"}]}