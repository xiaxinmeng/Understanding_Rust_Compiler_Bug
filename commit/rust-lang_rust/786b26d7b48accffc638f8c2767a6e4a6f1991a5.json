{"sha": "786b26d7b48accffc638f8c2767a6e4a6f1991a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NmIyNmQ3YjQ4YWNjZmZjNjM4ZjhjMjc2N2E2ZTRhNmYxOTkxYTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-17T01:39:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-17T01:39:59Z"}, "message": "Auto merge of #33491 - arielb1:obligation-jungle, r=nikomatsakis\n\nReplace the obligation forest with a graph\n\nIn the presence of caching, arbitrary nodes in the obligation forest can be merged, which makes it a general graph. Handle it as such, using cycle-detection algorithms in the processing.\n\nI should do performance measurements sometime.\n\nThis was pretty much written as a proof-of-concept. Please help me write this in a less-ugly way. I should also add comments explaining what is going on.\n\nr? @nikomatsakis", "tree": {"sha": "32f3c04dd6a7bc2eb5a4988764afee6392d3e0cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32f3c04dd6a7bc2eb5a4988764afee6392d3e0cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/786b26d7b48accffc638f8c2767a6e4a6f1991a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/786b26d7b48accffc638f8c2767a6e4a6f1991a5", "html_url": "https://github.com/rust-lang/rust/commit/786b26d7b48accffc638f8c2767a6e4a6f1991a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/786b26d7b48accffc638f8c2767a6e4a6f1991a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6a400175cc230008a5094a8bbb44a3794f0465", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6a400175cc230008a5094a8bbb44a3794f0465", "html_url": "https://github.com/rust-lang/rust/commit/cd6a400175cc230008a5094a8bbb44a3794f0465"}, {"sha": "65ad935737138eb307fdd01279ba5553a047bb6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/65ad935737138eb307fdd01279ba5553a047bb6c", "html_url": "https://github.com/rust-lang/rust/commit/65ad935737138eb307fdd01279ba5553a047bb6c"}], "stats": {"total": 1832, "additions": 794, "deletions": 1038}, "files": [{"sha": "847aade630f6eafd1753162c02c058704edcafd9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 43, "deletions": 284, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -26,11 +26,11 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{InferCtxt, TypeOrigin};\n-use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable, TypeVariants};\n+use infer::{InferCtxt};\n+use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n-use ty::subst::{self, ParamSpace, Subst};\n+use ty::subst::{self, Subst};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cmp;\n@@ -61,128 +61,6 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-// Enum used to differentiate the \"big\" and \"little\" weights.\n-enum Weight {\n-    Coarse,\n-    Precise,\n-}\n-\n-trait AssociatedWeight {\n-    fn get_weight(&self) -> (u32, u32);\n-}\n-\n-impl<'a> AssociatedWeight for TypeVariants<'a> {\n-    // Left number is for \"global\"/\"big\" weight and right number is for better precision.\n-    fn get_weight(&self) -> (u32, u32) {\n-        match *self {\n-            TypeVariants::TyBool => (1, 1),\n-            TypeVariants::TyChar => (1, 2),\n-            TypeVariants::TyStr => (1, 3),\n-\n-            TypeVariants::TyInt(_) => (2, 1),\n-            TypeVariants::TyUint(_) => (2, 2),\n-            TypeVariants::TyFloat(_) => (2, 3),\n-            TypeVariants::TyRawPtr(_) => (2, 4),\n-\n-            TypeVariants::TyEnum(_, _) => (3, 1),\n-            TypeVariants::TyStruct(_, _) => (3, 2),\n-            TypeVariants::TyBox(_) => (3, 3),\n-            TypeVariants::TyTuple(_) => (3, 4),\n-\n-            TypeVariants::TyArray(_, _) => (4, 1),\n-            TypeVariants::TySlice(_) => (4, 2),\n-\n-            TypeVariants::TyRef(_, _) => (5, 1),\n-            TypeVariants::TyFnDef(_, _, _) => (5, 2),\n-            TypeVariants::TyFnPtr(_) => (5, 3),\n-\n-            TypeVariants::TyTrait(_) => (6, 1),\n-\n-            TypeVariants::TyClosure(_, _) => (7, 1),\n-\n-            TypeVariants::TyProjection(_) => (8, 1),\n-            TypeVariants::TyParam(_) => (8, 2),\n-            TypeVariants::TyInfer(_) => (8, 3),\n-\n-            TypeVariants::TyError => (9, 1),\n-        }\n-    }\n-}\n-\n-// The \"closer\" the types are, the lesser the weight.\n-fn get_weight_diff(a: &ty::TypeVariants, b: &TypeVariants, weight: Weight) -> u32 {\n-    let (w1, w2) = match weight {\n-        Weight::Coarse => (a.get_weight().0, b.get_weight().0),\n-        Weight::Precise => (a.get_weight().1, b.get_weight().1),\n-    };\n-    if w1 < w2 {\n-        w2 - w1\n-    } else {\n-        w1 - w2\n-    }\n-}\n-\n-// Once we have \"globally matching\" types, we need to run another filter on them.\n-//\n-// In the function `get_best_matching_type`, we got the types which might fit the\n-// most to the type we're looking for. This second filter now intends to get (if\n-// possible) the type which fits the most.\n-//\n-// For example, the trait expects an `usize` and here you have `u32` and `i32`.\n-// Obviously, the \"correct\" one is `u32`.\n-fn filter_matching_types<'tcx>(weights: &[(usize, u32)],\n-                               imps: &[(DefId, subst::Substs<'tcx>)],\n-                               trait_types: &[ty::Ty<'tcx>])\n-                               -> usize {\n-    let matching_weight = weights[0].1;\n-    let iter = weights.iter().filter(|&&(_, weight)| weight == matching_weight);\n-    let mut filtered_weights = vec!();\n-\n-    for &(pos, _) in iter {\n-        let mut weight = 0;\n-        for (type_to_compare, original_type) in imps[pos].1\n-                                                         .types\n-                                                         .get_slice(ParamSpace::TypeSpace)\n-                                                         .iter()\n-                                                         .zip(trait_types.iter()) {\n-            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, Weight::Precise);\n-        }\n-        filtered_weights.push((pos, weight));\n-    }\n-    filtered_weights.sort_by(|a, b| a.1.cmp(&b.1));\n-    filtered_weights[0].0\n-}\n-\n-// Here, we run the \"big\" filter. Little example:\n-//\n-// We receive a `String`, an `u32` and an `i32`.\n-// The trait expected an `usize`.\n-// From human point of view, it's easy to determine that `String` doesn't correspond to\n-// the expected type at all whereas `u32` and `i32` could.\n-//\n-// This first filter intends to only keep the types which match the most.\n-fn get_best_matching_type<'tcx>(imps: &[(DefId, subst::Substs<'tcx>)],\n-                                trait_types: &[ty::Ty<'tcx>]) -> usize {\n-    let mut weights = vec!();\n-    for (pos, imp) in imps.iter().enumerate() {\n-        let mut weight = 0;\n-        for (type_to_compare, original_type) in imp.1\n-                                                   .types\n-                                                   .get_slice(ParamSpace::TypeSpace)\n-                                                   .iter()\n-                                                   .zip(trait_types.iter()) {\n-            weight += get_weight_diff(&type_to_compare.sty, &original_type.sty, Weight::Coarse);\n-        }\n-        weights.push((pos, weight));\n-    }\n-    weights.sort_by(|a, b| a.1.cmp(&b.1));\n-    if weights[0].1 == weights[1].1 {\n-        filter_matching_types(&weights, &imps, trait_types)\n-    } else {\n-        weights[0].0\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n         for error in errors {\n@@ -272,72 +150,53 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         substs\n     }\n \n-    fn get_current_failing_impl(&self,\n-                                trait_ref: &TraitRef<'tcx>,\n-                                obligation: &PredicateObligation<'tcx>)\n-                                -> Option<(DefId, subst::Substs<'tcx>)> {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.self_ty(),\n-                                              true);\n-        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n+    fn impl_with_self_type_of(&self,\n+                              trait_ref: ty::PolyTraitRef<'tcx>,\n+                              obligation: &PredicateObligation<'tcx>)\n+                              -> Option<DefId>\n+    {\n+        let tcx = self.tcx;\n+        let mut result = None;\n+        let mut ambiguous = false;\n \n-        match simp {\n-            Some(_) => {\n-                let mut matching_impls = Vec::new();\n-                trait_def.for_each_impl(self.tcx, |def_id| {\n-                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                    let substs = self.impl_substs(def_id, obligation.clone());\n-                    let imp = imp.subst(self.tcx, &substs);\n-\n-                    if self.eq_types(true,\n-                                      TypeOrigin::Misc(obligation.cause.span),\n-                                      trait_ref.self_ty(),\n-                                      imp.self_ty()).is_ok() {\n-                        matching_impls.push((def_id, imp.substs.clone()));\n-                    }\n-                });\n-                if matching_impls.len() == 0 {\n-                    None\n-                } else if matching_impls.len() == 1 {\n-                    Some(matching_impls[0].clone())\n-                } else {\n-                    let end = trait_ref.input_types().len() - 1;\n-                    // we need to determine which type is the good one!\n-                    Some(matching_impls[get_best_matching_type(&matching_impls,\n-                                                               &trait_ref.input_types()[0..end])]\n-                                                              .clone())\n-                }\n-            },\n-            None => None,\n+        let trait_self_ty = tcx.erase_late_bound_regions(&trait_ref).self_ty();\n+\n+        if trait_self_ty.is_ty_var() {\n+            return None;\n         }\n-    }\n \n-    fn find_attr(&self,\n-                 def_id: DefId,\n-                 attr_name: &str)\n-                 -> Option<ast::Attribute> {\n-        for item in self.tcx.get_attrs(def_id).iter() {\n-            if item.check_name(attr_name) {\n-                return Some(item.clone());\n-            }\n+        self.tcx.lookup_trait_def(trait_ref.def_id())\n+            .for_each_relevant_impl(self.tcx, trait_self_ty, |def_id| {\n+                let impl_self_ty = tcx\n+                    .impl_trait_ref(def_id)\n+                    .unwrap()\n+                    .self_ty()\n+                    .subst(tcx, &self.impl_substs(def_id, obligation.clone()));\n+\n+                if !tcx.has_attr(def_id, \"rustc_on_unimplemented\") {\n+                    return;\n+                }\n+\n+                if let Ok(..) = self.can_equate(&trait_self_ty, &impl_self_ty) {\n+                    ambiguous = result.is_some();\n+                    result = Some(def_id);\n+                }\n+            });\n+\n+        if ambiguous {\n+            None\n+        } else {\n+            result\n         }\n-        None\n     }\n \n     fn on_unimplemented_note(&self,\n                              trait_ref: ty::PolyTraitRef<'tcx>,\n                              obligation: &PredicateObligation<'tcx>) -> Option<String> {\n+        let def_id = self.impl_with_self_type_of(trait_ref, obligation)\n+            .unwrap_or(trait_ref.def_id());\n         let trait_ref = trait_ref.skip_binder();\n-        let def_id = match self.get_current_failing_impl(trait_ref, obligation) {\n-            Some((def_id, _)) => {\n-                if let Some(_) = self.find_attr(def_id, \"rustc_on_unimplemented\") {\n-                    def_id\n-                } else {\n-                    trait_ref.def_id\n-                }\n-            },\n-            None => trait_ref.def_id,\n-        };\n+\n         let span = obligation.cause.span;\n         let mut report = None;\n         for item in self.tcx.get_attrs(def_id).iter() {\n@@ -511,115 +370,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// that we can give a more helpful error message (and, in particular,\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n-    pub fn report_overflow_error_cycle(&self, cycle: &Vec<PredicateObligation<'tcx>>) -> ! {\n-        assert!(cycle.len() > 1);\n-\n-        debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n-\n-        let cycle = self.resolve_type_vars_if_possible(cycle);\n+    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_type_vars_if_possible(&cycle.to_owned());\n+        assert!(cycle.len() > 0);\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n \n-        assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n-\n-        self.try_report_overflow_error_type_of_infinite_size(&cycle);\n         self.report_overflow_error(&cycle[0], false);\n     }\n \n-    /// If a cycle results from evaluated whether something is Sized, that\n-    /// is a particular special case that always results from a struct or\n-    /// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n-    /// }`). We wish to report a targeted error for this case.\n-    pub fn try_report_overflow_error_type_of_infinite_size(&self,\n-        cycle: &[PredicateObligation<'tcx>])\n-    {\n-        let sized_trait = match self.tcx.lang_items.sized_trait() {\n-            Some(v) => v,\n-            None => return,\n-        };\n-        let top_is_sized = {\n-            match cycle[0].predicate {\n-                ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n-                _ => false,\n-            }\n-        };\n-        if !top_is_sized {\n-            return;\n-        }\n-\n-        // The only way to have a type of infinite size is to have,\n-        // somewhere, a struct/enum type involved. Identify all such types\n-        // and report the cycle to the user.\n-\n-        let struct_enum_tys: Vec<_> =\n-            cycle.iter()\n-                 .flat_map(|obligation| match obligation.predicate {\n-                     ty::Predicate::Trait(ref data) => {\n-                         assert_eq!(data.def_id(), sized_trait);\n-                         let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n-                         // (*) ok to skip binder because this is just\n-                         // error reporting and regions don't really\n-                         // matter\n-                         match self_ty.sty {\n-                             ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n-                             _ => None,\n-                         }\n-                     }\n-                     _ => {\n-                         span_bug!(obligation.cause.span,\n-                                   \"Sized cycle involving non-trait-ref: {:?}\",\n-                                   obligation.predicate);\n-                     }\n-                 })\n-                 .collect();\n-\n-        assert!(!struct_enum_tys.is_empty());\n-\n-        // This is a bit tricky. We want to pick a \"main type\" in the\n-        // listing that is local to the current crate, so we can give a\n-        // good span to the user. But it might not be the first one in our\n-        // cycle list. So find the first one that is local and then\n-        // rotate.\n-        let (main_index, main_def_id) =\n-            struct_enum_tys.iter()\n-                           .enumerate()\n-                           .filter_map(|(index, ty)| match ty.sty {\n-                               ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n-                                   if adt_def.did.is_local() =>\n-                                   Some((index, adt_def.did)),\n-                               _ =>\n-                                   None,\n-                           })\n-                           .next()\n-                           .unwrap(); // should always be SOME local type involved!\n-\n-        // Rotate so that the \"main\" type is at index 0.\n-        let struct_enum_tys: Vec<_> =\n-            struct_enum_tys.iter()\n-                           .cloned()\n-                           .skip(main_index)\n-                           .chain(struct_enum_tys.iter().cloned().take(main_index))\n-                           .collect();\n-\n-        let tcx = self.tcx;\n-        let mut err = tcx.recursive_type_with_infinite_size_error(main_def_id);\n-        let len = struct_enum_tys.len();\n-        if len > 2 {\n-            err.note(&format!(\"type `{}` is embedded within `{}`...\",\n-                     struct_enum_tys[0],\n-                     struct_enum_tys[1]));\n-            for &next_ty in &struct_enum_tys[1..len-1] {\n-                err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n-            }\n-            err.note(&format!(\"...which in turn is embedded within `{}`, \\\n-                               completing the cycle.\",\n-                              struct_enum_tys[len-1]));\n-        }\n-        err.emit();\n-        self.tcx.sess.abort_if_errors();\n-        bug!();\n-    }\n-\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>,"}, {"sha": "d9d0367bdcb10a872878dacdd5b68bd2a1a9c7ea", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 59, "deletions": 268, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -10,13 +10,14 @@\n \n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ToPolyTraitRef};\n-use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n-use std::iter;\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt};\n+use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n+use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n+use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FnvHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -29,16 +30,17 @@ use super::project;\n use super::select::SelectionContext;\n use super::Unimplemented;\n \n+impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n+    type Predicate = ty::Predicate<'tcx>;\n+\n+    fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n+}\n+\n pub struct GlobalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n     dep_graph: DepGraph,\n }\n \n-#[derive(Debug)]\n-pub struct LocalFulfilledPredicates<'tcx> {\n-    set: FnvHashSet<ty::Predicate<'tcx>>\n-}\n-\n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n@@ -50,23 +52,9 @@ pub struct LocalFulfilledPredicates<'tcx> {\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n pub struct FulfillmentContext<'tcx> {\n-    // a simple cache that aims to cache *exact duplicate obligations*\n-    // and avoid adding them twice. This serves a different purpose\n-    // than the `SelectionCache`: it avoids duplicate errors and\n-    // permits recursive obligations, which are often generated from\n-    // traits like `Send` et al.\n-    //\n-    // Note that because of type inference, a predicate can still\n-    // occur twice in the predicates list, for example when 2\n-    // initially-distinct type variables are unified after being\n-    // inserted. Deduplicating the predicate set on selection had a\n-    // significant performance cost the last time I checked.\n-    duplicate_set: LocalFulfilledPredicates<'tcx>,\n-\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: ObligationForest<PendingPredicateObligation<'tcx>,\n-                                 LocalFulfilledPredicates<'tcx>>,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n     // A list of new obligations due to RFC1592.\n     rfc1592_obligations: Vec<PredicateObligation<'tcx>>,\n@@ -115,7 +103,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n-            duplicate_set: LocalFulfilledPredicates::new(),\n             predicates: ObligationForest::new(),\n             rfc1592_obligations: Vec::new(),\n             region_obligations: NodeMap(),\n@@ -184,19 +171,15 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n-        assert!(!obligation.has_escaping_regions());\n-\n-        if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n-            debug!(\"register_predicate_obligation({:?}) -- already seen, skip\", obligation);\n-            return;\n+        if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate)\n+        {\n+            return\n         }\n \n-        debug!(\"register_predicate_obligation({:?})\", obligation);\n-        let obligation = PendingPredicateObligation {\n+        self.predicates.register_obligation(PendingPredicateObligation {\n             obligation: obligation,\n             stalled_on: vec![]\n-        };\n-        self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n+        });\n     }\n \n     pub fn register_rfc1592_obligation(&mut self,\n@@ -261,32 +244,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                           predicate: &ty::Predicate<'tcx>)\n-                           -> bool {\n-        // For \"global\" predicates -- that is, predicates that don't\n-        // involve type parameters, inference variables, or regions\n-        // other than 'static -- we can check the cache in the tcx,\n-        // which allows us to leverage work from other threads. Note\n-        // that we don't add anything to this cache yet (unlike the\n-        // local cache).  This is because the tcx cache maintains the\n-        // invariant that it only contains things that have been\n-        // proven, and we have not yet proven that `predicate` holds.\n-        if tcx.fulfilled_predicates.borrow().check_duplicate(predicate) {\n-            return true;\n-        }\n-\n-        // If `predicate` is not global, or not present in the tcx\n-        // cache, we can still check for it in our local cache and add\n-        // it if not present. Note that if we find this predicate in\n-        // the local cache we can stop immediately, without reporting\n-        // any errors, even though we don't know yet if it is\n-        // true. This is because, while we don't yet know if the\n-        // predicate holds, we know that this same fulfillment context\n-        // already is in the process of finding out.\n-        self.duplicate_set.is_duplicate_or_add(predicate)\n-    }\n-\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n@@ -299,18 +256,11 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = {\n-                let region_obligations = &mut self.region_obligations;\n-                let rfc1592_obligations = &mut self.rfc1592_obligations;\n-                self.predicates.process_obligations(\n-                    |obligation, tree, backtrace| process_predicate(selcx,\n-                                                                    tree,\n-                                                                    obligation,\n-                                                                    backtrace,\n-                                                                    region_obligations,\n-                                                                    rfc1592_obligations))\n-            };\n-\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                    selcx: selcx,\n+                    region_obligations: &mut self.region_obligations,\n+                    rfc1592_obligations: &mut self.rfc1592_obligations\n+            });\n             debug!(\"select: outcome={:?}\", outcome);\n \n             // these are obligations that were proven to be true.\n@@ -341,177 +291,40 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     }\n }\n \n-/// Like `process_predicate1`, but wrap result into a pending predicate.\n-fn process_predicate<'a, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n-    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-              FulfillmentErrorCode<'tcx>>\n-{\n-    match process_predicate1(selcx, pending_obligation, region_obligations,\n-                             rfc1592_obligations) {\n-        Ok(Some(v)) => process_child_obligations(selcx,\n-                                                 tree_cache,\n-                                                 &pending_obligation.obligation,\n-                                                 backtrace,\n-                                                 v),\n-        Ok(None) => Ok(None),\n-        Err(e) => Err(e)\n-    }\n+struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>\n }\n \n-fn process_child_obligations<'a, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n-    pending_obligation: &PredicateObligation<'tcx>,\n-    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-    child_obligations: Vec<PredicateObligation<'tcx>>)\n-    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-              FulfillmentErrorCode<'tcx>>\n-{\n-    // FIXME(#30977) The code below is designed to detect (and\n-    // permit) DAGs, while still ensuring that the reasoning\n-    // is acyclic. However, it does a few things\n-    // suboptimally. For example, it refreshes type variables\n-    // a lot, probably more than needed, but also less than\n-    // you might want.\n-    //\n-    //   - more than needed: I want to be very sure we don't\n-    //     accidentally treat a cycle as a DAG, so I am\n-    //     refreshing type variables as we walk the ancestors;\n-    //     but we are going to repeat this a lot, which is\n-    //     sort of silly, and it would be nicer to refresh\n-    //     them *in place* so that later predicate processing\n-    //     can benefit from the same work;\n-    //   - less than you might want: we only add items in the cache here,\n-    //     but maybe we learn more about type variables and could add them into\n-    //     the cache later on.\n-\n-    let tcx = selcx.tcx();\n-\n-    let mut ancestor_set = AncestorSet::new(&backtrace);\n-\n-    let pending_predicate_obligations: Vec<_> =\n-        child_obligations\n-        .into_iter()\n-        .filter_map(|obligation| {\n-            // Probably silly, but remove any inference\n-            // variables. This is actually crucial to the ancestor\n-            // check marked (*) below, but it's not clear that it\n-            // makes sense to ALWAYS do it.\n-            let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n-\n-            // Screen out obligations that we know globally\n-            // are true.\n-            if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n-                return None;\n-            }\n+impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n+    type Obligation = PendingPredicateObligation<'tcx>;\n+    type Error = FulfillmentErrorCode<'tcx>;\n \n-            // Check whether this obligation appears\n-            // somewhere else in the tree. If not, we have to\n-            // process it for sure.\n-            if !tree_cache.is_duplicate_or_add(&obligation.predicate) {\n-                return Some(PendingPredicateObligation {\n-                    obligation: obligation,\n-                    stalled_on: vec![]\n-                });\n-            }\n-\n-            debug!(\"process_child_obligations: duplicate={:?}\",\n-                   obligation.predicate);\n-\n-            // OK, the obligation appears elsewhere in the tree.\n-            // This is either a fatal error or else something we can\n-            // ignore. If the obligation appears in our *ancestors*\n-            // (rather than some more distant relative), that\n-            // indicates a cycle. Cycles are either considered\n-            // resolved (if this is a coinductive case) or a fatal\n-            // error.\n-            if let Some(index) = ancestor_set.has(selcx.infcx(), &obligation.predicate) {\n-                //                            ~~~ (*) see above\n-                debug!(\"process_child_obligations: cycle index = {}\", index);\n-\n-                let backtrace = backtrace.clone();\n-                let cycle: Vec<_> =\n-                    iter::once(&obligation)\n-                    .chain(Some(pending_obligation))\n-                    .chain(backtrace.take(index + 1).map(|p| &p.obligation))\n-                    .cloned()\n-                    .collect();\n-                if coinductive_match(selcx, &cycle) {\n-                    debug!(\"process_child_obligations: coinductive match\");\n-                    None\n-                } else {\n-                    selcx.infcx().report_overflow_error_cycle(&cycle);\n-                }\n-            } else {\n-                // Not a cycle. Just ignore this obligation then,\n-                // we're already in the process of proving it.\n-                debug!(\"process_child_obligations: not a cycle\");\n-                None\n-            }\n-        })\n-        .collect();\n-\n-    Ok(Some(pending_predicate_obligations))\n-}\n-\n-struct AncestorSet<'b, 'tcx: 'b> {\n-    populated: bool,\n-    cache: FnvHashMap<ty::Predicate<'tcx>, usize>,\n-    backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n-}\n-\n-impl<'a, 'b, 'gcx, 'tcx> AncestorSet<'b, 'tcx> {\n-    fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n-        AncestorSet {\n-            populated: false,\n-            cache: FnvHashMap(),\n-            backtrace: backtrace.clone(),\n-        }\n+    fn process_obligation(&mut self,\n+                          obligation: &mut Self::Obligation)\n+                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+    {\n+        process_predicate(self.selcx,\n+                          obligation,\n+                          self.region_obligations,\n+                          self.rfc1592_obligations)\n+            .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n+                obligation: o,\n+                stalled_on: vec![]\n+            }).collect()))\n     }\n \n-    /// Checks whether any of the ancestors in the backtrace are equal\n-    /// to `predicate` (`predicate` is assumed to be fully\n-    /// type-resolved).  Returns `None` if not; otherwise, returns\n-    /// `Some` with the index within the backtrace.\n-    fn has(&mut self,\n-           infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-           predicate: &ty::Predicate<'tcx>)\n-           -> Option<usize> {\n-        // the first time, we have to populate the cache\n-        if !self.populated {\n-            let backtrace = self.backtrace.clone();\n-            for (index, ancestor) in backtrace.enumerate() {\n-                // Ugh. This just feels ridiculously\n-                // inefficient.  But we need to compare\n-                // predicates without being concerned about\n-                // the vagaries of type inference, so for now\n-                // just ensure that they are always\n-                // up-to-date. (I suppose we could just use a\n-                // snapshot and check if they are unifiable?)\n-                let resolved_predicate =\n-                    infcx.resolve_type_vars_if_possible(\n-                        &ancestor.obligation.predicate);\n-\n-                // Though we try to avoid it, it can happen that a\n-                // cycle already exists in the predecessors. This\n-                // happens if the type variables were not fully known\n-                // at the time that the ancestors were pushed. We'll\n-                // just ignore such cycles for now, on the premise\n-                // that they will repeat themselves and we'll deal\n-                // with them properly then.\n-                self.cache.entry(resolved_predicate)\n-                          .or_insert(index);\n-            }\n-            self.populated = true;\n+    fn process_backedge<'c, I>(&mut self, cycle: I,\n+                               _marker: PhantomData<&'c PendingPredicateObligation<'tcx>>)\n+        where I: Clone + Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n+    {\n+        if coinductive_match(self.selcx, cycle.clone()) {\n+            debug!(\"process_child_obligations: coinductive match\");\n+        } else {\n+            let cycle : Vec<_> = cycle.map(|c| c.obligation.clone()).collect();\n+            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n         }\n-\n-        self.cache.get(predicate).cloned()\n     }\n }\n \n@@ -533,7 +346,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n /// - `Ok(None)` if we don't have enough info to be sure\n /// - `Err` if the predicate does not hold\n-fn process_predicate1<'a, 'gcx, 'tcx>(\n+fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n@@ -725,25 +538,22 @@ fn process_predicate1<'a, 'gcx, 'tcx>(\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n-fn coinductive_match<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                     cycle: &[PredicateObligation<'tcx>])\n-                                     -> bool\n+fn coinductive_match<'a,'c,'gcx,'tcx,I>(selcx: &mut SelectionContext<'a,'gcx,'tcx>,\n+                                        cycle: I) -> bool\n+    where I: Iterator<Item=&'c PendingPredicateObligation<'tcx>>,\n+          'tcx: 'c\n {\n-    let len = cycle.len();\n-\n-    assert_eq!(cycle[0].predicate, cycle[len - 1].predicate);\n-\n-    cycle[0..len-1]\n-        .iter()\n+    let mut cycle = cycle;\n+    cycle\n         .all(|bt_obligation| {\n-            let result = coinductive_obligation(selcx, bt_obligation);\n+            let result = coinductive_obligation(selcx, &bt_obligation.obligation);\n             debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n                    bt_obligation, result);\n             result\n         })\n }\n \n-fn coinductive_obligation<'a, 'gcx, 'tcx>(selcx: &SelectionContext<'a, 'gcx, 'tcx>,\n+fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n                                           -> bool {\n     match obligation.predicate {\n@@ -774,25 +584,6 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n \n }\n \n-impl<'tcx> LocalFulfilledPredicates<'tcx> {\n-    pub fn new() -> LocalFulfilledPredicates<'tcx> {\n-        LocalFulfilledPredicates {\n-            set: FnvHashSet()\n-        }\n-    }\n-\n-    fn is_duplicate_or_add(&mut self, key: &ty::Predicate<'tcx>) -> bool {\n-        // For a `LocalFulfilledPredicates`, if we find a match, we\n-        // don't need to add a read edge to the dep-graph. This is\n-        // because it means that the predicate has already been\n-        // considered by this `FulfillmentContext`, and hence the\n-        // containing task will already have an edge. (Here we are\n-        // assuming each `FulfillmentContext` only gets used from one\n-        // task; but to do otherwise makes no sense)\n-        !self.set.insert(key.clone())\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n     pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {"}, {"sha": "926ee85230a311e0498b8eaa806d05420ae76bbb", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -28,6 +28,8 @@\n #![feature(nonzero)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(unboxed_closures)]\n+#![feature(fn_traits)]\n \n #![cfg_attr(test, feature(test))]\n "}, {"sha": "b713b2285a65feb4418b9f7336c41b48e1c45522", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 359, "deletions": 288, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -15,20 +15,45 @@\n //! in the first place). See README.md for a general overview of how\n //! to use this class.\n \n+use fnv::{FnvHashMap, FnvHashSet};\n+\n+use std::cell::Cell;\n+use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n-use std::mem;\n+use std::hash;\n+use std::marker::PhantomData;\n \n mod node_index;\n use self::node_index::NodeIndex;\n \n-mod tree_index;\n-use self::tree_index::TreeIndex;\n-\n-\n #[cfg(test)]\n mod test;\n \n-pub struct ObligationForest<O, T> {\n+pub trait ForestObligation : Clone + Debug {\n+    type Predicate : Clone + hash::Hash + Eq + Debug;\n+\n+    fn as_predicate(&self) -> &Self::Predicate;\n+}\n+\n+pub trait ObligationProcessor {\n+    type Obligation : ForestObligation;\n+    type Error : Debug;\n+\n+    fn process_obligation(&mut self,\n+                          obligation: &mut Self::Obligation)\n+                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n+\n+    fn process_backedge<'c, I>(&mut self, cycle: I,\n+                               _marker: PhantomData<&'c Self::Obligation>)\n+        where I: Clone + Iterator<Item=&'c Self::Obligation>;\n+}\n+\n+struct SnapshotData {\n+    node_len: usize,\n+    cache_list_len: usize,\n+}\n+\n+pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n     /// `Pending` or `Success` state (with a non-zero number of\n@@ -42,51 +67,66 @@ pub struct ObligationForest<O, T> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n-    trees: Vec<Tree<T>>,\n-    snapshots: Vec<usize>,\n+    /// A cache of predicates that have been successfully completed.\n+    done_cache: FnvHashSet<O::Predicate>,\n+    /// An cache of the nodes in `nodes`, indexed by predicate.\n+    waiting_cache: FnvHashMap<O::Predicate, NodeIndex>,\n+    /// A list of the obligations added in snapshots, to allow\n+    /// for their removal.\n+    cache_list: Vec<O::Predicate>,\n+    snapshots: Vec<SnapshotData>,\n+    scratch: Option<Vec<usize>>,\n }\n \n pub struct Snapshot {\n     len: usize,\n }\n \n-struct Tree<T> {\n-    root: NodeIndex,\n-    state: T,\n-}\n-\n+#[derive(Debug)]\n struct Node<O> {\n-    state: NodeState<O>,\n+    obligation: O,\n+    state: Cell<NodeState>,\n+\n+    /// Obligations that depend on this obligation for their\n+    /// completion. They must all be in a non-pending state.\n+    dependents: Vec<NodeIndex>,\n+    /// The parent of a node - the original obligation of\n+    /// which it is a subobligation. Except for error reporting,\n+    /// this is just another member of `dependents`.\n     parent: Option<NodeIndex>,\n-    tree: TreeIndex,\n }\n \n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n-#[derive(Debug)]\n-enum NodeState<O> {\n-    /// Obligation not yet resolved to success or error.\n-    Pending {\n-        obligation: O,\n-    },\n-\n-    /// Obligation resolved to success; `num_incomplete_children`\n-    /// indicates the number of children still in an \"incomplete\"\n-    /// state. Incomplete means that either the child is still\n-    /// pending, or it has children which are incomplete. (Basically,\n-    /// there is pending work somewhere in the subtree of the child.)\n-    ///\n-    /// Once all children have completed, success nodes are removed\n-    /// from the vector by the compression step.\n-    Success {\n-        obligation: O,\n-        num_incomplete_children: usize,\n-    },\n+///\n+/// Outside of ObligationForest methods, nodes should be either Pending\n+/// or Waiting.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum NodeState {\n+    /// Obligations for which selection had not yet returned a\n+    /// non-ambiguous result.\n+    Pending,\n+\n+    /// This obligation was selected successfuly, but may or\n+    /// may not have subobligations.\n+    Success,\n+\n+    /// This obligation was selected sucessfully, but it has\n+    /// a pending subobligation.\n+    Waiting,\n+\n+    /// This obligation, along with its subobligations, are complete,\n+    /// and will be removed in the next collection.\n+    Done,\n \n     /// This obligation was resolved to an error. Error nodes are\n     /// removed from the vector by the compression step.\n     Error,\n+\n+    /// This is a temporary state used in DFS loops to detect cycles,\n+    /// it should not exist outside of these DFSes.\n+    OnDfsStack,\n }\n \n #[derive(Debug)]\n@@ -113,12 +153,15 @@ pub struct Error<O, E> {\n     pub backtrace: Vec<O>,\n }\n \n-impl<O: Debug, T: Debug> ObligationForest<O, T> {\n-    pub fn new() -> ObligationForest<O, T> {\n+impl<O: ForestObligation> ObligationForest<O> {\n+    pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n-            trees: vec![],\n             nodes: vec![],\n             snapshots: vec![],\n+            done_cache: FnvHashSet(),\n+            waiting_cache: FnvHashMap(),\n+            cache_list: vec![],\n+            scratch: Some(vec![]),\n         }\n     }\n \n@@ -129,57 +172,69 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     }\n \n     pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(self.trees.len());\n+        self.snapshots.push(SnapshotData {\n+            node_len: self.nodes.len(),\n+            cache_list_len: self.cache_list.len()\n+        });\n         Snapshot { len: self.snapshots.len() }\n     }\n \n     pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let trees_len = self.snapshots.pop().unwrap();\n-        assert!(self.trees.len() >= trees_len);\n+        let info = self.snapshots.pop().unwrap();\n+        assert!(self.nodes.len() >= info.node_len);\n+        assert!(self.cache_list.len() >= info.cache_list_len);\n     }\n \n     pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n         // Check that we are obeying stack discipline.\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let trees_len = self.snapshots.pop().unwrap();\n+        let info = self.snapshots.pop().unwrap();\n \n-        // If nothing happened in snapshot, done.\n-        if self.trees.len() == trees_len {\n-            return;\n+        for entry in &self.cache_list[info.cache_list_len..] {\n+            self.done_cache.remove(entry);\n+            self.waiting_cache.remove(entry);\n         }\n \n-        // Find root of first tree; because nothing can happen in a\n-        // snapshot but pushing trees, all nodes after that should be\n-        // roots of other trees as well\n-        let first_root_index = self.trees[trees_len].root.get();\n-        debug_assert!(self.nodes[first_root_index..]\n-                          .iter()\n-                          .zip(first_root_index..)\n-                          .all(|(root, root_index)| {\n-                              self.trees[root.tree.get()].root.get() == root_index\n-                          }));\n-\n-        // Pop off tree/root pairs pushed during snapshot.\n-        self.trees.truncate(trees_len);\n-        self.nodes.truncate(first_root_index);\n+        self.nodes.truncate(info.node_len);\n+        self.cache_list.truncate(info.cache_list_len);\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n         !self.snapshots.is_empty()\n     }\n \n-    /// Adds a new tree to the forest.\n+    /// Registers an obligation\n     ///\n-    /// This CAN be done during a snapshot.\n-    pub fn push_tree(&mut self, obligation: O, tree_state: T) {\n-        let index = NodeIndex::new(self.nodes.len());\n-        let tree = TreeIndex::new(self.trees.len());\n-        self.trees.push(Tree {\n-            root: index,\n-            state: tree_state,\n-        });\n-        self.nodes.push(Node::new(tree, None, obligation));\n+    /// This CAN be done in a snapshot\n+    pub fn register_obligation(&mut self, obligation: O) {\n+        self.register_obligation_at(obligation, None)\n+    }\n+\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>) {\n+        if self.done_cache.contains(obligation.as_predicate()) { return }\n+\n+        match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n+            Entry::Occupied(o) => {\n+                debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n+                       obligation, parent, o.get());\n+                if let Some(parent) = parent {\n+                    if self.nodes[o.get().get()].dependents.contains(&parent) {\n+                        debug!(\"register_obligation_at({:?}, {:?}) - duplicate subobligation\",\n+                               obligation, parent);\n+                    } else {\n+                        self.nodes[o.get().get()].dependents.push(parent);\n+                    }\n+                }\n+            }\n+            Entry::Vacant(v) => {\n+                debug!(\"register_obligation_at({:?}, {:?}) - ok\",\n+                       obligation, parent);\n+                v.insert(NodeIndex::new(self.nodes.len()));\n+                self.cache_list.push(obligation.as_predicate().clone());\n+                self.nodes.push(Node::new(parent, obligation));\n+            }\n+        };\n     }\n \n     /// Convert all remaining obligations to the given error.\n@@ -189,10 +244,8 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n         assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n-            debug_assert!(!self.nodes[index].is_popped());\n-            self.inherit_error(index);\n-            if let NodeState::Pending { .. } = self.nodes[index].state {\n-                let backtrace = self.backtrace(index);\n+            if let NodeState::Pending = self.nodes[index].state.get() {\n+                let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace: backtrace,\n@@ -210,56 +263,36 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     {\n         self.nodes\n             .iter()\n-            .filter_map(|n| {\n-                match n.state {\n-                    NodeState::Pending { ref obligation } => Some(obligation),\n-                    _ => None,\n-                }\n-            })\n-            .cloned()\n+            .filter(|n| n.state.get() == NodeState::Pending)\n+            .map(|n| n.obligation.clone())\n             .collect()\n     }\n \n-    /// Process the obligations.\n+    /// Perform a pass through the obligation list. This must\n+    /// be called in a loop until `outcome.stalled` is false.\n     ///\n     /// This CANNOT be unrolled (presently, at least).\n-    pub fn process_obligations<E, F>(&mut self, mut action: F) -> Outcome<O, E>\n-        where E: Debug,\n-              F: FnMut(&mut O, &mut T, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+    pub fn process_obligations<P>(&mut self, processor: &mut P) -> Outcome<O, P::Error>\n+        where P: ObligationProcessor<Obligation=O>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n         assert!(!self.in_snapshot()); // cannot unroll this action\n \n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        // We maintain the invariant that the list is in pre-order, so\n-        // parents occur before their children. Also, whenever an\n-        // error occurs, we propagate it from the child all the way to\n-        // the root of the tree. Together, these two facts mean that\n-        // when we visit a node, we can check if its root is in error,\n-        // and we will find out if any prior node within this forest\n-        // encountered an error.\n-\n         for index in 0..self.nodes.len() {\n-            debug_assert!(!self.nodes[index].is_popped());\n-            self.inherit_error(index);\n-\n             debug!(\"process_obligations: node {} == {:?}\",\n                    index,\n-                   self.nodes[index].state);\n-\n-            let result = {\n-                let Node { tree, parent, .. } = self.nodes[index];\n-                let (prefix, suffix) = self.nodes.split_at_mut(index);\n-                let backtrace = Backtrace::new(prefix, parent);\n-                match suffix[0].state {\n-                    NodeState::Error |\n-                    NodeState::Success { .. } => continue,\n-                    NodeState::Pending { ref mut obligation } => {\n-                        action(obligation, &mut self.trees[tree.get()].state, backtrace)\n-                    }\n+                   self.nodes[index]);\n+\n+            let result = match self.nodes[index] {\n+                Node { state: ref _state, ref mut obligation, .. }\n+                    if _state.get() == NodeState::Pending =>\n+                {\n+                    processor.process_obligation(obligation)\n                 }\n+                _ => continue\n             };\n \n             debug!(\"process_obligations: node {} got result {:?}\",\n@@ -273,10 +306,15 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n                 Ok(Some(children)) => {\n                     // if we saw a Some(_) result, we are not (yet) stalled\n                     stalled = false;\n-                    self.success(index, children);\n+                    for child in children {\n+                        self.register_obligation_at(child,\n+                                                    Some(NodeIndex::new(index)));\n+                    }\n+\n+                    self.nodes[index].state.set(NodeState::Success);\n                 }\n                 Err(err) => {\n-                    let backtrace = self.backtrace(index);\n+                    let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n                         backtrace: backtrace,\n@@ -285,259 +323,292 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n             }\n         }\n \n+        self.mark_as_waiting();\n+        self.process_cycles(processor);\n+\n         // Now we have to compress the result\n-        let successful_obligations = self.compress();\n+        let completed_obligations = self.compress();\n \n         debug!(\"process_obligations: complete\");\n \n         Outcome {\n-            completed: successful_obligations,\n+            completed: completed_obligations,\n             errors: errors,\n             stalled: stalled,\n         }\n     }\n \n-    /// Indicates that node `index` has been processed successfully,\n-    /// yielding `children` as the derivative work. If children is an\n-    /// empty vector, this will update the ref count on the parent of\n-    /// `index` to indicate that a child has completed\n-    /// successfully. Otherwise, adds new nodes to represent the child\n-    /// work.\n-    fn success(&mut self, index: usize, children: Vec<O>) {\n-        debug!(\"success(index={}, children={:?})\", index, children);\n-\n-        let num_incomplete_children = children.len();\n-\n-        if num_incomplete_children == 0 {\n-            // if there is no work left to be done, decrement parent's ref count\n-            self.update_parent(index);\n-        } else {\n-            // create child work\n-            let tree_index = self.nodes[index].tree;\n-            let node_index = NodeIndex::new(index);\n-            self.nodes.extend(children.into_iter()\n-                                      .map(|o| Node::new(tree_index, Some(node_index), o)));\n+    /// Mark all NodeState::Success nodes as NodeState::Done and\n+    /// report all cycles between them. This should be called\n+    /// after `mark_as_waiting` marks all nodes with pending\n+    /// subobligations as NodeState::Waiting.\n+    fn process_cycles<P>(&mut self, processor: &mut P)\n+        where P: ObligationProcessor<Obligation=O>\n+    {\n+        let mut stack = self.scratch.take().unwrap();\n+\n+        for node in 0..self.nodes.len() {\n+            self.find_cycles_from_node(&mut stack, processor, node);\n         }\n \n-        // change state from `Pending` to `Success`, temporarily swapping in `Error`\n-        let state = mem::replace(&mut self.nodes[index].state, NodeState::Error);\n-        self.nodes[index].state = match state {\n-            NodeState::Pending { obligation } => {\n-                NodeState::Success {\n-                    obligation: obligation,\n-                    num_incomplete_children: num_incomplete_children,\n-                }\n-            }\n-            NodeState::Success { .. } |\n-            NodeState::Error => unreachable!(),\n-        };\n+        self.scratch = Some(stack);\n     }\n \n-    /// Decrements the ref count on the parent of `child`; if the\n-    /// parent's ref count then reaches zero, proceeds recursively.\n-    fn update_parent(&mut self, child: usize) {\n-        debug!(\"update_parent(child={})\", child);\n-        if let Some(parent) = self.nodes[child].parent {\n-            let parent = parent.get();\n-            match self.nodes[parent].state {\n-                NodeState::Success { ref mut num_incomplete_children, .. } => {\n-                    *num_incomplete_children -= 1;\n-                    if *num_incomplete_children > 0 {\n-                        return;\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>,\n+                                processor: &mut P, index: usize)\n+        where P: ObligationProcessor<Obligation=O>\n+    {\n+        let node = &self.nodes[index];\n+        let state = node.state.get();\n+        match state {\n+            NodeState::OnDfsStack => {\n+                let index =\n+                    stack.iter().rposition(|n| *n == index).unwrap();\n+                // I need a Clone closure\n+                #[derive(Clone)]\n+                struct GetObligation<'a, O: 'a>(&'a [Node<O>]);\n+                impl<'a, 'b, O> FnOnce<(&'b usize,)> for GetObligation<'a, O> {\n+                    type Output = &'a O;\n+                    extern \"rust-call\" fn call_once(self, args: (&'b usize,)) -> &'a O {\n+                        &self.0[*args.0].obligation\n+                    }\n+                }\n+                impl<'a, 'b, O> FnMut<(&'b usize,)> for GetObligation<'a, O> {\n+                    extern \"rust-call\" fn call_mut(&mut self, args: (&'b usize,)) -> &'a O {\n+                        &self.0[*args.0].obligation\n                     }\n                 }\n-                _ => unreachable!(),\n-            }\n-            self.update_parent(parent);\n-        }\n-    }\n \n-    /// If the root of `child` is in an error state, places `child`\n-    /// into an error state. This is used during processing so that we\n-    /// skip the remaining obligations from a tree once some other\n-    /// node in the tree is found to be in error.\n-    fn inherit_error(&mut self, child: usize) {\n-        let tree = self.nodes[child].tree;\n-        let root = self.trees[tree.get()].root;\n-        if let NodeState::Error = self.nodes[root.get()].state {\n-            self.nodes[child].state = NodeState::Error;\n-        }\n+                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n+                                           PhantomData);\n+            }\n+            NodeState::Success => {\n+                node.state.set(NodeState::OnDfsStack);\n+                stack.push(index);\n+                if let Some(parent) = node.parent {\n+                    self.find_cycles_from_node(stack, processor, parent.get());\n+                }\n+                for dependent in &node.dependents {\n+                    self.find_cycles_from_node(stack, processor, dependent.get());\n+                }\n+                stack.pop();\n+                node.state.set(NodeState::Done);\n+            },\n+            NodeState::Waiting | NodeState::Pending => {\n+                // this node is still reachable from some pending node. We\n+                // will get to it when they are all processed.\n+            }\n+            NodeState::Done | NodeState::Error => {\n+                // already processed that node\n+            }\n+        };\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    /// The fact that the root is now marked as an error is used by\n-    /// `inherit_error` above to propagate the error state to the\n-    /// remainder of the tree.\n-    fn backtrace(&mut self, mut p: usize) -> Vec<O> {\n+    fn error_at(&mut self, p: usize) -> Vec<O> {\n+        let mut error_stack = self.scratch.take().unwrap();\n         let mut trace = vec![];\n+\n+        let mut n = p;\n         loop {\n-            let state = mem::replace(&mut self.nodes[p].state, NodeState::Error);\n-            match state {\n-                NodeState::Pending { obligation } |\n-                NodeState::Success { obligation, .. } => {\n-                    trace.push(obligation);\n-                }\n-                NodeState::Error => {\n-                    // we should not encounter an error, because if\n-                    // there was an error in the ancestors, it should\n-                    // have been propagated down and we should never\n-                    // have tried to process this obligation\n-                    panic!(\"encountered error in node {:?} when collecting stack trace\",\n-                           p);\n-                }\n-            }\n+            self.nodes[n].state.set(NodeState::Error);\n+            trace.push(self.nodes[n].obligation.clone());\n+            error_stack.extend(self.nodes[n].dependents.iter().map(|x| x.get()));\n \n             // loop to the parent\n-            match self.nodes[p].parent {\n-                Some(q) => {\n-                    p = q.get();\n-                }\n-                None => {\n-                    return trace;\n-                }\n+            match self.nodes[n].parent {\n+                Some(q) => n = q.get(),\n+                None => break\n+            }\n+        }\n+\n+        loop {\n+            // non-standard `while let` to bypass #6393\n+            let i = match error_stack.pop() {\n+                Some(i) => i,\n+                None => break\n+            };\n+\n+            let node = &self.nodes[i];\n+\n+            match node.state.get() {\n+                NodeState::Error => continue,\n+                _ => node.state.set(NodeState::Error)\n+            }\n+\n+            error_stack.extend(\n+                node.dependents.iter().cloned().chain(node.parent).map(|x| x.get())\n+            );\n+        }\n+\n+        self.scratch = Some(error_stack);\n+        trace\n+    }\n+\n+    /// Marks all nodes that depend on a pending node as NodeState;:Waiting.\n+    fn mark_as_waiting(&self) {\n+        for node in &self.nodes {\n+            if node.state.get() == NodeState::Waiting {\n+                node.state.set(NodeState::Success);\n+            }\n+        }\n+\n+        for node in &self.nodes {\n+            if node.state.get() == NodeState::Pending {\n+                self.mark_as_waiting_from(node)\n             }\n         }\n     }\n \n+    fn mark_as_waiting_from(&self, node: &Node<O>) {\n+        match node.state.get() {\n+            NodeState::Pending | NodeState::Done => {},\n+            NodeState::Waiting | NodeState::Error | NodeState::OnDfsStack => return,\n+            NodeState::Success => {\n+                node.state.set(NodeState::Waiting);\n+            }\n+        }\n+\n+        if let Some(parent) = node.parent {\n+            self.mark_as_waiting_from(&self.nodes[parent.get()]);\n+        }\n+\n+        for dependent in &node.dependents {\n+            self.mark_as_waiting_from(&self.nodes[dependent.get()]);\n+        }\n+    }\n+\n     /// Compresses the vector, removing all popped nodes. This adjusts\n     /// the indices and hence invalidates any outstanding\n     /// indices. Cannot be used during a transaction.\n+    ///\n+    /// Beforehand, all nodes must be marked as `Done` and no cycles\n+    /// on these nodes may be present. This is done by e.g. `process_cycles`.\n+    #[inline(never)]\n     fn compress(&mut self) -> Vec<O> {\n         assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-        let mut node_rewrites: Vec<_> = (0..self.nodes.len()).collect();\n-        let mut tree_rewrites: Vec<_> = (0..self.trees.len()).collect();\n \n-        // Finish propagating error state. Note that in this case we\n-        // only have to check immediate parents, rather than all\n-        // ancestors, because all errors have already occurred that\n-        // are going to occur.\n         let nodes_len = self.nodes.len();\n-        for i in 0..nodes_len {\n-            if !self.nodes[i].is_popped() {\n-                self.inherit_error(i);\n-            }\n-        }\n+        let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n+        node_rewrites.extend(0..nodes_len);\n+        let mut dead_nodes = 0;\n \n-        // Determine which trees to remove by checking if their root\n-        // is popped.\n-        let mut dead_trees = 0;\n-        let trees_len = self.trees.len();\n-        for i in 0..trees_len {\n-            let root_node = self.trees[i].root;\n-            if self.nodes[root_node.get()].is_popped() {\n-                dead_trees += 1;\n-            } else if dead_trees > 0 {\n-                self.trees.swap(i, i - dead_trees);\n-                tree_rewrites[i] -= dead_trees;\n+        // Now move all popped nodes to the end. Try to keep the order.\n+        //\n+        // LOOP INVARIANT:\n+        //     self.nodes[0..i - dead_nodes] are the first remaining nodes\n+        //     self.nodes[i - dead_nodes..i] are all dead\n+        //     self.nodes[i..] are unchanged\n+        for i in 0..self.nodes.len() {\n+            match self.nodes[i].state.get() {\n+                NodeState::Done => {\n+                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                    // FIXME(HashMap): why can't I get my key back?\n+                    self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n+                }\n+                NodeState::Error => {\n+                    // We *intentionally* remove the node from the cache at this point. Otherwise\n+                    // tests must come up with a different type on every type error they\n+                    // check against.\n+                    self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                }\n+                _ => {}\n             }\n-        }\n \n-        // Now go through and move all nodes that are either\n-        // successful or which have an error over into to the end of\n-        // the list, preserving the relative order of the survivors\n-        // (which is important for the `inherit_error` logic).\n-        let mut dead_nodes = 0;\n-        for i in 0..nodes_len {\n             if self.nodes[i].is_popped() {\n+                node_rewrites[i] = nodes_len;\n                 dead_nodes += 1;\n-            } else if dead_nodes > 0 {\n-                self.nodes.swap(i, i - dead_nodes);\n-                node_rewrites[i] -= dead_nodes;\n+            } else {\n+                if dead_nodes > 0 {\n+                    self.nodes.swap(i, i - dead_nodes);\n+                    node_rewrites[i] -= dead_nodes;\n+                }\n             }\n         }\n \n         // No compression needed.\n-        if dead_nodes == 0 && dead_trees == 0 {\n+        if dead_nodes == 0 {\n+            node_rewrites.truncate(0);\n+            self.scratch = Some(node_rewrites);\n             return vec![];\n         }\n \n-        // Pop off the trees we killed.\n-        self.trees.truncate(trees_len - dead_trees);\n-\n         // Pop off all the nodes we killed and extract the success\n         // stories.\n         let successful = (0..dead_nodes)\n                              .map(|_| self.nodes.pop().unwrap())\n                              .flat_map(|node| {\n-                                 match node.state {\n+                                 match node.state.get() {\n                                      NodeState::Error => None,\n-                                     NodeState::Pending { .. } => unreachable!(),\n-                                     NodeState::Success { obligation, num_incomplete_children } => {\n-                                         assert_eq!(num_incomplete_children, 0);\n-                                         Some(obligation)\n-                                     }\n+                                     NodeState::Done => Some(node.obligation),\n+                                     _ => unreachable!()\n                                  }\n                              })\n-                             .collect();\n+            .collect();\n+        self.apply_rewrites(&node_rewrites);\n+\n+        node_rewrites.truncate(0);\n+        self.scratch = Some(node_rewrites);\n+\n+        successful\n+    }\n+\n+    fn apply_rewrites(&mut self, node_rewrites: &[usize]) {\n+        let nodes_len = node_rewrites.len();\n \n-        // Adjust the various indices, since we compressed things.\n-        for tree in &mut self.trees {\n-            tree.root = NodeIndex::new(node_rewrites[tree.root.get()]);\n-        }\n         for node in &mut self.nodes {\n-            if let Some(ref mut index) = node.parent {\n+            if let Some(index) = node.parent {\n                 let new_index = node_rewrites[index.get()];\n-                debug_assert!(new_index < (nodes_len - dead_nodes));\n-                *index = NodeIndex::new(new_index);\n+                if new_index >= nodes_len {\n+                    // parent dead due to error\n+                    node.parent = None;\n+                } else {\n+                    node.parent = Some(NodeIndex::new(new_index));\n+                }\n             }\n \n-            node.tree = TreeIndex::new(tree_rewrites[node.tree.get()]);\n+            let mut i = 0;\n+            while i < node.dependents.len() {\n+                let new_index = node_rewrites[node.dependents[i].get()];\n+                if new_index >= nodes_len {\n+                    node.dependents.swap_remove(i);\n+                } else {\n+                    node.dependents[i] = NodeIndex::new(new_index);\n+                    i += 1;\n+                }\n+            }\n         }\n \n-        successful\n+        let mut kill_list = vec![];\n+        for (predicate, index) in self.waiting_cache.iter_mut() {\n+            let new_index = node_rewrites[index.get()];\n+            if new_index >= nodes_len {\n+                kill_list.push(predicate.clone());\n+            } else {\n+                *index = NodeIndex::new(new_index);\n+            }\n+        }\n+\n+        for predicate in kill_list { self.waiting_cache.remove(&predicate); }\n     }\n }\n \n impl<O> Node<O> {\n-    fn new(tree: TreeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+    fn new(parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n         Node {\n+            obligation: obligation,\n             parent: parent,\n-            state: NodeState::Pending { obligation: obligation },\n-            tree: tree,\n+            state: Cell::new(NodeState::Pending),\n+            dependents: vec![],\n         }\n     }\n \n     fn is_popped(&self) -> bool {\n-        match self.state {\n-            NodeState::Pending { .. } => false,\n-            NodeState::Success { num_incomplete_children, .. } => num_incomplete_children == 0,\n-            NodeState::Error => true,\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct Backtrace<'b, O: 'b> {\n-    nodes: &'b [Node<O>],\n-    pointer: Option<NodeIndex>,\n-}\n-\n-impl<'b, O> Backtrace<'b, O> {\n-    fn new(nodes: &'b [Node<O>], pointer: Option<NodeIndex>) -> Backtrace<'b, O> {\n-        Backtrace {\n-            nodes: nodes,\n-            pointer: pointer,\n-        }\n-    }\n-}\n-\n-impl<'b, O> Iterator for Backtrace<'b, O> {\n-    type Item = &'b O;\n-\n-    fn next(&mut self) -> Option<&'b O> {\n-        debug!(\"Backtrace: self.pointer = {:?}\", self.pointer);\n-        if let Some(p) = self.pointer {\n-            self.pointer = self.nodes[p.get()].parent;\n-            match self.nodes[p.get()].state {\n-                NodeState::Pending { ref obligation } |\n-                NodeState::Success { ref obligation, .. } => Some(obligation),\n-                NodeState::Error => {\n-                    panic!(\"Backtrace encountered an error.\");\n-                }\n-            }\n-        } else {\n-            None\n+        match self.state.get() {\n+            NodeState::Pending | NodeState::Waiting => false,\n+            NodeState::Error | NodeState::Done => true,\n+            NodeState::OnDfsStack | NodeState::Success => unreachable!()\n         }\n     }\n }"}, {"sha": "8eac8892a3efe42c65f874bc0d5c14370a0aacd1", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 280, "deletions": 96, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -8,30 +8,82 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{ObligationForest, Outcome, Error};\n+#![cfg(test)]\n+\n+use super::{ObligationForest, ObligationProcessor, Outcome, Error};\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+\n+impl<'a> super::ForestObligation for &'a str {\n+    type Predicate = &'a str;\n+\n+    fn as_predicate(&self) -> &Self::Predicate {\n+        self\n+    }\n+}\n+\n+struct ClosureObligationProcessor<OF, BF, O, E> {\n+    process_obligation: OF,\n+    _process_backedge: BF,\n+    marker: PhantomData<(O, E)>,\n+}\n+\n+#[allow(non_snake_case)]\n+fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'static str>\n+    where OF: FnMut(&mut O) -> Result<Option<Vec<O>>, &'static str>,\n+          BF: FnMut(&[O])\n+{\n+    ClosureObligationProcessor {\n+        process_obligation: of,\n+        _process_backedge: bf,\n+        marker: PhantomData\n+    }\n+}\n+\n+impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O, E>\n+    where O: super::ForestObligation + fmt::Debug,\n+          E: fmt::Debug,\n+          OF: FnMut(&mut O) -> Result<Option<Vec<O>>, E>,\n+          BF: FnMut(&[O])\n+{\n+    type Obligation = O;\n+    type Error = E;\n+\n+    fn process_obligation(&mut self,\n+                          obligation: &mut Self::Obligation)\n+                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+    {\n+        (self.process_obligation)(obligation)\n+    }\n+\n+    fn process_backedge<'c, I>(&mut self, _cycle: I,\n+                               _marker: PhantomData<&'c Self::Obligation>)\n+        where I: Clone + Iterator<Item=&'c Self::Obligation> {\n+        }\n+}\n+\n \n #[test]\n fn push_pop() {\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n-    forest.push_tree(\"B\", \"B\");\n-    forest.push_tree(\"C\", \"C\");\n+    forest.register_obligation(\"A\");\n+    forest.register_obligation(\"B\");\n+    forest.register_obligation(\"C\");\n \n     // first round, B errors out, A has subtasks, and C completes, creating this:\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n-                                                                                 tree,\n-                                                                                 _| {\n-        assert_eq!(obligation.chars().next(), tree.chars().next());\n-        match *obligation {\n-            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-            \"B\" => Err(\"B is for broken\"),\n-            \"C\" => Ok(Some(vec![])),\n-            _ => unreachable!(),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"B\" => Err(\"B is for broken\"),\n+                \"C\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"C\"]);\n     assert_eq!(err,\n                vec![Error {\n@@ -45,56 +97,53 @@ fn push_pop() {\n     //        |-> A.3 |-> A.3.i\n     //      D |-> D.1\n     //        |-> D.2\n-    forest.push_tree(\"D\", \"D\");\n-    let Outcome { completed: ok, errors: err, .. }: Outcome<&'static str, ()> =\n-        forest.process_obligations(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+    forest.register_obligation(\"D\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.1\" => Ok(None),\n                 \"A.2\" => Ok(None),\n                 \"A.3\" => Ok(Some(vec![\"A.3.i\"])),\n                 \"D\" => Ok(Some(vec![\"D.1\", \"D.2\"])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, Vec::<&'static str>::new());\n     assert_eq!(err, Vec::new());\n \n \n     // third round: ok in A.1 but trigger an error in A.2. Check that it\n-    // propagates to A.3.i, but not D.1 or D.2.\n+    // propagates to A, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n-                                                                                 tree,\n-                                                                                 _| {\n-        assert_eq!(obligation.chars().next(), tree.chars().next());\n-        match *obligation {\n-            \"A.1\" => Ok(Some(vec![])),\n-            \"A.2\" => Err(\"A is for apple\"),\n-            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n-            _ => unreachable!(),\n-        }\n-    });\n-    assert_eq!(ok, vec![\"A.1\"]);\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A.1\" => Ok(Some(vec![])),\n+                \"A.2\" => Err(\"A is for apple\"),\n+                \"A.3.i\" => Ok(Some(vec![])),\n+                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_| {}));\n+    assert_eq!(ok, vec![\"A.3\", \"A.1\", \"A.3.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"A is for apple\",\n                         backtrace: vec![\"A.2\", \"A\"],\n                     }]);\n \n-    // fourth round: error in D.1.i that should propagate to D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n-                                                                                 tree,\n-                                                                                 _| {\n-        assert_eq!(obligation.chars().next(), tree.chars().next());\n-        match *obligation {\n-            \"D.1.i\" => Err(\"D is for dumb\"),\n-            _ => panic!(\"unexpected obligation {:?}\", obligation),\n-        }\n-    });\n-    assert_eq!(ok, Vec::<&'static str>::new());\n+    // fourth round: error in D.1.i\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D.1.i\" => Err(\"D is for dumb\"),\n+                \"D.2.i\" => Ok(Some(vec![])),\n+                _ => panic!(\"unexpected obligation {:?}\", obligation),\n+            }\n+        }, |_| {}));\n+    assert_eq!(ok, vec![\"D.2.i\", \"D.2\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"D is for dumb\",\n@@ -113,124 +162,259 @@ fn push_pop() {\n #[test]\n fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n+    forest.register_obligation(\"A\");\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.1\" => Ok(Some(vec![])),\n                 \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n                 \"A.3\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"A.3\", \"A.1\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n                 \"A.2.ii\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.2.i.a\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations::<(), _>(|_,\n-                                                                                          _,\n-                                                                                          _| {\n-        unreachable!()\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}));\n+\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n \n #[test]\n fn to_errors_no_throw() {\n     // check that converting multiple children with common parent (A)\n-    // only yields one of them (and does not panic, in particular).\n+    // yields to correct errors (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n+    forest.register_obligation(\"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_|{}));\n     assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n     let errors = forest.to_errors(());\n-    assert_eq!(errors.len(), 1);\n+    assert_eq!(errors[0].backtrace, vec![\"A.1\", \"A\"]);\n+    assert_eq!(errors[1].backtrace, vec![\"A.2\", \"A\"]);\n+    assert_eq!(errors[2].backtrace, vec![\"A.3\", \"A\"]);\n+    assert_eq!(errors.len(), 3);\n }\n \n #[test]\n-fn backtrace() {\n-    // check that converting multiple children with common parent (A)\n-    // only yields one of them (and does not panic, in particular).\n+fn diamond() {\n+    // check that diamond dependencies are handled correctly\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n+    forest.register_obligation(\"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            assert!(backtrace.next().is_none());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\"])),\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\"])),\n                 _ => unreachable!(),\n             }\n-        });\n-    assert!(ok.is_empty());\n-    assert!(err.is_empty());\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            assert!(backtrace.next().unwrap() == &\"A\");\n-            assert!(backtrace.next().is_none());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![\"A.1.i\"])),\n+                \"A.1\" => Ok(Some(vec![\"D\"])),\n+                \"A.2\" => Ok(Some(vec![\"D\"])),\n                 _ => unreachable!(),\n             }\n-        });\n-    assert!(ok.is_empty());\n-    assert!(err.is_empty());\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n+    let mut d_count = 0;\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            assert!(backtrace.next().unwrap() == &\"A.1\");\n-            assert!(backtrace.next().unwrap() == &\"A\");\n-            assert!(backtrace.next().is_none());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1.i\" => Ok(None),\n+                \"D\" => { d_count += 1; Ok(Some(vec![])) },\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_|{}));\n+    assert_eq!(d_count, 1);\n+    assert_eq!(ok, vec![\"D\", \"A.2\", \"A.1\", \"A\"]);\n+    assert_eq!(err.len(), 0);\n+\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 0);\n+\n+    forest.register_obligation(\"A'\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A'\" => Ok(Some(vec![\"A'.1\", \"A'.2\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n     assert_eq!(ok.len(), 0);\n-    assert!(err.is_empty());\n+    assert_eq!(err.len(), 0);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A'.1\" => Ok(Some(vec![\"D'\", \"A'\"])),\n+                \"A'.2\" => Ok(Some(vec![\"D'\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n+    let mut d_count = 0;\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D'\" => { d_count += 1; Err(\"operation failed\") },\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(d_count, 1);\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"operation failed\",\n+        backtrace: vec![\"D'\", \"A'.1\", \"A'\"]\n+    }]);\n+\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 0);\n+}\n+\n+#[test]\n+fn done_dependency() {\n+    // check that the local cache works\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"A: Sized\");\n+    forest.register_obligation(\"B: Sized\");\n+    forest.register_obligation(\"C: Sized\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok, vec![\"C: Sized\", \"B: Sized\", \"A: Sized\"]);\n+    assert_eq!(err.len(), 0);\n+\n+    forest.register_obligation(\"(A,B,C): Sized\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"(A,B,C): Sized\" => Ok(Some(vec![\n+                    \"A: Sized\",\n+                    \"B: Sized\",\n+                    \"C: Sized\"\n+                        ])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n+    assert_eq!(err.len(), 0);\n+\n+\n+}\n+\n+\n+#[test]\n+fn orphan() {\n+    // check that orphaned nodes are handled correctly\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"A\");\n+    forest.register_obligation(\"B\");\n+    forest.register_obligation(\"C1\");\n+    forest.register_obligation(\"C2\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"D\", \"E\"])),\n+                \"B\" => Ok(None),\n+                \"C1\" => Ok(Some(vec![])),\n+                \"C2\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok, vec![\"C2\", \"C1\"]);\n+    assert_eq!(err.len(), 0);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D\" | \"E\" => Ok(None),\n+                \"B\" => Ok(Some(vec![\"D\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D\" => Ok(None),\n+                \"E\" => Err(\"E is for error\"),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"E is for error\",\n+        backtrace: vec![\"E\", \"A\"]\n+    }]);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D\" => Err(\"D is dead\"),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"D is dead\",\n+        backtrace: vec![\"D\"]\n+    }]);\n+\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 0);\n }"}, {"sha": "499448634acbdbeeea90e6ee39bfdec6371dd5ff", "filename": "src/librustc_data_structures/obligation_forest/tree_index.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cd6a400175cc230008a5094a8bbb44a3794f0465/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6a400175cc230008a5094a8bbb44a3794f0465/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftree_index.rs?ref=cd6a400175cc230008a5094a8bbb44a3794f0465", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::u32;\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub struct TreeIndex {\n-    index: u32,\n-}\n-\n-impl TreeIndex {\n-    pub fn new(value: usize) -> TreeIndex {\n-        assert!(value < (u32::MAX as usize));\n-        TreeIndex { index: value as u32 }\n-    }\n-\n-    pub fn get(self) -> usize {\n-        self.index as usize\n-    }\n-}"}, {"sha": "4bf428ef46d9b4db5cc49918fd13e5b182d1bc38", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -247,7 +247,8 @@ pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!(\n         \"rustc {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n+//        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n+        \"nightly edition\"\n     )\n }\n "}, {"sha": "8aaf752125690d829c7e40518d6032191e8e8969", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -14,5 +14,4 @@ pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n     //~^ ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n     //~| ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n-    //~| ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n }"}, {"sha": "6f4b211452c8215a4c2663f8a2c1508f747ed968", "filename": "src/test/compile-fail/check_on_unimplemented_on_slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck_on_unimplemented_on_slice.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -12,6 +12,8 @@\n \n #![feature(rustc_attrs)]\n \n+use std::ops::Index;\n+\n #[rustc_error]\n fn main() {\n     let x = &[1, 2, 3] as &[i32];"}, {"sha": "2a86cdef9812fb88da2b80c8950634921f6648a9", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -27,12 +27,14 @@ fn f<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a = &t as &Gettable<T>;\n     //~^ ERROR : std::marker::Send` is not satisfied\n+    //~^^ ERROR : std::marker::Copy` is not satisfied\n }\n \n fn g<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a: &Gettable<T> = &t;\n     //~^ ERROR : std::marker::Send` is not satisfied\n+    //~^^ ERROR : std::marker::Copy` is not satisfied\n }\n \n fn foo<'a>() {"}, {"sha": "58c0791b84ec5b25c05e30dc063c1a6a444e9b4c", "filename": "src/test/compile-fail/not-panic-safe-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -18,6 +18,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<Rc<RefCell<i32>>>(); //~ ERROR E0277\n+    assert::<Rc<RefCell<i32>>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }\n-"}, {"sha": "481ffb802812a02f30718384c32fa9b4f6690d57", "filename": "src/test/compile-fail/not-panic-safe-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -18,5 +18,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<Arc<RefCell<i32>>>(); //~ ERROR E0277\n+    assert::<Arc<RefCell<i32>>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }"}, {"sha": "47302d3af78b2909d8159a4d3fb5dab267267e23", "filename": "src/test/compile-fail/not-panic-safe-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -17,5 +17,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<&RefCell<i32>>(); //~ ERROR E0277\n+    assert::<&RefCell<i32>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }"}, {"sha": "fe13b0a75c9eb18dd7f7de6ad99b7e42c74e7543", "filename": "src/test/compile-fail/not-panic-safe-6.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -17,6 +17,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<*mut RefCell<i32>>(); //~ ERROR E0277\n+    assert::<*mut RefCell<i32>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }\n-"}, {"sha": "1a5b5ff206ad0de73445c8057ff7663f094fb593", "filename": "src/test/compile-fail/on_unimplemented.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cd6a400175cc230008a5094a8bbb44a3794f0465/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6a400175cc230008a5094a8bbb44a3794f0465/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon_unimplemented.rs?ref=cd6a400175cc230008a5094a8bbb44a3794f0465", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test if the on_unimplemented message override works\n-\n-#![feature(on_unimplemented)]\n-#![feature(rustc_attrs)]\n-\n-#[rustc_on_unimplemented = \"invalid\"]\n-trait Index<Idx: ?Sized> {\n-    type Output: ?Sized;\n-    fn index(&self, index: Idx) -> &Self::Output;\n-}\n-\n-#[rustc_on_unimplemented = \"a isize is required to index into a slice\"]\n-impl Index<isize> for [i32] {\n-    type Output = i32;\n-    fn index(&self, index: isize) -> &i32 {\n-        &self[index as usize]\n-    }\n-}\n-\n-#[rustc_on_unimplemented = \"a usize is required to index into a slice\"]\n-impl Index<usize> for [i32] {\n-    type Output = i32;\n-    fn index(&self, index: usize) -> &i32 {\n-        &self[index]\n-    }\n-}\n-\n-trait Foo<A, B> {\n-    fn f(&self, a: &A, b: &B);\n-}\n-\n-#[rustc_on_unimplemented = \"two i32 Foo trait takes\"]\n-impl Foo<i32, i32> for [i32] {\n-    fn f(&self, a: &i32, b: &i32) {}\n-}\n-\n-#[rustc_on_unimplemented = \"two u32 Foo trait takes\"]\n-impl Foo<u32, u32> for [i32] {\n-    fn f(&self, a: &u32, b: &u32) {}\n-}\n-\n-#[rustc_error]\n-fn main() {\n-    Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32); //~ ERROR E0277\n-                                                     //~| NOTE a usize is required\n-                                                     //~| NOTE required by\n-    Index::<i32>::index(&[1, 2, 3] as &[i32], 2i32); //~ ERROR E0277\n-                                                     //~| NOTE a isize is required\n-                                                     //~| NOTE required by\n-\n-    Foo::<usize, usize>::f(&[1, 2, 3] as &[i32], &2usize, &2usize); //~ ERROR E0277\n-                                                                    //~| NOTE two u32 Foo trait\n-                                                                    //~| NOTE required by\n-}"}, {"sha": "5b0dd256b4c41788670d51f2c66f4fddc3d30a4e", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -17,7 +17,9 @@ pub fn main() {\n \n     // Bool => does not implement iterator.\n     for i in false..true {}\n-    //~^ ERROR E0277\n+    //~^ ERROR `bool: std::num::One` is not satisfied\n+    //~^^ ERROR `bool: std::iter::Step` is not satisfied\n+    //~^^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];"}, {"sha": "2d4df77f960452a126928ce40ee05fb108324012", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -21,7 +21,5 @@ fn main() {\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038\n-    //~| ERROR E0038\n-    //~| ERROR E0038\n     //~| ERROR E0277\n }"}, {"sha": "2968e8a7ca9968edaeb83f689ab50274800dded0", "filename": "src/test/compile-fail/traits-inductive-overflow-simultaneous.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-simultaneous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786b26d7b48accffc638f8c2767a6e4a6f1991a5/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-simultaneous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-inductive-overflow-simultaneous.rs?ref=786b26d7b48accffc638f8c2767a6e4a6f1991a5", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #33344, initial version. This example allowed\n+// arbitrary trait bounds to be synthesized.\n+\n+trait Tweedledum: IntoIterator {}\n+trait Tweedledee: IntoIterator {}\n+\n+impl<T: Tweedledum> Tweedledee for T {}\n+impl<T: Tweedledee> Tweedledum for T {}\n+\n+trait Combo: IntoIterator {}\n+impl<T: Tweedledee + Tweedledum> Combo for T {}\n+\n+fn is_ee<T: Combo>(t: T) {\n+    t.into_iter();\n+}\n+\n+fn main() {\n+    is_ee(4);\n+    //~^ ERROR overflow evaluating the requirement `_: Tweedle\n+}"}]}