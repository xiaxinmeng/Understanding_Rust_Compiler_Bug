{"sha": "582e1f13f068dd85411405672e29ead829238fbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4MmUxZjEzZjA2OGRkODU0MTE0MDU2NzJlMjllYWQ4MjkyMzhmYmM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-25T05:17:17Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-25T05:36:53Z"}, "message": "Invalidate constraints correctly after an assignment expression\n\nModified typestate to throw away any constraints mentioning a\nvariable on the LHS of an assignment, recv, assign_op, or on\neither side of a swap.\n\nSome code cleanup as well.", "tree": {"sha": "bf3d42e9425857753693fea585e5aa3e9d9ac64b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf3d42e9425857753693fea585e5aa3e9d9ac64b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/582e1f13f068dd85411405672e29ead829238fbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/582e1f13f068dd85411405672e29ead829238fbc", "html_url": "https://github.com/rust-lang/rust/commit/582e1f13f068dd85411405672e29ead829238fbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/582e1f13f068dd85411405672e29ead829238fbc/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "818d7c939881e22ffd9ff15383cac3f06b60f4fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/818d7c939881e22ffd9ff15383cac3f06b60f4fd", "html_url": "https://github.com/rust-lang/rust/commit/818d7c939881e22ffd9ff15383cac3f06b60f4fd"}], "stats": {"total": 816, "additions": 441, "deletions": 375}, "files": [{"sha": "1778014da01a3c80323e1e3d6577425fa10a39a3", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -11,6 +11,9 @@ type ident = str;\n // Functions may or may not have names.\n type fn_ident = option::t[ident];\n \n+// FIXME: with typestate constraint, could say\n+// idents and types are the same length, and are\n+// non-empty\n type path_ = rec(vec[ident] idents, vec[@ty] types);\n \n type path = spanned[path_];"}, {"sha": "d8aae77e6218ed05a93fc91c83dfa22289ae0c09", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -112,28 +112,37 @@ fn set_in_postcond(uint i, &pre_and_post p) -> bool {\n     // sets the ith bit in p's post\n     auto was_set = tritv_get(p.postcondition, i);\n     tritv_set(i, p.postcondition, ttrue);\n-    ret was_set != ttrue;\n+    ret was_set == dont_care;\n }\n \n fn set_in_poststate(uint i, &pre_and_post_state s) -> bool {\n     // sets the ith bit in p's post\n-    auto was_set = tritv_get(s.poststate, i);\n-    tritv_set(i, s.poststate, ttrue);\n-    ret was_set != ttrue;\n+    ret set_in_poststate_(i, s.poststate);\n+}\n+\n+fn set_in_poststate_(uint i, &poststate p) -> bool {\n+    auto was_set = tritv_get(p, i);\n+    tritv_set(i, p, ttrue);\n+    ret was_set == dont_care;\n+\n }\n \n fn clear_in_poststate(uint i, &pre_and_post_state s) -> bool {\n     // sets the ith bit in p's post\n-    auto was_set = tritv_get(s.poststate, i);\n-    tritv_set(i, s.poststate, tfalse);\n-    ret was_set != tfalse;\n+    ret clear_in_poststate_(i, s.poststate);\n+}\n+\n+fn clear_in_poststate_(uint i, &poststate s) -> bool {\n+    auto was_set = tritv_get(s, i);\n+    tritv_set(i, s, tfalse);\n+    ret was_set == dont_care;\n }\n \n fn clear_in_postcond(uint i, &pre_and_post s) -> bool {\n     // sets the ith bit in p's post\n     auto was_set = tritv_get(s.postcondition, i);\n     tritv_set(i, s.postcondition, tfalse);\n-    ret was_set != tfalse;\n+    ret was_set == dont_care;\n }\n \n // Sets all the bits in a's precondition to equal the\n@@ -222,6 +231,14 @@ fn implies(t a, t b) -> bool {\n     tritv_difference(tmp, a);\n     ret tritv_doesntcare(tmp);\n }\n+\n+fn trit_str(trit t) -> str {\n+    alt (t) {\n+        case (dont_care) { \"?\" }\n+        case (ttrue)     { \"1\" }\n+        case (tfalse)    { \"0\" }\n+    }\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "e88b934ab05307e90f3d7facb414e7281ab12e71", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 86, "deletions": 16, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -39,6 +39,7 @@ import tstate::ann::set_postcondition;\n import tstate::ann::ts_ann;\n import tstate::ann::clear_in_postcond;\n import tstate::ann::clear_in_poststate;\n+import tstate::ann::clear_in_poststate_;\n import tritv::*;\n \n import pretty::ppaux::constr_args_to_str;\n@@ -655,8 +656,9 @@ tag if_ty {\n     plain_if;\n }\n \n-fn local_node_id_to_def_id(&fn_ctxt fcx, &span sp, &node_id i) -> def_id {\n-    alt (fcx.ccx.tcx.def_map.find(i)) {\n+fn local_node_id_to_def_id_strict(&fn_ctxt fcx, &span sp, &node_id i) \n+    -> def_id {\n+    alt (local_node_id_to_def(fcx, i)) {\n         case (some(def_local(?d_id))) {\n             ret d_id;\n         }\n@@ -675,30 +677,86 @@ fn local_node_id_to_def_id(&fn_ctxt fcx, &span sp, &node_id i) -> def_id {\n     }\n }\n \n-fn forget_in_postcond(&fn_ctxt fcx, &span dead_sp,\n-                      node_id parent_exp, node_id dead_v) {\n+fn local_node_id_to_def(&fn_ctxt fcx, &node_id i) -> option::t[def]\n+  { fcx.ccx.tcx.def_map.find(i) }\n+\n+fn local_node_id_to_def_id(&fn_ctxt fcx, &node_id i) -> option::t[def_id] {\n+    alt (local_node_id_to_def(fcx, i)) {\n+        case (some(def_local(?d_id))) { some(d_id) }\n+        case (some (def_arg(?a_id)))  { some(a_id) } \n+        case (_)                      { none }\n+    }\n+}\n+\n+/* FIXME should refactor this better */\n+fn forget_in_postcond(&fn_ctxt fcx, node_id parent_exp, node_id dead_v) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d_id = local_node_id_to_def_id(fcx, dead_sp, dead_v);\n-    for (norm_constraint c in constraints(fcx)) {\n-        if (constraint_mentions(fcx, c, d_id)) {\n-            clear_in_postcond(c.bit_num,\n-              node_id_to_ts_ann(fcx.ccx, parent_exp).conditions);\n+    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    alt (d) {\n+        case (some(?d_id)) {\n+            for (norm_constraint c in constraints(fcx)) {\n+                if (constraint_mentions(fcx, c, d_id)) {\n+                    clear_in_postcond(c.bit_num,\n+                      node_id_to_ts_ann(fcx.ccx, parent_exp).conditions);\n+                }\n+            }\n         }\n+        case (_) {}\n     }\n }\n \n-fn forget_in_poststate(&fn_ctxt fcx, &span dead_sp, \n-                       node_id parent_exp, node_id dead_v) -> bool {\n+fn forget_in_postcond_still_init(&fn_ctxt fcx, node_id parent_exp,\n+                                 node_id dead_v) {\n+    // In the postcondition given by parent_exp, clear the bits\n+    // for any constraints mentioning dead_v\n+    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    alt (d) {\n+        case (some(?d_id)) {\n+            for (norm_constraint c in constraints(fcx)) {\n+                if (non_init_constraint_mentions(fcx, c, d_id)) {\n+                    clear_in_postcond(c.bit_num,\n+                      node_id_to_ts_ann(fcx.ccx, parent_exp).conditions);\n+                }\n+            }\n+        }\n+        case (_) { }\n+    }\n+}\n+\n+fn forget_in_poststate(&fn_ctxt fcx, &poststate p, node_id dead_v) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n-    auto d_id = local_node_id_to_def_id(fcx, dead_sp, dead_v);\n+    auto d = local_node_id_to_def_id(fcx, dead_v);\n     auto changed = false;\n-    for (norm_constraint c in constraints(fcx)) {\n-        if (constraint_mentions(fcx, c, d_id)) {\n-            changed = clear_in_poststate(c.bit_num,\n-              node_id_to_ts_ann(fcx.ccx, parent_exp).states) || changed;\n+    alt (d) {\n+        case (some(?d_id)) {\n+            for (norm_constraint c in constraints(fcx)) {\n+                if (constraint_mentions(fcx, c, d_id)) {\n+                    changed = clear_in_poststate_(c.bit_num, p) || changed;\n+                }\n+            }\n+        }\n+        case (_) {}\n+    }\n+    ret changed;\n+}\n+\n+fn forget_in_poststate_still_init(&fn_ctxt fcx, &poststate p, node_id dead_v)\n+    -> bool {\n+    // In the poststate given by parent_exp, clear the bits\n+    // for any constraints mentioning dead_v\n+    auto d = local_node_id_to_def_id(fcx, dead_v);\n+    auto changed = false;\n+    alt (d) {\n+        case (some(?d_id)) {\n+            for (norm_constraint c in constraints(fcx)) {\n+                if (non_init_constraint_mentions(fcx, c, d_id)) {\n+                    changed = clear_in_poststate_(c.bit_num, p) || changed;\n+                }\n+            }\n         }\n+        case (_) {}\n     }\n     ret changed;\n }\n@@ -714,6 +772,18 @@ fn constraint_mentions(&fn_ctxt fcx, &norm_constraint c, &def_id v) -> bool {\n         });\n }\n \n+fn non_init_constraint_mentions(&fn_ctxt fcx, &norm_constraint c,\n+                                &def_id v) -> bool {\n+    ret (alt (c.c.node.c) {\n+            case (ninit(_)) {\n+                false\n+            }\n+            case (npred(_, ?args)) {\n+                args_mention(args, v)\n+            }\n+        });\n+}\n+\n \n fn args_mention(&vec[@constr_arg_use] args, &def_id v) -> bool {\n     fn mentions(&def_id v, &@constr_arg_use a) -> bool {"}, {"sha": "21934ca04b7829a1c1d1160a5c77b3673fb8f2ae", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -1,7 +1,10 @@\n+\n import front::ast::*;\n+import std::option::*;\n import std::vec;\n import std::vec::len;\n import std::vec::slice;\n+import aux::local_node_id_to_def;\n import aux::fn_ctxt;\n import aux::fn_info;\n import aux::log_tritv;\n@@ -38,7 +41,9 @@ import tstate::ann::intersect;\n import tstate::ann::clone;\n import tstate::ann::set_in_postcond;\n import tstate::ann::set_in_poststate;\n+import tstate::ann::set_in_poststate_;\n import tstate::ann::clear_in_poststate;\n+import tstate::ann::clear_in_poststate_;\n import tritv::*;\n \n fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n@@ -219,6 +224,36 @@ fn kill_poststate(&fn_ctxt fcx, node_id id, &constr_ c) -> bool {\n     ret clear_in_poststate(bit_num(fcx, c),\n                            node_id_to_ts_ann(fcx.ccx, id).states);\n }\n+\n+fn clear_in_poststate_expr(&fn_ctxt fcx, &@expr e, &poststate t) {\n+    alt (e.node) {\n+        case (expr_path(?p)) {\n+            alt (vec::last(p.node.idents)) {\n+                case (some(?i)) {\n+                    alt (local_node_id_to_def(fcx, e.id)) {\n+                        case (some(def_local(?d_id))) {\n+                            clear_in_poststate_(bit_num(fcx,\n+                                                        rec(id=d_id._1,\n+                                                            c=ninit(i))), t);\n+                        }\n+                        case (some(_)) { /* ignore args (for now...) */ }\n+                        case (_) { \n+                            fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n+                                   unbound var\"); }\n+                        }\n+                }\n+                case (_) { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr\"); }\n+            }\n+        }\n+        case (_) { /* do nothing */ }\n+    }\n+}\n+\n+fn set_in_poststate_ident(&fn_ctxt fcx, &node_id id, &ident ident,\n+                          &poststate t) -> bool {\n+    ret set_in_poststate_(bit_num(fcx, rec(id=id, c=ninit(ident))), t);\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "4455f09bdc2fbebf12ebfe8f68aee30020a79314", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -48,6 +48,7 @@ import aux::if_ty;\n import aux::if_check;\n import aux::plain_if;\n import aux::forget_in_postcond;\n+import aux::forget_in_postcond_still_init;\n \n import aux::constraints_expr;\n import aux::substitute_constr_args;\n@@ -61,7 +62,6 @@ import bitvectors::seq_postconds;\n import bitvectors::intersect_postconds;\n import bitvectors::declare_var;\n import bitvectors::gen_poststate;\n-import bitvectors::kill_poststate;\n import bitvectors::relax_precond_block;\n import bitvectors::gen;\n import front::ast::*;\n@@ -274,27 +274,21 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n     auto enclosing = fcx.enclosing;\n     auto num_local_vars = num_constraints(enclosing);\n     fn do_rand_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n-    log \"find_pre_post_expr (num_constraints =\" + uistr(num_local_vars) +\n-        \"):\";\n-    log_expr(*e);\n+\n     alt (e.node) {\n         case (expr_call(?operator, ?operands)) {\n-            auto args = vec::clone[@expr](operands);\n-            vec::push[@expr](args, operator);\n+            auto args = vec::clone(operands);\n+            vec::push(args, operator);\n             find_pre_post_exprs(fcx, args, e.id);\n             /* see if the call has any constraints on its type */\n-\n-            log \"a function: \";\n-            log_expr(*operator);\n-            auto pp = expr_pp(fcx.ccx, e);\n             for (@ty::constr_def c in constraints_expr(fcx.ccx.tcx, operator))\n                 {\n                     auto i =\n                         bit_num(fcx,\n                                 rec(id=c.node.id._1,\n                                     c=substitute_constr_args(fcx.ccx.tcx,\n                                                              operands, c)));\n-                    require(i, pp);\n+                    require(i, expr_pp(fcx.ccx, e));\n                 }\n \n             /* if this is a failing call, its postcondition sets everything */\n@@ -304,8 +298,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             }\n         }\n         case (expr_spawn(_, _, ?operator, ?operands)) {\n-            auto args = vec::clone[@expr](operands);\n-            vec::push[@expr](args, operator);\n+            auto args = vec::clone(operands);\n+            vec::push(args, operator);\n             find_pre_post_exprs(fcx, args, e.id);\n         }\n         case (expr_vec(?args, _, _)) {\n@@ -356,7 +350,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         }\n         case (expr_rec(?fields, ?maybe_base)) {\n             auto es = field_exprs(fields);\n-            vec::plus_option[@expr](es, maybe_base);\n+            vec::plus_option(es, maybe_base);\n             find_pre_post_exprs(fcx, es, e.id);\n         }\n         case (expr_move(?lhs, ?rhs)) {\n@@ -366,17 +360,22 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 }\n                 case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n             }\n-            forget_in_postcond(fcx, rhs.span, e.id, rhs.id);\n+            forget_in_postcond(fcx, e.id, rhs.id);\n         }\n         case (expr_swap(?lhs, ?rhs)) {\n             // Both sides must already be initialized\n             \n             find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n+            forget_in_postcond_still_init(fcx, e.id, lhs.id);\n+            forget_in_postcond_still_init(fcx, e.id, rhs.id);\n+            // Could be more precise and swap the roles of lhs and rhs\n+            // in any constraints\n         }\n         case (expr_assign(?lhs, ?rhs)) {\n             alt (lhs.node) {\n                 case (expr_path(?p)) {\n                     gen_if_local(fcx, lhs, rhs, e.id, lhs.id, p);\n+                    forget_in_postcond_still_init(fcx, e.id, lhs.id);\n                 }\n                 case (_) { find_pre_post_exprs(fcx, [lhs, rhs], e.id); }\n             }\n@@ -385,7 +384,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             alt (rhs.node) {\n                 case (expr_path(?p)) {\n                     gen_if_local(fcx, rhs, lhs, e.id, rhs.id, p);\n-                }\n+                    forget_in_postcond_still_init(fcx, e.id, lhs.id);\n+                 }\n                 case (_) {\n                     // doesn't check that rhs is an lval, but\n                     // that's probably ok\n@@ -399,6 +399,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                already be initialized */\n \n             find_pre_post_exprs(fcx, [lhs, rhs], e.id);\n+            forget_in_postcond_still_init(fcx, e.id, lhs.id);\n         }\n         case (expr_lit(_)) { clear_pp(expr_pp(fcx.ccx, e)); }\n         case (expr_ret(?maybe_val)) {\n@@ -585,8 +586,8 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n                             \n                             alt (an_init.op) {\n                                 case (init_move) {\n-                                    forget_in_postcond(fcx, an_init.expr.span,\n-                                                       id, an_init.expr.id);\n+                                    forget_in_postcond(fcx, id,\n+                                                       an_init.expr.id);\n                                 }\n                                 case (_) { /* nothing gets deinitialized */ } \n                             }"}, {"sha": "673186e4415c54c8783853a212337bc74099e89f", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 198, "deletions": 316, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -7,20 +7,21 @@ import std::option::is_none;\n import std::option::none;\n import std::option::some;\n import std::option::maybe;\n+import tstate::ann::set_in_poststate_;\n import tstate::ann::pre_and_post;\n import tstate::ann::get_post;\n import tstate::ann::postcond;\n import tstate::ann::empty_pre_post;\n import tstate::ann::empty_poststate;\n-import tstate::ann::require_and_preserve;\n+import tstate::ann::clear_in_poststate;\n import tstate::ann::intersect;\n import tstate::ann::empty_prestate;\n import tstate::ann::prestate;\n import tstate::ann::poststate;\n import tstate::ann::false_postcond;\n import tstate::ann::ts_ann;\n-import tstate::ann::extend_prestate;\n-import tstate::ann::extend_poststate;\n+import tstate::ann::set_prestate;\n+import tstate::ann::set_poststate;\n import aux::crate_ctxt;\n import aux::fn_ctxt;\n import aux::num_constraints;\n@@ -61,13 +62,14 @@ import aux::if_ty;\n import aux::if_check;\n import aux::plain_if;\n import aux::forget_in_poststate;\n+import aux::forget_in_poststate_still_init;\n import tritv::tritv_clone;\n import tritv::tritv_set;\n import tritv::ttrue;\n \n-import bitvectors::seq_preconds;\n+import bitvectors::set_in_poststate_ident;\n+import bitvectors::clear_in_poststate_expr;\n import bitvectors::intersect_postconds;\n-import bitvectors::declare_var;\n import bitvectors::bit_num;\n import bitvectors::gen_poststate;\n import bitvectors::kill_poststate;\n@@ -89,23 +91,101 @@ import util::common::log_stmt;\n import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n+// Used to communicate which operands should be invalidated\n+// to helper functions\n+tag oper_type {\n+    oper_move;\n+    oper_swap;\n+    oper_assign;\n+    oper_pure;\n+}\n+\n fn seq_states(&fn_ctxt fcx, prestate pres, vec[@expr] exprs) ->\n    tup(bool, poststate) {\n     auto changed = false;\n     auto post = pres;\n     for (@expr e in exprs) {\n         changed = find_pre_post_state_expr(fcx, post, e) || changed;\n+        // log_err(\"Seq_states: changed =\");\n+        // log_err changed;\n         post = expr_poststate(fcx.ccx, e);\n     }\n     ret tup(changed, post);\n }\n \n+fn find_pre_post_state_sub(&fn_ctxt fcx, &prestate pres, &@expr e,\n+                           node_id parent, option::t[aux::constr_] c)\n+    -> bool {\n+    auto changed = find_pre_post_state_expr(fcx, pres, e);\n+\n+    changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n+\n+    auto post = tritv_clone(expr_poststate(fcx.ccx, e));\n+    alt (c) {\n+        case (none) {}\n+        case (some(?c1)) {\n+            set_in_poststate_(bit_num(fcx, c1), post);\n+        }\n+    }\n+\n+    changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n+    ret changed;\n+}\n+\n+fn find_pre_post_state_two(&fn_ctxt fcx, &prestate pres, &@expr a, &@expr b,\n+                           node_id parent, oper_type op) -> bool {\n+    auto changed = set_prestate_ann(fcx.ccx, parent, pres);\n+    changed = find_pre_post_state_expr(fcx, pres, a) || changed;\n+    changed = find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, a), b)\n+        || changed;\n+\n+    // for termination, need to make sure intermediate changes don't set\n+    // changed flag\n+    auto post = tritv_clone(expr_poststate(fcx.ccx, b));\n+    alt (op) {\n+        case (oper_move) {\n+            forget_in_poststate(fcx, post, b.id);\n+            gen_if_local(fcx, post, a); \n+        }\n+        case (oper_swap) {\n+            forget_in_poststate_still_init(fcx, post, a.id);\n+            forget_in_poststate_still_init(fcx, post, b.id);\n+        }\n+        case (oper_assign) {\n+            forget_in_poststate_still_init(fcx, post, a.id);\n+            gen_if_local(fcx, post, a); \n+        }\n+        case (_) {}\n+    }\n+    changed = set_poststate_ann(fcx.ccx, parent, post) || changed;\n+    ret changed;\n+}\n+\n+fn find_pre_post_state_call(&fn_ctxt fcx, &prestate pres, &@expr a,\n+                            node_id id, &vec[@expr] bs,\n+                            controlflow cf) -> bool {\n+    auto changed = find_pre_post_state_expr(fcx, pres, a);\n+    ret find_pre_post_state_exprs(fcx,\n+          expr_poststate(fcx.ccx, a), id, bs, cf) || changed;\n+}\n+\n fn find_pre_post_state_exprs(&fn_ctxt fcx, &prestate pres, ast::node_id id,\n-                             &vec[@expr] es) -> bool {\n-    auto rslt = seq_states(fcx, pres, es);\n-    auto changed = rslt._0;\n-    changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n-    changed = extend_poststate_ann(fcx.ccx, id, rslt._1) || changed;\n+                             &vec[@expr] es, controlflow cf) -> bool {\n+    auto res = seq_states(fcx, pres, es);\n+    auto changed = res._0;\n+    changed = set_prestate_ann(fcx.ccx, id, pres) || changed;\n+    /* if this is a failing call, it sets everything as initialized */\n+    alt (cf) {\n+        case (noreturn) {\n+            changed =\n+                set_poststate_ann(fcx.ccx, id,\n+                   false_postcond(num_constraints(fcx.enclosing))) ||\n+                changed;\n+        }\n+        case (_) { \n+            changed = set_poststate_ann(fcx.ccx, id, res._1) || changed;\n+        }\n+    }\n     ret changed;\n }\n \n@@ -116,7 +196,7 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n \n     // FIXME: also want to set l as initialized, no?\n \n-    changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+    changed = set_prestate_ann(fcx.ccx, id, pres) || changed;\n     changed = find_pre_post_state_expr(fcx, pres, index) || changed;\n     /* in general, would need the intersection of\n        (poststate of index, poststate of body) */\n@@ -132,18 +212,22 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@local l,\n     auto res_p =\n         intersect_postconds([expr_poststate(fcx.ccx, index),\n                              block_poststate(fcx.ccx, body)]);\n-    changed = extend_poststate_ann(fcx.ccx, id, res_p) || changed;\n+    changed = set_poststate_ann(fcx.ccx, id, res_p) || changed;\n     ret changed;\n }\n \n-fn gen_if_local(&fn_ctxt fcx, node_id new_var, node_id id, &path p) -> bool {\n-    alt (node_id_to_def(fcx.ccx, new_var)) {\n-        case (some(def_local(?loc))) {\n-            ret gen_poststate(fcx, id,\n-                              rec(id=loc._1,\n-                                  c=ninit(path_to_ident(fcx.ccx.tcx, p))));\n+fn gen_if_local(&fn_ctxt fcx, &poststate p, &@expr e) -> bool {\n+    alt (e.node) {\n+        case (expr_path(?pth)) { \n+            alt (node_id_to_def(fcx.ccx, e.id)) {\n+                case (some(def_local(?loc))) {\n+                    ret set_in_poststate_ident(fcx, loc._1,\n+                           path_to_ident(fcx.ccx.tcx, pth), p);\n+                }\n+            case (_) { ret false; }\n+            }\n         }\n-        case (_) { ret false; }\n+    case (_) { ret false; }\n     }\n }\n \n@@ -152,7 +236,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                   &prestate pres) -> bool {\n     auto changed = false;\n \n-    changed = extend_prestate_ann(fcx.ccx, id, pres) || changed;\n+    changed = set_prestate_ann(fcx.ccx, id, pres) || changed;\n     changed = find_pre_post_state_expr(fcx, pres, antec) || changed;\n     \n     /*\n@@ -178,7 +262,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                                   conseq) || changed;\n    \n             changed =\n-                extend_poststate_ann(fcx.ccx, id,\n+                set_poststate_ann(fcx.ccx, id,\n                                      expr_poststate(fcx.ccx, antec))\n                 || changed;\n         }\n@@ -218,7 +302,7 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                block_poststate(fcx.ccx, conseq))); */\n \n             changed =\n-                extend_poststate_ann(fcx.ccx, id, poststate_res) ||\n+                set_poststate_ann(fcx.ccx, id, poststate_res) ||\n                 changed;\n         }\n     }\n@@ -228,100 +312,44 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n     auto changed = false;\n     auto num_local_vars = num_constraints(fcx.enclosing);\n-    /*\n-    log_err(\"states:\");\n-    log_expr_err(*e);\n-    aux::log_bitv_err(fcx, expr_prestate(fcx.ccx, e));\n-    aux::log_bitv_err(fcx, expr_poststate(fcx.ccx, e));\n-    */\n \n-    /* FIXME could get rid of some of the copy/paste */\n     alt (e.node) {\n         case (expr_vec(?elts, _, _)) {\n-            ret find_pre_post_state_exprs(fcx, pres, e.id, elts);\n+            ret find_pre_post_state_exprs(fcx, pres, e.id, elts, return);\n         }\n         case (expr_tup(?elts)) {\n-            ret find_pre_post_state_exprs(fcx, pres, e.id, elt_exprs(elts));\n+            ret find_pre_post_state_exprs(fcx, pres, e.id,\n+                                          elt_exprs(elts), return);\n         }\n         case (expr_call(?operator, ?operands)) {\n-            /* do the prestate for the rator */\n-\n-            /*            fcx.ccx.tcx.sess.span_note(operator.span, \n-                         \"pres = \" + aux::bitv_to_str(fcx, pres));\n-            */\n-\n-            changed =\n-                find_pre_post_state_expr(fcx, pres, operator) || changed;\n-            /* rands go left-to-right */\n-\n-            changed =\n-                find_pre_post_state_exprs(fcx,\n-                                          expr_poststate(fcx.ccx, operator),\n-                                          e.id, operands) || changed;\n-            /* if this is a failing call, it sets everything as initialized */\n-\n-            alt (controlflow_expr(fcx.ccx, operator)) {\n-                case (noreturn) {\n-                    changed =\n-                        set_poststate_ann(fcx.ccx, e.id,\n-                                          false_postcond(num_local_vars)) ||\n-                            changed;\n-                }\n-                case (_) { }\n-            }\n-\n-            /*            fcx.ccx.tcx.sess.span_note(operator.span, \n-               \"pres = \" + aux::bitv_to_str(fcx, expr_poststate(fcx.ccx, e)));\n-            */\n+            changed = find_pre_post_state_call(fcx, pres, operator,\n+                               e.id, operands,\n+                               controlflow_expr(fcx.ccx, operator))\n+                || changed;\n             ret changed;\n         }\n         case (expr_spawn(_, _, ?operator, ?operands)) {\n-            changed = find_pre_post_state_expr(fcx, pres, operator);\n-            ret find_pre_post_state_exprs(fcx,\n-                                          expr_poststate(fcx.ccx, operator),\n-                                          e.id, operands) || changed;\n-        }\n+            ret find_pre_post_state_call(fcx, pres, operator, e.id, operands,\n+                                         return);\n+         }\n         case (expr_bind(?operator, ?maybe_args)) {\n-            changed =\n-                find_pre_post_state_expr(fcx, pres, operator) || changed;\n-            ret find_pre_post_state_exprs\n-                (fcx, expr_poststate(fcx.ccx, operator), e.id,\n-                 cat_options[@expr](maybe_args)) || changed;\n+            ret find_pre_post_state_call(fcx, pres, operator, e.id,\n+                                         cat_options(maybe_args), return);\n         }\n         case (expr_path(_)) { ret pure_exp(fcx.ccx, e.id, pres); }\n         case (expr_log(_, ?ex)) {\n-            /* factor out the \"one exp\" pattern */\n-\n-            changed = find_pre_post_state_expr(fcx, pres, ex);\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, ex)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n         }\n         case (expr_chan(?ex)) {\n-            changed = find_pre_post_state_expr(fcx, pres, ex);\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, ex)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_sub(fcx, pres, ex, e.id, none);\n         }\n         case (expr_ext(_, _, _, ?expanded)) {\n-            changed = find_pre_post_state_expr(fcx, pres, expanded);\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, expanded)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_sub(fcx, pres, expanded, e.id, none);\n         }\n         case (expr_put(?maybe_e)) {\n             alt (maybe_e) {\n                 case (some(?arg)) {\n-                    changed = find_pre_post_state_expr(fcx, pres, arg);\n-                    changed = extend_prestate_ann\n-                        (fcx.ccx, e.id, pres) || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, arg)) ||\n-                        changed;\n-                    ret changed;\n+                    ret find_pre_post_state_sub(fcx, pres, arg, e.id, none);\n                 }\n                 case (none) { ret pure_exp(fcx.ccx, e.id, pres); }\n             }\n@@ -331,129 +359,55 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_fn(?f)) { ret pure_exp(fcx.ccx, e.id, pres); }\n         case (expr_block(?b)) {\n             changed = find_pre_post_state_block(fcx, pres, b) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = extend_poststate_ann\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_poststate_ann\n                 (fcx.ccx, e.id, block_poststate(fcx.ccx, b)) || changed;\n             ret changed;\n         }\n         case (expr_rec(?fields, ?maybe_base)) {\n             changed = find_pre_post_state_exprs\n-                (fcx, pres, e.id, field_exprs(fields)) || changed;\n+                (fcx, pres, e.id, field_exprs(fields), return) || changed;\n             alt (maybe_base) {\n                 case (none) {/* do nothing */ }\n                 case (some(?base)) {\n                     changed =\n                         find_pre_post_state_expr(fcx, pres, base) || changed;\n-                    changed = extend_poststate_ann\n+                    changed = set_poststate_ann\n                         (fcx.ccx, e.id, expr_poststate(fcx.ccx, base))\n                         || changed;\n                 }\n             }\n             ret changed;\n         }\n         case (expr_move(?lhs, ?rhs)) {\n-        \n-            extend_prestate_ann(fcx.ccx, e.id, pres);\n-            alt (lhs.node) {\n-                case (expr_path(?p)) {\n-                    // assignment to local var\n-\n-                    changed = pure_exp(fcx.ccx, lhs.id, pres) || changed;\n-                    changed = find_pre_post_state_expr\n-                        (fcx, pres, rhs) || changed;\n-                    // not extending e's poststate,\n-                    // because rhs is getting deinit'd anyway\n-                    changed = gen_if_local(fcx, lhs.id, e.id, p) || changed;\n-                }\n-                case (_) {\n-                    // assignment to something that must already have been\n-                    // init'd\n-\n-                    changed = find_pre_post_state_expr(fcx, pres, lhs)\n-                        || changed;\n-                    changed = find_pre_post_state_expr\n-                        (fcx, expr_poststate(fcx.ccx, lhs), rhs)\n-                        || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs))\n-                        || changed;\n-                }\n-            }\n-\n-            changed = forget_in_poststate(fcx, rhs.span, e.id, rhs.id)\n-                || changed;\n-            ret changed;\n+            ret find_pre_post_state_two(fcx, pres, lhs, rhs,\n+                                        e.id, oper_move);\n         }\n         case (expr_assign(?lhs, ?rhs)) {\n-            extend_prestate_ann(fcx.ccx, e.id, pres);\n-            alt (lhs.node) {\n-                case (expr_path(?p)) {\n-                    // assignment to local var\n-\n-                    changed = pure_exp(fcx.ccx, lhs.id, pres) || changed;\n-                    changed = find_pre_post_state_expr(fcx, pres, rhs)\n-                        || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs))\n-                        || changed;\n-                    changed = gen_if_local(fcx, lhs.id, e.id, p) || changed;\n-                }\n-                case (_) {\n-                    // assignment to something that must already have been\n-                    // init'd\n-\n-                    changed = find_pre_post_state_expr(fcx, pres, lhs)\n-                        || changed;\n-                    changed = find_pre_post_state_expr\n-                        (fcx, expr_poststate(fcx.ccx, lhs), rhs) || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs))\n-                        || changed;\n-                }\n-            }\n-            ret changed;\n+            ret find_pre_post_state_two(fcx, pres, lhs, rhs,\n+                                        e.id, oper_assign);\n         }\n         case (expr_swap(?lhs, ?rhs)) {\n-            /* quite similar to binary -- should abstract this */\n-\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-            changed = find_pre_post_state_expr\n-                (fcx, expr_poststate(fcx.ccx, lhs), rhs) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs)) || changed;\n-            ret changed;\n+           ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n+                                       oper_swap);\n+             // Could be more precise and actually swap the role of\n+             // lhs and rhs in constraints\n         }\n         case (expr_recv(?lhs, ?rhs)) {\n-            extend_prestate_ann(fcx.ccx, e.id, pres);\n-            alt (rhs.node) {\n-                case (expr_path(?p)) {\n-                    // receive to local var\n-\n-                    changed = pure_exp(fcx.ccx, rhs.id, pres) || changed;\n-                    changed = find_pre_post_state_expr(fcx, pres, lhs)\n-                        || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, lhs))\n-                        || changed;\n-                    changed = gen_if_local(fcx, rhs.id, e.id, p) || changed;\n-                }\n-                case (_) {\n-                    // receive to something that must already have been init'd\n-\n-                    changed = find_pre_post_state_expr\n-                        (fcx, pres, rhs) || changed;\n-                    changed = find_pre_post_state_expr\n-                        (fcx, expr_poststate(fcx.ccx, rhs), lhs) || changed;\n-                    changed = extend_poststate_ann\n-                        (fcx.ccx, e.id, expr_poststate(fcx.ccx, lhs))\n-                        || changed;\n-                }\n-            }\n+            // Opposite order as most other binary operations,\n+            // so not using find_pre_post_state_two\n+            auto changed = set_prestate_ann(fcx.ccx, e.id, pres);\n+            changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n+            changed = find_pre_post_state_expr(fcx,\n+                expr_poststate(fcx.ccx, lhs), rhs)  || changed;\n+            auto post = tritv_clone(expr_poststate(fcx.ccx, rhs));\n+            forget_in_poststate_still_init(fcx, post, rhs.id);\n+            gen_if_local(fcx, post, rhs); \n+            changed = set_poststate_ann(fcx.ccx, e.id, post) || changed;\n             ret changed;\n         }\n         case (expr_ret(?maybe_ret_val)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             /* normally, everything is true if execution continues after\n                a ret expression (since execution never continues locally\n                after a ret expression */\n@@ -471,14 +425,14 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             alt (maybe_ret_val) {\n                 case (none) {/* do nothing */ }\n                 case (some(?ret_val)) {\n-                    changed = find_pre_post_state_expr\n-                        (fcx, pres, ret_val) || changed;\n+                    changed = find_pre_post_state_expr(fcx, pres, ret_val)\n+                        || changed;\n                 }\n             }\n             ret changed;\n         }\n         case (expr_be(?val)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             set_poststate_ann(fcx.ccx, e.id, false_postcond(num_local_vars));\n             changed = find_pre_post_state_expr(fcx, pres, val) || changed;\n             ret changed;\n@@ -494,38 +448,17 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         }\n         case (expr_binary(?bop, ?l, ?r)) {\n             /* FIXME: what if bop is lazy? */\n-\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n-            changed = find_pre_post_state_expr\n-                (fcx, expr_poststate(fcx.ccx, l), r) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, r)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n         }\n         case (expr_send(?l, ?r)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, l) || changed;\n-            changed = find_pre_post_state_expr\n-                (fcx, expr_poststate(fcx.ccx, l), r) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, r)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_two(fcx, pres, l, r, e.id, oper_pure);\n         }\n         case (expr_assign_op(?op, ?lhs, ?rhs)) {\n-            /* quite similar to binary -- should abstract this */\n-\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n-            changed =\n-                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n-                                         rhs) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, rhs)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_two(fcx, pres, lhs, rhs, e.id,\n+                                        oper_assign);\n         }\n         case (expr_while(?test, ?body)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             /* to handle general predicates, we need to pass in\n                 pres `intersect` (poststate(a)) \n              like: auto test_pres = intersect_postconds(pres,\n@@ -547,12 +480,12 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n             auto e_post = expr_poststate(fcx.ccx, test);\n             auto b_post = block_poststate(fcx.ccx, body);\n-            ret extend_poststate_ann\n+            ret set_poststate_ann\n                 (fcx.ccx, e.id, intersect_postconds([e_post, b_post])) ||\n-                changed\n+                changed;\n         }\n         case (expr_do_while(?body, ?test)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             auto changed0 = changed;\n             changed = find_pre_post_state_block(fcx, pres, body) || changed;\n             /* conservative approximination: if the body of the loop\n@@ -579,7 +512,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                 set_poststate_ann(fcx.ccx, e.id, pres);\n             }\n             else {\n-                changed =  extend_poststate_ann(fcx.ccx, e.id,\n+                changed =  set_poststate_ann(fcx.ccx, e.id,\n                                             expr_poststate(fcx.ccx, test)) ||\n                     changed;\n             }\n@@ -592,18 +525,10 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             ret find_pre_post_state_loop(fcx, pres, d, index, body, e.id);\n         }\n         case (expr_index(?val, ?sub)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, val) || changed;\n-            changed =\n-                find_pre_post_state_expr\n-                (fcx, expr_poststate(fcx.ccx, val), sub) || changed;\n-            changed =\n-                extend_poststate_ann(fcx.ccx, e.id,\n-                                     expr_poststate(fcx.ccx, sub));\n-            ret changed;\n+            ret find_pre_post_state_two(fcx, pres, val, sub, e.id, oper_pure);\n         }\n         case (expr_alt(?val, ?alts)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             changed = find_pre_post_state_expr(fcx, pres, val) || changed;\n             auto e_post = expr_poststate(fcx.ccx, val);\n             auto a_post;\n@@ -624,32 +549,20 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n                 a_post = e_post;\n             }\n-            changed = extend_poststate_ann(fcx.ccx, e.id, a_post) || changed;\n+            changed = set_poststate_ann(fcx.ccx, e.id, a_post) || changed;\n             ret changed;\n         }\n         case (expr_field(?val, _)) {\n-            changed = find_pre_post_state_expr(fcx, pres, val);\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, val)) || changed;\n-            ret changed;\n+            ret find_pre_post_state_sub(fcx, pres, val, e.id, none);\n         }\n         case (expr_unary(_, ?operand)) {\n-            changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            ret extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, operand))\n-                || changed;\n+            ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n         }\n         case (expr_cast(?operand, _)) {\n-            changed = find_pre_post_state_expr(fcx, pres, operand) || changed;\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            ret extend_poststate_ann\n-                (fcx.ccx, e.id, expr_poststate(fcx.ccx, operand))\n-                || changed;\n+            ret find_pre_post_state_sub(fcx, pres, operand, e.id, none);\n         }\n         case (expr_fail(_)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n+            changed = set_prestate_ann(fcx.ccx, e.id, pres) || changed;\n             /* if execution continues after fail, then everything is true!\n                woo! */\n \n@@ -658,19 +571,14 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n             ret changed;\n         }\n         case (expr_assert(?p)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            changed = extend_poststate_ann(fcx.ccx, e.id, pres) || changed;\n-            ret changed;\n+            ret find_pre_post_state_sub(fcx, pres, p, e.id, none);\n         }\n         case (expr_check(?p)) {\n-            changed = extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, p) || changed;\n-            changed = extend_poststate_ann(fcx.ccx, e.id, pres) || changed;\n             /* predicate p holds after this expression executes */\n \n             let aux::constr c = expr_to_constr(fcx.ccx.tcx, p);\n-            changed = gen_poststate(fcx, e.id, c.node) || changed;\n+            changed = find_pre_post_state_sub(fcx, pres, p, e.id,\n+                          some(c.node)) || changed;\n             ret changed;\n         }\n         case (expr_if_check(?p, ?conseq, ?maybe_alt)) {\n@@ -686,14 +594,7 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         case (expr_anon_obj(?anon_obj, _, _)) {\n             alt (anon_obj.with_obj) {\n                 case (some(?wt)) {\n-                    changed = find_pre_post_state_expr(fcx, pres, wt);\n-                    changed =\n-                        extend_prestate_ann(fcx.ccx, e.id, pres) || changed;\n-                    changed =\n-                        extend_poststate_ann(fcx.ccx, e.id,\n-                                             expr_poststate(fcx.ccx, wt)) ||\n-                            changed;\n-                    ret changed;\n+                    ret find_pre_post_state_sub(fcx, pres, wt, e.id, none);\n                 }\n                 case (none) { ret pure_exp(fcx.ccx, e.id, pres); }\n             }\n@@ -705,15 +606,15 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n     auto changed = false;\n     auto stmt_ann = stmt_to_ann(fcx.ccx, *s);\n \n-    /*\n+    /*    \n     log_err \"*At beginning: stmt = \";\n     log_stmt_err(*s);\n     log_err \"*prestate = \";\n-    log_err bitv::to_str(stmt_ann.states.prestate);\n+    log_err tritv::to_str(stmt_ann.states.prestate);\n     log_err \"*poststate =\";\n-    log_err bitv::to_str(stmt_ann.states.poststate);\n-    log_err \"*changed =\";\n-    log_err changed;\n+    log_err tritv::to_str(stmt_ann.states.poststate);\n+    log_err \"pres = \";\n+    log_err tritv::to_str(pres);\n     */\n \n     alt (s.node) {\n@@ -723,37 +624,32 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                     alt (alocal.node.init) {\n                         case (some(?an_init)) {\n                             changed =\n-                                extend_prestate(stmt_ann.states.prestate,\n-                                                pres) || changed;\n+                                set_prestate(stmt_ann, pres) || changed;\n+                            \n                             changed =\n                                 find_pre_post_state_expr(fcx, pres,\n                                                          an_init.expr)\n                                 || changed;\n \n-\n-                            /* FIXME less copypasta */\n+                            auto post = tritv_clone(expr_poststate(fcx.ccx,\n+                                                      an_init.expr));\n                             alt (an_init.op) {\n                                 case (init_move) {\n-                                    changed = forget_in_poststate(fcx,\n-                                      an_init.expr.span, id, an_init.expr.id)\n-                                        || changed;\n-                /* Safe to forget rhs's poststate here 'cause it's a var. */\n+                                    clear_in_poststate_expr(fcx, an_init.expr,\n+                                                            post);\n                                 }\n-                                case (_) { /* nothing gets deinitialized */ \n-                                    changed =\n-                                      extend_poststate(\n-                                        stmt_ann.states.poststate,\n-                                        expr_poststate(fcx.ccx, an_init.expr))\n-                                        || changed;\n-                                } \n+                                case (_) { /* nothing gets deinitialized */ } \n                             }\n \n-                            changed =\n-                                gen_poststate(fcx, id,\n-                                              rec(id=alocal.node.id,\n-                                                  c=ninit(alocal.node.ident)))\n+                            set_in_poststate_ident(fcx, alocal.node.id,\n+                                                   alocal.node.ident, post);\n+\n+                            /* important to do this in one step to ensure\n+                               termination (don't want to set changed to true\n+                               for intermediate changes) */\n+                            changed = set_poststate(stmt_ann, post)\n                                 || changed;\n-                            \n+\n                             /*\n                             log_err \"Summary: stmt = \";\n                             log_stmt_err(*s);\n@@ -769,22 +665,18 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                         }\n                         case (none) {\n                             changed =\n-                                extend_prestate(stmt_ann.states.prestate,\n-                                                pres) || changed;\n+                                set_prestate(stmt_ann, pres) || changed;\n                             changed =\n-                                extend_poststate(stmt_ann.states.poststate,\n-                                                 pres) || changed;\n+                                set_poststate(stmt_ann, pres) || changed;\n                             ret changed;\n                         }\n                     }\n                 }\n                 case (decl_item(?an_item)) {\n                     changed =\n-                        extend_prestate(stmt_ann.states.prestate, pres) ||\n-                            changed;\n+                        set_prestate(stmt_ann, pres) || changed;\n                     changed =\n-                        extend_poststate(stmt_ann.states.poststate, pres) ||\n-                            changed;\n+                        set_poststate(stmt_ann, pres) || changed;\n                     /* the outer \"walk\" will recurse into the item */\n \n                     ret changed;\n@@ -794,14 +686,13 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n         case (stmt_expr(?ex, _)) {\n             changed = find_pre_post_state_expr(fcx, pres, ex) || changed;\n             changed =\n-                extend_prestate(stmt_ann.states.prestate,\n-                                expr_prestate(fcx.ccx, ex)) || changed;\n+                set_prestate(stmt_ann, expr_prestate(fcx.ccx, ex)) || changed;\n             changed =\n-                extend_poststate(stmt_ann.states.poststate,\n-                                 expr_poststate(fcx.ccx, ex)) || changed;\n-            \n+                set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex))\n+                || changed;\n+          \n             /*\n-              log_err(\"Summary: stmt = \");\n+            log_err \"Finally:\";\n               log_stmt_err(*s);\n               log_err(\"prestate = \");\n               //              log_err(bitv::to_str(stmt_ann.states.prestate));\n@@ -848,7 +739,7 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b) ->\n \n     set_prestate_ann(fcx.ccx, b.node.id, pres0);\n     set_poststate_ann(fcx.ccx, b.node.id, post);\n-    \n+\n     /*\n     log_err \"For block:\";\n     log_block_err(b);\n@@ -881,16 +772,7 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n             if (!type_is_nil(fcx.ccx.tcx, tailty) &&\n                     !type_is_bot(fcx.ccx.tcx, tailty)) {\n                 auto p = false_postcond(num_local_vars);\n-                set_poststate_ann(fcx.ccx, tailexpr.id, p);\n-                // be sure to set the block poststate to the same thing\n                 set_poststate_ann(fcx.ccx, f.body.node.id, p);\n-                alt (fcx.enclosing.cf) {\n-                    case (noreturn) {\n-                        kill_poststate(fcx, tailexpr.id,\n-                                       rec(id=fcx.id, c=ninit(fcx.name)));\n-                    }\n-                    case (_) { }\n-                }\n             }\n         }\n         case (none) {/* fallthrough */ }"}, {"sha": "aa7ee64b395c53f43654fa2c2a904afeab0386b8", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -17,6 +17,7 @@ export tritv_intersect;\n export tritv_copy;\n export tritv_clear;\n export tritv_doesntcare;\n+export to_str;\n \n /* for a fixed index: \n    10 = \"this constraint may or may not be true after execution\"\n@@ -81,21 +82,22 @@ fn trit_or(trit a, trit b) -> trit {\n   }\n }\n \n-// FIXME: not sure about this\n fn trit_and(trit a, trit b) -> trit {\n   alt (a) {\n     case (dont_care) { dont_care }\n     case (ttrue)     {\n       alt (b) {\n         case (dont_care) { dont_care }\n         case (ttrue)     { ttrue }\n-        case (tfalse)    { tfalse } // FIXME: ???\n+        case (tfalse)    { dont_care } // ???\n       }\n     }\n     case (tfalse) { tfalse }\n   }\n }\n \n+fn change(bool changed, trit old, trit new) -> bool { changed || new != old }\n+\n fn tritv_difference(&t p1, &t p2) -> bool {\n     let uint i = 0u;\n     assert (p1.nbits == p2.nbits);\n@@ -104,7 +106,7 @@ fn tritv_difference(&t p1, &t p2) -> bool {\n     while (i < sz) {\n       auto old = tritv_get(p1, i);\n       auto new = trit_minus(old, tritv_get(p2, i));\n-      changed = changed || (old != new);\n+      changed = change(changed, old, new);\n       tritv_set(i, p1, new);\n       i += 1u;\n     }\n@@ -119,7 +121,7 @@ fn tritv_union(&t p1, &t p2) -> bool {\n     while (i < sz) {\n       auto old = tritv_get(p1, i);\n       auto new = trit_or(old, tritv_get(p2, i));\n-      changed = changed || (old != new);\n+      changed = change(changed, old, new);\n       tritv_set(i, p1, new);\n       i += 1u;\n     }\n@@ -134,7 +136,7 @@ fn tritv_intersect(&t p1, &t p2) -> bool {\n     while (i < sz) {\n       auto old = tritv_get(p1, i);\n       auto new = trit_and(old, tritv_get(p2, i));\n-      changed = changed || (old != new);\n+      changed = change(changed, old, new);\n       tritv_set(i, p1, new);\n       i += 1u;\n     }\n@@ -166,24 +168,26 @@ fn tritv_set(uint i, &t v, trit t) -> bool {\n       bitv::set(v.val, i, false);\n     }\n   }\n-  ret (old != t);\n+  ret change(false, old, t);\n }\n \n fn tritv_copy(&t target, &t source) -> bool {\n   let uint i = 0u;\n   assert (target.nbits == source.nbits);\n   auto changed = false;\n-  auto old;\n-  auto new;\n+  auto oldunc;\n+  auto newunc;\n+  auto oldval;\n+  auto newval;\n   while (i < target.nbits) {\n-    old = bitv::get(target.uncertain, i);\n-    new = bitv::get(source.uncertain, i);\n-    bitv::set(target.uncertain, i, new);\n-    changed = changed || (old != new);\n-    old = bitv::get(target.val, i);\n-    new = bitv::get(source.val, i);\n-    bitv::set(target.val, i, new);\n-    changed = changed || (old != new);\n+    oldunc = bitv::get(target.uncertain, i);\n+    newunc = bitv::get(source.uncertain, i);\n+    oldval = bitv::get(target.val, i);\n+    newval = bitv::get(source.val, i);\n+    bitv::set(target.uncertain, i, newunc);\n+    changed = changed || (oldunc && !newunc);\n+    bitv::set(target.val, i, newval);\n+    changed = changed || (oldval && !newval);\n     i += 1u;\n   }\n   ret changed;\n@@ -234,6 +238,20 @@ fn to_vec(&t v) -> vec[uint] {\n   }\n   ret rslt;\n }\n+\n+fn to_str(&t v) -> str {\n+  let uint i = 0u;\n+  let str res = \"\";\n+  while (i < v.nbits) {\n+    res += alt (tritv_get(v, i)) {\n+        case (dont_care) { \"?\" }\n+        case (ttrue)     { \"1\" }\n+        case (tfalse)    { \"0\" } };\n+    i += 1u;\n+  }\n+  ret res;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "3be6c1ef9ad356eea5850e97e1166ad45c065442", "filename": "src/lib/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -116,7 +116,7 @@ fn buf_off[T](array[T] v, uint offset) -> vbuf {\n \n fn print_debug_info[T](array[T] v) { rustrt::vec_print_debug_info[T](v); }\n \n-\n+// FIXME: typestate precondition (list is non-empty)\n // Returns the last element of v.\n fn last[T](array[T] v) -> option::t[T] {\n     auto l = len[T](v);"}, {"sha": "784164a589e4bc249e3e3daa1847dbd4e56afeb9", "filename": "src/test/compile-fail/pred-assign.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -0,0 +1,20 @@\n+// xfail-stage0\n+// -*- rust -*-\n+\n+// error-pattern: Unsatisfied precondition constraint (for example, lt(a, b)\n+\n+fn f(int a, int b) : lt(a,b) {\n+}\n+\n+pred lt(int a, int b) -> bool {\n+  ret a < b;\n+}\n+\n+fn main() {\n+  let int a = 10;\n+  let int b = 23;\n+  let int c = 77;\n+  check lt(a,b);\n+  a = 24;\n+  f(a,b);\n+}"}, {"sha": "9d21ba759331ca33bfe150e982e3f5fdbd3ab2f8", "filename": "src/test/compile-fail/pred-swap.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/582e1f13f068dd85411405672e29ead829238fbc/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/582e1f13f068dd85411405672e29ead829238fbc/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs?ref=582e1f13f068dd85411405672e29ead829238fbc", "patch": "@@ -0,0 +1,20 @@\n+// xfail-stage0\n+// -*- rust -*-\n+\n+// error-pattern: Unsatisfied precondition constraint (for example, lt(a, b)\n+\n+fn f(int a, int b) : lt(a,b) {\n+}\n+\n+pred lt(int a, int b) -> bool {\n+  ret a < b;\n+}\n+\n+fn main() {\n+  let int a = 10;\n+  let int b = 23;\n+  let int c = 77;\n+  check lt(a,b);\n+  b <-> a;\n+  f(a,b);\n+}"}]}