{"sha": "15ff8a5a9fd8d0af2793eaef091700139bba513d", "node_id": "C_kwDOAAsO6NoAKDE1ZmY4YTVhOWZkOGQwYWYyNzkzZWFlZjA5MTcwMDEzOWJiYTUxM2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-12T14:37:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-12T14:37:45Z"}, "message": "Auto merge of #13715 - feniljain:fix_completions, r=jonas-schievink\n\nfix: breaking snippets on typed incomplete suggestions\n\nPossible fix for #7929\n\nFix the case where if a user types `&&42.o`, snippet completion was still applying &&Ok(42). Note this was fixed previously on `&&42.` but this still remained a problem for this case\n\nPrevious relevant PR: #13517\n\n### Points to help in review:\n\n- The main problem why everything broke on adding an extra `o` was, earlier `dot_receiver` was `42.` which was a `LITERAL` but now `42.o` becomes a `FIELD_EXPR`\n\n- Till now `include_references` was just checking for parent of `LITERAL` and if it was a `REF_EXPR`, but now we consider `FIELD_EXPR` and traverse all of them, finally to reach `REF_EXPR`. If `REF_EXPR` is not found we  just return the original `initial_element`\n\n- We are constructing a new node during `include_references` because if we rely on `dot_receiver` solely we would get `&&42.o` to be replaced with, but we want `&&42` to be replaced with\n\n### Output Video:\n\nhttps://user-images.githubusercontent.com/49019259/205420166-efbdef78-5b3a-4aef-ab4b-d892dac056a0.mov\n\nHope everything I wrote makes sense \ud83d\ude05\n\nAlso interestingly previous PR's number was `13517` and this PR's number is `13715`, nicee", "tree": {"sha": "bbe1bad6301c88fcbffc8edb7d806d0aa7080100", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbe1bad6301c88fcbffc8edb7d806d0aa7080100"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ff8a5a9fd8d0af2793eaef091700139bba513d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ff8a5a9fd8d0af2793eaef091700139bba513d", "html_url": "https://github.com/rust-lang/rust/commit/15ff8a5a9fd8d0af2793eaef091700139bba513d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ff8a5a9fd8d0af2793eaef091700139bba513d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7dff7491a675588a42089fe86009ddf93305e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7dff7491a675588a42089fe86009ddf93305e10", "html_url": "https://github.com/rust-lang/rust/commit/e7dff7491a675588a42089fe86009ddf93305e10"}, {"sha": "ec268c0d6c240123ca2cb7f5179b483c40dd888d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec268c0d6c240123ca2cb7f5179b483c40dd888d", "html_url": "https://github.com/rust-lang/rust/commit/ec268c0d6c240123ca2cb7f5179b483c40dd888d"}], "stats": {"total": 99, "additions": 77, "deletions": 22}, "files": [{"sha": "3669f462a99ed388b93dd246b84dc6a6fb8dfe13", "filename": "crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/15ff8a5a9fd8d0af2793eaef091700139bba513d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ff8a5a9fd8d0af2793eaef091700139bba513d/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=15ff8a5a9fd8d0af2793eaef091700139bba513d", "patch": "@@ -5,7 +5,7 @@ mod format_like;\n use hir::{Documentation, HasAttrs};\n use ide_db::{imports::insert_use::ImportScope, ty_filter::TryEnum, SnippetCap};\n use syntax::{\n-    ast::{self, AstNode, AstToken},\n+    ast::{self, make, AstNode, AstToken},\n     SyntaxKind::{EXPR_STMT, STMT_LIST},\n     TextRange, TextSize,\n };\n@@ -129,8 +129,10 @@ pub(crate) fn complete_postfix(\n \n     // The rest of the postfix completions create an expression that moves an argument,\n     // so it's better to consider references now to avoid breaking the compilation\n-    let dot_receiver = include_references(dot_receiver);\n-    let receiver_text = get_receiver_text(&dot_receiver, receiver_is_ambiguous_float_literal);\n+\n+    let (dot_receiver, node_to_replace_with) = include_references(dot_receiver);\n+    let receiver_text =\n+        get_receiver_text(&node_to_replace_with, receiver_is_ambiguous_float_literal);\n     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, &dot_receiver) {\n         Some(it) => it,\n         None => return,\n@@ -210,23 +212,43 @@ fn get_receiver_text(receiver: &ast::Expr, receiver_is_ambiguous_float_literal:\n     text.replace('\\\\', \"\\\\\\\\\").replace('$', \"\\\\$\")\n }\n \n-fn include_references(initial_element: &ast::Expr) -> ast::Expr {\n+fn include_references(initial_element: &ast::Expr) -> (ast::Expr, ast::Expr) {\n     let mut resulting_element = initial_element.clone();\n-    while let Some(parent_ref_element) =\n-        resulting_element.syntax().parent().and_then(ast::RefExpr::cast)\n+\n+    while let Some(field_expr) = resulting_element.syntax().parent().and_then(ast::FieldExpr::cast)\n     {\n-        resulting_element = ast::Expr::from(parent_ref_element);\n+        resulting_element = ast::Expr::from(field_expr);\n     }\n-    resulting_element\n+\n+    let mut new_element_opt = initial_element.clone();\n+\n+    if let Some(first_ref_expr) = resulting_element.syntax().parent().and_then(ast::RefExpr::cast) {\n+        if let Some(expr) = first_ref_expr.expr() {\n+            resulting_element = expr.clone();\n+        }\n+\n+        while let Some(parent_ref_element) =\n+            resulting_element.syntax().parent().and_then(ast::RefExpr::cast)\n+        {\n+            resulting_element = ast::Expr::from(parent_ref_element);\n+\n+            new_element_opt = make::expr_ref(new_element_opt, false);\n+        }\n+    } else {\n+        // If we do not find any ref expressions, restore\n+        // all the progress of tree climbing\n+        resulting_element = initial_element.clone();\n+    }\n+\n+    (resulting_element, new_element_opt)\n }\n \n fn build_postfix_snippet_builder<'ctx>(\n     ctx: &'ctx CompletionContext<'_>,\n     cap: SnippetCap,\n     receiver: &'ctx ast::Expr,\n ) -> Option<impl Fn(&str, &str, &str) -> Builder + 'ctx> {\n-    let receiver_syntax = receiver.syntax();\n-    let receiver_range = ctx.sema.original_range_opt(receiver_syntax)?.range;\n+    let receiver_range = ctx.sema.original_range_opt(receiver.syntax())?.range;\n     if ctx.source_range().end() < receiver_range.start() {\n         // This shouldn't happen, yet it does. I assume this might be due to an incorrect token mapping.\n         return None;\n@@ -616,22 +638,55 @@ fn main() {\n \n     #[test]\n     fn postfix_custom_snippets_completion_for_references() {\n+        // https://github.com/rust-lang/rust-analyzer/issues/7929\n+\n+        let snippet = Snippet::new(\n+            &[],\n+            &[\"ok\".into()],\n+            &[\"Ok(${receiver})\".into()],\n+            \"\",\n+            &[],\n+            crate::SnippetScope::Expr,\n+        )\n+        .unwrap();\n+\n         check_edit_with_config(\n-            CompletionConfig {\n-                snippets: vec![Snippet::new(\n-                    &[],\n-                    &[\"ok\".into()],\n-                    &[\"Ok(${receiver})\".into()],\n-                    \"\",\n-                    &[],\n-                    crate::SnippetScope::Expr,\n-                )\n-                .unwrap()],\n-                ..TEST_CONFIG\n-            },\n+            CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },\n+            \"ok\",\n+            r#\"fn main() { &&42.o$0 }\"#,\n+            r#\"fn main() { Ok(&&42) }\"#,\n+        );\n+\n+        check_edit_with_config(\n+            CompletionConfig { snippets: vec![snippet.clone()], ..TEST_CONFIG },\n             \"ok\",\n             r#\"fn main() { &&42.$0 }\"#,\n             r#\"fn main() { Ok(&&42) }\"#,\n         );\n+\n+        check_edit_with_config(\n+            CompletionConfig { snippets: vec![snippet], ..TEST_CONFIG },\n+            \"ok\",\n+            r#\"\n+struct A {\n+    a: i32,\n+}\n+\n+fn main() {\n+    let a = A {a :1};\n+    &a.a.$0\n+}\n+            \"#,\n+            r#\"\n+struct A {\n+    a: i32,\n+}\n+\n+fn main() {\n+    let a = A {a :1};\n+    Ok(&a.a)\n+}\n+            \"#,\n+        );\n     }\n }"}]}