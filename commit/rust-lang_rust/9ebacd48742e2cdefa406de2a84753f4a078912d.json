{"sha": "9ebacd48742e2cdefa406de2a84753f4a078912d", "node_id": "C_kwDOAAsO6NoAKDllYmFjZDQ4NzQyZTJjZGVmYTQwNmRlMmE4NDc1M2Y0YTA3ODkxMmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-12T15:48:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-12T15:48:55Z"}, "message": "Auto merge of #8703 - aldhsu:add_repeated_where_clause_or_trait_bound, r=flip1995\n\nAdd `repeated_where_clause_or_trait_bound` lint\n\nI thought I would try and scratch my own itch for #8674.\n\n1. Is comparing the `Res` the correct way for ensuring we have the same trait?\n2. Is there a way to get the spans for the bounds and clauses for suggestions?\nI tried to use `GenericParam::bounds_span_for_suggestions` but it only gave me an empty span at the end of the spans.\nI tried `WhereClause::span_for_predicates_or_empty_place` and it included the comma.\n3. Is there a simpler way to get the trait names? I have used the spans of the traits because I didn't see a way to get it off the `Res` or `Def`.\n\nchangelog: Add ``[`repeated_where_clause_or_trait_bound`]`` lint.", "tree": {"sha": "557b7ac1c3d2404eeb993726bd206ab962b87869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/557b7ac1c3d2404eeb993726bd206ab962b87869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ebacd48742e2cdefa406de2a84753f4a078912d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ebacd48742e2cdefa406de2a84753f4a078912d", "html_url": "https://github.com/rust-lang/rust/commit/9ebacd48742e2cdefa406de2a84753f4a078912d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ebacd48742e2cdefa406de2a84753f4a078912d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eabad8ea53235103e86688b2e39f63067a17ea87", "url": "https://api.github.com/repos/rust-lang/rust/commits/eabad8ea53235103e86688b2e39f63067a17ea87", "html_url": "https://github.com/rust-lang/rust/commit/eabad8ea53235103e86688b2e39f63067a17ea87"}, {"sha": "8878d674b1d030cbf87605fce2ebbd05cc8f3670", "url": "https://api.github.com/repos/rust-lang/rust/commits/8878d674b1d030cbf87605fce2ebbd05cc8f3670", "html_url": "https://github.com/rust-lang/rust/commit/8878d674b1d030cbf87605fce2ebbd05cc8f3670"}], "stats": {"total": 355, "additions": 340, "deletions": 15}, "files": [{"sha": "0a42a31fb8cf9e0a96dac08ede5a215e3e736880", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 123, "deletions": 6, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9ebacd48742e2cdefa406de2a84753f4a078912d/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ebacd48742e2cdefa406de2a84753f4a078912d/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=9ebacd48742e2cdefa406de2a84753f4a078912d", "patch": "@@ -1,5 +1,5 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::source::{snippet, snippet_opt, snippet_with_applicability};\n use clippy_utils::{SpanlessEq, SpanlessHash};\n use core::hash::{Hash, Hasher};\n use if_chain::if_chain;\n@@ -9,8 +9,8 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{\n-    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, PredicateOrigin, QPath, TraitBoundModifier,\n-    TraitItem, Ty, TyKind, WherePredicate,\n+    GenericArg, GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, PredicateOrigin, QPath,\n+    TraitBoundModifier, TraitItem, TraitRef, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -36,7 +36,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.38.0\"]\n     pub TYPE_REPETITION_IN_BOUNDS,\n     nursery,\n-    \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n+    \"types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n declare_clippy_lint! {\n@@ -63,10 +63,26 @@ declare_clippy_lint! {\n     ///\n     /// fn func<T>(arg: T) where T: Clone + Default {}\n     /// ```\n+    ///\n+    /// ```rust\n+    /// fn foo<T: Default + Default>(bar: T) {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo<T: Default>(bar: T) {}\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// fn foo<T>(bar: T) where T: Default + Default {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn foo<T>(bar: T) where T: Default {}\n+    /// ```\n     #[clippy::version = \"1.47.0\"]\n     pub TRAIT_DUPLICATION_IN_BOUNDS,\n     nursery,\n-    \"Check if the same trait bounds are specified twice during a function declaration\"\n+    \"check if the same trait bounds are specified more than once during a generic declaration\"\n }\n \n #[derive(Copy, Clone)]\n@@ -87,6 +103,19 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     fn check_generics(&mut self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n         self.check_type_repetition(cx, gen);\n         check_trait_bound_duplication(cx, gen);\n+        check_bounds_or_where_duplication(cx, gen);\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        // special handling for self trait bounds as these are not considered generics\n+        // ie. trait Foo: Display {}\n+        if let Item {\n+            kind: ItemKind::Trait(_, _, _, bounds, ..),\n+            ..\n+        } = item\n+        {\n+            rollup_traits(cx, bounds, \"these bounds contain repeated elements\");\n+        }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n@@ -241,6 +270,26 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n     }\n }\n \n+#[derive(PartialEq, Eq, Hash, Debug)]\n+struct ComparableTraitRef(Res, Vec<Res>);\n+\n+fn check_bounds_or_where_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n+    if gen.span.from_expansion() {\n+        return;\n+    }\n+\n+    for predicate in gen.predicates {\n+        if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate {\n+            let msg = if predicate.in_where_clause() {\n+                \"these where clauses contain repeated elements\"\n+            } else {\n+                \"these bounds contain repeated elements\"\n+            };\n+            rollup_traits(cx, bound_predicate.bounds, msg);\n+        }\n+    }\n+}\n+\n fn get_trait_info_from_bound<'a>(bound: &'a GenericBound<'_>) -> Option<(Res, &'a [PathSegment<'a>], Span)> {\n     if let GenericBound::Trait(t, tbm) = bound {\n         let trait_path = t.trait_ref.path;\n@@ -257,3 +306,71 @@ fn get_trait_info_from_bound<'a>(bound: &'a GenericBound<'_>) -> Option<(Res, &'\n         None\n     }\n }\n+\n+// FIXME: ComparableTraitRef does not support nested bounds needed for associated_type_bounds\n+fn into_comparable_trait_ref(trait_ref: &TraitRef<'_>) -> ComparableTraitRef {\n+    ComparableTraitRef(\n+        trait_ref.path.res,\n+        trait_ref\n+            .path\n+            .segments\n+            .iter()\n+            .filter_map(|segment| {\n+                // get trait bound type arguments\n+                Some(segment.args?.args.iter().filter_map(|arg| {\n+                    if_chain! {\n+                        if let GenericArg::Type(ty) = arg;\n+                        if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n+                        then { return Some(path.res) }\n+                    }\n+                    None\n+                }))\n+            })\n+            .flatten()\n+            .collect(),\n+    )\n+}\n+\n+fn rollup_traits(cx: &LateContext<'_>, bounds: &[GenericBound<'_>], msg: &str) {\n+    let mut map = FxHashMap::default();\n+    let mut repeated_res = false;\n+\n+    let only_comparable_trait_refs = |bound: &GenericBound<'_>| {\n+        if let GenericBound::Trait(t, _) = bound {\n+            Some((into_comparable_trait_ref(&t.trait_ref), t.span))\n+        } else {\n+            None\n+        }\n+    };\n+\n+    for bound in bounds.iter().filter_map(only_comparable_trait_refs) {\n+        let (comparable_bound, span_direct) = bound;\n+        if map.insert(comparable_bound, span_direct).is_some() {\n+            repeated_res = true;\n+        }\n+    }\n+\n+    if_chain! {\n+        if repeated_res;\n+        if let [first_trait, .., last_trait] = bounds;\n+        then {\n+            let all_trait_span = first_trait.span().to(last_trait.span());\n+\n+            let mut traits = map.values()\n+                .filter_map(|span| snippet_opt(cx, *span))\n+                .collect::<Vec<_>>();\n+            traits.sort_unstable();\n+            let traits = traits.join(\" + \");\n+\n+            span_lint_and_sugg(\n+                cx,\n+                TRAIT_DUPLICATION_IN_BOUNDS,\n+                all_trait_span,\n+                msg,\n+                \"try\",\n+                traits,\n+                Applicability::MachineApplicable\n+            );\n+        }\n+    }\n+}"}, {"sha": "52cf751c8d0b5268885d2fac8d3f8eaad359cf1b", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ebacd48742e2cdefa406de2a84753f4a078912d/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ebacd48742e2cdefa406de2a84753f4a078912d/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=9ebacd48742e2cdefa406de2a84753f4a078912d", "patch": "@@ -397,6 +397,7 @@ const RUSTFIX_COVERAGE_KNOWN_EXCEPTIONS: &[&str] = &[\n     \"single_component_path_imports_nested_first.rs\",\n     \"string_add.rs\",\n     \"toplevel_ref_arg_non_rustfix.rs\",\n+    \"trait_duplication_in_bounds.rs\",\n     \"unit_arg.rs\",\n     \"unnecessary_clone.rs\",\n     \"unnecessary_lazy_eval_unfixable.rs\","}, {"sha": "a5751c58aab8f09f1b7c032f281d4281e001e2d5", "filename": "tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9ebacd48742e2cdefa406de2a84753f4a078912d/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ebacd48742e2cdefa406de2a84753f4a078912d/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=9ebacd48742e2cdefa406de2a84753f4a078912d", "patch": "@@ -1,4 +1,5 @@\n #![deny(clippy::trait_duplication_in_bounds)]\n+#![allow(unused)]\n \n use std::collections::BTreeMap;\n use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n@@ -98,4 +99,114 @@ trait FooIter: Iterator<Item = Foo> {\n // This should not lint\n fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n \n+mod repeated_where_clauses_or_trait_bounds {\n+    fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+        unimplemented!();\n+    }\n+\n+    fn bad_bar<T, U>(arg0: T, arg1: U)\n+    where\n+        T: Clone + Clone + Clone + Copy,\n+        U: Clone + Copy,\n+    {\n+        unimplemented!();\n+    }\n+\n+    fn good_bar<T: Clone + Copy, U: Clone + Copy>(arg0: T, arg1: U) {\n+        unimplemented!();\n+    }\n+\n+    fn good_foo<T, U>(arg0: T, arg1: U)\n+    where\n+        T: Clone + Copy,\n+        U: Clone + Copy,\n+    {\n+        unimplemented!();\n+    }\n+\n+    trait GoodSelfTraitBound: Clone + Copy {\n+        fn f();\n+    }\n+\n+    trait GoodSelfWhereClause {\n+        fn f()\n+        where\n+            Self: Clone + Copy;\n+    }\n+\n+    trait BadSelfTraitBound: Clone + Clone + Clone {\n+        fn f();\n+    }\n+\n+    trait BadSelfWhereClause {\n+        fn f()\n+        where\n+            Self: Clone + Clone + Clone;\n+    }\n+\n+    trait GoodTraitBound<T: Clone + Copy, U: Clone + Copy> {\n+        fn f();\n+    }\n+\n+    trait GoodWhereClause<T, U> {\n+        fn f()\n+        where\n+            T: Clone + Copy,\n+            U: Clone + Copy;\n+    }\n+\n+    trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+        fn f();\n+    }\n+\n+    trait BadWhereClause<T, U> {\n+        fn f()\n+        where\n+            T: Clone + Clone + Clone + Copy,\n+            U: Clone + Copy;\n+    }\n+\n+    struct GoodStructBound<T: Clone + Copy, U: Clone + Copy> {\n+        t: T,\n+        u: U,\n+    }\n+\n+    impl<T: Clone + Copy, U: Clone + Copy> GoodTraitBound<T, U> for GoodStructBound<T, U> {\n+        // this should not warn\n+        fn f() {}\n+    }\n+\n+    struct GoodStructWhereClause;\n+\n+    impl<T, U> GoodTraitBound<T, U> for GoodStructWhereClause\n+    where\n+        T: Clone + Copy,\n+        U: Clone + Copy,\n+    {\n+        // this should not warn\n+        fn f() {}\n+    }\n+\n+    fn no_error_separate_arg_bounds(program: impl AsRef<()>, dir: impl AsRef<()>, args: &[impl AsRef<()>]) {}\n+\n+    trait GenericTrait<T> {}\n+\n+    // This should not warn but currently does see #8757\n+    fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+        unimplemented!();\n+    }\n+\n+    fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+        unimplemented!();\n+    }\n+\n+    mod foo {\n+        pub trait Clone {}\n+    }\n+\n+    fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+        unimplemented!();\n+    }\n+}\n+\n fn main() {}"}, {"sha": "7ef04e52708f4c91e16c67c6dddf6cc786779c9b", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 105, "deletions": 9, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9ebacd48742e2cdefa406de2a84753f4a078912d/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9ebacd48742e2cdefa406de2a84753f4a078912d/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=9ebacd48742e2cdefa406de2a84753f4a078912d", "patch": "@@ -1,5 +1,5 @@\n error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:6:15\n+  --> $DIR/trait_duplication_in_bounds.rs:7:15\n    |\n LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n    |               ^^^^^\n@@ -12,60 +12,156 @@ LL | #![deny(clippy::trait_duplication_in_bounds)]\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in the where clause\n-  --> $DIR/trait_duplication_in_bounds.rs:6:23\n+  --> $DIR/trait_duplication_in_bounds.rs:7:23\n    |\n LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n    |                       ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:35:15\n+  --> $DIR/trait_duplication_in_bounds.rs:36:15\n    |\n LL |         Self: Default;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:49:15\n+  --> $DIR/trait_duplication_in_bounds.rs:50:15\n    |\n LL |         Self: Default + Clone;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:55:15\n+  --> $DIR/trait_duplication_in_bounds.rs:56:15\n    |\n LL |         Self: Default + Clone;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:55:25\n+  --> $DIR/trait_duplication_in_bounds.rs:56:25\n    |\n LL |         Self: Default + Clone;\n    |                         ^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:58:15\n+  --> $DIR/trait_duplication_in_bounds.rs:59:15\n    |\n LL |         Self: Default;\n    |               ^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n error: this trait bound is already specified in trait declaration\n-  --> $DIR/trait_duplication_in_bounds.rs:93:15\n+  --> $DIR/trait_duplication_in_bounds.rs:94:15\n    |\n LL |         Self: Iterator<Item = Foo>,\n    |               ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider removing this trait bound\n \n-error: aborting due to 8 previous errors\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:103:19\n+   |\n+LL |     fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+   |                   ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:103:19\n+   |\n+LL |     fn bad_foo<T: Clone + Clone + Clone + Copy, U: Clone + Copy>(arg0: T, argo1: U) {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:109:12\n+   |\n+LL |         T: Clone + Clone + Clone + Copy,\n+   |            ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: these where clauses contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:109:12\n+   |\n+LL |         T: Clone + Clone + Clone + Copy,\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:137:30\n+   |\n+LL |     trait BadSelfTraitBound: Clone + Clone + Clone {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n+\n+error: these where clauses contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:144:19\n+   |\n+LL |             Self: Clone + Clone + Clone;\n+   |                   ^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone`\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:158:28\n+   |\n+LL |     trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+   |                            ^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:158:28\n+   |\n+LL |     trait BadTraitBound<T: Clone + Clone + Clone + Copy, U: Clone + Copy> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+\n+error: these where clauses contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:165:16\n+   |\n+LL |             T: Clone + Clone + Clone + Copy,\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + Copy`\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:195:24\n+   |\n+LL |     fn good_generic<T: GenericTrait<u64> + GenericTrait<u32>>(arg0: T) {\n+   |                        ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:199:23\n+   |\n+LL |     fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+   |                       ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:199:23\n+   |\n+LL |     fn bad_generic<T: GenericTrait<u64> + GenericTrait<u32> + GenericTrait<u64>>(arg0: T) {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `GenericTrait<u32> + GenericTrait<u64>`\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:207:26\n+   |\n+LL |     fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+   |                          ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: these bounds contain repeated elements\n+  --> $DIR/trait_duplication_in_bounds.rs:207:26\n+   |\n+LL |     fn qualified_path<T: std::clone::Clone + Clone + foo::Clone>(arg0: T) {\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Clone + foo::Clone`\n+\n+error: aborting due to 22 previous errors\n "}]}