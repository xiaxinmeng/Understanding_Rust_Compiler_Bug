{"sha": "ec71459c44045c867bad055d3c954d46fd587a03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNzE0NTljNDQwNDVjODY3YmFkMDU1ZDNjOTU0ZDQ2ZmQ1ODdhMDM=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-17T16:08:18Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-03-18T23:23:53Z"}, "message": "Format macro arguments with vertical layout", "tree": {"sha": "382aac59baeb1249a66f60ab7dc0df51864fb765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/382aac59baeb1249a66f60ab7dc0df51864fb765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec71459c44045c867bad055d3c954d46fd587a03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec71459c44045c867bad055d3c954d46fd587a03", "html_url": "https://github.com/rust-lang/rust/commit/ec71459c44045c867bad055d3c954d46fd587a03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec71459c44045c867bad055d3c954d46fd587a03/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84ea306d32f0b9950346108c51c10d2e763530ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/84ea306d32f0b9950346108c51c10d2e763530ae", "html_url": "https://github.com/rust-lang/rust/commit/84ea306d32f0b9950346108c51c10d2e763530ae"}], "stats": {"total": 443, "additions": 384, "deletions": 59}, "files": [{"sha": "d6420af764b04fb6b1c0ed755b6027ab46c31c17", "filename": "src/macros.rs", "status": "modified", "additions": 384, "deletions": 59, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/ec71459c44045c867bad055d3c954d46fd587a03/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec71459c44045c867bad055d3c954d46fd587a03/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=ec71459c44045c867bad055d3c954d46fd587a03", "patch": "@@ -463,73 +463,401 @@ fn replace_names(input: &str) -> Option<(String, HashMap<String, String>)> {\n     Some((result, substs))\n }\n \n-// This is a bit sketchy. The token rules probably need tweaking, but it works\n-// for some common cases. I hope the basic logic is sufficient. Note that the\n-// meaning of some tokens is a bit different here from usual Rust, e.g., `*`\n-// and `(`/`)` have special meaning.\n-//\n-// We always try and format on one line.\n-// FIXME: Use multi-line when every thing does not fit on one line.\n-fn format_macro_args(toks: ThinTokenStream, shape: Shape) -> Option<String> {\n-    let mut result = String::with_capacity(128);\n-    let mut insert_space = SpaceState::Never;\n+#[derive(Debug, Clone)]\n+enum MacroArgKind {\n+    MetaVariable(ast::Ident, String),\n+    Repeat(\n+        DelimToken,\n+        Vec<ParsedMacroArg>,\n+        Option<Box<ParsedMacroArg>>,\n+        Token,\n+    ),\n+    Delimited(DelimToken, Vec<ParsedMacroArg>),\n+    Separator(String, String),\n+    Other(String, String),\n+}\n \n-    for tok in (toks.into(): TokenStream).trees() {\n-        match tok {\n-            TokenTree::Token(_, t) => {\n-                if !result.is_empty() && force_space_before(&t) {\n-                    insert_space = SpaceState::Always;\n-                }\n-                if force_no_space_before(&t) {\n-                    insert_space = SpaceState::Never;\n-                }\n-                match (insert_space, ident_like(&t)) {\n-                    (SpaceState::Always, _)\n-                    | (SpaceState::Punctuation, false)\n-                    | (SpaceState::Ident, true) => {\n-                        result.push(' ');\n+fn delim_token_to_str(\n+    context: &RewriteContext,\n+    delim_token: &DelimToken,\n+    shape: Shape,\n+    use_multiple_lines: bool,\n+) -> (String, String) {\n+    let (lhs, rhs) = match *delim_token {\n+        DelimToken::Paren => (\"(\", \")\"),\n+        DelimToken::Bracket => (\"[\", \"]\"),\n+        DelimToken::Brace => (\"{\", \"}\"),\n+        DelimToken::NoDelim => (\"\", \"\"),\n+    };\n+    if use_multiple_lines {\n+        let indent_str = shape.indent.to_string_with_newline(context.config);\n+        let nested_indent_str = shape\n+            .indent\n+            .block_indent(context.config)\n+            .to_string_with_newline(context.config);\n+        (\n+            format!(\"{}{}\", lhs, nested_indent_str),\n+            format!(\"{}{}\", indent_str, rhs),\n+        )\n+    } else {\n+        (lhs.to_owned(), rhs.to_owned())\n+    }\n+}\n+\n+impl MacroArgKind {\n+    fn starts_with_dollar(&self) -> bool {\n+        match *self {\n+            MacroArgKind::Repeat(..) | MacroArgKind::MetaVariable(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn ends_with_space(&self) -> bool {\n+        match *self {\n+            MacroArgKind::Separator(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn has_prefix_space(&self) -> bool {\n+        match *self {\n+            MacroArgKind::Separator(_, ref prefix) | MacroArgKind::Other(_, ref prefix) => {\n+                prefix.starts_with(\" \")\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn rewrite(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        use_multiple_lines: bool,\n+    ) -> Option<String> {\n+        let rewrite_delimited_inner = |delim_tok, args| -> Option<(String, String, String)> {\n+            let (lhs, rhs) = delim_token_to_str(context, delim_tok, shape, false);\n+            let inner = wrap_macro_args(context, args, shape)?;\n+            if lhs.len() + inner.len() + rhs.len() <= shape.width {\n+                return Some((lhs, inner, rhs));\n+            }\n+\n+            let (lhs, rhs) = delim_token_to_str(context, delim_tok, shape, true);\n+            let nested_shape = shape\n+                .block_indent(context.config.tab_spaces())\n+                .with_max_width(context.config);\n+            let inner = wrap_macro_args(context, args, nested_shape)?;\n+            Some((lhs, inner, rhs))\n+        };\n+\n+        match *self {\n+            MacroArgKind::MetaVariable(ty, ref name) => {\n+                Some(format!(\"${}: {}\", name, ty.name.as_str()))\n+            }\n+            MacroArgKind::Repeat(ref delim_tok, ref args, ref another, ref tok) => {\n+                let (lhs, inner, rhs) = rewrite_delimited_inner(delim_tok, args)?;\n+                let another = another\n+                    .as_ref()\n+                    .and_then(|a| a.rewrite(context, shape, use_multiple_lines))\n+                    .unwrap_or(\"\".to_owned());\n+                let repeat_tok = pprust::token_to_string(tok);\n+\n+                Some(format!(\"${}{}{}{}{}\", lhs, inner, rhs, another, repeat_tok))\n+            }\n+            MacroArgKind::Delimited(ref delim_tok, ref args) => {\n+                rewrite_delimited_inner(delim_tok, args)\n+                    .map(|(lhs, inner, rhs)| format!(\"{}{}{}\", lhs, inner, rhs))\n+            }\n+            MacroArgKind::Separator(ref sep, ref prefix) => Some(format!(\"{}{} \", prefix, sep)),\n+            MacroArgKind::Other(ref inner, ref prefix) => Some(format!(\"{}{}\", prefix, inner)),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+struct ParsedMacroArg {\n+    kind: MacroArgKind,\n+    span: Span,\n+}\n+\n+impl ParsedMacroArg {\n+    pub fn rewrite(\n+        &self,\n+        context: &RewriteContext,\n+        shape: Shape,\n+        use_multiple_lines: bool,\n+    ) -> Option<String> {\n+        self.kind.rewrite(context, shape, use_multiple_lines)\n+    }\n+}\n+\n+struct MacroArgParser {\n+    lo: BytePos,\n+    hi: BytePos,\n+    buf: String,\n+    is_arg: bool,\n+    last_tok: Token,\n+    start_tok: Token,\n+    result: Vec<ParsedMacroArg>,\n+}\n+\n+fn last_tok(tt: &TokenTree) -> Token {\n+    match *tt {\n+        TokenTree::Token(_, ref t) => t.clone(),\n+        TokenTree::Delimited(_, ref d) => d.close_token(),\n+    }\n+}\n+\n+impl MacroArgParser {\n+    pub fn new() -> MacroArgParser {\n+        MacroArgParser {\n+            lo: BytePos(0),\n+            hi: BytePos(0),\n+            buf: String::new(),\n+            is_arg: false,\n+            last_tok: Token::Eof,\n+            start_tok: Token::Eof,\n+            result: vec![],\n+        }\n+    }\n+\n+    fn set_last_tok(&mut self, tok: &TokenTree) {\n+        self.hi = tok.span().hi();\n+        self.last_tok = last_tok(tok);\n+    }\n+\n+    fn add_separator(&mut self) {\n+        let prefix = if self.need_space_prefix() {\n+            \" \".to_owned()\n+        } else {\n+            \"\".to_owned()\n+        };\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Separator(self.buf.clone(), prefix),\n+            span: mk_sp(self.lo, self.hi),\n+        });\n+        self.buf.clear();\n+    }\n+\n+    fn add_other(&mut self) {\n+        let prefix = if self.need_space_prefix() {\n+            \" \".to_owned()\n+        } else {\n+            \"\".to_owned()\n+        };\n+        self.result.push(ParsedMacroArg {\n+            kind: MacroArgKind::Other(self.buf.clone(), prefix),\n+            span: mk_sp(self.lo, self.hi),\n+        });\n+        self.buf.clear();\n+    }\n+\n+    fn add_meta_variable(&mut self, iter: &mut Cursor) {\n+        match iter.next() {\n+            Some(TokenTree::Token(sp, Token::Ident(ref ident))) => {\n+                self.result.push(ParsedMacroArg {\n+                    kind: MacroArgKind::MetaVariable(ident.clone(), self.buf.clone()),\n+                    span: mk_sp(self.lo, sp.hi()),\n+                });\n+\n+                self.buf.clear();\n+                self.is_arg = false;\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn update_buffer(&mut self, lo: BytePos, t: &Token) {\n+        if self.buf.is_empty() {\n+            self.lo = lo;\n+            self.start_tok = t.clone();\n+        } else if force_space_before(t) {\n+            self.buf.push(' ');\n+        }\n+\n+        self.buf.push_str(&pprust::token_to_string(t));\n+    }\n+\n+    fn need_space_prefix(&self) -> bool {\n+        if self.result.is_empty() {\n+            return false;\n+        }\n+\n+        let last_arg = self.result.last().unwrap();\n+        if let MacroArgKind::MetaVariable(..) = last_arg.kind {\n+            if ident_like(&self.start_tok) {\n+                return true;\n+            }\n+        }\n+\n+        if force_space_before(&self.start_tok) {\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    /// Returns a collection of parsed macro def's arguments.\n+    pub fn parse(mut self, tokens: ThinTokenStream) -> Vec<ParsedMacroArg> {\n+        let mut iter = (tokens.into(): TokenStream).trees();\n+\n+        while let Some(ref tok) = iter.next() {\n+            match tok {\n+                TokenTree::Token(sp, Token::Dollar) => {\n+                    // We always want to add a separator before meta variables.\n+                    if !self.buf.is_empty() {\n+                        self.add_separator();\n                     }\n-                    _ => {}\n+\n+                    // Start keeping the name of this metavariable in the buffer.\n+                    self.is_arg = true;\n+                    self.lo = sp.lo();\n+                    self.start_tok = Token::Dollar;\n                 }\n-                result.push_str(&pprust::token_to_string(&t));\n-                insert_space = next_space(&t);\n-            }\n-            TokenTree::Delimited(_, d) => {\n-                if let SpaceState::Always = insert_space {\n-                    result.push(' ');\n+                TokenTree::Token(_, Token::Colon) if self.is_arg => {\n+                    self.add_meta_variable(&mut iter);\n                 }\n-                let formatted = format_macro_args(d.tts, shape)?;\n-                match d.delim {\n-                    DelimToken::Paren => {\n-                        result.push_str(&format!(\"({})\", formatted));\n-                        insert_space = SpaceState::Always;\n-                    }\n-                    DelimToken::Bracket => {\n-                        result.push_str(&format!(\"[{}]\", formatted));\n-                        insert_space = SpaceState::Always;\n-                    }\n-                    DelimToken::Brace => {\n-                        result.push_str(&format!(\" {{ {} }}\", formatted));\n-                        insert_space = SpaceState::Always;\n+                TokenTree::Token(sp, ref t) => self.update_buffer(sp.lo(), t),\n+                TokenTree::Delimited(sp, ref delimited) => {\n+                    if !self.buf.is_empty() {\n+                        if next_space(&self.last_tok) == SpaceState::Always {\n+                            self.add_separator();\n+                        } else {\n+                            self.add_other();\n+                        }\n                     }\n-                    DelimToken::NoDelim => {\n-                        result.push_str(&format!(\"{}\", formatted));\n-                        insert_space = SpaceState::Always;\n+\n+                    let mut parser = MacroArgParser::new();\n+                    parser.lo = sp.lo();\n+                    let mut delimited_arg = parser.parse(delimited.tts.clone());\n+\n+                    if self.is_arg {\n+                        // Parse '*' or '+'.\n+                        let mut buffer = String::new();\n+                        let mut first = false;\n+                        let mut lo = sp.lo();\n+\n+                        while let Some(ref next_tok) = iter.next() {\n+                            self.set_last_tok(next_tok);\n+                            if first {\n+                                first = false;\n+                                lo = next_tok.span().lo();\n+                            }\n+\n+                            match next_tok {\n+                                TokenTree::Token(_, Token::BinOp(BinOpToken::Plus))\n+                                | TokenTree::Token(_, Token::Question)\n+                                | TokenTree::Token(_, Token::BinOp(BinOpToken::Star)) => {\n+                                    break;\n+                                }\n+                                TokenTree::Token(_, ref t) => {\n+                                    buffer.push_str(&pprust::token_to_string(t))\n+                                }\n+                                _ => unreachable!(),\n+                            }\n+                        }\n+\n+                        let another = if buffer.trim().is_empty() {\n+                            None\n+                        } else {\n+                            Some(Box::new(ParsedMacroArg {\n+                                kind: MacroArgKind::Other(buffer, \"\".to_owned()),\n+                                span: mk_sp(lo, self.hi),\n+                            }))\n+                        };\n+\n+                        self.result.push(ParsedMacroArg {\n+                            kind: MacroArgKind::Repeat(\n+                                delimited.delim,\n+                                delimited_arg,\n+                                another,\n+                                self.last_tok.clone(),\n+                            ),\n+                            span: mk_sp(self.lo, self.hi),\n+                        });\n+                    } else {\n+                        self.result.push(ParsedMacroArg {\n+                            kind: MacroArgKind::Delimited(delimited.delim, delimited_arg),\n+                            span: *sp,\n+                        });\n                     }\n                 }\n             }\n+\n+            self.set_last_tok(tok);\n+        }\n+\n+        if !self.buf.is_empty() {\n+            self.add_other();\n+        }\n+\n+        self.result\n+    }\n+}\n+\n+fn wrap_macro_args(\n+    context: &RewriteContext,\n+    args: &[ParsedMacroArg],\n+    shape: Shape,\n+) -> Option<String> {\n+    wrap_macro_args_inner(context, args, shape, false)\n+        .or_else(|| wrap_macro_args_inner(context, args, shape, true))\n+}\n+\n+fn wrap_macro_args_inner(\n+    context: &RewriteContext,\n+    args: &[ParsedMacroArg],\n+    shape: Shape,\n+    use_multiple_lines: bool,\n+) -> Option<String> {\n+    let mut result = String::with_capacity(128);\n+    let mut iter = args.iter().peekable();\n+    let indent_str = shape.indent.to_string_with_newline(context.config);\n+\n+    while let Some(ref arg) = iter.next() {\n+        let nested_shape = if use_multiple_lines {\n+            shape.with_max_width(context.config)\n+        } else {\n+            shape\n+        };\n+        result.push_str(&arg.rewrite(context, nested_shape, use_multiple_lines)?);\n+\n+        if use_multiple_lines && arg.kind.ends_with_space() {\n+            result.pop();\n+            result.push_str(&indent_str);\n+        } else if let Some(ref next_arg) = iter.peek() {\n+            let space_before_dollar =\n+                !arg.kind.ends_with_space() && next_arg.kind.starts_with_dollar();\n+            if space_before_dollar {\n+                result.push(' ');\n+            }\n         }\n     }\n \n-    if result.len() <= shape.width {\n-        Some(result)\n-    } else {\n+    if !use_multiple_lines && result.len() >= shape.width {\n         None\n+    } else {\n+        Some(result)\n     }\n }\n \n+// This is a bit sketchy. The token rules probably need tweaking, but it works\n+// for some common cases. I hope the basic logic is sufficient. Note that the\n+// meaning of some tokens is a bit different here from usual Rust, e.g., `*`\n+// and `(`/`)` have special meaning.\n+//\n+// We always try and format on one line.\n+// FIXME: Use multi-line when every thing does not fit on one line.\n+fn format_macro_args(\n+    context: &RewriteContext,\n+    toks: ThinTokenStream,\n+    shape: Shape,\n+) -> Option<String> {\n+    let parsed_args = MacroArgParser::new().parse(toks);\n+    wrap_macro_args(context, &parsed_args, shape)\n+}\n+\n // We should insert a space if the next token is a:\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq)]\n enum SpaceState {\n     Never,\n     Punctuation,\n@@ -538,6 +866,8 @@ enum SpaceState {\n }\n \n fn force_space_before(tok: &Token) -> bool {\n+    debug!(\"tok: force_space_before {:?}\", tok);\n+\n     match *tok {\n         Token::Eq\n         | Token::Lt\n@@ -562,13 +892,6 @@ fn force_space_before(tok: &Token) -> bool {\n     }\n }\n \n-fn force_no_space_before(tok: &Token) -> bool {\n-    match *tok {\n-        Token::Semi | Token::Comma | Token::Dot => true,\n-        Token::BinOp(bot) => bot == BinOpToken::Star,\n-        _ => false,\n-    }\n-}\n fn ident_like(tok: &Token) -> bool {\n     match *tok {\n         Token::Ident(_) | Token::Literal(..) | Token::Lifetime(_) => true,\n@@ -577,6 +900,8 @@ fn ident_like(tok: &Token) -> bool {\n }\n \n fn next_space(tok: &Token) -> SpaceState {\n+    debug!(\"next_space: {:?}\", tok);\n+\n     match *tok {\n         Token::Not\n         | Token::Tilde\n@@ -804,7 +1129,7 @@ impl MacroBranch {\n         }\n \n         // 5 = \" => {\"\n-        let mut result = format_macro_args(self.args.clone(), shape.sub_width(5)?)?;\n+        let mut result = format_macro_args(context, self.args.clone(), shape.sub_width(5)?)?;\n \n         if multi_branch_style {\n             result += \" =>\";"}]}