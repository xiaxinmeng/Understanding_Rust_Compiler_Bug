{"sha": "484e07c231e29febc68f2f21e970f8eb19818ad6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NGUwN2MyMzFlMjlmZWJjNjhmMmYyMWU5NzBmOGViMTk4MThhZDY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-07T10:08:41Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:15:13Z"}, "message": "[eddyb/rebase cleanup] s/&self./self.", "tree": {"sha": "bc5962d8ee9199d97fa3413a07e32b06fcde0cc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc5962d8ee9199d97fa3413a07e32b06fcde0cc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/484e07c231e29febc68f2f21e970f8eb19818ad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/484e07c231e29febc68f2f21e970f8eb19818ad6", "html_url": "https://github.com/rust-lang/rust/commit/484e07c231e29febc68f2f21e970f8eb19818ad6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/484e07c231e29febc68f2f21e970f8eb19818ad6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a1c50955b35892643a4bcfce08e72d9297b5bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1c50955b35892643a4bcfce08e72d9297b5bca", "html_url": "https://github.com/rust-lang/rust/commit/0a1c50955b35892643a4bcfce08e72d9297b5bca"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "a7a00dd0707b009d489911e59b12c61f1d60af18", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=484e07c231e29febc68f2f21e970f8eb19818ad6", "patch": "@@ -761,7 +761,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n-        let fty = &self.cx().type_func(&argtys[..], output);\n+        let fty = self.cx().type_func(&argtys[..], output);\n         unsafe {\n             // Ask LLVM to verify that the constraints are well-formed.\n             let constraints_ok = llvm::LLVMRustInlineAsmVerify(fty, cons);\n@@ -896,9 +896,9 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = self.cx.val_ty(elt);\n-            let undef = llvm::LLVMGetUndef(&self.cx().type_vector(elt_ty, num_elts as u64));\n+            let undef = llvm::LLVMGetUndef(self.cx().type_vector(elt_ty, num_elts as u64));\n             let vec = self.insert_element(undef, elt, self.cx.const_i32(0));\n-            let vec_i32_ty = &self.cx().type_vector(&self.cx().type_i32(), num_elts as u64);\n+            let vec_i32_ty = self.cx().type_vector(self.cx().type_i32(), num_elts as u64);\n             self.shuffle_vector(vec, undef, self.cx().const_null(vec_i32_ty))\n         }\n     }\n@@ -1305,6 +1305,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn cx(&self) -> &'a CodegenCx<'ll, 'tcx> {\n-        &self.cx\n+        self.cx\n     }\n }"}, {"sha": "e20a93e4e3e6618ae03c8d63aca040da556056ae", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=484e07c231e29febc68f2f21e970f8eb19818ad6", "patch": "@@ -255,19 +255,19 @@ impl<'ll, 'tcx: 'll> ConstMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn const_bool(&self, val: bool) -> &'ll Value {\n-        &self.const_uint(&self.type_i1(), val as u64)\n+        self.const_uint(self.type_i1(), val as u64)\n     }\n \n     fn const_i32(&self, i: i32) -> &'ll Value {\n-        &self.const_int(&self.type_i32(), i as i64)\n+        self.const_int(self.type_i32(), i as i64)\n     }\n \n     fn const_u32(&self, i: u32) -> &'ll Value {\n-        &self.const_uint(&self.type_i32(), i as u64)\n+        self.const_uint(self.type_i32(), i as u64)\n     }\n \n     fn const_u64(&self, i: u64) -> &'ll Value {\n-        &self.const_uint(&self.type_i64(), i)\n+        self.const_uint(self.type_i64(), i)\n     }\n \n     fn const_usize(&self, i: u64) -> &'ll Value {\n@@ -277,11 +277,11 @@ impl<'ll, 'tcx: 'll> ConstMethods for CodegenCx<'ll, 'tcx> {\n             assert!(i < (1<<bit_size));\n         }\n \n-        &self.const_uint(&self.isize_ty, i)\n+        self.const_uint(self.isize_ty, i)\n     }\n \n     fn const_u8(&self, i: u8) -> &'ll Value {\n-        &self.const_uint(&self.type_i8(), i as u64)\n+        self.const_uint(self.type_i8(), i as u64)\n     }\n \n \n@@ -293,23 +293,23 @@ impl<'ll, 'tcx: 'll> ConstMethods for CodegenCx<'ll, 'tcx> {\n         null_terminated: bool,\n     ) -> &'ll Value {\n         unsafe {\n-            if let Some(&llval) = &self.const_cstr_cache.borrow().get(&s) {\n+            if let Some(&llval) = self.const_cstr_cache.borrow().get(&s) {\n                 return llval;\n             }\n \n-            let sc = llvm::LLVMConstStringInContext(&self.llcx,\n+            let sc = llvm::LLVMConstStringInContext(self.llcx,\n                                                     s.as_ptr() as *const c_char,\n                                                     s.len() as c_uint,\n                                                     !null_terminated as Bool);\n-            let sym = &self.generate_local_symbol_name(\"str\");\n-            let g = declare::define_global(&self, &sym[..], &self.val_ty(sc)).unwrap_or_else(||{\n+            let sym = self.generate_local_symbol_name(\"str\");\n+            let g = declare::define_global(&self, &sym[..], self.val_ty(sc)).unwrap_or_else(||{\n                 bug!(\"symbol `{}` is already defined\", sym);\n             });\n             llvm::LLVMSetInitializer(g, sc);\n             llvm::LLVMSetGlobalConstant(g, True);\n             llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n \n-            &self.const_cstr_cache.borrow_mut().insert(s, g);\n+            self.const_cstr_cache.borrow_mut().insert(s, g);\n             g\n         }\n     }\n@@ -318,9 +318,9 @@ impl<'ll, 'tcx: 'll> ConstMethods for CodegenCx<'ll, 'tcx> {\n     // you will be kicked off fast isel. See issue #4352 for an example of this.\n     fn const_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n         let len = s.len();\n-        let cs = consts::ptrcast(&self.const_cstr(s, false),\n-            &self.type_ptr_to(&self.layout_of(&self.tcx.mk_str()).llvm_type(&self)));\n-        &self.const_fat_ptr(cs, &self.const_usize(len as u64))\n+        let cs = consts::ptrcast(self.const_cstr(s, false),\n+            self.type_ptr_to(self.layout_of(self.tcx.mk_str()).llvm_type(&self)));\n+        self.const_fat_ptr(cs, self.const_usize(len as u64))\n     }\n \n     fn const_fat_ptr(\n@@ -330,15 +330,15 @@ impl<'ll, 'tcx: 'll> ConstMethods for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll Value {\n         assert_eq!(abi::FAT_PTR_ADDR, 0);\n         assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-        &self.const_struct(&[ptr, meta], false)\n+        self.const_struct(&[ptr, meta], false)\n     }\n \n     fn const_struct(\n         &self,\n         elts: &[&'ll Value],\n         packed: bool\n     ) -> &'ll Value {\n-        struct_in_context(&self.llcx, elts, packed)\n+        struct_in_context(self.llcx, elts, packed)\n     }\n \n     fn const_array(&self, ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n@@ -354,7 +354,7 @@ impl<'ll, 'tcx: 'll> ConstMethods for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn const_bytes(&self, bytes: &[u8]) -> &'ll Value {\n-        bytes_in_context(&self.llcx, bytes)\n+        bytes_in_context(self.llcx, bytes)\n     }\n \n     fn const_get_elt(&self, v: &'ll Value, idx: u64) -> &'ll Value {"}, {"sha": "9b330bc5f8e8a106e9bf628438b6bf8413951455", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=484e07c231e29febc68f2f21e970f8eb19818ad6", "patch": "@@ -137,16 +137,16 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll Value {\n         unsafe {\n             let gv = match kind {\n-                Some(kind) if !&self.tcx.sess.fewer_names() => {\n-                    let name = &self.generate_local_symbol_name(kind);\n+                Some(kind) if !self.tcx.sess.fewer_names() => {\n+                    let name = self.generate_local_symbol_name(kind);\n                     let gv = declare::define_global(&self, &name[..],\n-                        &self.val_ty(cv)).unwrap_or_else(||{\n+                        self.val_ty(cv)).unwrap_or_else(||{\n                             bug!(\"symbol `{}` is already defined\", name);\n                     });\n                     llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n                     gv\n                 },\n-                _ => declare::define_private_global(&self, &self.val_ty(cv)),\n+                _ => declare::define_private_global(&self, self.val_ty(cv)),\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n             set_global_alignment(&self, gv, align);\n@@ -161,7 +161,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         align: Align,\n         kind: Option<&str>,\n     ) -> &'ll Value {\n-        if let Some(&gv) = &self.const_globals.borrow().get(&cv) {\n+        if let Some(&gv) = self.const_globals.borrow().get(&cv) {\n             unsafe {\n                 // Upgrade the alignment in cases where the same constant is used with different\n                 // alignment requirements\n@@ -172,21 +172,21 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n             return gv;\n         }\n-        let gv = &self.static_addr_of_mut(cv, align, kind);\n+        let gv = self.static_addr_of_mut(cv, align, kind);\n         unsafe {\n             llvm::LLVMSetGlobalConstant(gv, True);\n         }\n-        &self.const_globals.borrow_mut().insert(cv, gv);\n+        self.const_globals.borrow_mut().insert(cv, gv);\n         gv\n     }\n \n     fn get_static(&self, def_id: DefId) -> &'ll Value {\n         let instance = Instance::mono(self.tcx, def_id);\n-        if let Some(&g) = &self.instances.borrow().get(&instance) {\n+        if let Some(&g) = self.instances.borrow().get(&instance) {\n             return g;\n         }\n \n-        let defined_in_current_codegen_unit = &self.codegen_unit\n+        let defined_in_current_codegen_unit = self.codegen_unit\n                                                 .items()\n                                                 .contains_key(&MonoItem::Static(def_id));\n         assert!(!defined_in_current_codegen_unit,\n@@ -201,8 +201,8 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         let g = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n \n-            let llty = &self.layout_of(ty).llvm_type(&self);\n-            let (g, attrs) = match &self.tcx.hir.get(id) {\n+            let llty = self.layout_of(ty).llvm_type(&self);\n+            let (g, attrs) = match self.tcx.hir.get(id) {\n                 Node::Item(&hir::Item {\n                     ref attrs, span, node: hir::ItemKind::Static(..), ..\n                 }) => {\n@@ -212,7 +212,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     let g = declare::define_global(&self, &sym[..], llty).unwrap();\n \n-                    if !&self.tcx.is_reachable_non_generic(def_id) {\n+                    if !self.tcx.is_reachable_non_generic(def_id) {\n                         unsafe {\n                             llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                         }\n@@ -224,7 +224,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 Node::ForeignItem(&hir::ForeignItem {\n                     ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n                 }) => {\n-                    let fn_attrs = &self.tcx.codegen_fn_attrs(def_id);\n+                    let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n                     (check_and_apply_linkage(&self, &fn_attrs, ty, sym, Some(span)), attrs)\n                 }\n \n@@ -242,9 +242,9 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             g\n         } else {\n             // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-            debug!(\"get_static: sym={} item_attr={:?}\", sym, &self.tcx.item_attrs(def_id));\n+            debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n \n-            let attrs = &self.tcx.codegen_fn_attrs(def_id);\n+            let attrs = self.tcx.codegen_fn_attrs(def_id);\n             let g = check_and_apply_linkage(&self, &attrs, ty, sym, None);\n \n             // Thread-local statics in some other crate need to *always* be linked\n@@ -258,11 +258,11 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n \n             let needs_dll_storage_attr =\n-                self.use_dll_storage_attrs && !&self.tcx.is_foreign_item(def_id) &&\n+                self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n                 // dynamic linking when cross-language LTO is enabled.\n-                !&self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n+                !self.tcx.sess.opts.debugging_opts.cross_lang_lto.enabled();\n \n             // If this assertion triggers, there's something wrong with commandline\n             // argument validation.\n@@ -281,7 +281,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 // crates, so there are cases where a static with an upstream DefId\n                 // is actually present in the current crate. We can find out via the\n                 // is_codegened_item query.\n-                if !&self.tcx.is_codegened_item(def_id) {\n+                if !self.tcx.is_codegened_item(def_id) {\n                     unsafe {\n                         llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);\n                     }\n@@ -297,7 +297,7 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        &self.instances.borrow_mut().insert(instance, g);\n+        self.instances.borrow_mut().insert(instance, g);\n         g\n     }\n \n@@ -307,15 +307,15 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         is_mutable: bool,\n     ) {\n         unsafe {\n-            let attrs = &self.tcx.codegen_fn_attrs(def_id);\n+            let attrs = self.tcx.codegen_fn_attrs(def_id);\n \n             let (v, alloc) = match ::mir::codegen_static_initializer(&self, def_id) {\n                 Ok(v) => v,\n                 // Error has already been reported\n                 Err(_) => return,\n             };\n \n-            let g = &self.get_static(def_id);\n+            let g = self.get_static(def_id);\n \n             // boolean SSA values are i1, but they have to be stored in i8 slots,\n             // otherwise some LLVM optimization passes don't work as expected\n@@ -344,15 +344,15 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 let visibility = llvm::LLVMRustGetVisibility(g);\n \n                 let new_g = llvm::LLVMRustGetOrInsertGlobal(\n-                    &self.llmod, name_string.as_ptr(), val_llty);\n+                    self.llmod, name_string.as_ptr(), val_llty);\n \n                 llvm::LLVMRustSetLinkage(new_g, linkage);\n                 llvm::LLVMRustSetVisibility(new_g, visibility);\n \n                 // To avoid breaking any invariants, we leave around the old\n                 // global for the moment; we'll replace all references to it\n                 // with the new global later. (See base::codegen_backend.)\n-                &self.statics_to_rauw.borrow_mut().push((g, new_g));\n+                self.statics_to_rauw.borrow_mut().push((g, new_g));\n                 new_g\n             };\n             set_global_alignment(&self, g, self.align_of(ty));\n@@ -416,19 +416,19 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             if self.tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n                 if let Some(section) = attrs.link_section {\n                     let section = llvm::LLVMMDStringInContext(\n-                        &self.llcx,\n+                        self.llcx,\n                         section.as_str().as_ptr() as *const _,\n                         section.as_str().len() as c_uint,\n                     );\n                     let alloc = llvm::LLVMMDStringInContext(\n-                        &self.llcx,\n+                        self.llcx,\n                         alloc.bytes.as_ptr() as *const _,\n                         alloc.bytes.len() as c_uint,\n                     );\n                     let data = [section, alloc];\n-                    let meta = llvm::LLVMMDNodeInContext(&self.llcx, data.as_ptr(), 2);\n+                    let meta = llvm::LLVMMDNodeInContext(self.llcx, data.as_ptr(), 2);\n                     llvm::LLVMAddNamedMetadataOperand(\n-                        &self.llmod,\n+                        self.llmod,\n                         \"wasm.custom_sections\\0\".as_ptr() as *const _,\n                         meta,\n                     );\n@@ -439,8 +439,8 @@ impl StaticMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n             if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n                 // This static will be stored in the llvm.used variable which is an array of i8*\n-                let cast = llvm::LLVMConstPointerCast(g, &self.type_i8p());\n-                &self.used_statics.borrow_mut().push(cast);\n+                let cast = llvm::LLVMConstPointerCast(g, self.type_i8p());\n+                self.used_statics.borrow_mut().push(cast);\n             }\n         }\n     }"}, {"sha": "cd0c2ffacd58678ec8b7fdc8efee1c17a2855487", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484e07c231e29febc68f2f21e970f8eb19818ad6/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=484e07c231e29febc68f2f21e970f8eb19818ad6", "patch": "@@ -339,52 +339,52 @@ impl IntrinsicDeclarationMethods for CodegenCx<'b, 'tcx> {\n         macro_rules! ifn {\n             ($name:expr, fn() -> $ret:expr) => (\n                 if key == $name {\n-                    let f = declare::declare_cfn(&self, $name, &self.type_func(&[], $ret));\n+                    let f = declare::declare_cfn(&self, $name, self.type_func(&[], $ret));\n                     llvm::SetUnnamedAddr(f, false);\n-                    &self.intrinsics.borrow_mut().insert($name, f.clone());\n+                    self.intrinsics.borrow_mut().insert($name, f.clone());\n                     return Some(f);\n                 }\n             );\n             ($name:expr, fn(...) -> $ret:expr) => (\n                 if key == $name {\n-                    let f = declare::declare_cfn(&self, $name, &self.type_variadic_func(&[], $ret));\n+                    let f = declare::declare_cfn(&self, $name, self.type_variadic_func(&[], $ret));\n                     llvm::SetUnnamedAddr(f, false);\n-                    &self.intrinsics.borrow_mut().insert($name, f.clone());\n+                    self.intrinsics.borrow_mut().insert($name, f.clone());\n                     return Some(f);\n                 }\n             );\n             ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n                 if key == $name {\n-                    let f = declare::declare_cfn(&self, $name, &self.type_func(&[$($arg),*], $ret));\n+                    let f = declare::declare_cfn(&self, $name, self.type_func(&[$($arg),*], $ret));\n                     llvm::SetUnnamedAddr(f, false);\n-                    &self.intrinsics.borrow_mut().insert($name, f.clone());\n+                    self.intrinsics.borrow_mut().insert($name, f.clone());\n                     return Some(f);\n                 }\n             );\n         }\n         macro_rules! mk_struct {\n-            ($($field_ty:expr),*) => (&self.type_struct( &[$($field_ty),*], false))\n+            ($($field_ty:expr),*) => (self.type_struct( &[$($field_ty),*], false))\n         }\n \n-        let i8p = &self.type_i8p();\n-        let void = &self.type_void();\n-        let i1 = &self.type_i1();\n-        let t_i8 = &self.type_i8();\n-        let t_i16 = &self.type_i16();\n-        let t_i32 = &self.type_i32();\n-        let t_i64 = &self.type_i64();\n-        let t_i128 = &self.type_i128();\n-        let t_f32 = &self.type_f32();\n-        let t_f64 = &self.type_f64();\n-\n-        let t_v2f32 = &self.type_vector(t_f32, 2);\n-        let t_v4f32 = &self.type_vector(t_f32, 4);\n-        let t_v8f32 = &self.type_vector(t_f32, 8);\n-        let t_v16f32 = &self.type_vector(t_f32, 16);\n-\n-        let t_v2f64 = &self.type_vector(t_f64, 2);\n-        let t_v4f64 = &self.type_vector(t_f64, 4);\n-        let t_v8f64 = &self.type_vector(t_f64, 8);\n+        let i8p = self.type_i8p();\n+        let void = self.type_void();\n+        let i1 = self.type_i1();\n+        let t_i8 = self.type_i8();\n+        let t_i16 = self.type_i16();\n+        let t_i32 = self.type_i32();\n+        let t_i64 = self.type_i64();\n+        let t_i128 = self.type_i128();\n+        let t_f32 = self.type_f32();\n+        let t_f64 = self.type_f64();\n+\n+        let t_v2f32 = self.type_vector(t_f32, 2);\n+        let t_v4f32 = self.type_vector(t_f32, 4);\n+        let t_v8f32 = self.type_vector(t_f32, 8);\n+        let t_v16f32 = self.type_vector(t_f32, 16);\n+\n+        let t_v2f64 = self.type_vector(t_f64, 2);\n+        let t_v4f64 = self.type_vector(t_f64, 4);\n+        let t_v8f64 = self.type_vector(t_f64, 8);\n \n         ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n         ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n@@ -637,8 +637,8 @@ impl IntrinsicDeclarationMethods for CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.prefetch\", fn(i8p, t_i32, t_i32, t_i32) -> void);\n \n         if self.sess().opts.debuginfo != DebugInfo::None {\n-            ifn!(\"llvm.dbg.declare\", fn(&self.type_metadata(), &self.type_metadata()) -> void);\n-            ifn!(\"llvm.dbg.value\", fn(&self.type_metadata(), t_i64, &self.type_metadata()) -> void);\n+            ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n+            ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);\n         }\n         return None;\n     }\n@@ -694,7 +694,7 @@ impl<'b, 'tcx> CodegenCx<'b, 'tcx> {\n                 } else {\n                     \"rust_eh_personality\"\n                 };\n-                let fty = &self.type_variadic_func(&[], &self.type_i32());\n+                let fty = self.type_variadic_func(&[], self.type_i32());\n                 declare::declare_cfn(self, name, fty)\n             }\n         };"}]}