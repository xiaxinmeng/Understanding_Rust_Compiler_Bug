{"sha": "34e05812e029206add91fa39df86765fcb3f8b5a", "node_id": "C_kwDOAAsO6NoAKDM0ZTA1ODEyZTAyOTIwNmFkZDkxZmEzOWRmODY3NjVmY2IzZjhiNWE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-27T03:22:28Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-05-28T18:38:22Z"}, "message": "Fix TyKind lint, make consts no longer fn, etc", "tree": {"sha": "fc2d0bfaf18186b591d68aa830c54026df9316b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc2d0bfaf18186b591d68aa830c54026df9316b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34e05812e029206add91fa39df86765fcb3f8b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34e05812e029206add91fa39df86765fcb3f8b5a", "html_url": "https://github.com/rust-lang/rust/commit/34e05812e029206add91fa39df86765fcb3f8b5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34e05812e029206add91fa39df86765fcb3f8b5a/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a056a953f00d7b78d12dc192b34c47cca6fa7b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a056a953f00d7b78d12dc192b34c47cca6fa7b6b", "html_url": "https://github.com/rust-lang/rust/commit/a056a953f00d7b78d12dc192b34c47cca6fa7b6b"}], "stats": {"total": 1384, "additions": 857, "deletions": 527}, "files": [{"sha": "bf38ca19484c939e11ff050abd74c691a3a4da76", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -98,8 +98,10 @@ struct Upvar<'tcx> {\n     by_ref: bool,\n }\n \n-const fn deref_projection<'tcx>() -> &'tcx [PlaceElem<'tcx>; 1] {\n-    &[ProjectionElem::Deref]\n+/// Associate some local constants with the `'tcx` lifetime\n+struct TyCtxtConsts<'tcx>(TyCtxt<'tcx>);\n+impl<'tcx> TyCtxtConsts<'tcx> {\n+    const DEREF_PROJECTION: &'tcx [PlaceElem<'tcx>; 1] = &[ProjectionElem::Deref];\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -1445,7 +1447,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Thread-locals might be dropped after the function exits\n                 // We have to dereference the outer reference because\n                 // borrows don't conflict behind shared references.\n-                root_place.projection = deref_projection();\n+                root_place.projection = TyCtxtConsts::DEREF_PROJECTION;\n                 (true, true)\n             } else {\n                 (false, self.locals_are_invalidated_at_exit)"}, {"sha": "dd3adbf70a62fc5ed2f739d4a92bd5faac7f6aca", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -33,7 +33,7 @@ use rustc_middle::mir::{self, GeneratorLayout};\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, common_vtable_entries, AdtKind, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, Instance, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::{self, DebugInfo};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileName;\n@@ -1392,7 +1392,7 @@ fn build_vtable_type_di_node<'ll, 'tcx>(\n \n         tcx.vtable_entries(trait_ref)\n     } else {\n-        common_vtable_entries()\n+        TyCtxt::COMMON_VTABLE_ENTRIES\n     };\n \n     // All function pointers are described as opaque pointers. This could be improved in the future"}, {"sha": "c4d1074e4379c01d8ec023eb699a911eab5d250f", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -2,8 +2,8 @@ use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic};\n use rustc_middle::ty::{\n-    self, common_vtable_entries, Ty, COMMON_VTABLE_ENTRIES_ALIGN,\n-    COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n+    self, Ty, TyCtxt, COMMON_VTABLE_ENTRIES_ALIGN, COMMON_VTABLE_ENTRIES_DROPINPLACE,\n+    COMMON_VTABLE_ENTRIES_SIZE,\n };\n use rustc_target::abi::{Align, Size};\n \n@@ -38,7 +38,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Resolves the function at the specified slot in the provided\n-    /// vtable. Currently an index of '3' (`common_vtable_entries().len()`)\n+    /// vtable. Currently an index of '3' (`TyCtxt::COMMON_VTABLE_ENTRIES.len()`)\n     /// corresponds to the first method declared in the trait of the provided vtable.\n     pub fn get_vtable_slot(\n         &self,\n@@ -64,7 +64,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable = self\n             .get_ptr_alloc(\n                 vtable,\n-                pointer_size * u64::try_from(common_vtable_entries().len()).unwrap(),\n+                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n             )?\n             .expect(\"cannot be a ZST\");\n@@ -99,7 +99,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let vtable = self\n             .get_ptr_alloc(\n                 vtable,\n-                pointer_size * u64::try_from(common_vtable_entries().len()).unwrap(),\n+                pointer_size * u64::try_from(TyCtxt::COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n             )?\n             .expect(\"cannot be a ZST\");"}, {"sha": "b83d63e0da086008b00cb320ddb60174866e458e", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 123, "deletions": 68, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -5,8 +5,8 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n-use rustc_hir::{Expr, ExprKind, GenericArg, Path, PathSegment, QPath};\n-use rustc_hir::{HirId, Item, ItemKind, Node, Ty, TyKind};\n+use rustc_hir::{Expr, ExprKind, GenericArg, PatKind, Path, PathSegment, QPath};\n+use rustc_hir::{HirId, Item, ItemKind, Node, Pat, Ty, TyKind};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n@@ -123,55 +123,115 @@ declare_lint_pass!(TyTyKind => [\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n-    fn check_path(&mut self, cx: &LateContext<'_>, path: &'tcx Path<'tcx>, _: HirId) {\n-        let segments = path.segments.iter().rev().skip(1).rev();\n-\n-        if let Some(last) = segments.last() {\n-            let span = path.span.with_hi(last.ident.span.hi());\n-            if lint_ty_kind_usage(cx, last) {\n-                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, |lint| {\n-                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n-                        .span_suggestion(\n-                            span,\n-                            \"try using ty::<kind> directly\",\n-                            \"ty\".to_string(),\n-                            Applicability::MaybeIncorrect, // ty maybe needs an import\n-                        )\n-                        .emit();\n-                })\n-            }\n+    fn check_path(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        path: &'tcx rustc_hir::Path<'tcx>,\n+        _: rustc_hir::HirId,\n+    ) {\n+        if let Some(segment) = path.segments.iter().nth_back(1)\n+        && let Some(res) = &segment.res\n+        && lint_ty_kind_usage(cx, res)\n+        {\n+            let span = path.span.with_hi(\n+                segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n+            );\n+            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                    .span_suggestion(\n+                        span,\n+                        \"try using `ty::<kind>` directly\",\n+                        \"ty\".to_string(),\n+                        Applicability::MaybeIncorrect, // ty maybe needs an import\n+                    )\n+                    .emit();\n+            });\n         }\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, ty: &'tcx Ty<'tcx>) {\n         match &ty.kind {\n             TyKind::Path(QPath::Resolved(_, path)) => {\n-                if let Some(last) = path.segments.iter().last() {\n-                    if lint_ty_kind_usage(cx, last) {\n-                        cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n-                            lint.build(\"usage of `ty::TyKind`\")\n-                                .help(\"try using `Ty` instead\")\n-                                .emit();\n-                        })\n-                    } else {\n-                        if ty.span.from_expansion() {\n-                            return;\n-                        }\n-                        if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n-                            if path.segments.len() > 1 {\n-                                cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n-                                    lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                if lint_ty_kind_usage(cx, &path.res) {\n+                    cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                        let hir = cx.tcx.hir();\n+                        match hir.find(hir.get_parent_node(ty.hir_id)) {\n+                            Some(Node::Pat(Pat {\n+                                kind:\n+                                    PatKind::Path(qpath)\n+                                    | PatKind::TupleStruct(qpath, ..)\n+                                    | PatKind::Struct(qpath, ..),\n+                                ..\n+                            })) => {\n+                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                    && qpath_ty.hir_id == ty.hir_id\n+                                {\n+                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                        .span_suggestion(\n+                                            path.span,\n+                                            \"try using `ty::<kind>` directly\",\n+                                            \"ty\".to_string(),\n+                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n+                                        )\n+                                        .emit();\n+                                    return;\n+                                }\n+                            }\n+                            Some(Node::Expr(Expr {\n+                                kind: ExprKind::Path(qpath),\n+                                ..\n+                            })) => {\n+                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                    && qpath_ty.hir_id == ty.hir_id\n+                                {\n+                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n                                         .span_suggestion(\n                                             path.span,\n-                                            \"try importing it and using it unqualified\",\n-                                            t,\n-                                            // The import probably needs to be changed\n-                                            Applicability::MaybeIncorrect,\n+                                            \"try using `ty::<kind>` directly\",\n+                                            \"ty\".to_string(),\n+                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n                                         )\n                                         .emit();\n-                                })\n+                                    return;\n+                                }\n                             }\n+                            // Can't unify these two branches because qpath below is `&&` and above is `&`\n+                            // and `A | B` paths don't play well together with adjustments, apparently.\n+                            Some(Node::Expr(Expr {\n+                                kind: ExprKind::Struct(qpath, ..),\n+                                ..\n+                            })) => {\n+                                if let QPath::TypeRelative(qpath_ty, ..) = qpath\n+                                    && qpath_ty.hir_id == ty.hir_id\n+                                {\n+                                    lint.build(\"usage of `ty::TyKind::<kind>`\")\n+                                        .span_suggestion(\n+                                            path.span,\n+                                            \"try using `ty::<kind>` directly\",\n+                                            \"ty\".to_string(),\n+                                            Applicability::MaybeIncorrect, // ty maybe needs an import\n+                                        )\n+                                        .emit();\n+                                    return;\n+                                }\n+                            }\n+                            _ => {}\n                         }\n+                        lint.build(\"usage of `ty::TyKind`\").help(\"try using `Ty` instead\").emit();\n+                    })\n+                } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n+                    if path.segments.len() > 1 {\n+                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n+                            lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                                .span_suggestion(\n+                                    path.span,\n+                                    \"try importing it and using it unqualified\",\n+                                    t,\n+                                    // The import probably needs to be changed\n+                                    Applicability::MaybeIncorrect,\n+                                )\n+                                .emit();\n+                        })\n                     }\n                 }\n             }\n@@ -180,42 +240,37 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n     }\n }\n \n-fn lint_ty_kind_usage(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> bool {\n-    if let Some(res) = segment.res {\n-        if let Some(did) = res.opt_def_id() {\n-            return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n-        }\n+fn lint_ty_kind_usage(cx: &LateContext<'_>, res: &Res) -> bool {\n+    if let Some(did) = res.opt_def_id() {\n+        cx.tcx.is_diagnostic_item(sym::TyKind, did) || cx.tcx.is_diagnostic_item(sym::IrTyKind, did)\n+    } else {\n+        false\n     }\n-\n-    false\n }\n \n-fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n-    if let TyKind::Path(QPath::Resolved(_, path)) = &ty.kind {\n-        match path.res {\n-            Res::Def(_, def_id) => {\n-                if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(def_id) {\n-                    return Some(format!(\"{}{}\", name, gen_args(path.segments.last().unwrap())));\n-                }\n+fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, path: &Path<'_>) -> Option<String> {\n+    match &path.res {\n+        Res::Def(_, def_id) => {\n+            if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(*def_id) {\n+                return Some(format!(\"{}{}\", name, gen_args(path.segments.last().unwrap())));\n             }\n-            // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n-            Res::SelfTy { trait_: None, alias_to: Some((did, _)) } => {\n-                if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n-                    if let Some(name @ (sym::Ty | sym::TyCtxt)) =\n-                        cx.tcx.get_diagnostic_name(adt.did())\n-                    {\n-                        // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n-                        // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n-                        // is not actually allowed.\n-                        //\n-                        // I(@lcnr) still kept this branch in so we don't miss this\n-                        // if we ever change it in the future.\n-                        return Some(format!(\"{}<{}>\", name, substs[0]));\n-                    }\n+        }\n+        // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n+        Res::SelfTy { trait_: None, alias_to: Some((did, _)) } => {\n+            if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+                if let Some(name @ (sym::Ty | sym::TyCtxt)) = cx.tcx.get_diagnostic_name(adt.did())\n+                {\n+                    // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n+                    // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n+                    // is not actually allowed.\n+                    //\n+                    // I(@lcnr) still kept this branch in so we don't miss this\n+                    // if we ever change it in the future.\n+                    return Some(format!(\"{}<{}>\", name, substs[0]));\n                 }\n             }\n-            _ => (),\n         }\n+        _ => (),\n     }\n \n     None"}, {"sha": "6f548658ef33dd64647a5c78dfdd27fa0a95abfe", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -94,6 +94,7 @@ pub struct TyInterner<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n }\n \n+/*\n /// We don't ever actually need this. It's only required for derives.\n impl<'tcx> Hash for TyInterner<'tcx> {\n     fn hash<H: Hasher>(&self, _state: &mut H) {}\n@@ -128,6 +129,7 @@ impl fmt::Debug for TyInterner<'_> {\n         write!(f, \"TyInterner\")\n     }\n }\n+*/\n \n #[allow(rustc::usage_of_ty_tykind)]\n impl<'tcx> Interner for TyInterner<'tcx> {"}, {"sha": "208cd9ba16a0844bde36b859f7f5fb24b3ba6944", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -207,10 +207,10 @@ pub struct DeepRejectCtxt {\n }\n \n impl DeepRejectCtxt {\n-    pub fn generic_args_may_unify(\n+    pub fn generic_args_may_unify<'tcx>(\n         self,\n-        obligation_arg: ty::GenericArg<'_>,\n-        impl_arg: ty::GenericArg<'_>,\n+        obligation_arg: ty::GenericArg<'tcx>,\n+        impl_arg: ty::GenericArg<'tcx>,\n     ) -> bool {\n         match (obligation_arg.unpack(), impl_arg.unpack()) {\n             // We don't fast reject based on regions for now.\n@@ -225,7 +225,7 @@ impl DeepRejectCtxt {\n         }\n     }\n \n-    pub fn types_may_unify(self, obligation_ty: Ty<'_>, impl_ty: Ty<'_>) -> bool {\n+    pub fn types_may_unify<'tcx>(self, obligation_ty: Ty<'tcx>, impl_ty: Ty<'tcx>) -> bool {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case."}, {"sha": "25305804d3a71202600107e860bf737405da34aa", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -449,13 +449,13 @@ pub(crate) struct TyS<'tcx> {\n }\n \n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n-//#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-//static_assert_size!(TyS<'_>, 40);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(TyS<'_>, 40);\n \n // We are actually storing a stable hash cache next to the type, so let's\n // also check the full size\n-//#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-//static_assert_size!(WithStableHash<TyS<'_>>, 56);\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(WithStableHash<TyS<'_>>, 56);\n \n /// Use this rather than `TyS`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]"}, {"sha": "9410166ac2013c94d22862484575eb7bc6cb177e", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 200, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -27,9 +27,12 @@ use std::marker::PhantomData;\n use std::ops::{ControlFlow, Deref, Range};\n use ty::util::IntTypeExt;\n \n+use rustc_type_ir::sty::TyKind::*;\n use rustc_type_ir::TyKind as IrTyKind;\n+\n+// Re-export the `TyKind` from `rustc_type_ir` here for convenience\n+#[rustc_diagnostic_item = \"TyKind\"]\n pub type TyKind<'tcx> = IrTyKind<ty::TyInterner<'tcx>>;\n-use rustc_type_ir::sty::TyKind::*;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n@@ -80,205 +83,6 @@ impl BoundRegionKind {\n     }\n }\n \n-/*\n-/// Defines the kinds of types used by the type system.\n-///\n-/// Types written by the user start out as [hir::TyKind](rustc_hir::TyKind) and get\n-/// converted to this representation using `AstConv::ast_ty_to_ty`.\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable, Debug)]\n-#[derive(HashStable)]\n-#[rustc_diagnostic_item = \"TyKind\"]\n-pub enum TyKind<'tcx> {\n-    /// The primitive boolean type. Written as `bool`.\n-    Bool,\n-\n-    /// The primitive character type; holds a Unicode scalar value\n-    /// (a non-surrogate code point). Written as `char`.\n-    Char,\n-\n-    /// A primitive signed integer type. For example, `i32`.\n-    Int(ty::IntTy),\n-\n-    /// A primitive unsigned integer type. For example, `u32`.\n-    Uint(ty::UintTy),\n-\n-    /// A primitive floating-point type. For example, `f64`.\n-    Float(ty::FloatTy),\n-\n-    /// Algebraic data types (ADT). For example: structures, enumerations and unions.\n-    ///\n-    /// For example, the type `List<i32>` would be represented using the `AdtDef`\n-    /// for `struct List<T>` and the substs `[i32]`.\n-    ///\n-    /// Note that generic parameters in fields only get lazily substituted\n-    /// by using something like `adt_def.all_fields().map(|field| field.ty(tcx, substs))`.\n-    Adt(AdtDef<'tcx>, SubstsRef<'tcx>),\n-\n-    /// An unsized FFI type that is opaque to Rust. Written as `extern type T`.\n-    Foreign(DefId),\n-\n-    /// The pointee of a string slice. Written as `str`.\n-    Str,\n-\n-    /// An array with the given length. Written as `[T; N]`.\n-    Array(Ty<'tcx>, ty::Const<'tcx>),\n-\n-    /// The pointee of an array slice. Written as `[T]`.\n-    Slice(Ty<'tcx>),\n-\n-    /// A raw pointer. Written as `*mut T` or `*const T`\n-    RawPtr(TypeAndMut<'tcx>),\n-\n-    /// A reference; a pointer with an associated lifetime. Written as\n-    /// `&'a mut T` or `&'a T`.\n-    Ref(Region<'tcx>, Ty<'tcx>, hir::Mutability),\n-\n-    /// The anonymous type of a function declaration/definition. Each\n-    /// function has a unique type.\n-    ///\n-    /// For the function `fn foo() -> i32 { 3 }` this type would be\n-    /// shown to the user as `fn() -> i32 {foo}`.\n-    ///\n-    /// For example the type of `bar` here:\n-    /// ```rust\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar = foo; // bar: fn() -> i32 {foo}\n-    /// ```\n-    FnDef(DefId, SubstsRef<'tcx>),\n-\n-    /// A pointer to a function. Written as `fn() -> i32`.\n-    ///\n-    /// Note that both functions and closures start out as either\n-    /// [FnDef] or [Closure] which can be then be coerced to this variant.\n-    ///\n-    /// For example the type of `bar` here:\n-    ///\n-    /// ```rust\n-    /// fn foo() -> i32 { 1 }\n-    /// let bar: fn() -> i32 = foo;\n-    /// ```\n-    FnPtr(PolyFnSig<'tcx>),\n-\n-    /// A trait object. Written as `dyn for<'b> Trait<'b, Assoc = u32> + Send + 'a`.\n-    Dynamic(&'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n-\n-    /// The anonymous type of a closure. Used to represent the type of `|a| a`.\n-    ///\n-    /// Closure substs contain both the - potentially substituted - generic parameters\n-    /// of its parent and some synthetic parameters. See the documentation for\n-    /// [ClosureSubsts] for more details.\n-    Closure(DefId, SubstsRef<'tcx>),\n-\n-    /// The anonymous type of a generator. Used to represent the type of\n-    /// `|a| yield a`.\n-    ///\n-    /// For more info about generator substs, visit the documentation for\n-    /// [GeneratorSubsts].\n-    Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n-\n-    /// A type representing the types stored inside a generator.\n-    /// This should only appear as part of the [GeneratorSubsts].\n-    ///\n-    /// Note that the captured variables for generators are stored separately\n-    /// using a tuple in the same way as for closures.\n-    ///\n-    /// Unlike upvars, the witness can reference lifetimes from\n-    /// inside of the generator itself. To deal with them in\n-    /// the type of the generator, we convert them to higher ranked\n-    /// lifetimes bound by the witness itself.\n-    ///\n-    /// Looking at the following example, the witness for this generator\n-    /// may end up as something like `for<'a> [Vec<i32>, &'a Vec<i32>]`:\n-    ///\n-    /// ```ignore UNSOLVED (ask @compiler-errors, should this error? can we just swap the yields?)\n-    /// #![feature(generators)]\n-    /// |a| {\n-    ///     let x = &vec![3];\n-    ///     yield a;\n-    ///     yield x[0];\n-    /// }\n-    /// # ;\n-    /// ```\n-    GeneratorWitness(Binder<'tcx, &'tcx List<Ty<'tcx>>>),\n-\n-    /// The never type `!`.\n-    Never,\n-\n-    /// A tuple type. For example, `(i32, bool)`.\n-    Tuple(&'tcx List<Ty<'tcx>>),\n-\n-    /// The projection of an associated type. For example,\n-    /// `<T as Trait<..>>::N`.\n-    Projection(ProjectionTy<'tcx>),\n-\n-    /// Opaque (`impl Trait`) type found in a return type.\n-    ///\n-    /// The `DefId` comes either from\n-    /// * the `impl Trait` ast::Ty node,\n-    /// * or the `type Foo = impl Trait` declaration\n-    ///\n-    /// For RPIT the substitutions are for the generics of the function,\n-    /// while for TAIT it is used for the generic parameters of the alias.\n-    ///\n-    /// During codegen, `tcx.type_of(def_id)` can be used to get the underlying type.\n-    Opaque(DefId, SubstsRef<'tcx>),\n-\n-    /// A type parameter; for example, `T` in `fn f<T>(x: T) {}`.\n-    Param(ParamTy),\n-\n-    /// Bound type variable, used to represent the `'a` in `for<'a> fn(&'a ())`.\n-    ///\n-    /// For canonical queries, we replace inference variables with bound variables,\n-    /// so e.g. when checking whether `&'_ (): Trait<_>` holds, we canonicalize that to\n-    /// `for<'a, T> &'a (): Trait<T>` and then convert the introduced bound variables\n-    /// back to inference variables in a new inference context when inside of the query.\n-    ///\n-    /// See the `rustc-dev-guide` for more details about\n-    /// [higher-ranked trait bounds][1] and [canonical queries][2].\n-    ///\n-    /// [1]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    /// [2]: https://rustc-dev-guide.rust-lang.org/traits/canonical-queries.html\n-    Bound(ty::DebruijnIndex, BoundTy),\n-\n-    /// A placeholder type, used during higher ranked subtyping to instantiate\n-    /// bound variables.\n-    Placeholder(ty::PlaceholderType),\n-\n-    /// A type variable used during type checking.\n-    ///\n-    /// Similar to placeholders, inference variables also live in a universe to\n-    /// correctly deal with higher ranked types. Though unlike placeholders,\n-    /// that universe is stored in the `InferCtxt` instead of directly\n-    /// inside of the type.\n-    Infer(InferTy),\n-\n-    /// A placeholder for a type which could not be computed; this is\n-    /// propagated to avoid useless error messages.\n-    Error(DelaySpanBugEmitted),\n-}\n-*/\n-\n-/*\n-impl<'tcx> TyKind<'tcx> {\n-    #[inline]\n-    pub fn is_primitive(&self) -> bool {\n-        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n-    }\n-\n-    /// Get the article (\"a\" or \"an\") to use with this type.\n-    pub fn article(&self) -> &'static str {\n-        match self {\n-            Int(_) | Float(_) | Array(_, _) => \"an\",\n-            Adt(def, _) if def.is_enum() => \"an\",\n-            // This should never happen, but ICEing and causing the user's code\n-            // to not compile felt too harsh.\n-            Error(_) => \"a\",\n-            _ => \"a\",\n-        }\n-    }\n-}\n-*/\n-\n pub trait Article {\n     fn article(&self) -> &'static str;\n }"}, {"sha": "04a9fd1f71308d2e67c015e6e6b805e093587ba4", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -36,8 +36,10 @@ impl<'tcx> fmt::Debug for VtblEntry<'tcx> {\n     }\n }\n \n-pub const fn common_vtable_entries<'tcx>() -> &'tcx [VtblEntry<'tcx>] {\n-    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign]\n+// Needs to be associated with the `'tcx` lifetime\n+impl<'tcx> TyCtxt<'tcx> {\n+    pub const COMMON_VTABLE_ENTRIES: &'tcx [VtblEntry<'tcx>] =\n+        &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n }\n \n pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n@@ -58,7 +60,7 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n \n         tcx.vtable_entries(trait_ref)\n     } else {\n-        common_vtable_entries()\n+        TyCtxt::COMMON_VTABLE_ENTRIES\n     };\n \n     let layout = tcx"}, {"sha": "6aeedc49adf557c9b27c1252cdad6536f0ba23cd", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -205,6 +205,7 @@ symbols! {\n         IntoIterator,\n         IoRead,\n         IoWrite,\n+        IrTyKind,\n         Is,\n         ItemContext,\n         Iterator,"}, {"sha": "03757b5447eead25d56b0677274a9674e8d7764c", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -32,9 +32,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{\n-    self, common_vtable_entries, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry,\n-};\n+use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n use rustc_span::{sym, Span};\n use smallvec::SmallVec;\n \n@@ -695,7 +693,7 @@ fn vtable_entries<'tcx>(\n     let vtable_segment_callback = |segment| -> ControlFlow<()> {\n         match segment {\n             VtblSegment::MetadataDSA => {\n-                entries.extend(common_vtable_entries());\n+                entries.extend(TyCtxt::COMMON_VTABLE_ENTRIES);\n             }\n             VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                 let existential_trait_ref = trait_ref\n@@ -785,7 +783,7 @@ fn vtable_trait_first_method_offset<'tcx>(\n         move |segment| {\n             match segment {\n                 VtblSegment::MetadataDSA => {\n-                    vtable_base += common_vtable_entries().len();\n+                    vtable_base += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                 }\n                 VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                     if tcx.erase_regions(trait_ref) == trait_to_be_found_erased {"}, {"sha": "34dc81b14d29e80810186ddeb50ea1395ca5c45a", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -12,7 +12,7 @@ use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, EarlyBinder, GenericParamDefKind, Ty};\n+use rustc_middle::ty::{self, EarlyBinder, GenericParamDefKind, Ty, TyCtxt};\n use rustc_middle::ty::{ToPolyTraitRef, ToPredicate};\n use rustc_span::def_id::DefId;\n \n@@ -834,7 +834,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             move |segment| {\n                 match segment {\n                     VtblSegment::MetadataDSA => {\n-                        vptr_offset += ty::common_vtable_entries().len();\n+                        vptr_offset += TyCtxt::COMMON_VTABLE_ENTRIES.len();\n                     }\n                     VtblSegment::TraitOwnEntries { trait_ref, emit_vptr } => {\n                         vptr_offset += util::count_own_vtable_entries(tcx, trait_ref);"}, {"sha": "766875dd82bdf25290bb8916243bbe85a5e09e6f", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -21,8 +21,6 @@ pub mod sty;\n pub use codec::*;\n pub use sty::*;\n \n-extern crate self as rustc_type_ir;\n-\n pub trait Interner {\n     type AdtDef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;\n     type SubstsRef: Clone + Debug + Hash + PartialEq + Eq + PartialOrd + Ord;"}, {"sha": "33b3a273f44ccb9172e8fc41d28eca9d4ea463ed", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 577, "deletions": 141, "changes": 718, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -1,3 +1,8 @@\n+#![allow(rustc::usage_of_ty_tykind)]\n+\n+use std::cmp::{Eq, Ord, Ordering, PartialEq, PartialOrd};\n+use std::{fmt, hash};\n+\n use crate::DebruijnIndex;\n use crate::FloatTy;\n use crate::IntTy;\n@@ -6,17 +11,17 @@ use crate::TyDecoder;\n use crate::TyEncoder;\n use crate::UintTy;\n \n+use self::TyKind::*;\n+\n use rustc_serialize::{Decodable, Encodable};\n \n /// Defines the kinds of types used by the type system.\n ///\n-/// Types written by the user start out as [hir::TyKind](rustc_hir::TyKind) and get\n+/// Types written by the user start out as `hir::TyKind` and get\n /// converted to this representation using `AstConv::ast_ty_to_ty`.\n-#[allow(rustc::usage_of_ty_tykind)]\n-#[derive(PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-//#[derive(TyEncodable, TyDecodable)]\n-//#[derive(HashStable)]\n-#[rustc_diagnostic_item = \"TyKind\"]\n+///\n+/// The `HashStable` implementation for this type is defined in `rustc_query_system::ich`.\n+#[rustc_diagnostic_item = \"IrTyKind\"]\n pub enum TyKind<I: Interner> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -95,18 +100,18 @@ pub enum TyKind<I: Interner> {\n     ///\n     /// Closure substs contain both the - potentially substituted - generic parameters\n     /// of its parent and some synthetic parameters. See the documentation for\n-    /// [ClosureSubsts] for more details.\n+    /// `ClosureSubsts` for more details.\n     Closure(I::DefId, I::SubstsRef),\n \n     /// The anonymous type of a generator. Used to represent the type of\n     /// `|a| yield a`.\n     ///\n     /// For more info about generator substs, visit the documentation for\n-    /// [GeneratorSubsts].\n+    /// `GeneratorSubsts`.\n     Generator(I::DefId, I::SubstsRef, I::Movability),\n \n     /// A type representing the types stored inside a generator.\n-    /// This should only appear as part of the [GeneratorSubsts].\n+    /// This should only appear as part of the `GeneratorSubsts`.\n     ///\n     /// Note that the captured variables for generators are stored separately\n     /// using a tuple in the same way as for closures.\n@@ -186,10 +191,47 @@ pub enum TyKind<I: Interner> {\n     Error(I::DelaySpanBugEmitted),\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n+impl<I: Interner> TyKind<I> {\n+    #[inline]\n+    pub fn is_primitive(&self) -> bool {\n+        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n+    }\n+}\n+\n+fn discriminant<I: Interner>(value: &TyKind<I>) -> usize {\n+    match value {\n+        Bool => 0,\n+        Char => 1,\n+        Int(_) => 2,\n+        Uint(_) => 3,\n+        Float(_) => 4,\n+        Adt(_, _) => 5,\n+        Foreign(_) => 6,\n+        Str => 7,\n+        Array(_, _) => 8,\n+        Slice(_) => 9,\n+        RawPtr(_) => 10,\n+        Ref(_, _, _) => 11,\n+        FnDef(_, _) => 12,\n+        FnPtr(_) => 13,\n+        Dynamic(_, _) => 14,\n+        Closure(_, _) => 15,\n+        Generator(_, _, _) => 16,\n+        GeneratorWitness(_) => 17,\n+        Never => 18,\n+        Tuple(_) => 19,\n+        Projection(_) => 20,\n+        Opaque(_, _) => 21,\n+        Param(_) => 22,\n+        Bound(_, _) => 23,\n+        Placeholder(_) => 24,\n+        Infer(_) => 25,\n+        Error(_) => 26,\n+    }\n+}\n+\n impl<I: Interner> Clone for TyKind<I> {\n     fn clone(&self) -> Self {\n-        use crate::TyKind::*;\n         match self {\n             Bool => Bool,\n             Char => Char,\n@@ -222,149 +264,553 @@ impl<I: Interner> Clone for TyKind<I> {\n     }\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n-impl<I: Interner> TyKind<I> {\n+impl<I: Interner> PartialEq for TyKind<I> {\n     #[inline]\n-    pub fn is_primitive(&self) -> bool {\n-        use crate::TyKind::*;\n-        matches!(self, Bool | Char | Int(_) | Uint(_) | Float(_))\n+    fn eq(&self, other: &TyKind<I>) -> bool {\n+        let __self_vi = discriminant(self);\n+        let __arg_1_vi = discriminant(other);\n+        if __self_vi == __arg_1_vi {\n+            match (&*self, &*other) {\n+                (&Int(ref __self_0), &Int(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Float(ref __self_0), &Float(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (\n+                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n+                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n+                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Dynamic(ref __self_0, ref __self_1), &Dynamic(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (\n+                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n+                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => __self_0 == __arg_1_0 && __self_1 == __arg_1_1 && __self_2 == __arg_1_2,\n+                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n+                    __self_0 == __arg_1_0\n+                }\n+                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Param(ref __self_0), &Param(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n+                    __self_0 == __arg_1_0 && __self_1 == __arg_1_1\n+                }\n+                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                (&Error(ref __self_0), &Error(ref __arg_1_0)) => __self_0 == __arg_1_0,\n+                _ => true,\n+            }\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<I: Interner> Eq for TyKind<I> {}\n+\n+impl<I: Interner> PartialOrd for TyKind<I> {\n+    #[inline]\n+    fn partial_cmp(&self, other: &TyKind<I>) -> Option<Ordering> {\n+        Some(Ord::cmp(self, other))\n+    }\n+}\n+\n+impl<I: Interner> Ord for TyKind<I> {\n+    #[inline]\n+    fn cmp(&self, other: &TyKind<I>) -> Ordering {\n+        let __self_vi = discriminant(self);\n+        let __arg_1_vi = discriminant(other);\n+        if __self_vi == __arg_1_vi {\n+            match (&*self, &*other) {\n+                (&Int(ref __self_0), &Int(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Uint(ref __self_0), &Uint(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Float(ref __self_0), &Float(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Adt(ref __self_0, ref __self_1), &Adt(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Foreign(ref __self_0), &Foreign(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Array(ref __self_0, ref __self_1), &Array(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Slice(ref __self_0), &Slice(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&RawPtr(ref __self_0), &RawPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (\n+                    &Ref(ref __self_0, ref __self_1, ref __self_2),\n+                    &Ref(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => match Ord::cmp(__self_0, __arg_1_0) {\n+                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n+                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n+                        cmp => cmp,\n+                    },\n+                    cmp => cmp,\n+                },\n+                (&FnDef(ref __self_0, ref __self_1), &FnDef(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&FnPtr(ref __self_0), &FnPtr(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Dynamic(ref __self_0, ref __self_1), &Dynamic(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Closure(ref __self_0, ref __self_1), &Closure(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (\n+                    &Generator(ref __self_0, ref __self_1, ref __self_2),\n+                    &Generator(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),\n+                ) => match Ord::cmp(__self_0, __arg_1_0) {\n+                    Ordering::Equal => match Ord::cmp(__self_1, __arg_1_1) {\n+                        Ordering::Equal => Ord::cmp(__self_2, __arg_1_2),\n+                        cmp => cmp,\n+                    },\n+                    cmp => cmp,\n+                },\n+                (&GeneratorWitness(ref __self_0), &GeneratorWitness(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&Tuple(ref __self_0), &Tuple(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Projection(ref __self_0), &Projection(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&Opaque(ref __self_0, ref __self_1), &Opaque(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Param(ref __self_0), &Param(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Bound(ref __self_0, ref __self_1), &Bound(ref __arg_1_0, ref __arg_1_1)) => {\n+                    match Ord::cmp(__self_0, __arg_1_0) {\n+                        Ordering::Equal => Ord::cmp(__self_1, __arg_1_1),\n+                        cmp => cmp,\n+                    }\n+                }\n+                (&Placeholder(ref __self_0), &Placeholder(ref __arg_1_0)) => {\n+                    Ord::cmp(__self_0, __arg_1_0)\n+                }\n+                (&Infer(ref __self_0), &Infer(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                (&Error(ref __self_0), &Error(ref __arg_1_0)) => Ord::cmp(__self_0, __arg_1_0),\n+                _ => Ordering::Equal,\n+            }\n+        } else {\n+            Ord::cmp(&__self_vi, &__arg_1_vi)\n+        }\n+    }\n+}\n+\n+impl<I: Interner> hash::Hash for TyKind<I> {\n+    fn hash<__H: hash::Hasher>(&self, state: &mut __H) -> () {\n+        match (&*self,) {\n+            (&Int(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Uint(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Float(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Adt(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Foreign(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Array(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Slice(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&RawPtr(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state);\n+                hash::Hash::hash(__self_2, state)\n+            }\n+            (&FnDef(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&FnPtr(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Dynamic(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Closure(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state);\n+                hash::Hash::hash(__self_2, state)\n+            }\n+            (&GeneratorWitness(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Tuple(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Projection(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Opaque(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Param(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Bound(ref __self_0, ref __self_1),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state);\n+                hash::Hash::hash(__self_1, state)\n+            }\n+            (&Placeholder(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Infer(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            (&Error(ref __self_0),) => {\n+                hash::Hash::hash(&discriminant(self), state);\n+                hash::Hash::hash(__self_0, state)\n+            }\n+            _ => hash::Hash::hash(&discriminant(self), state),\n+        }\n     }\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n-impl<__I: Interner, __E: TyEncoder> Encodable<__E> for TyKind<__I>\n+impl<I: Interner> fmt::Debug for TyKind<I> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match (&*self,) {\n+            (&Bool,) => fmt::Formatter::write_str(f, \"Bool\"),\n+            (&Char,) => fmt::Formatter::write_str(f, \"Char\"),\n+            (&Int(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Int\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Uint(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Uint\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Float(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Float\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Adt(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Adt\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Foreign(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Foreign\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Str,) => fmt::Formatter::write_str(f, \"Str\"),\n+            (&Array(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Array\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Slice(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Slice\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&RawPtr(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"RawPtr\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Ref(ref __self_0, ref __self_1, ref __self_2),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Ref\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_2);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&FnDef(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"FnDef\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&FnPtr(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"FnPtr\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Dynamic(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Dynamic\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Closure(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Closure\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Generator(ref __self_0, ref __self_1, ref __self_2),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Generator\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_2);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&GeneratorWitness(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"GeneratorWitness\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Never,) => fmt::Formatter::write_str(f, \"Never\"),\n+            (&Tuple(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Tuple\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Projection(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Projection\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Opaque(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Opaque\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Param(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Param\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Bound(ref __self_0, ref __self_1),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Bound\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_1);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Placeholder(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Placeholder\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Infer(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Infer\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+            (&Error(ref __self_0),) => {\n+                let debug_trait_builder = &mut fmt::Formatter::debug_tuple(f, \"Error\");\n+                let _ = fmt::DebugTuple::field(debug_trait_builder, &__self_0);\n+                fmt::DebugTuple::finish(debug_trait_builder)\n+            }\n+        }\n+    }\n+}\n+\n+impl<I: Interner, E: TyEncoder> Encodable<E> for TyKind<I>\n where\n-    __I::DelaySpanBugEmitted: Encodable<__E>,\n-    __I::AdtDef: Encodable<__E>,\n-    __I::SubstsRef: Encodable<__E>,\n-    __I::DefId: Encodable<__E>,\n-    __I::Ty: Encodable<__E>,\n-    __I::Const: Encodable<__E>,\n-    __I::Region: Encodable<__E>,\n-    __I::TypeAndMut: Encodable<__E>,\n-    __I::Mutability: Encodable<__E>,\n-    __I::Movability: Encodable<__E>,\n-    __I::PolyFnSig: Encodable<__E>,\n-    __I::ListBinderExistentialPredicate: Encodable<__E>,\n-    __I::BinderListTy: Encodable<__E>,\n-    __I::ListTy: Encodable<__E>,\n-    __I::ProjectionTy: Encodable<__E>,\n-    __I::ParamTy: Encodable<__E>,\n-    __I::BoundTy: Encodable<__E>,\n-    __I::PlaceholderType: Encodable<__E>,\n-    __I::InferTy: Encodable<__E>,\n-    __I::DelaySpanBugEmitted: Encodable<__E>,\n-    __I::PredicateKind: Encodable<__E>,\n-    __I::AllocId: Encodable<__E>,\n+    I::DelaySpanBugEmitted: Encodable<E>,\n+    I::AdtDef: Encodable<E>,\n+    I::SubstsRef: Encodable<E>,\n+    I::DefId: Encodable<E>,\n+    I::Ty: Encodable<E>,\n+    I::Const: Encodable<E>,\n+    I::Region: Encodable<E>,\n+    I::TypeAndMut: Encodable<E>,\n+    I::Mutability: Encodable<E>,\n+    I::Movability: Encodable<E>,\n+    I::PolyFnSig: Encodable<E>,\n+    I::ListBinderExistentialPredicate: Encodable<E>,\n+    I::BinderListTy: Encodable<E>,\n+    I::ListTy: Encodable<E>,\n+    I::ProjectionTy: Encodable<E>,\n+    I::ParamTy: Encodable<E>,\n+    I::BoundTy: Encodable<E>,\n+    I::PlaceholderType: Encodable<E>,\n+    I::InferTy: Encodable<E>,\n+    I::DelaySpanBugEmitted: Encodable<E>,\n+    I::PredicateKind: Encodable<E>,\n+    I::AllocId: Encodable<E>,\n {\n-    fn encode(&self, e: &mut __E) -> Result<(), <__E as rustc_serialize::Encoder>::Error> {\n+    fn encode(&self, e: &mut E) -> Result<(), <E as rustc_serialize::Encoder>::Error> {\n         rustc_serialize::Encoder::emit_enum(e, |e| {\n-            use rustc_type_ir::TyKind::*;\n+            let disc = discriminant(self);\n             match self {\n-                Bool => e.emit_enum_variant(\"Bool\", 0, 0, |_| Ok(())),\n-                Char => e.emit_enum_variant(\"Char\", 1, 0, |_| Ok(())),\n-                Int(i) => e.emit_enum_variant(\"Int\", 2, 1, |e| {\n+                Bool => e.emit_enum_variant(\"Bool\", disc, 0, |_| Ok(())),\n+                Char => e.emit_enum_variant(\"Char\", disc, 0, |_| Ok(())),\n+                Int(i) => e.emit_enum_variant(\"Int\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n                     Ok(())\n                 }),\n-                Uint(u) => e.emit_enum_variant(\"Uint\", 3, 1, |e| {\n+                Uint(u) => e.emit_enum_variant(\"Uint\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| u.encode(e))?;\n                     Ok(())\n                 }),\n-                Float(f) => e.emit_enum_variant(\"Float\", 4, 1, |e| {\n+                Float(f) => e.emit_enum_variant(\"Float\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| f.encode(e))?;\n                     Ok(())\n                 }),\n-                Adt(adt, substs) => e.emit_enum_variant(\"Adt\", 5, 2, |e| {\n+                Adt(adt, substs) => e.emit_enum_variant(\"Adt\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| adt.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Foreign(def_id) => e.emit_enum_variant(\"Foreign\", 6, 1, |e| {\n+                Foreign(def_id) => e.emit_enum_variant(\"Foreign\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n                     Ok(())\n                 }),\n-                Str => e.emit_enum_variant(\"Str\", 7, 0, |_| Ok(())),\n-                Array(t, c) => e.emit_enum_variant(\"Array\", 8, 2, |e| {\n+                Str => e.emit_enum_variant(\"Str\", disc, 0, |_| Ok(())),\n+                Array(t, c) => e.emit_enum_variant(\"Array\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| c.encode(e))?;\n                     Ok(())\n                 }),\n-                Slice(t) => e.emit_enum_variant(\"Slice\", 9, 1, |e| {\n+                Slice(t) => e.emit_enum_variant(\"Slice\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| t.encode(e))?;\n                     Ok(())\n                 }),\n-                RawPtr(tam) => e.emit_enum_variant(\"RawPtr\", 10, 1, |e| {\n+                RawPtr(tam) => e.emit_enum_variant(\"RawPtr\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| tam.encode(e))?;\n                     Ok(())\n                 }),\n-                Ref(r, t, m) => e.emit_enum_variant(\"Ref\", 11, 3, |e| {\n+                Ref(r, t, m) => e.emit_enum_variant(\"Ref\", disc, 3, |e| {\n                     e.emit_enum_variant_arg(true, |e| r.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| t.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n                     Ok(())\n                 }),\n-                FnDef(def_id, substs) => e.emit_enum_variant(\"FnDef\", 12, 2, |e| {\n+                FnDef(def_id, substs) => e.emit_enum_variant(\"FnDef\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                FnPtr(polyfnsig) => e.emit_enum_variant(\"FnPtr\", 13, 1, |e| {\n+                FnPtr(polyfnsig) => e.emit_enum_variant(\"FnPtr\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| polyfnsig.encode(e))?;\n                     Ok(())\n                 }),\n-                Dynamic(l, r) => e.emit_enum_variant(\"Dynamic\", 14, 2, |e| {\n+                Dynamic(l, r) => e.emit_enum_variant(\"Dynamic\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| l.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| r.encode(e))?;\n                     Ok(())\n                 }),\n-                Closure(def_id, substs) => e.emit_enum_variant(\"Closure\", 15, 2, |e| {\n+                Closure(def_id, substs) => e.emit_enum_variant(\"Closure\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Generator(def_id, substs, m) => e.emit_enum_variant(\"Generator\", 16, 3, |e| {\n+                Generator(def_id, substs, m) => e.emit_enum_variant(\"Generator\", disc, 3, |e| {\n                     e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| m.encode(e))?;\n                     Ok(())\n                 }),\n-                GeneratorWitness(b) => e.emit_enum_variant(\"GeneratorWitness\", 17, 1, |e| {\n+                GeneratorWitness(b) => e.emit_enum_variant(\"GeneratorWitness\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| b.encode(e))?;\n                     Ok(())\n                 }),\n-                Never => e.emit_enum_variant(\"Never\", 18, 0, |_| Ok(())),\n-                Tuple(substs) => e.emit_enum_variant(\"Tuple\", 19, 1, |e| {\n+                Never => e.emit_enum_variant(\"Never\", disc, 0, |_| Ok(())),\n+                Tuple(substs) => e.emit_enum_variant(\"Tuple\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Projection(p) => e.emit_enum_variant(\"Projection\", 20, 1, |e| {\n+                Projection(p) => e.emit_enum_variant(\"Projection\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n                     Ok(())\n                 }),\n-                Opaque(def_id, substs) => e.emit_enum_variant(\"Opaque\", 21, 2, |e| {\n+                Opaque(def_id, substs) => e.emit_enum_variant(\"Opaque\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| def_id.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| substs.encode(e))?;\n                     Ok(())\n                 }),\n-                Param(p) => e.emit_enum_variant(\"Param\", 22, 1, |e| {\n+                Param(p) => e.emit_enum_variant(\"Param\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n                     Ok(())\n                 }),\n-                Bound(d, b) => e.emit_enum_variant(\"Bound\", 23, 2, |e| {\n+                Bound(d, b) => e.emit_enum_variant(\"Bound\", disc, 2, |e| {\n                     e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n                     e.emit_enum_variant_arg(false, |e| b.encode(e))?;\n                     Ok(())\n                 }),\n-                Placeholder(p) => e.emit_enum_variant(\"Placeholder\", 24, 1, |e| {\n+                Placeholder(p) => e.emit_enum_variant(\"Placeholder\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| p.encode(e))?;\n                     Ok(())\n                 }),\n-                Infer(i) => e.emit_enum_variant(\"Infer\", 25, 1, |e| {\n+                Infer(i) => e.emit_enum_variant(\"Infer\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| i.encode(e))?;\n                     Ok(())\n                 }),\n-                Error(d) => e.emit_enum_variant(\"Error\", 26, 1, |e| {\n+                Error(d) => e.emit_enum_variant(\"Error\", disc, 1, |e| {\n                     e.emit_enum_variant_arg(true, |e| d.encode(e))?;\n                     Ok(())\n                 }),\n@@ -373,92 +819,82 @@ where\n     }\n }\n \n-#[allow(rustc::usage_of_ty_tykind)]\n-impl<__I: Interner, __D: TyDecoder<I = __I>> Decodable<__D> for TyKind<__I>\n+impl<I: Interner, D: TyDecoder<I = I>> Decodable<D> for TyKind<I>\n where\n-    __I::DelaySpanBugEmitted: Decodable<__D>,\n-    __I::AdtDef: Decodable<__D>,\n-    __I::SubstsRef: Decodable<__D>,\n-    __I::DefId: Decodable<__D>,\n-    __I::Ty: Decodable<__D>,\n-    __I::Const: Decodable<__D>,\n-    __I::Region: Decodable<__D>,\n-    __I::TypeAndMut: Decodable<__D>,\n-    __I::Mutability: Decodable<__D>,\n-    __I::Movability: Decodable<__D>,\n-    __I::PolyFnSig: Decodable<__D>,\n-    __I::ListBinderExistentialPredicate: Decodable<__D>,\n-    __I::BinderListTy: Decodable<__D>,\n-    __I::ListTy: Decodable<__D>,\n-    __I::ProjectionTy: Decodable<__D>,\n-    __I::ParamTy: Decodable<__D>,\n-    __I::BoundTy: Decodable<__D>,\n-    __I::PlaceholderType: Decodable<__D>,\n-    __I::InferTy: Decodable<__D>,\n-    __I::DelaySpanBugEmitted: Decodable<__D>,\n-    __I::PredicateKind: Decodable<__D>,\n-    __I::AllocId: Decodable<__D>,\n+    I::DelaySpanBugEmitted: Decodable<D>,\n+    I::AdtDef: Decodable<D>,\n+    I::SubstsRef: Decodable<D>,\n+    I::DefId: Decodable<D>,\n+    I::Ty: Decodable<D>,\n+    I::Const: Decodable<D>,\n+    I::Region: Decodable<D>,\n+    I::TypeAndMut: Decodable<D>,\n+    I::Mutability: Decodable<D>,\n+    I::Movability: Decodable<D>,\n+    I::PolyFnSig: Decodable<D>,\n+    I::ListBinderExistentialPredicate: Decodable<D>,\n+    I::BinderListTy: Decodable<D>,\n+    I::ListTy: Decodable<D>,\n+    I::ProjectionTy: Decodable<D>,\n+    I::ParamTy: Decodable<D>,\n+    I::BoundTy: Decodable<D>,\n+    I::PlaceholderType: Decodable<D>,\n+    I::InferTy: Decodable<D>,\n+    I::DelaySpanBugEmitted: Decodable<D>,\n+    I::PredicateKind: Decodable<D>,\n+    I::AllocId: Decodable<D>,\n {\n-    fn decode(__decoder: &mut __D) -> Self {\n-        use TyKind::*;\n-\n-        match rustc_serialize::Decoder::read_usize(__decoder) {\n+    fn decode(d: &mut D) -> Self {\n+        match rustc_serialize::Decoder::read_usize(d) {\n             0 => Bool,\n             1 => Char,\n-            2 => Int(rustc_serialize::Decodable::decode(__decoder)),\n-            3 => Uint(rustc_serialize::Decodable::decode(__decoder)),\n-            4 => Float(rustc_serialize::Decodable::decode(__decoder)),\n-            5 => Adt(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-            ),\n-            6 => Foreign(rustc_serialize::Decodable::decode(__decoder)),\n+            2 => Int(rustc_serialize::Decodable::decode(d)),\n+            3 => Uint(rustc_serialize::Decodable::decode(d)),\n+            4 => Float(rustc_serialize::Decodable::decode(d)),\n+            5 => Adt(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d)),\n+            6 => Foreign(rustc_serialize::Decodable::decode(d)),\n             7 => Str,\n-            8 => Array(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-            ),\n-            9 => Slice(rustc_serialize::Decodable::decode(__decoder)),\n-            10 => RawPtr(rustc_serialize::Decodable::decode(__decoder)),\n+            8 => {\n+                Array(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            9 => Slice(rustc_serialize::Decodable::decode(d)),\n+            10 => RawPtr(rustc_serialize::Decodable::decode(d)),\n             11 => Ref(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-            ),\n-            12 => FnDef(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n             ),\n-            13 => FnPtr(rustc_serialize::Decodable::decode(__decoder)),\n+            12 => {\n+                FnDef(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            13 => FnPtr(rustc_serialize::Decodable::decode(d)),\n             14 => Dynamic(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n             ),\n             15 => Closure(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n             ),\n             16 => Generator(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n+                rustc_serialize::Decodable::decode(d),\n             ),\n-            17 => GeneratorWitness(rustc_serialize::Decodable::decode(__decoder)),\n+            17 => GeneratorWitness(rustc_serialize::Decodable::decode(d)),\n             18 => Never,\n-            19 => Tuple(rustc_serialize::Decodable::decode(__decoder)),\n-            20 => Projection(rustc_serialize::Decodable::decode(__decoder)),\n-            21 => Opaque(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-            ),\n-            22 => Param(rustc_serialize::Decodable::decode(__decoder)),\n-            23 => Bound(\n-                rustc_serialize::Decodable::decode(__decoder),\n-                rustc_serialize::Decodable::decode(__decoder),\n-            ),\n-            24 => Placeholder(rustc_serialize::Decodable::decode(__decoder)),\n-            25 => Infer(rustc_serialize::Decodable::decode(__decoder)),\n-            26 => Error(rustc_serialize::Decodable::decode(__decoder)),\n+            19 => Tuple(rustc_serialize::Decodable::decode(d)),\n+            20 => Projection(rustc_serialize::Decodable::decode(d)),\n+            21 => {\n+                Opaque(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            22 => Param(rustc_serialize::Decodable::decode(d)),\n+            23 => {\n+                Bound(rustc_serialize::Decodable::decode(d), rustc_serialize::Decodable::decode(d))\n+            }\n+            24 => Placeholder(rustc_serialize::Decodable::decode(d)),\n+            25 => Infer(rustc_serialize::Decodable::decode(d)),\n+            26 => Error(rustc_serialize::Decodable::decode(d)),\n             _ => panic!(\n                 \"{}\",\n                 format!("}, {"sha": "8f78bda033ec18726123ae23da4afe8e0af6b73a", "filename": "src/test/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -154,7 +154,7 @@ fn get_bodies<'tcx>(tcx: TyCtxt<'tcx>) -> Vec<(String, BodyWithBorrowckFacts<'tc\n                 // SAFETY: For soundness we need to ensure that the bodies have\n                 // the same lifetime (`'tcx`), which they had before they were\n                 // stored in the thread local.\n-                (def_path.to_string_no_crate_verbose(), body)\n+                (def_path.to_string_no_crate_verbose(), unsafe { std::mem::transmute(body) })\n             })\n             .collect()\n     })"}, {"sha": "2cb1ed6fcb76b349133493d7a627d91ba157e16a", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -3,46 +3,54 @@\n #![feature(rustc_private)]\n \n extern crate rustc_middle;\n+extern crate rustc_type_ir;\n \n use rustc_middle::ty::{self, Ty, TyKind};\n+use rustc_type_ir::{Interner, TyKind as IrTyKind};\n \n #[deny(rustc::usage_of_ty_tykind)]\n fn main() {\n     let kind = TyKind::Bool; //~ ERROR usage of `ty::TyKind::<kind>`\n \n     match kind {\n-        TyKind::Bool => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Char => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Int(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Uint(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Float(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Adt(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Foreign(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Str => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Array(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Slice(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::RawPtr(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Ref(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::FnDef(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::FnPtr(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Dynamic(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Closure(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Generator(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Bool => (),                 //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Char => (),                 //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Int(..) => (),              //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Uint(..) => (),             //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Float(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Adt(..) => (),              //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Foreign(..) => (),          //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Str => (),                  //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Array(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Slice(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::RawPtr(..) => (),           //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Ref(..) => (),              //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::FnDef(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::FnPtr(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Dynamic(..) => (),          //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Closure(..) => (),          //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Generator(..) => (),        //~ ERROR usage of `ty::TyKind::<kind>`\n         TyKind::GeneratorWitness(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Never => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Tuple(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Projection(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Opaque(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Param(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Bound(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Placeholder(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Infer(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n-        TyKind::Error(_) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Never => (),                //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Tuple(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Projection(..) => (),       //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Opaque(..) => (),           //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Param(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Bound(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Placeholder(..) => (),      //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Infer(..) => (),            //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Error(_) => (),             //~ ERROR usage of `ty::TyKind::<kind>`\n     }\n \n     if let ty::Int(int_ty) = kind {}\n \n     if let TyKind::Int(int_ty) = kind {} //~ ERROR usage of `ty::TyKind::<kind>`\n \n     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {} //~ ERROR usage of `ty::TyKind`\n+\n+    fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n+        //~^ ERROR usage of `ty::TyKind`\n+        //~| ERROR usage of `ty::TyKind`\n+        IrTyKind::Bool //~ ERROR usage of `ty::TyKind::<kind>`\n+    }\n }"}, {"sha": "171f49087d6953fc4818eafa7c00b7794fa7a038", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/34e05812e029206add91fa39df86765fcb3f8b5a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/34e05812e029206add91fa39df86765fcb3f8b5a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=34e05812e029206add91fa39df86765fcb3f8b5a", "patch": "@@ -1,190 +1,214 @@\n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:11:16\n+  --> $DIR/ty_tykind_usage.rs:13:16\n    |\n LL |     let kind = TyKind::Bool;\n-   |                ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |                ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n    |\n note: the lint level is defined here\n-  --> $DIR/ty_tykind_usage.rs:9:8\n+  --> $DIR/ty_tykind_usage.rs:11:8\n    |\n LL | #[deny(rustc::usage_of_ty_tykind)]\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:14:9\n+  --> $DIR/ty_tykind_usage.rs:16:9\n    |\n LL |         TyKind::Bool => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:15:9\n+  --> $DIR/ty_tykind_usage.rs:17:9\n    |\n LL |         TyKind::Char => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:16:9\n+  --> $DIR/ty_tykind_usage.rs:18:9\n    |\n LL |         TyKind::Int(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:17:9\n+  --> $DIR/ty_tykind_usage.rs:19:9\n    |\n LL |         TyKind::Uint(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:18:9\n+  --> $DIR/ty_tykind_usage.rs:20:9\n    |\n LL |         TyKind::Float(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:19:9\n+  --> $DIR/ty_tykind_usage.rs:21:9\n    |\n LL |         TyKind::Adt(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:20:9\n+  --> $DIR/ty_tykind_usage.rs:22:9\n    |\n LL |         TyKind::Foreign(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:21:9\n+  --> $DIR/ty_tykind_usage.rs:23:9\n    |\n LL |         TyKind::Str => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:22:9\n+  --> $DIR/ty_tykind_usage.rs:24:9\n    |\n LL |         TyKind::Array(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:23:9\n+  --> $DIR/ty_tykind_usage.rs:25:9\n    |\n LL |         TyKind::Slice(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:24:9\n+  --> $DIR/ty_tykind_usage.rs:26:9\n    |\n LL |         TyKind::RawPtr(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:25:9\n+  --> $DIR/ty_tykind_usage.rs:27:9\n    |\n LL |         TyKind::Ref(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:26:9\n+  --> $DIR/ty_tykind_usage.rs:28:9\n    |\n LL |         TyKind::FnDef(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:27:9\n+  --> $DIR/ty_tykind_usage.rs:29:9\n    |\n LL |         TyKind::FnPtr(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:28:9\n+  --> $DIR/ty_tykind_usage.rs:30:9\n    |\n LL |         TyKind::Dynamic(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:29:9\n+  --> $DIR/ty_tykind_usage.rs:31:9\n    |\n LL |         TyKind::Closure(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:30:9\n+  --> $DIR/ty_tykind_usage.rs:32:9\n    |\n LL |         TyKind::Generator(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:31:9\n+  --> $DIR/ty_tykind_usage.rs:33:9\n    |\n LL |         TyKind::GeneratorWitness(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:32:9\n+  --> $DIR/ty_tykind_usage.rs:34:9\n    |\n LL |         TyKind::Never => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:33:9\n+  --> $DIR/ty_tykind_usage.rs:35:9\n    |\n LL |         TyKind::Tuple(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:34:9\n+  --> $DIR/ty_tykind_usage.rs:36:9\n    |\n LL |         TyKind::Projection(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:35:9\n+  --> $DIR/ty_tykind_usage.rs:37:9\n    |\n LL |         TyKind::Opaque(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:36:9\n+  --> $DIR/ty_tykind_usage.rs:38:9\n    |\n LL |         TyKind::Param(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:37:9\n+  --> $DIR/ty_tykind_usage.rs:39:9\n    |\n LL |         TyKind::Bound(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:38:9\n+  --> $DIR/ty_tykind_usage.rs:40:9\n    |\n LL |         TyKind::Placeholder(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:39:9\n+  --> $DIR/ty_tykind_usage.rs:41:9\n    |\n LL |         TyKind::Infer(..) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:40:9\n+  --> $DIR/ty_tykind_usage.rs:42:9\n    |\n LL |         TyKind::Error(_) => (),\n-   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |         ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind::<kind>`\n-  --> $DIR/ty_tykind_usage.rs:45:12\n+  --> $DIR/ty_tykind_usage.rs:47:12\n    |\n LL |     if let TyKind::Int(int_ty) = kind {}\n-   |            ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |            ^^^^^^ help: try using `ty::<kind>` directly: `ty`\n \n error: usage of `ty::TyKind`\n-  --> $DIR/ty_tykind_usage.rs:47:24\n+  --> $DIR/ty_tykind_usage.rs:49:24\n    |\n LL |     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {}\n    |                        ^^^^^^^^^^\n    |\n    = help: try using `Ty` instead\n \n-error: aborting due to 30 previous errors\n+error: usage of `ty::TyKind`\n+  --> $DIR/ty_tykind_usage.rs:51:37\n+   |\n+LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n+   |                                     ^^^^^^^^^^^\n+   |\n+   = help: try using `Ty` instead\n+\n+error: usage of `ty::TyKind`\n+  --> $DIR/ty_tykind_usage.rs:51:53\n+   |\n+LL |     fn ir_ty_kind<I: Interner>(bad: IrTyKind<I>) -> IrTyKind<I> {\n+   |                                                     ^^^^^^^^^^^\n+   |\n+   = help: try using `Ty` instead\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:54:9\n+   |\n+LL |         IrTyKind::Bool\n+   |         --------^^^^^^\n+   |         |\n+   |         help: try using `ty::<kind>` directly: `ty`\n+\n+error: aborting due to 33 previous errors\n "}]}