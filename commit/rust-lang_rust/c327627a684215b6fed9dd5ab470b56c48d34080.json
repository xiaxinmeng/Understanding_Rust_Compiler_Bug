{"sha": "c327627a684215b6fed9dd5ab470b56c48d34080", "node_id": "C_kwDOAAsO6NoAKGMzMjc2MjdhNjg0MjE1YjZmZWQ5ZGQ1YWI0NzBiNTZjNDhkMzQwODA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-12-01T01:19:37Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-12-21T03:50:15Z"}, "message": "Bail if printing item named `_` in `try_print_visible_def_path`", "tree": {"sha": "ea7f719b58a234f6e1d2bc0002ddcd199f208f5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea7f719b58a234f6e1d2bc0002ddcd199f208f5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c327627a684215b6fed9dd5ab470b56c48d34080", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c327627a684215b6fed9dd5ab470b56c48d34080", "html_url": "https://github.com/rust-lang/rust/commit/c327627a684215b6fed9dd5ab470b56c48d34080", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c327627a684215b6fed9dd5ab470b56c48d34080/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f2cf1e9b7d57562f5c10837caf8df357b64df4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f2cf1e9b7d57562f5c10837caf8df357b64df4c", "html_url": "https://github.com/rust-lang/rust/commit/1f2cf1e9b7d57562f5c10837caf8df357b64df4c"}], "stats": {"total": 44, "additions": 28, "deletions": 16}, "files": [{"sha": "47a9234419c2d9ca5c066bbf5dba383ae1c915d4", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c327627a684215b6fed9dd5ab470b56c48d34080/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c327627a684215b6fed9dd5ab470b56c48d34080/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c327627a684215b6fed9dd5ab470b56c48d34080", "patch": "@@ -319,6 +319,9 @@ pub trait PrettyPrinter<'tcx>:\n     ///\n     /// `callers` is a chain of visible_parent's leading to `def_id`,\n     /// to support cycle detection during recursion.\n+    ///\n+    /// This method returns false if we can't print the visible path, so\n+    /// `print_def_path` can fall back on the item's real definition path.\n     fn try_print_visible_def_path_recur(\n         mut self,\n         def_id: DefId,\n@@ -405,19 +408,7 @@ pub trait PrettyPrinter<'tcx>:\n             Some(parent) => parent,\n             None => return Ok((self, false)),\n         };\n-        if callers.contains(&visible_parent) {\n-            return Ok((self, false));\n-        }\n-        callers.push(visible_parent);\n-        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n-        // knowing ahead of time whether the entire path will succeed or not.\n-        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n-        // linked list on the stack would need to be built, before any printing.\n-        match self.try_print_visible_def_path_recur(visible_parent, callers)? {\n-            (cx, false) => return Ok((cx, false)),\n-            (cx, true) => self = cx,\n-        }\n-        callers.pop();\n+\n         let actual_parent = self.tcx().parent(def_id);\n         debug!(\n             \"try_print_visible_def_path: visible_parent={:?} actual_parent={:?}\",\n@@ -463,14 +454,21 @@ pub trait PrettyPrinter<'tcx>:\n             // `visible_parent_map`), looking for the specific child we currently have and then\n             // have access to the re-exported name.\n             DefPathData::TypeNs(ref mut name) if Some(visible_parent) != actual_parent => {\n+                // Item might be re-exported several times, but filter for the one\n+                // that's public and whose identifier isn't `_`.\n                 let reexport = self\n                     .tcx()\n                     .item_children(visible_parent)\n                     .iter()\n-                    .find(|child| child.res.opt_def_id() == Some(def_id))\n+                    .filter(|child| child.res.opt_def_id() == Some(def_id))\n+                    .find(|child| child.vis.is_public() && child.ident.name != kw::Underscore)\n                     .map(|child| child.ident.name);\n-                if let Some(reexport) = reexport {\n-                    *name = reexport;\n+\n+                if let Some(new_name) = reexport {\n+                    *name = new_name;\n+                } else {\n+                    // There is no name that is public and isn't `_`, so bail.\n+                    return Ok((self, false));\n                 }\n             }\n             // Re-exported `extern crate` (#43189).\n@@ -481,6 +479,20 @@ pub trait PrettyPrinter<'tcx>:\n         }\n         debug!(\"try_print_visible_def_path: data={:?}\", data);\n \n+        if callers.contains(&visible_parent) {\n+            return Ok((self, false));\n+        }\n+        callers.push(visible_parent);\n+        // HACK(eddyb) this bypasses `path_append`'s prefix printing to avoid\n+        // knowing ahead of time whether the entire path will succeed or not.\n+        // To support printers that do not implement `PrettyPrinter`, a `Vec` or\n+        // linked list on the stack would need to be built, before any printing.\n+        match self.try_print_visible_def_path_recur(visible_parent, callers)? {\n+            (cx, false) => return Ok((cx, false)),\n+            (cx, true) => self = cx,\n+        }\n+        callers.pop();\n+\n         Ok((self.path_append(Ok, &DisambiguatedDefPathData { data, disambiguator: 0 })?, true))\n     }\n "}]}