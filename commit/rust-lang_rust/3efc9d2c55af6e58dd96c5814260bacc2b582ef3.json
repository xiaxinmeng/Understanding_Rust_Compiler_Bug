{"sha": "3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZmM5ZDJjNTVhZjZlNThkZDk2YzU4MTQyNjBiYWNjMmI1ODJlZjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-01T15:11:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:29Z"}, "message": "Fix bug in higher-ranked code that would sometimes leak skolemized regions and/or cause incorrect results.", "tree": {"sha": "0c9d4717d2ef6cb41fc29d666da5f81c01ddf7e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c9d4717d2ef6cb41fc29d666da5f81c01ddf7e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "html_url": "https://github.com/rust-lang/rust/commit/3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "514dfdbf12b71758c7abc3219ae1a3936e4d59d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/514dfdbf12b71758c7abc3219ae1a3936e4d59d9", "html_url": "https://github.com/rust-lang/rust/commit/514dfdbf12b71758c7abc3219ae1a3936e4d59d9"}], "stats": {"total": 697, "additions": 456, "deletions": 241}, "files": [{"sha": "43d99ecb427a7d8631447d6eb29b502b3194f7f2", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -286,7 +286,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -309,7 +309,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -327,7 +327,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     match self.unsize_ty(t_a, sty_a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n-                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -384,7 +384,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     let mut result = None;\n                     let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                     for (i, (tp_a, tp_b)) in tps {\n-                        if self.get_ref().infcx.try(|| sub.tys(*tp_a, *tp_b)).is_ok() {\n+                        if self.get_ref().infcx.try(|_| sub.tys(*tp_a, *tp_b)).is_ok() {\n                             continue;\n                         }\n                         match\n@@ -397,7 +397,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 let mut new_substs = substs_a.clone();\n                                 new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                 let ty = ty::mk_struct(tcx, did_a, new_substs);\n-                                if self.get_ref().infcx.try(|| sub.tys(ty, ty_b)).is_err() {\n+                                if self.get_ref().infcx.try(|_| sub.tys(ty, ty_b)).is_err() {\n                                     debug!(\"Unsized type parameter '{}', but still \\\n                                             could not match types {} and {}\",\n                                            ppaux::ty_to_string(tcx, *tp_a),"}, {"sha": "1b72a572e9ec06df086468aee61d020a72669400", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -706,14 +706,38 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n-            ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n-            _ if self.make_region_vars => {\n-                // FIXME: This is non-ideal because we don't give a\n-                // very descriptive origin for this region variable.\n-                self.infcx.next_region_var(MiscVariable(self.span))\n+            // Never make variables for regions bound within the type itself.\n+            ty::ReLateBound(..) => { return r; }\n+\n+            // Early-bound regions should really have been substituted away before\n+            // we get to this point.\n+            ty::ReEarlyBound(..) => {\n+                self.tcx().sess.span_bug(\n+                    self.span,\n+                    format!(\"Encountered early bound region when generalizing: {}\",\n+                            r.repr(self.tcx()))[]);\n+            }\n+\n+            // Always make a fresh region variable for skolemized regions;\n+            // the higher-ranked decision procedures rely on this.\n+            ty::ReInfer(ty::ReSkolemized(..)) => { }\n+\n+            // For anything else, we make a region variable, unless we\n+            // are *equating*, in which case it's just wasteful.\n+            ty::ReEmpty |\n+            ty::ReStatic |\n+            ty::ReScope(..) |\n+            ty::ReInfer(ty::ReVar(..)) |\n+            ty::ReFree(..) => {\n+                if !self.make_region_vars {\n+                    return r;\n+                }\n             }\n-            _ => r,\n         }\n+\n+        // FIXME: This is non-ideal because we don't give a\n+        // very descriptive origin for this region variable.\n+        self.infcx.next_region_var(MiscVariable(self.span))\n     }\n }\n "}, {"sha": "e1473847c235b80d24ac91f1ac98f27418e7af6e", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -1640,7 +1640,7 @@ pub trait Resolvable<'tcx> {\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n-        infcx.resolve_type_vars_if_possible(*self)\n+        infcx.resolve_type_vars_if_possible(self)\n     }\n     fn contains_error(&self) -> bool {\n         ty::type_is_error(*self)\n@@ -1650,7 +1650,7 @@ impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n                    -> Rc<ty::TraitRef<'tcx>> {\n-        Rc::new(infcx.resolve_type_vars_in_trait_ref_if_possible(&**self))\n+        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {\n         ty::trait_ref_contains_error(&**self)"}, {"sha": "f6f254c0e8dfce198a1162bcc7a38e06126b315a", "filename": "src/librustc/middle/infer/higher_ranked/doc.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -249,19 +249,21 @@\n //! in T and try to, in some cases, replace them with bound regions to\n //! yield the final result.\n //!\n-//! To decide whether to replace a region `R` that appears in `T` with a\n-//! bound region, the algorithms make use of two bits of information.\n-//! First is a set `V` that contains all region variables created as part\n-//! of the LUB/GLB computation. `V` will contain the region variables\n-//! created to replace the bound regions in the input types, but it also\n-//! contains 'intermediate' variables created to represent the LUB/GLB of\n-//! individual regions.  Basically, when asked to compute the LUB/GLB of a\n-//! region variable with another region, the inferencer cannot oblige\n-//! immediately since the values of that variables are not known.\n-//! Therefore, it creates a new variable that is related to the two\n-//! regions.  For example, the LUB of two variables `$x` and `$y` is a\n-//! fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-//! <= $z`.  So `V` will contain these intermediate variables as well.\n+//! To decide whether to replace a region `R` that appears in `T` with\n+//! a bound region, the algorithms make use of two bits of\n+//! information.  First is a set `V` that contains all region\n+//! variables created as part of the LUB/GLB computation (roughly; see\n+//! `region_vars_confined_to_snapshot()` for full details). `V` will\n+//! contain the region variables created to replace the bound regions\n+//! in the input types, but it also contains 'intermediate' variables\n+//! created to represent the LUB/GLB of individual regions.\n+//! Basically, when asked to compute the LUB/GLB of a region variable\n+//! with another region, the inferencer cannot oblige immediately\n+//! since the values of that variables are not known.  Therefore, it\n+//! creates a new variable that is related to the two regions.  For\n+//! example, the LUB of two variables `$x` and `$y` is a fresh\n+//! variable `$z` that is constrained such that `$x <= $z` and `$y <=\n+//! $z`.  So `V` will contain these intermediate variables as well.\n //!\n //! The other important factor in deciding how to replace a region in T is\n //! the function `Tainted($r)` which, for a region variable, identifies"}, {"sha": "0a2049bef48f2a97b14dd71cd76936fcd87e853c", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 228, "deletions": 135, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -11,14 +11,13 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{combine, cres, InferCtxt, HigherRankedType};\n+use super::{combine, CombinedSnapshot, cres, InferCtxt, HigherRankedType};\n use super::combine::Combine;\n-use super::region_inference::{RegionMark};\n \n use middle::ty::{mod, Ty, replace_late_bound_regions};\n use middle::ty_fold::{mod, HigherRankedFoldable, TypeFoldable};\n use syntax::codemap::Span;\n-use util::nodemap::FnvHashMap;\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::{bound_region_to_string, Repr};\n \n pub trait HigherRankedCombineable<'tcx>: HigherRankedFoldable<'tcx> +\n@@ -37,6 +36,14 @@ pub trait HigherRankedRelations<'tcx> {\n         where T : HigherRankedCombineable<'tcx>;\n }\n \n+trait InferCtxtExt<'tcx> {\n+    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region>;\n+\n+    fn region_vars_confined_to_snapshot(&self,\n+                                        snapshot: &CombinedSnapshot)\n+                                        -> Vec<ty::RegionVid>;\n+}\n+\n impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     where C : Combine<'tcx>\n {\n@@ -54,114 +61,115 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         // please see the large comment at the end of the file in the (inlined) module\n         // `doc`.\n \n-        // Make a mark so we can examine \"all bindings that were\n+        // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.infcx().region_vars.mark();\n-\n-        // First, we instantiate each bound region in the subtype with a fresh\n-        // region variable.\n-        let (a_prime, _) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                self.trace().origin.span(),\n-                HigherRankedType,\n-                a);\n-\n-        // Second, we instantiate each bound region in the supertype with a\n-        // fresh concrete region.\n-        let (b_prime, skol_map) = {\n-            replace_late_bound_regions(self.tcx(), b, |br, _| {\n-                let skol = self.infcx().region_vars.new_skolemized(br);\n-                debug!(\"Bound region {} skolemized to {}\",\n-                       bound_region_to_string(self.tcx(), \"\", false, br),\n-                       skol);\n-                skol\n-            })\n-        };\n-\n-        debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n-        debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n-\n-        // Compare types now that bound regions have been replaced.\n-        let result = try!(HigherRankedCombineable::super_combine(self, &a_prime, &b_prime));\n-\n-        // Presuming type comparison succeeds, we need to check\n-        // that the skolemized regions do not \"leak\".\n-        let new_vars =\n-            self.infcx().region_vars.vars_created_since_mark(mark);\n-        for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.infcx().region_vars.tainted(mark, skol);\n-            for tainted_region in tainted.iter() {\n-                // Each skolemized should only be relatable to itself\n-                // or new variables:\n-                match *tainted_region {\n-                    ty::ReInfer(ty::ReVar(ref vid)) => {\n-                        if new_vars.iter().any(|x| x == vid) { continue; }\n-                    }\n-                    _ => {\n-                        if *tainted_region == skol { continue; }\n+        return self.infcx().try(|snapshot| {\n+            // First, we instantiate each bound region in the subtype with a fresh\n+            // region variable.\n+            let (a_prime, _) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    self.trace().origin.span(),\n+                    HigherRankedType,\n+                    a);\n+\n+            // Second, we instantiate each bound region in the supertype with a\n+            // fresh concrete region.\n+            let (b_prime, skol_map) = {\n+                replace_late_bound_regions(self.tcx(), b, |br, _| {\n+                    let skol = self.infcx().region_vars.new_skolemized(br);\n+                    debug!(\"Bound region {} skolemized to {}\",\n+                           bound_region_to_string(self.tcx(), \"\", false, br),\n+                           skol);\n+                    skol\n+                })\n+            };\n+\n+            debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n+            debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+\n+            // Compare types now that bound regions have been replaced.\n+            let result = try!(HigherRankedCombineable::super_combine(self, &a_prime, &b_prime));\n+\n+            // Presuming type comparison succeeds, we need to check\n+            // that the skolemized regions do not \"leak\".\n+            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n+            for (&skol_br, &skol) in skol_map.iter() {\n+                let tainted = self.infcx().tainted_regions(snapshot, skol);\n+                for tainted_region in tainted.iter() {\n+                    // Each skolemized should only be relatable to itself\n+                    // or new variables:\n+                    match *tainted_region {\n+                        ty::ReInfer(ty::ReVar(ref vid)) => {\n+                            if new_vars.iter().any(|x| x == vid) { continue; }\n+                        }\n+                        _ => {\n+                            if *tainted_region == skol { continue; }\n+                        }\n+                    };\n+\n+                    // A is not as polymorphic as B:\n+                    if self.a_is_expected() {\n+                        debug!(\"Not as polymorphic!\");\n+                        return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n+                                                                               *tainted_region));\n+                    } else {\n+                        debug!(\"Overly polymorphic!\");\n+                        return Err(ty::terr_regions_overly_polymorphic(skol_br,\n+                                                                       *tainted_region));\n                     }\n-                };\n-\n-                // A is not as polymorphic as B:\n-                if self.a_is_expected() {\n-                    debug!(\"Not as polymorphic!\");\n-                    return Err(ty::terr_regions_insufficiently_polymorphic(\n-                        skol_br, *tainted_region));\n-                } else {\n-                    debug!(\"Overly polymorphic!\");\n-                    return Err(ty::terr_regions_overly_polymorphic(\n-                        skol_br, *tainted_region));\n                 }\n             }\n-        }\n \n-        debug!(\"higher_ranked_sub: OK result={}\",\n-               result.repr(self.tcx()));\n+            debug!(\"higher_ranked_sub: OK result={}\",\n+                   result.repr(self.tcx()));\n \n-        return Ok(result);\n+            Ok(result)\n+        });\n     }\n \n     fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n         where T : HigherRankedCombineable<'tcx>\n     {\n-        // Make a mark so we can examine \"all bindings that were\n+        // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.infcx().region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let span = self.trace().origin.span();\n-        let (a_with_fresh, a_map) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                span, HigherRankedType, a);\n-        let (b_with_fresh, _) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                span, HigherRankedType, b);\n-\n-        // Collect constraints.\n-        let result0 =\n-            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n-\n-        // Generalize the regions appearing in result0 if possible\n-        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n-        let span = self.trace().origin.span();\n-        let result1 =\n-            fold_regions_in(\n-                self.tcx(),\n-                &result0,\n-                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n-                                                new_vars.as_slice(), &a_map, r));\n-\n-        debug!(\"lub({},{}) = {}\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()),\n-               result1.repr(self.tcx()));\n-\n-        return Ok(result1);\n+        return self.infcx().try(|snapshot| {\n+            // Instantiate each bound region with a fresh region variable.\n+            let span = self.trace().origin.span();\n+            let (a_with_fresh, a_map) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    span, HigherRankedType, a);\n+            let (b_with_fresh, _) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    span, HigherRankedType, b);\n+\n+            // Collect constraints.\n+            let result0 =\n+                try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+            let result0 =\n+                self.infcx().resolve_type_vars_if_possible(&result0);\n+            debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n+\n+            // Generalize the regions appearing in result0 if possible\n+            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace().origin.span();\n+            let result1 =\n+                fold_regions_in(\n+                    self.tcx(),\n+                    &result0,\n+                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                                                    new_vars.as_slice(), &a_map, r));\n+\n+            debug!(\"lub({},{}) = {}\",\n+                   a.repr(self.tcx()),\n+                   b.repr(self.tcx()),\n+                   result1.repr(self.tcx()));\n+\n+            Ok(result1)\n+        });\n \n         fn generalize_region(infcx: &InferCtxt,\n                              span: Span,\n-                             mark: RegionMark,\n+                             snapshot: &CombinedSnapshot,\n                              debruijn: ty::DebruijnIndex,\n                              new_vars: &[ty::RegionVid],\n                              a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n@@ -174,7 +182,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 return r0;\n             }\n \n-            let tainted = infcx.region_vars.tainted(mark, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -215,47 +223,49 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         debug!(\"{}.higher_ranked_glb({}, {})\",\n                self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n \n-        // Make a mark so we can examine \"all bindings that were\n+        // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.infcx().region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_map) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                self.trace().origin.span(), HigherRankedType, a);\n-        let (b_with_fresh, b_map) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                self.trace().origin.span(), HigherRankedType, b);\n-        let a_vars = var_ids(self, &a_map);\n-        let b_vars = var_ids(self, &b_map);\n-\n-        // Collect constraints.\n-        let result0 =\n-            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n-\n-        // Generalize the regions appearing in fn_ty0 if possible\n-        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n-        let span = self.trace().origin.span();\n-        let result1 =\n-            fold_regions_in(\n-                self.tcx(),\n-                &result0,\n-                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n-                                                new_vars.as_slice(),\n-                                                &a_map, a_vars.as_slice(), b_vars.as_slice(),\n-                                                r));\n-\n-        debug!(\"glb({},{}) = {}\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()),\n-               result1.repr(self.tcx()));\n-\n-        return Ok(result1);\n+        return self.infcx().try(|snapshot| {\n+            // Instantiate each bound region with a fresh region variable.\n+            let (a_with_fresh, a_map) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    self.trace().origin.span(), HigherRankedType, a);\n+            let (b_with_fresh, b_map) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    self.trace().origin.span(), HigherRankedType, b);\n+            let a_vars = var_ids(self, &a_map);\n+            let b_vars = var_ids(self, &b_map);\n+\n+            // Collect constraints.\n+            let result0 =\n+                try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+            let result0 =\n+                self.infcx().resolve_type_vars_if_possible(&result0);\n+            debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n+\n+            // Generalize the regions appearing in fn_ty0 if possible\n+            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace().origin.span();\n+            let result1 =\n+                fold_regions_in(\n+                    self.tcx(),\n+                    &result0,\n+                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                                                    new_vars.as_slice(),\n+                                                    &a_map, a_vars.as_slice(), b_vars.as_slice(),\n+                                                    r));\n+\n+            debug!(\"glb({},{}) = {}\",\n+                   a.repr(self.tcx()),\n+                   b.repr(self.tcx()),\n+                   result1.repr(self.tcx()));\n+\n+            Ok(result1)\n+        });\n \n         fn generalize_region(infcx: &InferCtxt,\n                              span: Span,\n-                             mark: RegionMark,\n+                             snapshot: &CombinedSnapshot,\n                              debruijn: ty::DebruijnIndex,\n                              new_vars: &[ty::RegionVid],\n                              a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n@@ -267,7 +277,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 return r0;\n             }\n \n-            let tainted = infcx.region_vars.tainted(mark, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0);\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -443,3 +453,86 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>, value: &T, mut fldr: F) ->\n     }))\n }\n \n+impl<'a,'tcx> InferCtxtExt<'tcx> for InferCtxt<'a,'tcx> {\n+    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n+        self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n+    }\n+\n+    fn region_vars_confined_to_snapshot(&self,\n+                                        snapshot: &CombinedSnapshot)\n+                                        -> Vec<ty::RegionVid>\n+    {\n+        /*!\n+         * Returns the set of region variables that do not affect any\n+         * types/regions which existed before `snapshot` was\n+         * started. This is used in the sub/lub/glb computations. The\n+         * idea here is that when we are computing lub/glb of two\n+         * regions, we sometimes create intermediate region variables.\n+         * Those region variables may touch some of the skolemized or\n+         * other \"forbidden\" regions we created to replace bound\n+         * regions, but they don't really represent an \"external\"\n+         * constraint.\n+         *\n+         * However, sometimes fresh variables are created for other\n+         * purposes too, and those *may* represent an external\n+         * constraint. In particular, when a type variable is\n+         * instantiated, we create region variables for all the\n+         * regions that appear within, and if that type variable\n+         * pre-existed the snapshot, then those region variables\n+         * represent external constraints.\n+         *\n+         * An example appears in the unit test\n+         * `sub_free_bound_false_infer`.  In this test, we want to\n+         * know whether\n+         *\n+         * ```rust\n+         * fn(_#0t) <: for<'a> fn(&'a int)\n+         * ```\n+         *\n+         * Note that the subtype has a type variable. Because the type\n+         * variable can't be instantiated with a region that is bound\n+         * in the fn signature, this comparison ought to fail. But if\n+         * we're not careful, it will succeed.\n+         *\n+         * The reason is that when we walk through the subtyping\n+         * algorith, we begin by replacing `'a` with a skolemized\n+         * variable `'0`. We then have `fn(_#0t) <: fn(&'0 int)`. This\n+         * can be made true by unifying `_#0t` with `&'0 int`. In the\n+         * process, we create a fresh variable for the skolemized\n+         * region, `'$0`, and hence we have that `_#0t == &'$0\n+         * int`. However, because `'$0` was created during the sub\n+         * computation, if we're not careful we will erroneously\n+         * assume it is one of the transient region variables\n+         * representing a lub/glb internally. Not good.\n+         *\n+         * To prevent this, we check for type variables which were\n+         * unified during the snapshot, and say that any region\n+         * variable created during the snapshot but which finds its\n+         * way into a type variable is considered to \"escape\" the\n+         * snapshot.\n+         */\n+\n+        let mut region_vars =\n+            self.region_vars.vars_created_since_snapshot(&snapshot.region_vars_snapshot);\n+\n+        let escaping_types =\n+            self.type_variables.borrow().types_escaping_snapshot(&snapshot.type_snapshot);\n+\n+        let escaping_region_vars: FnvHashSet<_> =\n+            escaping_types\n+            .iter()\n+            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t).into_iter())\n+            .collect();\n+\n+        region_vars.retain(|&region_vid| {\n+            let r = ty::ReInfer(ty::ReVar(region_vid));\n+            !escaping_region_vars.contains(&r)\n+        });\n+\n+        debug!(\"region_vars_confined_to_snapshot: region_vars={} escaping_types={}\",\n+               region_vars.repr(self.tcx),\n+               escaping_types.repr(self.tcx));\n+\n+        region_vars\n+    }\n+}"}, {"sha": "4ad7af713bd2ca1c8503cd7e335fb863a80e2576", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -520,6 +520,7 @@ pub fn uok<'tcx>() -> ures<'tcx> {\n     Ok(())\n }\n \n+#[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot {\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n@@ -629,16 +630,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n         F: FnOnce() -> Result<T, E>\n     {\n-        self.commit_unconditionally(move || self.try(move || f()))\n+        self.commit_unconditionally(move || self.try(move |_| f()))\n     }\n \n     /// Execute `f`, unroll bindings on panic\n     pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n     {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n-        let r = f();\n+        let r = f(&snapshot);\n         debug!(\"try() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n             Ok(_) => {\n@@ -821,7 +822,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         ty_to_string(self.tcx,\n-                     self.resolve_type_vars_if_possible(t))\n+                     self.resolve_type_vars_if_possible(&t))\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -830,7 +831,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n-        let t = self.resolve_type_vars_in_trait_ref_if_possible(&**t);\n+        let t = self.resolve_type_vars_if_possible(&**t);\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n@@ -867,35 +868,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type_vars_if_possible(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match resolve_type(self,\n-                           None,\n-                           typ, resolve_nested_tvar | resolve_ivar) {\n-          Ok(new_type) => new_type,\n-          Err(_) => typ\n-        }\n-    }\n-\n-    pub fn resolve_type_vars_in_trait_ref_if_possible(&self,\n-                                                      trait_ref: &ty::TraitRef<'tcx>)\n-                                                      -> ty::TraitRef<'tcx> {\n-        // make up a dummy type just to reuse/abuse the resolve machinery\n-        let dummy0 = ty::mk_trait(self.tcx,\n-                                  (*trait_ref).clone(),\n-                                  ty::region_existential_bound(ty::ReStatic));\n-        let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n-        match dummy1.sty {\n-            ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n-                (*principal).clone()\n-            }\n-            _ => {\n-                self.tcx.sess.bug(\n-                    format!(\"resolve_type_vars_if_possible() yielded {} \\\n-                             when supplied with {}\",\n-                            self.ty_to_string(dummy0),\n-                            self.ty_to_string(dummy1)).as_slice());\n-            }\n-        }\n+    pub fn resolve_type_vars_if_possible<T:TypeFoldable<'tcx>>(&self, value: &T) -> T {\n+        let mut r = resolve::DeepTypeResolver::new(self);\n+        value.fold_with(&mut r)\n     }\n \n     // [Note-Type-error-reporting]\n@@ -929,9 +904,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let resolved_expected = expected_ty.map(|e_ty| {\n-            self.resolve_type_vars_if_possible(e_ty)\n-        });\n+        let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n         match resolved_expected {\n             Some(t) if ty::type_is_error(t) => (),\n@@ -958,7 +931,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  err: Option<&ty::type_err<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n-        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+        let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n         if ty::type_is_error(actual_ty) {"}, {"sha": "fef87c920679e5f8b89898e65096dd01e0ac66a6", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -81,7 +81,6 @@ impl Copy for TwoRegions {}\n pub enum UndoLogEntry {\n     OpenSnapshot,\n     CommitedSnapshot,\n-    Mark,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n     AddVerify(uint),\n@@ -225,19 +224,11 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n }\n \n #[deriving(Show)]\n+#[allow(missing_copy_implementations)]\n pub struct RegionSnapshot {\n     length: uint\n }\n \n-impl Copy for RegionSnapshot {}\n-\n-#[deriving(Show)]\n-pub struct RegionMark {\n-    length: uint\n-}\n-\n-impl Copy for RegionMark {}\n-\n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> RegionVarBindings<'a, 'tcx> {\n         RegionVarBindings {\n@@ -266,13 +257,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         RegionSnapshot { length: length }\n     }\n \n-    pub fn mark(&self) -> RegionMark {\n-        let length = self.undo_log.borrow().len();\n-        debug!(\"RegionVarBindings: mark({})\", length);\n-        self.undo_log.borrow_mut().push(Mark);\n-        RegionMark { length: length }\n-    }\n-\n     pub fn commit(&self, snapshot: RegionSnapshot) {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n@@ -296,7 +280,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 OpenSnapshot => {\n                     panic!(\"Failure to observe stack discipline\");\n                 }\n-                Mark | CommitedSnapshot => { }\n+                CommitedSnapshot => { }\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n@@ -597,8 +581,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         ReInfer(ReVar(c))\n     }\n \n-    pub fn vars_created_since_mark(&self, mark: RegionMark)\n-                                   -> Vec<RegionVid>\n+    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n+                                       -> Vec<RegionVid>\n     {\n         self.undo_log.borrow()\n             .slice_from(mark.length)\n@@ -613,7 +597,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// Computes all regions that have been related to `r0` in any way since the mark `mark` was\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n-    pub fn tainted(&self, mark: RegionMark, r0: Region) -> Vec<Region> {\n+    pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n         debug!(\"tainted(mark={}, r0={})\", mark, r0.repr(self.tcx));\n         let _indenter = indenter();\n \n@@ -668,7 +652,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         }\n                     }\n                     &AddCombination(..) |\n-                    &Mark |\n                     &AddVar(..) |\n                     &OpenSnapshot |\n                     &CommitedSnapshot => {"}, {"sha": "5edf78a474b6270d73261e480c9903c5470fc527", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -258,3 +258,38 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+/// DEEP TYPE RESOLVER\n+///\n+/// This kind of resolver can be used at any time. It simply replaces\n+/// type variables that have been unified with the things they have\n+/// been unified with (similar to `shallow_resolve`, but deep). This is\n+/// useful for printing messages etc but also required at various\n+/// points for correctness.\n+pub struct DeepTypeResolver<'a, 'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> DeepTypeResolver<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> DeepTypeResolver<'a, 'tcx> {\n+        DeepTypeResolver { infcx: infcx }\n+    }\n+}\n+\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for DeepTypeResolver<'a, 'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty::type_has_ty_infer(t) {\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+        } else {\n+            let t0 = self.infcx.shallow_resolve(t);\n+            ty_fold::super_fold_ty(self, t0)\n+        }\n+    }\n+}\n+\n+"}, {"sha": "0d7f542535c2f3ab4c585abf731b345c3a7c369d", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -13,7 +13,9 @@ use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n \n use middle::ty::{mod, Ty};\n+use std::cmp::min;\n use std::mem;\n+use std::uint;\n use util::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n@@ -78,7 +80,6 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n-\n         if a != b {\n             self.relations(a).push((dir, b));\n             self.relations(b).push((dir.opposite(), a));\n@@ -151,6 +152,49 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn commit(&mut self, s: Snapshot) {\n         self.values.commit(s.snapshot);\n     }\n+\n+    pub fn types_escaping_snapshot(&self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n+        /*!\n+         * Find the set of type variables that existed *before* `s`\n+         * but which have only been unified since `s` started, and\n+         * return the types with which they were unified. So if we had\n+         * a type variable `V0`, then we started the snapshot, then we\n+         * created a type variable `V1`, unifed `V0` with `T0`, and\n+         * unified `V1` with `T1`, this function would return `{T0}`.\n+         */\n+\n+        let mut new_elem_threshold = uint::MAX;\n+        let mut escaping_types = Vec::new();\n+        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n+        for action in actions_since_snapshot.iter() {\n+            match *action {\n+                sv::UndoLog::NewElem(index) => {\n+                    // if any new variables were created during the\n+                    // snapshot, remember the lower index (which will\n+                    // always be the first one we see). Note that this\n+                    // action must precede those variables being\n+                    // specified.\n+                    new_elem_threshold = min(new_elem_threshold, index);\n+                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n+                }\n+\n+                sv::UndoLog::Other(SpecifyVar(vid, _)) => {\n+                    if vid.index < new_elem_threshold {\n+                        // quick check to see if this variable was\n+                        // created since the snapshot started or not.\n+                        let escaping_type = self.probe(vid).unwrap();\n+                        escaping_types.push(escaping_type);\n+                    }\n+                    debug!(\"SpecifyVar({}) new_elem_threshold={}\", vid, new_elem_threshold);\n+                }\n+\n+                _ => { }\n+            }\n+        }\n+\n+        escaping_types\n+    }\n }\n \n impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {"}, {"sha": "3da9fba0ee89d8b4d2152339f5ed86785996da10", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -790,6 +790,17 @@ impl<'a, 'tcx, F> RegionFolder<'a, 'tcx, F> where F: FnMut(ty::Region, uint) ->\n     }\n }\n \n+pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> Vec<ty::Region>\n+    where T : TypeFoldable<'tcx>\n+{\n+    let mut vec = Vec::new();\n+    {\n+        let mut folder = RegionFolder::new(tcx, |r, _| { vec.push(r); r });\n+        value.fold_with(&mut folder);\n+    }\n+    vec\n+}\n+\n impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n     F: FnMut(ty::Region, uint) -> ty::Region,\n {"}, {"sha": "749c39d7a6b92219591dac776430ff97d6686bb9", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -23,7 +23,7 @@ use self::UndoLog::*;\n use std::mem;\n \n #[deriving(PartialEq)]\n-enum UndoLog<T,U> {\n+pub enum UndoLog<T,U> {\n     /// Indicates where a snapshot started.\n     OpenSnapshot,\n \n@@ -113,6 +113,12 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         Snapshot { length: length }\n     }\n \n+    pub fn actions_since_snapshot(&self,\n+                                  snapshot: &Snapshot)\n+                                  -> &[UndoLog<T,U>] {\n+        self.undo_log[snapshot.length..]\n+    }\n+\n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n         // Or else there was a failure to follow a stack discipline:\n         assert!(self.undo_log.len() > snapshot.length);"}, {"sha": "14d36432afaa8df6f5025976a01de220bf76ca89", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -502,6 +502,26 @@ fn sub_free_bound_false_infer() {\n     })\n }\n \n+#[test]\n+fn lub_free_bound_infer() {\n+    //! Test result of:\n+    //!\n+    //!     LUB(fn(_#1), for<'b> fn(&'b int))\n+    //!\n+    //! This should yield `fn(&'_ int)`. We check\n+    //! that it yields `fn(&'x int)` for some free `'x`,\n+    //! anyhow.\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_infer1 = env.infcx.next_ty_var();\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.check_lub(env.t_fn(&[t_infer1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+    });\n+}\n+\n #[test]\n fn lub_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n@@ -605,6 +625,28 @@ fn glb_bound_free() {\n     })\n }\n \n+#[test]\n+fn glb_bound_free_infer() {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_infer1 = env.infcx.next_ty_var();\n+\n+        // compute GLB(fn(_) -> int, for<'b> fn(&'b int) -> int),\n+        // which should yield for<'b> fn(&'b int) -> int\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_infer1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+\n+        // as a side-effect, computing GLB should unify `_` with\n+        // `&'_ int`\n+        let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n+        match t_resolve1.sty {\n+            ty::ty_rptr(..) => { }\n+            _ => { panic!(\"t_resolve1={}\", t_resolve1.repr(env.infcx.tcx)); }\n+        }\n+    })\n+}\n+\n #[test]\n fn glb_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {"}, {"sha": "a4fee8573c592af18ce48902022bc8dbc4b5610e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -196,7 +196,7 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     debug!(\"found object type {}\", kind);\n \n     let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n-    let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(arg_param_ty);\n+    let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n     debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n     let input_tys = match arg_param_ty.sty {\n@@ -206,7 +206,7 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n     let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n-    let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(ret_param_ty);\n+    let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n     let fn_sig = ty::FnSig {"}, {"sha": "ac7bc81b2f874cafa3e3f61fa888ed30d80bf79f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -100,7 +100,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n-    let self_ty = fcx.infcx().resolve_type_vars_if_possible(self_ty);\n+    let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n     let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }"}, {"sha": "ea33153f3b1af6dbefa0368b1c86be199c9d7158", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -1638,7 +1638,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn default_diverging_type_variables_to_nil(&self) {\n         for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n-            if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(*ty)) {\n+            if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(ty)) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n             }\n         }\n@@ -2486,7 +2486,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let method_type = match method {\n         Some(ref method) => method.ty,\n         None => {\n-            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(expr_type);\n+            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(&expr_type);\n \n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n@@ -3976,7 +3976,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         vtable::select_new_fcx_obligations(fcx);\n \n         debug!(\"ExprForLoop each item has type {}\",\n-               fcx.infcx().resolve_type_vars_if_possible(typ).repr(fcx.tcx()));\n+               fcx.infcx().resolve_type_vars_if_possible(&typ).repr(fcx.tcx()));\n \n         let pcx = pat_ctxt {\n             fcx: fcx,\n@@ -4371,11 +4371,11 @@ impl<'tcx> Expectation<'tcx> {\n             }\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(\n-                    fcx.infcx().resolve_type_vars_if_possible(t))\n+                    fcx.infcx().resolve_type_vars_if_possible(&t))\n             }\n             ExpectHasType(t) => {\n                 ExpectHasType(\n-                    fcx.infcx().resolve_type_vars_if_possible(t))\n+                    fcx.infcx().resolve_type_vars_if_possible(&t))\n             }\n         }\n     }"}, {"sha": "664705c89ab2a2c89c9cb48eb13fd6e16a3bad9d", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -331,7 +331,7 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             match obligation.trait_ref {\n                 ty::Predicate::Trait(ref trait_ref) => {\n                     let trait_ref =\n-                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref);\n+                        fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n                     fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n                         format!(\n@@ -341,8 +341,8 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n \n                 ty::Predicate::Equate(a, b) => {\n-                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n-                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n+                    let a = fcx.infcx().resolve_type_vars_if_possible(&a);\n+                    let b = fcx.infcx().resolve_type_vars_if_possible(&b);\n                     fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n                         format!(\n@@ -373,8 +373,7 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             match obligation.trait_ref {\n                 ty::Predicate::Trait(ref trait_ref) => {\n                     let trait_ref =\n-                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n-                            &**trait_ref);\n+                        fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n                     if !ty::type_is_error(trait_ref.self_ty()) {\n                         fcx.tcx().sess.span_err(\n                             obligation.cause.span,\n@@ -387,8 +386,8 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n \n                 ty::Predicate::Equate(a, b) => {\n-                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n-                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n+                    let a = fcx.infcx().resolve_type_vars_if_possible(&a);\n+                    let b = fcx.infcx().resolve_type_vars_if_possible(&b);\n                     let err = infer::can_mk_eqty(fcx.infcx(), a, b).unwrap_err();\n                     fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n@@ -413,10 +412,10 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref =\n-                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                fcx.infcx().resolve_type_vars_if_possible(\n                     &**expected_trait_ref);\n             let actual_trait_ref =\n-                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                fcx.infcx().resolve_type_vars_if_possible(\n                     &**actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n                 fcx.tcx().sess.span_err(\n@@ -443,7 +442,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let trait_ref = match obligation.trait_ref {\n         ty::Predicate::Trait(ref trait_ref) => {\n-            fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref)\n+            fcx.infcx().resolve_type_vars_if_possible(&**trait_ref)\n         }\n         _ => {\n             fcx.tcx().sess.span_bug("}, {"sha": "728b577df1dd4a3e2a3ecb6ee7c85c055220ca8d", "filename": "src/test/compile-fail/bad-match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Ftest%2Fcompile-fail%2Fbad-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3efc9d2c55af6e58dd96c5814260bacc2b582ef3/src%2Ftest%2Fcompile-fail%2Fbad-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-match.rs?ref=3efc9d2c55af6e58dd96c5814260bacc2b582ef3", "patch": "@@ -14,3 +14,6 @@ fn main() {\n   let int x = 5;\n   match x;\n }\n+\n+fn main() {\n+}"}]}