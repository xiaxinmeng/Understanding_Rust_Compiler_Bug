{"sha": "8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg0MzdkN2MwZjEzYTFlYmI0Y2IxNGQ3MTc0YjExYjQ0YTFhNDU2OTU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-12T00:55:49Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:56Z"}, "message": "rustc: extend the niche-filling enum optimization past 2 variants.", "tree": {"sha": "077d9299e1a17a900bd15a85d7b9e639a5b894ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/077d9299e1a17a900bd15a85d7b9e639a5b894ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "html_url": "https://github.com/rust-lang/rust/commit/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d893285b657b39bc9703270179a50e3562dd38e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d893285b657b39bc9703270179a50e3562dd38e8", "html_url": "https://github.com/rust-lang/rust/commit/d893285b657b39bc9703270179a50e3562dd38e8"}], "stats": {"total": 330, "additions": 210, "deletions": 120}, "files": [{"sha": "c1ce6143d109a479ec30afe1ab550c0cb917110f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 129, "deletions": 102, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "patch": "@@ -805,19 +805,19 @@ pub enum Variants {\n         variants: Vec<CachedLayout>,\n     },\n \n-    /// Two cases distinguished by a niche (a value invalid for a type):\n+    /// Multiple cases distinguished by a niche (values invalid for a type):\n     /// the variant `dataful_variant` contains a niche at an arbitrary\n-    /// offset (field 0 of the enum), which is set to `niche_value`\n-    /// for the other variant.\n+    /// offset (field 0 of the enum), which for a variant with discriminant\n+    /// `d` is set to `(d - niche_variants.start).wrapping_add(niche_start)`.\n     ///\n     /// For example, `Option<(usize, &T)>`  is represented such that\n     /// `None` has a null pointer for the second tuple field, and\n     /// `Some` is the identity function (with a non-null reference).\n     NicheFilling {\n         dataful_variant: usize,\n-        niche_variant: usize,\n+        niche_variants: RangeInclusive<usize>,\n         niche: Scalar,\n-        niche_value: u128,\n+        niche_start: u128,\n         variants: Vec<CachedLayout>,\n     }\n }\n@@ -1372,11 +1372,11 @@ impl<'a, 'tcx> CachedLayout {\n                     }).collect::<Result<Vec<_>, _>>()\n                 }).collect::<Result<Vec<_>, _>>()?;\n \n-                let (inh_first, inh_second, inh_third) = {\n+                let (inh_first, inh_second) = {\n                     let mut inh_variants = (0..variants.len()).filter(|&v| {\n                         variants[v].iter().all(|f| f.abi != Abi::Uninhabited)\n                     });\n-                    (inh_variants.next(), inh_variants.next(), inh_variants.next())\n+                    (inh_variants.next(), inh_variants.next())\n                 };\n                 if inh_first.is_none() {\n                     // Uninhabited because it has no variants, or only uninhabited ones.\n@@ -1472,68 +1472,94 @@ impl<'a, 'tcx> CachedLayout {\n                 let no_explicit_discriminants = def.variants.iter().enumerate()\n                     .all(|(i, v)| v.discr == ty::VariantDiscr::Relative(i));\n \n-                if inh_second.is_some() && inh_third.is_none() &&\n-                   !def.repr.inhibit_enum_layout_opt() &&\n-                   no_explicit_discriminants {\n-                    // Nullable pointer optimization\n-                    let (a, b) = (inh_first.unwrap(), inh_second.unwrap());\n-                    for &(i, other) in &[(a, b), (b, a)] {\n-                        if !variants[other].iter().all(|f| f.is_zst()) {\n-                            continue;\n+                // Niche-filling enum optimization.\n+                if !def.repr.inhibit_enum_layout_opt() && no_explicit_discriminants {\n+                    let mut dataful_variant = None;\n+                    let mut niche_variants = usize::max_value()..=0;\n+\n+                    // Find one non-ZST variant.\n+                    'variants: for (v, fields) in variants.iter().enumerate() {\n+                        for f in fields {\n+                            if f.abi == Abi::Uninhabited {\n+                                continue 'variants;\n+                            }\n+                            if !f.is_zst() {\n+                                if dataful_variant.is_none() {\n+                                    dataful_variant = Some(v);\n+                                    continue 'variants;\n+                                } else {\n+                                    dataful_variant = None;\n+                                    break 'variants;\n+                                }\n+                            }\n+                        }\n+                        if niche_variants.start > v {\n+                            niche_variants.start = v;\n                         }\n+                        niche_variants.end = v;\n+                    }\n+\n+                    if niche_variants.start > niche_variants.end {\n+                        dataful_variant = None;\n+                    }\n \n+                    if let Some(i) = dataful_variant {\n+                        let count = (niche_variants.end - niche_variants.start + 1) as u128;\n                         for (field_index, field) in variants[i].iter().enumerate() {\n-                            if let Some((offset, niche, niche_value)) = field.find_niche(cx)? {\n-                                let st = variants.iter().enumerate().map(|(j, v)| {\n-                                    let mut st = univariant_uninterned(v,\n-                                        &def.repr, StructKind::AlwaysSized)?;\n-                                    st.variants = Variants::Single { index: j };\n-                                    Ok(st)\n-                                }).collect::<Result<Vec<_>, _>>()?;\n-\n-                                let offset = st[i].fields.offset(field_index) + offset;\n-                                let CachedLayout {\n-                                    size,\n-                                    mut align,\n-                                    mut primitive_align,\n-                                    ..\n-                                } = st[i];\n-\n-                                let mut niche_align = niche.value.align(dl);\n-                                let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n-                                    Abi::Scalar(niche.clone())\n-                                } else {\n-                                    let mut packed = st[i].abi.is_packed();\n-                                    if offset.abi_align(niche_align) != offset {\n-                                        packed = true;\n-                                        niche_align = dl.i8_align;\n-                                    }\n-                                    Abi::Aggregate {\n-                                       sized: true,\n-                                       packed\n-                                    }\n+                            let (offset, niche, niche_start) =\n+                                match field.find_niche(cx, count)? {\n+                                    Some(niche) => niche,\n+                                    None => continue\n                                 };\n-                                align = align.max(niche_align);\n-                                primitive_align = primitive_align.max(niche_align);\n-\n-                                return Ok(tcx.intern_layout(CachedLayout {\n-                                    variants: Variants::NicheFilling {\n-                                        dataful_variant: i,\n-                                        niche_variant: other,\n-                                        niche,\n-                                        niche_value,\n-                                        variants: st,\n-                                    },\n-                                    fields: FieldPlacement::Arbitrary {\n-                                        offsets: vec![offset],\n-                                        memory_index: vec![0]\n-                                    },\n-                                    abi,\n-                                    size,\n-                                    align,\n-                                    primitive_align\n-                                }));\n-                            }\n+                            let st = variants.iter().enumerate().map(|(j, v)| {\n+                                let mut st = univariant_uninterned(v,\n+                                    &def.repr, StructKind::AlwaysSized)?;\n+                                st.variants = Variants::Single { index: j };\n+                                Ok(st)\n+                            }).collect::<Result<Vec<_>, _>>()?;\n+\n+                            let offset = st[i].fields.offset(field_index) + offset;\n+                            let CachedLayout {\n+                                size,\n+                                mut align,\n+                                mut primitive_align,\n+                                ..\n+                            } = st[i];\n+\n+                            let mut niche_align = niche.value.align(dl);\n+                            let abi = if offset.bytes() == 0 && niche.value.size(dl) == size {\n+                                Abi::Scalar(niche.clone())\n+                            } else {\n+                                let mut packed = st[i].abi.is_packed();\n+                                if offset.abi_align(niche_align) != offset {\n+                                    packed = true;\n+                                    niche_align = dl.i8_align;\n+                                }\n+                                Abi::Aggregate {\n+                                    sized: true,\n+                                    packed\n+                                }\n+                            };\n+                            align = align.max(niche_align);\n+                            primitive_align = primitive_align.max(niche_align);\n+\n+                            return Ok(tcx.intern_layout(CachedLayout {\n+                                variants: Variants::NicheFilling {\n+                                    dataful_variant: i,\n+                                    niche_variants,\n+                                    niche,\n+                                    niche_start,\n+                                    variants: st,\n+                                },\n+                                fields: FieldPlacement::Arbitrary {\n+                                    offsets: vec![offset],\n+                                    memory_index: vec![0]\n+                                },\n+                                abi,\n+                                size,\n+                                align,\n+                                primitive_align\n+                            }));\n                         }\n                     }\n                 }\n@@ -2267,50 +2293,50 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n \n     /// Find the offset of a niche leaf field, starting from\n-    /// the given type and recursing through aggregates.\n+    /// the given type and recursing through aggregates, which\n+    /// has at least `count` consecutive invalid values.\n     /// The tuple is `(offset, scalar, niche_value)`.\n     // FIXME(eddyb) traverse already optimized enums.\n-    fn find_niche<C>(&self, cx: C)\n+    fn find_niche<C>(&self, cx: C, count: u128)\n         -> Result<Option<(Size, Scalar, u128)>, LayoutError<'tcx>>\n         where C: LayoutOf<Ty<'tcx>, TyLayout = Result<Self, LayoutError<'tcx>>> +\n                  HasTyCtxt<'tcx>\n     {\n         let scalar_component = |scalar: &Scalar, offset| {\n-            // FIXME(eddyb) support negative/wrap-around discriminant ranges.\n-            let Scalar { value, ref valid_range } = *scalar;\n-            if valid_range.start < valid_range.end {\n-                let bits = value.size(cx).bits();\n-                assert!(bits <= 128);\n-                let max_value = !0u128 >> (128 - bits);\n-                if valid_range.start > 0 {\n-                    let niche = valid_range.start - 1;\n-                    Ok(Some((offset, Scalar {\n-                        value,\n-                        valid_range: niche..=valid_range.end\n-                    }, niche)))\n-                } else if valid_range.end < max_value {\n-                    let niche = valid_range.end + 1;\n-                    Ok(Some((offset, Scalar {\n-                        value,\n-                        valid_range: valid_range.start..=niche\n-                    }, niche)))\n-                } else {\n-                    Ok(None)\n-                }\n+            let Scalar { value, valid_range: ref v } = *scalar;\n+\n+            let bits = value.size(cx).bits();\n+            assert!(bits <= 128);\n+            let max_value = !0u128 >> (128 - bits);\n+\n+            // Find out how many values are outside the valid range.\n+            let niches = if v.start <= v.end {\n+                v.start + (max_value - v.end)\n             } else {\n-                Ok(None)\n+                v.start - v.end - 1\n+            };\n+\n+            // Give up if we can't fit `count` consecutive niches.\n+            if count > niches {\n+                return None;\n             }\n+\n+            let niche_start = v.end.wrapping_add(1) & max_value;\n+            let niche_end = v.end.wrapping_add(count) & max_value;\n+            Some((offset, Scalar {\n+                value,\n+                valid_range: v.start..=niche_end\n+            }, niche_start))\n         };\n \n         match self.abi {\n             Abi::Scalar(ref scalar) => {\n-                return scalar_component(scalar, Size::from_bytes(0));\n+                return Ok(scalar_component(scalar, Size::from_bytes(0)));\n             }\n             Abi::ScalarPair(ref a, ref b) => {\n-                if let Some(result) = scalar_component(a, Size::from_bytes(0))? {\n-                    return Ok(Some(result));\n-                }\n-                return scalar_component(b, a.value.size(cx).abi_align(b.value.align(cx)));\n+                return Ok(scalar_component(a, Size::from_bytes(0)).or_else(|| {\n+                    scalar_component(b, a.value.size(cx).abi_align(b.value.align(cx)))\n+                }));\n             }\n             _ => {}\n         }\n@@ -2323,13 +2349,13 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                 return Ok(None);\n             }\n         }\n-        if let FieldPlacement::Array { count, .. } = self.fields {\n-            if count > 0 {\n-                return self.field(cx, 0)?.find_niche(cx);\n+        if let FieldPlacement::Array { .. } = self.fields {\n+            if self.fields.count() > 0 {\n+                return self.field(cx, 0)?.find_niche(cx, count);\n             }\n         }\n         for i in 0..self.fields.count() {\n-            let r = self.field(cx, i)?.find_niche(cx)?;\n+            let r = self.field(cx, i)?.find_niche(cx, count)?;\n             if let Some((offset, scalar, niche_value)) = r {\n                 let offset = self.fields.offset(i) + offset;\n                 return Ok(Some((offset, scalar, niche_value)));\n@@ -2359,15 +2385,16 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n             }\n             NicheFilling {\n                 dataful_variant,\n-                niche_variant,\n+                niche_variants: RangeInclusive { start, end },\n                 ref niche,\n-                niche_value,\n+                niche_start,\n                 ref variants,\n             } => {\n                 dataful_variant.hash_stable(hcx, hasher);\n-                niche_variant.hash_stable(hcx, hasher);\n+                start.hash_stable(hcx, hasher);\n+                end.hash_stable(hcx, hasher);\n                 niche.hash_stable(hcx, hasher);\n-                niche_value.hash_stable(hcx, hasher);\n+                niche_start.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n             }\n         }"}, {"sha": "b2ad538a8ab290f9f1e84bede3f02ccf99e18e11", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "patch": "@@ -1186,7 +1186,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 }).collect()\n             }\n-            layout::Variants::NicheFilling { dataful_variant, niche_variant, .. } => {\n+            layout::Variants::NicheFilling { dataful_variant, ref niche_variants, .. } => {\n                 let variant = self.layout.for_variant(cx, dataful_variant);\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, member_description_factory) =\n@@ -1209,6 +1209,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n                 // HACK(eddyb) the debuggers should just handle offset+size\n                 // of discriminant instead of us having to recover its path.\n+                // Right now it's not even going to work for `niche_start > 0`,\n+                // and for multiple niche variants it only supports the first.\n                 fn compute_field_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 name: &mut String,\n                                                 layout: TyLayout<'tcx>,\n@@ -1231,7 +1233,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                    self.layout,\n                                    self.layout.fields.offset(0),\n                                    self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[niche_variant].name.as_str());\n+                name.push_str(&adt.variants[niche_variants.start].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec!["}, {"sha": "8c013330e5bcb506dd792ee1103612da777f2adc", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "patch": "@@ -1163,12 +1163,19 @@ fn trans_const_adt<'a, 'tcx>(\n                 build_const_struct(ccx, l.for_variant(ccx, variant_index), vals, Some(discr))\n             }\n         }\n-        layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n+        layout::Variants::NicheFilling {\n+            dataful_variant,\n+            ref niche_variants,\n+            niche_start,\n+            ..\n+        } => {\n             if variant_index == dataful_variant {\n                 build_const_struct(ccx, l.for_variant(ccx, dataful_variant), vals, None)\n             } else {\n                 let niche = l.field(ccx, 0);\n                 let niche_llty = niche.llvm_type(ccx);\n+                let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    .wrapping_add(niche_start);\n                 // FIXME(eddyb) Check the actual primitive type here.\n                 let niche_llval = if niche_value == 0 {\n                     // HACK(eddyb) Using `C_null` as it works on all types."}, {"sha": "6478bd2c8488052a470a6a8742841cf62dd43d15", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "patch": "@@ -328,21 +328,31 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n-                niche_variant,\n-                niche_value,\n+                ref niche_variants,\n+                niche_start,\n                 ..\n             } => {\n-                let niche_llty = discr.layout.llvm_type(bcx.ccx);\n-                // FIXME(eddyb) Check the actual primitive type here.\n-                let niche_llval = if niche_value == 0 {\n-                    // HACK(eddyb) Using `C_null` as it works on all types.\n-                    C_null(niche_llty)\n+                let niche_llty = discr.layout.immediate_llvm_type(bcx.ccx);\n+                if niche_variants.start == niche_variants.end {\n+                    // FIXME(eddyb) Check the actual primitive type here.\n+                    let niche_llval = if niche_start == 0 {\n+                        // HACK(eddyb) Using `C_null` as it works on all types.\n+                        C_null(niche_llty)\n+                    } else {\n+                        C_uint_big(niche_llty, niche_start)\n+                    };\n+                    bcx.select(bcx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n+                        C_uint(cast_to, niche_variants.start as u64),\n+                        C_uint(cast_to, dataful_variant as u64))\n                 } else {\n-                    C_uint_big(niche_llty, niche_value)\n-                };\n-                bcx.select(bcx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n-                    C_uint(cast_to, niche_variant as u64),\n-                    C_uint(cast_to, dataful_variant as u64))\n+                    // Rebase from niche values to discriminant values.\n+                    let delta = niche_start.wrapping_sub(niche_variants.start as u128);\n+                    let lldiscr = bcx.sub(lldiscr, C_uint_big(niche_llty, delta));\n+                    let lldiscr_max = C_uint(niche_llty, niche_variants.end as u64);\n+                    bcx.select(bcx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n+                        bcx.intcast(lldiscr, cast_to, false),\n+                        C_uint(cast_to, dataful_variant as u64))\n+                }\n             }\n         }\n     }\n@@ -367,7 +377,12 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n-            layout::Variants::NicheFilling { dataful_variant, niche_value, .. } => {\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n+            } => {\n                 if variant_index != dataful_variant {\n                     if bcx.sess().target.target.arch == \"arm\" ||\n                        bcx.sess().target.target.arch == \"aarch64\" {\n@@ -382,15 +397,17 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                     }\n \n                     let niche = self.project_field(bcx, 0);\n-                    let niche_llty = niche.layout.llvm_type(bcx.ccx);\n+                    let niche_llty = niche.layout.immediate_llvm_type(bcx.ccx);\n+                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                        .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n                         // HACK(eddyb) Using `C_null` as it works on all types.\n                         C_null(niche_llty)\n                     } else {\n                         C_uint_big(niche_llty, niche_value)\n                     };\n-                    bcx.store(niche_llval, niche.llval, niche.alignment.non_abi());\n+                    OperandValue::Immediate(niche_llval).store(bcx, niche);\n                 }\n             }\n         }"}, {"sha": "f1c419d889556968346229911c65297faa26c34e", "filename": "src/test/ui/print_type_sizes/niche-filling.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.rs?ref=8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "patch": "@@ -68,6 +68,13 @@ impl One for u32 {\n     fn one() -> Self { 1 }\n }\n \n+pub enum Enum4<A, B, C, D> {\n+    One(A),\n+    Two(B),\n+    Three(C),\n+    Four(D)\n+}\n+\n pub fn main() {\n     let _x: MyOption<NonZero<u32>> = Default::default();\n     let _y: EmbeddedDiscr = Default::default();\n@@ -76,4 +83,7 @@ pub fn main() {\n     let _b: MyOption<char> = Default::default();\n     let _c: MyOption<std::cmp::Ordering> = Default::default();\n     let _b: MyOption<MyOption<u8>> = Default::default();\n+    let _e: Enum4<(), char, (), ()> = Enum4::One(());\n+    let _f: Enum4<(), (), bool, ()> = Enum4::One(());\n+    let _g: Enum4<(), (), (), MyOption<u8>> = Enum4::One(());\n }"}, {"sha": "af3e89a936ee05cc85b4a41823fa8b0668e286cf", "filename": "src/test/ui/print_type_sizes/niche-filling.stdout", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8437d7c0f13a1ebb4cb14d7174b11b44a1a45695/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fniche-filling.stdout?ref=8437d7c0f13a1ebb4cb14d7174b11b44a1a45695", "patch": "@@ -19,6 +19,15 @@ print-type-size     field `.val`: 4 bytes\n print-type-size     field `.post`: 2 bytes\n print-type-size     field `.pre`: 1 bytes\n print-type-size     end padding: 1 bytes\n+print-type-size type: `Enum4<(), char, (), ()>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `One`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Two`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size     variant `Three`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Four`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n print-type-size type: `MyOption<char>`: 4 bytes, alignment: 4 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 4 bytes\n@@ -29,6 +38,15 @@ print-type-size     variant `Some`: 4 bytes\n print-type-size         field `.0`: 4 bytes\n print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n print-type-size     field `.0`: 4 bytes\n+print-type-size type: `Enum4<(), (), (), MyOption<u8>>`: 2 bytes, alignment: 1 bytes\n+print-type-size     variant `One`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Two`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Three`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Four`: 2 bytes\n+print-type-size         field `.0`: 2 bytes\n print-type-size type: `MyOption<MyOption<u8>>`: 2 bytes, alignment: 1 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 2 bytes\n@@ -38,6 +56,15 @@ print-type-size     discriminant: 1 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 1 bytes\n print-type-size         field `.0`: 1 bytes\n+print-type-size type: `Enum4<(), (), bool, ()>`: 1 bytes, alignment: 1 bytes\n+print-type-size     variant `One`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Two`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n+print-type-size     variant `Three`: 1 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size     variant `Four`: 0 bytes\n+print-type-size         field `.0`: 0 bytes\n print-type-size type: `MyOption<bool>`: 1 bytes, alignment: 1 bytes\n print-type-size     variant `None`: 0 bytes\n print-type-size     variant `Some`: 1 bytes"}]}