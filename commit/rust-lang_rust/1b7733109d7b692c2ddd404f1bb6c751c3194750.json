{"sha": "1b7733109d7b692c2ddd404f1bb6c751c3194750", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiNzczMzEwOWQ3YjY5MmMyZGRkNDA0ZjFiYjZjNzUxYzMxOTQ3NTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-01-31T22:01:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-02-10T00:23:10Z"}, "message": "std: Stop parameterizing some memcpy functions over RawPtr\n\nIt unsafe assumptions that any impl of RawPtr is for actual pointers,\nthat they can be copied by memcpy. Removing it is easy, so I don't\nthink it's solving a real problem.", "tree": {"sha": "1cc915a223e2de4c45c2fa32c31b0d62eee08eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1cc915a223e2de4c45c2fa32c31b0d62eee08eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b7733109d7b692c2ddd404f1bb6c751c3194750", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b7733109d7b692c2ddd404f1bb6c751c3194750", "html_url": "https://github.com/rust-lang/rust/commit/1b7733109d7b692c2ddd404f1bb6c751c3194750", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b7733109d7b692c2ddd404f1bb6c751c3194750/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27f9c7951fb30b299341668f16a6f84169e1379e", "url": "https://api.github.com/repos/rust-lang/rust/commits/27f9c7951fb30b299341668f16a6f84169e1379e", "html_url": "https://github.com/rust-lang/rust/commit/27f9c7951fb30b299341668f16a6f84169e1379e"}], "stats": {"total": 45, "additions": 22, "deletions": 23}, "files": [{"sha": "ffdd70a6c144a6f0e300048d7f872ccd3a5ff085", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=1b7733109d7b692c2ddd404f1bb6c751c3194750", "patch": "@@ -10,7 +10,6 @@\n \n //! Unsafe casting functions\n \n-use ptr::RawPtr;\n use mem;\n use unstable::intrinsics;\n use ptr::copy_nonoverlapping_memory;\n@@ -72,13 +71,13 @@ pub unsafe fn transmute_region<'a,'b,T>(ptr: &'a T) -> &'b T {\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_mut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *mut T {\n+pub unsafe fn transmute_mut_unsafe<T>(ptr: *T) -> *mut T {\n     transmute(ptr)\n }\n \n /// Coerce an immutable reference to be mutable.\n #[inline]\n-pub unsafe fn transmute_immut_unsafe<T,P:RawPtr<T>>(ptr: P) -> *T {\n+pub unsafe fn transmute_immut_unsafe<T>(ptr: *mut T) -> *T {\n     transmute(ptr)\n }\n "}, {"sha": "484f81f277f21377d3dcb640cc9f8e786739a49b", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=1b7733109d7b692c2ddd404f1bb6c751c3194750", "patch": "@@ -92,8 +92,8 @@ pub fn is_not_null<T,P:RawPtr<T>>(ptr: P) -> bool { ptr.is_not_null() }\n  * and destination may overlap.\n  */\n #[inline]\n-pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n-    intrinsics::copy_memory(dst, cast::transmute_immut_unsafe(src), count)\n+pub unsafe fn copy_memory<T>(dst: *mut T, src: *T, count: uint) {\n+    intrinsics::copy_memory(dst, src, count)\n }\n \n /**\n@@ -103,10 +103,10 @@ pub unsafe fn copy_memory<T,P:RawPtr<T>>(dst: *mut T, src: P, count: uint) {\n  * and destination may *not* overlap.\n  */\n #[inline]\n-pub unsafe fn copy_nonoverlapping_memory<T,P:RawPtr<T>>(dst: *mut T,\n-                                                        src: P,\n-                                                        count: uint) {\n-    intrinsics::copy_nonoverlapping_memory(dst, cast::transmute_immut_unsafe(src), count)\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n+                                            src: *T,\n+                                            count: uint) {\n+    intrinsics::copy_nonoverlapping_memory(dst, src, count)\n }\n \n /**\n@@ -137,9 +137,9 @@ pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n     let t: *mut T = &mut tmp;\n \n     // Perform the swap\n-    copy_nonoverlapping_memory(t, x, 1);\n-    copy_memory(x, y, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping_memory(y, t, 1);\n+    copy_nonoverlapping_memory(t, &*x, 1);\n+    copy_memory(x, &*y, 1); // `x` and `y` may overlap\n+    copy_nonoverlapping_memory(y, &*t, 1);\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant."}, {"sha": "4f7fbbc2bbcdecfbf19805745f16545f2928fd2b", "filename": "src/libstd/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=1b7733109d7b692c2ddd404f1bb6c751c3194750", "patch": "@@ -32,9 +32,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         // Perform the swap, `&mut` pointers never alias\n         let x_raw: *mut T = x;\n         let y_raw: *mut T = y;\n-        ptr::copy_nonoverlapping_memory(t, x_raw, 1);\n-        ptr::copy_nonoverlapping_memory(x, y_raw, 1);\n-        ptr::copy_nonoverlapping_memory(y, t, 1);\n+        ptr::copy_nonoverlapping_memory(t, &*x_raw, 1);\n+        ptr::copy_nonoverlapping_memory(x, &*y_raw, 1);\n+        ptr::copy_nonoverlapping_memory(y, &*t, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `tmp`\n         // because it's no longer relevant."}, {"sha": "de865434a3e5e000b77ee164cd7a868eed7727e5", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b7733109d7b692c2ddd404f1bb6c751c3194750/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1b7733109d7b692c2ddd404f1bb6c751c3194750", "patch": "@@ -1548,7 +1548,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let p = self.as_mut_ptr().offset(i as int);\n             // Shift everything over to make space. (Duplicating the\n             // `i`th element into two consecutive places.)\n-            ptr::copy_memory(p.offset(1), p, len - i);\n+            ptr::copy_memory(p.offset(1), &*p, len - i);\n             // Write it in, overwriting the first copy of the `i`th\n             // element.\n             mem::move_val_init(&mut *p, x);\n@@ -1567,7 +1567,7 @@ impl<T> OwnedVector<T> for ~[T] {\n                 let ret = Some(ptr::read_ptr(ptr as *T));\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy_memory(ptr, ptr.offset(1), len - i - 1);\n+                ptr::copy_memory(ptr, &*ptr.offset(1), len - i - 1);\n                 self.set_len(len - 1);\n \n                 ret\n@@ -1842,7 +1842,7 @@ fn insertion_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n             if i != j {\n                 let tmp = ptr::read_ptr(read_ptr);\n                 ptr::copy_memory(buf_v.offset(j + 1),\n-                                 buf_v.offset(j),\n+                                 &*buf_v.offset(j),\n                                  (i - j) as uint);\n                 ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n                                                 &tmp as *T,\n@@ -1920,7 +1920,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n                 ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 buf_dat.offset(j),\n+                                 &*buf_dat.offset(j),\n                                  i - j as uint);\n                 ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n             }\n@@ -1970,11 +1970,11 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                     if left == right_start {\n                         // the number remaining in this run.\n                         let elems = (right_end as uint - right as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, right, elems);\n+                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n                         break;\n                     } else if right == right_end {\n                         let elems = (right_start as uint - left as uint) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, left, elems);\n+                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n                         break;\n                     }\n \n@@ -1988,7 +1988,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n                     } else {\n                         step(&mut left)\n                     };\n-                    ptr::copy_nonoverlapping_memory(out, to_copy, 1);\n+                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n                     step(&mut out);\n                 }\n             }\n@@ -2002,7 +2002,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n     // write the result to `v` in one go, so that there are never two copies\n     // of the same object in `v`.\n     unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), buf_dat, len);\n+        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n     }\n \n     // increment the pointer, returning the old pointer."}]}