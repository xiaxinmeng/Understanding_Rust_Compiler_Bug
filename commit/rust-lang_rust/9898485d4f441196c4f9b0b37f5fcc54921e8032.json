{"sha": "9898485d4f441196c4f9b0b37f5fcc54921e8032", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4OTg0ODVkNGY0NDExOTZjNGY5YjBiMzdmNWZjYzU0OTIxZTgwMzI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-25T01:24:45Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-25T01:24:45Z"}, "message": "Merge pull request #4613 from erickt/incoming\n\nconvert most of libcore and libstd to structs, work around tzset race", "tree": {"sha": "de85d7acce577d0d9814d011ce8177336872ac96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de85d7acce577d0d9814d011ce8177336872ac96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9898485d4f441196c4f9b0b37f5fcc54921e8032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9898485d4f441196c4f9b0b37f5fcc54921e8032", "html_url": "https://github.com/rust-lang/rust/commit/9898485d4f441196c4f9b0b37f5fcc54921e8032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9898485d4f441196c4f9b0b37f5fcc54921e8032/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f19e16881e474e7f854ad04872e84755a8ad182b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f19e16881e474e7f854ad04872e84755a8ad182b", "html_url": "https://github.com/rust-lang/rust/commit/f19e16881e474e7f854ad04872e84755a8ad182b"}, {"sha": "11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "url": "https://api.github.com/repos/rust-lang/rust/commits/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40", "html_url": "https://github.com/rust-lang/rust/commit/11fd2beef95f2a1e28fbd7b7b7b8647f88f15d40"}], "stats": {"total": 1965, "additions": 1051, "deletions": 914}, "files": [{"sha": "a62e5ff9d32740492aefdabdbe084010f0165db4", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -158,17 +158,10 @@ fn run_tests(config: config) {\n }\n \n fn test_opts(config: config) -> test::TestOpts {\n-    {filter:\n-         match config.filter {\n-           option::Some(s) => option::Some(s),\n-           option::None => option::None\n-         },\n-     run_ignored: config.run_ignored,\n-     logfile:\n-         match config.logfile {\n-           option::Some(s) => option::Some(s.to_str()),\n-           option::None => option::None\n-         }\n+    test::TestOpts {\n+        filter: config.filter,\n+        run_ignored: config.run_ignored,\n+        logfile: config.logfile.map(|s| s.to_str()),\n     }\n }\n "}, {"sha": "4f0d76d69f32ce491900fe29775ba97e4da5beca", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 122, "deletions": 106, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -28,28 +28,26 @@ use option::{None, Option, Some};\n use option;\n use vec;\n \n-type DListLink<T> = Option<DListNode<T>>;\n+pub type DListLink<T> = Option<@DListNode<T>>;\n \n-enum DListNode<T> = @{\n+pub struct DListNode<T> {\n     data: T,\n     mut linked: bool, // for assertions\n     mut prev: DListLink<T>,\n-    mut next: DListLink<T>\n-};\n-\n-pub enum DList<T> {\n-    DList_(@{\n-        mut size: uint,\n-        mut hd:   DListLink<T>,\n-        mut tl:   DListLink<T>\n-    })\n+    mut next: DListLink<T>,\n+}\n+\n+pub struct DList<T> {\n+    mut size: uint,\n+    mut hd: DListLink<T>,\n+    mut tl: DListLink<T>,\n }\n \n priv impl<T> DListNode<T> {\n-    pure fn assert_links() {\n+    pure fn assert_links(@self) {\n         match self.next {\n             Some(neighbour) => match neighbour.prev {\n-              Some(me) => if !managed::ptr_eq(*self, *me) {\n+              Some(me) => if !managed::ptr_eq(self, me) {\n                   fail ~\"Asymmetric next-link in dlist node.\"\n               },\n               None => fail ~\"One-way next-link in dlist node.\"\n@@ -58,7 +56,7 @@ priv impl<T> DListNode<T> {\n         }\n         match self.prev {\n             Some(neighbour) => match neighbour.next {\n-              Some(me) => if !managed::ptr_eq(*me, *self) {\n+              Some(me) => if !managed::ptr_eq(me, self) {\n                   fail ~\"Asymmetric prev-link in dlist node.\"\n               },\n               None => fail ~\"One-way prev-link in dlist node.\"\n@@ -70,24 +68,24 @@ priv impl<T> DListNode<T> {\n \n impl<T> DListNode<T> {\n     /// Get the next node in the list, if there is one.\n-    pure fn next_link() -> Option<DListNode<T>> {\n+    pure fn next_link(@self) -> DListLink<T> {\n         self.assert_links();\n         self.next\n     }\n     /// Get the next node in the list, failing if there isn't one.\n-    pure fn next_node() -> DListNode<T> {\n+    pure fn next_node(@self) -> @DListNode<T> {\n         match self.next_link() {\n             Some(nobe) => nobe,\n             None       => fail ~\"This dlist node has no next neighbour.\"\n         }\n     }\n     /// Get the previous node in the list, if there is one.\n-    pure fn prev_link() -> Option<DListNode<T>> {\n+    pure fn prev_link(@self) -> DListLink<T> {\n         self.assert_links();\n         self.prev\n     }\n     /// Get the previous node in the list, failing if there isn't one.\n-    pure fn prev_node() -> DListNode<T> {\n+    pure fn prev_node(@self) -> @DListNode<T> {\n         match self.prev_link() {\n             Some(nobe) => nobe,\n             None       => fail ~\"This dlist node has no previous neighbour.\"\n@@ -96,24 +94,23 @@ impl<T> DListNode<T> {\n }\n \n /// Creates a new dlist node with the given data.\n-pub pure fn new_dlist_node<T>(data: T) -> DListNode<T> {\n-    DListNode(@{data: move data, mut linked: false,\n-                 mut prev: None, mut next: None})\n+pub pure fn new_dlist_node<T>(data: T) -> @DListNode<T> {\n+    @DListNode { data: data, linked: false, prev: None, next: None }\n }\n \n /// Creates a new, empty dlist.\n-pub pure fn DList<T>() -> DList<T> {\n-    DList_(@{mut size: 0, mut hd: None, mut tl: None})\n+pub pure fn DList<T>() -> @DList<T> {\n+    @DList { size: 0, hd: None, tl: None }\n }\n \n /// Creates a new dlist with a single element\n-pub pure fn from_elem<T>(data: T) -> DList<T> {\n+pub pure fn from_elem<T>(data: T) -> @DList<T> {\n     let list = DList();\n-    unsafe { list.push(move data); }\n+    unsafe { list.push(data); }\n     list\n }\n \n-pub fn from_vec<T: Copy>(vec: &[T]) -> DList<T> {\n+pub fn from_vec<T: Copy>(vec: &[T]) -> @DList<T> {\n     do vec::foldl(DList(), vec) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n@@ -122,7 +119,7 @@ pub fn from_vec<T: Copy>(vec: &[T]) -> DList<T> {\n \n /// Produce a list from a list of lists, leaving no elements behind in the\n /// input. O(number of sub-lists).\n-pub fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n+pub fn concat<T>(lists: @DList<@DList<T>>) -> @DList<T> {\n     let result = DList();\n     while !lists.is_empty() {\n         result.append(lists.pop().get());\n@@ -131,27 +128,26 @@ pub fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n }\n \n priv impl<T> DList<T> {\n-    pure fn new_link(data: T) -> DListLink<T> {\n-        Some(DListNode(@{data: move data, mut linked: true,\n-                          mut prev: None, mut next: None}))\n+    static pure fn new_link(data: T) -> DListLink<T> {\n+        Some(@DListNode { data: data, linked: true, prev: None, next: None })\n     }\n-    pure fn assert_mine(nobe: DListNode<T>) {\n+    pure fn assert_mine(@self, nobe: @DListNode<T>) {\n         // These asserts could be stronger if we had node-root back-pointers,\n         // but those wouldn't allow for O(1) append.\n         if self.size == 0 {\n             fail ~\"This dlist is empty; that node can't be on it.\"\n         }\n         if !nobe.linked { fail ~\"That node isn't linked to any dlist.\" }\n         if !((nobe.prev.is_some()\n-              || managed::ptr_eq(*self.hd.expect(~\"headless dlist?\"),\n-                                 *nobe)) &&\n+              || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                 nobe)) &&\n              (nobe.next.is_some()\n-              || managed::ptr_eq(*self.tl.expect(~\"tailless dlist?\"),\n-                                 *nobe))) {\n+              || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                 nobe))) {\n             fail ~\"That node isn't on this dlist.\"\n         }\n     }\n-    fn make_mine(nobe: DListNode<T>) {\n+    fn make_mine(nobe: @DListNode<T>) {\n         if nobe.prev.is_some() || nobe.next.is_some() || nobe.linked {\n             fail ~\"Cannot insert node that's already on a dlist!\"\n         }\n@@ -171,7 +167,7 @@ priv impl<T> DList<T> {\n         }\n     }\n     // Remove a node from the list.\n-    fn unlink(nobe: DListNode<T>) {\n+    fn unlink(@self, nobe: @DListNode<T>) {\n         self.assert_mine(nobe);\n         assert self.size > 0;\n         self.link(nobe.prev, nobe.next);\n@@ -181,24 +177,24 @@ priv impl<T> DList<T> {\n         self.size -= 1;\n     }\n \n-    fn add_head(nobe: DListLink<T>) {\n+    fn add_head(@self, nobe: DListLink<T>) {\n         self.link(nobe, self.hd); // Might set tail too.\n         self.hd = nobe;\n         self.size += 1;\n     }\n-    fn add_tail(nobe: DListLink<T>) {\n+    fn add_tail(@self, nobe: DListLink<T>) {\n         self.link(self.tl, nobe); // Might set head too.\n         self.tl = nobe;\n         self.size += 1;\n     }\n-    fn insert_left(nobe: DListLink<T>, neighbour: DListNode<T>) {\n+    fn insert_left(@self, nobe: DListLink<T>, neighbour: @DListNode<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(neighbour.prev, nobe);\n         self.link(nobe, Some(neighbour));\n         self.size += 1;\n     }\n-    fn insert_right(neighbour: DListNode<T>, nobe: DListLink<T>) {\n+    fn insert_right(@self, neighbour: @DListNode<T>, nobe: DListLink<T>) {\n         self.assert_mine(neighbour);\n         assert self.size > 0;\n         self.link(nobe, neighbour.next);\n@@ -209,128 +205,136 @@ priv impl<T> DList<T> {\n \n impl<T> DList<T> {\n     /// Get the size of the list. O(1).\n-    pure fn len()          -> uint { self.size }\n+    pure fn len(@self) -> uint { self.size }\n     /// Returns true if the list is empty. O(1).\n-    pure fn is_empty()     -> bool { self.len() == 0 }\n+    pure fn is_empty(@self) -> bool { self.len() == 0 }\n     /// Returns true if the list is not empty. O(1).\n-    pure fn is_not_empty() -> bool { self.len() != 0 }\n+    pure fn is_not_empty(@self) -> bool { self.len() != 0 }\n \n     /// Add data to the head of the list. O(1).\n-    fn push_head(data: T) {\n-        self.add_head(self.new_link(move data));\n+    fn push_head(@self, data: T) {\n+        self.add_head(DList::new_link(data));\n     }\n     /**\n      * Add data to the head of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_head_n(data: T) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn push_head_n(@self, data: T) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.add_head(nobe);\n-        option::get(nobe)\n+        nobe.get()\n     }\n     /// Add data to the tail of the list. O(1).\n-    fn push(data: T) {\n-        self.add_tail(self.new_link(move data));\n+    fn push(@self, data: T) {\n+        self.add_tail(DList::new_link(data));\n     }\n     /**\n      * Add data to the tail of the list, and get the new containing\n      * node. O(1).\n      */\n-    fn push_n(data: T) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn push_n(@self, data: T) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.add_tail(nobe);\n-        option::get(nobe)\n+        nobe.get()\n     }\n     /**\n      * Insert data into the middle of the list, left of the given node.\n      * O(1).\n      */\n-    fn insert_before(data: T, neighbour: DListNode<T>) {\n-        self.insert_left(self.new_link(move data), neighbour);\n+    fn insert_before(@self, data: T, neighbour: @DListNode<T>) {\n+        self.insert_left(DList::new_link(data), neighbour);\n     }\n     /**\n      * Insert an existing node in the middle of the list, left of the\n      * given node. O(1).\n      */\n-    fn insert_n_before(nobe: DListNode<T>, neighbour: DListNode<T>) {\n+    fn insert_n_before(@self, nobe: @DListNode<T>, neighbour: @DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_left(Some(nobe), neighbour);\n     }\n     /**\n      * Insert data in the middle of the list, left of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_before_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn insert_before_n(\n+        @self,\n+        data: T,\n+        neighbour: @DListNode<T>\n+    ) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.insert_left(nobe, neighbour);\n-        option::get(nobe)\n+        nobe.get()\n     }\n     /**\n      * Insert data into the middle of the list, right of the given node.\n      * O(1).\n      */\n-    fn insert_after(data: T, neighbour: DListNode<T>) {\n-        self.insert_right(neighbour, self.new_link(move data));\n+    fn insert_after(@self, data: T, neighbour: @DListNode<T>) {\n+        self.insert_right(neighbour, DList::new_link(data));\n     }\n     /**\n      * Insert an existing node in the middle of the list, right of the\n      * given node. O(1).\n      */\n-    fn insert_n_after(nobe: DListNode<T>, neighbour: DListNode<T>) {\n+    fn insert_n_after(@self, nobe: @DListNode<T>, neighbour: @DListNode<T>) {\n         self.make_mine(nobe);\n         self.insert_right(neighbour, Some(nobe));\n     }\n     /**\n      * Insert data in the middle of the list, right of the given node,\n      * and get its containing node. O(1).\n      */\n-    fn insert_after_n(data: T, neighbour: DListNode<T>) -> DListNode<T> {\n-        let mut nobe = self.new_link(move data);\n+    fn insert_after_n(\n+        @self,\n+        data: T,\n+        neighbour: @DListNode<T>\n+    ) -> @DListNode<T> {\n+        let mut nobe = DList::new_link(data);\n         self.insert_right(neighbour, nobe);\n-        option::get(nobe)\n+        nobe.get()\n     }\n \n     /// Remove a node from the head of the list. O(1).\n-    fn pop_n() -> Option<DListNode<T>> {\n+    fn pop_n(@self) -> DListLink<T> {\n         let hd = self.peek_n();\n         hd.map(|nobe| self.unlink(*nobe));\n         hd\n     }\n     /// Remove a node from the tail of the list. O(1).\n-    fn pop_tail_n() -> Option<DListNode<T>> {\n+    fn pop_tail_n(@self) -> DListLink<T> {\n         let tl = self.peek_tail_n();\n         tl.map(|nobe| self.unlink(*nobe));\n         tl\n     }\n     /// Get the node at the list's head. O(1).\n-    pure fn peek_n() -> Option<DListNode<T>> { self.hd }\n+    pure fn peek_n(@self) -> DListLink<T> { self.hd }\n     /// Get the node at the list's tail. O(1).\n-    pure fn peek_tail_n() -> Option<DListNode<T>> { self.tl }\n+    pure fn peek_tail_n(@self) -> DListLink<T> { self.tl }\n \n     /// Get the node at the list's head, failing if empty. O(1).\n-    pure fn head_n() -> DListNode<T> {\n+    pure fn head_n(@self) -> @DListNode<T> {\n         match self.hd {\n             Some(nobe) => nobe,\n             None       => fail ~\"Attempted to get the head of an empty dlist.\"\n         }\n     }\n     /// Get the node at the list's tail, failing if empty. O(1).\n-    pure fn tail_n() -> DListNode<T> {\n+    pure fn tail_n(@self) -> @DListNode<T> {\n         match self.tl {\n             Some(nobe) => nobe,\n             None       => fail ~\"Attempted to get the tail of an empty dlist.\"\n         }\n     }\n \n     /// Remove a node from anywhere in the list. O(1).\n-    fn remove(nobe: DListNode<T>) { self.unlink(nobe); }\n+    fn remove(@self, nobe: @DListNode<T>) { self.unlink(nobe); }\n \n     /**\n      * Empty another list onto the end of this list, joining this list's tail\n      * to the other list's head. O(1).\n      */\n-    fn append(them: DList<T>) {\n-        if managed::ptr_eq(*self, *them) {\n+    fn append(@self, them: @DList<T>) {\n+        if managed::ptr_eq(self, them) {\n             fail ~\"Cannot append a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -346,8 +350,8 @@ impl<T> DList<T> {\n      * Empty another list onto the start of this list, joining the other\n      * list's tail to this list's head. O(1).\n      */\n-    fn prepend(them: DList<T>) {\n-        if managed::ptr_eq(*self, *them) {\n+    fn prepend(@self, them: @DList<T>) {\n+        if managed::ptr_eq(self, them) {\n             fail ~\"Cannot prepend a dlist to itself!\"\n         }\n         if them.len() > 0 {\n@@ -361,7 +365,7 @@ impl<T> DList<T> {\n     }\n \n     /// Reverse the list's elements in place. O(n).\n-    fn reverse() {\n+    fn reverse(@self) {\n         do option::while_some(self.hd) |nobe| {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n@@ -375,7 +379,7 @@ impl<T> DList<T> {\n      * Remove everything from the list. This is important because the cyclic\n      * links won't otherwise be automatically refcounted-collected. O(n).\n      */\n-    fn clear() {\n+    fn clear(@self) {\n         // Cute as it would be to simply detach the list and proclaim \"O(1)!\",\n         // the GC would still be a hidden O(n). Better to be honest about it.\n         while !self.is_empty() {\n@@ -384,7 +388,7 @@ impl<T> DList<T> {\n     }\n \n     /// Iterate over nodes.\n-    pure fn each_node(f: fn(DListNode<T>) -> bool) {\n+    pure fn each_node(@self, f: fn(@DListNode<T>) -> bool) {\n         let mut link = self.peek_n();\n         while link.is_some() {\n             let nobe = link.get();\n@@ -394,26 +398,26 @@ impl<T> DList<T> {\n     }\n \n     /// Check data structure integrity. O(n).\n-    fn assert_consistent() {\n-        if option::is_none(&self.hd) || option::is_none(&self.tl) {\n-            assert option::is_none(&self.hd) && option::is_none(&self.tl);\n+    fn assert_consistent(@self) {\n+        if self.hd.is_none() || self.tl.is_none() {\n+            assert self.hd.is_none() && self.tl.is_none();\n         }\n         // iterate forwards\n         let mut count = 0;\n         let mut link = self.peek_n();\n         let mut rabbit = link;\n-        while option::is_some(&link) {\n-            let nobe = option::get(link);\n+        while link.is_some() {\n+            let nobe = link.get();\n             assert nobe.linked;\n             // check cycle\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).next;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().next;\n             }\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).next;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().next;\n             }\n-            if option::is_some(&rabbit) {\n-                assert !managed::ptr_eq(*option::get(rabbit), *nobe);\n+            if rabbit.is_some() {\n+                assert !managed::ptr_eq(rabbit.get(), nobe);\n             }\n             // advance\n             link = nobe.next_link();\n@@ -423,18 +427,18 @@ impl<T> DList<T> {\n         // iterate backwards - some of this is probably redundant.\n         link = self.peek_tail_n();\n         rabbit = link;\n-        while option::is_some(&link) {\n-            let nobe = option::get(link);\n+        while link.is_some() {\n+            let nobe = link.get();\n             assert nobe.linked;\n             // check cycle\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).prev;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().prev;\n             }\n-            if option::is_some(&rabbit) {\n-                rabbit = option::get(rabbit).prev;\n+            if rabbit.is_some() {\n+                rabbit = rabbit.get().prev;\n             }\n-            if option::is_some(&rabbit) {\n-                assert !managed::ptr_eq(*option::get(rabbit), *nobe);\n+            if rabbit.is_some() {\n+                assert !managed::ptr_eq(rabbit.get(), nobe);\n             }\n             // advance\n             link = nobe.prev_link();\n@@ -446,21 +450,33 @@ impl<T> DList<T> {\n \n impl<T: Copy> DList<T> {\n     /// Remove data from the head of the list. O(1).\n-    fn pop()       -> Option<T> { self.pop_n().map       (|nobe| nobe.data) }\n+    fn pop(@self) -> Option<T> {\n+        self.pop_n().map(|nobe| nobe.data)\n+    }\n+\n     /// Remove data from the tail of the list. O(1).\n-    fn pop_tail()  -> Option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n+    fn pop_tail(@self) -> Option<T> {\n+        self.pop_tail_n().map(|nobe| nobe.data)\n+    }\n+\n     /// Get data at the list's head. O(1).\n-    pure fn peek() -> Option<T> { self.peek_n().map      (|nobe| nobe.data) }\n+    pure fn peek(@self) -> Option<T> {\n+        self.peek_n().map(|nobe| nobe.data)\n+    }\n+\n     /// Get data at the list's tail. O(1).\n-    pure fn peek_tail() -> Option<T> {\n+    pure fn peek_tail(@self) -> Option<T> {\n         self.peek_tail_n().map (|nobe| nobe.data)\n     }\n+\n     /// Get data at the list's head, failing if empty. O(1).\n-    pure fn head() -> T { self.head_n().data }\n+    pure fn head(@self) -> T { self.head_n().data }\n+\n     /// Get data at the list's tail, failing if empty. O(1).\n-    pure fn tail() -> T { self.tail_n().data }\n+    pure fn tail(@self) -> T { self.tail_n().data }\n+\n     /// Get the elements of the list as a vector. O(n).\n-    pure fn to_vec() -> ~[T] {\n+    pure fn to_vec(@self) -> ~[T] {\n         let mut v = vec::with_capacity(self.size);\n         unsafe {\n             // Take this out of the unchecked when iter's functions are pure"}, {"sha": "854f99be1e2d1b0d568ee7fef5aef083dcae8e19", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -376,13 +376,23 @@ pub mod ct {\n     fn test_parse_fmt_string() {\n         assert parse_fmt_string(\"foo %s bar\", die) == ~[\n             PieceString(~\"foo \"),\n-            PieceConv(Conv {param: None, flags: ~[], width: CountImplied,\n-                            precision: CountImplied, ty: TyStr}),\n+            PieceConv(Conv {\n+                param: None,\n+                flags: ~[],\n+                width: CountImplied,\n+                precision: CountImplied,\n+                ty: TyStr,\n+            }),\n             PieceString(~\" bar\")];\n \n         assert parse_fmt_string(\"%s\", die) == ~[\n-            PieceConv(Conv {param: None, flags: ~[], width: CountImplied,\n-                            precision: CountImplied, ty: TyStr })];\n+            PieceConv(Conv {\n+                param: None,\n+                flags: ~[],\n+                width: CountImplied,\n+                precision: CountImplied,\n+                ty: TyStr,\n+            })];\n \n         assert parse_fmt_string(\"%%%%\", die) == ~[\n             PieceString(~\"%\"), PieceString(~\"%\")];\n@@ -466,7 +476,7 @@ pub mod ct {\n // Functions used by the fmt extension at runtime. For now there are a lot of\n // decisions made a runtime. If it proves worthwhile then some of these\n // conditions can be evaluated at compile-time. For now though it's cleaner to\n-// implement it 0this way, I think.\n+// implement it this way, I think.\n #[doc(hidden)]\n pub mod rt {\n     use float;\n@@ -486,8 +496,19 @@ pub mod rt {\n \n     pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n+    #[cfg(stage0)]\n     pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    pub struct Conv {\n+        flags: u32,\n+        width: Count,\n+        precision: Count,\n+        ty: Ty,\n+    }\n+\n     pub pure fn conv_int(cv: Conv, i: int) -> ~str {\n         let radix = 10;\n         let prec = get_int_precision(cv);"}, {"sha": "698e264b57a65ae12ccabcbe1d6792c058a851d5", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -87,7 +87,10 @@ unsafe fn get_safe_point_count() -> uint {\n     return *module_meta;\n }\n \n-type SafePoint = { sp_meta: *Word, fn_meta: *Word };\n+struct SafePoint {\n+    sp_meta: *Word,\n+    fn_meta: *Word,\n+}\n \n // Returns the safe point metadata for the given program counter, if\n // any.\n@@ -106,7 +109,10 @@ unsafe fn is_safe_point(pc: *Word) -> Option<SafePoint> {\n         let sp: **Word = bump(safe_points, spi*3);\n         let sp_loc = *sp;\n         if sp_loc == pc {\n-            return Some({sp_meta: *bump(sp, 1), fn_meta: *bump(sp, 2)});\n+            return Some(SafePoint {\n+                sp_meta: *bump(sp, 1),\n+                fn_meta: *bump(sp, 2),\n+            });\n         }\n         spi += 1;\n     }"}, {"sha": "fedcb9511960e34152f1e047118824e77710be73", "filename": "src/libcore/io.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -455,10 +455,15 @@ impl *libc::FILE: Reader {\n     }\n }\n \n+struct Wrapper<T, C> {\n+    base: T,\n+    cleanup: C,\n+}\n+\n // A forwarding impl of reader that also holds on to a resource for the\n // duration of its lifetime.\n // FIXME there really should be a better way to do this // #2004\n-impl<T: Reader, C> {base: T, cleanup: C}: Reader {\n+impl<R: Reader, C> Wrapper<R, C>: Reader {\n     fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n         self.base.read(bytes, len)\n     }\n@@ -487,7 +492,7 @@ pub fn FILERes(f: *libc::FILE) -> FILERes {\n \n pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n     if cleanup {\n-        {base: f, cleanup: FILERes(f)} as Reader\n+        Wrapper { base: f, cleanup: FILERes(f) } as Reader\n     } else {\n         f as Reader\n     }\n@@ -587,7 +592,7 @@ pub trait Writer {\n     fn get_type(&self) -> WriterType;\n }\n \n-impl<T: Writer, C> {base: T, cleanup: C}: Writer {\n+impl<W: Writer, C> Wrapper<W, C>: Writer {\n     fn write(&self, bs: &[const u8]) { self.base.write(bs); }\n     fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n     fn tell(&self) -> uint { self.base.tell() }\n@@ -639,7 +644,7 @@ impl *libc::FILE: Writer {\n \n pub fn FILE_writer(f: *libc::FILE, cleanup: bool) -> Writer {\n     if cleanup {\n-        {base: f, cleanup: FILERes(f)} as Writer\n+        Wrapper { base: f, cleanup: FILERes(f) } as Writer\n     } else {\n         f as Writer\n     }\n@@ -696,7 +701,7 @@ pub fn FdRes(fd: fd_t) -> FdRes {\n \n pub fn fd_writer(fd: fd_t, cleanup: bool) -> Writer {\n     if cleanup {\n-        {base: fd, cleanup: FdRes(fd)} as Writer\n+        Wrapper { base: fd, cleanup: FdRes(fd) } as Writer\n     } else {\n         fd as Writer\n     }\n@@ -1086,11 +1091,9 @@ pub fn read_whole_file(file: &Path) -> Result<~[u8], ~str> {\n // fsync related\n \n pub mod fsync {\n+    use prelude::*;\n     use io::{FILERes, FdRes, fd_t};\n-    use kinds::Copy;\n     use libc;\n-    use option::Option;\n-    use option;\n     use os;\n \n     pub enum Level {\n@@ -1110,10 +1113,13 @@ pub mod fsync {\n     // Artifacts that need to fsync on destruction\n     pub struct Res<t: Copy> {\n         arg: Arg<t>,\n-        drop {\n+    }\n+\n+    impl<T: Copy> Res<T>: Drop {\n+        fn finalize(&self) {\n           match self.arg.opt_level {\n-            option::None => (),\n-            option::Some(level) => {\n+            None => (),\n+            Some(level) => {\n               // fail hard if not succesful\n               assert((self.arg.fsync_fn)(self.arg.val, level) != -1);\n             }\n@@ -1127,19 +1133,19 @@ pub mod fsync {\n         }\n     }\n \n-    pub type Arg<t> = {\n+    pub struct Arg<t> {\n         val: t,\n         opt_level: Option<Level>,\n-        fsync_fn: fn@(f: t, Level) -> int\n-    };\n+        fsync_fn: fn@(f: t, Level) -> int,\n+    }\n \n     // fsync file after executing blk\n     // FIXME (#2004) find better way to create resources within lifetime of\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n                          blk: fn(v: Res<*libc::FILE>)) {\n         unsafe {\n-            blk(move Res({\n+            blk(Res(Arg {\n                 val: file.f, opt_level: opt_level,\n                 fsync_fn: fn@(file: *libc::FILE, l: Level) -> int {\n                     unsafe {\n@@ -1153,7 +1159,7 @@ pub mod fsync {\n     // fsync fd after executing blk\n     pub fn fd_res_sync(fd: &FdRes, opt_level: Option<Level>,\n                        blk: fn(v: Res<fd_t>)) {\n-        blk(move Res({\n+        blk(Res(Arg {\n             val: fd.fd, opt_level: opt_level,\n             fsync_fn: fn@(fd: fd_t, l: Level) -> int {\n                 return os::fsync_fd(fd, l) as int;\n@@ -1167,7 +1173,7 @@ pub mod fsync {\n     // Call o.fsync after executing blk\n     pub fn obj_sync(o: FSyncable, opt_level: Option<Level>,\n                     blk: fn(v: Res<FSyncable>)) {\n-        blk(Res({\n+        blk(Res(Arg {\n             val: o, opt_level: opt_level,\n             fsync_fn: fn@(o: FSyncable, l: Level) -> int {\n                 return o.fsync(l);"}, {"sha": "5b5f786bac7ffb516cb0cb52a75b6e97301a7cc7", "filename": "src/libcore/iter-trait/dlist.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -10,12 +10,13 @@\n \n mod inst {\n     use dlist;\n+    use dlist::DList;\n     use managed;\n     use option::{Option, Some};\n     use option;\n \n     #[allow(non_camel_case_types)]\n-    pub type IMPL_T<A> = dlist::DList<A>;\n+    pub type IMPL_T<A> = @DList<A>;\n \n     /**\n     * Iterates through the current contents.\n@@ -36,11 +37,11 @@ mod inst {\n             }\n             if !nobe.linked ||\n                 (!((nobe.prev.is_some()\n-                    || managed::ptr_eq(*self.hd.expect(~\"headless dlist?\"),\n-                                   *nobe))\n+                    || managed::ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                       nobe))\n                    && (nobe.next.is_some()\n-                    || managed::ptr_eq(*self.tl.expect(~\"tailless dlist?\"),\n-                                   *nobe)))) {\n+                    || managed::ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                       nobe)))) {\n                 fail ~\"Removing a dlist node during iteration is forbidden!\"\n             }\n             link = nobe.next_link();"}, {"sha": "0ef30668dbce101274a5e9bd0b02bb6ab96460df", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -132,18 +132,27 @@ pub struct BufferHeader {\n     // thing along.\n }\n \n-pub fn BufferHeader() -> BufferHeader{\n+pub fn BufferHeader() -> BufferHeader {\n     BufferHeader {\n         ref_count: 0\n     }\n }\n \n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n+#[cfg(stage0)]\n type Buffer<T: Owned> = {\n     header: BufferHeader,\n     data: T,\n };\n+#[doc(hidden)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub struct Buffer<T: Owned> {\n+    header: BufferHeader,\n+    data: T,\n+}\n \n struct PacketHeader {\n     mut state: State,\n@@ -201,10 +210,10 @@ impl PacketHeader {\n }\n \n #[doc(hidden)]\n-pub type Packet<T: Owned> = {\n+pub struct Packet<T: Owned> {\n     header: PacketHeader,\n     mut payload: Option<T>,\n-};\n+}\n \n #[doc(hidden)]\n pub trait HasBuffer {\n@@ -223,19 +232,39 @@ impl<T: Owned> Packet<T>: HasBuffer {\n \n #[doc(hidden)]\n pub fn mk_packet<T: Owned>() -> Packet<T> {\n-    {\n+    Packet {\n         header: PacketHeader(),\n-        mut payload: None\n+        payload: None,\n     }\n }\n \n #[doc(hidden)]\n+#[cfg(stage0)]\n fn unibuffer<T: Owned>() -> ~Buffer<Packet<T>> {\n     let b = ~{\n         header: BufferHeader(),\n-        data: {\n+        data: Packet {\n             header: PacketHeader(),\n-            mut payload: None,\n+            payload: None,\n+        }\n+    };\n+\n+    unsafe {\n+        b.data.header.buffer = reinterpret_cast(&b);\n+    }\n+    move b\n+}\n+\n+#[doc(hidden)]\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+fn unibuffer<T: Owned>() -> ~Buffer<Packet<T>> {\n+    let b = ~Buffer {\n+        header: BufferHeader(),\n+        data: Packet {\n+            header: PacketHeader(),\n+            payload: None,\n         }\n     };\n \n@@ -1011,15 +1040,19 @@ pub trait Peekable<T> {\n }\n \n #[doc(hidden)]\n-type Chan_<T:Owned> = { mut endp: Option<streamp::client::Open<T>> };\n+struct Chan_<T:Owned> {\n+    mut endp: Option<streamp::client::Open<T>>,\n+}\n \n /// An endpoint that can send many messages.\n pub enum Chan<T:Owned> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n-type Port_<T:Owned> = { mut endp: Option<streamp::server::Open<T>> };\n+struct Port_<T:Owned> {\n+    mut endp: Option<streamp::server::Open<T>>,\n+}\n \n /// An endpoint that can receive many messages.\n pub enum Port<T:Owned> {\n@@ -1034,7 +1067,7 @@ These allow sending or receiving an unlimited number of messages.\n pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     let (c, s) = streamp::init();\n \n-    (Port_({ mut endp: Some(move s) }), Chan_({ mut endp: Some(move c) }))\n+    (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n }\n \n impl<T: Owned> Chan<T>: GenericChan<T> {"}, {"sha": "976c186912b37032ff9cf638d57da4b3ae20d04a", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -42,7 +42,10 @@ pub trait Rng {\n }\n \n /// A value with a particular weight compared to other values\n-pub type Weighted<T> = { weight: uint, item: T };\n+pub struct Weighted<T> {\n+    weight: uint,\n+    item: T,\n+}\n \n /// Extension methods for random number generators\n impl Rng {\n@@ -312,12 +315,12 @@ pub fn seeded_rng(seed: &~[u8]) -> Rng {\n     }\n }\n \n-type XorShiftState = {\n+struct XorShiftState {\n     mut x: u32,\n     mut y: u32,\n     mut z: u32,\n-    mut w: u32\n-};\n+    mut w: u32,\n+}\n \n impl XorShiftState: Rng {\n     fn next() -> u32 {\n@@ -338,7 +341,7 @@ pub pure fn xorshift() -> Rng {\n }\n \n pub pure fn seeded_xorshift(x: u32, y: u32, z: u32, w: u32) -> Rng {\n-    {mut x: x, mut y: y, mut z: z, mut w: w} as Rng\n+    XorShiftState { x: x, y: y, z: z, w: w } as Rng\n }\n \n \n@@ -492,21 +495,24 @@ pub mod tests {\n     #[test]\n     pub fn choose_weighted() {\n         let r = rand::Rng();\n-        assert r.choose_weighted(~[{weight: 1u, item: 42}]) == 42;\n         assert r.choose_weighted(~[\n-            {weight: 0u, item: 42},\n-            {weight: 1u, item: 43}\n+            rand::Weighted { weight: 1u, item: 42 },\n+        ]) == 42;\n+        assert r.choose_weighted(~[\n+            rand::Weighted { weight: 0u, item: 42 },\n+            rand::Weighted { weight: 1u, item: 43 },\n         ]) == 43;\n     }\n \n     #[test]\n     pub fn choose_weighted_option() {\n         let r = rand::Rng();\n-        assert r.choose_weighted_option(~[{weight: 1u, item: 42}]) ==\n-               Some(42);\n         assert r.choose_weighted_option(~[\n-            {weight: 0u, item: 42},\n-            {weight: 1u, item: 43}\n+            rand::Weighted { weight: 1u, item: 42 },\n+        ]) == Some(42);\n+        assert r.choose_weighted_option(~[\n+            rand::Weighted { weight: 0u, item: 42 },\n+            rand::Weighted { weight: 1u, item: 43 },\n         ]) == Some(43);\n         let v: Option<int> = r.choose_weighted_option([]);\n         assert v.is_none();\n@@ -518,9 +524,9 @@ pub mod tests {\n         let empty: ~[int] = ~[];\n         assert r.weighted_vec(~[]) == empty;\n         assert r.weighted_vec(~[\n-            {weight: 0u, item: 3u},\n-            {weight: 1u, item: 2u},\n-            {weight: 2u, item: 1u}\n+            rand::Weighted { weight: 0u, item: 3u },\n+            rand::Weighted { weight: 1u, item: 2u },\n+            rand::Weighted { weight: 2u, item: 1u },\n         ]) == ~[2u, 1u, 1u];\n     }\n "}, {"sha": "8960d40b85a24cd100ff9d119c12046d0844ee0d", "filename": "src/libcore/run.rs", "status": "modified", "additions": 68, "deletions": 65, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -204,83 +204,86 @@ pub fn run_program(prog: &str, args: &[~str]) -> int {\n  * A class with a <program> field\n  */\n pub fn start_program(prog: &str, args: &[~str]) -> Program {\n+    let pipe_input = os::pipe();\n+    let pipe_output = os::pipe();\n+    let pipe_err = os::pipe();\n+    let pid =\n+        spawn_process(prog, args, &None, &None,\n+                      pipe_input.in, pipe_output.out,\n+                      pipe_err.out);\n+\n     unsafe {\n-        let pipe_input = os::pipe();\n-        let pipe_output = os::pipe();\n-        let pipe_err = os::pipe();\n-        let pid =\n-            spawn_process(prog, args, &None, &None,\n-                          pipe_input.in, pipe_output.out,\n-                          pipe_err.out);\n+        if pid == -1 as pid_t { fail; }\n+        libc::close(pipe_input.in);\n+        libc::close(pipe_output.out);\n+        libc::close(pipe_err.out);\n+    }\n \n-        unsafe {\n-            if pid == -1 as pid_t { fail; }\n-            libc::close(pipe_input.in);\n-            libc::close(pipe_output.out);\n-            libc::close(pipe_err.out);\n-        }\n+    struct ProgRepr {\n+        pid: pid_t,\n+        mut in_fd: c_int,\n+        out_file: *libc::FILE,\n+        err_file: *libc::FILE,\n+        mut finished: bool,\n+    }\n \n-        type ProgRepr = {pid: pid_t,\n-                         mut in_fd: c_int,\n-                         out_file: *libc::FILE,\n-                         err_file: *libc::FILE,\n-                         mut finished: bool};\n-\n-        fn close_repr_input(r: &ProgRepr) {\n-            let invalid_fd = -1i32;\n-            if r.in_fd != invalid_fd {\n-                unsafe {\n-                    libc::close(r.in_fd);\n-                }\n-                r.in_fd = invalid_fd;\n-            }\n-        }\n-        fn finish_repr(r: &ProgRepr) -> int {\n-            if r.finished { return 0; }\n-            r.finished = true;\n-            close_repr_input(r);\n-            return waitpid(r.pid);\n-        }\n-        fn destroy_repr(r: &ProgRepr) {\n+    fn close_repr_input(r: &ProgRepr) {\n+        let invalid_fd = -1i32;\n+        if r.in_fd != invalid_fd {\n             unsafe {\n-                finish_repr(r);\n-                libc::fclose(r.out_file);\n-                libc::fclose(r.err_file);\n+                libc::close(r.in_fd);\n             }\n+            r.in_fd = invalid_fd;\n         }\n-        struct ProgRes {\n-            r: ProgRepr,\n-            drop { destroy_repr(&self.r); }\n+    }\n+    fn finish_repr(r: &ProgRepr) -> int {\n+        if r.finished { return 0; }\n+        r.finished = true;\n+        close_repr_input(r);\n+        return waitpid(r.pid);\n+    }\n+    fn destroy_repr(r: &ProgRepr) {\n+        unsafe {\n+            finish_repr(r);\n+            libc::fclose(r.out_file);\n+            libc::fclose(r.err_file);\n         }\n+    }\n+    struct ProgRes {\n+        r: ProgRepr,\n+        drop { destroy_repr(&self.r); }\n+    }\n \n-        fn ProgRes(r: ProgRepr) -> ProgRes {\n-            ProgRes {\n-                r: move r\n-            }\n+    fn ProgRes(r: ProgRepr) -> ProgRes {\n+        ProgRes {\n+            r: move r\n         }\n+    }\n \n-        impl ProgRes: Program {\n-            fn get_id() -> pid_t { return self.r.pid; }\n-            fn input() -> io::Writer {\n-                io::fd_writer(self.r.in_fd, false)\n-            }\n-            fn output() -> io::Reader {\n-                io::FILE_reader(self.r.out_file, false)\n-            }\n-            fn err() -> io::Reader {\n-                io::FILE_reader(self.r.err_file, false)\n-            }\n-            fn close_input() { close_repr_input(&self.r); }\n-            fn finish() -> int { finish_repr(&self.r) }\n-            fn destroy() { destroy_repr(&self.r); }\n+    impl ProgRes: Program {\n+        fn get_id() -> pid_t { return self.r.pid; }\n+        fn input() -> io::Writer {\n+            io::fd_writer(self.r.in_fd, false)\n+        }\n+        fn output() -> io::Reader {\n+            io::FILE_reader(self.r.out_file, false)\n+        }\n+        fn err() -> io::Reader {\n+            io::FILE_reader(self.r.err_file, false)\n         }\n-        let repr = {pid: pid,\n-                    mut in_fd: pipe_input.out,\n-                    out_file: os::fdopen(pipe_output.in),\n-                    err_file: os::fdopen(pipe_err.in),\n-                    mut finished: false};\n-        return ProgRes(move repr) as Program;\n+        fn close_input() { close_repr_input(&self.r); }\n+        fn finish() -> int { finish_repr(&self.r) }\n+        fn destroy() { destroy_repr(&self.r); }\n     }\n+    let repr = ProgRepr {\n+        pid: pid,\n+        in_fd: pipe_input.out,\n+        out_file: os::fdopen(pipe_output.in),\n+        err_file: os::fdopen(pipe_err.in),\n+        finished: false,\n+    };\n+\n+    ProgRes(repr) as Program\n }\n \n fn read_all(rd: io::Reader) -> ~str {"}, {"sha": "a4d99bf5db4a6cb78ea9efcd977a6783d2cc9441", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -168,10 +168,10 @@ impl SchedMode : cmp::Eq {\n  *     default these foreign stacks have unspecified size, but with this\n  *     option their size can be precisely specified.\n  */\n-pub type SchedOpts = {\n+pub struct SchedOpts {\n     mode: SchedMode,\n-    foreign_stack_size: Option<uint>\n-};\n+    foreign_stack_size: Option<uint>,\n+}\n \n /**\n  * Task configuration options\n@@ -200,12 +200,12 @@ pub type SchedOpts = {\n  *     into foreign code that blocks. Without doing so in a different\n  *     scheduler other tasks will be impeded or even blocked indefinitely.\n  */\n-pub type TaskOpts = {\n+pub struct TaskOpts {\n     linked: bool,\n     supervised: bool,\n     mut notify_chan: Option<Chan<TaskResult>>,\n     sched: Option<SchedOpts>,\n-};\n+}\n \n /**\n  * The task builder type.\n@@ -251,15 +251,15 @@ priv impl TaskBuilder {\n         self.consumed = true;\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n             gen_body: self.gen_body,\n             can_not_copy: None,\n-            mut consumed: false\n+            consumed: false\n         }\n     }\n }\n@@ -272,10 +272,10 @@ impl TaskBuilder {\n     fn unlinked() -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: false,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -290,10 +290,10 @@ impl TaskBuilder {\n     fn supervised() -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: false,\n                 supervised: true,\n-                mut notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -307,10 +307,10 @@ impl TaskBuilder {\n     fn linked() -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: true,\n                 supervised: false,\n-                mut notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -352,10 +352,10 @@ impl TaskBuilder {\n \n         // Reconfigure self to use a notify channel.\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: Some(move notify_pipe_ch),\n+                notify_chan: Some(notify_pipe_ch),\n                 sched: self.opts.sched\n             },\n             can_not_copy: None,\n@@ -366,11 +366,14 @@ impl TaskBuilder {\n     fn sched_mode(mode: SchedMode) -> TaskBuilder {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n-                sched: Some({ mode: mode, foreign_stack_size: None})\n+                notify_chan: notify_chan,\n+                sched: Some(SchedOpts {\n+                    mode: mode,\n+                    foreign_stack_size: None,\n+                })\n             },\n             can_not_copy: None,\n             .. self.consume()\n@@ -393,10 +396,10 @@ impl TaskBuilder {\n         let prev_gen_body = self.gen_body;\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         TaskBuilder {\n-            opts: {\n+            opts: TaskOpts {\n                 linked: self.opts.linked,\n                 supervised: self.opts.supervised,\n-                mut notify_chan: move notify_chan,\n+                notify_chan: notify_chan,\n                 sched: self.opts.sched\n             },\n             // tjc: I think this is the line that gets miscompiled\n@@ -424,10 +427,10 @@ impl TaskBuilder {\n     fn spawn(f: fn~()) {\n         let notify_chan = replace(&mut self.opts.notify_chan, None);\n         let x = self.consume();\n-        let opts = {\n+        let opts = TaskOpts {\n             linked: x.opts.linked,\n             supervised: x.opts.supervised,\n-            mut notify_chan: move notify_chan,\n+            notify_chan: notify_chan,\n             sched: x.opts.sched\n         };\n         spawn::spawn_raw(move opts, (x.gen_body)(move f));\n@@ -482,10 +485,10 @@ pub fn default_task_opts() -> TaskOpts {\n      * into the same scheduler, and do not post lifecycle notifications.\n      */\n \n-    {\n+    TaskOpts {\n         linked: true,\n         supervised: false,\n-        mut notify_chan: None,\n+        notify_chan: None,\n         sched: None\n     }\n }"}, {"sha": "edeacb31e1d0993059b3b422b41b0cc550b16ec8", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -114,14 +114,14 @@ pub fn taskset_each(tasks: &TaskSet, blk: fn(v: *rust_task) -> bool) {\n }\n \n // One of these per group of linked-failure tasks.\n-type TaskGroupData = {\n+struct TaskGroupData {\n     // All tasks which might kill this group. When this is empty, the group\n     // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n     mut members:     TaskSet,\n     // All tasks unidirectionally supervised by (directly or transitively)\n     // tasks in this group.\n     mut descendants: TaskSet,\n-};\n+}\n type TaskGroupArc = private::Exclusive<Option<TaskGroupData>>;\n \n type TaskGroupInner = &mut Option<TaskGroupData>;\n@@ -138,7 +138,7 @@ pure fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-type AncestorNode = {\n+struct AncestorNode {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -150,7 +150,8 @@ type AncestorNode = {\n     mut parent_group: Option<TaskGroupArc>,\n     // Recursive rest of the list.\n     mut ancestors:    AncestorList,\n-};\n+}\n+\n enum AncestorList = Option<private::Exclusive<AncestorNode>>;\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n@@ -450,11 +451,10 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                 // Main task, doing first spawn ever. Lazily initialise here.\n                 let mut members = new_taskset();\n                 taskset_insert(&mut members, spawner);\n-                let tasks =\n-                    private::exclusive(Some({\n-                        mut members:     move members,\n-                        mut descendants: new_taskset()\n-                    }));\n+                let tasks = private::exclusive(Some(TaskGroupData {\n+                    members: members,\n+                    descendants: new_taskset(),\n+                }));\n                 // Main task/group has no ancestors, no notifier, etc.\n                 let group =\n                     @TCB(spawner, move tasks, AncestorList(None), true, None);\n@@ -475,9 +475,9 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             (move g, move a, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n-            let g = private::exclusive(Some({\n-                mut members:     new_taskset(),\n-                mut descendants: new_taskset()\n+            let g = private::exclusive(Some(TaskGroupData {\n+                members:     new_taskset(),\n+                descendants: new_taskset(),\n             }));\n             let a = if supervised {\n                 // Child's ancestors start with the spawner.\n@@ -495,10 +495,11 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     };\n                 assert new_generation < uint::max_value;\n                 // Build a new node in the ancestor list.\n-                AncestorList(Some(private::exclusive(\n-                    { generation:       new_generation,\n-                      mut parent_group: Some(spawner_group.tasks.clone()),\n-                      mut ancestors:    move old_ancestors })))\n+                AncestorList(Some(private::exclusive(AncestorNode {\n+                    generation: new_generation,\n+                    parent_group: Some(spawner_group.tasks.clone()),\n+                    ancestors: old_ancestors,\n+                })))\n             } else {\n                 // Child has no ancestors.\n                 AncestorList(None)\n@@ -685,9 +686,9 @@ fn test_spawn_raw_simple() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_spawn_raw_unsupervise() {\n-    let opts = {\n+    let opts = task::TaskOpts {\n         linked: false,\n-        mut notify_chan: None,\n+        notify_chan: None,\n         .. default_task_opts()\n     };\n     do spawn_raw(move opts) {\n@@ -700,8 +701,8 @@ fn test_spawn_raw_unsupervise() {\n fn test_spawn_raw_notify_success() {\n     let (notify_po, notify_ch) = pipes::stream();\n \n-    let opts = {\n-        notify_chan: Some(move notify_ch),\n+    let opts = task::TaskOpts {\n+        notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n     do spawn_raw(move opts) {\n@@ -715,9 +716,9 @@ fn test_spawn_raw_notify_failure() {\n     // New bindings for these\n     let (notify_po, notify_ch) = pipes::stream();\n \n-    let opts = {\n+    let opts = task::TaskOpts {\n         linked: false,\n-        notify_chan: Some(move notify_ch),\n+        notify_chan: Some(notify_ch),\n         .. default_task_opts()\n     };\n     do spawn_raw(move opts) {"}, {"sha": "ebfcfd3757739d8376ffb4fa58b8906af3d961a1", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -2027,10 +2027,10 @@ pub mod raw {\n         unboxed: UnboxedVecRepr\n     }\n \n-    pub type SliceRepr = {\n+    pub struct SliceRepr {\n         mut data: *u8,\n         mut len: uint\n-    };\n+    }\n \n     /**\n      * Sets the length of a vector"}, {"sha": "96fce53dd63b41ea7dd30e2217d630a0a6f18e7b", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -287,7 +287,7 @@ fn get_lint_settings_level(settings: lint_settings,\n // This is kind of unfortunate. It should be somewhere else, or we should use\n // a persistent data structure...\n fn clone_lint_modes(modes: lint_modes) -> lint_modes {\n-    smallintmap::SmallIntMap_(@{v: copy modes.v})\n+    smallintmap::SmallIntMap_(@smallintmap::SmallIntMap_ { v: copy modes.v })\n }\n \n type ctxt_ = {dict: lint_dict,"}, {"sha": "eef84ae2422ee7fc81e189a8c28dc6dd4f0f4d98", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -68,7 +68,11 @@ const tydesc_drop_glue_index: size_t = 3 as size_t;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-type Chunk = {data: @[u8], mut fill: uint, is_pod: bool};\n+struct Chunk {\n+    data: @[u8],\n+    mut fill: uint,\n+    is_pod: bool,\n+}\n \n pub struct Arena {\n     // The head is seperated out from the list as a unbenchmarked\n@@ -93,13 +97,19 @@ impl Arena : Drop {\n fn chunk(size: uint, is_pod: bool) -> Chunk {\n     let mut v: @[const u8] = @[];\n     unsafe { at_vec::raw::reserve(&mut v, size); }\n-    { data: unsafe { cast::transmute(v) }, mut fill: 0u, is_pod: is_pod }\n+    Chunk {\n+        data: unsafe { cast::transmute(v) },\n+        fill: 0u,\n+        is_pod: is_pod,\n+    }\n }\n \n pub fn arena_with_size(initial_size: uint) -> Arena {\n-    return Arena {mut head: chunk(initial_size, false),\n-                  mut pod_head: chunk(initial_size, true),\n-                  mut chunks: @Nil};\n+    Arena {\n+        head: chunk(initial_size, false),\n+        pod_head: chunk(initial_size, true),\n+        chunks: @Nil,\n+    }\n }\n \n pub fn Arena() -> Arena {"}, {"sha": "b4217dfb39d4a15dbd2c64a13efa5d6392d22748", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -61,10 +61,12 @@ pub fn create<T: Copy>() -> Deque<T> {\n         match (*elts).get_elt(i) { Some(move t) => t, _ => fail }\n     }\n \n-    type Repr<T> = {mut nelts: uint,\n-                    mut lo: uint,\n-                    mut hi: uint,\n-                    elts: DVec<Cell<T>>};\n+    struct Repr<T> {\n+        mut nelts: uint,\n+        mut lo: uint,\n+        mut hi: uint,\n+        elts: DVec<Cell<T>>,\n+    }\n \n     impl <T: Copy> Repr<T>: Deque<T> {\n         fn size() -> uint { return self.nelts; }\n@@ -119,15 +121,14 @@ pub fn create<T: Copy>() -> Deque<T> {\n         }\n     }\n \n-    let repr: Repr<T> = {\n-        mut nelts: 0u,\n-        mut lo: 0u,\n-        mut hi: 0u,\n-        elts:\n-            dvec::from_vec(\n-                vec::from_elem(initial_capacity, None))\n+    let repr: Repr<T> = Repr {\n+        nelts: 0u,\n+        lo: 0u,\n+        hi: 0u,\n+        elts: dvec::from_vec(vec::from_elem(initial_capacity, None)),\n     };\n-    (move repr) as Deque::<T>\n+\n+    repr as Deque::<T>\n }\n \n #[cfg(test)]\n@@ -254,7 +255,11 @@ mod tests {\n         Onepar(int), Twopar(int, int), Threepar(int, int, int),\n     }\n \n-    type RecCy = {x: int, y: int, t: Taggy};\n+    struct RecCy {\n+        x: int,\n+        y: int,\n+        t: Taggy,\n+    }\n \n     impl Taggy : Eq {\n         pure fn eq(&self, other: &Taggy) -> bool {\n@@ -335,10 +340,10 @@ mod tests {\n \n     #[test]\n     fn test_param_reccy() {\n-        let reccy1: RecCy = {x: 1, y: 2, t: One(1)};\n-        let reccy2: RecCy = {x: 345, y: 2, t: Two(1, 2)};\n-        let reccy3: RecCy = {x: 1, y: 777, t: Three(1, 2, 3)};\n-        let reccy4: RecCy = {x: 19, y: 252, t: Two(17, 42)};\n+        let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+        let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+        let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+        let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n         test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n     }\n }"}, {"sha": "3c890ef06541f4e81613b5c9ca56cc5c12671818", "filename": "src/libstd/map.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -107,7 +107,11 @@ pub trait Map<K:Eq IterBytes Hash Copy, V: Copy> {\n }\n \n pub mod util {\n-    pub type Rational = {num: int, den: int}; // : int::positive(*.den);\n+    pub struct Rational {\n+        // : int::positive(*.den);\n+        num: int,\n+        den: int,\n+    }\n \n     pub pure fn rational_leq(x: Rational, y: Rational) -> bool {\n         // NB: Uses the fact that rationals have positive denominators WLOG:\n@@ -265,9 +269,11 @@ pub mod chained {\n \n                 // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n-                let load = {num: (self.count + 1u) as int,\n-                            den: nchains as int};\n-                if !util::rational_leq(load, {num:3, den:4}) {\n+                let load = util::Rational {\n+                    num: (self.count + 1u) as int,\n+                    den: nchains as int,\n+                };\n+                if !util::rational_leq(load, util::Rational {num:3, den:4}) {\n                     self.rehash();\n                 }\n \n@@ -324,9 +330,11 @@ pub mod chained {\n \n                 // consider rehashing if more 3/4 full\n                 let nchains = vec::len(self.chains);\n-                let load = {num: (self.count + 1u) as int,\n-                            den: nchains as int};\n-                if !util::rational_leq(load, {num:3, den:4}) {\n+                let load = util::Rational {\n+                    num: (self.count + 1u) as int,\n+                    den: nchains as int,\n+                };\n+                if !util::rational_leq(load, util::Rational {num:3, den:4}) {\n                     self.rehash();\n                 }\n "}, {"sha": "84c3b75564984a82572875270f45bda7b1f20da1", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -48,9 +48,9 @@ pub enum IpAddr {\n }\n \n /// Human-friendly feedback on why a parse_addr attempt failed\n-pub type ParseAddrErr = {\n-    err_msg: ~str\n-};\n+pub struct ParseAddrErr {\n+    err_msg: ~str,\n+}\n \n /**\n  * Convert a `IpAddr` to a str\n@@ -122,7 +122,7 @@ pub fn get_addr(node: &str, iotask: iotask)\n                 log(debug, fmt!(\"slice len %?\", len));\n                 let handle = create_uv_getaddrinfo_t();\n                 let handle_ptr = ptr::addr_of(&handle);\n-                let handle_data: GetAddrData = {\n+                let handle_data = GetAddrData {\n                     output_ch: output_ch\n                 };\n                 let handle_data_ptr = ptr::addr_of(&handle_data);\n@@ -187,7 +187,7 @@ pub mod v4 {\n     }\n     // the simple, old style numberic representation of\n     // ipv4\n-    pub type Ipv4Rep = { a: u8, b: u8, c: u8, d:u8 };\n+    pub struct Ipv4Rep { a: u8, b: u8, c: u8, d: u8 }\n \n     pub trait AsUnsafeU32 {\n         unsafe fn as_u32() -> u32;\n@@ -207,14 +207,14 @@ pub mod v4 {\n             }\n         });\n         if parts.len() != 4 {\n-                result::Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-                }\n-        else if parts.contains(&256) {\n-                result::Err(fmt!(\"invalid octal in addr '%s'\", ip))\n-                }\n-        else {\n-            result::Ok({a: parts[0] as u8, b: parts[1] as u8,\n-                        c: parts[2] as u8, d: parts[3] as u8})\n+            Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n+        } else if parts.contains(&256) {\n+            Err(fmt!(\"invalid octal in addr '%s'\", ip))\n+        } else {\n+            Ok(Ipv4Rep {\n+                a: parts[0] as u8, b: parts[1] as u8,\n+                c: parts[2] as u8, d: parts[3] as u8,\n+            })\n         }\n     }\n     pub fn try_parse_addr(ip: &str) -> result::Result<IpAddr,ParseAddrErr> {\n@@ -223,7 +223,7 @@ pub mod v4 {\n             let ip_rep_result = parse_to_ipv4_rep(ip);\n             if result::is_err(&ip_rep_result) {\n                 let err_str = result::get_err(&ip_rep_result);\n-                return result::Err({err_msg: err_str})\n+                return result::Err(ParseAddrErr { err_msg: err_str })\n             }\n             // ipv4_rep.as_u32 is unsafe :/\n             let input_is_inaddr_none =\n@@ -236,15 +236,16 @@ pub mod v4 {\n             let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n             if result::is_err(&ref_ip_rep_result) {\n                 let err_str = result::get_err(&ref_ip_rep_result);\n-                return result::Err({err_msg: err_str})\n+                return Err(ParseAddrErr { err_msg: err_str })\n             }\n+\n             if result::get(&ref_ip_rep_result).as_u32() == INADDR_NONE &&\n                  !input_is_inaddr_none {\n-                return result::Err(\n-                    {err_msg: ~\"uv_ip4_name produced invalid result.\"})\n-            }\n-            else {\n-                result::Ok(Ipv4(copy(new_addr)))\n+                Err(ParseAddrErr {\n+                    err_msg: ~\"uv_ip4_name produced invalid result.\",\n+                })\n+            } else {\n+                Ok(Ipv4(copy(new_addr)))\n             }\n         }\n     }\n@@ -289,19 +290,18 @@ pub mod v6 {\n             // '::' appears to be uv_ip6_name() returns for bogus\n             // parses..\n             if  ip != &\"::\" && reparsed_name == ~\"::\" {\n-                result::Err({err_msg:fmt!(\"failed to parse '%s'\",\n-                                           ip)})\n+                Err(ParseAddrErr { err_msg:fmt!(\"failed to parse '%s'\", ip) })\n             }\n             else {\n-                result::Ok(Ipv6(new_addr))\n+                Ok(Ipv6(new_addr))\n             }\n         }\n     }\n }\n \n-type GetAddrData = {\n+struct GetAddrData {\n     output_ch: oldcomm::Chan<result::Result<~[IpAddr],IpGetAddrErr>>\n-};\n+}\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                       res: *addrinfo) {"}, {"sha": "aa5eec2b43ce2f701ecbf53472e1514daba48ee5", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -83,10 +83,11 @@ pub fn TcpSocketBuf(data: @TcpBufferedSocketData) -> TcpSocketBuf {\n }\n \n /// Contains raw, string-based, error information returned from libuv\n-pub type TcpErrData = {\n+pub struct TcpErrData {\n     err_name: ~str,\n-    err_msg: ~str\n-};\n+    err_msg: ~str,\n+}\n+\n /// Details returned as part of a `result::err` result from `tcp::listen`\n pub enum TcpListenErrData {\n     /**\n@@ -155,7 +156,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n         let reader_po = oldcomm::Port::<result::Result<~[u8], TcpErrData>>();\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-        let socket_data = @{\n+        let socket_data = @TcpSocketData {\n             reader_po: reader_po,\n             reader_ch: oldcomm::Chan(&reader_po),\n             stream_handle_ptr: stream_handle_ptr,\n@@ -231,7 +232,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                         // ip or somesuch\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n                         oldcomm::send((*conn_data_ptr).result_ch,\n-                                   ConnFailure(err_data.to_tcp_err()));\n+                                   ConnFailure(err_data));\n                         uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                                        conn_data_ptr);\n                         uv::ll::close(stream_handle_ptr,\n@@ -243,7 +244,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                     // failure to create a tcp handle\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n                     oldcomm::send((*conn_data_ptr).result_ch,\n-                               ConnFailure(err_data.to_tcp_err()));\n+                               ConnFailure(err_data));\n                   }\n                 }\n             }\n@@ -513,7 +514,7 @@ pub fn accept(new_conn: TcpNewConnection)\n             let iotask = (*server_data_ptr).iotask;\n             let stream_handle_ptr = malloc_uv_tcp_t();\n             *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n-            let client_socket_data = @{\n+            let client_socket_data = @TcpSocketData {\n                 reader_po: reader_po,\n                 reader_ch: oldcomm::Chan(&reader_po),\n                 stream_handle_ptr : stream_handle_ptr,\n@@ -785,7 +786,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n  * A buffered wrapper that you can cast as an `io::reader` or `io::writer`\n  */\n pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n-    TcpSocketBuf(@{ sock: move sock, mut buf: ~[] })\n+    TcpSocketBuf(@TcpBufferedSocketData { sock: sock, buf: ~[] })\n }\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n@@ -979,7 +980,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n             match move read_result {\n               None => {\n                 log(debug, ~\"tcp::read: timed out..\");\n-                let err_data = {\n+                let err_data = TcpErrData {\n                     err_name: ~\"TIMEOUT\",\n                     err_msg: ~\"req timed out\"\n                 };\n@@ -1020,9 +1021,10 @@ fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n                 }\n             }\n         };\n+\n         match oldcomm::recv(stop_po) {\n-          Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n-          None => result::Ok(())\n+          Some(move err_data) => Err(err_data),\n+          None => Ok(())\n         }\n     }\n }\n@@ -1108,8 +1110,8 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         // ownership of everything to the I/O task and let it deal with the\n         // aftermath, so we don't have to sit here blocking.\n         match oldcomm::recv(result_po) {\n-          TcpWriteSuccess => result::Ok(()),\n-          TcpWriteError(ref err_data) => result::Err(err_data.to_tcp_err())\n+            TcpWriteSuccess => Ok(()),\n+            TcpWriteError(move err_data) => Err(err_data)\n         }\n     }\n }\n@@ -1118,15 +1120,15 @@ enum TcpNewConnection {\n     NewTcpConn(*uv::ll::uv_tcp_t)\n }\n \n-type TcpListenFcData = {\n+struct TcpListenFcData {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n     stream_closed_ch: oldcomm::Chan<()>,\n     kill_ch: oldcomm::Chan<Option<TcpErrData>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     ipv6: bool,\n-    mut active: bool\n-};\n+    mut active: bool,\n+}\n \n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n@@ -1191,7 +1193,7 @@ trait ToTcpErr {\n \n impl uv::ll::uv_err_data: ToTcpErr {\n     fn to_tcp_err() -> TcpErrData {\n-        { err_name: self.err_name, err_msg: self.err_msg }\n+        TcpErrData { err_name: self.err_name, err_msg: self.err_msg }\n     }\n }\n \n@@ -1244,9 +1246,9 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n     }\n }\n \n-type TcpSocketCloseData = {\n-    closed_ch: oldcomm::Chan<()>\n-};\n+struct TcpSocketCloseData {\n+    closed_ch: oldcomm::Chan<()>,\n+}\n \n extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n@@ -1273,19 +1275,19 @@ extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n             log(debug, ~\"failure to write\");\n             oldcomm::send((*write_data_ptr).result_ch,\n-                             TcpWriteError(err_data));\n+                             TcpWriteError(err_data.to_tcp_err()));\n         }\n     }\n }\n \n-type WriteReqData = {\n-    result_ch: oldcomm::Chan<TcpWriteResult>\n-};\n+struct WriteReqData {\n+    result_ch: oldcomm::Chan<TcpWriteResult>,\n+}\n \n-type ConnectReqData = {\n+struct ConnectReqData {\n     result_ch: oldcomm::Chan<ConnAttempt>,\n-    closed_signal_ch: oldcomm::Chan<()>\n-};\n+    closed_signal_ch: oldcomm::Chan<()>,\n+}\n \n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n     unsafe {\n@@ -1337,20 +1339,20 @@ enum ConnAttempt {\n     ConnFailure(uv::ll::uv_err_data)\n }\n \n-type TcpSocketData = {\n+struct TcpSocketData {\n     reader_po: oldcomm::Port<result::Result<~[u8], TcpErrData>>,\n     reader_ch: oldcomm::Chan<result::Result<~[u8], TcpErrData>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n     ipv6: bool,\n-    iotask: IoTask\n-};\n+    iotask: IoTask,\n+}\n \n-type TcpBufferedSocketData = {\n+struct TcpBufferedSocketData {\n     sock: TcpSocket,\n-    mut buf: ~[u8]\n-};\n+    mut buf: ~[u8],\n+}\n \n //#[cfg(test)]\n pub mod test {"}, {"sha": "8c6d77c8828384a988bff20cf7c4c1d718c4f838", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 72, "deletions": 66, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -595,12 +595,12 @@ pub mod node {\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n      */\n-    pub type Leaf = {\n+    pub struct Leaf {\n         byte_offset: uint,\n-        byte_len:    uint,\n-        char_len:   uint,\n-        content:    @~str\n-    };\n+        byte_len: uint,\n+        char_len: uint,\n+        content: @~str,\n+    }\n \n     /**\n      * A node obtained from the concatenation of two other nodes\n@@ -619,14 +619,14 @@ pub mod node {\n      *\n      *     Used for rebalancing and to allocate stacks for traversals.\n      */\n-    pub type Concat = {\n+    pub struct Concat {\n         //FIXME (#2744): Perhaps a `vec` instead of `left`/`right`\n-        left:     @Node,\n-        right:    @Node,\n+        left: @Node,\n+        right: @Node,\n         char_len: uint,\n         byte_len: uint,\n-        height:   uint\n-    };\n+        height: uint,\n+    }\n \n     pub enum Node {\n         /// A leaf consisting in a `str`\n@@ -709,11 +709,12 @@ pub mod node {\n     pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n                              char_len: uint) -> @Node {\n         assert(byte_start + byte_len <= str::len(*str));\n-        let candidate = @Leaf({\n-                byte_offset: byte_start,\n-                byte_len:    byte_len,\n-                char_len:    char_len,\n-                content:     str});\n+        let candidate = @Leaf(Leaf {\n+            byte_offset: byte_start,\n+            byte_len: byte_len,\n+            char_len: char_len,\n+            content: str,\n+        });\n         if char_len <= hint_max_leaf_char_len {\n             return candidate;\n         } else {\n@@ -736,11 +737,11 @@ pub mod node {\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n                     str::count_bytes(*str, offset, chunk_char_len);\n-                nodes[i] = @Leaf({\n+                nodes[i] = @Leaf(Leaf {\n                     byte_offset: offset,\n-                    byte_len:    chunk_byte_len,\n-                    char_len:    chunk_char_len,\n-                    content:     str\n+                    byte_len: chunk_byte_len,\n+                    char_len: chunk_char_len,\n+                    content: str,\n                 });\n \n                 offset += chunk_byte_len;\n@@ -767,15 +768,15 @@ pub mod node {\n     pub pure fn byte_len(node: @Node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         match (*node) {\n-          Leaf(y)   => return y.byte_len,\n-          Concat(ref y) => return y.byte_len\n+          Leaf(y) => y.byte_len,\n+          Concat(ref y) => y.byte_len\n         }\n     }\n \n     pub pure fn char_len(node: @Node) -> uint {\n         match (*node) {\n-          Leaf(y)   => return y.char_len,\n-          Concat(ref y) => return y.char_len\n+          Leaf(y) => y.char_len,\n+          Concat(ref y) => y.char_len\n         }\n     }\n \n@@ -867,15 +868,15 @@ pub mod node {\n     pub fn flatten(node: @Node) -> @Node {\n         unsafe {\n             match (*node) {\n-              Leaf(_) => return node,\n-              Concat(ref x) => {\n-                return @Leaf({\n-                    byte_offset: 0u,\n-                    byte_len:    x.byte_len,\n-                    char_len:    x.char_len,\n-                    content:     @serialize_node(node)\n-                })\n-              }\n+                Leaf(_) => node,\n+                Concat(ref x) => {\n+                    @Leaf(Leaf {\n+                        byte_offset: 0u,\n+                        byte_len: x.byte_len,\n+                        char_len: x.char_len,\n+                        content: @serialize_node(node),\n+                    })\n+                }\n             }\n         }\n     }\n@@ -943,10 +944,12 @@ pub mod node {\n               node::Leaf(x) => {\n                 let char_len =\n                     str::count_chars(*x.content, byte_offset, byte_len);\n-                return @Leaf({byte_offset: byte_offset,\n-                                byte_len:    byte_len,\n-                                char_len:    char_len,\n-                                content:     x.content});\n+                return @Leaf(Leaf {\n+                    byte_offset: byte_offset,\n+                    byte_len: byte_len,\n+                    char_len: char_len,\n+                    content: x.content,\n+                });\n               }\n               node::Concat(ref x) => {\n                 let left_len: uint = node::byte_len(x.left);\n@@ -1007,10 +1010,12 @@ pub mod node {\n                     str::count_bytes(*x.content, 0u, char_offset);\n                 let byte_len    =\n                     str::count_bytes(*x.content, byte_offset, char_len);\n-                return @Leaf({byte_offset: byte_offset,\n-                           byte_len:    byte_len,\n-                           char_len:    char_len,\n-                           content:     x.content});\n+                return @Leaf(Leaf {\n+                    byte_offset: byte_offset,\n+                    byte_len: byte_len,\n+                    char_len: char_len,\n+                    content: x.content,\n+                });\n               }\n               node::Concat(ref x) => {\n                 if char_offset == 0u && char_len == x.char_len {return node;}\n@@ -1040,18 +1045,19 @@ pub mod node {\n     }\n \n     pub fn concat2(left: @Node, right: @Node) -> @Node {\n-        return @Concat({left    : left,\n-                     right   : right,\n-             char_len: char_len(left) + char_len(right),\n-                     byte_len: byte_len(left) + byte_len(right),\n-             height: uint::max(height(left), height(right)) + 1u\n-                    })\n+        @Concat(Concat {\n+            left: left,\n+            right: right,\n+            char_len: char_len(left) + char_len(right),\n+            byte_len: byte_len(left) + byte_len(right),\n+            height: uint::max(height(left), height(right)) + 1u,\n+        })\n     }\n \n     pub pure fn height(node: @Node) -> uint {\n         match (*node) {\n-          Leaf(_)   => return 0u,\n-          Concat(ref x) => return x.height\n+          Leaf(_) => 0u,\n+          Concat(ref x) => x.height,\n         }\n     }\n \n@@ -1135,7 +1141,7 @@ pub mod node {\n         loop {\n             match *node {\n               Leaf(x) => return str::char_at(*x.content, pos),\n-              Concat({left, right, _}) => {\n+              Concat(Concat {left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n                        else { pos -= left_len; right };\n@@ -1151,22 +1157,22 @@ pub mod node {\n         use core::prelude::*;\n         use core::vec;\n \n-        pub type T = {\n-            stack:            ~[mut @Node],\n-            mut stackpos: int\n-        };\n+        pub struct T {\n+            stack: ~[mut @Node],\n+            mut stackpos: int,\n+        }\n \n         pub fn empty() -> T {\n             let stack : ~[mut @Node] = ~[mut];\n-            return {stack: move stack, mut stackpos: -1}\n+            T { stack: stack, stackpos: -1 }\n         }\n \n         pub fn start(node: @Node) -> T {\n             let stack = vec::cast_to_mut(\n                 vec::from_elem(height(node)+1u, node));\n-            return {\n-                stack:         move stack,\n-                mut stackpos:  0\n+            T {\n+                stack: stack,\n+                stackpos:  0,\n             }\n         }\n \n@@ -1196,25 +1202,25 @@ pub mod node {\n         use core::prelude::*;\n         use core::str;\n \n-        pub type T = {\n+        pub struct T {\n             leaf_iterator: leaf_iterator::T,\n             mut leaf:  Option<Leaf>,\n-            mut leaf_byte_pos: uint\n-        };\n+            mut leaf_byte_pos: uint,\n+        }\n \n         pub fn start(node: @Node) -> T {\n-            return {\n+            T {\n                 leaf_iterator: leaf_iterator::start(node),\n-                mut leaf:          option::None,\n-                mut leaf_byte_pos: 0u\n+                leaf: option::None,\n+                leaf_byte_pos: 0u,\n             }\n         }\n \n         pub fn empty() -> T {\n-            return {\n+            T {\n                 leaf_iterator: leaf_iterator::empty(),\n-                mut leaf:  option::None,\n-                mut leaf_byte_pos: 0u\n+                leaf:  option::None,\n+                leaf_byte_pos: 0u,\n             }\n         }\n "}, {"sha": "51c209b1b5f476684c2480594a9b8bfaee7774f7", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 60, "deletions": 40, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -284,7 +284,10 @@ mod tests {\n     #[test]\n     fn test() {\n         unsafe {\n-            type Test = {input: ~str, output: ~[u8]};\n+            struct Test {\n+                input: ~str,\n+                output: ~[u8],\n+            }\n \n             fn a_million_letter_a() -> ~str {\n                 let mut i = 0;\n@@ -297,47 +300,64 @@ mod tests {\n             }\n             // Test messages from FIPS 180-1\n \n-            let fips_180_1_tests: ~[Test] =\n-                ~[{input: ~\"abc\",\n-                  output:\n-                      ~[0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                       0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                       0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                       0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                       0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n-                 {input:\n-                      ~\"abcdbcdecdefdefgefghfghighij\" +\n-                      ~\"hijkijkljklmklmnlmnomnopnopq\",\n-                  output:\n-                      ~[0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                       0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                       0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                       0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                       0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n-                 {input: a_million_letter_a(),\n-                  output:\n-                      ~[0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                       0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                       0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                       0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                       0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n+            let fips_180_1_tests = ~[\n+                Test {\n+                    input: ~\"abc\",\n+                    output: ~[\n+                        0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                        0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                        0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                        0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                        0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                    ],\n+                },\n+                Test {\n+                    input:\n+                         ~\"abcdbcdecdefdefgefghfghighij\" +\n+                         ~\"hijkijkljklmklmnlmnomnopnopq\",\n+                    output: ~[\n+                        0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                        0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                        0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                        0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                        0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                    ],\n+                },\n+                Test {\n+                    input: a_million_letter_a(),\n+                    output: ~[\n+                        0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                        0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                        0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                        0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                        0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n+                    ],\n+                },\n+            ];\n             // Examples from wikipedia\n \n-            let wikipedia_tests: ~[Test] =\n-                ~[{input: ~\"The quick brown fox jumps over the lazy dog\",\n-                  output:\n-                      ~[0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                       0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                       0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                       0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                       0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n-                 {input: ~\"The quick brown fox jumps over the lazy cog\",\n-                  output:\n-                      ~[0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                       0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                       0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                       0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                       0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n+            let wikipedia_tests = ~[\n+                Test {\n+                    input: ~\"The quick brown fox jumps over the lazy dog\",\n+                    output: ~[\n+                        0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                        0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                        0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                        0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                        0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                    ],\n+                },\n+                Test {\n+                    input: ~\"The quick brown fox jumps over the lazy cog\",\n+                    output: ~[\n+                        0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                        0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                        0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                        0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                        0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                    ],\n+                },\n+            ];\n             let tests = fips_180_1_tests + wikipedia_tests;\n             fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n                 assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));"}, {"sha": "feabb678d6686e05128bae31eb0d0a280adf97f7", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -25,7 +25,9 @@ use core::prelude::*;\n \n // FIXME (#2347): Should not be @; there's a bug somewhere in rustc that\n // requires this to be.\n-type SmallIntMap_<T: Copy> = {v: DVec<Option<T>>};\n+struct SmallIntMap_<T: Copy> {\n+    v: DVec<Option<T>>,\n+}\n \n pub enum SmallIntMap<T:Copy> {\n     SmallIntMap_(@SmallIntMap_<T>)\n@@ -34,7 +36,7 @@ pub enum SmallIntMap<T:Copy> {\n /// Create a smallintmap\n pub fn mk<T: Copy>() -> SmallIntMap<T> {\n     let v = DVec();\n-    return SmallIntMap_(@{v: move v});\n+    SmallIntMap_(@SmallIntMap_ { v: v } )\n }\n \n /**"}, {"sha": "7b94702f974b4b371c14b36d9557baa796249982", "filename": "src/libstd/test.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -74,8 +74,11 @@ pub fn test_main(args: &[~str], tests: &[TestDesc]) {\n     if !run_tests_console(&opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n-pub type TestOpts = {filter: Option<~str>, run_ignored: bool,\n-                  logfile: Option<~str>};\n+pub struct TestOpts {\n+    filter: Option<~str>,\n+    run_ignored: bool,\n+    logfile: Option<~str>,\n+}\n \n type OptRes = Either<TestOpts, ~str>;\n \n@@ -97,10 +100,13 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n     let run_ignored = getopts::opt_present(&matches, ~\"ignored\");\n     let logfile = getopts::opt_maybe_str(&matches, ~\"logfile\");\n \n-    let test_opts = {filter: filter, run_ignored: run_ignored,\n-                     logfile: logfile};\n+    let test_opts = TestOpts {\n+        filter: filter,\n+        run_ignored: run_ignored,\n+        logfile: logfile,\n+    };\n \n-    return either::Left(test_opts);\n+    either::Left(test_opts)\n }\n \n #[deriving_eq]\n@@ -396,7 +402,10 @@ pub fn filter_tests(opts: &TestOpts,\n     move filtered\n }\n \n-type TestFuture = {test: TestDesc, wait: fn@() -> TestResult};\n+struct TestFuture {\n+    test: TestDesc,\n+    wait: fn@() -> TestResult,\n+}\n \n pub fn run_test(test: TestDesc, monitor_ch: oldcomm::Chan<MonitorMsg>) {\n     if test.ignore {\n@@ -431,7 +440,7 @@ mod tests {\n     #[legacy_exports];\n \n     use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc};\n-    use test::{run_test};\n+    use test::{TestOpts, run_test};\n \n     use core::either;\n     use core::oldcomm;\n@@ -528,13 +537,26 @@ mod tests {\n         // When we run ignored tests the test filter should filter out all the\n         // unignored tests and flip the ignore flag on the rest to false\n \n-        let opts = {filter: option::None, run_ignored: true,\n-            logfile: option::None};\n-        let tests =\n-            ~[TestDesc {name: ~\"1\", testfn: fn~() { },\n-                        ignore: true, should_fail: false},\n-              TestDesc {name: ~\"2\", testfn: fn~() { },\n-                        ignore: false, should_fail: false}];\n+        let opts = TestOpts {\n+            filter: option::None,\n+            run_ignored: true,\n+            logfile: option::None,\n+        };\n+\n+        let tests = ~[\n+            TestDesc {\n+                name: ~\"1\",\n+                testfn: fn~() { },\n+                ignore: true,\n+                should_fail: false,\n+            },\n+            TestDesc {\n+                name: ~\"2\",\n+                testfn: fn~() { },\n+                ignore: false,\n+                should_fail: false,\n+            },\n+        ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n@@ -544,8 +566,11 @@ mod tests {\n \n     #[test]\n     fn sort_tests() {\n-        let opts = {filter: option::None, run_ignored: false,\n-            logfile: option::None};\n+        let opts = TestOpts {\n+            filter: option::None,\n+            run_ignored: false,\n+            logfile: option::None,\n+        };\n \n         let names =\n             ~[~\"sha1::test\", ~\"int::test_to_str\", ~\"int::test_pow\","}, {"sha": "731767d475faa0d9b0d20b1d78ec7e01fd4672e4", "filename": "src/libstd/time.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -902,7 +902,6 @@ mod tests {\n     use core::uint;\n     use core::vec;\n \n-    #[test]\n     fn test_get_time() {\n         const some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n         const some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n@@ -926,7 +925,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n     fn test_precise_time() {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n@@ -944,7 +942,6 @@ mod tests {\n         assert ns2 >= ns1;\n     }\n \n-    #[test]\n     fn test_at_utc() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -966,7 +963,6 @@ mod tests {\n         assert utc.tm_nsec == 54321_i32;\n     }\n \n-    #[test]\n     fn test_at() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -995,7 +991,6 @@ mod tests {\n         assert local.tm_nsec == 54321_i32;\n     }\n \n-    #[test]\n     fn test_to_timespec() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -1007,7 +1002,6 @@ mod tests {\n         assert utc.to_local().to_timespec() == time;\n     }\n \n-    #[test]\n     fn test_conversions() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -1024,7 +1018,6 @@ mod tests {\n         assert utc.to_local().to_utc() == utc;\n     }\n \n-    #[test]\n     fn test_strptime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -1179,8 +1172,6 @@ mod tests {\n         assert test(~\"%\", ~\"%%\");\n     }\n \n-    #[test]\n-    #[ignore(reason = \"randomred\")]\n     fn test_ctime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -1195,8 +1186,6 @@ mod tests {\n         assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";\n     }\n \n-    #[test]\n-    #[ignore(reason = \"randomred\")]\n     fn test_strftime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n@@ -1270,7 +1259,6 @@ mod tests {\n         assert utc.rfc3339() == ~\"2009-02-13T23:31:30Z\";\n     }\n \n-    #[test]\n     fn test_timespec_eq_ord() {\n         use core::cmp::{eq, ge, gt, le, lt, ne};\n \n@@ -1303,4 +1291,20 @@ mod tests {\n         assert gt(c, b);\n         assert gt(d, c);\n     }\n+\n+    #[test]\n+    fn run_tests() {\n+        // The tests race on tzset. So instead of having many independent\n+        // tests, we will just call the functions now.\n+        test_get_time();\n+        test_precise_time();\n+        test_at_utc();\n+        test_at();\n+        test_to_timespec();\n+        test_conversions();\n+        test_strptime();\n+        test_ctime();\n+        test_strftime();\n+        test_timespec_eq_ord();\n+    }\n }"}, {"sha": "0a3d64a02a4eab4862a81a1b67b2e171a11ae886", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -111,7 +111,7 @@ fn run_loop(iotask_ch: Chan<IoTask>) {\n         ll::async_init(loop_ptr, async_handle, wake_up_cb);\n \n         // initialize our loop data and store it in the loop\n-        let data: IoTaskLoopData = {\n+        let data = IoTaskLoopData {\n             async_handle: async_handle,\n             msg_po: Port()\n         };\n@@ -134,10 +134,10 @@ fn run_loop(iotask_ch: Chan<IoTask>) {\n }\n \n // data that lives for the lifetime of the high-evel oo\n-type IoTaskLoopData = {\n+struct IoTaskLoopData {\n     async_handle: *ll::uv_async_t,\n-    msg_po: Port<IoTaskMsg>\n-};\n+    msg_po: Port<IoTaskMsg>,\n+}\n \n fn send_msg(iotask: IoTask, msg: IoTaskMsg) {\n     unsafe {\n@@ -214,10 +214,10 @@ mod test {\n             ll::close(handle, async_close_cb);\n         }\n     }\n-    type AhData = {\n+    struct AhData {\n         iotask: IoTask,\n-        exit_ch: oldcomm::Chan<()>\n-    };\n+        exit_ch: oldcomm::Chan<()>,\n+    }\n     fn impl_uv_iotask_async(iotask: IoTask) {\n         unsafe {\n             let async_handle = ll::async_t();"}, {"sha": "5060ae1a7227934b15e5abc7a00c9866b344def3", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 243, "deletions": 188, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -41,10 +41,10 @@ use core::str;\n use core::vec;\n \n // libuv struct mappings\n-pub type uv_ip4_addr = {\n+pub struct uv_ip4_addr {\n     ip: ~[u8],\n-    port: int\n-};\n+    port: int,\n+}\n pub type uv_ip6_addr = uv_ip4_addr;\n \n pub enum uv_handle_type {\n@@ -67,31 +67,31 @@ pub enum uv_handle_type {\n \n pub type handle_type = libc::c_uint;\n \n-pub type uv_handle_fields = {\n+pub struct uv_handle_fields {\n    loop_handle: *libc::c_void,\n    type_: handle_type,\n    close_cb: *u8,\n    mut data: *libc::c_void,\n-};\n+}\n \n // unix size: 8\n-pub type uv_err_t = {\n+pub struct uv_err_t {\n     code: libc::c_int,\n     sys_errno_: libc::c_int\n-};\n+}\n \n // don't create one of these directly. instead,\n // count on it appearing in libuv callbacks or embedded\n // in other types as a pointer to be used in other\n // operations (so mostly treat it as opaque, once you\n // have it in this form..)\n-pub type uv_stream_t = {\n-    fields: uv_handle_fields\n-};\n+pub struct uv_stream_t {\n+    fields: uv_handle_fields,\n+}\n \n // 64bit unix size: 272\n #[cfg(unix)]\n-pub type uv_tcp_t = {\n+pub struct uv_tcp_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n@@ -101,191 +101,191 @@ pub type uv_tcp_t = {\n     a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n     a24: *u8, a25: *u8, a26: *u8, a27: *u8,\n     a28: *u8,\n-    a30: uv_tcp_t_32bit_unix_riders\n-};\n+    a30: uv_tcp_t_32bit_unix_riders,\n+}\n // 32bit unix size: 328 (164)\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_tcp_t_32bit_unix_riders = {\n-    a29: *u8\n-};\n+pub struct uv_tcp_t_32bit_unix_riders {\n+    a29: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_tcp_t_32bit_unix_riders = {\n+pub struct uv_tcp_t_32bit_unix_riders {\n     a29: *u8, a30: *u8, a31: *u8,\n     a32: *u8, a33: *u8, a34: *u8,\n-    a35: *u8, a36: *u8\n-};\n+    a35: *u8, a36: *u8,\n+}\n \n // 32bit win32 size: 240 (120)\n #[cfg(windows)]\n-pub type uv_tcp_t = {\n+pub struct uv_tcp_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n     a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n     a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n     a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n-    a24: *u8, a25: *u8\n-};\n+    a24: *u8, a25: *u8,\n+}\n \n // unix size: 48\n #[cfg(unix)]\n-pub type uv_connect_t = {\n+pub struct uv_connect_t {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-    a04: *u8, a05: *u8\n-};\n+    a04: *u8, a05: *u8,\n+}\n // win32 size: 88 (44)\n #[cfg(windows)]\n-pub type uv_connect_t = {\n+pub struct uv_connect_t {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8\n-};\n+    a08: *u8, a09: *u8, a10: *u8,\n+}\n \n // unix size: 16\n-pub type uv_buf_t = {\n+pub struct uv_buf_t {\n     base: *u8,\n-    len: libc::size_t\n-};\n+    len: libc::size_t,\n+}\n // no gen stub method.. should create\n // it via uv::direct::buf_init()\n \n // unix size: 144\n #[cfg(unix)]\n-pub type uv_write_t = {\n+pub struct uv_write_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n     a12: *u8,\n-    a14: uv_write_t_32bit_unix_riders\n-};\n+    a14: uv_write_t_32bit_unix_riders,\n+}\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_write_t_32bit_unix_riders = {\n-    a13: *u8\n-};\n+pub struct uv_write_t_32bit_unix_riders {\n+    a13: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_write_t_32bit_unix_riders = {\n-    a13: *u8, a14: *u8\n-};\n+pub struct uv_write_t_32bit_unix_riders {\n+    a13: *u8, a14: *u8,\n+}\n // win32 size: 136 (68)\n #[cfg(windows)]\n-pub type uv_write_t = {\n+pub struct uv_write_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8\n-};\n+    a12: *u8,\n+}\n // 64bit unix size: 120\n // 32bit unix size: 152 (76)\n #[cfg(unix)]\n-pub type uv_async_t = {\n+pub struct uv_async_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8,\n-    a11: uv_async_t_32bit_unix_riders\n-};\n+    a11: uv_async_t_32bit_unix_riders,\n+}\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_async_t_32bit_unix_riders = {\n-    a10: *u8\n-};\n+pub struct uv_async_t_32bit_unix_riders {\n+    a10: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_async_t_32bit_unix_riders = {\n-    a10: *u8, a11: *u8, a12: *u8, a13: *u8\n-};\n+pub struct uv_async_t_32bit_unix_riders {\n+    a10: *u8, a11: *u8, a12: *u8, a13: *u8,\n+}\n // win32 size 132 (68)\n #[cfg(windows)]\n-pub type uv_async_t = {\n+pub struct uv_async_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n-    a12: *u8\n-};\n+    a12: *u8,\n+}\n \n // 64bit unix size: 128\n // 32bit unix size: 84\n #[cfg(unix)]\n-pub type uv_timer_t = {\n+pub struct uv_timer_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n     a08: *u8, a09: *u8,\n-    a11: uv_timer_t_32bit_unix_riders\n-};\n+    a11: uv_timer_t_32bit_unix_riders,\n+}\n #[cfg(target_arch=\"x86_64\")]\n-pub type uv_timer_t_32bit_unix_riders = {\n-    a10: *u8, a11: *u8\n-};\n+pub struct uv_timer_t_32bit_unix_riders {\n+    a10: *u8, a11: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type uv_timer_t_32bit_unix_riders = {\n+pub struct uv_timer_t_32bit_unix_riders {\n     a10: *u8, a11: *u8, a12: *u8, a13: *u8,\n-    a14: *u8, a15: *u8, a16: *u8\n-};\n+    a14: *u8, a15: *u8, a16: *u8,\n+}\n // win32 size: 64\n #[cfg(windows)]\n-pub type uv_timer_t = {\n+pub struct uv_timer_t {\n     fields: uv_handle_fields,\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n     a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n-    a08: *u8, a09: *u8, a10: *u8, a11: *u8\n-};\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+}\n \n // unix size: 16\n-pub type sockaddr_in = {\n+pub struct sockaddr_in {\n     mut sin_family: u16,\n     mut sin_port: u16,\n     mut sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n-    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8)\n-};\n+    mut sin_zero: (u8, u8, u8, u8, u8, u8, u8, u8),\n+}\n \n // unix size: 28 .. FIXME #1645\n // stuck with 32 becuse of rust padding structs?\n #[cfg(target_arch=\"x86_64\")]\n-pub type sockaddr_in6 = {\n+pub struct sockaddr_in6 {\n     a0: *u8, a1: *u8,\n-    a2: *u8, a3: *u8\n-};\n+    a2: *u8, a3: *u8,\n+}\n #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-pub type sockaddr_in6 = {\n+pub struct sockaddr_in6 {\n     a0: *u8, a1: *u8,\n     a2: *u8, a3: *u8,\n     a4: *u8, a5: *u8,\n-    a6: *u8, a7: *u8\n-};\n+    a6: *u8, a7: *u8,\n+}\n \n // unix size: 28 .. FIXME #1645\n // stuck with 32 becuse of rust padding structs?\n pub type addr_in = addr_in_impl::addr_in;\n #[cfg(unix)]\n pub mod addr_in_impl {\n     #[cfg(target_arch=\"x86_64\")]\n-    pub type addr_in = {\n+    pub struct addr_in {\n         a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8\n-    };\n+        a2: *u8, a3: *u8,\n+    }\n     #[cfg(target_arch=\"x86\")]\n #[cfg(target_arch=\"arm\")]\n-    pub type addr_in = {\n+    pub struct addr_in {\n         a0: *u8, a1: *u8,\n         a2: *u8, a3: *u8,\n         a4: *u8, a5: *u8,\n         a6: *u8, a7: *u8,\n-    };\n+    }\n }\n #[cfg(windows)]\n pub mod addr_in_impl {\n-    pub type addr_in = {\n+    pub struct addr_in {\n         a0: *u8, a1: *u8,\n-        a2: *u8, a3: *u8\n-    };\n+        a2: *u8, a3: *u8,\n+    }\n }\n \n // unix size: 48, 32bit: 32\n@@ -294,42 +294,60 @@ pub type addrinfo = addrinfo_impl::addrinfo;\n #[cfg(target_os=\"android\")]\n pub mod addrinfo_impl {\n     #[cfg(target_arch=\"x86_64\")]\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8\n-    };\n+        a04: *u8, a05: *u8,\n+    }\n     #[cfg(target_arch=\"x86\")]\n     #[cfg(target_arch=\"arm\")]\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8, a06: *u8, a07: *u8\n-    };\n+        a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    }\n }\n #[cfg(target_os=\"macos\")]\n #[cfg(target_os=\"freebsd\")]\n pub mod addrinfo_impl {\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8\n-    };\n+        a04: *u8, a05: *u8,\n+    }\n }\n #[cfg(windows)]\n pub mod addrinfo_impl {\n-    pub type addrinfo = {\n+    pub struct addrinfo {\n         a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n-        a04: *u8, a05: *u8\n-    };\n+        a04: *u8, a05: *u8,\n+    }\n }\n \n // unix size: 72\n-pub type uv_getaddrinfo_t = {\n+pub struct uv_getaddrinfo_t {\n     a00: *u8, a01: *u8, a02: *u8, a03: *u8, a04: *u8, a05: *u8,\n-    a06: *u8, a07: *u8, a08: *u8\n-};\n+    a06: *u8, a07: *u8, a08: *u8,\n+}\n \n pub mod uv_ll_struct_stubgen {\n-    use uv_ll::{uv_async_t, uv_connect_t, uv_getaddrinfo_t, uv_tcp_t};\n-    use uv_ll::{uv_timer_t, uv_write_t};\n+    use uv_ll::{\n+        uv_async_t,\n+        uv_connect_t,\n+        uv_getaddrinfo_t,\n+        uv_handle_fields,\n+        uv_tcp_t,\n+        uv_timer_t,\n+        uv_write_t,\n+    };\n+\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"android\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    use uv_ll::{\n+        uv_async_t_32bit_unix_riders,\n+        uv_tcp_t_32bit_unix_riders,\n+        uv_timer_t_32bit_unix_riders,\n+        uv_write_t_32bit_unix_riders,\n+    };\n \n     use core::ptr;\n \n@@ -343,9 +361,12 @@ pub mod uv_ll_struct_stubgen {\n             return gen_stub_arch();\n             #[cfg(target_arch=\"x86_64\")]\n             pub fn gen_stub_arch() -> uv_tcp_t {\n-                return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                                close_cb: ptr::null(),\n-                                mut data: ptr::null() },\n+                uv_tcp_t {\n+                    fields: uv_handle_fields {\n+                        loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        data: ptr::null(),\n+                    },\n                     a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                     a03: 0 as *u8,\n                     a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -361,17 +382,18 @@ pub mod uv_ll_struct_stubgen {\n                     a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8,\n                     a27: 0 as *u8,\n                     a28: 0 as *u8,\n-                    a30: {\n-                        a29: 0 as *u8\n-                    }\n-                };\n+                    a30: uv_tcp_t_32bit_unix_riders { a29: 0 as *u8 },\n+                }\n             }\n             #[cfg(target_arch=\"x86\")]\n             #[cfg(target_arch=\"arm\")]\n             pub fn gen_stub_arch() -> uv_tcp_t {\n-                return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                                close_cb: ptr::null(),\n-                                mut data: ptr::null() },\n+                uv_tcp_t {\n+                    fields: uv_handle_fields {\n+                        loop_handle: ptr::null(), type_: 0u32,\n+                        close_cb: ptr::null(),\n+                        data: ptr::null(),\n+                    },\n                     a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                     a03: 0 as *u8,\n                     a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -387,19 +409,22 @@ pub mod uv_ll_struct_stubgen {\n                     a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8,\n                     a27: 0 as *u8,\n                     a28: 0 as *u8,\n-                    a30: {\n+                    a30: uv_tcp_t_32bit_unix_riders {\n                         a29: 0 as *u8, a30: 0 as *u8, a31: 0 as *u8,\n                         a32: 0 as *u8, a33: 0 as *u8, a34: 0 as *u8,\n-                        a35: 0 as *u8, a36: 0 as *u8\n-                    }\n-                };\n+                        a35: 0 as *u8, a36: 0 as *u8,\n+                    },\n+                }\n             }\n         }\n         #[cfg(windows)]\n         pub fn gen_stub_os() -> uv_tcp_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_tcp_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -412,58 +437,62 @@ pub mod uv_ll_struct_stubgen {\n                 a19: 0 as *u8,\n                 a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8,\n                 a23: 0 as *u8,\n-                a24: 0 as *u8, a25: 0 as *u8\n-            };\n+                a24: 0 as *u8, a25: 0 as *u8,\n+            }\n         }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        return {\n+        uv_connect_t {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n-            a04: 0 as *u8, a05: 0 as *u8\n-        };\n+            a04: 0 as *u8, a05: 0 as *u8,\n+        }\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_connect_t() -> uv_connect_t {\n-        return {\n+        uv_connect_t {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n             a07: 0 as *u8,\n-            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8\n-        };\n+            a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n+        }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_async_t() -> uv_async_t {\n         return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n         pub fn gen_stub_arch() -> uv_async_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_async_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n-                    a10: 0 as *u8\n-                }\n-            };\n+                a11: uv_async_t_32bit_unix_riders { a10: 0 as *u8 },\n+            }\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         pub fn gen_stub_arch() -> uv_async_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_async_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n+                a11: uv_async_t_32bit_unix_riders {\n                     a10: 0 as *u8, a11: 0 as *u8,\n                     a12: 0 as *u8, a13: 0 as *u8\n                 }\n@@ -472,107 +501,133 @@ pub mod uv_ll_struct_stubgen {\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_async_t() -> uv_async_t {\n-        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        mut data: ptr::null() },\n+        uv_async_t {\n+            fields: uv_handle_fields {\n+                loop_handle: ptr::null(), type_: 0u32,\n+                close_cb: ptr::null(),\n+                data: ptr::null(),\n+            },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n             a07: 0 as *u8,\n             a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n             a11: 0 as *u8,\n-            a12: 0 as *u8\n-        };\n+            a12: 0 as *u8,\n+        }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n         return gen_stub_arch();\n         #[cfg(target_arch = \"x86_64\")]\n         pub fn gen_stub_arch() -> uv_timer_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_timer_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n+                a11: uv_timer_t_32bit_unix_riders {\n                     a10: 0 as *u8, a11: 0 as *u8\n-                }\n-            };\n+                },\n+            }\n         }\n         #[cfg(target_arch = \"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         pub fn gen_stub_arch() -> uv_timer_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_timer_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8,\n-                a11: {\n+                a11: uv_timer_t_32bit_unix_riders {\n                     a10: 0 as *u8, a11: 0 as *u8,\n                     a12: 0 as *u8, a13: 0 as *u8,\n                     a14: 0 as *u8, a15: 0 as *u8,\n-                    a16: 0 as *u8\n-                }\n-            };\n+                    a16: 0 as *u8,\n+                },\n+            }\n         }\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_timer_t() -> uv_timer_t {\n-        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        mut data: ptr::null() },\n+        uv_timer_t {\n+            fields: uv_handle_fields {\n+                loop_handle: ptr::null(), type_: 0u32,\n+                close_cb: ptr::null(),\n+                data: ptr::null(),\n+            },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n             a07: 0 as *u8,\n             a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n-            a11: 0 as *u8\n-        };\n+            a11: 0 as *u8,\n+        }\n     }\n     #[cfg(unix)]\n     pub fn gen_stub_uv_write_t() -> uv_write_t {\n         return gen_stub_arch();\n         #[cfg(target_arch=\"x86_64\")]\n         pub fn gen_stub_arch() -> uv_write_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_write_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n                 a11: 0 as *u8,\n-                a12: 0 as *u8, a14: { a13: 0 as *u8 }\n-            };\n+                a12: 0 as *u8,\n+                a14: uv_write_t_32bit_unix_riders { a13: 0 as *u8 },\n+            }\n         }\n         #[cfg(target_arch=\"x86\")]\n         #[cfg(target_arch=\"arm\")]\n         pub fn gen_stub_arch() -> uv_write_t {\n-            return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                            close_cb: ptr::null(),\n-                            mut data: ptr::null() },\n+            uv_write_t {\n+                fields: uv_handle_fields {\n+                    loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    data: ptr::null(),\n+                },\n                 a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n                 a03: 0 as *u8,\n                 a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n                 a07: 0 as *u8,\n                 a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8,\n                 a11: 0 as *u8,\n-                a12: 0 as *u8, a14: { a13: 0 as *u8, a14: 0 as *u8 }\n+                a12: 0 as *u8,\n+                a14: uv_write_t_32bit_unix_riders {\n+                    a13: 0 as *u8,\n+                    a14: 0 as *u8,\n+                }\n             };\n         }\n     }\n     #[cfg(windows)]\n     pub fn gen_stub_uv_write_t() -> uv_write_t {\n-        return { fields: { loop_handle: ptr::null(), type_: 0u32,\n-                        close_cb: ptr::null(),\n-                        mut data: ptr::null() },\n+        uv_write_t {\n+            fields: uv_handle_fields {\n+                loop_handle: ptr::null(), type_: 0u32,\n+                close_cb: ptr::null(),\n+                data: ptr::null(),\n+            },\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8,\n             a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8,\n@@ -583,7 +638,7 @@ pub mod uv_ll_struct_stubgen {\n         };\n     }\n     pub fn gen_stub_uv_getaddrinfo_t() -> uv_getaddrinfo_t {\n-        {\n+        uv_getaddrinfo_t {\n             a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n             a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n             a08: 0 as *u8\n@@ -851,7 +906,7 @@ pub unsafe fn async_send(async_handle: *uv_async_t) {\n     return rustrt::rust_uv_async_send(async_handle);\n }\n pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n+    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(&out_buf);\n     log(debug, fmt!(\"buf_init - input %u len %u out_buf: %u\",\n                      input as uint,\n@@ -1043,13 +1098,13 @@ pub unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n     let err_ptr = ptr::addr_of(&err);\n     let err_name = str::raw::from_c_str(err_name(err_ptr));\n     let err_msg = str::raw::from_c_str(strerror(err_ptr));\n-    { err_name: err_name, err_msg: err_msg }\n+    uv_err_data { err_name: err_name, err_msg: err_msg }\n }\n \n-pub type uv_err_data = {\n+pub struct uv_err_data {\n     err_name: ~str,\n-    err_msg: ~str\n-};\n+    err_msg: ~str,\n+}\n \n pub unsafe fn is_ipv4_addrinfo(input: *addrinfo) -> bool {\n     rustrt::rust_uv_is_ipv4_addrinfo(input)\n@@ -1090,11 +1145,11 @@ pub mod test {\n         tcp_read_error\n     }\n \n-    type request_wrapper = {\n+    struct request_wrapper {\n         write_req: *uv_write_t,\n         req_buf: *~[uv_buf_t],\n-        read_chan: *oldcomm::Chan<~str>\n-    };\n+        read_chan: *oldcomm::Chan<~str>,\n+    }\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n         log(debug, fmt!(\"after uv_close! handle ptr: %?\",\n@@ -1424,18 +1479,18 @@ pub mod test {\n         }\n     }\n \n-    type tcp_server_data = {\n+    struct tcp_server_data {\n         client: *uv_tcp_t,\n         server: *uv_tcp_t,\n         server_kill_msg: ~str,\n         server_resp_buf: *~[uv_buf_t],\n         server_chan: *oldcomm::Chan<~str>,\n-        server_write_req: *uv_write_t\n-    };\n+        server_write_req: *uv_write_t,\n+    }\n \n-    type async_handle_data = {\n-        continue_chan: *oldcomm::Chan<bool>\n-    };\n+    struct async_handle_data {\n+        continue_chan: *oldcomm::Chan<bool>,\n+    }\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n         log(debug, fmt!(\"SERVER: closing async cb... h: %?\",\n@@ -1489,7 +1544,7 @@ pub mod test {\n                 { continue_chan: continue_chan };\n             let async_data_ptr = ptr::addr_of(&async_data);\n \n-            let server_data: tcp_server_data = {\n+            let server_data = tcp_server_data {\n                 client: tcp_client_ptr,\n                 server: tcp_server_ptr,\n                 server_kill_msg: kill_server_msg,"}, {"sha": "77f230311358e8a851927c96ed9b6515572ca053", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 75, "deletions": 182, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -130,20 +130,6 @@ fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_ty(\n-                    @ast::Ty {node: ast::ty_rec(ref fields), _},\n-                    tps\n-                ) => {\n-                    let ser_impl = mk_rec_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*fields),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n                 ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n@@ -199,20 +185,6 @@ fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_ty(\n-                    @ast::Ty {node: ast::ty_rec(ref fields), _},\n-                    tps\n-                ) => {\n-                    let deser_impl = mk_rec_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*fields),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n                 ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n@@ -693,67 +665,48 @@ fn mk_deser_method(\n     }\n }\n \n-fn mk_rec_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[ast::ty_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `__s.emit_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_rec\")\n-        ),\n-        ~[cx.lambda_stmts(span, fields)]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_rec_deser_impl(\n+fn mk_struct_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    fields: ~[ast::ty_field],\n+    fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n ) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `read_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_rec\")\n-        ),\n-        ~[\n-            cx.lambda_expr(\n-                cx.expr(\n+    let fields = do mk_struct_fields(fields).mapi |idx, field| {\n+        // ast for `|| self.$(name).encode(__s)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n                     span,\n-                    ast::expr_rec(fields, None)\n-                )\n+                    cx.expr_field(\n+                        span,\n+                        cx.expr_var(span, ~\"self\"),\n+                        field.ident\n+                    ),\n+                    cx.ident_of(~\"encode\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n             )\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n+        );\n \n-fn mk_struct_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n+        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_var(span, ~\"__s\"),\n+                    cx.ident_of(~\"emit_field\")\n+                ),\n+                ~[\n+                    cx.lit_str(span, @cx.str_of(field.ident)),\n+                    cx.lit_uint(span, idx),\n+                    expr_lambda,\n+                ]\n+            )\n+        )\n+    };\n \n     // ast for `__s.emit_struct($(name), || $(fields))`\n     let ser_body = cx.expr_call(\n@@ -780,7 +733,47 @@ fn mk_struct_deser_impl(\n     fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n ) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n+    let fields = do mk_struct_fields(fields).mapi |idx, field| {\n+        // ast for `|| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda(\n+            cx.expr_blk(\n+                cx.expr_call(\n+                    span,\n+                    cx.expr_path_global(span, ~[\n+                        cx.ident_of(~\"std\"),\n+                        cx.ident_of(~\"serialize\"),\n+                        cx.ident_of(~\"Decodable\"),\n+                        cx.ident_of(~\"decode\"),\n+                    ]),\n+                    ~[cx.expr_var(span, ~\"__d\")]\n+                )\n+            )\n+        );\n+\n+        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        let expr: @ast::expr = cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_field\")\n+            ),\n+            ~[\n+                cx.lit_str(span, @cx.str_of(field.ident)),\n+                cx.lit_uint(span, idx),\n+                expr_lambda,\n+            ]\n+        );\n+\n+        ast::spanned {\n+            node: ast::field_ {\n+                mutbl: field.mutbl,\n+                ident: field.ident,\n+                expr: expr,\n+            },\n+            span: span,\n+        }\n+    };\n \n     // ast for `read_struct($(name), || $(fields))`\n     let body = cx.expr_call(\n@@ -818,16 +811,6 @@ struct field {\n     mutbl: ast::mutability,\n }\n \n-fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n-    do fields.map |field| {\n-        field {\n-            span: field.span,\n-            ident: field.node.ident,\n-            mutbl: field.node.mt.mutbl,\n-        }\n-    }\n-}\n-\n fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n     do fields.map |field| {\n         let (ident, mutbl) = match field.node.kind {\n@@ -847,96 +830,6 @@ fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n     }\n }\n \n-fn mk_ser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[field]\n-) -> ~[@ast::stmt] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| self.$(name).encode(__s)`\n-        let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_field(\n-                        span,\n-                        cx.expr_var(span, ~\"self\"),\n-                        field.ident\n-                    ),\n-                    cx.ident_of(~\"encode\")\n-                ),\n-                ~[cx.expr_var(span, ~\"__s\")]\n-            )\n-        );\n-\n-        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_field\")\n-                ),\n-                ~[\n-                    cx.lit_str(span, @cx.str_of(field.ident)),\n-                    cx.lit_uint(span, idx),\n-                    expr_lambda,\n-                ]\n-            )\n-        )\n-    }\n-}\n-\n-fn mk_deser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[field]\n-) -> ~[ast::field] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda(\n-            cx.expr_blk(\n-                cx.expr_call(\n-                    span,\n-                    cx.expr_path_global(span, ~[\n-                        cx.ident_of(~\"std\"),\n-                        cx.ident_of(~\"serialize\"),\n-                        cx.ident_of(~\"Decodable\"),\n-                        cx.ident_of(~\"decode\"),\n-                    ]),\n-                    ~[cx.expr_var(span, ~\"__d\")]\n-                )\n-            )\n-        );\n-\n-        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_field\")\n-            ),\n-            ~[\n-                cx.lit_str(span, @cx.str_of(field.ident)),\n-                cx.lit_uint(span, idx),\n-                expr_lambda,\n-            ]\n-        );\n-\n-        ast::spanned {\n-            node: ast::field_ {\n-                mutbl: field.mutbl,\n-                ident: field.ident,\n-                expr: expr,\n-            },\n-            span: span,\n-        }\n-    }\n-}\n-\n fn mk_enum_ser_impl(\n     cx: ext_ctxt,\n     span: span,"}, {"sha": "5a8a1d8753dee8d2e16e5193943d25864b805dfc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -172,6 +172,15 @@ fn mk_struct_e(cx: ext_ctxt, sp: span,\n                              mk_fields(sp, fields),\n                                     option::None::<@ast::expr>))\n }\n+fn mk_global_struct_e(cx: ext_ctxt, sp: span,\n+               ctor_path: ~[ast::ident],\n+               fields: ~[{ident: ast::ident, ex: @ast::expr}]) ->\n+    @ast::expr {\n+    mk_expr(cx, sp,\n+            ast::expr_struct(mk_raw_path_global(sp, ctor_path),\n+                             mk_fields(sp, fields),\n+                                    option::None::<@ast::expr>))\n+}\n fn mk_glob_use(cx: ext_ctxt, sp: span,\n                path: ~[ast::ident]) -> @ast::view_item {\n     let glob = @ast::spanned {"}, {"sha": "65890351e39fbbd3c442c965ead62a18131c57f5", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -56,8 +56,8 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, tts: ~[ast::token_tree])\n fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n-    fn make_path_vec(_cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n-        let intr = _cx.parse_sess().interner;\n+    fn make_path_vec(cx: ext_ctxt, ident: @~str) -> ~[ast::ident] {\n+        let intr = cx.parse_sess().interner;\n         return ~[intr.intern(@~\"extfmt\"), intr.intern(@~\"rt\"),\n                  intr.intern(ident)];\n     }\n@@ -111,23 +111,28 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             }\n             return make_rt_path_expr(cx, sp, @rt_type);\n         }\n-        fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n+        fn make_conv_struct(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             let intr = cx.parse_sess().interner;\n-            return mk_rec_e(cx, sp,\n-                         ~[{ident: intr.intern(@~\"flags\"), ex: flags_expr},\n-                           {ident: intr.intern(@~\"width\"), ex: width_expr},\n-                           {ident: intr.intern(@~\"precision\"),\n-                            ex: precision_expr},\n-                           {ident: intr.intern(@~\"ty\"), ex: ty_expr}]);\n+            mk_global_struct_e(\n+                cx,\n+                sp,\n+                make_path_vec(cx, @~\"Conv\"),\n+                ~[\n+                    {ident: intr.intern(@~\"flags\"), ex: flags_expr},\n+                    {ident: intr.intern(@~\"width\"), ex: width_expr},\n+                    {ident: intr.intern(@~\"precision\"), ex: precision_expr},\n+                    {ident: intr.intern(@~\"ty\"), ex: ty_expr},\n+                ]\n+            )\n         }\n         let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n         let rt_conv_precision = make_count(cx, sp, cnv.precision);\n         let rt_conv_ty = make_ty(cx, sp, cnv.ty);\n-        return make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n-                          rt_conv_precision, rt_conv_ty);\n+        make_conv_struct(cx, sp, rt_conv_flags, rt_conv_width,\n+                         rt_conv_precision, rt_conv_ty)\n     }\n     fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: ~str, cnv: Conv,\n                       arg: @ast::expr) -> @ast::expr {"}, {"sha": "e53057cb312e3240ad251a53328cad9122632701", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -357,10 +357,10 @@ impl protocol: gen_init {\n     fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n         debug!(\"gen_init_bounded\");\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n-        let buffer = quote_expr!(\n-            ~{header: ::pipes::BufferHeader(),\n-              data: $buffer_fields}\n-        );\n+        let buffer = quote_expr!(~::pipes::Buffer {\n+            header: ::pipes::BufferHeader(),\n+            data: $buffer_fields,\n+        });\n \n         let entangle_body = ext_cx.block_expr(\n             ext_cx.block("}, {"sha": "6ea08d200e77d0bebb757c42ee308c79234044bb", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -123,29 +123,33 @@ impl CLike : cmp::Eq {\n     pure fn eq(&self, other: &CLike) -> bool {\n         (*self) as int == *other as int\n     }\n-    pure fn ne(&self, other: &CLike) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &CLike) -> bool { !self.eq(other) }\n }\n \n #[auto_encode]\n #[auto_decode]\n-type Spanned<T> = {lo: uint, hi: uint, node: T};\n+struct Spanned<T> {\n+    lo: uint,\n+    hi: uint,\n+    node: T,\n+}\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n     pure fn eq(&self, other: &Spanned<T>) -> bool {\n-        (*self).lo == other.lo &&\n-        (*self).hi == other.hi &&\n-        (*self).node == other.node\n+        self.lo == other.lo &&\n+        self.hi == other.hi &&\n+        self.node == other.node\n     }\n-    pure fn ne(&self, other: &Spanned<T>) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &Spanned<T>) -> bool { !self.eq(other) }\n }\n \n #[auto_encode]\n #[auto_decode]\n-type SomeRec = {v: ~[uint]};\n+struct SomeStruct { v: ~[uint] }\n \n #[auto_encode]\n #[auto_decode]\n-enum AnEnum = SomeRec;\n+enum AnEnum = SomeStruct;\n \n #[auto_encode]\n #[auto_decode]\n@@ -168,12 +172,12 @@ fn main() {\n                            @Plus(@Val(22u), @Val(5u)))\");\n     test_ebml(a);\n \n-    let a = &{lo: 0u, hi: 5u, node: 22u};\n-    test_prettyprint(a, &~\"{lo: 0u, hi: 5u, node: 22u}\");\n+    let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n+    test_prettyprint(a, &~\"Spanned {lo: 0u, hi: 5u, node: 22u}\");\n     test_ebml(a);\n \n-    let a = &AnEnum({v: ~[1u, 2u, 3u]});\n-    test_prettyprint(a, &~\"AnEnum({v: ~[1u, 2u, 3u]})\");\n+    let a = &AnEnum(SomeStruct {v: ~[1u, 2u, 3u]});\n+    test_prettyprint(a, &~\"AnEnum(SomeStruct {v: ~[1u, 2u, 3u]})\");\n     test_ebml(a);\n \n     let a = &Point {x: 3u, y: 5u};"}, {"sha": "f44c54d38e4d9cfeef2964abbb3168ca35de113e", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9898485d4f441196c4f9b0b37f5fcc54921e8032/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=9898485d4f441196c4f9b0b37f5fcc54921e8032", "patch": "@@ -27,7 +27,7 @@ mod pingpong {\n     };\n \n     pub fn init() -> (client::ping, server::ping) {\n-        let buffer = ~{\n+        let buffer = ~Buffer {\n             header: BufferHeader(),\n             data: {\n                 ping: mk_packet::<ping>(),"}]}