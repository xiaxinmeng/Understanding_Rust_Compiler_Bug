{"sha": "94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YWQ0ZTFkMzhkNGYzYWMwZjNlNTMyYjVjZDA3ZjBlMTUwMjVjODc=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-01-23T23:38:41Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-08T09:53:09Z"}, "message": "Add theme tests", "tree": {"sha": "cfab705532f86a540888e4d5d60b234876b7befb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfab705532f86a540888e4d5d60b234876b7befb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87", "html_url": "https://github.com/rust-lang/rust/commit/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "932c736479f43dc8893a924946e4335d8e308c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/932c736479f43dc8893a924946e4335d8e308c2e", "html_url": "https://github.com/rust-lang/rust/commit/932c736479f43dc8893a924946e4335d8e308c2e"}], "stats": {"total": 285, "additions": 285, "deletions": 0}, "files": [{"sha": "efdfcafb40a2f61829a56e80f273992bc9314d54", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87", "patch": "@@ -91,6 +91,7 @@ pub mod plugins;\n pub mod visit_ast;\n pub mod visit_lib;\n pub mod test;\n+pub mod theme;\n \n use clean::AttributesExt;\n \n@@ -267,6 +268,11 @@ pub fn opts() -> Vec<RustcOptGroup> {\n                        \"additional themes which will be added to the generated docs\",\n                        \"FILES\")\n         }),\n+        unstable(\"theme-checker\", |o| {\n+            o.optmulti(\"\", \"theme-checker\",\n+                       \"check if given theme is valid\",\n+                       \"FILES\")\n+        }),\n     ]\n }\n \n@@ -316,6 +322,27 @@ pub fn main_args(args: &[String]) -> isize {\n         return 0;\n     }\n \n+    let to_check = matches.opt_strs(\"theme-checker\");\n+    if !to_check.is_empty() {\n+        let pathes = theme::load_css_pathes(include_bytes!(\"html/static/themes/main.css\"));\n+        let mut errors = 0;\n+\n+        println!(\"rustdoc: [theme-checker] Starting tests!\");\n+        for theme_file in to_check.iter() {\n+            print!(\" - Checking \\\"{}\\\"...\", theme_file);\n+            if !theme::test_theme_against(theme_file, &pathes) {\n+                eprintln!(\" FAILED\");\n+                errors += 1;\n+            } else {\n+                println!(\" OK\");\n+            }\n+        }\n+        if errors != 0 {\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n     if matches.free.is_empty() {\n         print_error(\"missing file operand\");\n         return 1;"}, {"sha": "ff1adc3e4c4f787a69ab26483344e110984b9774", "filename": "src/librustdoc/theme.rs", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=94ad4e1d38d4f3ac0f3e532b5cd07f0e15025c87", "patch": "@@ -0,0 +1,258 @@\n+// Copyright 2012-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+use std::fs::File;\n+use std::hash::{Hash, Hasher};\n+use std::io::Read;\n+use std::path::Path;\n+\n+macro_rules! try_false {\n+    ($e:expr) => ({\n+        match $e {\n+            Ok(c) => c,\n+            Err(e) => {\n+                eprintln!(\"rustdoc: got an error: {}\", e);\n+                return false;\n+            }\n+        }\n+    })\n+}\n+\n+#[derive(Debug, Clone, Eq)]\n+pub struct CssPath {\n+    pub name: String,\n+    pub children: HashSet<CssPath>,\n+}\n+\n+// This PartialEq implementation IS NOT COMMUTATIVE!!!\n+//\n+// The order is very important: the second object must have all first's rules.\n+// However, the first doesn't require to have all second's rules.\n+impl PartialEq for CssPath {\n+    fn eq(&self, other: &CssPath) -> bool {\n+        if self.name != other.name {\n+            false\n+        } else {\n+            for child in &self.children {\n+                if !other.children.iter().any(|c| child == c) {\n+                    return false;\n+                }\n+            }\n+            true\n+        }\n+    }\n+}\n+\n+impl Hash for CssPath {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.name.hash(state);\n+        for x in &self.children {\n+            x.hash(state);\n+        }\n+    }\n+}\n+\n+impl CssPath {\n+    fn new(name: String) -> CssPath {\n+        CssPath {\n+            name,\n+            children: HashSet::new(),\n+        }\n+    }\n+}\n+\n+/// All variants contain the position they occur.\n+#[derive(Debug, Clone, Copy)]\n+enum Events {\n+    StartLineComment(usize),\n+    StartComment(usize),\n+    EndComment(usize),\n+    InBlock(usize),\n+    OutBlock(usize),\n+}\n+\n+impl Events {\n+    fn get_pos(&self) -> usize {\n+        match *self {\n+            Events::StartLineComment(p) |\n+            Events::StartComment(p) |\n+            Events::EndComment(p) |\n+            Events::InBlock(p) |\n+            Events::OutBlock(p) => p,\n+        }\n+    }\n+\n+    fn is_comment(&self) -> bool {\n+        match *self {\n+            Events::StartLineComment(_) |\n+            Events::StartComment(_) |\n+            Events::EndComment(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn previous_is_line_comment(events: &[Events]) -> bool {\n+    if let Some(&Events::StartLineComment(_)) = events.last() {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_line_comment(pos: usize, v: &[u8], events: &[Events]) -> bool {\n+    if let Some(&Events::StartComment(_)) = events.last() {\n+        return false;\n+    }\n+    pos + 1 < v.len() && v[pos + 1] == b'/'\n+}\n+\n+fn load_css_events(v: &[u8]) -> Vec<Events> {\n+    let mut pos = 0;\n+    let mut events = Vec::with_capacity(100);\n+\n+    while pos < v.len() - 1 {\n+        match v[pos] {\n+            b'/' if pos + 1 < v.len() && v[pos + 1] == b'*' => {\n+                events.push(Events::StartComment(pos));\n+                pos += 1;\n+            }\n+            b'/' if is_line_comment(pos, v, &events) => {\n+                events.push(Events::StartLineComment(pos));\n+                pos += 1;\n+            }\n+            b'\\n' if previous_is_line_comment(&events) => {\n+                events.push(Events::EndComment(pos));\n+            }\n+            b'*' if pos + 1 < v.len() && v[pos + 1] == b'/' => {\n+                events.push(Events::EndComment(pos + 2));\n+                pos += 1;\n+            }\n+            b'{' if !previous_is_line_comment(&events) => {\n+                if let Some(&Events::StartComment(_)) = events.last() {\n+                    pos += 1;\n+                    continue\n+                }\n+                events.push(Events::InBlock(pos + 1));\n+            }\n+            b'}' if !previous_is_line_comment(&events) => {\n+                if let Some(&Events::StartComment(_)) = events.last() {\n+                    pos += 1;\n+                    continue\n+                }\n+                events.push(Events::OutBlock(pos + 1));\n+            }\n+            _ => {}\n+        }\n+        pos += 1;\n+    }\n+    events\n+}\n+\n+fn get_useful_next(events: &[Events], pos: &mut usize) -> Option<Events> {\n+    while *pos < events.len() {\n+        if !events[*pos].is_comment() {\n+            return Some(events[*pos]);\n+        }\n+        *pos += 1;\n+    }\n+    None\n+}\n+\n+fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> HashSet<CssPath> {\n+    let mut pathes = Vec::with_capacity(50);\n+\n+    while *pos < events.len() {\n+        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n+            println!(\"00 => {:?}\", events[*pos]);\n+            *pos += 1;\n+            break\n+        }\n+        println!(\"a => {:?}\", events[*pos]);\n+        if let Some(Events::InBlock(start_pos)) = get_useful_next(events, pos) {\n+            println!(\"aa => {:?}\", events[*pos]);\n+            pathes.push(CssPath::new(::std::str::from_utf8(if *pos > 0 {\n+                &v[events[*pos - 1].get_pos()..start_pos - 1]\n+            } else {\n+                &v[..start_pos]\n+            }).unwrap_or(\"\").trim().to_owned()));\n+            *pos += 1;\n+        }\n+        println!(\"b => {:?}\", events[*pos]);\n+        while let Some(Events::InBlock(_)) = get_useful_next(events, pos) {\n+            println!(\"bb => {:?}\", events[*pos]);\n+            if let Some(ref mut path) = pathes.last_mut() {\n+                for entry in inner(v, events, pos).iter() {\n+                    path.children.insert(entry.clone());\n+                }\n+            }\n+        }\n+        if *pos < events.len() {\n+            println!(\"c => {:?}\", events[*pos]);\n+        }\n+        if let Some(Events::OutBlock(_)) = get_useful_next(events, pos) {\n+            *pos += 1;\n+        }\n+    }\n+    pathes.iter().cloned().collect()\n+}\n+\n+pub fn load_css_pathes(v: &[u8]) -> CssPath {\n+    let events = load_css_events(v);\n+    let mut pos = 0;\n+\n+    println!(\"\\n======> {:?}\", events);\n+    let mut parent = CssPath::new(\"parent\".to_owned());\n+    parent.children = inner(v, &events, &mut pos);\n+    parent\n+}\n+\n+pub fn test_theme_against<P: AsRef<Path>>(f: &P, against: &CssPath) -> bool {\n+    let mut file = try_false!(File::open(f));\n+    let mut data = Vec::with_capacity(1000);\n+\n+    try_false!(file.read_to_end(&mut data));\n+    let pathes = load_css_pathes(&data);\n+    println!(\"========= {:?}\", pathes);\n+    println!(\"========= {:?}\", against);\n+    pathes == *against\n+}\n+\n+#[test]\n+fn test_comments_in_rules() {\n+    let text = r#\"\n+rule a {}\n+\n+rule b, c\n+// a line comment\n+{}\n+\n+rule d\n+// another line comment\n+e {}\n+\n+rule f/* a multine\n+\n+comment*/{}\n+\n+rule g/* another multine\n+\n+comment*/h\n+\n+i {}\n+\n+rule j/*commeeeeent\n+\n+you like things like \"{}\" in there? :)\n+*/\n+end {}\n+\"#;\n+}\n\\ No newline at end of file"}]}