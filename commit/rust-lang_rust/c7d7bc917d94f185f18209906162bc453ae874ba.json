{"sha": "c7d7bc917d94f185f18209906162bc453ae874ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZDdiYzkxN2Q5NGYxODVmMTgyMDk5MDYxNjJiYzQ1M2FlODc0YmE=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-12-09T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2020-12-09T00:00:00Z"}, "message": "Move RWUTable to a separate module", "tree": {"sha": "e7f1dfeb7f5c5da6d0a13dbaf5f6b42c28a80764", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7f1dfeb7f5c5da6d0a13dbaf5f6b42c28a80764"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7d7bc917d94f185f18209906162bc453ae874ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7d7bc917d94f185f18209906162bc453ae874ba", "html_url": "https://github.com/rust-lang/rust/commit/c7d7bc917d94f185f18209906162bc453ae874ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7d7bc917d94f185f18209906162bc453ae874ba/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1700ca07c6dd7becff85678409a5df6ad4cf4f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/1700ca07c6dd7becff85678409a5df6ad4cf4f47", "html_url": "https://github.com/rust-lang/rust/commit/1700ca07c6dd7becff85678409a5df6ad4cf4f47"}], "stats": {"total": 295, "additions": 149, "deletions": 146}, "files": [{"sha": "a449bddbaae17bc07ab50f70b9480af63978d1a4", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 5, "deletions": 146, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c7d7bc917d94f185f18209906162bc453ae874ba/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d7bc917d94f185f18209906162bc453ae874ba/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=c7d7bc917d94f185f18209906162bc453ae874ba", "patch": "@@ -105,6 +105,8 @@ use std::io;\n use std::io::prelude::*;\n use std::rc::Rc;\n \n+mod rwu_table;\n+\n rustc_index::newtype_index! {\n     pub struct Variable {\n         DEBUG_FORMAT = \"v({})\",\n@@ -468,149 +470,6 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n // Actually we compute just a bit more than just liveness, but we use\n // the same basic propagation framework in all cases.\n \n-#[derive(Clone, Copy)]\n-struct RWU {\n-    reader: bool,\n-    writer: bool,\n-    used: bool,\n-}\n-\n-/// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n-/// RWU`s can get very large, so it uses a more compact representation.\n-struct RWUTable {\n-    /// Total number of live nodes.\n-    live_nodes: usize,\n-    /// Total number of variables.\n-    vars: usize,\n-\n-    /// A compressed representation of `RWU`s.\n-    ///\n-    /// Each word represents 2 different `RWU`s packed together. Each packed RWU\n-    /// is stored in 4 bits: a reader bit, a writer bit, a used bit and a\n-    /// padding bit.\n-    ///\n-    /// The data for each live node is contiguous and starts at a word boundary,\n-    /// so there might be an unused space left.\n-    words: Vec<u8>,\n-    /// Number of words per each live node.\n-    live_node_words: usize,\n-}\n-\n-impl RWUTable {\n-    const RWU_READER: u8 = 0b0001;\n-    const RWU_WRITER: u8 = 0b0010;\n-    const RWU_USED: u8 = 0b0100;\n-    const RWU_MASK: u8 = 0b1111;\n-\n-    /// Size of packed RWU in bits.\n-    const RWU_BITS: usize = 4;\n-    /// Size of a word in bits.\n-    const WORD_BITS: usize = std::mem::size_of::<u8>() * 8;\n-    /// Number of packed RWUs that fit into a single word.\n-    const WORD_RWU_COUNT: usize = Self::WORD_BITS / Self::RWU_BITS;\n-\n-    fn new(live_nodes: usize, vars: usize) -> RWUTable {\n-        let live_node_words = (vars + Self::WORD_RWU_COUNT - 1) / Self::WORD_RWU_COUNT;\n-        Self { live_nodes, vars, live_node_words, words: vec![0u8; live_node_words * live_nodes] }\n-    }\n-\n-    fn word_and_shift(&self, ln: LiveNode, var: Variable) -> (usize, u32) {\n-        assert!(ln.index() < self.live_nodes);\n-        assert!(var.index() < self.vars);\n-\n-        let var = var.index();\n-        let word = var / Self::WORD_RWU_COUNT;\n-        let shift = Self::RWU_BITS * (var % Self::WORD_RWU_COUNT);\n-        (ln.index() * self.live_node_words + word, shift as u32)\n-    }\n-\n-    fn pick2_rows_mut(&mut self, a: LiveNode, b: LiveNode) -> (&mut [u8], &mut [u8]) {\n-        assert!(a.index() < self.live_nodes);\n-        assert!(b.index() < self.live_nodes);\n-        assert!(a != b);\n-\n-        let a_start = a.index() * self.live_node_words;\n-        let b_start = b.index() * self.live_node_words;\n-\n-        unsafe {\n-            let ptr = self.words.as_mut_ptr();\n-            (\n-                std::slice::from_raw_parts_mut(ptr.add(a_start), self.live_node_words),\n-                std::slice::from_raw_parts_mut(ptr.add(b_start), self.live_node_words),\n-            )\n-        }\n-    }\n-\n-    fn copy(&mut self, dst: LiveNode, src: LiveNode) {\n-        if dst == src {\n-            return;\n-        }\n-\n-        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n-        dst_row.copy_from_slice(src_row);\n-    }\n-\n-    /// Sets `dst` to the union of `dst` and `src`, returns true if `dst` was\n-    /// changed.\n-    fn union(&mut self, dst: LiveNode, src: LiveNode) -> bool {\n-        if dst == src {\n-            return false;\n-        }\n-\n-        let mut changed = false;\n-        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n-        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n-            let old = *dst_word;\n-            let new = *dst_word | src_word;\n-            *dst_word = new;\n-            changed |= old != new;\n-        }\n-        changed\n-    }\n-\n-    fn get_reader(&self, ln: LiveNode, var: Variable) -> bool {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        (self.words[word] >> shift) & Self::RWU_READER != 0\n-    }\n-\n-    fn get_writer(&self, ln: LiveNode, var: Variable) -> bool {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        (self.words[word] >> shift) & Self::RWU_WRITER != 0\n-    }\n-\n-    fn get_used(&self, ln: LiveNode, var: Variable) -> bool {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        (self.words[word] >> shift) & Self::RWU_USED != 0\n-    }\n-\n-    fn get(&self, ln: LiveNode, var: Variable) -> RWU {\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        let rwu_packed = self.words[word] >> shift;\n-        RWU {\n-            reader: rwu_packed & Self::RWU_READER != 0,\n-            writer: rwu_packed & Self::RWU_WRITER != 0,\n-            used: rwu_packed & Self::RWU_USED != 0,\n-        }\n-    }\n-\n-    fn set(&mut self, ln: LiveNode, var: Variable, rwu: RWU) {\n-        let mut packed = 0;\n-        if rwu.reader {\n-            packed |= Self::RWU_READER;\n-        }\n-        if rwu.writer {\n-            packed |= Self::RWU_WRITER;\n-        }\n-        if rwu.used {\n-            packed |= Self::RWU_USED;\n-        }\n-\n-        let (word, shift) = self.word_and_shift(ln, var);\n-        let word = &mut self.words[word];\n-        *word = (*word & !(Self::RWU_MASK << shift)) | (packed << shift)\n-    }\n-}\n-\n const ACC_READ: u32 = 1;\n const ACC_WRITE: u32 = 2;\n const ACC_USE: u32 = 4;\n@@ -623,7 +482,7 @@ struct Liveness<'a, 'tcx> {\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n     closure_captures: Option<&'tcx FxIndexMap<hir::HirId, ty::UpvarId>>,\n     successors: IndexVec<LiveNode, Option<LiveNode>>,\n-    rwu_table: RWUTable,\n+    rwu_table: rwu_table::RWUTable,\n \n     /// A live node representing a point of execution before closure entry &\n     /// after closure exit. Used to calculate liveness of captured variables\n@@ -661,7 +520,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             upvars,\n             closure_captures,\n             successors: IndexVec::from_elem_n(None, num_live_nodes),\n-            rwu_table: RWUTable::new(num_live_nodes, num_vars),\n+            rwu_table: rwu_table::RWUTable::new(num_live_nodes, num_vars),\n             closure_ln,\n             exit_ln,\n             break_ln: Default::default(),\n@@ -802,7 +661,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     // this) so we just clear out all the data.\n     fn define(&mut self, writer: LiveNode, var: Variable) {\n         let used = self.rwu_table.get_used(writer, var);\n-        self.rwu_table.set(writer, var, RWU { reader: false, writer: false, used });\n+        self.rwu_table.set(writer, var, rwu_table::RWU { reader: false, writer: false, used });\n         debug!(\"{:?} defines {:?}: {}\", writer, var, self.ln_str(writer));\n     }\n "}, {"sha": "a1a6f27398ec86aede95a18945161017376989ae", "filename": "compiler/rustc_passes/src/liveness/rwu_table.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/c7d7bc917d94f185f18209906162bc453ae874ba/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7d7bc917d94f185f18209906162bc453ae874ba/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs?ref=c7d7bc917d94f185f18209906162bc453ae874ba", "patch": "@@ -0,0 +1,144 @@\n+use crate::liveness::{LiveNode, Variable};\n+\n+#[derive(Clone, Copy)]\n+pub(super) struct RWU {\n+    pub(super) reader: bool,\n+    pub(super) writer: bool,\n+    pub(super) used: bool,\n+}\n+\n+/// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n+/// RWU`s can get very large, so it uses a more compact representation.\n+pub(super) struct RWUTable {\n+    /// Total number of live nodes.\n+    live_nodes: usize,\n+    /// Total number of variables.\n+    vars: usize,\n+\n+    /// A compressed representation of `RWU`s.\n+    ///\n+    /// Each word represents 2 different `RWU`s packed together. Each packed RWU\n+    /// is stored in 4 bits: a reader bit, a writer bit, a used bit and a\n+    /// padding bit.\n+    ///\n+    /// The data for each live node is contiguous and starts at a word boundary,\n+    /// so there might be an unused space left.\n+    words: Vec<u8>,\n+    /// Number of words per each live node.\n+    live_node_words: usize,\n+}\n+\n+impl RWUTable {\n+    const RWU_READER: u8 = 0b0001;\n+    const RWU_WRITER: u8 = 0b0010;\n+    const RWU_USED: u8 = 0b0100;\n+    const RWU_MASK: u8 = 0b1111;\n+\n+    /// Size of packed RWU in bits.\n+    const RWU_BITS: usize = 4;\n+    /// Size of a word in bits.\n+    const WORD_BITS: usize = std::mem::size_of::<u8>() * 8;\n+    /// Number of packed RWUs that fit into a single word.\n+    const WORD_RWU_COUNT: usize = Self::WORD_BITS / Self::RWU_BITS;\n+\n+    pub(super) fn new(live_nodes: usize, vars: usize) -> RWUTable {\n+        let live_node_words = (vars + Self::WORD_RWU_COUNT - 1) / Self::WORD_RWU_COUNT;\n+        Self { live_nodes, vars, live_node_words, words: vec![0u8; live_node_words * live_nodes] }\n+    }\n+\n+    fn word_and_shift(&self, ln: LiveNode, var: Variable) -> (usize, u32) {\n+        assert!(ln.index() < self.live_nodes);\n+        assert!(var.index() < self.vars);\n+\n+        let var = var.index();\n+        let word = var / Self::WORD_RWU_COUNT;\n+        let shift = Self::RWU_BITS * (var % Self::WORD_RWU_COUNT);\n+        (ln.index() * self.live_node_words + word, shift as u32)\n+    }\n+\n+    fn pick2_rows_mut(&mut self, a: LiveNode, b: LiveNode) -> (&mut [u8], &mut [u8]) {\n+        assert!(a.index() < self.live_nodes);\n+        assert!(b.index() < self.live_nodes);\n+        assert!(a != b);\n+\n+        let a_start = a.index() * self.live_node_words;\n+        let b_start = b.index() * self.live_node_words;\n+\n+        unsafe {\n+            let ptr = self.words.as_mut_ptr();\n+            (\n+                std::slice::from_raw_parts_mut(ptr.add(a_start), self.live_node_words),\n+                std::slice::from_raw_parts_mut(ptr.add(b_start), self.live_node_words),\n+            )\n+        }\n+    }\n+\n+    pub(super) fn copy(&mut self, dst: LiveNode, src: LiveNode) {\n+        if dst == src {\n+            return;\n+        }\n+\n+        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n+        dst_row.copy_from_slice(src_row);\n+    }\n+\n+    /// Sets `dst` to the union of `dst` and `src`, returns true if `dst` was\n+    /// changed.\n+    pub(super) fn union(&mut self, dst: LiveNode, src: LiveNode) -> bool {\n+        if dst == src {\n+            return false;\n+        }\n+\n+        let mut changed = false;\n+        let (dst_row, src_row) = self.pick2_rows_mut(dst, src);\n+        for (dst_word, src_word) in dst_row.iter_mut().zip(src_row.iter()) {\n+            let old = *dst_word;\n+            let new = *dst_word | src_word;\n+            *dst_word = new;\n+            changed |= old != new;\n+        }\n+        changed\n+    }\n+\n+    pub(super) fn get_reader(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_READER != 0\n+    }\n+\n+    pub(super) fn get_writer(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_WRITER != 0\n+    }\n+\n+    pub(super) fn get_used(&self, ln: LiveNode, var: Variable) -> bool {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        (self.words[word] >> shift) & Self::RWU_USED != 0\n+    }\n+\n+    pub(super) fn get(&self, ln: LiveNode, var: Variable) -> RWU {\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        let rwu_packed = self.words[word] >> shift;\n+        RWU {\n+            reader: rwu_packed & Self::RWU_READER != 0,\n+            writer: rwu_packed & Self::RWU_WRITER != 0,\n+            used: rwu_packed & Self::RWU_USED != 0,\n+        }\n+    }\n+\n+    pub(super) fn set(&mut self, ln: LiveNode, var: Variable, rwu: RWU) {\n+        let mut packed = 0;\n+        if rwu.reader {\n+            packed |= Self::RWU_READER;\n+        }\n+        if rwu.writer {\n+            packed |= Self::RWU_WRITER;\n+        }\n+        if rwu.used {\n+            packed |= Self::RWU_USED;\n+        }\n+\n+        let (word, shift) = self.word_and_shift(ln, var);\n+        let word = &mut self.words[word];\n+        *word = (*word & !(Self::RWU_MASK << shift)) | (packed << shift)\n+    }\n+}"}]}