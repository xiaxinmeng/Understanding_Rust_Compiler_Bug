{"sha": "270b4273e79aac33f424673caf455f839da2bb40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3MGI0MjczZTc5YWFjMzNmNDI0NjczY2FmNDU1ZjgzOWRhMmJiNDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T11:00:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T14:15:27Z"}, "message": "Pass bounds to trans::type_of_fn", "tree": {"sha": "a2f896c6c28ee2fa1e6eb6adf6413a5b593de099", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2f896c6c28ee2fa1e6eb6adf6413a5b593de099"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/270b4273e79aac33f424673caf455f839da2bb40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/270b4273e79aac33f424673caf455f839da2bb40", "html_url": "https://github.com/rust-lang/rust/commit/270b4273e79aac33f424673caf455f839da2bb40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/270b4273e79aac33f424673caf455f839da2bb40/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "664a0443ade2ecc969d39d5ca3f18387b94af5b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/664a0443ade2ecc969d39d5ca3f18387b94af5b4", "html_url": "https://github.com/rust-lang/rust/commit/664a0443ade2ecc969d39d5ca3f18387b94af5b4"}], "stats": {"total": 115, "additions": 65, "deletions": 50}, "files": [{"sha": "9e85d02a648cd99a55e64d95f84463d5fb47722c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=270b4273e79aac33f424673caf455f839da2bb40", "patch": "@@ -83,7 +83,7 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - trans_args\n fn type_of_fn(cx: @crate_ctxt, sp: span,\n               is_method: bool, inputs: [ty::arg],\n-              output: ty::t, ty_param_count: uint)\n+              output: ty::t, params: [ty::param_bounds])\n    : non_ty_var(cx, output) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n@@ -100,8 +100,10 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n \n     // Args >2: ty params, if not acquired via capture...\n     if !is_method {\n-        let i = 0u;\n-        while i < ty_param_count { atys += [T_ptr(cx.tydesc_type)]; i += 1u; }\n+        // FIXME[impl] Also add args for the dicts\n+        for _param in params {\n+            atys += [T_ptr(cx.tydesc_type)];\n+        }\n     }\n     // ... then explicit args.\n     atys += type_of_explicit_args(cx, sp, inputs);\n@@ -110,15 +112,15 @@ fn type_of_fn(cx: @crate_ctxt, sp: span,\n \n // Given a function type and a count of ty params, construct an llvm type\n fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n-                      ty_param_count: uint)\n+                      param_bounds: [ty::param_bounds])\n     : returns_non_ty_var(cx, fty) -> TypeRef {\n     // FIXME: Check should be unnecessary, b/c it's implied\n     // by returns_non_ty_var(t). Make that a postcondition\n     // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n     check non_ty_var(cx, ret_ty);\n     ret type_of_fn(cx, sp, false, ty::ty_fn_args(cx.tcx, fty),\n-                   ret_ty, ty_param_count);\n+                   ret_ty, param_bounds);\n }\n \n fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n@@ -171,10 +173,10 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_fn(_) {\n         // FIXME: could be a constraint on ty_fn\n         check returns_non_ty_var(cx, t);\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, 0u))\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, []))\n       }\n       ty::ty_native_fn(args, out) {\n-        let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n+        let nft = native_fn_wrapper_type(cx, sp, [], t);\n         T_fn_pair(cx, nft)\n       }\n       ty::ty_obj(meths) { cx.rust_object_type }\n@@ -234,7 +236,7 @@ fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt, sp: span,\n     alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_) | ty::ty_native_fn(_, _) {\n         check returns_non_ty_var(cx, t);\n-        ret type_of_fn_from_ty(cx, sp, t, vec::len(tpt.bounds));\n+        ret type_of_fn_from_ty(cx, sp, t, tpt.bounds);\n       }\n       _ {\n         // fall through\n@@ -2562,7 +2564,8 @@ fn trans_do_while(cx: @block_ctxt, body: ast::blk, cond: @ast::expr) ->\n type generic_info =\n     {item_type: ty::t,\n      static_tis: [option::t<@tydesc_info>],\n-     tydescs: [ValueRef]};\n+     tydescs: [ValueRef],\n+     param_bounds: [ty::param_bounds]};\n \n tag lval_kind {\n     temporary; //< Temporary value passed by value if of immediate type\n@@ -2608,18 +2611,19 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n     -> lval_maybe_callee {\n-    let tpt = ty::lookup_item_type(bcx_tcx(bcx), fn_id);\n+    let ccx = bcx_ccx(bcx);\n+    let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let val = if fn_id.crate == ast::local_crate {\n         // Internal reference.\n-        assert (bcx_ccx(bcx).item_ids.contains_key(fn_id.node));\n-        bcx_ccx(bcx).item_ids.get(fn_id.node)\n+        assert (ccx.item_ids.contains_key(fn_id.node));\n+        ccx.item_ids.get(fn_id.node)\n     } else {\n         // External reference.\n         trans_external_path(bcx, fn_id, tpt)\n     };\n-    let tys = ty::node_id_to_type_params(bcx_tcx(bcx), id);\n+    let tys = ty::node_id_to_type_params(ccx.tcx, id);\n     let gen = none, bcx = bcx;\n-    if vec::len::<ty::t>(tys) != 0u {\n+    if vec::len(tys) != 0u {\n         let tydescs = [], tis = [];\n         for t in tys {\n             // TODO: Doesn't always escape.\n@@ -2629,7 +2633,11 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n             bcx = td.bcx;\n             tydescs += [td.val];\n         }\n-        gen = some({item_type: tpt.ty, static_tis: tis, tydescs: tydescs});\n+        let bounds = ty::lookup_item_type(ccx.tcx, fn_id).bounds;\n+        gen = some({item_type: tpt.ty,\n+                    static_tis: tis,\n+                    tydescs: tydescs,\n+                    param_bounds: bounds});\n     }\n     ret {bcx: bcx, val: val, kind: owned, env: null_env, generic: gen};\n }\n@@ -2767,7 +2775,7 @@ fn trans_object_field_inner(bcx: @block_ctxt, o: ValueRef,\n     check non_ty_var(ccx, ret_ty);\n \n     let ll_fn_ty = type_of_fn(ccx, bcx.sp, true,\n-                              ty::ty_fn_args(tcx, fn_ty), ret_ty, 0u);\n+                              ty::ty_fn_args(tcx, fn_ty), ret_ty, []);\n     v = Load(bcx, PointerCast(bcx, v, T_ptr(T_ptr(ll_fn_ty))));\n     ret {bcx: bcx, mthptr: v, objptr: o};\n }\n@@ -5084,13 +5092,17 @@ fn register_fn(ccx: @crate_ctxt, sp: span, path: [str], flav: str,\n     register_fn_full(ccx, sp, path, flav, ty_params, node_id, t);\n }\n \n+fn param_bounds(ccx: @crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n+    ccx.tcx.ty_param_bounds.get(ast_util::local_def(tp.id))\n+}\n+\n fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n-                    ty_params: [ast::ty_param], node_id: ast::node_id,\n+                    tps: [ast::ty_param], node_id: ast::node_id,\n                     node_type: ty::t)\n     : returns_non_ty_var(ccx, node_type) {\n     let path = path;\n-    let llfty =\n-        type_of_fn_from_ty(ccx, sp, node_type, vec::len(ty_params));\n+    let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n+                                   vec::map(tps, {|p| param_bounds(ccx, p)}));\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n@@ -5128,7 +5140,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n         let nt = ty::mk_nil(ccx.tcx);\n         check non_ty_var(ccx, nt);\n \n-        let llfty = type_of_fn(ccx, sp, false, [vecarg_ty], nt, 0u);\n+        let llfty = type_of_fn(ccx, sp, false, [vecarg_ty], nt, []);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n@@ -5221,12 +5233,13 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n+fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span,\n+                          param_bounds: [ty::param_bounds],\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_native_fn(args, out) {\n         check non_ty_var(cx, out);\n-        ret type_of_fn(cx, sp, false, args, out, ty_param_count);\n+        ret type_of_fn(cx, sp, false, args, out, param_bounds);\n       }\n     }\n }\n@@ -5273,10 +5286,10 @@ fn collect_native_item(ccx: @crate_ctxt,\n               ast::native_abi_rust_intrinsic. {\n                 // For intrinsics: link the function directly to the intrinsic\n                 // function itself.\n-                let num_ty_param = vec::len(tps);\n                 check returns_non_ty_var(ccx, node_type);\n-                let fn_type = type_of_fn_from_ty(ccx, sp, node_type,\n-                                                 num_ty_param);\n+                let fn_type = type_of_fn_from_ty(\n+                    ccx, sp, node_type,\n+                    vec::map(tps, {|p| param_bounds(ccx, p)}));\n                 let ri_name = \"rust_intrinsic_\" + link_name(i);\n                 let llnativefn = get_extern_fn(\n                     ccx.externs, ccx.llmod, ri_name,"}, {"sha": "18552e84237a83408c6582ecf13751a9193d0b48", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=270b4273e79aac33f424673caf455f839da2bb40", "patch": "@@ -383,7 +383,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n     check returns_non_ty_var(ccx, fty);\n-    let llfnty = type_of_fn_from_ty(ccx, sp, fty, 0u);\n+    let llfnty = type_of_fn_from_ty(ccx, sp, fty, []);\n     let sub_cx = extend_path(bcx.fcx.lcx, ccx.names.next(\"anon\"));\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n@@ -436,16 +436,13 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     }\n \n     // Figure out which tydescs we need to pass, if any.\n-    let outgoing_fty_real; // the type with typarams still in it\n-    let lltydescs: [ValueRef];\n-    alt f_res.generic {\n-      none. { outgoing_fty_real = outgoing_fty; lltydescs = []; }\n+    let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n+      none. { (outgoing_fty, [], []) }\n       some(ginfo) {\n         lazily_emit_all_generic_info_tydesc_glues(cx, ginfo);\n-        outgoing_fty_real = ginfo.item_type;\n-        lltydescs = ginfo.tydescs;\n+        (ginfo.item_type, ginfo.tydescs, ginfo.param_bounds)\n       }\n-    }\n+    };\n \n     let ty_param_count = vec::len(lltydescs);\n     if vec::len(bound) == 0u && ty_param_count == 0u {\n@@ -487,7 +484,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n     // Make thunk\n     let llthunk =\n         trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n-                         box_ty, ty_param_count, target_res);\n+                         box_ty, param_bounds, target_res);\n \n     // Fill the function pair\n     fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, llbox);\n@@ -558,7 +555,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                     outgoing_fty: ty::t,\n                     args: [option::t<@ast::expr>],\n                     boxed_closure_ty: ty::t,\n-                    ty_param_count: uint,\n+                    param_bounds: [ty::param_bounds],\n                     target_fn: option::t<ValueRef>)\n     -> {val: ValueRef, ty: TypeRef} {\n     // If we supported constraints on record fields, we could make the\n@@ -667,7 +664,8 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let llargs: [ValueRef] = [llretptr, lltargetenv];\n \n     // Copy in the type parameters.\n-    let i: uint = 0u;\n+    // FIXME[impl] This will also have to copy the dicts\n+    let i = 0u, ty_param_count = vec::len(param_bounds);\n     while i < ty_param_count {\n         // Silly check\n         check type_is_tup_like(load_env_bcx, boxed_closure_ty);\n@@ -739,11 +737,10 @@ fn trans_bind_thunk(cx: @local_ctxt,\n \n     check returns_non_ty_var(ccx, outgoing_fty);\n     let lltargetty =\n-        type_of_fn_from_ty(ccx, sp, outgoing_fty, ty_param_count);\n+        type_of_fn_from_ty(ccx, sp, outgoing_fty, param_bounds);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     Call(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret {val: llthunk, ty: llthunk_ty};\n }\n-"}, {"sha": "c8f561859878b7438d9502d1d580db9d01101197", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=270b4273e79aac33f424673caf455f839da2bb40", "patch": "@@ -320,13 +320,13 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n         }\n     }\n \n-    let params = csearch::get_type_param_count(ccx.sess.get_cstore(), did);\n+    let param_bounds = ty::lookup_item_type(ccx.tcx, did).bounds;\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n     let f_t = type_of_fn(ccx, sp, false,\n                          [{mode: ast::by_ref, ty: inner_t}],\n-                         nil_res, params);\n+                         nil_res, param_bounds);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.get_cstore(),\n                                                     did), f_t);"}, {"sha": "8b8a4b018d4ed6746ca68f0d4662d11beeb932e5", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=270b4273e79aac33f424673caf455f839da2bb40", "patch": "@@ -880,8 +880,9 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n       ty::ty_fn(f) {\n         let out = f.output;\n         check non_ty_var(ccx, out);\n-        llfnty = type_of_fn(ccx, m.span, true, f.inputs, out,\n-                            vec::len(ty_params));\n+        llfnty = type_of_fn(\n+            ccx, m.span, true, f.inputs, out,\n+            vec::map(ty_params, {|p| param_bounds(ccx, p)}));\n       }\n     }\n     let mcx: @local_ctxt =\n@@ -933,7 +934,8 @@ fn type_of_meth(ccx: @crate_ctxt, sp: span, m: @ty::method,\n                 tps: [ast::ty_param]) -> TypeRef {\n     let out_ty = m.fty.output;\n     check non_ty_var(ccx, out_ty);\n-    type_of_fn(ccx, sp, true, m.fty.inputs, out_ty, vec::len(tps))\n+    type_of_fn(ccx, sp, true, m.fty.inputs, out_ty,\n+               vec::map(tps, {|p| param_bounds(ccx, p)}))\n }\n \n //"}, {"sha": "c6e68c7777ef8d80e3e4553183eb4100065a8c39", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=270b4273e79aac33f424673caf455f839da2bb40", "patch": "@@ -185,7 +185,7 @@ export closure_kind;\n export closure_block;\n export closure_shared;\n export closure_send;\n-export param_bound, bound_copy, bound_send, bound_iface;\n+export param_bound, param_bounds, bound_copy, bound_send, bound_iface;\n export param_bounds_to_kind;\n \n // Data types\n@@ -194,7 +194,9 @@ type arg = {mode: mode, ty: t};\n \n type field = {ident: ast::ident, mt: mt};\n \n-type method = {ident: ast::ident, tps: [@[param_bound]], fty: fn_ty};\n+type param_bounds = @[param_bound];\n+\n+type method = {ident: ast::ident, tps: [param_bounds], fty: fn_ty};\n \n type constr_table = hashmap<ast::node_id, [constr]>;\n \n@@ -220,7 +222,7 @@ type ctxt =\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>,\n       tag_var_cache: hashmap<def_id, @[variant_info]>,\n       iface_method_cache: hashmap<def_id, @[method]>,\n-      ty_param_bounds: hashmap<def_id, @[param_bound]>};\n+      ty_param_bounds: hashmap<def_id, param_bounds>};\n \n type ty_ctxt = ctxt;\n \n@@ -308,7 +310,7 @@ tag param_bound {\n     bound_iface(t);\n }\n \n-fn param_bounds_to_kind(bounds: @[param_bound]) -> kind {\n+fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let kind = kind_noncopyable;\n     for bound in *bounds {\n         alt bound {\n@@ -322,7 +324,7 @@ fn param_bounds_to_kind(bounds: @[param_bound]) -> kind {\n     kind\n }\n \n-type ty_param_bounds_and_ty = @{bounds: [@[param_bound]], ty: t};\n+type ty_param_bounds_and_ty = @{bounds: [param_bounds], ty: t};\n \n type type_cache = hashmap<ast::def_id, ty_param_bounds_and_ty>;\n "}, {"sha": "3901c808bcffe12f3b6de6739c4c931f98a8963c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/270b4273e79aac33f424673caf455f839da2bb40/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=270b4273e79aac33f424673caf455f839da2bb40", "patch": "@@ -504,7 +504,7 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     ret tpt;\n }\n fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n-    -> [@[ty::param_bound]] {\n+    -> [ty::param_bounds] {\n     let result = [];\n     for param in params {\n         result += [alt tcx.ty_param_bounds.find(local_def(param.id)) {\n@@ -626,7 +626,7 @@ mod write {\n }\n \n fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n-    -> {bounds: [@[ty::param_bound]], params: [ty::t]} {\n+    -> {bounds: [ty::param_bounds], params: [ty::t]} {\n     let i = 0u, bounds = ty_param_bounds(tcx, m_collect, atps);\n     {bounds: bounds,\n      params: vec::map(atps, {|atp|\n@@ -2896,6 +2896,7 @@ fn resolve_vtables(tcx: ty::ctxt, impl_map: resolve::impl_map,\n             ty::ty_iface(did, _) { did }\n             _ { ret; }\n         };\n+        // FIXME check against bounded param types\n         let found = false;\n         std::list::iter(isc) {|impls|\n             if found { ret; }"}]}