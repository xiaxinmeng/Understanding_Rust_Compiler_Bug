{"sha": "064f7182476342e89b83a86bf308e620afa14ea6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NGY3MTgyNDc2MzQyZTg5YjgzYTg2YmYzMDhlNjIwYWZhMTRlYTY=", "commit": {"author": {"name": "Tim Neumann", "email": "mail@timnn.me", "date": "2017-09-17T11:19:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-17T11:19:09Z"}, "message": "Rollup merge of #44595 - budziq:stabilize_compiler_fences, r=alexcrichton\n\nstabilized compiler_fences (fixes #41091)\n\nI did not know what to proceed with \"unstable-book\" entry. The feature would no longer be unstable so I have deleted it. If it was the wrong call I'll revert it (unfortunately his case is not described in the CONTRIBUTING.md).", "tree": {"sha": "8ff19ed145ddb9608a7f16d7c1a489f34a5452c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ff19ed145ddb9608a7f16d7c1a489f34a5452c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/064f7182476342e89b83a86bf308e620afa14ea6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/064f7182476342e89b83a86bf308e620afa14ea6", "html_url": "https://github.com/rust-lang/rust/commit/064f7182476342e89b83a86bf308e620afa14ea6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/064f7182476342e89b83a86bf308e620afa14ea6/comments", "author": {"login": "TimNN", "id": 1178249, "node_id": "MDQ6VXNlcjExNzgyNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1178249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimNN", "html_url": "https://github.com/TimNN", "followers_url": "https://api.github.com/users/TimNN/followers", "following_url": "https://api.github.com/users/TimNN/following{/other_user}", "gists_url": "https://api.github.com/users/TimNN/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimNN/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimNN/subscriptions", "organizations_url": "https://api.github.com/users/TimNN/orgs", "repos_url": "https://api.github.com/users/TimNN/repos", "events_url": "https://api.github.com/users/TimNN/events{/privacy}", "received_events_url": "https://api.github.com/users/TimNN/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1437e53f9f5b9d66bc71f9626291a7fc231f0239", "url": "https://api.github.com/repos/rust-lang/rust/commits/1437e53f9f5b9d66bc71f9626291a7fc231f0239", "html_url": "https://github.com/rust-lang/rust/commit/1437e53f9f5b9d66bc71f9626291a7fc231f0239"}, {"sha": "5f62c0c8649a61fb304466e90325a042f8c40449", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f62c0c8649a61fb304466e90325a042f8c40449", "html_url": "https://github.com/rust-lang/rust/commit/5f62c0c8649a61fb304466e90325a042f8c40449"}], "stats": {"total": 165, "additions": 54, "deletions": 111}, "files": [{"sha": "b1e36ab13d5aee82fe881e4833bd2e779a564a27", "filename": "src/doc/unstable-book/src/library-features/compiler-fences.md", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/1437e53f9f5b9d66bc71f9626291a7fc231f0239/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-fences.md", "raw_url": "https://github.com/rust-lang/rust/raw/1437e53f9f5b9d66bc71f9626291a7fc231f0239/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-fences.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-fences.md?ref=1437e53f9f5b9d66bc71f9626291a7fc231f0239", "patch": "@@ -1,106 +0,0 @@\n-# `compiler_fences`\n-\n-The tracking issue for this feature is: [#41091]\n-\n-[#41091]: https://github.com/rust-lang/rust/issues/41091\n-\n-------------------------\n-\n-The `compiler_fences` feature exposes the `compiler_fence` function\n-in `std::sync::atomic`. This function is conceptually similar to C++'s\n-`atomic_signal_fence`, which can currently only be accessed in nightly\n-Rust using the `atomic_singlethreadfence_*` instrinsic functions in\n-`core`, or through the mostly equivalent literal assembly:\n-\n-```rust\n-#![feature(asm)]\n-unsafe { asm!(\"\" ::: \"memory\" : \"volatile\") };\n-```\n-\n-A `compiler_fence` restricts the kinds of memory re-ordering the\n-compiler is allowed to do. Specifically, depending on the given ordering\n-semantics, the compiler may be disallowed from moving reads or writes\n-from before or after the call to the other side of the call to\n-`compiler_fence`. Note that it does **not** prevent the *hardware*\n-from doing such re-ordering. This is not a problem in a single-threaded,\n-execution context, but when other threads may modify memory at the same\n-time, stronger synchronization primitives are required.\n-\n-## Examples\n-\n-`compiler_fence` is generally only useful for preventing a thread from\n-racing *with itself*. That is, if a given thread is executing one piece\n-of code, and is then interrupted, and starts executing code elsewhere\n-(while still in the same thread, and conceptually still on the same\n-core). In traditional programs, this can only occur when a signal\n-handler is registered. In more low-level code, such situations can also\n-arise when handling interrupts, when implementing green threads with\n-pre-emption, etc.\n-\n-To give a straightforward example of when a `compiler_fence` is\n-necessary, consider the following example:\n-\n-```rust\n-# use std::sync::atomic::{AtomicBool, AtomicUsize};\n-# use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n-# use std::sync::atomic::Ordering;\n-static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n-static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n-\n-fn main() {\n-    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n-    IS_READY.store(true, Ordering::Relaxed);\n-}\n-\n-fn signal_handler() {\n-    if IS_READY.load(Ordering::Relaxed) {\n-        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n-    }\n-}\n-```\n-\n-The way it is currently written, the `assert_eq!` is *not* guaranteed to\n-succeed, despite everything happening in a single thread. To see why,\n-remember that the compiler is free to swap the stores to\n-`IMPORTANT_VARIABLE` and `IS_READ` since they are both\n-`Ordering::Relaxed`. If it does, and the signal handler is invoked right\n-after `IS_READY` is updated, then the signal handler will see\n-`IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n-\n-Using a `compiler_fence`, we can remedy this situation:\n-\n-```rust\n-#![feature(compiler_fences)]\n-# use std::sync::atomic::{AtomicBool, AtomicUsize};\n-# use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n-# use std::sync::atomic::Ordering;\n-use std::sync::atomic::compiler_fence;\n-\n-static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n-static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n-\n-fn main() {\n-    IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n-    // prevent earlier writes from being moved beyond this point\n-    compiler_fence(Ordering::Release);\n-    IS_READY.store(true, Ordering::Relaxed);\n-}\n-\n-fn signal_handler() {\n-    if IS_READY.load(Ordering::Relaxed) {\n-        assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n-    }\n-}\n-```\n-\n-A deeper discussion of compiler barriers with various re-ordering\n-semantics (such as `Ordering::SeqCst`) is beyond the scope of this text.\n-Curious readers are encouraged to read the Linux kernel's discussion of\n-[memory barriers][1], the C++ references on [`std::memory_order`][2] and\n-[`atomic_signal_fence`][3], and [this StackOverflow answer][4] for\n-further details.\n-\n-[1]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n-[2]: http://en.cppreference.com/w/cpp/atomic/memory_order\n-[3]: http://www.cplusplus.com/reference/atomic/atomic_signal_fence/\n-[4]: http://stackoverflow.com/a/18454971/472927"}, {"sha": "3dd08e697106652f32c2aba27c2f33e58bee03fb", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/064f7182476342e89b83a86bf308e620afa14ea6/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/064f7182476342e89b83a86bf308e620afa14ea6/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=064f7182476342e89b83a86bf308e620afa14ea6", "patch": "@@ -1679,10 +1679,14 @@ pub fn fence(order: Ordering) {\n \n /// A compiler memory fence.\n ///\n-/// `compiler_fence` does not emit any machine code, but prevents the compiler from re-ordering\n-/// memory operations across this point. Which reorderings are disallowed is dictated by the given\n-/// [`Ordering`]. Note that `compiler_fence` does *not* introduce inter-thread memory\n-/// synchronization; for that, a [`fence`] is needed.\n+/// `compiler_fence` does not emit any machine code, but restricts the kinds\n+/// of memory re-ordering the compiler is allowed to do. Specifically, depending on\n+/// the given [`Ordering`] semantics, the compiler may be disallowed from moving reads\n+/// or writes from before or after the call to the other side of the call to\n+/// `compiler_fence`. Note that it does **not** prevent the *hardware*\n+/// from doing such re-ordering. This is not a problem in a single-threaded,\n+/// execution context, but when other threads may modify memory at the same\n+/// time, stronger synchronization primitives such as [`fence`] are required.\n ///\n /// The re-ordering prevented by the different ordering semantics are:\n ///\n@@ -1691,19 +1695,64 @@ pub fn fence(order: Ordering) {\n ///  - with [`Acquire`], subsequent reads and writes cannot be moved ahead of preceding reads.\n ///  - with [`AcqRel`], both of the above rules are enforced.\n ///\n+/// `compiler_fence` is generally only useful for preventing a thread from\n+/// racing *with itself*. That is, if a given thread is executing one piece\n+/// of code, and is then interrupted, and starts executing code elsewhere\n+/// (while still in the same thread, and conceptually still on the same\n+/// core). In traditional programs, this can only occur when a signal\n+/// handler is registered. In more low-level code, such situations can also\n+/// arise when handling interrupts, when implementing green threads with\n+/// pre-emption, etc. Curious readers are encouraged to read the Linux kernel's\n+/// discussion of [memory barriers].\n+///\n /// # Panics\n ///\n /// Panics if `order` is [`Relaxed`].\n ///\n+/// # Examples\n+///\n+/// Without `compiler_fence`, the `assert_eq!` in following code\n+/// is *not* guaranteed to succeed, despite everything happening in a single thread.\n+/// To see why, remember that the compiler is free to swap the stores to\n+/// `IMPORTANT_VARIABLE` and `IS_READ` since they are both\n+/// `Ordering::Relaxed`. If it does, and the signal handler is invoked right\n+/// after `IS_READY` is updated, then the signal handler will see\n+/// `IS_READY=1`, but `IMPORTANT_VARIABLE=0`.\n+/// Using a `compiler_fence` remedies this situation.\n+///\n+/// ```\n+/// use std::sync::atomic::{AtomicBool, AtomicUsize};\n+/// use std::sync::atomic::{ATOMIC_BOOL_INIT, ATOMIC_USIZE_INIT};\n+/// use std::sync::atomic::Ordering;\n+/// use std::sync::atomic::compiler_fence;\n+///\n+/// static IMPORTANT_VARIABLE: AtomicUsize = ATOMIC_USIZE_INIT;\n+/// static IS_READY: AtomicBool = ATOMIC_BOOL_INIT;\n+///\n+/// fn main() {\n+///     IMPORTANT_VARIABLE.store(42, Ordering::Relaxed);\n+///     // prevent earlier writes from being moved beyond this point\n+///     compiler_fence(Ordering::Release);\n+///     IS_READY.store(true, Ordering::Relaxed);\n+/// }\n+///\n+/// fn signal_handler() {\n+///     if IS_READY.load(Ordering::Relaxed) {\n+///         assert_eq!(IMPORTANT_VARIABLE.load(Ordering::Relaxed), 42);\n+///     }\n+/// }\n+/// ```\n+///\n /// [`fence`]: fn.fence.html\n /// [`Ordering`]: enum.Ordering.html\n /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n /// [`Release`]: enum.Ordering.html#variant.Release\n /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n+/// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n #[inline]\n-#[unstable(feature = \"compiler_fences\", issue = \"41091\")]\n+#[stable(feature = \"compiler_fences\", since = \"1.22.0\")]\n pub fn compiler_fence(order: Ordering) {\n     unsafe {\n         match order {"}]}