{"sha": "cbf666dbc1409f1afbe866ba03755e44dbd1927c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiZjY2NmRiYzE0MDlmMWFmYmU4NjZiYTAzNzU1ZTQ0ZGJkMTkyN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-18T01:31:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-18T01:31:10Z"}, "message": "Auto merge of #82241 - Dylan-DPC:rollup-munmzg5, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #77728 (Expose force_quotes on Windows.)\n - #80572 (Add a `Result::into_ok_or_err` method to extract a `T` from `Result<T, T>`)\n - #81860 (Fix SourceMap::start_point)\n - #81869 (Simplify pattern grammar, improve or-pattern diagnostics)\n - #81898 (Fix debug information for function arguments of type &str or slice.)\n - #81972 (Placeholder lifetime error cleanup)\n - #82007 (Implement reborrow for closure captures)\n - #82021 (Spell out nested Self type in lint message)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "732f41658ac528cc398e033decfc6ad75909832f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/732f41658ac528cc398e033decfc6ad75909832f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbf666dbc1409f1afbe866ba03755e44dbd1927c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf666dbc1409f1afbe866ba03755e44dbd1927c", "html_url": "https://github.com/rust-lang/rust/commit/cbf666dbc1409f1afbe866ba03755e44dbd1927c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbf666dbc1409f1afbe866ba03755e44dbd1927c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93f6a4b9d85b7eef71e17d95c113f5834238b574", "url": "https://api.github.com/repos/rust-lang/rust/commits/93f6a4b9d85b7eef71e17d95c113f5834238b574", "html_url": "https://github.com/rust-lang/rust/commit/93f6a4b9d85b7eef71e17d95c113f5834238b574"}, {"sha": "f7501b6d5ec7b72a696d4f7e03fbb47116c7b71f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7501b6d5ec7b72a696d4f7e03fbb47116c7b71f", "html_url": "https://github.com/rust-lang/rust/commit/f7501b6d5ec7b72a696d4f7e03fbb47116c7b71f"}], "stats": {"total": 1993, "additions": 1111, "deletions": 882}, "files": [{"sha": "ea59e1831188b82bca2bb0db58037f9d3c1bcba9", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -320,6 +320,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>> {\n         let full_debug_info = self.cx.sess().opts.debuginfo == DebugInfo::Full;\n \n+        let target_is_msvc = self.cx.sess().target.is_like_msvc;\n+\n         if !full_debug_info && self.cx.sess().fewer_names() {\n             return None;\n         }\n@@ -341,11 +343,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n                         {\n                             let arg_index = place.local.index() - 1;\n-\n-                            // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n-                            // offset in closures to account for the hidden environment?\n-                            // Also, is this `+ 1` needed at all?\n-                            VariableKind::ArgumentVariable(arg_index + 1)\n+                            if target_is_msvc {\n+                                // Rust compiler decomposes every &str or slice argument into two components:\n+                                // a pointer to the memory address where the data is stored and a usize representing\n+                                // the length of the str (or slice). These components will later be used to reconstruct\n+                                // the original argument inside the body of the function that owns it (see the\n+                                // definition of debug_introduce_local for more details).\n+                                //\n+                                // Since the original argument is declared inside a function rather than being passed\n+                                // in as an argument, it must be marked as a LocalVariable for MSVC debuggers to visualize\n+                                // its data correctly. (See issue #81894 for an in-depth description of the problem).\n+                                match *var_ty.kind() {\n+                                    ty::Ref(_, inner_type, _) => match *inner_type.kind() {\n+                                        ty::Slice(_) | ty::Str => VariableKind::LocalVariable,\n+                                        _ => VariableKind::ArgumentVariable(arg_index + 1),\n+                                    },\n+                                    _ => VariableKind::ArgumentVariable(arg_index + 1),\n+                                }\n+                            } else {\n+                                // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n+                                // offset in closures to account for the hidden environment?\n+                                // Also, is this `+ 1` needed at all?\n+                                VariableKind::ArgumentVariable(arg_index + 1)\n+                            }\n                         } else {\n                             VariableKind::LocalVariable\n                         };"}, {"sha": "f23e3b9f7471a865a22daae11eca453206f833aa", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -22,7 +22,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n-use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, Parser};\n+use rustc_parse::parser::{AttemptLocalParseRecovery, ForceCollect, GateOr, Parser, RecoverComma};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -914,7 +914,9 @@ pub fn parse_ast_fragment<'a>(\n             }\n         }\n         AstFragmentKind::Ty => AstFragment::Ty(this.parse_ty()?),\n-        AstFragmentKind::Pat => AstFragment::Pat(this.parse_pat(None)?),\n+        AstFragmentKind::Pat => {\n+            AstFragment::Pat(this.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)?)\n+        }\n         AstFragmentKind::Arms\n         | AstFragmentKind::Fields\n         | AstFragmentKind::FieldPats"}, {"sha": "0599c78ebfd079295788debc9d11bf4123a2a54a", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -43,7 +43,7 @@ impl<'cx, 'tcx> NiceRegionError<'cx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'cx>> {\n+    pub fn try_report_from_nll(&self) -> Option<DiagnosticBuilder<'tcx>> {\n         // Due to the improved diagnostics returned by the MIR borrow checker, only a subset of\n         // the nice region errors are required when running under the MIR borrow checker.\n         self.try_report_named_anon_conflict().or_else(|| self.try_report_placeholder_conflict())"}, {"sha": "2f622231a081ed07a562725b4e4baa6902388e07", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::ty;\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n-    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n+    pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'tcx>> {\n         let (span, sub, sup) = self.regions()?;\n \n         debug!("}, {"sha": "4aecc2f40b8741599ee61e8966ff1de700dd8344", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 126, "deletions": 106, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -16,7 +16,7 @@ use std::fmt::{self, Write};\n impl NiceRegionError<'me, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n     /// an anonymous region, emit a descriptive diagnostic error.\n-    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'me>> {\n+    pub(super) fn try_report_placeholder_conflict(&self) -> Option<DiagnosticBuilder<'tcx>> {\n         match &self.error {\n             ///////////////////////////////////////////////////////////////////////////\n             // NB. The ordering of cases in this match is very\n@@ -30,157 +30,153 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 Some(sub_placeholder),\n                 Some(sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_placeholder @ ty::RePlaceholder(_),\n                 _,\n                 _,\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 Some(sub_placeholder),\n                 None,\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 _,\n                 _,\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::UpperBoundUniverseConflict(\n                 vid,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sup_placeholder @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 Some(self.tcx().mk_region(ty::ReVar(*vid))),\n                 cause,\n                 None,\n                 Some(*sup_placeholder),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region @ ty::RePlaceholder(_),\n                 sup_region @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n+            )) => self.try_report_trait_placeholder_mismatch(\n                 None,\n                 cause,\n                 Some(*sub_region),\n                 Some(*sup_region),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region @ ty::RePlaceholder(_),\n                 sup_region,\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n-                Some(sup_region),\n+            )) => self.try_report_trait_placeholder_mismatch(\n+                (!sup_region.has_name()).then_some(sup_region),\n                 cause,\n-                Some(*sub_region),\n+                Some(sub_region),\n                 None,\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                values,\n+            ),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(box TypeTrace {\n-                    cause,\n-                    values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n-                }),\n+                SubregionOrigin::Subtype(box TypeTrace { cause, values }),\n                 sub_region,\n                 sup_region @ ty::RePlaceholder(_),\n-            )) if expected.def_id == found.def_id => Some(self.try_report_placeholders_trait(\n-                Some(sub_region),\n+            )) => self.try_report_trait_placeholder_mismatch(\n+                (!sub_region.has_name()).then_some(sub_region),\n                 cause,\n                 None,\n-                Some(*sup_region),\n-                expected.def_id,\n-                expected.substs,\n-                found.substs,\n-            )),\n+                Some(sup_region),\n+                values,\n+            ),\n \n             _ => None,\n         }\n     }\n \n+    fn try_report_trait_placeholder_mismatch(\n+        &self,\n+        vid: Option<ty::Region<'tcx>>,\n+        cause: &ObligationCause<'tcx>,\n+        sub_placeholder: Option<ty::Region<'tcx>>,\n+        sup_placeholder: Option<ty::Region<'tcx>>,\n+        value_pairs: &ValuePairs<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        let (expected_substs, found_substs, trait_def_id) = match value_pairs {\n+            ValuePairs::TraitRefs(ExpectedFound { expected, found })\n+                if expected.def_id == found.def_id =>\n+            {\n+                (expected.substs, found.substs, expected.def_id)\n+            }\n+            ValuePairs::PolyTraitRefs(ExpectedFound { expected, found })\n+                if expected.def_id() == found.def_id() =>\n+            {\n+                // It's possible that the placeholders come from a binder\n+                // outside of this value pair. Use `no_bound_vars` as a\n+                // simple heuristic for that.\n+                (expected.no_bound_vars()?.substs, found.no_bound_vars()?.substs, expected.def_id())\n+            }\n+            _ => return None,\n+        };\n+\n+        Some(self.report_trait_placeholder_mismatch(\n+            vid,\n+            cause,\n+            sub_placeholder,\n+            sup_placeholder,\n+            trait_def_id,\n+            expected_substs,\n+            found_substs,\n+        ))\n+    }\n+\n     // error[E0308]: implementation of `Foo` does not apply to enough lifetimes\n     //   --> /home/nmatsakis/tmp/foo.rs:12:5\n     //    |\n@@ -190,7 +186,8 @@ impl NiceRegionError<'me, 'tcx> {\n     //    = note: Due to a where-clause on the function `all`,\n     //    = note: `T` must implement `...` for any two lifetimes `'1` and `'2`.\n     //    = note: However, the type `T` only implements `...` for some specific lifetime `'2`.\n-    fn try_report_placeholders_trait(\n+    #[instrument(level = \"debug\", skip(self))]\n+    fn report_trait_placeholder_mismatch(\n         &self,\n         vid: Option<ty::Region<'tcx>>,\n         cause: &ObligationCause<'tcx>,\n@@ -199,28 +196,13 @@ impl NiceRegionError<'me, 'tcx> {\n         trait_def_id: DefId,\n         expected_substs: SubstsRef<'tcx>,\n         actual_substs: SubstsRef<'tcx>,\n-    ) -> DiagnosticBuilder<'me> {\n-        debug!(\n-            \"try_report_placeholders_trait(\\\n-             vid={:?}, \\\n-             sub_placeholder={:?}, \\\n-             sup_placeholder={:?}, \\\n-             trait_def_id={:?}, \\\n-             expected_substs={:?}, \\\n-             actual_substs={:?})\",\n-            vid, sub_placeholder, sup_placeholder, trait_def_id, expected_substs, actual_substs\n-        );\n-\n+    ) -> DiagnosticBuilder<'tcx> {\n         let span = cause.span(self.tcx());\n         let msg = format!(\n             \"implementation of `{}` is not general enough\",\n             self.tcx().def_path_str(trait_def_id),\n         );\n         let mut err = self.tcx().sess.struct_span_err(span, &msg);\n-        err.span_label(\n-            self.tcx().def_span(trait_def_id),\n-            format!(\"trait `{}` defined here\", self.tcx().def_path_str(trait_def_id)),\n-        );\n \n         let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = cause.code {\n             err.span_label(span, \"doesn't satisfy where-clause\");\n@@ -285,17 +267,13 @@ impl NiceRegionError<'me, 'tcx> {\n \n         let any_self_ty_has_vid = actual_self_ty_has_vid || expected_self_ty_has_vid;\n \n-        debug!(\"try_report_placeholders_trait: actual_has_vid={:?}\", actual_has_vid);\n-        debug!(\"try_report_placeholders_trait: expected_has_vid={:?}\", expected_has_vid);\n-        debug!(\"try_report_placeholders_trait: has_sub={:?}\", has_sub);\n-        debug!(\"try_report_placeholders_trait: has_sup={:?}\", has_sup);\n         debug!(\n-            \"try_report_placeholders_trait: actual_self_ty_has_vid={:?}\",\n-            actual_self_ty_has_vid\n-        );\n-        debug!(\n-            \"try_report_placeholders_trait: expected_self_ty_has_vid={:?}\",\n-            expected_self_ty_has_vid\n+            ?actual_has_vid,\n+            ?expected_has_vid,\n+            ?has_sub,\n+            ?has_sup,\n+            ?actual_self_ty_has_vid,\n+            ?expected_self_ty_has_vid,\n         );\n \n         self.explain_actual_impl_that_was_found(\n@@ -388,6 +366,8 @@ impl NiceRegionError<'me, 'tcx> {\n             value: trait_ref,\n         };\n \n+        let same_self_type = actual_trait_ref.self_ty() == expected_trait_ref.self_ty();\n+\n         let mut expected_trait_ref = highlight_trait_ref(expected_trait_ref);\n         expected_trait_ref.highlight.maybe_highlighting_region(sub_placeholder, has_sub);\n         expected_trait_ref.highlight.maybe_highlighting_region(sup_placeholder, has_sup);\n@@ -403,7 +383,42 @@ impl NiceRegionError<'me, 'tcx> {\n                 }\n             };\n \n-            let mut note = if passive_voice {\n+            let mut note = if same_self_type {\n+                let mut self_ty = expected_trait_ref.map(|tr| tr.self_ty());\n+                self_ty.highlight.maybe_highlighting_region(vid, actual_has_vid);\n+\n+                if self_ty.value.is_closure()\n+                    && self\n+                        .tcx()\n+                        .fn_trait_kind_from_lang_item(expected_trait_ref.value.def_id)\n+                        .is_some()\n+                {\n+                    let closure_sig = self_ty.map(|closure| {\n+                        if let ty::Closure(_, substs) = closure.kind() {\n+                            self.tcx().signature_unclosure(\n+                                substs.as_closure().sig(),\n+                                rustc_hir::Unsafety::Normal,\n+                            )\n+                        } else {\n+                            bug!(\"type is not longer closure\");\n+                        }\n+                    });\n+\n+                    format!(\n+                        \"{}closure with signature `{}` must implement `{}`\",\n+                        if leading_ellipsis { \"...\" } else { \"\" },\n+                        closure_sig,\n+                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                    )\n+                } else {\n+                    format!(\n+                        \"{}`{}` must implement `{}`\",\n+                        if leading_ellipsis { \"...\" } else { \"\" },\n+                        self_ty,\n+                        expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                    )\n+                }\n+            } else if passive_voice {\n                 format!(\n                     \"{}`{}` would have to be implemented for the type `{}`\",\n                     if leading_ellipsis { \"...\" } else { \"\" },\n@@ -449,7 +464,12 @@ impl NiceRegionError<'me, 'tcx> {\n                 None => true,\n             };\n \n-            let mut note = if passive_voice {\n+            let mut note = if same_self_type {\n+                format!(\n+                    \"...but it actually implements `{}`\",\n+                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n+                )\n+            } else if passive_voice {\n                 format!(\n                     \"...but `{}` is actually implemented for the type `{}`\",\n                     actual_trait_ref.map(|tr| tr.print_only_trait_path()),"}, {"sha": "0f49386dec07b083e80293934094cc9b14437159", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1654,7 +1654,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n-        let pat = self.parse_pat(Some(\"argument name\"))?;\n+        let pat = self.parse_pat_no_top_alt(Some(\"argument name\"))?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n "}, {"sha": "59fd060aa24658f3bb6a4156af7b21eb1def6e9b", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1726,7 +1726,7 @@ impl<'a> Parser<'a> {\n         let lo = self.token.span;\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n-            let pat = this.parse_pat(PARAM_EXPECTED)?;\n+            let pat = this.parse_pat_no_top_alt(PARAM_EXPECTED)?;\n             let ty = if this.eat(&token::Colon) {\n                 this.parse_ty()?\n             } else {\n@@ -1803,7 +1803,7 @@ impl<'a> Parser<'a> {\n     /// The `let` token has already been eaten.\n     fn parse_let_expr(&mut self, attrs: AttrVec) -> PResult<'a, P<Expr>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_top_pat(GateOr::No, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(None, GateOr::No, RecoverComma::Yes)?;\n         self.expect(&token::Eq)?;\n         let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n@@ -1866,7 +1866,7 @@ impl<'a> Parser<'a> {\n             _ => None,\n         };\n \n-        let pat = self.parse_top_pat(GateOr::Yes, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::Yes)?;\n         if !self.eat_keyword(kw::In) {\n             self.error_missing_in_for_loop();\n         }\n@@ -1977,7 +1977,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n-            let pat = this.parse_top_pat(GateOr::No, RecoverComma::Yes)?;\n+            let pat = this.parse_pat_allow_top_alt(None, GateOr::No, RecoverComma::Yes)?;\n             let guard = if this.eat_keyword(kw::If) {\n                 let if_span = this.prev_token.span;\n                 let cond = this.parse_expr()?;"}, {"sha": "ace4134b1f698362872b2dc204f079ce488685c2", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -14,6 +14,7 @@ use crate::lexer::UnmatchedBrace;\n pub use attr_wrapper::AttrWrapper;\n pub use diagnostics::AttemptLocalParseRecovery;\n use diagnostics::Error;\n+pub use pat::{GateOr, RecoverComma};\n pub use path::PathStyle;\n \n use rustc_ast::ptr::P;"}, {"sha": "a84ae5151442d8c9f0c6c5c1d5b53bebe45612c2", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -120,9 +120,9 @@ impl<'a> Parser<'a> {\n             },\n             NonterminalKind::Pat2018 { .. } | NonterminalKind::Pat2021 { .. } => {\n                 token::NtPat(self.collect_tokens_no_attrs(|this| match kind {\n-                    NonterminalKind::Pat2018 { .. } => this.parse_pat(None),\n+                    NonterminalKind::Pat2018 { .. } => this.parse_pat_no_top_alt(None),\n                     NonterminalKind::Pat2021 { .. } => {\n-                        this.parse_top_pat(GateOr::Yes, RecoverComma::No)\n+                        this.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)\n                     }\n                     _ => unreachable!(),\n                 })?)"}, {"sha": "8874548da784df87e2bd16dae267174620fb40e0", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 102, "deletions": 81, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -19,14 +19,14 @@ const WHILE_PARSING_OR_MSG: &str = \"while parsing this or-pattern starting here\"\n \n /// Whether or not an or-pattern should be gated when occurring in the current context.\n #[derive(PartialEq, Clone, Copy)]\n-pub(super) enum GateOr {\n+pub enum GateOr {\n     Yes,\n     No,\n }\n \n /// Whether or not to recover a `,` when parsing or-patterns.\n #[derive(PartialEq, Copy, Clone)]\n-pub(super) enum RecoverComma {\n+pub enum RecoverComma {\n     Yes,\n     No,\n }\n@@ -37,80 +37,57 @@ impl<'a> Parser<'a> {\n     /// Corresponds to `pat<no_top_alt>` in RFC 2535 and does not admit or-patterns\n     /// at the top level. Used when parsing the parameters of lambda expressions,\n     /// functions, function pointers, and `pat` macro fragments.\n-    pub fn parse_pat(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n+    pub fn parse_pat_no_top_alt(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n \n-    /// Entry point to the main pattern parser.\n+    /// Parses a pattern.\n+    ///\n     /// Corresponds to `top_pat` in RFC 2535 and allows or-pattern at the top level.\n-    pub(super) fn parse_top_pat(\n+    /// Used for parsing patterns in all cases when `pat<no_top_alt>` is not used.\n+    ///\n+    /// Note that after the FCP in <https://github.com/rust-lang/rust/issues/81415>,\n+    /// a leading vert is allowed in nested or-patterns, too. This allows us to\n+    /// simplify the grammar somewhat.\n+    pub fn parse_pat_allow_top_alt(\n         &mut self,\n+        expected: Expected,\n         gate_or: GateOr,\n         rc: RecoverComma,\n     ) -> PResult<'a, P<Pat>> {\n         // Allow a '|' before the pats (RFCs 1925, 2530, and 2535).\n-        let gated_leading_vert = self.eat_or_separator(None) && gate_or == GateOr::Yes;\n-        let leading_vert_span = self.prev_token.span;\n-\n-        // Parse the possibly-or-pattern.\n-        let pat = self.parse_pat_with_or(None, gate_or, rc)?;\n-\n-        // If we parsed a leading `|` which should be gated,\n-        // and no other gated or-pattern has been parsed thus far,\n-        // then we should really gate the leading `|`.\n-        // This complicated procedure is done purely for diagnostics UX.\n-        if gated_leading_vert && self.sess.gated_spans.is_ungated(sym::or_patterns) {\n-            self.sess.gated_spans.gate(sym::or_patterns, leading_vert_span);\n-        }\n-\n-        Ok(pat)\n-    }\n-\n-    /// Parse the pattern for a function or function pointer parameter.\n-    /// Special recovery is provided for or-patterns and leading `|`.\n-    pub(super) fn parse_fn_param_pat(&mut self) -> PResult<'a, P<Pat>> {\n-        self.recover_leading_vert(None, \"not allowed in a parameter pattern\");\n-        let pat = self.parse_pat_with_or(PARAM_EXPECTED, GateOr::No, RecoverComma::No)?;\n-\n-        if let PatKind::Or(..) = &pat.kind {\n-            self.ban_illegal_fn_param_or_pat(&pat);\n-        }\n-\n-        Ok(pat)\n-    }\n+        let leading_vert_span =\n+            if self.eat_or_separator(None) { Some(self.prev_token.span) } else { None };\n \n-    /// Ban `A | B` immediately in a parameter pattern and suggest wrapping in parens.\n-    fn ban_illegal_fn_param_or_pat(&self, pat: &Pat) {\n-        let msg = \"wrap the pattern in parenthesis\";\n-        let fix = format!(\"({})\", pprust::pat_to_string(pat));\n-        self.struct_span_err(pat.span, \"an or-pattern parameter must be wrapped in parenthesis\")\n-            .span_suggestion(pat.span, msg, fix, Applicability::MachineApplicable)\n-            .emit();\n-    }\n-\n-    /// Parses a pattern, that may be a or-pattern (e.g. `Foo | Bar` in `Some(Foo | Bar)`).\n-    /// Corresponds to `pat<allow_top_alt>` in RFC 2535.\n-    fn parse_pat_with_or(\n-        &mut self,\n-        expected: Expected,\n-        gate_or: GateOr,\n-        rc: RecoverComma,\n-    ) -> PResult<'a, P<Pat>> {\n         // Parse the first pattern (`p_0`).\n-        let first_pat = self.parse_pat(expected)?;\n+        let first_pat = self.parse_pat_no_top_alt(expected)?;\n         self.maybe_recover_unexpected_comma(first_pat.span, rc, gate_or)?;\n \n         // If the next token is not a `|`,\n         // this is not an or-pattern and we should exit here.\n         if !self.check(&token::BinOp(token::Or)) && self.token != token::OrOr {\n+            // If we parsed a leading `|` which should be gated,\n+            // then we should really gate the leading `|`.\n+            // This complicated procedure is done purely for diagnostics UX.\n+            if let Some(leading_vert_span) = leading_vert_span {\n+                if gate_or == GateOr::Yes && self.sess.gated_spans.is_ungated(sym::or_patterns) {\n+                    self.sess.gated_spans.gate(sym::or_patterns, leading_vert_span);\n+                }\n+\n+                // If there was a leading vert, treat this as an or-pattern. This improves\n+                // diagnostics.\n+                let span = leading_vert_span.to(self.prev_token.span);\n+                return Ok(self.mk_pat(span, PatKind::Or(vec![first_pat])));\n+            }\n+\n             return Ok(first_pat);\n         }\n \n         // Parse the patterns `p_1 | ... | p_n` where `n > 0`.\n-        let lo = first_pat.span;\n+        let lo = leading_vert_span.unwrap_or(first_pat.span);\n         let mut pats = vec![first_pat];\n         while self.eat_or_separator(Some(lo)) {\n-            let pat = self.parse_pat(expected).map_err(|mut err| {\n+            let pat = self.parse_pat_no_top_alt(expected).map_err(|mut err| {\n                 err.span_label(lo, WHILE_PARSING_OR_MSG);\n                 err\n             })?;\n@@ -127,6 +104,62 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n     }\n \n+    /// Parse the pattern for a function or function pointer parameter.\n+    pub(super) fn parse_fn_param_pat(&mut self) -> PResult<'a, P<Pat>> {\n+        // We actually do _not_ allow top-level or-patterns in function params, but we use\n+        // `parse_pat_allow_top_alt` anyway so that we can detect when a user tries to use it. This\n+        // allows us to print a better error message.\n+        //\n+        // In order to get good UX, we first recover in the case of a leading vert for an illegal\n+        // top-level or-pat. Normally, this means recovering both `|` and `||`, but in this case,\n+        // a leading `||` probably doesn't indicate an or-pattern attempt, so we handle that\n+        // separately.\n+        if let token::OrOr = self.token.kind {\n+            let span = self.token.span;\n+            let mut err = self.struct_span_err(span, \"unexpected `||` before function parameter\");\n+            err.span_suggestion(\n+                span,\n+                \"remove the `||`\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\"alternatives in or-patterns are separated with `|`, not `||`\");\n+            err.emit();\n+            self.bump();\n+        }\n+\n+        let pat = self.parse_pat_allow_top_alt(PARAM_EXPECTED, GateOr::No, RecoverComma::No)?;\n+\n+        if let PatKind::Or(..) = &pat.kind {\n+            self.ban_illegal_fn_param_or_pat(&pat);\n+        }\n+\n+        Ok(pat)\n+    }\n+\n+    /// Ban `A | B` immediately in a parameter pattern and suggest wrapping in parens.\n+    fn ban_illegal_fn_param_or_pat(&self, pat: &Pat) {\n+        // If all we have a leading vert, then print a special message. This is the case if\n+        // `parse_pat_allow_top_alt` returns an or-pattern with one variant.\n+        let (msg, fix) = match &pat.kind {\n+            PatKind::Or(pats) if pats.len() == 1 => {\n+                let msg = \"remove the leading `|`\";\n+                let fix = pprust::pat_to_string(pat);\n+                (msg, fix)\n+            }\n+\n+            _ => {\n+                let msg = \"wrap the pattern in parentheses\";\n+                let fix = format!(\"({})\", pprust::pat_to_string(pat));\n+                (msg, fix)\n+            }\n+        };\n+\n+        self.struct_span_err(pat.span, \"an or-pattern parameter must be wrapped in parentheses\")\n+            .span_suggestion(pat.span, msg, fix, Applicability::MachineApplicable)\n+            .emit();\n+    }\n+\n     /// Eat the or-pattern `|` separator.\n     /// If instead a `||` token is encountered, recover and pretend we parsed `|`.\n     fn eat_or_separator(&mut self, lo: Option<Span>) -> bool {\n@@ -179,7 +212,7 @@ impl<'a> Parser<'a> {\n \n     /// We have parsed `||` instead of `|`. Error and suggest `|` instead.\n     fn ban_unexpected_or_or(&mut self, lo: Option<Span>) {\n-        let mut err = self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\");\n+        let mut err = self.struct_span_err(self.token.span, \"unexpected token `||` in pattern\");\n         err.span_suggestion(\n             self.token.span,\n             \"use a single `|` to separate multiple alternative patterns\",\n@@ -244,30 +277,14 @@ impl<'a> Parser<'a> {\n     /// sequence of patterns until `)` is reached.\n     fn skip_pat_list(&mut self) -> PResult<'a, ()> {\n         while !self.check(&token::CloseDelim(token::Paren)) {\n-            self.parse_pat(None)?;\n+            self.parse_pat_no_top_alt(None)?;\n             if !self.eat(&token::Comma) {\n                 return Ok(());\n             }\n         }\n         Ok(())\n     }\n \n-    /// Recursive possibly-or-pattern parser with recovery for an erroneous leading `|`.\n-    /// See `parse_pat_with_or` for details on parsing or-patterns.\n-    fn parse_pat_with_or_inner(&mut self) -> PResult<'a, P<Pat>> {\n-        self.recover_leading_vert(None, \"only allowed in a top-level pattern\");\n-        self.parse_pat_with_or(None, GateOr::Yes, RecoverComma::No)\n-    }\n-\n-    /// Recover if `|` or `||` is here.\n-    /// The user is thinking that a leading `|` is allowed in this position.\n-    fn recover_leading_vert(&mut self, lo: Option<Span>, ctx: &str) {\n-        if let token::BinOp(token::Or) | token::OrOr = self.token.kind {\n-            self.ban_illegal_vert(lo, \"leading\", ctx);\n-            self.bump();\n-        }\n-    }\n-\n     /// A `|` or possibly `||` token shouldn't be here. Ban it.\n     fn ban_illegal_vert(&mut self, lo: Option<Span>, pos: &str, ctx: &str) {\n         let span = self.token.span;\n@@ -305,8 +322,9 @@ impl<'a> Parser<'a> {\n             self.parse_pat_tuple_or_parens()?\n         } else if self.check(&token::OpenDelim(token::Bracket)) {\n             // Parse `[pat, pat,...]` as a slice pattern.\n-            let (pats, _) =\n-                self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat_with_or_inner())?;\n+            let (pats, _) = self.parse_delim_comma_seq(token::Bracket, |p| {\n+                p.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)\n+            })?;\n             PatKind::Slice(pats)\n         } else if self.check(&token::DotDot) && !self.is_pat_range_end_start(1) {\n             // A rest pattern `..`.\n@@ -429,7 +447,7 @@ impl<'a> Parser<'a> {\n \n         // At this point we attempt to parse `@ $pat_rhs` and emit an error.\n         self.bump(); // `@`\n-        let mut rhs = self.parse_pat(None)?;\n+        let mut rhs = self.parse_pat_no_top_alt(None)?;\n         let sp = lhs.span.to(rhs.span);\n \n         if let PatKind::Ident(_, _, ref mut sub @ None) = rhs.kind {\n@@ -518,8 +536,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse a tuple or parenthesis pattern.\n     fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n-        let (fields, trailing_comma) =\n-            self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner())?;\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| {\n+            p.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)\n+        })?;\n \n         // Here, `(pat,)` is a tuple pattern.\n         // For backward compatibility, `(..)` is a tuple pattern as well.\n@@ -548,7 +567,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // Parse the pattern we hope to be an identifier.\n-        let mut pat = self.parse_pat(Some(\"identifier\"))?;\n+        let mut pat = self.parse_pat_no_top_alt(Some(\"identifier\"))?;\n \n         // If we don't have `mut $ident (@ pat)?`, error.\n         if let PatKind::Ident(BindingMode::ByValue(m @ Mutability::Not), ..) = &mut pat.kind {\n@@ -793,7 +812,7 @@ impl<'a> Parser<'a> {\n     fn parse_pat_ident(&mut self, binding_mode: BindingMode) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n-            Some(self.parse_pat(Some(\"binding pattern\"))?)\n+            Some(self.parse_pat_no_top_alt(Some(\"binding pattern\"))?)\n         } else {\n             None\n         };\n@@ -832,7 +851,9 @@ impl<'a> Parser<'a> {\n         if qself.is_some() {\n             return self.error_qpath_before_pat(&path, \"(\");\n         }\n-        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat_with_or_inner())?;\n+        let (fields, _) = self.parse_paren_comma_seq(|p| {\n+            p.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)\n+        })?;\n         Ok(PatKind::TupleStruct(path, fields))\n     }\n \n@@ -998,7 +1019,7 @@ impl<'a> Parser<'a> {\n             // Parsing a pattern of the form `fieldname: pat`.\n             let fieldname = self.parse_field_name()?;\n             self.bump();\n-            let pat = self.parse_pat_with_or_inner()?;\n+            let pat = self.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::No)?;\n             hi = pat.span;\n             (pat, fieldname, false)\n         } else {"}, {"sha": "2e00ddfaacc81a27324fb44cb2216e2451c85232", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -220,7 +220,7 @@ impl<'a> Parser<'a> {\n     /// Parses a local variable declaration.\n     fn parse_local(&mut self, attrs: AttrVec) -> PResult<'a, P<Local>> {\n         let lo = self.prev_token.span;\n-        let pat = self.parse_top_pat(GateOr::Yes, RecoverComma::Yes)?;\n+        let pat = self.parse_pat_allow_top_alt(None, GateOr::Yes, RecoverComma::Yes)?;\n \n         let (err, ty) = if self.eat(&token::Colon) {\n             // Save the state of the parser before parsing type normally, in case there is a `:`"}, {"sha": "b7eb6d5b3790b3371f63f549f5ecde10036c9e91", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -778,16 +778,35 @@ impl SourceMap {\n         self.span_until_char(sp, '{')\n     }\n \n-    /// Returns a new span representing just the start point of this span.\n+    /// Returns a new span representing just the first character of the given span.\n     pub fn start_point(&self, sp: Span) -> Span {\n-        let pos = sp.lo().0;\n-        let width = self.find_width_of_character_at_span(sp, false);\n-        let corrected_start_position = pos.checked_add(width).unwrap_or(pos);\n-        let end_point = BytePos(cmp::max(corrected_start_position, sp.lo().0));\n-        sp.with_hi(end_point)\n+        let width = {\n+            let sp = sp.data();\n+            let local_begin = self.lookup_byte_offset(sp.lo);\n+            let start_index = local_begin.pos.to_usize();\n+            let src = local_begin.sf.external_src.borrow();\n+\n+            let snippet = if let Some(ref src) = local_begin.sf.src {\n+                Some(&src[start_index..])\n+            } else if let Some(src) = src.get_source() {\n+                Some(&src[start_index..])\n+            } else {\n+                None\n+            };\n+\n+            match snippet {\n+                None => 1,\n+                Some(snippet) => match snippet.chars().next() {\n+                    None => 1,\n+                    Some(c) => c.len_utf8(),\n+                },\n+            }\n+        };\n+\n+        sp.with_hi(BytePos(sp.lo().0 + width as u32))\n     }\n \n-    /// Returns a new span representing just the end point of this span.\n+    /// Returns a new span representing just the last character of this span.\n     pub fn end_point(&self, sp: Span) -> Span {\n         let pos = sp.hi().0;\n \n@@ -816,7 +835,8 @@ impl SourceMap {\n         Span::new(BytePos(start_of_next_point), end_of_next_point, sp.ctxt())\n     }\n \n-    /// Finds the width of a character, either before or after the provided span.\n+    /// Finds the width of the character, either before or after the end of provided span,\n+    /// depending on the `forwards` parameter.\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {\n         let sp = sp.data();\n         if sp.lo == sp.hi {\n@@ -863,11 +883,9 @@ impl SourceMap {\n         // We need to extend the snippet to the end of the src rather than to end_index so when\n         // searching forwards for boundaries we've got somewhere to search.\n         let snippet = if let Some(ref src) = local_begin.sf.src {\n-            let len = src.len();\n-            &src[start_index..len]\n+            &src[start_index..]\n         } else if let Some(src) = src.get_source() {\n-            let len = src.len();\n-            &src[start_index..len]\n+            &src[start_index..]\n         } else {\n             return 1;\n         };"}, {"sha": "5d7f5bf1c7b8001b06800c7de473ca09007d476a", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -7,8 +7,9 @@ use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorReported};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n-use rustc_hir::{ItemKind, Node};\n+use rustc_hir::{def::Res, ItemKind, Node, PathSegment};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n@@ -513,10 +514,11 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n-    #[derive(Debug)]\n     struct ProhibitOpaqueVisitor<'tcx> {\n         opaque_identity_ty: Ty<'tcx>,\n         generics: &'tcx ty::Generics,\n+        tcx: TyCtxt<'tcx>,\n+        selftys: Vec<(Span, Option<String>)>,\n     }\n \n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n@@ -533,6 +535,29 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n+    impl Visitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n+        type Map = rustc_middle::hir::map::Map<'tcx>;\n+\n+        fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+            hir::intravisit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+        }\n+\n+        fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n+            match arg.kind {\n+                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n+                    [PathSegment { res: Some(Res::SelfTy(_, impl_ref)), .. }] => {\n+                        let impl_ty_name =\n+                            impl_ref.map(|(def_id, _)| self.tcx.def_path_str(def_id));\n+                        self.selftys.push((path.span, impl_ty_name));\n+                    }\n+                    _ => {}\n+                },\n+                _ => {}\n+            }\n+            hir::intravisit::walk_ty(self, arg);\n+        }\n+    }\n+\n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n         origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n         ..\n@@ -544,17 +569,20 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n             ),\n             generics: tcx.generics_of(def_id),\n+            tcx,\n+            selftys: vec![],\n         };\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n             .iter()\n             .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n         debug!(\n-            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor={:?}\",\n-            prohibit_opaque, visitor\n+            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor.opaque_identity_ty={:?}, visitor.generics={:?}\",\n+            prohibit_opaque, visitor.opaque_identity_ty, visitor.generics\n         );\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n+            visitor.visit_item(&item);\n             let is_async = match item.kind {\n                 ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {\n                     matches!(origin, hir::OpaqueTyOrigin::AsyncFn)\n@@ -571,15 +599,13 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n                 if is_async { \"async fn\" } else { \"impl Trait\" },\n             );\n \n-            if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n-                if snippet == \"Self\" {\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider spelling out the type instead\",\n-                        format!(\"{:?}\", ty),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+            for (span, name) in visitor.selftys {\n+                err.span_suggestion(\n+                    span,\n+                    \"consider spelling out the type instead\",\n+                    name.unwrap_or_else(|| format!(\"{:?}\", ty)),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n             err.emit();\n         }"}, {"sha": "69c09528662d37d5c2f7535679e6be9935670461", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -180,7 +180,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     debug!(\"seed place {:?}\", place);\n \n                     let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n-                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let capture_kind =\n+                        self.init_capture_kind_for_place(&place, capture_clause, upvar_id, span);\n                     let fake_info = ty::CaptureInfo {\n                         capture_kind_expr_id: None,\n                         path_expr_id: None,\n@@ -205,11 +206,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If we have an origin, store it.\n             if let Some(origin) = delegate.current_origin.clone() {\n                 let origin = if self.tcx.features().capture_disjoint_fields {\n-                    origin\n+                    (origin.0, restrict_capture_precision(origin.1))\n                 } else {\n-                    // FIXME(project-rfc-2229#31): Once the changes to support reborrowing are\n-                    //                             made, make sure we are selecting and restricting\n-                    //                             the origin correctly.\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n \n@@ -449,7 +447,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(place, capture_info.capture_kind);\n+            let place = restrict_capture_precision(place);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n@@ -897,15 +895,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn init_capture_kind(\n+    fn init_capture_kind_for_place(\n         &self,\n+        place: &Place<'tcx>,\n         capture_clause: hir::CaptureBy,\n         upvar_id: ty::UpvarId,\n         closure_span: Span,\n     ) -> ty::UpvarCapture<'tcx> {\n         match capture_clause {\n-            hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n-            hir::CaptureBy::Ref => {\n+            // In case of a move closure if the data is accessed through a reference we\n+            // want to capture by ref to allow precise capture using reborrows.\n+            //\n+            // If the data will be moved out of this place, then the place will be truncated\n+            // at the first Deref in `adjust_upvar_borrow_kind_for_consume` and then moved into\n+            // the closure.\n+            hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n+                ty::UpvarCapture::ByValue(None)\n+            }\n+            hir::CaptureBy::Value | hir::CaptureBy::Ref => {\n                 let origin = UpvarRegion(upvar_id, closure_span);\n                 let upvar_region = self.next_region_var(origin);\n                 let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n@@ -1109,12 +1116,25 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        // we only care about moves\n-        match mode {\n-            euv::Copy => {\n+        match (self.capture_clause, mode) {\n+            // In non-move closures, we only care about moves\n+            (hir::CaptureBy::Ref, euv::Copy) => return,\n+\n+            // We want to capture Copy types that read through a ref via a reborrow\n+            (hir::CaptureBy::Value, euv::Copy)\n+                if place_with_id.place.deref_tys().any(ty::TyS::is_ref) =>\n+            {\n                 return;\n             }\n-            euv::Move => {}\n+\n+            (hir::CaptureBy::Ref, euv::Move) | (hir::CaptureBy::Value, euv::Move | euv::Copy) => {}\n+        };\n+\n+        let place = truncate_capture_for_move(place_with_id.place.clone());\n+        let place_with_id = PlaceWithHirId { place: place.clone(), hir_id: place_with_id.hir_id };\n+\n+        if !self.capture_information.contains_key(&place) {\n+            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -1128,13 +1148,15 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         let usage_span = tcx.hir().span(diag_expr_id);\n \n-        // To move out of an upvar, this must be a FnOnce closure\n-        self.adjust_closure_kind(\n-            upvar_id.closure_expr_id,\n-            ty::ClosureKind::FnOnce,\n-            usage_span,\n-            place_with_id.place.clone(),\n-        );\n+        if matches!(mode, euv::Move) {\n+            // To move out of an upvar, this must be a FnOnce closure\n+            self.adjust_closure_kind(\n+                upvar_id.closure_expr_id,\n+                ty::ClosureKind::FnOnce,\n+                usage_span,\n+                place.clone(),\n+            );\n+        }\n \n         let capture_info = ty::CaptureInfo {\n             capture_kind_expr_id: Some(diag_expr_id),\n@@ -1317,8 +1339,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            let capture_kind =\n-                self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n+            let capture_kind = self.fcx.init_capture_kind_for_place(\n+                &place_with_id.place,\n+                self.capture_clause,\n+                upvar_id,\n+                self.closure_span,\n+            );\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo {\n@@ -1392,15 +1418,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n }\n \n /// Truncate projections so that following rules are obeyed by the captured `place`:\n-///\n-/// - No Derefs in move closure, this will result in value behind a reference getting moved.\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-fn restrict_capture_precision<'tcx>(\n-    mut place: Place<'tcx>,\n-    capture_kind: ty::UpvarCapture<'tcx>,\n-) -> Place<'tcx> {\n+fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1412,7 +1433,6 @@ fn restrict_capture_precision<'tcx>(\n     }\n \n     let mut truncated_length = usize::MAX;\n-    let mut first_deref_projection = usize::MAX;\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         if proj.ty.is_unsafe_ptr() {\n@@ -1426,31 +1446,30 @@ fn restrict_capture_precision<'tcx>(\n                 truncated_length = truncated_length.min(i);\n                 break;\n             }\n-            ProjectionKind::Deref => {\n-                // We only drop Derefs in case of move closures\n-                // There might be an index projection or raw ptr ahead, so we don't stop here.\n-                first_deref_projection = first_deref_projection.min(i);\n-            }\n+            ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n             ProjectionKind::Subslice => {}  // We never capture this\n         }\n     }\n \n-    let length = place\n-        .projections\n-        .len()\n-        .min(truncated_length)\n-        // In case of capture `ByValue` we want to not capture derefs\n-        .min(match capture_kind {\n-            ty::UpvarCapture::ByValue(..) => first_deref_projection,\n-            ty::UpvarCapture::ByRef(..) => usize::MAX,\n-        });\n+    let length = place.projections.len().min(truncated_length);\n \n     place.projections.truncate(length);\n \n     place\n }\n \n+/// Truncates a place so that the resultant capture doesn't move data out of a reference\n+fn truncate_capture_for_move(mut place: Place<'tcx>) -> Place<'tcx> {\n+    if let Some(i) = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref) {\n+        // We only drop Derefs in case of move closures\n+        // There might be an index projection or raw ptr ahead, so we don't stop here.\n+        place.projections.truncate(i);\n+    }\n+\n+    place\n+}\n+\n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),"}, {"sha": "d8747f8b8d6dcb4900af1f98325333cc47cf8586", "filename": "library/core/src/result.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1276,6 +1276,41 @@ impl<T, E> Result<Result<T, E>, E> {\n     }\n }\n \n+impl<T> Result<T, T> {\n+    /// Returns the [`Ok`] value if `self` is `Ok`, and the [`Err`] value if\n+    /// `self` is `Err`.\n+    ///\n+    /// In other words, this function returns the value (the `T`) of a\n+    /// `Result<T, T>`, regardless of whether or not that result is `Ok` or\n+    /// `Err`.\n+    ///\n+    /// This can be useful in conjunction with APIs such as\n+    /// [`Atomic*::compare_exchange`], or [`slice::binary_search`][binary_search], but only in\n+    /// cases where you don't care if the result was `Ok` or not.\n+    ///\n+    /// [`Atomic*::compare_exchange`]: crate::sync::atomic::AtomicBool::compare_exchange\n+    /// [binary_search]: ../../std/primitive.slice.html#method.binary_search\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_into_ok_or_err)]\n+    /// let ok: Result<u32, u32> = Ok(3);\n+    /// let err: Result<u32, u32> = Err(4);\n+    ///\n+    /// assert_eq!(ok.into_ok_or_err(), 3);\n+    /// assert_eq!(err.into_ok_or_err(), 4);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"result_into_ok_or_err\", reason = \"newly added\", issue = \"82223\")]\n+    pub const fn into_ok_or_err(self) -> T {\n+        match self {\n+            Ok(v) => v,\n+            Err(v) => v,\n+        }\n+    }\n+}\n+\n // This is a separate function to reduce the code size of the methods\n #[inline(never)]\n #[cold]"}, {"sha": "34e05760db259d61ba96b74fb55822289fce0fb2", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -65,6 +65,7 @@\n #![feature(never_type)]\n #![feature(unwrap_infallible)]\n #![feature(option_result_unwrap_unchecked)]\n+#![feature(result_into_ok_or_err)]\n #![feature(option_unwrap_none)]\n #![feature(peekable_peek_mut)]\n #![feature(once_cell)]"}, {"sha": "5fcd7b4d3a3273d6427104d10edf8b7a8c659f08", "filename": "library/core/tests/result.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fresult.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -95,6 +95,15 @@ fn test_unwrap_or() {\n     assert_eq!(ok_err.unwrap_or(50), 50);\n }\n \n+#[test]\n+fn test_ok_or_err() {\n+    let ok: Result<isize, isize> = Ok(100);\n+    let err: Result<isize, isize> = Err(200);\n+\n+    assert_eq!(ok.into_ok_or_err(), 100);\n+    assert_eq!(err.into_ok_or_err(), 200);\n+}\n+\n #[test]\n fn test_unwrap_or_else() {\n     fn handler(msg: &'static str) -> isize {"}, {"sha": "67412e1677937b7afea82a624d6f13581bade34b", "filename": "library/std/src/sys/windows/ext/process.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fext%2Fprocess.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -105,6 +105,22 @@ pub trait CommandExt: Sealed {\n     /// [1]: https://docs.microsoft.com/en-us/windows/win32/procthread/process-creation-flags\n     #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n     fn creation_flags(&mut self, flags: u32) -> &mut process::Command;\n+\n+    /// Forces all arguments to be wrapped in quote (`\"`) characters.\n+    ///\n+    /// This is useful for passing arguments to [MSYS2/Cygwin][1] based\n+    /// executables: these programs will expand unquoted arguments containing\n+    /// wildcard characters (`?` and `*`) by searching for any file paths\n+    /// matching the wildcard pattern.\n+    ///\n+    /// Adding quotes has no effect when passing arguments to programs\n+    /// that use [msvcrt][2]. This includes programs built with both\n+    /// MinGW and MSVC.\n+    ///\n+    /// [1]: <https://github.com/msys2/MSYS2-packages/issues/2176>\n+    /// [2]: <https://msdn.microsoft.com/en-us/library/17w5ykft.aspx>\n+    #[unstable(feature = \"windows_process_extensions_force_quotes\", issue = \"82227\")]\n+    fn force_quotes(&mut self, enabled: bool) -> &mut process::Command;\n }\n \n #[stable(feature = \"windows_process_extensions\", since = \"1.16.0\")]\n@@ -113,4 +129,9 @@ impl CommandExt for process::Command {\n         self.as_inner_mut().creation_flags(flags);\n         self\n     }\n+\n+    fn force_quotes(&mut self, enabled: bool) -> &mut process::Command {\n+        self.as_inner_mut().force_quotes(enabled);\n+        self\n+    }\n }"}, {"sha": "83d37795ee5c10bf4099a561cfe3ce6427ced88a", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -78,6 +78,7 @@ pub struct Command {\n     stdin: Option<Stdio>,\n     stdout: Option<Stdio>,\n     stderr: Option<Stdio>,\n+    force_quotes_enabled: bool,\n }\n \n pub enum Stdio {\n@@ -109,6 +110,7 @@ impl Command {\n             stdin: None,\n             stdout: None,\n             stderr: None,\n+            force_quotes_enabled: false,\n         }\n     }\n \n@@ -134,6 +136,10 @@ impl Command {\n         self.flags = flags;\n     }\n \n+    pub fn force_quotes(&mut self, enabled: bool) {\n+        self.force_quotes_enabled = enabled;\n+    }\n+\n     pub fn get_program(&self) -> &OsStr {\n         &self.program\n     }\n@@ -181,7 +187,7 @@ impl Command {\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n         let program = program.as_ref().unwrap_or(&self.program);\n-        let mut cmd_str = make_command_line(program, &self.args)?;\n+        let mut cmd_str = make_command_line(program, &self.args, self.force_quotes_enabled)?;\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -467,7 +473,7 @@ fn zeroed_process_information() -> c::PROCESS_INFORMATION {\n \n // Produces a wide string *without terminating null*; returns an error if\n // `prog` or any of the `args` contain a nul.\n-fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n+fn make_command_line(prog: &OsStr, args: &[OsString], force_quotes: bool) -> io::Result<Vec<u16>> {\n     // Encode the command and arguments in a command line string such\n     // that the spawned process may recover them using CommandLineToArgvW.\n     let mut cmd: Vec<u16> = Vec::new();\n@@ -476,7 +482,7 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> io::Result<Vec<u16>> {\n     append_arg(&mut cmd, prog, true)?;\n     for arg in args {\n         cmd.push(' ' as u16);\n-        append_arg(&mut cmd, arg, false)?;\n+        append_arg(&mut cmd, arg, force_quotes)?;\n     }\n     return Ok(cmd);\n "}, {"sha": "8830ae049c65d8b10e690ab770b1ba78debb827d", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -3,29 +3,41 @@ use crate::ffi::{OsStr, OsString};\n \n #[test]\n fn test_make_command_line() {\n-    fn test_wrapper(prog: &str, args: &[&str]) -> String {\n+    fn test_wrapper(prog: &str, args: &[&str], force_quotes: bool) -> String {\n         let command_line = &make_command_line(\n             OsStr::new(prog),\n             &args.iter().map(|a| OsString::from(a)).collect::<Vec<OsString>>(),\n+            force_quotes,\n         )\n         .unwrap();\n         String::from_utf16(command_line).unwrap()\n     }\n \n-    assert_eq!(test_wrapper(\"prog\", &[\"aaa\", \"bbb\", \"ccc\"]), \"\\\"prog\\\" aaa bbb ccc\");\n+    assert_eq!(test_wrapper(\"prog\", &[\"aaa\", \"bbb\", \"ccc\"], false), \"\\\"prog\\\" aaa bbb ccc\");\n \n     assert_eq!(\n-        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\"]),\n+        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\"], false),\n         \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n     );\n     assert_eq!(\n-        test_wrapper(\"C:\\\\Program Files\\\\test\", &[\"aa\\\"bb\"]),\n+        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\", \"v*\"], false),\n+        \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa v*\"\n+    );\n+    assert_eq!(\n+        test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\", \"v*\"], true),\n+        \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" \\\"aaa\\\" \\\"v*\\\"\"\n+    );\n+    assert_eq!(\n+        test_wrapper(\"C:\\\\Program Files\\\\test\", &[\"aa\\\"bb\"], false),\n         \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n     );\n-    assert_eq!(test_wrapper(\"echo\", &[\"a b c\"]), \"\\\"echo\\\" \\\"a b c\\\"\");\n-    assert_eq!(test_wrapper(\"echo\", &[\"\\\" \\\\\\\" \\\\\", \"\\\\\"]), \"\\\"echo\\\" \\\"\\\\\\\" \\\\\\\\\\\\\\\" \\\\\\\\\\\" \\\\\");\n+    assert_eq!(test_wrapper(\"echo\", &[\"a b c\"], false), \"\\\"echo\\\" \\\"a b c\\\"\");\n+    assert_eq!(\n+        test_wrapper(\"echo\", &[\"\\\" \\\\\\\" \\\\\", \"\\\\\"], false),\n+        \"\\\"echo\\\" \\\"\\\\\\\" \\\\\\\\\\\\\\\" \\\\\\\\\\\" \\\\\"\n+    );\n     assert_eq!(\n-        test_wrapper(\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\", &[]),\n+        test_wrapper(\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\", &[], false),\n         \"\\\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\\\"\"\n     );\n }"}, {"sha": "6897b31fe46857dd89de03866b7719553126c631", "filename": "src/test/ui/associated-types/associated-types-eq-hr.stderr", "status": "modified", "additions": 15, "deletions": 50, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-eq-hr.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -31,82 +31,47 @@ LL |     bar::<IntStruct>();\n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:96:5\n    |\n-LL | / pub trait TheTrait<T> {\n-LL | |     type A;\n-LL | |\n-LL | |     fn get(&self, t: T) -> Self::A;\n-LL | | }\n-   | |_- trait `TheTrait` defined here\n-...\n-LL |       tuple_one::<Tuple>();\n-   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+LL |     tuple_one::<Tuple>();\n+   |     ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n    = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n+   = note: ...but it actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:96:5\n    |\n-LL | / pub trait TheTrait<T> {\n-LL | |     type A;\n-LL | |\n-LL | |     fn get(&self, t: T) -> Self::A;\n-LL | | }\n-   | |_- trait `TheTrait` defined here\n-...\n-LL |       tuple_one::<Tuple>();\n-   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+LL |     tuple_one::<Tuple>();\n+   |     ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n    = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n+   = note: ...but it actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:102:5\n    |\n-LL | / pub trait TheTrait<T> {\n-LL | |     type A;\n-LL | |\n-LL | |     fn get(&self, t: T) -> Self::A;\n-LL | | }\n-   | |_- trait `TheTrait` defined here\n-...\n-LL |       tuple_two::<Tuple>();\n-   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+LL |     tuple_two::<Tuple>();\n+   |     ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n    = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n+   = note: ...but it actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:102:5\n    |\n-LL | / pub trait TheTrait<T> {\n-LL | |     type A;\n-LL | |\n-LL | |     fn get(&self, t: T) -> Self::A;\n-LL | | }\n-   | |_- trait `TheTrait` defined here\n-...\n-LL |       tuple_two::<Tuple>();\n-   |       ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+LL |     tuple_two::<Tuple>();\n+   |     ^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n    = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n+   = note: ...but it actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: implementation of `TheTrait` is not general enough\n   --> $DIR/associated-types-eq-hr.rs:112:5\n    |\n-LL | / pub trait TheTrait<T> {\n-LL | |     type A;\n-LL | |\n-LL | |     fn get(&self, t: T) -> Self::A;\n-LL | | }\n-   | |_- trait `TheTrait` defined here\n-...\n-LL |       tuple_four::<Tuple>();\n-   |       ^^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n+LL |     tuple_four::<Tuple>();\n+   |     ^^^^^^^^^^^^^^^^^^^ implementation of `TheTrait` is not general enough\n    |\n    = note: `Tuple` must implement `TheTrait<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `Tuple` actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n+   = note: ...but it actually implements `TheTrait<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "8aaeaecf3e1da11ddb7c81d4e5e20b252974d8a0", "filename": "src/test/ui/async-await/issues/issue-78600.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+\n+struct S<'a>(&'a i32);\n+\n+impl<'a> S<'a> {\n+    async fn new(i: &'a i32) -> Result<Self, ()> {\n+        //~^ ERROR: `async fn`\n+        Ok(S(&22))\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "92b66147106e1eae7ecf4b851d1f1975cf9af1c6", "filename": "src/test/ui/async-await/issues/issue-78600.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -0,0 +1,11 @@\n+error[E0760]: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+  --> $DIR/issue-78600.rs:6:33\n+   |\n+LL |     async fn new(i: &'a i32) -> Result<Self, ()> {\n+   |                                 ^^^^^^^----^^^^^\n+   |                                        |\n+   |                                        help: consider spelling out the type instead: `S<'a>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0760`."}, {"sha": "27c8fb1363f17a03144b1707cece124c012c1769", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -26,7 +26,8 @@ fn big_box() {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n         let p = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n         println!(\"{} {:?}\", t.1, p);\n         //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow"}, {"sha": "944e4c40a78ef6707a21e7b35bf1f11544235829", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -28,13 +28,18 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Capturing t[(0, 0)] -> ByValue\n   --> $DIR/by_value.rs:28:17\n    |\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:31:29\n+  --> $DIR/by_value.rs:32:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^\n@@ -57,7 +62,7 @@ note: Min Capture t[(0, 0)] -> ByValue\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:31:29\n+  --> $DIR/by_value.rs:32:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^"}, {"sha": "cd7c25620a7c43bccf5020fa0e36270e6d2352b6", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-array-diagnostics.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -0,0 +1,16 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Test that array access is not stored as part of closure kind origin\n+\n+fn expect_fn<F: Fn()>(_f: F) {}\n+\n+fn main() {\n+    let s = [format!(\"s\"), format!(\"s\")];\n+    let c = || { //~ ERROR expected a closure that implements the `Fn`\n+        let [_, _s] = s;\n+    };\n+    expect_fn(c);\n+}"}, {"sha": "bd9428771f4c5b5816d91791e97ced2499b8c346", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-array-diagnostics.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-array-diagnostics.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`\n+  --> $DIR/closure-origin-array-diagnostics.rs:12:13\n+   |\n+LL |     let c = || {\n+   |             ^^ this closure implements `FnOnce`, not `Fn`\n+LL |         let [_, _s] = s;\n+   |                       - closure is `FnOnce` because it moves the variable `s` out of its environment\n+LL |     };\n+LL |     expect_fn(c);\n+   |     --------- the requirement to implement `Fn` derives from here\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0525`."}, {"sha": "1c574da5f48bc24bc182d975425e72eaf1226466", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -6,7 +6,25 @@\n //~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n #![feature(rustc_attrs)]\n \n-// Test we truncate derefs properly\n+fn simple_move_closure() {\n+    struct S(String);\n+    struct T(S);\n+\n+    let t = T(S(\"s\".into()));\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        t.0.0 = \"new S\".into();\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+    };\n+    c();\n+}\n+\n+// Test move closure use reborrows when using references\n fn simple_ref() {\n     let mut s = 10;\n     let ref_s = &mut s;\n@@ -18,14 +36,14 @@ fn simple_ref() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         *ref_s += 10;\n-        //~^ NOTE: Capturing ref_s[Deref] -> ByValue\n-        //~| NOTE: Min Capture ref_s[] -> ByValue\n+        //~^ NOTE: Capturing ref_s[Deref] -> UniqueImmBorrow\n+        //~| NOTE: Min Capture ref_s[Deref] -> UniqueImmBorrow\n     };\n     c();\n }\n \n-// Test we truncate derefs properly\n-fn struct_contains_ref_to_another_struct() {\n+// Test move closure use reborrows when using references\n+fn struct_contains_ref_to_another_struct_1() {\n     struct S(String);\n     struct T<'a>(&'a mut S);\n \n@@ -39,34 +57,85 @@ fn struct_contains_ref_to_another_struct() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         t.0.0 = \"new s\".into();\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n-        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n     };\n \n     c();\n }\n \n-// Test that we don't reduce precision when there is nothing deref.\n-fn no_ref() {\n+// Test that we can use reborrows to read data of Copy types\n+// i.e. without truncating derefs\n+fn struct_contains_ref_to_another_struct_2() {\n+    struct S(i32);\n+    struct T<'a>(&'a S);\n+\n+    let s = S(0);\n+    let t = T(&s);\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let _t = t.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+// Test that we can use truncate to move out of !Copy types\n+fn struct_contains_ref_to_another_struct_3() {\n     struct S(String);\n-    struct T(S);\n+    struct T<'a>(&'a S);\n+\n+    let s = S(\"s\".into());\n+    let t = T(&s);\n \n-    let t = T(S(\"s\".into()));\n     let mut c = #[rustc_capture_analysis]\n     //~^ ERROR: attributes on expressions are experimental\n     //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     move || {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n-        t.0.0 = \"new S\".into();\n-        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n-        //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+        let _t = t.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n     };\n+\n+    c();\n+}\n+\n+// Test that derefs of box are truncated in move closures\n+fn truncate_box_derefs() {\n+    struct S(i32);\n+\n+    let b = Box::new(S(10));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let _t = b.0;\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Capturing b[] -> ByValue\n+        //~| NOTE: Min Capture b[] -> ByValue\n+    };\n+\n     c();\n }\n \n fn main() {\n+    simple_move_closure();\n     simple_ref();\n-    struct_contains_ref_to_another_struct();\n-    no_ref();\n+    struct_contains_ref_to_another_struct_1();\n+    struct_contains_ref_to_another_struct_2();\n+    struct_contains_ref_to_another_struct_3();\n+    truncate_box_derefs();\n }"}, {"sha": "b91ef4dd85c487118d3ac1509fb9c2fc0c11054d", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 171, "deletions": 26, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -8,7 +8,7 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:35:17\n+  --> $DIR/move_closure.rs:32:17\n    |\n LL |     let mut c = #[rustc_capture_analysis]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,14 +17,41 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:55:17\n+  --> $DIR/move_closure.rs:53:17\n    |\n LL |     let mut c = #[rustc_capture_analysis]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:76:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:98:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:119:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/move_closure.rs:3:12\n    |\n@@ -40,20 +67,56 @@ error: First Pass analysis includes:\n LL | /     move || {\n LL | |\n LL | |\n-LL | |         *ref_s += 10;\n+LL | |         t.0.0 = \"new S\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:20:9\n+   |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:17:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new S\".into();\n LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing ref_s[Deref] -> ByValue\n+note: Min Capture t[(0, 0),(0, 0)] -> ByValue\n   --> $DIR/move_closure.rs:20:9\n    |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:35:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         *ref_s += 10;\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing ref_s[Deref] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:38:9\n+   |\n LL |         *ref_s += 10;\n    |         ^^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:17:5\n+  --> $DIR/move_closure.rs:35:5\n    |\n LL | /     move || {\n LL | |\n@@ -64,14 +127,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture ref_s[] -> ByValue\n-  --> $DIR/move_closure.rs:20:9\n+note: Min Capture ref_s[Deref] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:38:9\n    |\n LL |         *ref_s += 10;\n    |         ^^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:38:5\n+  --> $DIR/move_closure.rs:56:5\n    |\n LL | /     move || {\n LL | |\n@@ -82,14 +145,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:41:9\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:59:9\n    |\n LL |         t.0.0 = \"new s\".into();\n    |         ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:38:5\n+  --> $DIR/move_closure.rs:56:5\n    |\n LL | /     move || {\n LL | |\n@@ -100,48 +163,130 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:41:9\n+note: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:59:9\n    |\n LL |         t.0.0 = \"new s\".into();\n    |         ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:58:5\n+  --> $DIR/move_closure.rs:79:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n-LL | |         t.0.0 = \"new S\".into();\n+LL | |         let _t = t.0.0;\n LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:61:9\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:82:18\n    |\n-LL |         t.0.0 = \"new S\".into();\n-   |         ^^^^^\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:58:5\n+  --> $DIR/move_closure.rs:79:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n-LL | |         t.0.0 = \"new S\".into();\n+LL | |         let _t = t.0.0;\n LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0),(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:61:9\n+note: Min Capture t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:82:18\n    |\n-LL |         t.0.0 = \"new S\".into();\n-   |         ^^^^^\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:101:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:104:18\n+   |\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+note: Capturing t[(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:104:18\n+   |\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:101:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:104:18\n+   |\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:122:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = b.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing b[Deref,(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:125:18\n+   |\n+LL |         let _t = b.0;\n+   |                  ^^^\n+note: Capturing b[] -> ByValue\n+  --> $DIR/move_closure.rs:125:18\n+   |\n+LL |         let _t = b.0;\n+   |                  ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:122:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = b.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture b[] -> ByValue\n+  --> $DIR/move_closure.rs:125:18\n+   |\n+LL |         let _t = b.0;\n+   |                  ^^^\n \n-error: aborting due to 9 previous errors; 1 warning emitted\n+error: aborting due to 18 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "afaafbda018774feb36039447a98ec1feae56170", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -56,9 +56,50 @@ fn no_ref_nested() {\n     c();\n }\n \n+struct A<'a>(&'a mut String,  &'a mut String);\n+// Test that reborrowing works as expected for move closures\n+// by attempting a disjoint capture through a reference.\n+fn disjoint_via_ref() {\n+    let mut x = String::new();\n+    let mut y = String::new();\n+\n+    let mut a = A(&mut x, &mut y);\n+    let a = &mut a;\n+\n+    let mut c1 = move || {\n+        a.0.truncate(0);\n+    };\n+\n+    let mut c2 = move || {\n+        a.1.truncate(0);\n+    };\n+\n+    c1();\n+    c2();\n+}\n+\n+// Test that even if a path is moved into the closure, the closure is not FnOnce\n+// if the path is not moved by the closure call.\n+fn data_moved_but_not_fn_once() {\n+    let x = Box::new(10i32);\n+\n+    let c = move || {\n+        // *x has type i32 which is Copy. So even though the box `x` will be moved\n+        // into the closure, `x` is never moved when the closure is called, i.e. the\n+        // ownership stays with the closure and therefore we can call the function multiple times.\n+        let _x = *x;\n+    };\n+\n+    c();\n+    c();\n+}\n+\n fn main() {\n     simple_ref();\n     struct_contains_ref_to_another_struct();\n     no_ref();\n     no_ref_nested();\n+\n+    disjoint_via_ref();\n+    data_moved_but_not_fn_once();\n }"}, {"sha": "da3d3249f0e7ee157cef94630c21f310d70dfb1a", "filename": "src/test/ui/generator/auto-trait-regions.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fauto-trait-regions.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,33 +1,24 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:31:5\n    |\n-LL | auto trait Foo {}\n-   | ----------------- trait `Foo` defined here\n-...\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo` would have to be implemented for the type `&'0 OnlyFooIfStaticRef`, for any lifetime `'0`...\n-   = note: ...but `Foo` is actually implemented for the type `&'1 OnlyFooIfStaticRef`, for some specific lifetime `'1`\n+   = note: `&'0 OnlyFooIfStaticRef` must implement `Foo`, for any lifetime `'0`...\n+   = note: ...but `Foo` is actually implemented for the type `&'static OnlyFooIfStaticRef`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:31:5\n    |\n-LL | auto trait Foo {}\n-   | ----------------- trait `Foo` defined here\n-...\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n-   = note: `Foo` would have to be implemented for the type `&'0 OnlyFooIfStaticRef`, for any lifetime `'0`...\n-   = note: ...but `Foo` is actually implemented for the type `&'1 OnlyFooIfStaticRef`, for some specific lifetime `'1`\n+   = note: `&'0 OnlyFooIfStaticRef` must implement `Foo`, for any lifetime `'0`...\n+   = note: ...but `Foo` is actually implemented for the type `&'static OnlyFooIfStaticRef`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:50:5\n    |\n-LL | auto trait Foo {}\n-   | ----------------- trait `Foo` defined here\n-...\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n@@ -37,9 +28,6 @@ LL |     assert_foo(gen);\n error: implementation of `Foo` is not general enough\n   --> $DIR/auto-trait-regions.rs:50:5\n    |\n-LL | auto trait Foo {}\n-   | ----------------- trait `Foo` defined here\n-...\n LL |     assert_foo(gen);\n    |     ^^^^^^^^^^ implementation of `Foo` is not general enough\n    |"}, {"sha": "520938a633514b6c41bdf929605ab24a2f061843", "filename": "src/test/ui/hrtb/due-to-where-clause.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -3,9 +3,6 @@ error: implementation of `Foo` is not general enough\n    |\n LL |     test::<FooS>(&mut 42);\n    |     ^^^^^^^^^^^^ implementation of `Foo` is not general enough\n-...\n-LL | trait Foo<'a> {}\n-   | ---------------- trait `Foo` defined here\n    |\n    = note: `FooS<'_>` must implement `Foo<'0>`, for any lifetime `'0`...\n    = note: ...but `FooS<'_>` actually implements `Foo<'1>`, for some specific lifetime `'1`"}, {"sha": "f014eab8601fa4a728a6411304841a81553f5eeb", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,9 +1,6 @@\n error: implementation of `Deserialize` is not general enough\n   --> $DIR/hrtb-cache-issue-54302.rs:19:5\n    |\n-LL | trait Deserialize<'de> {}\n-   | ------------------------- trait `Deserialize` defined here\n-...\n LL |     assert_deserialize_owned::<&'static str>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Deserialize` is not general enough\n    |"}, {"sha": "b1d4c0bf375059018da73037ace6791a091c262a", "filename": "src/test/ui/hrtb/hrtb-conflate-regions.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-conflate-regions.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,16 +1,11 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-conflate-regions.rs:27:10\n    |\n-LL | / trait Foo<X> {\n-LL | |     fn foo(&self, x: X) { }\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |   fn b() { want_foo2::<SomeStruct>(); }\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL | fn b() { want_foo2::<SomeStruct>(); }\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `SomeStruct` must implement `Foo<(&'0 isize, &'1 isize)>`, for any two lifetimes `'0` and `'1`...\n-   = note: ...but `SomeStruct` actually implements `Foo<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n+   = note: ...but it actually implements `Foo<(&'2 isize, &'2 isize)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n "}, {"sha": "613f4dc4951ec3f16ced03fdcb9f1b0ed25e7e8e", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-contravariant.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-contravariant.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,14 +1,11 @@\n error: implementation of `Trait` is not general enough\n   --> $DIR/hrtb-exists-forall-trait-contravariant.rs:34:5\n    |\n-LL | trait Trait<T> {}\n-   | ----------------- trait `Trait` defined here\n-...\n LL |     foo::<()>();\n    |     ^^^^^^^^^ implementation of `Trait` is not general enough\n    |\n    = note: `()` must implement `Trait<for<'b> fn(&'b u32)>`\n-   = note: ...but `()` actually implements `Trait<fn(&'0 u32)>`, for some specific lifetime `'0`\n+   = note: ...but it actually implements `Trait<fn(&'0 u32)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n "}, {"sha": "b487ce3e0ffa1ce09b5f4dc8771a12e03c162217", "filename": "src/test/ui/hrtb/hrtb-exists-forall-trait-invariant.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-exists-forall-trait-invariant.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,14 +1,11 @@\n error: implementation of `Trait` is not general enough\n   --> $DIR/hrtb-exists-forall-trait-invariant.rs:28:5\n    |\n-LL | trait Trait<T> {}\n-   | ----------------- trait `Trait` defined here\n-...\n LL |     foo::<()>();\n    |     ^^^^^^^^^ implementation of `Trait` is not general enough\n    |\n    = note: `()` must implement `Trait<for<'b> fn(Cell<&'b u32>)>`\n-   = note: ...but `()` actually implements `Trait<fn(Cell<&'0 u32>)>`, for some specific lifetime `'0`\n+   = note: ...but it actually implements `Trait<fn(Cell<&'0 u32>)>`, for some specific lifetime `'0`\n \n error: aborting due to previous error\n "}, {"sha": "ffc83aab4af4d03dd35344ded3eba490c6b73323", "filename": "src/test/ui/hrtb/hrtb-just-for-static.stderr", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-just-for-static.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,27 +1,17 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:24:5\n    |\n-LL | / trait Foo<X> {\n-LL | |     fn foo(&self, x: X) { }\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |       want_hrtb::<StaticInt>()\n-   |       ^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL |     want_hrtb::<StaticInt>()\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `StaticInt` must implement `Foo<&'0 isize>`, for any lifetime `'0`...\n-   = note: ...but `StaticInt` actually implements `Foo<&'1 isize>`, for some specific lifetime `'1`\n+   = note: ...but it actually implements `Foo<&'static isize>`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/hrtb-just-for-static.rs:30:5\n    |\n-LL | / trait Foo<X> {\n-LL | |     fn foo(&self, x: X) { }\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |       want_hrtb::<&'a u32>()\n-   |       ^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL |     want_hrtb::<&'a u32>()\n+   |     ^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `Foo<&'0 isize>` would have to be implemented for the type `&'a u32`, for any lifetime `'0`...\n    = note: ...but `Foo<&'1 isize>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`"}, {"sha": "c3dd794957540ccfd50f1d5228f23b63d1e12014", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.nll.stderr", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.nll.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,11 +1,11 @@\n warning: function cannot return without recursing\n-  --> $DIR/hrtb-perfect-forwarding.rs:22:1\n+  --> $DIR/hrtb-perfect-forwarding.rs:16:1\n    |\n-LL | / fn no_hrtb<'b,T>(mut t: T)\n-LL | |     where T : Bar<&'b isize>\n+LL | / fn no_hrtb<'b, T>(mut t: T)\n+LL | | where\n+LL | |     T: Bar<&'b isize>,\n LL | | {\n-LL | |     // OK -- `T : Bar<&'b isize>`, and thus the impl above ensures that\n-LL | |     // `&mut T : Bar<&'b isize>`.\n+...  |\n LL | |     no_hrtb(&mut t);\n    | |     --------------- recursive call site\n LL | | }\n@@ -15,12 +15,12 @@ LL | | }\n    = help: a `loop` may express intention better if this is on purpose\n \n warning: function cannot return without recursing\n-  --> $DIR/hrtb-perfect-forwarding.rs:30:1\n+  --> $DIR/hrtb-perfect-forwarding.rs:25:1\n    |\n LL | / fn bar_hrtb<T>(mut t: T)\n-LL | |     where T : for<'b> Bar<&'b isize>\n+LL | | where\n+LL | |     T: for<'b> Bar<&'b isize>,\n LL | | {\n-LL | |     // OK -- `T : for<'b> Bar<&'b isize>`, and thus the impl above\n ...  |\n LL | |     bar_hrtb(&mut t);\n    | |     ---------------- recursive call site\n@@ -30,25 +30,26 @@ LL | | }\n    = help: a `loop` may express intention better if this is on purpose\n \n warning: function cannot return without recursing\n-  --> $DIR/hrtb-perfect-forwarding.rs:39:1\n+  --> $DIR/hrtb-perfect-forwarding.rs:35:1\n    |\n-LL | / fn foo_hrtb_bar_not<'b,T>(mut t: T)\n-LL | |     where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n+LL | / fn foo_hrtb_bar_not<'b, T>(mut t: T)\n+LL | | where\n+LL | |     T: for<'a> Foo<&'a isize> + Bar<&'b isize>,\n LL | | {\n-LL | |     // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n ...  |\n LL | |     foo_hrtb_bar_not(&mut t);\n    | |     ------------------------ recursive call site\n LL | |\n+LL | |\n LL | | }\n    | |_^ cannot return without recursing\n    |\n    = help: a `loop` may express intention better if this is on purpose\n \n error: lifetime may not live long enough\n-  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+  --> $DIR/hrtb-perfect-forwarding.rs:43:5\n    |\n-LL | fn foo_hrtb_bar_not<'b,T>(mut t: T)\n+LL | fn foo_hrtb_bar_not<'b, T>(mut t: T)\n    |                     -- lifetime `'b` defined here\n ...\n LL |     foo_hrtb_bar_not(&mut t);\n@@ -57,18 +58,19 @@ LL |     foo_hrtb_bar_not(&mut t);\n    = help: consider replacing `'b` with `'static`\n \n error: higher-ranked subtype error\n-  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+  --> $DIR/hrtb-perfect-forwarding.rs:43:5\n    |\n LL |     foo_hrtb_bar_not(&mut t);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: function cannot return without recursing\n-  --> $DIR/hrtb-perfect-forwarding.rs:50:1\n+  --> $DIR/hrtb-perfect-forwarding.rs:48:1\n    |\n LL | / fn foo_hrtb_bar_hrtb<T>(mut t: T)\n-LL | |     where T : for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>\n+LL | | where\n+LL | |     T: for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>,\n LL | | {\n-LL | |     // OK -- now we have `T : for<'b> Bar&'b isize>`.\n+LL | |     // OK -- now we have `T : for<'b> Bar<&'b isize>`.\n LL | |     foo_hrtb_bar_hrtb(&mut t);\n    | |     ------------------------- recursive call site\n LL | | }"}, {"sha": "441a788359e0345a0ce8f41d667fe24f5ff38b07", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -2,56 +2,55 @@\n // is being applied to `for<'a> Foo<&'a mut X>`. Issue #19730.\n \n trait Foo<X> {\n-    fn foo(&mut self, x: X) { }\n+    fn foo(&mut self, x: X) {}\n }\n \n trait Bar<X> {\n-    fn bar(&mut self, x: X) { }\n+    fn bar(&mut self, x: X) {}\n }\n \n-impl<'a,X,F> Foo<X> for &'a mut F\n-    where F : Foo<X> + Bar<X>\n-{\n-}\n+impl<'a, X, F> Foo<X> for &'a mut F where F: Foo<X> + Bar<X> {}\n \n-impl<'a,X,F> Bar<X> for &'a mut F\n-    where F : Bar<X>\n-{\n-}\n+impl<'a, X, F> Bar<X> for &'a mut F where F: Bar<X> {}\n \n-fn no_hrtb<'b,T>(mut t: T)\n-    where T : Bar<&'b isize>\n+fn no_hrtb<'b, T>(mut t: T)\n+where\n+    T: Bar<&'b isize>,\n {\n     // OK -- `T : Bar<&'b isize>`, and thus the impl above ensures that\n     // `&mut T : Bar<&'b isize>`.\n     no_hrtb(&mut t);\n }\n \n fn bar_hrtb<T>(mut t: T)\n-    where T : for<'b> Bar<&'b isize>\n+where\n+    T: for<'b> Bar<&'b isize>,\n {\n     // OK -- `T : for<'b> Bar<&'b isize>`, and thus the impl above\n     // ensures that `&mut T : for<'b> Bar<&'b isize>`.  This is an\n     // example of a \"perfect forwarding\" impl.\n     bar_hrtb(&mut t);\n }\n \n-fn foo_hrtb_bar_not<'b,T>(mut t: T)\n-    where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n+fn foo_hrtb_bar_not<'b, T>(mut t: T)\n+where\n+    T: for<'a> Foo<&'a isize> + Bar<&'b isize>,\n {\n     // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n     // be implemented. Thus to satisfy `&mut T : for<'a> Foo<&'a\n     // isize>`, we require `T : for<'a> Bar<&'a isize>`, but the where\n     // clause only specifies `T : Bar<&'b isize>`.\n-    foo_hrtb_bar_not(&mut t); //~ ERROR mismatched types\n-                              //~| ERROR mismatched types\n+    foo_hrtb_bar_not(&mut t);\n+    //~^ ERROR implementation of `Bar` is not general enough\n+    //~| ERROR implementation of `Bar` is not general enough\n }\n \n fn foo_hrtb_bar_hrtb<T>(mut t: T)\n-    where T : for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>\n+where\n+    T: for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>,\n {\n-    // OK -- now we have `T : for<'b> Bar&'b isize>`.\n+    // OK -- now we have `T : for<'b> Bar<&'b isize>`.\n     foo_hrtb_bar_hrtb(&mut t);\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "07ff9b96e44ff807d28eaa9571396338558acdda", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.stderr", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,41 +1,20 @@\n-error[E0308]: mismatched types\n-  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+error: implementation of `Bar` is not general enough\n+  --> $DIR/hrtb-perfect-forwarding.rs:43:5\n    |\n LL |     foo_hrtb_bar_not(&mut t);\n-   |     ^^^^^^^^^^^^^^^^ lifetime mismatch\n+   |     ^^^^^^^^^^^^^^^^ implementation of `Bar` is not general enough\n    |\n-   = note: expected type `Bar<&'a isize>`\n-              found type `Bar<&'b isize>`\n-note: the required lifetime does not necessarily outlive the lifetime `'b` as defined on the function body at 39:21\n-  --> $DIR/hrtb-perfect-forwarding.rs:39:21\n-   |\n-LL | fn foo_hrtb_bar_not<'b,T>(mut t: T)\n-   |                     ^^\n-note: the lifetime requirement is introduced here\n-  --> $DIR/hrtb-perfect-forwarding.rs:40:15\n-   |\n-LL |     where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n-   |               ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `T` must implement `Bar<&'0 isize>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `Bar<&'b isize>`\n \n-error[E0308]: mismatched types\n-  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+error: implementation of `Bar` is not general enough\n+  --> $DIR/hrtb-perfect-forwarding.rs:43:5\n    |\n LL |     foo_hrtb_bar_not(&mut t);\n-   |     ^^^^^^^^^^^^^^^^ lifetime mismatch\n-   |\n-   = note: expected type `Bar<&'a isize>`\n-              found type `Bar<&'b isize>`\n-note: the lifetime `'b` as defined on the function body at 39:21 doesn't meet the lifetime requirements\n-  --> $DIR/hrtb-perfect-forwarding.rs:39:21\n-   |\n-LL | fn foo_hrtb_bar_not<'b,T>(mut t: T)\n-   |                     ^^\n-note: the lifetime requirement is introduced here\n-  --> $DIR/hrtb-perfect-forwarding.rs:40:15\n+   |     ^^^^^^^^^^^^^^^^ implementation of `Bar` is not general enough\n    |\n-LL |     where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n-   |               ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `T` must implement `Bar<&'0 isize>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `Bar<&'b isize>`\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "f3d906cae4cc3c43c939b51befe8c4d9568045e0", "filename": "src/test/ui/hrtb/issue-46989.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,9 +1,6 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-46989.rs:38:5\n    |\n-LL | trait Foo {}\n-   | ------------ trait `Foo` defined here\n-...\n LL |     assert_foo::<fn(&i32)>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |"}, {"sha": "baa75f28d37f32c39cef43b2226a9a8b23f94837", "filename": "src/test/ui/issues/issue-54302-cases.stderr", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302-cases.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,55 +1,35 @@\n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:63:5\n    |\n-LL | / trait Foo<'x, T> {\n-LL | |     fn foo(self) -> &'x T;\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |       <u32 as RefFoo<u32>>::ref_foo(a)\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL |     <u32 as RefFoo<u32>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `Foo<'static, u32>` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n    = note: ...but `Foo<'_, u32>` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:69:5\n    |\n-LL | / trait Foo<'x, T> {\n-LL | |     fn foo(self) -> &'x T;\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |       <i32 as RefFoo<i32>>::ref_foo(a)\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL |     <i32 as RefFoo<i32>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `Foo<'static, i32>` would have to be implemented for the type `&'0 i32`, for any lifetime `'0`...\n    = note: ...but `Foo<'_, i32>` is actually implemented for the type `&'1 i32`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:75:5\n    |\n-LL | / trait Foo<'x, T> {\n-LL | |     fn foo(self) -> &'x T;\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |       <u64 as RefFoo<u64>>::ref_foo(a)\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL |     <u64 as RefFoo<u64>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `Foo<'static, u64>` would have to be implemented for the type `&'0 u64`, for any lifetime `'0`...\n    = note: ...but `Foo<'_, u64>` is actually implemented for the type `&'1 u64`, for some specific lifetime `'1`\n \n error: implementation of `Foo` is not general enough\n   --> $DIR/issue-54302-cases.rs:81:5\n    |\n-LL | / trait Foo<'x, T> {\n-LL | |     fn foo(self) -> &'x T;\n-LL | | }\n-   | |_- trait `Foo` defined here\n-...\n-LL |       <i64 as RefFoo<i64>>::ref_foo(a)\n-   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n+LL |     <i64 as RefFoo<i64>>::ref_foo(a)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Foo` is not general enough\n    |\n    = note: `Foo<'static, i64>` would have to be implemented for the type `&'0 i64`, for any lifetime `'0`...\n    = note: ...but `Foo<'_, i64>` is actually implemented for the type `&'1 i64`, for some specific lifetime `'1`"}, {"sha": "26c46571f9cb232d8155abcfc30a47d74d98a216", "filename": "src/test/ui/issues/issue-54302.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54302.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,9 +1,6 @@\n error: implementation of `Deserialize` is not general enough\n   --> $DIR/issue-54302.rs:13:5\n    |\n-LL | trait Deserialize<'de> {}\n-   | ------------------------- trait `Deserialize` defined here\n-...\n LL |     assert_deserialize_owned::<&'static str>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ implementation of `Deserialize` is not general enough\n    |"}, {"sha": "de327cd3cc23cc87a79129f2d39cf7465ea87fb1", "filename": "src/test/ui/issues/issue-55731.stderr", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-55731.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-55731.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55731.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,13 +1,8 @@\n error: implementation of `DistributedIteratorMulti` is not general enough\n   --> $DIR/issue-55731.rs:48:5\n    |\n-LL | / trait DistributedIteratorMulti<Source> {\n-LL | |     type Item;\n-LL | | }\n-   | |_- trait `DistributedIteratorMulti` defined here\n-...\n-LL |       multi(Map {\n-   |       ^^^^^ implementation of `DistributedIteratorMulti` is not general enough\n+LL |     multi(Map {\n+   |     ^^^^^ implementation of `DistributedIteratorMulti` is not general enough\n    |\n    = note: `DistributedIteratorMulti<&'0 ()>` would have to be implemented for the type `Cloned<&()>`, for any lifetime `'0`...\n    = note: ...but `DistributedIteratorMulti<&'1 ()>` is actually implemented for the type `Cloned<&'1 ()>`, for some specific lifetime `'1`"}, {"sha": "70d16cc9a1da66c97e16292faa5647d4b5bf5f98", "filename": "src/test/ui/issues/issue-57843.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-57843.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-57843.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57843.nll.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,5 +1,5 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-57843.rs:23:9\n+  --> $DIR/issue-57843.rs:25:9\n    |\n LL |     Foo(Box::new(|_| ()));\n    |         ^^^^^^^^^^^^^^^^"}, {"sha": "11629690ecc5e27ac51880a80e699b529ab2a68e", "filename": "src/test/ui/issues/issue-57843.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-57843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-57843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57843.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -11,7 +11,9 @@ trait ClonableFn<T> {\n }\n \n impl<T, F: 'static> ClonableFn<T> for F\n-where F: Fn(T) + Clone {\n+where\n+    F: Fn(T) + Clone,\n+{\n     fn clone(&self) -> Box<dyn Fn(T)> {\n         Box::new(self.clone())\n     }\n@@ -20,5 +22,5 @@ where F: Fn(T) + Clone {\n struct Foo(Box<dyn for<'a> ClonableFn<&'a bool>>);\n \n fn main() {\n-    Foo(Box::new(|_| ())); //~ ERROR mismatched types\n+    Foo(Box::new(|_| ())); //~ ERROR implementation of `FnOnce` is not general enough\n }"}, {"sha": "2ab49ec61cf597ef187b72d897312e9ffd112962", "filename": "src/test/ui/issues/issue-57843.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-57843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fissues%2Fissue-57843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57843.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,17 +1,11 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-57843.rs:23:9\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-57843.rs:25:9\n    |\n LL |     Foo(Box::new(|_| ()));\n-   |         ^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |         ^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&'a bool,)>`\n-              found type `FnOnce<(&bool,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57843.rs:23:18\n-   |\n-LL |     Foo(Box::new(|_| ()));\n-   |                  ^^^^^^\n+   = note: closure with signature `fn(&'2 bool)` must implement `FnOnce<(&'1 bool,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 bool,)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "2ee69ee2234eefbe9bc9b3bec3b4834061dc424c", "filename": "src/test/ui/lifetimes/issue-79187.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -2,5 +2,5 @@ fn thing(x: impl FnOnce(&u32)) {}\n \n fn main() {\n     let f = |_| ();\n-    thing(f); //~ERROR mismatched types\n+    thing(f); //~ERROR implementation of `FnOnce` is not general enough\n }"}, {"sha": "3c0439fb660e501c7bde75e61c948e1c41f1255d", "filename": "src/test/ui/lifetimes/issue-79187.stderr", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-79187.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,22 +1,11 @@\n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-79187.rs:5:5\n    |\n LL |     thing(f);\n-   |     ^^^^^ lifetime mismatch\n+   |     ^^^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&u32,)>`\n-              found type `FnOnce<(&u32,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-79187.rs:4:13\n-   |\n-LL |     let f = |_| ();\n-   |             ^^^^^^\n-note: the lifetime requirement is introduced here\n-  --> $DIR/issue-79187.rs:1:18\n-   |\n-LL | fn thing(x: impl FnOnce(&u32)) {}\n-   |                  ^^^^^^^^^^^^\n+   = note: closure with signature `fn(&'2 u32)` must implement `FnOnce<(&'1 u32,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 u32,)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "2d485d14a8d6b8fd963213f100da8727257c96a2", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -8,8 +8,8 @@ fn main() {\n fn baz<F: Fn(*mut &u32)>(_: F) {}\n fn _test<'a>(f: fn(*mut &'a u32)) {\n     baz(f);\n-    //~^ ERROR mismatched types\n-    //~| ERROR mismatched types\n+    //~^ ERROR implementation of `FnOnce` is not general enough\n+    //~| ERROR implementation of `FnOnce` is not general enough\n     //~| ERROR mismatched types\n     //~| ERROR mismatched types\n }"}, {"sha": "521de3742b03f510782842b8028ff6bdba5c5dcf", "filename": "src/test/ui/mismatched_types/closure-arg-type-mismatch.stderr", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-type-mismatch.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -41,24 +41,14 @@ note: the lifetime requirement is introduced here\n LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n    |           ^^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/closure-arg-type-mismatch.rs:10:5\n    |\n LL |     baz(f);\n-   |     ^^^ lifetime mismatch\n-   |\n-   = note: expected type `FnOnce<(*mut &u32,)>`\n-              found type `FnOnce<(*mut &'a u32,)>`\n-note: the required lifetime does not necessarily outlive the lifetime `'a` as defined on the function body at 9:10\n-  --> $DIR/closure-arg-type-mismatch.rs:9:10\n-   |\n-LL | fn _test<'a>(f: fn(*mut &'a u32)) {\n-   |          ^^\n-note: the lifetime requirement is introduced here\n-  --> $DIR/closure-arg-type-mismatch.rs:8:11\n+   |     ^^^ implementation of `FnOnce` is not general enough\n    |\n-LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n-   |           ^^^^^^^^^^^^^\n+   = note: `fn(*mut &'a u32)` must implement `FnOnce<(*mut &'0 u32,)>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `FnOnce<(*mut &'a u32,)>`\n \n error[E0308]: mismatched types\n   --> $DIR/closure-arg-type-mismatch.rs:10:5\n@@ -79,24 +69,14 @@ note: the lifetime requirement is introduced here\n LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n    |           ^^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/closure-arg-type-mismatch.rs:10:5\n    |\n LL |     baz(f);\n-   |     ^^^ lifetime mismatch\n-   |\n-   = note: expected type `FnOnce<(*mut &u32,)>`\n-              found type `FnOnce<(*mut &'a u32,)>`\n-note: the lifetime `'a` as defined on the function body at 9:10 doesn't meet the lifetime requirements\n-  --> $DIR/closure-arg-type-mismatch.rs:9:10\n-   |\n-LL | fn _test<'a>(f: fn(*mut &'a u32)) {\n-   |          ^^\n-note: the lifetime requirement is introduced here\n-  --> $DIR/closure-arg-type-mismatch.rs:8:11\n+   |     ^^^ implementation of `FnOnce` is not general enough\n    |\n-LL | fn baz<F: Fn(*mut &u32)>(_: F) {}\n-   |           ^^^^^^^^^^^^^\n+   = note: `fn(*mut &'a u32)` must implement `FnOnce<(*mut &'0 u32,)>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `FnOnce<(*mut &'a u32,)>`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "c01d17c0b3d7e10c24e0c7d44f167123d0b54038", "filename": "src/test/ui/or-patterns/feature-gate-or_patterns.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffeature-gate-or_patterns.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -8,10 +8,10 @@ LL |         Some(0 | 1 | 2) => {}\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:28:11\n+  --> $DIR/feature-gate-or_patterns.rs:28:9\n    |\n LL |     let | A | B;\n-   |           ^^^^^\n+   |         ^^^^^^^\n    |\n    = note: see issue #54883 <https://github.com/rust-lang/rust/issues/54883> for more information\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n@@ -26,10 +26,10 @@ LL |     let A | B;\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable\n \n error[E0658]: or-patterns syntax is experimental\n-  --> $DIR/feature-gate-or_patterns.rs:30:11\n+  --> $DIR/feature-gate-or_patterns.rs:30:9\n    |\n LL |     for | A | B in 0 {}\n-   |           ^^^^^\n+   |         ^^^^^^^\n    |\n    = note: see issue #54883 <https://github.com/rust-lang/rust/issues/54883> for more information\n    = help: add `#![feature(or_patterns)]` to the crate attributes to enable"}, {"sha": "bbc75d2b411eb2ab6c244446a0e9dc8247a9a9c1", "filename": "src/test/ui/or-patterns/fn-param-wrap-parens.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.fixed?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -11,4 +11,4 @@ enum E { A, B }\n use E::*;\n \n #[cfg(FALSE)]\n-fn fun1((A | B): E) {} //~ ERROR an or-pattern parameter must be wrapped in parenthesis\n+fn fun1((A | B): E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses"}, {"sha": "65b93dcbf7467e4a6dbaf04baad13218aeae0e58", "filename": "src/test/ui/or-patterns/fn-param-wrap-parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -11,4 +11,4 @@ enum E { A, B }\n use E::*;\n \n #[cfg(FALSE)]\n-fn fun1(A | B: E) {} //~ ERROR an or-pattern parameter must be wrapped in parenthesis\n+fn fun1(A | B: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses"}, {"sha": "0e6424a430043522ed5a3d320a157911a4dbe900", "filename": "src/test/ui/or-patterns/fn-param-wrap-parens.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Ffn-param-wrap-parens.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,8 +1,8 @@\n-error: an or-pattern parameter must be wrapped in parenthesis\n+error: an or-pattern parameter must be wrapped in parentheses\n   --> $DIR/fn-param-wrap-parens.rs:14:9\n    |\n LL | fn fun1(A | B: E) {}\n-   |         ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n+   |         ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error: aborting due to previous error\n "}, {"sha": "4d06101044f6c1f0ceeb0c84e5818dfdd275e4d1", "filename": "src/test/ui/or-patterns/multiple-pattern-typo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -4,41 +4,41 @@ fn main() {\n     let x = 3;\n \n     match x {\n-        1 | 2 || 3 => (), //~ ERROR unexpected token `||` after pattern\n+        1 | 2 || 3 => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n \n     match x {\n-        (1 | 2 || 3) => (), //~ ERROR unexpected token `||` after pattern\n+        (1 | 2 || 3) => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n \n     match (x,) {\n-        (1 | 2 || 3,) => (), //~ ERROR unexpected token `||` after pattern\n+        (1 | 2 || 3,) => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n \n     struct TS(u8);\n \n     match TS(x) {\n-        TS(1 | 2 || 3) => (), //~ ERROR unexpected token `||` after pattern\n+        TS(1 | 2 || 3) => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n \n     struct NS { f: u8 }\n \n     match (NS { f: x }) {\n-        NS { f: 1 | 2 || 3 } => (), //~ ERROR unexpected token `||` after pattern\n+        NS { f: 1 | 2 || 3 } => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n \n     match [x] {\n-        [1 | 2 || 3] => (), //~ ERROR unexpected token `||` after pattern\n+        [1 | 2 || 3] => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n \n     match x {\n-        || 1 | 2 | 3 => (), //~ ERROR unexpected token `||` after pattern\n+        || 1 | 2 | 3 => (), //~ ERROR unexpected token `||` in pattern\n         _ => (),\n     }\n }"}, {"sha": "b0a82b3673b83f3f329e513518d209d95be6c10d", "filename": "src/test/ui/or-patterns/multiple-pattern-typo.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmultiple-pattern-typo.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,52 +1,52 @@\n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:7:15\n    |\n LL |         1 | 2 || 3 => (),\n    |         -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |         |\n    |         while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:12:16\n    |\n LL |         (1 | 2 || 3) => (),\n    |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |          |\n    |          while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:17:16\n    |\n LL |         (1 | 2 || 3,) => (),\n    |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |          |\n    |          while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:24:18\n    |\n LL |         TS(1 | 2 || 3) => (),\n    |            -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |            |\n    |            while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:31:23\n    |\n LL |         NS { f: 1 | 2 || 3 } => (),\n    |                 -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |                 |\n    |                 while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:36:16\n    |\n LL |         [1 | 2 || 3] => (),\n    |          -     ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n    |          |\n    |          while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/multiple-pattern-typo.rs:41:9\n    |\n LL |         || 1 | 2 | 3 => (),"}, {"sha": "cbc24eb26fa475a4545f92b1fd7fc752162df9de", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -14,29 +14,8 @@ fn no_top_level_or_patterns() {\n     //           -------- This looks like an or-pattern but is in fact `|A| (B: E | ())`.\n \n     // ...and for now neither do we allow or-patterns at the top level of functions.\n-    fn fun1(A | B: E) {} //~ ERROR an or-pattern parameter must be wrapped in parenthesis\n+    fn fun1(A | B: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n \n     fn fun2(| A | B: E) {}\n-    //~^ ERROR a leading `|` is not allowed in a parameter pattern\n-    //~| ERROR an or-pattern parameter must be wrapped in parenthesis\n-}\n-\n-// We also do not allow a leading `|` when not in a top level position:\n-\n-fn no_leading_inner() {\n-    struct TS(E);\n-    struct NS { f: E }\n-\n-    let ( | A | B) = E::A; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let ( | A | B,) = (E::B,); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let [ | A | B ] = [E::A]; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let TS( | A | B ); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let NS { f: | A | B }; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-\n-    let ( || A | B) = E::A; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let [ || A | B ] = [E::A]; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let TS( || A | B ); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let NS { f: || A | B }; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-\n-    let recovery_witness: String = 0; //~ ERROR mismatched types\n+    //~^ ERROR an or-pattern parameter must be wrapped in parentheses\n }"}, {"sha": "db4d827757b036138203b402398f35ab9ba3621d", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-fail.stderr", "status": "modified", "additions": 6, "deletions": 85, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-fail.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,82 +1,14 @@\n-error: an or-pattern parameter must be wrapped in parenthesis\n+error: an or-pattern parameter must be wrapped in parentheses\n   --> $DIR/or-patterns-syntactic-fail.rs:17:13\n    |\n LL |     fn fun1(A | B: E) {}\n-   |             ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n+   |             ^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n-error: a leading `|` is not allowed in a parameter pattern\n+error: an or-pattern parameter must be wrapped in parentheses\n   --> $DIR/or-patterns-syntactic-fail.rs:19:13\n    |\n LL |     fn fun2(| A | B: E) {}\n-   |             ^ help: remove the `|`\n-\n-error: an or-pattern parameter must be wrapped in parenthesis\n-  --> $DIR/or-patterns-syntactic-fail.rs:19:15\n-   |\n-LL |     fn fun2(| A | B: E) {}\n-   |               ^^^^^ help: wrap the pattern in parenthesis: `(A | B)`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:30:11\n-   |\n-LL |     let ( | A | B) = E::A;\n-   |           ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:31:11\n-   |\n-LL |     let ( | A | B,) = (E::B,);\n-   |           ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:32:11\n-   |\n-LL |     let [ | A | B ] = [E::A];\n-   |           ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:33:13\n-   |\n-LL |     let TS( | A | B );\n-   |             ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:34:17\n-   |\n-LL |     let NS { f: | A | B };\n-   |                 ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:36:11\n-   |\n-LL |     let ( || A | B) = E::A;\n-   |           ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:37:11\n-   |\n-LL |     let [ || A | B ] = [E::A];\n-   |           ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:38:13\n-   |\n-LL |     let TS( || A | B );\n-   |             ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/or-patterns-syntactic-fail.rs:39:17\n-   |\n-LL |     let NS { f: || A | B };\n-   |                 ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n+   |             ^^^^^^^ help: wrap the pattern in parentheses: `(A | B)`\n \n error[E0369]: no implementation for `E | ()`\n   --> $DIR/or-patterns-syntactic-fail.rs:13:22\n@@ -88,17 +20,6 @@ LL |     let _ = |A | B: E| ();\n    |\n    = note: an implementation of `std::ops::BitOr` might be missing for `E`\n \n-error[E0308]: mismatched types\n-  --> $DIR/or-patterns-syntactic-fail.rs:41:36\n-   |\n-LL |     let recovery_witness: String = 0;\n-   |                           ------   ^\n-   |                           |        |\n-   |                           |        expected struct `String`, found integer\n-   |                           |        help: try using a conversion method: `0.to_string()`\n-   |                           expected due to this\n-\n-error: aborting due to 14 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0308, E0369.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "c8fac4faa2a660b525712e112fa048b9c9a8d563", "filename": "src/test/ui/or-patterns/remove-leading-vert.fixed", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.fixed?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -9,17 +9,17 @@ fn main() {}\n \n #[cfg(FALSE)]\n fn leading() {\n-    fn fun1(  A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n-    fn fun2(  A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n-    let (  A): E; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let (  A): (E); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let (  A,): (E,); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let [  A ]: [E; 1]; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let [  A ]: [E; 1]; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let TS(  A ): TS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let TS(  A ): TS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let NS { f:  A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let NS { f:  A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n+    fn fun1( A: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+    fn fun2(  A: E) {} //~ ERROR unexpected `||` before function parameter\n+    let ( | A): E;\n+    let ( | A): (E); //~ ERROR unexpected token `||` in pattern\n+    let ( | A,): (E,);\n+    let [ | A ]: [E; 1];\n+    let [ | A ]: [E; 1]; //~ ERROR unexpected token `||` in pattern\n+    let TS( | A ): TS;\n+    let TS( | A ): TS; //~ ERROR unexpected token `||` in pattern\n+    let NS { f: | A }: NS;\n+    let NS { f: | A }: NS; //~ ERROR unexpected token `||` in pattern\n }\n \n #[cfg(FALSE)]\n@@ -29,12 +29,12 @@ fn trailing() {\n     let ( A | B  ): E; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let [ A | B  ]: [E; 1]; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let S { f: B  }; //~ ERROR a trailing `|` is not allowed in an or-pattern\n-    let ( A | B  ): E; //~ ERROR unexpected token `||` after pattern\n+    let ( A | B  ): E; //~ ERROR unexpected token `||` in pattern\n     //~^ ERROR a trailing `|` is not allowed in an or-pattern\n     match A {\n         A  => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n         A  => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n-        A | B  => {} //~ ERROR unexpected token `||` after pattern\n+        A | B  => {} //~ ERROR unexpected token `||` in pattern\n         //~^ ERROR a trailing `|` is not allowed in an or-pattern\n         | A | B  => {}\n         //~^ ERROR a trailing `|` is not allowed in an or-pattern"}, {"sha": "2cf6b27ab1aacd75ec75dca24d6dc81cae21ed96", "filename": "src/test/ui/or-patterns/remove-leading-vert.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -9,17 +9,17 @@ fn main() {}\n \n #[cfg(FALSE)]\n fn leading() {\n-    fn fun1( | A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n-    fn fun2( || A: E) {} //~ ERROR a leading `|` is not allowed in a parameter pattern\n-    let ( | A): E; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let ( || A): (E); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let ( | A,): (E,); //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let [ | A ]: [E; 1]; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let [ || A ]: [E; 1]; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let TS( | A ): TS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let TS( || A ): TS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let NS { f: | A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n-    let NS { f: || A }: NS; //~ ERROR a leading `|` is only allowed in a top-level pattern\n+    fn fun1( | A: E) {} //~ ERROR an or-pattern parameter must be wrapped in parentheses\n+    fn fun2( || A: E) {} //~ ERROR unexpected `||` before function parameter\n+    let ( | A): E;\n+    let ( || A): (E); //~ ERROR unexpected token `||` in pattern\n+    let ( | A,): (E,);\n+    let [ | A ]: [E; 1];\n+    let [ || A ]: [E; 1]; //~ ERROR unexpected token `||` in pattern\n+    let TS( | A ): TS;\n+    let TS( || A ): TS; //~ ERROR unexpected token `||` in pattern\n+    let NS { f: | A }: NS;\n+    let NS { f: || A }: NS; //~ ERROR unexpected token `||` in pattern\n }\n \n #[cfg(FALSE)]\n@@ -29,12 +29,12 @@ fn trailing() {\n     let ( A | B | ): E; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let [ A | B | ]: [E; 1]; //~ ERROR a trailing `|` is not allowed in an or-pattern\n     let S { f: B | }; //~ ERROR a trailing `|` is not allowed in an or-pattern\n-    let ( A || B | ): E; //~ ERROR unexpected token `||` after pattern\n+    let ( A || B | ): E; //~ ERROR unexpected token `||` in pattern\n     //~^ ERROR a trailing `|` is not allowed in an or-pattern\n     match A {\n         A | => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n         A || => {} //~ ERROR a trailing `|` is not allowed in an or-pattern\n-        A || B | => {} //~ ERROR unexpected token `||` after pattern\n+        A || B | => {} //~ ERROR unexpected token `||` in pattern\n         //~^ ERROR a trailing `|` is not allowed in an or-pattern\n         | A | B | => {}\n         //~^ ERROR a trailing `|` is not allowed in an or-pattern"}, {"sha": "5c9efd44a187f6513bf3795a405f17e96b90045f", "filename": "src/test/ui/or-patterns/remove-leading-vert.stderr", "status": "modified", "additions": 17, "deletions": 55, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fremove-leading-vert.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,78 +1,40 @@\n-error: a leading `|` is not allowed in a parameter pattern\n+error: an or-pattern parameter must be wrapped in parentheses\n   --> $DIR/remove-leading-vert.rs:12:14\n    |\n LL |     fn fun1( | A: E) {}\n-   |              ^ help: remove the `|`\n+   |              ^^^ help: remove the leading `|`: `A`\n \n-error: a leading `|` is not allowed in a parameter pattern\n+error: unexpected `||` before function parameter\n   --> $DIR/remove-leading-vert.rs:13:14\n    |\n LL |     fn fun2( || A: E) {}\n    |              ^^ help: remove the `||`\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/remove-leading-vert.rs:14:11\n-   |\n-LL |     let ( | A): E;\n-   |           ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/remove-leading-vert.rs:15:11\n    |\n LL |     let ( || A): (E);\n-   |           ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/remove-leading-vert.rs:16:11\n-   |\n-LL |     let ( | A,): (E,);\n-   |           ^ help: remove the `|`\n+   |           ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n \n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/remove-leading-vert.rs:17:11\n-   |\n-LL |     let [ | A ]: [E; 1];\n-   |           ^ help: remove the `|`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/remove-leading-vert.rs:18:11\n    |\n LL |     let [ || A ]: [E; 1];\n-   |           ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/remove-leading-vert.rs:19:13\n-   |\n-LL |     let TS( | A ): TS;\n-   |             ^ help: remove the `|`\n+   |           ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n \n-error: a leading `|` is only allowed in a top-level pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/remove-leading-vert.rs:20:13\n    |\n LL |     let TS( || A ): TS;\n-   |             ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n-\n-error: a leading `|` is only allowed in a top-level pattern\n-  --> $DIR/remove-leading-vert.rs:21:17\n-   |\n-LL |     let NS { f: | A }: NS;\n-   |                 ^ help: remove the `|`\n+   |             ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n \n-error: a leading `|` is only allowed in a top-level pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/remove-leading-vert.rs:22:17\n    |\n LL |     let NS { f: || A }: NS;\n-   |                 ^^ help: remove the `||`\n-   |\n-   = note: alternatives in or-patterns are separated with `|`, not `||`\n+   |                 ^^ help: use a single `|` to separate multiple alternative patterns: `|`\n \n error: a trailing `|` is not allowed in an or-pattern\n   --> $DIR/remove-leading-vert.rs:27:13\n@@ -114,7 +76,7 @@ LL |     let S { f: B | };\n    |                |\n    |                while parsing this or-pattern starting here\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/remove-leading-vert.rs:32:13\n    |\n LL |     let ( A || B | ): E;\n@@ -148,7 +110,7 @@ LL |         A || => {}\n    |\n    = note: alternatives in or-patterns are separated with `|`, not `||`\n \n-error: unexpected token `||` after pattern\n+error: unexpected token `||` in pattern\n   --> $DIR/remove-leading-vert.rs:37:11\n    |\n LL |         A || B | => {}\n@@ -168,9 +130,9 @@ error: a trailing `|` is not allowed in an or-pattern\n   --> $DIR/remove-leading-vert.rs:39:17\n    |\n LL |         | A | B | => {}\n-   |           -     ^ help: remove the `|`\n-   |           |\n-   |           while parsing this or-pattern starting here\n+   |         -       ^ help: remove the `|`\n+   |         |\n+   |         while parsing this or-pattern starting here\n \n error: a trailing `|` is not allowed in an or-pattern\n   --> $DIR/remove-leading-vert.rs:43:11\n@@ -196,5 +158,5 @@ LL |     let a | ;\n    |         |\n    |         while parsing this or-pattern starting here\n \n-error: aborting due to 26 previous errors\n+error: aborting due to 21 previous errors\n "}, {"sha": "9ff4813d11286e860c0daf2a9f35dcd2c6c78789", "filename": "src/test/ui/rfc1623.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -22,7 +22,7 @@ static SOME_STRUCT: &SomeStruct = &SomeStruct {\n     foo: &Foo { bools: &[false, true] },\n     bar: &Bar { bools: &[true, true] },\n     f: &id,\n-    //~^ ERROR mismatched types\n+    //~^ ERROR implementation of `FnOnce` is not general enough\n };\n \n // very simple test for a 'static static with default lifetime"}, {"sha": "e95e68c8e6d26c92669d517b9e78f9d6d95ae2eb", "filename": "src/test/ui/rfc1623.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Frfc1623.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Frfc1623.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1623.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,12 +1,11 @@\n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/rfc1623.rs:24:8\n    |\n LL |     f: &id,\n-   |        ^^^ one type is more general than the other\n+   |        ^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&'a Foo<'b>,)>`\n-              found type `FnOnce<(&Foo<'_>,)>`\n+   = note: `fn(&'2 Foo<'_>) -> &'2 Foo<'_> {id::<&'2 Foo<'_>>}` must implement `FnOnce<(&'1 Foo<'b>,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 Foo<'_>,)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "6ac66fdcb65ad5e6b28ca7855ec694bbed3950b1", "filename": "src/test/ui/span/issue-81800.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fspan%2Fissue-81800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fspan%2Fissue-81800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-81800.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -0,0 +1,2 @@\n+fn x\u02c2- //~ ERROR: unknown start of token\n+       //~^ ERROR: expected one of `#`, `>`, `const`, identifier, or lifetime, found `-`"}, {"sha": "d37f13a6683b05d8c3afd812ff8e38c9eca10a4a", "filename": "src/test/ui/span/issue-81800.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fspan%2Fissue-81800.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fspan%2Fissue-81800.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-81800.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -0,0 +1,19 @@\n+error: unknown start of token: \\u{2c2}\n+  --> $DIR/issue-81800.rs:1:5\n+   |\n+LL | fn x\u02c2-\n+   |     ^\n+   |\n+help: Unicode character '\u02c2' (Modifier Letter Left Arrowhead) looks like '<' (Less-Than Sign), but it is not\n+   |\n+LL | fn x<-\n+   |     ^\n+\n+error: expected one of `#`, `>`, `const`, identifier, or lifetime, found `-`\n+  --> $DIR/issue-81800.rs:1:6\n+   |\n+LL | fn x\u02c2-\n+   |      ^ expected one of `#`, `>`, `const`, identifier, or lifetime\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "998e178966a22a30a31f43f8dc54f056043b9942", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.nll.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.nll.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -24,19 +24,14 @@ note: this closure does not fulfill the lifetime requirements\n LL |         |x| x\n    |         ^^^^^\n \n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&X,)>`\n-              found type `FnOnce<(&'static X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:25:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^\n+   = note: closure with signature `fn(&'static X) -> &'static X` must implement `FnOnce<(&'0 X,)>`, for any lifetime `'0`...\n+   = note: ...but it actually implements `FnOnce<(&'static X,)>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "561528c2abbd5fe2691f63c778ce06d846463abd", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -15,9 +15,9 @@ struct X;\n \n impl Foo for X {\n     type Bar = impl Baz<Self, Self>;\n-    //~^ ERROR mismatched types\n-    //~| ERROR mismatched types\n-    //~| ERROR mismatched types\n+    //~^ ERROR implementation of `FnOnce` is not general enough\n+    //~| ERROR implementation of `FnOnce` is not general enough\n+    //~| ERROR implementation of `FnOnce` is not general enough\n     //~| ERROR mismatched types\n     //~| ERROR mismatched types\n "}, {"sha": "91c9d459ad8ce5ccdcb27d44bdb93cfe32f3f12c", "filename": "src/test/ui/type-alias-impl-trait/issue-57611-trait-alias.stderr", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57611-trait-alias.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,16 +1,11 @@\n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n-   |\n-   = note: expected type `FnOnce<(&X,)>`\n-              found type `FnOnce<(&X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:25:9\n+   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n-LL |         |x| x\n-   |         ^^^^^\n+   = note: closure with signature `fn(&'2 X) -> &X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n@@ -26,19 +21,14 @@ note: this closure does not fulfill the lifetime requirements\n LL |         |x| x\n    |         ^^^^^\n \n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&X,)>`\n-              found type `FnOnce<(&'<empty> X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:25:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^\n+   = note: closure with signature `fn(&'2 X) -> &'2 X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`\n \n error[E0308]: mismatched types\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n@@ -54,19 +44,14 @@ note: this closure does not fulfill the lifetime requirements\n LL |         |x| x\n    |         ^^^^^\n \n-error[E0308]: mismatched types\n+error: implementation of `FnOnce` is not general enough\n   --> $DIR/issue-57611-trait-alias.rs:17:16\n    |\n LL |     type Bar = impl Baz<Self, Self>;\n-   |                ^^^^^^^^^^^^^^^^^^^^ one type is more general than the other\n+   |                ^^^^^^^^^^^^^^^^^^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&X,)>`\n-              found type `FnOnce<(&'<empty> X,)>`\n-note: this closure does not fulfill the lifetime requirements\n-  --> $DIR/issue-57611-trait-alias.rs:25:9\n-   |\n-LL |         |x| x\n-   |         ^^^^^\n+   = note: closure with signature `fn(&'2 X) -> &'2 X` must implement `FnOnce<(&'1 X,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 X,)>`, for some specific lifetime `'2`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "2db392e8b8b9f8b7f25a8a0ce2eaaa97f299597b", "filename": "src/test/ui/unboxed-closures/issue-30906.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.nll.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,5 +1,5 @@\n error: higher-ranked subtype error\n-  --> $DIR/issue-30906.rs:15:5\n+  --> $DIR/issue-30906.rs:18:5\n    |\n LL |     test(Compose(f, |_| {}));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e2d219e470384700bdf2e95eb2c3f6a681ee5626", "filename": "src/test/ui/unboxed-closures/issue-30906.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.rs?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -2,17 +2,21 @@\n \n fn test<F: for<'x> FnOnce<(&'x str,)>>(_: F) {}\n \n-struct Compose<F,G>(F,G);\n-impl<T,F,G> FnOnce<(T,)> for Compose<F,G>\n-where F: FnOnce<(T,)>, G: FnOnce<(F::Output,)> {\n+struct Compose<F, G>(F, G);\n+impl<T, F, G> FnOnce<(T,)> for Compose<F, G>\n+where\n+    F: FnOnce<(T,)>,\n+    G: FnOnce<(F::Output,)>,\n+{\n     type Output = G::Output;\n     extern \"rust-call\" fn call_once(self, (x,): (T,)) -> G::Output {\n         (self.1)((self.0)(x))\n     }\n }\n \n fn bad<T>(f: fn(&'static str) -> T) {\n-    test(Compose(f, |_| {})); //~ ERROR: mismatched types\n+    test(Compose(f, |_| {}));\n+    //~^ ERROR: implementation of `FnOnce` is not general enough\n }\n \n fn main() {}"}, {"sha": "35b1e454c02b4caf219ff4719994c9f4672beca7", "filename": "src/test/ui/unboxed-closures/issue-30906.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Fissue-30906.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,17 +1,11 @@\n-error[E0308]: mismatched types\n-  --> $DIR/issue-30906.rs:15:5\n+error: implementation of `FnOnce` is not general enough\n+  --> $DIR/issue-30906.rs:18:5\n    |\n LL |     test(Compose(f, |_| {}));\n-   |     ^^^^ lifetime mismatch\n+   |     ^^^^ implementation of `FnOnce` is not general enough\n    |\n-   = note: expected type `FnOnce<(&'x str,)>`\n-              found type `FnOnce<(&str,)>`\n-note: the lifetime requirement is introduced here\n-  --> $DIR/issue-30906.rs:3:12\n-   |\n-LL | fn test<F: for<'x> FnOnce<(&'x str,)>>(_: F) {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `fn(&'2 str) -> T` must implement `FnOnce<(&'1 str,)>`, for any lifetime `'1`...\n+   = note: ...but it actually implements `FnOnce<(&'2 str,)>`, for some specific lifetime `'2`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`."}, {"sha": "6da46e20c09c0116b3c75818cfae55d82107f78a", "filename": "src/test/ui/where-clauses/where-for-self-2.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbf666dbc1409f1afbe866ba03755e44dbd1927c/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwhere-clauses%2Fwhere-for-self-2.stderr?ref=cbf666dbc1409f1afbe866ba03755e44dbd1927c", "patch": "@@ -1,16 +1,11 @@\n error: implementation of `Bar` is not general enough\n   --> $DIR/where-for-self-2.rs:23:5\n    |\n-LL | / trait Bar {\n-LL | |     fn bar(&self);\n-LL | | }\n-   | |_- trait `Bar` defined here\n-...\n-LL |       foo(&X);\n-   |       ^^^ implementation of `Bar` is not general enough\n+LL |     foo(&X);\n+   |     ^^^ implementation of `Bar` is not general enough\n    |\n-   = note: `Bar` would have to be implemented for the type `&'0 u32`, for any lifetime `'0`...\n-   = note: ...but `Bar` is actually implemented for the type `&'1 u32`, for some specific lifetime `'1`\n+   = note: `&'0 u32` must implement `Bar`, for any lifetime `'0`...\n+   = note: ...but `Bar` is actually implemented for the type `&'static u32`\n \n error: aborting due to previous error\n "}]}