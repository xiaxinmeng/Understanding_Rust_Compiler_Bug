{"sha": "9db0b86f4e24c939cd33cff050ce556faf30e47d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYjBiODZmNGUyNGM5MzljZDMzY2ZmMDUwY2U1NTZmYWYzMGU0N2Q=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-30T01:11:14Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-22T04:25:29Z"}, "message": "rustdoc: Cache traits implemented by a type\n\nThis avoids taking the slow path several thousand times in a row.\n\n- Fallback to all traits if the traits in scope are unknown\n- Use a rustdoc thread_local cache instead of a query\n\nThe set of traits implemented by a type is not stable across crates:\nthere could be new traits added in a new crate.\n\n- Use DocContext instead of a thread-local", "tree": {"sha": "71f2a6dff5f79d4352ab32c05a94ca609ed18865", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f2a6dff5f79d4352ab32c05a94ca609ed18865"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9db0b86f4e24c939cd33cff050ce556faf30e47d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9db0b86f4e24c939cd33cff050ce556faf30e47d", "html_url": "https://github.com/rust-lang/rust/commit/9db0b86f4e24c939cd33cff050ce556faf30e47d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9db0b86f4e24c939cd33cff050ce556faf30e47d/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42232ba70add056cf422960ac96986264870b313", "url": "https://api.github.com/repos/rust-lang/rust/commits/42232ba70add056cf422960ac96986264870b313", "html_url": "https://github.com/rust-lang/rust/commit/42232ba70add056cf422960ac96986264870b313"}], "stats": {"total": 110, "additions": 65, "deletions": 45}, "files": [{"sha": "51d3b92b3e17a4131ea780258e083455872b40ac", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9db0b86f4e24c939cd33cff050ce556faf30e47d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9db0b86f4e24c939cd33cff050ce556faf30e47d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9db0b86f4e24c939cd33cff050ce556faf30e47d", "patch": "@@ -69,6 +69,11 @@ pub struct DocContext<'tcx> {\n     pub auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n     pub render_options: RenderOptions,\n+    /// The traits implemented by a given type.\n+    ///\n+    /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n+    /// `map<type, set<trait>>`\n+    pub type_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n }\n \n impl<'tcx> DocContext<'tcx> {\n@@ -510,6 +515,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                         .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n                         .collect(),\n                     render_options,\n+                    type_trait_cache: RefCell::new(FxHashMap::default()),\n                 };\n                 debug!(\"crate: {:?}\", tcx.hir().krate());\n "}, {"sha": "d6417ec2e1542feab17740eee5d33d75381ec065", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9db0b86f4e24c939cd33cff050ce556faf30e47d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9db0b86f4e24c939cd33cff050ce556faf30e47d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9db0b86f4e24c939cd33cff050ce556faf30e47d", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast as ast;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtensionKind;\n use rustc_feature::UnstableFeatures;\n@@ -9,7 +10,7 @@ use rustc_hir::def::{\n     PerNS, Res,\n };\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_resolve::ParentScope;\n use rustc_session::lint;\n use rustc_span::hygiene::MacroKind;\n@@ -347,7 +348,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             // HACK(jynelson): `clean` expects the type, not the associated item.\n                             // but the disambiguator logic expects the associated item.\n                             // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                            self.kind_side_channel.replace(Some(item.kind.as_def_kind()));\n+                            self.kind_side_channel.set(Some(kind.as_def_kind()));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         })\n                     } else if ns == Namespace::ValueNS {\n@@ -443,8 +444,6 @@ fn resolve_associated_trait_item(\n     ns: Namespace,\n     cx: &DocContext<'_>,\n ) -> Option<ty::AssocKind> {\n-    use rustc_hir::def_id::LOCAL_CRATE;\n-\n     let ty = cx.tcx.type_of(did);\n     // First consider automatic impls: `impl From<T> for T`\n     let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n@@ -501,54 +500,69 @@ fn resolve_associated_trait_item(\n             }\n         })\n         .collect();\n+\n     // Next consider explicit impls: `impl MyTrait for MyType`\n-    // There isn't a cheap way to do this. Just look at every trait!\n-    for &trait_ in cx.tcx.all_traits(LOCAL_CRATE) {\n-        trace!(\"considering explicit impl for trait {:?}\", trait_);\n-        // We can skip the trait if it doesn't have the associated item `item_name`\n-        let assoc_item = cx\n-            .tcx\n-            .associated_items(trait_)\n-            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-            .map(|assoc| (assoc.def_id, assoc.kind));\n-        if let Some(assoc_item) = assoc_item {\n-            debug!(\"considering item {:?}\", assoc_item);\n-            // Look at each trait implementation to see if it's an impl for `did`\n-            cx.tcx.for_each_relevant_impl(trait_, ty, |impl_| {\n-                use ty::TyKind;\n-\n-                let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n-                // Check if these are the same type.\n-                let impl_type = trait_ref.self_ty();\n-                debug!(\n-                    \"comparing type {} with kind {:?} against def_id {:?}\",\n-                    impl_type, impl_type.kind, did\n-                );\n-                // Fast path: if this is a primitive simple `==` will work\n-                let same_type = impl_type == ty\n-                    || match impl_type.kind {\n-                        // Check if these are the same def_id\n-                        TyKind::Adt(def, _) => {\n-                            debug!(\"adt did: {:?}\", def.did);\n-                            def.did == did\n-                        }\n-                        TyKind::Foreign(def_id) => def_id == did,\n-                        _ => false,\n-                    };\n-                if same_type {\n-                    // We found it!\n-                    debug!(\"found a match!\");\n-                    candidates.push(assoc_item);\n-                }\n-            });\n-        }\n+    // Give precedence to inherent impls.\n+    if candidates.is_empty() {\n+        let mut cache = cx.type_trait_cache.borrow_mut();\n+        let traits = cache.entry(did).or_insert_with(|| traits_implemented_by(cx.tcx, did));\n+        debug!(\"considering traits {:?}\", traits);\n+        candidates.extend(traits.iter().filter_map(|&trait_| {\n+            cx.tcx\n+                .associated_items(trait_)\n+                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n+                .map(|assoc| (assoc.def_id, assoc.kind))\n+        }));\n     }\n-\n     // FIXME: warn about ambiguity\n     debug!(\"the candidates were {:?}\", candidates);\n     candidates.pop().map(|(_, kind)| kind)\n }\n \n+/// Given a type, return all traits implemented by that type.\n+///\n+/// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n+/// So it is not stable to serialize cross-crate.\n+/// FIXME: this should only search traits in scope\n+fn traits_implemented_by<'a>(tcx: TyCtxt<'a>, type_: DefId) -> FxHashSet<DefId> {\n+    use rustc_hir::def_id::LOCAL_CRATE;\n+\n+    let all_traits = tcx.all_traits(LOCAL_CRATE).iter().copied();\n+    let ty = tcx.type_of(type_);\n+    let iter = all_traits.flat_map(|trait_| {\n+        trace!(\"considering explicit impl for trait {:?}\", trait_);\n+        let mut saw_impl = false;\n+        // Look at each trait implementation to see if it's an impl for `did`\n+        tcx.for_each_relevant_impl(trait_, ty, |impl_| {\n+            // FIXME: this is inefficient, find a way to short-circuit for_each_* so this doesn't take as long\n+            if saw_impl {\n+                return;\n+            }\n+\n+            let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+            // Check if these are the same type.\n+            let impl_type = trait_ref.self_ty();\n+            debug!(\n+                \"comparing type {} with kind {:?} against type {:?}\",\n+                impl_type, impl_type.kind, type_\n+            );\n+            // Fast path: if this is a primitive simple `==` will work\n+            saw_impl = impl_type == ty\n+                || match impl_type.kind {\n+                    // Check if these are the same def_id\n+                    ty::Adt(def, _) => {\n+                        debug!(\"adt def_id: {:?}\", def.did);\n+                        def.did == type_\n+                    }\n+                    ty::Foreign(def_id) => def_id == type_,\n+                    _ => false,\n+                };\n+        });\n+        if saw_impl { Some(trait_) } else { None }\n+    });\n+    iter.collect()\n+}\n+\n /// Check for resolve collisions between a trait and its derive\n ///\n /// These are common and we should just resolve to the trait in that case"}]}