{"sha": "faa280cee69a34462e43b1a5df7c06faf97e56be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYTI4MGNlZTY5YTM0NDYyZTQzYjFhNWRmN2MwNmZhZjk3ZTU2YmU=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-07-15T18:43:16Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2013-07-15T21:32:53Z"}, "message": "std: add consuming iterators for `HashMap` and `HashSet`", "tree": {"sha": "03afa75b4ea15b4278d9aec395ee2dad8932bdfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03afa75b4ea15b4278d9aec395ee2dad8932bdfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faa280cee69a34462e43b1a5df7c06faf97e56be", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faa280cee69a34462e43b1a5df7c06faf97e56be", "html_url": "https://github.com/rust-lang/rust/commit/faa280cee69a34462e43b1a5df7c06faf97e56be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faa280cee69a34462e43b1a5df7c06faf97e56be/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c22f6587049a13c74e1c07e0f6590ba356a3be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c22f6587049a13c74e1c07e0f6590ba356a3be9", "html_url": "https://github.com/rust-lang/rust/commit/9c22f6587049a13c74e1c07e0f6590ba356a3be9"}], "stats": {"total": 82, "additions": 82, "deletions": 0}, "files": [{"sha": "3b3b71d729735281acfb91ddf9479a4ba93e7538", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/faa280cee69a34462e43b1a5df7c06faf97e56be/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faa280cee69a34462e43b1a5df7c06faf97e56be/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=faa280cee69a34462e43b1a5df7c06faf97e56be", "patch": "@@ -455,6 +455,14 @@ impl<K: Hash + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Creates a consuming iterator, that is, one that moves each key-value\n+    /// pair out of the map in arbitrary order. The map cannot be used after\n+    /// calling this.\n+    pub fn consume_iter(self) -> HashMapConsumeIterator<K, V> {\n+        // `consume_rev_iter` is more efficient than `consume_iter` for vectors\n+        HashMapConsumeIterator {iter: self.buckets.consume_rev_iter()}\n+    }\n+\n     /// Retrieves a value for the given key, failing if the key is not\n     /// present.\n     pub fn get<'a>(&'a self, k: &K) -> &'a V {\n@@ -568,11 +576,21 @@ pub struct HashMapMutIterator<'self, K, V> {\n     priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n }\n \n+/// HashMap consume iterator\n+pub struct HashMapConsumeIterator<K, V> {\n+    priv iter: vec::VecConsumeRevIterator<Option<Bucket<K, V>>>,\n+}\n+\n /// HashSet iterator\n pub struct HashSetIterator<'self, K> {\n     priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n }\n \n+/// HashSet consume iterator\n+pub struct HashSetConsumeIterator<K> {\n+    priv iter: vec::VecConsumeRevIterator<Option<Bucket<K, ()>>>,\n+}\n+\n impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n     #[inline]\n     fn next(&mut self) -> Option<(&'self K, &'self V)> {\n@@ -599,6 +617,19 @@ impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'sel\n     }\n }\n \n+impl<K, V> Iterator<(K, V)> for HashMapConsumeIterator<K, V> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                Some(Bucket {key, value, _}) => return Some((key, value)),\n+                None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self K> {\n@@ -612,6 +643,19 @@ impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n     }\n }\n \n+impl<K> Iterator<K> for HashSetConsumeIterator<K> {\n+    #[inline]\n+    fn next(&mut self) -> Option<K> {\n+        for self.iter.advance |elt| {\n+            match elt {\n+                Some(bucket) => return Some(bucket.key),\n+                None => {},\n+            }\n+        }\n+        None\n+    }\n+}\n+\n impl<K: Eq + Hash, V, T: Iterator<(K, V)>> FromIterator<(K, V), T> for HashMap<K, V> {\n     pub fn from_iterator(iter: &mut T) -> HashMap<K, V> {\n         let (lower, _) = iter.size_hint();\n@@ -726,6 +770,14 @@ impl<T:Hash + Eq> HashSet<T> {\n         self.map.consume(|k, _| f(k))\n     }\n \n+    /// Creates a consuming iterator, that is, one that moves each value out\n+    /// of the set in arbitrary order. The set cannot be used after calling\n+    /// this.\n+    pub fn consume_iter(self) -> HashSetConsumeIterator<T> {\n+        // `consume_rev_iter` is more efficient than `consume_iter` for vectors\n+        HashSetConsumeIterator {iter: self.map.buckets.consume_rev_iter()}\n+    }\n+\n     /// Returns true if the hash set contains a value equivalent to the\n     /// given query value.\n     pub fn contains_equiv<Q:Hash + Equiv<T>>(&self, value: &Q) -> bool {\n@@ -888,6 +940,21 @@ mod test_map {\n         assert!(m.insert(1, 2));\n     }\n \n+    #[test]\n+    fn test_consume_iter() {\n+        let hm = {\n+            let mut hm = HashMap::new();\n+\n+            hm.insert('a', 1);\n+            hm.insert('b', 2);\n+\n+            hm\n+        };\n+\n+        let v = hm.consume_iter().collect::<~[(char, int)]>();\n+        assert!([('a', 1), ('b', 2)] == v || [('b', 2), ('a', 1)] == v);\n+    }\n+\n     #[test]\n     fn test_iterate() {\n         let mut m = linear_map_with_capacity(4);\n@@ -1168,4 +1235,19 @@ mod test_set {\n             assert!(set.contains(x));\n         }\n     }\n+\n+    #[test]\n+    fn test_consume_iter() {\n+        let hs = {\n+            let mut hs = HashSet::new();\n+\n+            hs.insert('a');\n+            hs.insert('b');\n+\n+            hs\n+        };\n+\n+        let v = hs.consume_iter().collect::<~[char]>();\n+        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n+    }\n }"}]}