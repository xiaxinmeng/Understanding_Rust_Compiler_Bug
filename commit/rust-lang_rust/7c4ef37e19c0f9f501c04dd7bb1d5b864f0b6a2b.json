{"sha": "7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNGVmMzdlMTljMGY5ZjUwMWMwNGRkN2JiMWQ1Yjg2NGYwYjZhMmI=", "commit": {"author": {"name": "pawanbisht62", "email": "36775517+pawanbisht62@users.noreply.github.com", "date": "2020-08-10T07:49:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-10T07:49:24Z"}, "message": "Merge branch 'master' into feature/incorporate-tracing", "tree": {"sha": "db7bfedf0de60ca646cce61f54d70100dccb623c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db7bfedf0de60ca646cce61f54d70100dccb623c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfMPwECRBK7hj4Ov3rIwAAdHIIAC6Dr/JBW7H0dcrpwRuvhOwL\nJ/NuSCKjgXxlGpcT8RhtoHEHTs6xf+QdMXEqsmkKm4JaBHdTQrzu0/FUJQCZAcez\ngpgJYCM08035oiKCWM4exYkhgnyyXpVcCfDToLyDtNbDLthuij7nwKnotMW6Ix90\nTk35eqgDFq+if/2v+TLsB7GLR2wbfTDyYOegxMB/A/x0gqq7CQKqyiwl6TKU0JHj\nnQ5MG0JP3A1H3oyhZkWi5gZFovGUk7q1Rq176WSvjIwTxujv/sTQdm6WviU8IfKn\nMrh6eaTAiY056S4o5+tJNrgf0Kcjud+EraR70Th3QDfuFKHWNL1FPd7TeD0UIlg=\n=t08X\n-----END PGP SIGNATURE-----\n", "payload": "tree db7bfedf0de60ca646cce61f54d70100dccb623c\nparent bac939edcf2137f625cfd7b56dfa4aa7b814868f\nparent 568f6195bbf3c04a601a297a386e0e1dc0ca8333\nauthor pawanbisht62 <36775517+pawanbisht62@users.noreply.github.com> 1597045764 +0530\ncommitter GitHub <noreply@github.com> 1597045764 +0530\n\nMerge branch 'master' into feature/incorporate-tracing"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "html_url": "https://github.com/rust-lang/rust/commit/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/comments", "author": {"login": "pawanbisht62", "id": 36775517, "node_id": "MDQ6VXNlcjM2Nzc1NTE3", "avatar_url": "https://avatars.githubusercontent.com/u/36775517?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pawanbisht62", "html_url": "https://github.com/pawanbisht62", "followers_url": "https://api.github.com/users/pawanbisht62/followers", "following_url": "https://api.github.com/users/pawanbisht62/following{/other_user}", "gists_url": "https://api.github.com/users/pawanbisht62/gists{/gist_id}", "starred_url": "https://api.github.com/users/pawanbisht62/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pawanbisht62/subscriptions", "organizations_url": "https://api.github.com/users/pawanbisht62/orgs", "repos_url": "https://api.github.com/users/pawanbisht62/repos", "events_url": "https://api.github.com/users/pawanbisht62/events{/privacy}", "received_events_url": "https://api.github.com/users/pawanbisht62/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bac939edcf2137f625cfd7b56dfa4aa7b814868f", "url": "https://api.github.com/repos/rust-lang/rust/commits/bac939edcf2137f625cfd7b56dfa4aa7b814868f", "html_url": "https://github.com/rust-lang/rust/commit/bac939edcf2137f625cfd7b56dfa4aa7b814868f"}, {"sha": "568f6195bbf3c04a601a297a386e0e1dc0ca8333", "url": "https://api.github.com/repos/rust-lang/rust/commits/568f6195bbf3c04a601a297a386e0e1dc0ca8333", "html_url": "https://github.com/rust-lang/rust/commit/568f6195bbf3c04a601a297a386e0e1dc0ca8333"}], "stats": {"total": 6974, "additions": 4478, "deletions": 2496}, "files": [{"sha": "2685de2244e9414f7bb5134bc0dff7d00b3b030a", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -137,12 +137,6 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n-[[package]]\n-name = \"autocfg\"\n-version = \"0.1.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n-\n [[package]]\n name = \"autocfg\"\n version = \"1.0.0\"\n@@ -766,7 +760,7 @@ version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c3c7c73a2d1e9fc0886a08b93e98eb643461230d5f1925e4036204d5f2e261a8\"\n dependencies = [\n- \"autocfg 1.0.0\",\n+ \"autocfg\",\n  \"cfg-if\",\n  \"lazy_static\",\n ]\n@@ -1245,11 +1239,11 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.6.2\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3cd9867f119b19fecb08cd5c326ad4488d7a1da4bf75b4d95d71db742525aaab\"\n+checksum = \"e91b62f79061a0bc2e046024cb7ba44b08419ed238ecbd9adbd787434b9e8c25\"\n dependencies = [\n- \"autocfg 0.1.7\",\n+ \"autocfg\",\n  \"compiler_builtins\",\n  \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n@@ -1388,9 +1382,13 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.0.2\"\n+version = \"1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e81a7c05f79578dbc15793d8b619db9ba32b4577003ef3af1a91c416798c58d\"\n+checksum = \"86b45e59b16c76b11bf9738fd5d38879d3bd28ad292d7b313608becb17ae2df9\"\n+dependencies = [\n+ \"autocfg\",\n+ \"hashbrown\",\n+]\n \n [[package]]\n name = \"installer\"\n@@ -2079,7 +2077,7 @@ version = \"0.9.54\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1024c0a59774200a555087a6da3f253a9095a5f344e353b212ac4c8b8e450986\"\n dependencies = [\n- \"autocfg 1.0.0\",\n+ \"autocfg\",\n  \"cc\",\n  \"libc\",\n  \"openssl-src\",\n@@ -3201,7 +3199,6 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n- \"scoped-tls\",\n  \"smallvec 1.4.0\",\n  \"tracing\",\n ]\n@@ -4925,7 +4922,7 @@ dependencies = [\n  \"ansi_term 0.12.1\",\n  \"lazy_static\",\n  \"matchers\",\n- \"parking_lot 0.9.0\",\n+ \"parking_lot 0.10.2\",\n  \"regex\",\n  \"sharded-slab\",\n  \"smallvec 1.4.0\","}, {"sha": "7e27aeb85392c05c813c7d63e9eb26294e2785fc", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 173, "deletions": 32, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,3 +1,5 @@\n+// ignore-tidy-filelength\n+\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n use core::fmt::Debug;\n@@ -355,6 +357,30 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n }\n \n+/// An owning iterator over the keys of a `BTreeMap`.\n+///\n+/// This `struct` is created by the [`into_keys`] method on [`BTreeMap`].\n+/// See its documentation for more.\n+///\n+/// [`into_keys`]: BTreeMap::into_keys\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+#[derive(Debug)]\n+pub struct IntoKeys<K, V> {\n+    inner: IntoIter<K, V>,\n+}\n+\n+/// An owning iterator over the values of a `BTreeMap`.\n+///\n+/// This `struct` is created by the [`into_values`] method on [`BTreeMap`].\n+/// See its documentation for more.\n+///\n+/// [`into_values`]: BTreeMap::into_values\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+#[derive(Debug)]\n+pub struct IntoValues<K, V> {\n+    inner: IntoIter<K, V>,\n+}\n+\n /// An iterator over a sub-range of entries in a `BTreeMap`.\n ///\n /// This `struct` is created by the [`range`] method on [`BTreeMap`]. See its\n@@ -1291,10 +1317,56 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         self.length = dfs(self.root.as_ref().unwrap().as_ref());\n     }\n+\n+    /// Creates a consuming iterator visiting all the keys, in sorted order.\n+    /// The map cannot be used after calling this.\n+    /// The iterator element type is `K`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_into_keys_values)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(2, \"b\");\n+    /// a.insert(1, \"a\");\n+    ///\n+    /// let keys: Vec<i32> = a.into_keys().collect();\n+    /// assert_eq!(keys, [1, 2]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+    pub fn into_keys(self) -> IntoKeys<K, V> {\n+        IntoKeys { inner: self.into_iter() }\n+    }\n+\n+    /// Creates a consuming iterator visiting all the values, in order by key.\n+    /// The map cannot be used after calling this.\n+    /// The iterator element type is `V`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_into_keys_values)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut a = BTreeMap::new();\n+    /// a.insert(1, \"hello\");\n+    /// a.insert(2, \"goodbye\");\n+    ///\n+    /// let values: Vec<&str> = a.into_values().collect();\n+    /// assert_eq!(values, [\"hello\", \"goodbye\"]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+    pub fn into_values(self) -> IntoValues<K, V> {\n+        IntoValues { inner: self.into_iter() }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> IntoIterator for &'a BTreeMap<K, V> {\n+impl<'a, K, V> IntoIterator for &'a BTreeMap<K, V> {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n \n@@ -1363,7 +1435,7 @@ impl<K, V> Clone for Iter<'_, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> IntoIterator for &'a mut BTreeMap<K, V> {\n+impl<'a, K, V> IntoIterator for &'a mut BTreeMap<K, V> {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n \n@@ -1697,10 +1769,9 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                let (kv, pos) = kv.remove_kv_tracking(|_| self.emptied_internal_root = true);\n                 self.cur_leaf_edge = Some(pos);\n-                self.emptied_internal_root |= emptied_internal_root;\n-                return Some(old_kv);\n+                return Some(kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -1781,6 +1852,82 @@ impl<'a, K, V> Range<'a, K, V> {\n     }\n }\n \n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> Iterator for IntoKeys<K, V> {\n+    type Item = K;\n+\n+    fn next(&mut self) -> Option<K> {\n+        self.inner.next().map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(mut self) -> Option<K> {\n+        self.next_back()\n+    }\n+\n+    fn min(mut self) -> Option<K> {\n+        self.next()\n+    }\n+\n+    fn max(mut self) -> Option<K> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> DoubleEndedIterator for IntoKeys<K, V> {\n+    fn next_back(&mut self) -> Option<K> {\n+        self.inner.next_back().map(|(k, _)| k)\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> FusedIterator for IntoKeys<K, V> {}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> Iterator for IntoValues<K, V> {\n+    type Item = V;\n+\n+    fn next(&mut self) -> Option<V> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    fn last(mut self) -> Option<V> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> DoubleEndedIterator for IntoValues<K, V> {\n+    fn next_back(&mut self) -> Option<V> {\n+        self.inner.next_back().map(|(_, v)| v)\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> ExactSizeIterator for IntoValues<K, V> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> FusedIterator for IntoValues<K, V> {}\n+\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> DoubleEndedIterator for Range<'a, K, V> {\n     fn next_back(&mut self) -> Option<(&'a K, &'a V)> {\n@@ -2645,35 +2792,28 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n-        let root = pos.into_node().into_root_mut();\n-        if emptied_internal_root {\n-            root.pop_internal_level();\n-        }\n+        let (old_kv, _) =\n+            self.handle.remove_kv_tracking(|root| root.into_root_mut().pop_internal_level());\n         old_kv\n     }\n }\n \n-struct RemoveResult<'a, K, V> {\n-    // Key and value removed.\n-    old_kv: (K, V),\n-    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n-    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    // Whether the remove left behind and empty internal root node, that should be removed\n-    // using `pop_internal_level`.\n-    emptied_internal_root: bool,\n-}\n-\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the tree, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair. It's possible this leaves\n     /// an empty internal root node, which the caller should subsequently pop from\n     /// the map holding the tree. The caller should also decrement the map's length.\n-    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n-        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n+    fn remove_kv_tracking<F>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>)\n+    where\n+        F: FnOnce(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    {\n+        let (old_kv, mut pos, was_internal) = match self.force() {\n             Leaf(leaf) => {\n-                let (hole, old_key, old_val) = leaf.remove();\n-                (hole, old_key, old_val, false)\n+                let (old_kv, pos) = leaf.remove();\n+                (old_kv, pos, false)\n             }\n             Internal(mut internal) => {\n                 // Replace the location freed in the internal node with the next KV,\n@@ -2688,17 +2828,16 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n                 let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n-                let (hole, key, val) = to_remove.remove();\n+                let (kv, pos) = to_remove.remove();\n \n-                let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n-                let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n+                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n \n-                (hole, old_key, old_val, true)\n+                ((old_key, old_val), pos, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2719,8 +2858,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // This empty parent must be the root, and should be popped off the tree.\n-                        emptied_internal_root = true;\n+                        // The parent that was just emptied must be the root,\n+                        // because nodes on a lower level would not have been\n+                        // left underfull. It has to be popped off the tree soon.\n+                        handle_emptied_internal_root(parent);\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2747,7 +2888,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n+        (old_kv, pos)\n     }\n }\n "}, {"sha": "33b1ee003ed3af1c98082a3cc2b942364aeca907", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,3 +1,5 @@\n+use core::intrinsics;\n+use core::mem;\n use core::ptr;\n \n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n@@ -79,16 +81,24 @@ def_next_kv_uncheched_dealloc! {unsafe fn next_kv_unchecked_dealloc: right_kv}\n def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_kv}\n \n /// This replaces the value behind the `v` unique reference by calling the\n-/// relevant function.\n+/// relevant function, and returns a result obtained along the way.\n ///\n-/// Safety: The change closure must not panic.\n+/// If a panic occurs in the `change` closure, the entire process will be aborted.\n #[inline]\n-unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n+fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n+    struct PanicGuard;\n+    impl Drop for PanicGuard {\n+        fn drop(&mut self) {\n+            intrinsics::abort()\n+        }\n+    }\n+    let guard = PanicGuard;\n     let value = unsafe { ptr::read(v) };\n     let (new_value, ret) = change(value);\n     unsafe {\n         ptr::write(v, new_value);\n     }\n+    mem::forget(guard);\n     ret\n }\n \n@@ -97,26 +107,22 @@ impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Ed\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (kv.next_leaf_edge(), kv.into_kv())\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (kv.next_leaf_edge(), kv.into_kv())\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_back_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (kv.next_back_leaf_edge(), kv.into_kv())\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (kv.next_back_leaf_edge(), kv.into_kv())\n+        })\n     }\n }\n \n@@ -127,16 +133,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unsafe {\n-            let kv = replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (ptr::read(&kv).next_leaf_edge(), kv)\n-            });\n-            // Doing the descend (and perhaps another move) invalidates the references\n-            // returned by `into_kv_mut`, so we have to do this last.\n-            kv.into_kv_mut()\n-        }\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (unsafe { ptr::read(&kv) }.next_leaf_edge(), kv)\n+        });\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n     }\n \n     /// Moves the leaf edge handle to the previous leaf and returns references to the\n@@ -145,16 +149,14 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        unsafe {\n-            let kv = replace(self, |leaf_edge| {\n-                let kv = leaf_edge.next_back_kv();\n-                let kv = unwrap_unchecked(kv.ok());\n-                (ptr::read(&kv).next_back_leaf_edge(), kv)\n-            });\n-            // Doing the descend (and perhaps another move) invalidates the references\n-            // returned by `into_kv_mut`, so we have to do this last.\n-            kv.into_kv_mut()\n-        }\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unsafe { unwrap_unchecked(kv.ok()) };\n+            (unsafe { ptr::read(&kv) }.next_back_leaf_edge(), kv)\n+        });\n+        // Doing the descend (and perhaps another move) invalidates the references\n+        // returned by `into_kv_mut`, so we have to do this last.\n+        kv.into_kv_mut()\n     }\n }\n \n@@ -172,14 +174,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   call this method again subject to both preconditions listed in the first point,\n     ///   or call counterpart `next_back_unchecked` subject to its preconditions.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = next_kv_unchecked_dealloc(leaf_edge);\n-                let k = ptr::read(kv.reborrow().into_kv().0);\n-                let v = ptr::read(kv.reborrow().into_kv().1);\n-                (kv.next_leaf_edge(), (k, v))\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = unsafe { next_kv_unchecked_dealloc(leaf_edge) };\n+            let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+            let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+            (kv.next_leaf_edge(), (k, v))\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -195,14 +195,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   call this method again subject to both preconditions listed in the first point,\n     ///   or call counterpart `next_unchecked` subject to its preconditions.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        unsafe {\n-            replace(self, |leaf_edge| {\n-                let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n-                let k = ptr::read(kv.reborrow().into_kv().0);\n-                let v = ptr::read(kv.reborrow().into_kv().1);\n-                (kv.next_back_leaf_edge(), (k, v))\n-            })\n-        }\n+        replace(self, |leaf_edge| {\n+            let kv = unsafe { next_back_kv_unchecked_dealloc(leaf_edge) };\n+            let k = unsafe { ptr::read(kv.reborrow().into_kv().0) };\n+            let v = unsafe { ptr::read(kv.reborrow().into_kv().1) };\n+            (kv.next_back_leaf_edge(), (k, v))\n+        })\n     }\n }\n "}, {"sha": "4e52c16d20d20d81fc2cbd424124fb98eb71d226", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1083,12 +1083,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n     pub fn remove(\n         mut self,\n-    ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n             (*self.node.as_leaf_mut()).len -= 1;\n-            (self.left_edge(), k, v)\n+            ((k, v), self.left_edge())\n         }\n     }\n }"}, {"sha": "247b636c808acf5e15a2b16acf212860872c73b3", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -203,13 +203,15 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// # Safety\n     ///\n-    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `ptr` must be allocated (via the given allocator `alloc`), and with the given\n+    /// `capacity`.\n     /// The `capacity` cannot exceed `isize::MAX` for sized types. (only a concern on 32-bit\n     /// systems). ZST vectors may have a capacity up to `usize::MAX`.\n-    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `alloc`, then this is\n+    /// guaranteed.\n     #[inline]\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n-        Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc: a }\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, alloc: A) -> Self {\n+        Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc }\n     }\n \n     /// Gets a raw pointer to the start of the allocation. Note that this is"}, {"sha": "5777bd60907144b9ccac9c0f30b973977a35761a", "filename": "library/alloc/tests/btree/map.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbtree%2Fmap.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1461,3 +1461,27 @@ fn test_into_iter_drop_leak_height_1() {\n         assert_eq!(DROPS.load(Ordering::SeqCst), size);\n     }\n }\n+\n+#[test]\n+fn test_into_keys() {\n+    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+    let map: BTreeMap<_, _> = vec.into_iter().collect();\n+    let keys: Vec<_> = map.into_keys().collect();\n+\n+    assert_eq!(keys.len(), 3);\n+    assert!(keys.contains(&1));\n+    assert!(keys.contains(&2));\n+    assert!(keys.contains(&3));\n+}\n+\n+#[test]\n+fn test_into_values() {\n+    let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+    let map: BTreeMap<_, _> = vec.into_iter().collect();\n+    let values: Vec<_> = map.into_values().collect();\n+\n+    assert_eq!(values.len(), 3);\n+    assert!(values.contains(&'a'));\n+    assert!(values.contains(&'b'));\n+    assert!(values.contains(&'c'));\n+}"}, {"sha": "3aacd4a687e384b454ab9eb12a83b732022208a7", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,6 +4,7 @@\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(map_first_last)]\n+#![feature(map_into_keys_values)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n #![feature(str_split_once)]"}, {"sha": "919070aadf972123ce3ca83cdc72ac9fbf80e69b", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 55, "deletions": 89, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -56,69 +56,55 @@ impl<T, const N: usize> IntoIter<T, N> {\n \n         // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n         // works with const generics:\n-        //     `mem::transmute::<[T; {N}], [MaybeUninit<T>; {N}]>(array)`\n+        //     `mem::transmute::<[T; N], [MaybeUninit<T>; N]>(array)`\n         //\n-        // Until then, we do it manually here. We first create a bitwise copy\n-        // but cast the pointer so that it is treated as a different type. Then\n-        // we forget `array` so that it is not dropped.\n-        let data = unsafe {\n-            let data = ptr::read(&array as *const [T; N] as *const [MaybeUninit<T>; N]);\n+        // Until then, we can use `mem::transmute_copy` to create a bitwise copy\n+        // as a different type, then forget `array` so that it is not dropped.\n+        unsafe {\n+            let iter = Self { data: mem::transmute_copy(&array), alive: 0..N };\n             mem::forget(array);\n-            data\n-        };\n-\n-        Self { data, alive: 0..N }\n+            iter\n+        }\n     }\n \n     /// Returns an immutable slice of all elements that have not been yielded\n     /// yet.\n     fn as_slice(&self) -> &[T] {\n-        let slice = &self.data[self.alive.clone()];\n-        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n-        // the size and alignment of `T`. Furthermore, we know that all\n-        // elements within `alive` are properly initialized.\n-        unsafe { mem::transmute::<&[MaybeUninit<T>], &[T]>(slice) }\n+        // SAFETY: We know that all elements within `alive` are properly initialized.\n+        unsafe {\n+            let slice = self.data.get_unchecked(self.alive.clone());\n+            MaybeUninit::slice_get_ref(slice)\n+        }\n     }\n \n     /// Returns a mutable slice of all elements that have not been yielded yet.\n     fn as_mut_slice(&mut self) -> &mut [T] {\n-        // This transmute is safe, same as in `as_slice` above.\n-        let slice = &mut self.data[self.alive.clone()];\n-        // SAFETY: This transmute is safe. As mentioned in `new`, `MaybeUninit` retains\n-        // the size and alignment of `T`. Furthermore, we know that all\n-        // elements within `alive` are properly initialized.\n-        unsafe { mem::transmute::<&mut [MaybeUninit<T>], &mut [T]>(slice) }\n+        // SAFETY: We know that all elements within `alive` are properly initialized.\n+        unsafe {\n+            let slice = self.data.get_unchecked_mut(self.alive.clone());\n+            MaybeUninit::slice_get_mut(slice)\n+        }\n     }\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> Iterator for IntoIter<T, N> {\n     type Item = T;\n     fn next(&mut self) -> Option<Self::Item> {\n-        if self.alive.start == self.alive.end {\n-            return None;\n-        }\n-\n-        // Bump start index.\n+        // Get the next index from the front.\n         //\n-        // From the check above we know that `alive.start != alive.end`.\n-        // Combine this with the invariant `alive.start <= alive.end`, we know\n-        // that `alive.start < alive.end`. Increasing `alive.start` by 1\n-        // maintains the invariant regarding `alive`. However, due to this\n-        // change, for a short time, the alive zone is not `data[alive]`\n-        // anymore, but `data[idx..alive.end]`.\n-        let idx = self.alive.start;\n-        self.alive.start += 1;\n-\n-        // Read the element from the array.\n-        // SAFETY: This is safe: `idx` is an index\n-        // into the \"alive\" region of the array. Reading this element means\n-        // that `data[idx]` is regarded as dead now (i.e. do not touch). As\n-        // `idx` was the start of the alive-zone, the alive zone is now\n-        // `data[alive]` again, restoring all invariants.\n-        let out = unsafe { self.data.get_unchecked(idx).read() };\n-\n-        Some(out)\n+        // Increasing `alive.start` by 1 maintains the invariant regarding\n+        // `alive`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[idx..alive.end]`.\n+        self.alive.next().map(|idx| {\n+            // Read the element from the array.\n+            // SAFETY: `idx` is an index into the former \"alive\" region of the\n+            // array. Reading this element means that `data[idx]` is regarded as\n+            // dead now (i.e. do not touch). As `idx` was the start of the\n+            // alive-zone, the alive zone is now `data[alive]` again, restoring\n+            // all invariants.\n+            unsafe { self.data.get_unchecked(idx).read() }\n+        })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -138,33 +124,20 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.alive.start == self.alive.end {\n-            return None;\n-        }\n-\n-        // Decrease end index.\n+        // Get the next index from the back.\n         //\n-        // From the check above we know that `alive.start != alive.end`.\n-        // Combine this with the invariant `alive.start <= alive.end`, we know\n-        // that `alive.start < alive.end`. As `alive.start` cannot be negative,\n-        // `alive.end` is at least 1, meaning that we can safely decrement it\n-        // by one. This also maintains the invariant `alive.start <=\n-        // alive.end`. However, due to this change, for a short time, the alive\n-        // zone is not `data[alive]` anymore, but `data[alive.start..alive.end\n-        // + 1]`.\n-        self.alive.end -= 1;\n-\n-        // Read the element from the array.\n-        // SAFETY: This is safe: `alive.end` is an\n-        // index into the \"alive\" region of the array. Compare the previous\n-        // comment that states that the alive region is\n-        // `data[alive.start..alive.end + 1]`. Reading this element means that\n-        // `data[alive.end]` is regarded as dead now (i.e. do not touch). As\n-        // `alive.end` was the end of the alive-zone, the alive zone is now\n-        // `data[alive]` again, restoring all invariants.\n-        let out = unsafe { self.data.get_unchecked(self.alive.end).read() };\n-\n-        Some(out)\n+        // Decreasing `alive.end` by 1 maintains the invariant regarding\n+        // `alive`. However, due to this change, for a short time, the alive\n+        // zone is not `data[alive]` anymore, but `data[alive.start..=idx]`.\n+        self.alive.next_back().map(|idx| {\n+            // Read the element from the array.\n+            // SAFETY: `idx` is an index into the former \"alive\" region of the\n+            // array. Reading this element means that `data[idx]` is regarded as\n+            // dead now (i.e. do not touch). As `idx` was the end of the\n+            // alive-zone, the alive zone is now `data[alive]` again, restoring\n+            // all invariants.\n+            unsafe { self.data.get_unchecked(idx).read() }\n+        })\n     }\n }\n \n@@ -203,26 +176,19 @@ unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> {}\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n impl<T: Clone, const N: usize> Clone for IntoIter<T, N> {\n     fn clone(&self) -> Self {\n-        // SAFETY: each point of unsafety is documented inside the unsafe block\n-        unsafe {\n-            // This creates a new uninitialized array. Note that the `assume_init`\n-            // refers to the array, not the individual elements. And it is Ok if\n-            // the array is in an uninitialized state as all elements may be\n-            // uninitialized (all bit patterns are valid). Compare the\n-            // `MaybeUninit` docs for more information.\n-            let mut new_data: [MaybeUninit<T>; N] = MaybeUninit::uninit().assume_init();\n-\n-            // Clone all alive elements.\n-            for idx in self.alive.clone() {\n-                // The element at `idx` in the old array is alive, so we can\n-                // safely call `get_ref()`. We then clone it, and write the\n-                // clone into the new array.\n-                let clone = self.data.get_unchecked(idx).get_ref().clone();\n-                new_data.get_unchecked_mut(idx).write(clone);\n-            }\n-\n-            Self { data: new_data, alive: self.alive.clone() }\n+        // Note, we don't really need to match the exact same alive range, so\n+        // we can just clone into offset 0 regardless of where `self` is.\n+        let mut new = Self { data: MaybeUninit::uninit_array(), alive: 0..0 };\n+\n+        // Clone all alive elements.\n+        for (src, dst) in self.as_slice().iter().zip(&mut new.data) {\n+            // Write a clone into the new array, then update its alive range.\n+            // If cloning panics, we'll correctly drop the previous items.\n+            dst.write(src.clone());\n+            new.alive.end += 1;\n         }\n+\n+        new\n     }\n }\n "}, {"sha": "3dc0ee2b555300d8c5183b3141517fb1b8a15c98", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -119,9 +119,11 @@ pub fn black_box<T>(dummy: T) -> T {\n     // box. This isn't the greatest implementation since it probably deoptimizes\n     // more than we want, but it's so far good enough.\n \n+    #[cfg(not(miri))] // This is just a hint, so it is fine to skip in Miri.\n     // SAFETY: the inline assembly is a no-op.\n     unsafe {\n         llvm_asm!(\"\" : : \"r\"(&dummy));\n-        dummy\n     }\n+\n+    dummy\n }"}, {"sha": "027498d3911c8fcac38383ee5df5cb0add760480", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -405,9 +405,11 @@ impl<T> MaybeUninit<T> {\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_as_ptr\", issue = \"75251\")]\n     #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n+    pub const fn as_ptr(&self) -> *const T {\n+        // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.\n+        self as *const _ as *const T\n     }\n \n     /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n@@ -442,9 +444,11 @@ impl<T> MaybeUninit<T> {\n     /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n     /// until they are, it is advisable to avoid them.)\n     #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[rustc_const_unstable(feature = \"const_maybe_uninit_as_ptr\", issue = \"75251\")]\n     #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n+    pub const fn as_mut_ptr(&mut self) -> *mut T {\n+        // `MaybeUninit` and `ManuallyDrop` are both `repr(transparent)` so we can cast the pointer.\n+        self as *mut _ as *mut T\n     }\n \n     /// Extracts the value from the `MaybeUninit<T>` container. This is a great way"}, {"sha": "68937176270356a031ac23cf1fed6053f5edff5a", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2346,17 +2346,12 @@ assert_eq!(\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute them to arrays of bytes\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute them to\n                 // arrays of bytes\n-                unsafe { Bytes { val: self }.bytes }\n+                unsafe { mem::transmute(self) }\n             }\n         }\n \n@@ -2464,16 +2459,11 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute to them\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute to them\n-                unsafe { Bytes { bytes }.val }\n+                unsafe { mem::transmute(bytes) }\n             }\n         }\n \n@@ -4368,23 +4358,18 @@ assert_eq!(\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute them to arrays of bytes\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute them to\n                 // arrays of bytes\n-                unsafe { Bytes { val: self }.bytes }\n+                unsafe { mem::transmute(self) }\n             }\n         }\n \n         doc_comment! {\n-            concat!(\"Create an integer value from its representation as a byte array in\n-big endian.\n+            concat!(\"Create a native endian integer value from its representation\n+as a byte array in big endian.\n \",\n $from_xe_bytes_doc,\n \"\n@@ -4416,8 +4401,8 @@ fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n \n         doc_comment! {\n             concat!(\"\n-Create an integer value from its representation as a byte array in\n-little endian.\n+Create a native endian integer value from its representation\n+as a byte array in little endian.\n \",\n $from_xe_bytes_doc,\n \"\n@@ -4448,8 +4433,8 @@ fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n         }\n \n         doc_comment! {\n-            concat!(\"Create an integer value from its memory representation as a byte\n-array in native endianness.\n+            concat!(\"Create a native endian integer value from its memory representation\n+as a byte array in native endianness.\n \n As the target platform's native endianness is used, portable code\n likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n@@ -4486,16 +4471,11 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute to them\n-            #[allow_internal_unstable(const_fn_union)]\n+            #[allow_internal_unstable(const_fn_transmute)]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n-                #[repr(C)]\n-                union Bytes {\n-                    val: $SelfT,\n-                    bytes: [u8; mem::size_of::<$SelfT>()],\n-                }\n                 // SAFETY: integers are plain old datatypes so we can always transmute to them\n-                unsafe { Bytes { bytes }.val }\n+                unsafe { mem::transmute(bytes) }\n             }\n         }\n "}, {"sha": "a16970e9fd1802863411b74ac32da08acf1a24b2", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -656,6 +656,38 @@ impl<T: ?Sized> *const T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n+    /// Sets the pointer value to `ptr`.\n+    ///\n+    /// In case `self` is a (fat) pointer to an unsized type, this operation\n+    /// will only affect the pointer part, whereas for (thin) pointers to\n+    /// sized types, this has the same effect as a simple assignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = &arr[0] as *const dyn Debug;\n+    /// let thin = ptr as *const u8;\n+    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n+    /// assert_eq!(unsafe { *(ptr as *const i32) }, 3);\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[inline]\n+    pub fn set_ptr_value(mut self, val: *const ()) -> Self {\n+        let thin = &mut self as *mut *const T as *mut *const ();\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *thin = val };\n+        self\n+    }\n+\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "b47f90c59962926462cd306ac87baf8d4f05f580", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -712,6 +712,38 @@ impl<T: ?Sized> *mut T {\n         self.wrapping_offset((count as isize).wrapping_neg())\n     }\n \n+    /// Sets the pointer value to `ptr`.\n+    ///\n+    /// In case `self` is a (fat) pointer to an unsized type, this operation\n+    /// will only affect the pointer part, whereas for (thin) pointers to\n+    /// sized types, this has the same effect as a simple assignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This function is primarily useful for allowing byte-wise pointer\n+    /// arithmetic on potentially fat pointers:\n+    ///\n+    /// ```\n+    /// #![feature(set_ptr_value)]\n+    /// # use core::fmt::Debug;\n+    /// let mut arr: [i32; 3] = [1, 2, 3];\n+    /// let mut ptr = &mut arr[0] as *mut dyn Debug;\n+    /// let thin = ptr as *mut u8;\n+    /// ptr = ptr.set_ptr_value(unsafe { thin.add(8).cast() });\n+    /// assert_eq!(unsafe { *(ptr as *mut i32) }, 3);\n+    /// ```\n+    #[unstable(feature = \"set_ptr_value\", issue = \"75091\")]\n+    #[inline]\n+    pub fn set_ptr_value(mut self, val: *mut ()) -> Self {\n+        let thin = &mut self as *mut *mut T as *mut *mut ();\n+        // SAFETY: In case of a thin pointer, this operations is identical\n+        // to a simple assignment. In case of a fat pointer, with the current\n+        // fat pointer layout implementation, the first field of such a\n+        // pointer is always the data pointer, which is likewise assigned.\n+        unsafe { *thin = val };\n+        self\n+    }\n+\n     /// Reads the value from `self` without moving it. This leaves the\n     /// memory in `self` unchanged.\n     ///"}, {"sha": "d876ab23653f367925b8f904ad1891705a080356", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -117,6 +117,24 @@ impl<T: ?Sized> NonNull<T> {\n     /// The resulting lifetime is bound to self so this behaves \"as if\"\n     /// it were actually an instance of T that is getting borrowed. If a longer\n     /// (unbound) lifetime is needed, use `&*my_ptr.as_ptr()`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    /// - `self` is properly aligned\n+    /// - `self` must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is, the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n+    /// Additionally, the lifetime of `self` does not necessarily reflect the actual\n+    /// lifetime of the data. *You* must enforce Rust's aliasing rules. In particular,\n+    /// for the duration of this lifetime, the memory the pointer points to must not\n+    /// get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// [here]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_ref(&self) -> &T {\n@@ -130,6 +148,24 @@ impl<T: ?Sized> NonNull<T> {\n     /// The resulting lifetime is bound to self so this behaves \"as if\"\n     /// it were actually an instance of T that is getting borrowed. If a longer\n     /// (unbound) lifetime is needed, use `&mut *my_ptr.as_ptr()`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// When calling this method, you have to ensure that all of the following is true:\n+    /// - `self` is properly aligned\n+    /// - `self` must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferenceable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n+    /// (The part about being initialized is not yet fully decided, but until\n+    /// it is the only safe approach is to ensure that they are indeed initialized.)\n+    ///\n+    /// Additionally, the lifetime of `self` does not necessarily reflect the actual\n+    /// lifetime of the data. *You* must enforce Rust's aliasing rules. In particular,\n+    /// for the duration of this lifetime, the memory this pointer points to must not\n+    /// get accessed (read or written) through any other pointer.\n+    ///\n+    /// [here]: crate::ptr#safety\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n@@ -224,6 +260,24 @@ impl<T> NonNull<[T]> {\n         unsafe { NonNull::new_unchecked(self.as_ptr().as_mut_ptr()) }\n     }\n \n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n+    /// assert_eq!(slice.as_mut_ptr(), 1 as *mut i8);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_mut_ptr(self) -> *mut T {\n+        self.as_non_null_ptr().as_ptr()\n+    }\n+\n     /// Returns a raw pointer to an element or subslice, without doing bounds\n     /// checking.\n     ///"}, {"sha": "eac4741cd260ad483969d3dfdc70f9cb838f2c45", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1923,7 +1923,10 @@ mod traits {\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n             let (start, end) = (self.start, self.end);\n-            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n+            match self.get(slice) {\n+                Some(s) => s,\n+                None => super::slice_error_fail(slice, start, end),\n+            }\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n@@ -1995,7 +1998,10 @@ mod traits {\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n             let end = self.end;\n-            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, 0, end))\n+            match self.get(slice) {\n+                Some(s) => s,\n+                None => super::slice_error_fail(slice, 0, end),\n+            }\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n@@ -2068,7 +2074,10 @@ mod traits {\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n             let (start, end) = (self.start, slice.len());\n-            self.get(slice).unwrap_or_else(|| super::slice_error_fail(slice, start, end))\n+            match self.get(slice) {\n+                Some(s) => s,\n+                None => super::slice_error_fail(slice, start, end),\n+            }\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {"}, {"sha": "5741f8a53b522b96044120af538f41f58b4bfd12", "filename": "library/core/src/time.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -30,12 +30,10 @@ const MICROS_PER_SEC: u64 = 1_000_000;\n /// nanosecond-level precision, APIs binding a system timeout will typically round up\n /// the number of nanoseconds.\n ///\n-/// `Duration`s implement many common traits, including [`Add`], [`Sub`], and other\n-/// [`ops`] traits. It implements `Default` by returning a zero-length `Duration`.\n+/// [`Duration`]s implement many common traits, including [`Add`], [`Sub`], and other\n+/// [`ops`] traits. It implements [`Default`] by returning a zero-length `Duration`.\n ///\n-/// [`Add`]: ../../std/ops/trait.Add.html\n-/// [`Sub`]: ../../std/ops/trait.Sub.html\n-/// [`ops`]: ../../std/ops/index.html\n+/// [`ops`]: crate::ops\n ///\n /// # Examples\n ///\n@@ -293,7 +291,7 @@ impl Duration {\n     ///            + duration.subsec_nanos() as f64 * 1e-9);\n     /// ```\n     ///\n-    /// [`subsec_nanos`]: #method.subsec_nanos\n+    /// [`subsec_nanos`]: Duration::subsec_nanos\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[rustc_const_stable(feature = \"duration\", since = \"1.32.0\")]\n     #[inline]\n@@ -421,8 +419,6 @@ impl Duration {\n     /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n     /// if overflow occurred.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -457,8 +453,6 @@ impl Duration {\n     /// Checked `Duration` subtraction. Computes `self - other`, returning [`None`]\n     /// if the result would be negative or if overflow occurred.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -494,8 +488,6 @@ impl Duration {\n     /// Checked `Duration` multiplication. Computes `self * other`, returning\n     /// [`None`] if overflow occurred.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -526,8 +518,6 @@ impl Duration {\n     /// Checked `Duration` division. Computes `self / other`, returning [`None`]\n     /// if `other == 0`.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "7d14893c4cc2e45a1e2c908dce780f8582eceb3a", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -50,6 +50,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         all(target_family = \"windows\", target_env = \"gnu\"),\n         target_os = \"cloudabi\",\n+        target_os = \"psp\",\n         target_family = \"unix\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {\n@@ -65,7 +66,6 @@ cfg_if::cfg_if! {\n         // - os=uefi\n         // - nvptx64-nvidia-cuda\n         // - avr-unknown-unknown\n-        // - mipsel-sony-psp\n         #[path = \"dummy.rs\"]\n         mod real_imp;\n     }"}, {"sha": "fc07fa77b85e7660cebdd53a9e24d30cae5c5ff7", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -20,7 +20,7 @@ libc = { version = \"0.2.51\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.32\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n-hashbrown = { version = \"0.6.2\", default-features = false, features = ['rustc-dep-of-std'] }\n+hashbrown = { version = \"0.8.1\", default-features = false, features = ['rustc-dep-of-std'] }\n \n # Dependencies of the `backtrace` crate\n addr2line = { version = \"0.13.0\", optional = true, default-features = false }"}, {"sha": "70f7214e2f1d78d3c5f2e1d3a5c798f43fe5ecf3", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 156, "deletions": 4, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -580,7 +580,7 @@ where\n     #[inline]\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n-        self.base.try_reserve(additional).map_err(map_collection_alloc_err)\n+        self.base.try_reserve(additional).map_err(map_try_reserve_error)\n     }\n \n     /// Shrinks the capacity of the map as much as possible. It will drop\n@@ -872,6 +872,52 @@ where\n     {\n         self.base.retain(f)\n     }\n+\n+    /// Creates a consuming iterator visiting all the keys in arbitrary order.\n+    /// The map cannot be used after calling this.\n+    /// The iterator element type is `K`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_into_keys_values)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// let vec: Vec<&str> = map.into_keys().collect();\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+    pub fn into_keys(self) -> IntoKeys<K, V> {\n+        IntoKeys { inner: self.into_iter() }\n+    }\n+\n+    /// Creates a consuming iterator visiting all the values in arbitrary order.\n+    /// The map cannot be used after calling this.\n+    /// The iterator element type is `V`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_into_keys_values)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// let vec: Vec<i32> = map.into_values().collect();\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+    pub fn into_values(self) -> IntoValues<K, V> {\n+        IntoValues { inner: self.into_iter() }\n+    }\n }\n \n impl<K, V, S> HashMap<K, V, S>\n@@ -1154,6 +1200,28 @@ pub struct ValuesMut<'a, K: 'a, V: 'a> {\n     inner: IterMut<'a, K, V>,\n }\n \n+/// An owning iterator over the keys of a `HashMap`.\n+///\n+/// This `struct` is created by the [`into_keys`] method on [`HashMap`].\n+/// See its documentation for more.\n+///\n+/// [`into_keys`]: HashMap::into_keys\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+pub struct IntoKeys<K, V> {\n+    inner: IntoIter<K, V>,\n+}\n+\n+/// An owning iterator over the values of a `HashMap`.\n+///\n+/// This `struct` is created by the [`into_values`] method on [`HashMap`].\n+/// See its documentation for more.\n+///\n+/// [`into_values`]: HashMap::into_values\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+pub struct IntoValues<K, V> {\n+    inner: IntoIter<K, V>,\n+}\n+\n /// A builder for computing where in a HashMap a key-value pair would be stored.\n ///\n /// See the [`HashMap::raw_entry_mut`] docs for usage examples.\n@@ -1827,6 +1895,66 @@ where\n     }\n }\n \n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> Iterator for IntoKeys<K, V> {\n+    type Item = K;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<K> {\n+        self.inner.next().map(|(k, _)| k)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> ExactSizeIterator for IntoKeys<K, V> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> FusedIterator for IntoKeys<K, V> {}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K: Debug, V: Debug> fmt::Debug for IntoKeys<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.inner.iter().map(|(k, _)| k)).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> Iterator for IntoValues<K, V> {\n+    type Item = V;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<V> {\n+        self.inner.next().map(|(_, v)| v)\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> ExactSizeIterator for IntoValues<K, V> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K, V> FusedIterator for IntoValues<K, V> {}\n+\n+#[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n+impl<K: Debug, V: Debug> fmt::Debug for IntoValues<K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_list().entries(self.inner.iter().map(|(_, v)| v)).finish()\n+    }\n+}\n+\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<'a, K, V> Iterator for Drain<'a, K, V> {\n     type Item = (K, V);\n@@ -2569,10 +2697,10 @@ fn map_entry<'a, K: 'a, V: 'a>(raw: base::RustcEntry<'a, K, V>) -> Entry<'a, K,\n }\n \n #[inline]\n-fn map_collection_alloc_err(err: hashbrown::CollectionAllocErr) -> TryReserveError {\n+fn map_try_reserve_error(err: hashbrown::TryReserveError) -> TryReserveError {\n     match err {\n-        hashbrown::CollectionAllocErr::CapacityOverflow => TryReserveError::CapacityOverflow,\n-        hashbrown::CollectionAllocErr::AllocErr { layout } => {\n+        hashbrown::TryReserveError::CapacityOverflow => TryReserveError::CapacityOverflow,\n+        hashbrown::TryReserveError::AllocError { layout } => {\n             TryReserveError::AllocError { layout, non_exhaustive: () }\n         }\n     }\n@@ -3084,6 +3212,30 @@ mod test_map {\n         assert!(values.contains(&6));\n     }\n \n+    #[test]\n+    fn test_into_keys() {\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let keys: Vec<_> = map.into_keys().collect();\n+\n+        assert_eq!(keys.len(), 3);\n+        assert!(keys.contains(&1));\n+        assert!(keys.contains(&2));\n+        assert!(keys.contains(&3));\n+    }\n+\n+    #[test]\n+    fn test_into_values() {\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let values: Vec<_> = map.into_values().collect();\n+\n+        assert_eq!(values.len(), 3);\n+        assert!(values.contains(&'a'));\n+        assert!(values.contains(&'b'));\n+        assert!(values.contains(&'c'));\n+    }\n+\n     #[test]\n     fn test_find() {\n         let mut m = HashMap::new();"}, {"sha": "ff343625a19ed75932bf944f9e9cd57f394aa1e1", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -943,8 +943,7 @@ mod mod_keyword {}\n /// Capture a [closure]'s environment by value.\n ///\n /// `move` converts any variables captured by reference or mutable reference\n-/// to owned by value variables. The three [`Fn` trait]'s mirror the ways to capture\n-/// variables, when `move` is used, the closures is represented by the `FnOnce` trait.\n+/// to owned by value variables.\n ///\n /// ```rust\n /// let capture = \"hello\";\n@@ -953,6 +952,23 @@ mod mod_keyword {}\n /// };\n /// ```\n ///\n+/// Note: `move` closures may still implement [`Fn`] or [`FnMut`], even though\n+/// they capture variables by `move`. This is because the traits implemented by\n+/// a closure type are determined by *what* the closure does with captured\n+/// values, not *how* it captures them:\n+///\n+/// ```rust\n+/// fn create_fn() -> impl Fn() {\n+///     let text = \"Fn\".to_owned();\n+///\n+///     move || println!(\"This is a: {}\", text)\n+/// }\n+///\n+///     let fn_plain = create_fn();\n+///\n+///     fn_plain();\n+/// ```\n+///\n /// `move` is often used when [threads] are involved.\n ///\n /// ```rust"}, {"sha": "159ab981b237d5a822f42ce646c9d7be625235b0", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -319,15 +319,9 @@ impl Ipv4Addr {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_ipv4\", since = \"1.32.0\")]\n     pub const fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {\n-        // FIXME: should just be u32::from_be_bytes([a, b, c, d]),\n-        // once that method is no longer rustc_const_unstable\n-        Ipv4Addr {\n-            inner: c::in_addr {\n-                s_addr: u32::to_be(\n-                    ((a as u32) << 24) | ((b as u32) << 16) | ((c as u32) << 8) | (d as u32),\n-                ),\n-            },\n-        }\n+        // `s_addr` is stored as BE on all machine and the array is in BE order.\n+        // So the native endian conversion method is used so that it's never swapped.\n+        Ipv4Addr { inner: c::in_addr { s_addr: u32::from_ne_bytes([a, b, c, d]) } }\n     }\n \n     /// An IPv4 address with the address pointing to localhost: 127.0.0.1.\n@@ -967,11 +961,6 @@ impl AsInner<c::in_addr> for Ipv4Addr {\n         &self.inner\n     }\n }\n-impl FromInner<c::in_addr> for Ipv4Addr {\n-    fn from_inner(addr: c::in_addr) -> Ipv4Addr {\n-        Ipv4Addr { inner: addr }\n-    }\n-}\n \n #[stable(feature = \"ip_u32\", since = \"1.1.0\")]\n impl From<Ipv4Addr> for u32 {\n@@ -982,8 +971,8 @@ impl From<Ipv4Addr> for u32 {\n     /// ```\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// let addr = Ipv4Addr::new(13, 12, 11, 10);\n-    /// assert_eq!(0x0d0c0b0au32, u32::from(addr));\n+    /// let addr = Ipv4Addr::new(0xca, 0xfe, 0xba, 0xbe);\n+    /// assert_eq!(0xcafebabe, u32::from(addr));\n     /// ```\n     fn from(ip: Ipv4Addr) -> u32 {\n         let ip = ip.octets();\n@@ -1000,8 +989,8 @@ impl From<u32> for Ipv4Addr {\n     /// ```\n     /// use std::net::Ipv4Addr;\n     ///\n-    /// let addr = Ipv4Addr::from(0x0d0c0b0au32);\n-    /// assert_eq!(Ipv4Addr::new(13, 12, 11, 10), addr);\n+    /// let addr = Ipv4Addr::from(0xcafebabe);\n+    /// assert_eq!(Ipv4Addr::new(0xca, 0xfe, 0xba, 0xbe), addr);\n     /// ```\n     fn from(ip: u32) -> Ipv4Addr {\n         Ipv4Addr::from(ip.to_be_bytes())"}, {"sha": "08d363a9a29649d1359f1de996bb8bcd64bc0661", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 51, "deletions": 8, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -7,6 +7,8 @@\n //! * Executing a panic up to doing the actual implementation\n //! * Shims around \"try\"\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use core::panic::{BoxMeUp, Location, PanicInfo};\n \n use crate::any::Any;\n@@ -322,25 +324,48 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     let mut data = Data { f: ManuallyDrop::new(f) };\n \n     let data_ptr = &mut data as *mut _ as *mut u8;\n-    return if intrinsics::r#try(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {\n-        Ok(ManuallyDrop::into_inner(data.r))\n-    } else {\n-        Err(ManuallyDrop::into_inner(data.p))\n-    };\n+    // SAFETY:\n+    //\n+    // Access to the union's fields: this is `std` and we know that the `r#try`\n+    // intrinsic fills in the `r` or `p` union field based on its return value.\n+    //\n+    // The call to `intrinsics::r#try` is made safe by:\n+    // - `do_call`, the first argument, can be called with the initial `data_ptr`.\n+    // - `do_catch`, the second argument, can be called with the `data_ptr` as well.\n+    // See their safety preconditions for more informations\n+    unsafe {\n+        return if intrinsics::r#try(do_call::<F, R>, data_ptr, do_catch::<F, R>) == 0 {\n+            Ok(ManuallyDrop::into_inner(data.r))\n+        } else {\n+            Err(ManuallyDrop::into_inner(data.p))\n+        };\n+    }\n \n     // We consider unwinding to be rare, so mark this function as cold. However,\n     // do not mark it no-inline -- that decision is best to leave to the\n     // optimizer (in most cases this function is not inlined even as a normal,\n     // non-cold function, though, as of the writing of this comment).\n     #[cold]\n     unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send + 'static> {\n-        let obj = Box::from_raw(__rust_panic_cleanup(payload));\n+        // SAFETY: The whole unsafe block hinges on a correct implementation of\n+        // the panic handler `__rust_panic_cleanup`. As such we can only\n+        // assume it returns the correct thing for `Box::from_raw` to work\n+        // without undefined behavior.\n+        let obj = unsafe { Box::from_raw(__rust_panic_cleanup(payload)) };\n         panic_count::decrease();\n         obj\n     }\n \n+    // SAFETY:\n+    // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`\n+    // Its must contains a valid `f` (type: F) value that can be use to fill\n+    // `data.r`.\n+    //\n+    // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n+    // expects normal function pointers.\n     #[inline]\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n+        // SAFETY: this is the responsibilty of the caller, see above.\n         unsafe {\n             let data = data as *mut Data<F, R>;\n             let data = &mut (*data);\n@@ -352,8 +377,21 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // We *do* want this part of the catch to be inlined: this allows the\n     // compiler to properly track accesses to the Data union and optimize it\n     // away most of the time.\n+    //\n+    // SAFETY:\n+    // data must be non-NUL, correctly aligned, and a pointer to a `Data<F, R>`\n+    // Since this uses `cleanup` it also hinges on a correct implementation of\n+    // `__rustc_panic_cleanup`.\n+    //\n+    // This function cannot be marked as `unsafe` because `intrinsics::r#try`\n+    // expects normal function pointers.\n     #[inline]\n     fn do_catch<F: FnOnce() -> R, R>(data: *mut u8, payload: *mut u8) {\n+        // SAFETY: this is the responsibilty of the caller, see above.\n+        //\n+        // When `__rustc_panic_cleaner` is correctly implemented we can rely\n+        // on `obj` being the correct thing to pass to `data.p` (after wrapping\n+        // in `ManuallyDrop`).\n         unsafe {\n             let data = data as *mut Data<F, R>;\n             let data = &mut (*data);\n@@ -434,7 +472,9 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n \n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n-    rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+    crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n+        rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+    })\n }\n \n /// This is the entry point of panicking for the non-format-string variants of\n@@ -453,7 +493,10 @@ pub fn begin_panic<M: Any + Send>(msg: M) -> ! {\n         intrinsics::abort()\n     }\n \n-    rust_panic_with_hook(&mut PanicPayload::new(msg), None, Location::caller());\n+    let loc = Location::caller();\n+    return crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n+        rust_panic_with_hook(&mut PanicPayload::new(msg), None, loc)\n+    });\n \n     struct PanicPayload<A> {\n         inner: Option<A>,"}, {"sha": "e3d529df7de1643732b64071a1fd5bf527d4ffde", "filename": "library/std/src/path.rs", "status": "modified", "additions": 69, "deletions": 163, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -56,16 +56,8 @@\n //! let path: PathBuf = [\"c:\\\\\", \"windows\", \"system32.dll\"].iter().collect();\n //! ```\n //!\n-//! [`Component`]: ../../std/path/enum.Component.html\n-//! [`components`]: ../../std/path/struct.Path.html#method.components\n-//! [`PathBuf`]: ../../std/path/struct.PathBuf.html\n-//! [`Path`]: ../../std/path/struct.Path.html\n-//! [`push`]: ../../std/path/struct.PathBuf.html#method.push\n-//! [`String`]: ../../std/string/struct.String.html\n-//!\n-//! [`str`]: ../../std/primitive.str.html\n-//! [`OsString`]: ../../std/ffi/struct.OsString.html\n-//! [`OsStr`]: ../../std/ffi/struct.OsStr.html\n+//! [`components`]: Path::components\n+//! [`push`]: PathBuf::push\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -390,12 +382,9 @@ enum State {\n /// # }\n /// ```\n ///\n-/// [`as_os_str`]: #method.as_os_str\n-/// [`Component`]: enum.Component.html\n-/// [`kind`]: #method.kind\n-/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n-/// [`Prefix` variant]: enum.Component.html#variant.Prefix\n-/// [`Prefix`]: enum.Prefix.html\n+/// [`as_os_str`]: PrefixComponent::as_os_str\n+/// [`kind`]: PrefixComponent::kind\n+/// [`Prefix` variant]: Component::Prefix\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Eq, Debug)]\n pub struct PrefixComponent<'a> {\n@@ -411,16 +400,12 @@ impl<'a> PrefixComponent<'a> {\n     ///\n     /// See [`Prefix`]'s documentation for more information on the different\n     /// kinds of prefixes.\n-    ///\n-    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> Prefix<'a> {\n         self.parsed\n     }\n \n     /// Returns the raw [`OsStr`] slice for this prefix.\n-    ///\n-    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &'a OsStr {\n         self.raw\n@@ -477,10 +462,6 @@ impl Hash for PrefixComponent<'_> {\n ///     Component::Normal(\"bar.txt\".as_ref()),\n /// ]);\n /// ```\n-///\n-/// [`Components`]: struct.Components.html\n-/// [`Path`]: struct.Path.html\n-/// [`Path::components`]: struct.Path.html#method.components\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Component<'a> {\n@@ -490,8 +471,6 @@ pub enum Component<'a> {\n     /// for more.\n     ///\n     /// Does not occur on Unix.\n-    ///\n-    /// [`Prefix`]: enum.Prefix.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Prefix(#[stable(feature = \"rust1\", since = \"1.0.0\")] PrefixComponent<'a>),\n \n@@ -529,8 +508,6 @@ impl<'a> Component<'a> {\n     /// let components: Vec<_> = path.components().map(|comp| comp.as_os_str()).collect();\n     /// assert_eq!(&components, &[\".\", \"tmp\", \"foo\", \"bar.txt\"]);\n     /// ```\n-    ///\n-    /// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(self) -> &'a OsStr {\n         match self {\n@@ -574,9 +551,7 @@ impl AsRef<Path> for Component<'_> {\n /// }\n /// ```\n ///\n-/// [`Component`]: enum.Component.html\n-/// [`components`]: struct.Path.html#method.components\n-/// [`Path`]: struct.Path.html\n+/// [`components`]: Path::components\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -602,10 +577,7 @@ pub struct Components<'a> {\n /// This `struct` is created by the [`iter`] method on [`Path`].\n /// See its documentation for more.\n ///\n-/// [`Component`]: enum.Component.html\n-/// [`iter`]: struct.Path.html#method.iter\n-/// [`OsStr`]: ../../std/ffi/struct.OsStr.html\n-/// [`Path`]: struct.Path.html\n+/// [`iter`]: Path::iter\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n@@ -1002,8 +974,7 @@ impl cmp::Ord for Components<'_> {\n /// }\n /// ```\n ///\n-/// [`ancestors`]: struct.Path.html#method.ancestors\n-/// [`Path`]: struct.Path.html\n+/// [`ancestors`]: Path::ancestors\n #[derive(Copy, Clone, Debug)]\n #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n pub struct Ancestors<'a> {\n@@ -1034,11 +1005,8 @@ impl FusedIterator for Ancestors<'_> {}\n /// the path in place. It also implements [`Deref`] to [`Path`], meaning that\n /// all methods on [`Path`] slices are available on `PathBuf` values as well.\n ///\n-/// [`String`]: ../string/struct.String.html\n-/// [`Path`]: struct.Path.html\n-/// [`push`]: struct.PathBuf.html#method.push\n-/// [`set_extension`]: struct.PathBuf.html#method.set_extension\n-/// [`Deref`]: ../ops/trait.Deref.html\n+/// [`push`]: PathBuf::push\n+/// [`set_extension`]: PathBuf::set_extension\n ///\n /// More details about the overall approach can be found in\n /// the [module documentation](index.html).\n@@ -1127,17 +1095,14 @@ impl PathBuf {\n     /// assert_eq!(capacity, path.capacity());\n     /// ```\n     ///\n-    /// [`with_capacity`]: ../ffi/struct.OsString.html#method.with_capacity\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`with_capacity`]: OsString::with_capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn with_capacity(capacity: usize) -> PathBuf {\n         PathBuf { inner: OsString::with_capacity(capacity) }\n     }\n \n     /// Coerces to a [`Path`] slice.\n     ///\n-    /// [`Path`]: struct.Path.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1224,18 +1189,17 @@ impl PathBuf {\n     /// Returns `false` and does nothing if [`self.parent`] is [`None`].\n     /// Otherwise, returns `true`.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`self.parent`]: struct.PathBuf.html#method.parent\n+    /// [`self.parent`]: Path::parent\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::path::{Path, PathBuf};\n     ///\n-    /// let mut p = PathBuf::from(\"/test/test.rs\");\n+    /// let mut p = PathBuf::from(\"/spirited/away.rs\");\n     ///\n     /// p.pop();\n-    /// assert_eq!(Path::new(\"/test\"), p);\n+    /// assert_eq!(Path::new(\"/spirited\"), p);\n     /// p.pop();\n     /// assert_eq!(Path::new(\"/\"), p);\n     /// ```\n@@ -1259,9 +1223,8 @@ impl PathBuf {\n     /// `file_name`. The new path will be a sibling of the original path.\n     /// (That is, it will have the same parent.)\n     ///\n-    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`pop`]: struct.PathBuf.html#method.pop\n+    /// [`self.file_name`]: Path::file_name\n+    /// [`pop`]: PathBuf::pop\n     ///\n     /// # Examples\n     ///\n@@ -1297,9 +1260,8 @@ impl PathBuf {\n     /// If [`self.extension`] is [`None`], the extension is added; otherwise\n     /// it is replaced.\n     ///\n-    /// [`self.file_name`]: struct.PathBuf.html#method.file_name\n-    /// [`self.extension`]: struct.PathBuf.html#method.extension\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`self.file_name`]: Path::file_name\n+    /// [`self.extension`]: Path::extension\n     ///\n     /// # Examples\n     ///\n@@ -1344,8 +1306,6 @@ impl PathBuf {\n \n     /// Consumes the `PathBuf`, yielding its internal [`OsString`] storage.\n     ///\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1360,9 +1320,6 @@ impl PathBuf {\n     }\n \n     /// Converts this `PathBuf` into a [boxed][`Box`] [`Path`].\n-    ///\n-    /// [`Box`]: ../../std/boxed/struct.Box.html\n-    /// [`Path`]: struct.Path.html\n     #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n     pub fn into_boxed_path(self) -> Box<Path> {\n         let rw = Box::into_raw(self.inner.into_boxed_os_str()) as *mut Path;\n@@ -1371,53 +1328,47 @@ impl PathBuf {\n \n     /// Invokes [`capacity`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`capacity`]: ../ffi/struct.OsString.html#method.capacity\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`capacity`]: OsString::capacity\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn capacity(&self) -> usize {\n         self.inner.capacity()\n     }\n \n     /// Invokes [`clear`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`clear`]: ../ffi/struct.OsString.html#method.clear\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`clear`]: OsString::clear\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn clear(&mut self) {\n         self.inner.clear()\n     }\n \n     /// Invokes [`reserve`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`reserve`]: ../ffi/struct.OsString.html#method.reserve\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`reserve`]: OsString::reserve\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n         self.inner.reserve(additional)\n     }\n \n     /// Invokes [`reserve_exact`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`reserve_exact`]: ../ffi/struct.OsString.html#method.reserve_exact\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`reserve_exact`]: OsString::reserve_exact\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn reserve_exact(&mut self, additional: usize) {\n         self.inner.reserve_exact(additional)\n     }\n \n     /// Invokes [`shrink_to_fit`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`shrink_to_fit`]: ../ffi/struct.OsString.html#method.shrink_to_fit\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`shrink_to_fit`]: OsString::shrink_to_fit\n     #[stable(feature = \"path_buf_capacity\", since = \"1.44.0\")]\n     pub fn shrink_to_fit(&mut self) {\n         self.inner.shrink_to_fit()\n     }\n \n     /// Invokes [`shrink_to`] on the underlying instance of [`OsString`].\n     ///\n-    /// [`shrink_to`]: ../ffi/struct.OsString.html#method.shrink_to\n-    /// [`OsString`]: ../ffi/struct.OsString.html\n+    /// [`shrink_to`]: OsString::shrink_to\n     #[unstable(feature = \"shrink_to\", issue = \"56431\")]\n     pub fn shrink_to(&mut self, min_capacity: usize) {\n         self.inner.shrink_to(min_capacity)\n@@ -1703,10 +1654,6 @@ impl AsRef<OsStr> for PathBuf {\n /// pointer like `&` or [`Box`]. For an owned version of this type,\n /// see [`PathBuf`].\n ///\n-/// [`str`]: ../primitive.str.html\n-/// [`Box`]: ../boxed/struct.Box.html\n-/// [`PathBuf`]: struct.PathBuf.html\n-///\n /// More details about the overall approach can be found in\n /// the [module documentation](index.html).\n ///\n@@ -1745,8 +1692,7 @@ pub struct Path {\n /// This `struct` is created by the [`strip_prefix`] method on [`Path`].\n /// See its documentation for more.\n ///\n-/// [`strip_prefix`]: struct.Path.html#method.strip_prefix\n-/// [`Path`]: struct.Path.html\n+/// [`strip_prefix`]: Path::strip_prefix\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n pub struct StripPrefixError(());\n@@ -1791,8 +1737,6 @@ impl Path {\n \n     /// Yields the underlying [`OsStr`] slice.\n     ///\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1812,7 +1756,7 @@ impl Path {\n     /// Note that validation is performed because non-UTF-8 strings are\n     /// perfectly valid for some OS.\n     ///\n-    /// [`&str`]: ../primitive.str.html\n+    /// [`&str`]: str\n     ///\n     /// # Examples\n     ///\n@@ -1832,8 +1776,8 @@ impl Path {\n     /// Any non-Unicode sequences are replaced with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD].\n     ///\n-    /// [`Cow<str>`]: ../borrow/enum.Cow.html\n-    /// [U+FFFD]: ../char/constant.REPLACEMENT_CHARACTER.html\n+    /// [`Cow<str>`]: Cow\n+    /// [U+FFFD]: super::char::REPLACEMENT_CHARACTER\n     ///\n     /// # Examples\n     ///\n@@ -1855,8 +1799,6 @@ impl Path {\n \n     /// Converts a `Path` to an owned [`PathBuf`].\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1888,7 +1830,7 @@ impl Path {\n     /// assert!(!Path::new(\"foo.txt\").is_absolute());\n     /// ```\n     ///\n-    /// [`has_root`]: #method.has_root\n+    /// [`has_root`]: Path::has_root\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n@@ -1912,7 +1854,7 @@ impl Path {\n     /// assert!(Path::new(\"foo.txt\").is_relative());\n     /// ```\n     ///\n-    /// [`is_absolute`]: #method.is_absolute\n+    /// [`is_absolute`]: Path::is_absolute\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1947,8 +1889,6 @@ impl Path {\n     ///\n     /// Returns [`None`] if the path terminates in a root or prefix.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1992,10 +1932,16 @@ impl Path {\n     /// assert_eq!(ancestors.next(), Some(Path::new(\"/foo\")));\n     /// assert_eq!(ancestors.next(), Some(Path::new(\"/\")));\n     /// assert_eq!(ancestors.next(), None);\n+    ///\n+    /// let mut ancestors = Path::new(\"../foo/bar\").ancestors();\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"../foo/bar\")));\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"../foo\")));\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"..\")));\n+    /// assert_eq!(ancestors.next(), Some(Path::new(\"\")));\n+    /// assert_eq!(ancestors.next(), None);\n     /// ```\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`parent`]: struct.Path.html#method.parent\n+    /// [`parent`]: Path::parent\n     #[stable(feature = \"path_ancestors\", since = \"1.28.0\")]\n     pub fn ancestors(&self) -> Ancestors<'_> {\n         Ancestors { next: Some(&self) }\n@@ -2008,8 +1954,6 @@ impl Path {\n     ///\n     /// Returns [`None`] if the path terminates in `..`.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2038,8 +1982,7 @@ impl Path {\n     /// If `base` is not a prefix of `self` (i.e., [`starts_with`]\n     /// returns `false`), returns [`Err`].\n     ///\n-    /// [`starts_with`]: #method.starts_with\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`starts_with`]: Path::starts_with\n     ///\n     /// # Examples\n     ///\n@@ -2053,8 +1996,9 @@ impl Path {\n     /// assert_eq!(path.strip_prefix(\"/test/\"), Ok(Path::new(\"haha/foo.txt\")));\n     /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt\"), Ok(Path::new(\"\")));\n     /// assert_eq!(path.strip_prefix(\"/test/haha/foo.txt/\"), Ok(Path::new(\"\")));\n-    /// assert_eq!(path.strip_prefix(\"test\").is_ok(), false);\n-    /// assert_eq!(path.strip_prefix(\"/haha\").is_ok(), false);\n+    ///\n+    /// assert!(path.strip_prefix(\"test\").is_err());\n+    /// assert!(path.strip_prefix(\"/haha\").is_err());\n     ///\n     /// let prefix = PathBuf::from(\"/test/\");\n     /// assert_eq!(path.strip_prefix(prefix), Ok(Path::new(\"haha/foo.txt\")));\n@@ -2087,9 +2031,13 @@ impl Path {\n     /// assert!(path.starts_with(\"/etc\"));\n     /// assert!(path.starts_with(\"/etc/\"));\n     /// assert!(path.starts_with(\"/etc/passwd\"));\n-    /// assert!(path.starts_with(\"/etc/passwd/\"));\n+    /// assert!(path.starts_with(\"/etc/passwd/\")); // extra slash is okay\n+    /// assert!(path.starts_with(\"/etc/passwd///\")); // multiple extra slashes are okay\n     ///\n     /// assert!(!path.starts_with(\"/e\"));\n+    /// assert!(!path.starts_with(\"/etc/passwd.txt\"));\n+    ///\n+    /// assert!(!Path::new(\"/etc/foo.rs\").starts_with(\"/etc/foo\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n@@ -2124,7 +2072,7 @@ impl Path {\n \n     /// Extracts the stem (non-extension) portion of [`self.file_name`].\n     ///\n-    /// [`self.file_name`]: struct.Path.html#method.file_name\n+    /// [`self.file_name`]: Path::file_name\n     ///\n     /// The stem is:\n     ///\n@@ -2133,16 +2081,13 @@ impl Path {\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::path::Path;\n     ///\n-    /// let path = Path::new(\"foo.rs\");\n-    ///\n-    /// assert_eq!(\"foo\", path.file_stem().unwrap());\n+    /// assert_eq!(\"foo\", Path::new(\"foo.rs\").file_stem().unwrap());\n+    /// assert_eq!(\"foo.tar\", Path::new(\"foo.tar.gz\").file_stem().unwrap());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_stem(&self) -> Option<&OsStr> {\n@@ -2158,17 +2103,15 @@ impl Path {\n     /// * [`None`], if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n     ///\n-    /// [`self.file_name`]: struct.Path.html#method.file_name\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`self.file_name`]: Path::file_name\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::path::Path;\n     ///\n-    /// let path = Path::new(\"foo.rs\");\n-    ///\n-    /// assert_eq!(\"rs\", path.extension().unwrap());\n+    /// assert_eq!(\"rs\", Path::new(\"foo.rs\").extension().unwrap());\n+    /// assert_eq!(\"gz\", Path::new(\"foo.tar.gz\").extension().unwrap());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn extension(&self) -> Option<&OsStr> {\n@@ -2179,9 +2122,6 @@ impl Path {\n     ///\n     /// See [`PathBuf::push`] for more details on what it means to adjoin a path.\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    /// [`PathBuf::push`]: struct.PathBuf.html#method.push\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2205,9 +2145,6 @@ impl Path {\n     ///\n     /// See [`PathBuf::set_file_name`] for more details.\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    /// [`PathBuf::set_file_name`]: struct.PathBuf.html#method.set_file_name\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2234,9 +2171,6 @@ impl Path {\n     ///\n     /// See [`PathBuf::set_extension`] for more details.\n     ///\n-    /// [`PathBuf`]: struct.PathBuf.html\n-    /// [`PathBuf::set_extension`]: struct.PathBuf.html#method.set_extension\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2247,6 +2181,8 @@ impl Path {\n     ///\n     /// let path = Path::new(\"foo.tar.gz\");\n     /// assert_eq!(path.with_extension(\"\"), PathBuf::from(\"foo.tar\"));\n+    /// assert_eq!(path.with_extension(\"xz\"), PathBuf::from(\"foo.tar.xz\"));\n+    /// assert_eq!(path.with_extension(\"\").with_extension(\"txt\"), PathBuf::from(\"foo.txt\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n@@ -2291,8 +2227,7 @@ impl Path {\n     /// assert_eq!(components.next(), None)\n     /// ```\n     ///\n-    /// [`Component`]: enum.Component.html\n-    /// [`CurDir`]: enum.Component.html#variant.CurDir\n+    /// [`CurDir`]: Component::CurDir\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components<'_> {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -2312,8 +2247,7 @@ impl Path {\n     /// For more information about the particulars of how the path is separated\n     /// into components, see [`components`].\n     ///\n-    /// [`components`]: #method.components\n-    /// [`OsStr`]: ../ffi/struct.OsStr.html\n+    /// [`components`]: Path::components\n     ///\n     /// # Examples\n     ///\n@@ -2335,7 +2269,7 @@ impl Path {\n     /// Returns an object that implements [`Display`] for safely printing paths\n     /// that may contain non-Unicode data.\n     ///\n-    /// [`Display`]: ../fmt/trait.Display.html\n+    /// [`Display`]: fmt::Display\n     ///\n     /// # Examples\n     ///\n@@ -2358,8 +2292,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::metadata`].\n     ///\n-    /// [`fs::metadata`]: ../fs/fn.metadata.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2378,8 +2310,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::symlink_metadata`].\n     ///\n-    /// [`fs::symlink_metadata`]: ../fs/fn.symlink_metadata.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2399,8 +2329,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::canonicalize`].\n     ///\n-    /// [`fs::canonicalize`]: ../fs/fn.canonicalize.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2418,8 +2346,6 @@ impl Path {\n     ///\n     /// This is an alias to [`fs::read_link`].\n     ///\n-    /// [`fs::read_link`]: ../fs/fn.read_link.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2435,15 +2361,11 @@ impl Path {\n \n     /// Returns an iterator over the entries within a directory.\n     ///\n-    /// The iterator will yield instances of [`io::Result`]`<`[`DirEntry`]`>`. New\n+    /// The iterator will yield instances of [`io::Result`]`<`[`fs::DirEntry`]`>`. New\n     /// errors may be encountered after an iterator is initially constructed.\n     ///\n     /// This is an alias to [`fs::read_dir`].\n     ///\n-    /// [`io::Result`]: ../io/type.Result.html\n-    /// [`DirEntry`]: ../fs/struct.DirEntry.html\n-    /// [`fs::read_dir`]: ../fs/fn.read_dir.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -2473,15 +2395,13 @@ impl Path {\n     ///\n     /// ```no_run\n     /// use std::path::Path;\n-    /// assert_eq!(Path::new(\"does_not_exist.txt\").exists(), false);\n+    /// assert!(!Path::new(\"does_not_exist.txt\").exists());\n     /// ```\n     ///\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [fs::metadata].\n-    ///\n-    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n+    /// check errors, call [`fs::metadata`].\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn exists(&self) -> bool {\n         fs::metadata(self).is_ok()\n@@ -2506,20 +2426,14 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [`fs::metadata`] and handle its Result. Then call\n-    /// [`fs::Metadata::is_file`] if it was Ok.\n+    /// check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n+    /// [`fs::Metadata::is_file`] if it was [`Ok`].\n     ///\n     /// When the goal is simply to read from (or write to) the source, the most\n     /// reliable way to test the source can be read (or written to) is to open\n     /// it. Only using `is_file` can break workflows like `diff <( prog_a )` on\n-    /// a Unix-like system for example. See [`File::open`] or\n-    /// [`OpenOptions::open`] for more information.\n-    ///\n-    /// [`fs::metadata`]: ../../std/fs/fn.metadata.html\n-    /// [`fs::Metadata`]: ../../std/fs/struct.Metadata.html\n-    /// [`fs::Metadata::is_file`]: ../../std/fs/struct.Metadata.html#method.is_file\n-    /// [`File::open`]: ../../std/fs/struct.File.html#method.open\n-    /// [`OpenOptions::open`]: ../../std/fs/struct.OpenOptions.html#method.open\n+    /// a Unix-like system for example. See [`fs::File::open`] or\n+    /// [`fs::OpenOptions::open`] for more information.\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_file(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n@@ -2544,21 +2458,15 @@ impl Path {\n     /// # See Also\n     ///\n     /// This is a convenience function that coerces errors to false. If you want to\n-    /// check errors, call [fs::metadata] and handle its Result. Then call\n-    /// [fs::Metadata::is_dir] if it was Ok.\n-    ///\n-    /// [fs::metadata]: ../../std/fs/fn.metadata.html\n-    /// [fs::Metadata::is_dir]: ../../std/fs/struct.Metadata.html#method.is_dir\n+    /// check errors, call [`fs::metadata`] and handle its [`Result`]. Then call\n+    /// [`fs::Metadata::is_dir`] if it was [`Ok`].\n     #[stable(feature = \"path_ext\", since = \"1.5.0\")]\n     pub fn is_dir(&self) -> bool {\n         fs::metadata(self).map(|m| m.is_dir()).unwrap_or(false)\n     }\n \n     /// Converts a [`Box<Path>`][`Box`] into a [`PathBuf`] without copying or\n     /// allocating.\n-    ///\n-    /// [`Box`]: ../../std/boxed/struct.Box.html\n-    /// [`PathBuf`]: struct.PathBuf.html\n     #[stable(feature = \"into_boxed_path\", since = \"1.20.0\")]\n     pub fn into_path_buf(self: Box<Path>) -> PathBuf {\n         let rw = Box::into_raw(self) as *mut OsStr;\n@@ -2597,10 +2505,8 @@ impl fmt::Debug for Path {\n /// println!(\"{}\", path.display());\n /// ```\n ///\n-/// [`Display`]: ../../std/fmt/trait.Display.html\n-/// [`format!`]: ../../std/macro.format.html\n-/// [`Path`]: struct.Path.html\n-/// [`Path::display`]: struct.Path.html#method.display\n+/// [`Display`]: fmt::Display\n+/// [`format!`]: crate::format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Display<'a> {\n     path: &'a Path,"}, {"sha": "45af9f68a0f6b149c365f04b6ce6f4cea56d61f2", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -48,9 +48,7 @@ fn lang_start_internal(\n         sys::args::init(argc, argv);\n \n         // Let's run some code!\n-        let exit_code = panic::catch_unwind(|| {\n-            sys_common::backtrace::__rust_begin_short_backtrace(move || main())\n-        });\n+        let exit_code = panic::catch_unwind(main);\n \n         sys_common::cleanup();\n         exit_code.unwrap_or(101) as isize\n@@ -64,5 +62,9 @@ fn lang_start<T: crate::process::Termination + 'static>(\n     argc: isize,\n     argv: *const *const u8,\n ) -> isize {\n-    lang_start_internal(&move || main().report(), argc, argv)\n+    lang_start_internal(\n+        &move || crate::sys_common::backtrace::__rust_begin_short_backtrace(main).report(),\n+        argc,\n+        argv,\n+    )\n }"}, {"sha": "8eaf07e52d69a228c945b4bb537993866849c3a2", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -106,7 +106,7 @@ pub unsafe extern \"C\" fn runtime_entry(\n     argv: *const *const c_char,\n     env: *const *const c_char,\n ) -> ! {\n-    use crate::sys::hermit::fast_thread_local::run_dtors;\n+    use crate::sys::hermit::thread_local_dtor::run_dtors;\n     extern \"C\" {\n         fn main(argc: isize, argv: *const *const c_char) -> i32;\n     }"}, {"sha": "7bd71e120de40a02f7cbbc96a3ccc64b8e37cf8f", "filename": "library/std/src/sys/hermit/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fthread.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,7 +4,7 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::sys::hermit::abi;\n-use crate::sys::hermit::fast_thread_local::run_dtors;\n+use crate::sys::hermit::thread_local_dtor::run_dtors;\n use crate::time::Duration;\n \n pub type Tid = abi::Tid;"}, {"sha": "ba169b251b0bc7ad768593f8fef355ce8e800d39", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -283,12 +283,12 @@ impl Drop for FileDesc {\n #[cfg(test)]\n mod tests {\n     use super::{FileDesc, IoSlice};\n+    use core::mem::ManuallyDrop;\n \n     #[test]\n     fn limit_vector_count() {\n-        let stdout = FileDesc { fd: 1 };\n+        let stdout = ManuallyDrop::new(FileDesc { fd: 1 });\n         let bufs = (0..1500).map(|_| IoSlice::new(&[])).collect::<Vec<_>>();\n-\n         assert!(stdout.write_vectored(&bufs).is_ok());\n     }\n }"}, {"sha": "982ec912c44b710eebdb7d78559e9ea314e6f95b", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -99,43 +99,28 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n \n pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n     let ptr = haystack.as_ptr();\n-    let mut len = haystack.len();\n     let mut start = &haystack[..];\n \n     // For performance reasons unfold the loop eight times.\n-    while len >= 8 {\n-        if start[0] == needle {\n-            return Some((start.as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[1] == needle {\n-            return Some((start[1..].as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[2] == needle {\n-            return Some((start[2..].as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[3] == needle {\n-            return Some((start[3..].as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[4] == needle {\n-            return Some((start[4..].as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[5] == needle {\n-            return Some((start[5..].as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[6] == needle {\n-            return Some((start[6..].as_ptr() as usize - ptr as usize) / 2);\n-        }\n-        if start[7] == needle {\n-            return Some((start[7..].as_ptr() as usize - ptr as usize) / 2);\n+    while start.len() >= 8 {\n+        macro_rules! if_return {\n+            ($($n:literal,)+) => {\n+                $(\n+                    if start[$n] == needle {\n+                        return Some((&start[$n] as *const u16 as usize - ptr as usize) / 2);\n+                    }\n+                )+\n+            }\n         }\n \n+        if_return!(0, 1, 2, 3, 4, 5, 6, 7,);\n+\n         start = &start[8..];\n-        len -= 8;\n     }\n \n-    for (i, c) in start.iter().enumerate() {\n+    for c in start {\n         if *c == needle {\n-            return Some((start.as_ptr() as usize - ptr as usize) / 2 + i);\n+            return Some((c as *const u16 as usize - ptr as usize) / 2);\n         }\n     }\n     None"}, {"sha": "1c5fbf7d70102fb30d9a3073a34c1082a771b6fd", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -74,6 +74,8 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n     bt_fmt.add_context()?;\n     let mut idx = 0;\n     let mut res = Ok(());\n+    // Start immediately if we're not using a short backtrace.\n+    let mut start = print_fmt != PrintFmt::Short;\n     backtrace_rs::trace_unsynchronized(|frame| {\n         if print_fmt == PrintFmt::Short && idx > MAX_NB_FRAMES {\n             return false;\n@@ -89,16 +91,24 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n                         stop = true;\n                         return;\n                     }\n+                    if sym.contains(\"__rust_end_short_backtrace\") {\n+                        start = true;\n+                        return;\n+                    }\n                 }\n             }\n \n-            res = bt_fmt.frame().symbol(frame, symbol);\n+            if start {\n+                res = bt_fmt.frame().symbol(frame, symbol);\n+            }\n         });\n         if stop {\n             return false;\n         }\n         if !hit {\n-            res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n+            if start {\n+                res = bt_fmt.frame().print_raw(frame.ip(), None, None, None);\n+            }\n         }\n \n         idx += 1;\n@@ -123,10 +133,29 @@ unsafe fn _print_fmt(fmt: &mut fmt::Formatter<'_>, print_fmt: PrintFmt) -> fmt::\n pub fn __rust_begin_short_backtrace<F, T>(f: F) -> T\n where\n     F: FnOnce() -> T,\n-    F: Send,\n-    T: Send,\n {\n-    f()\n+    let result = f();\n+\n+    // prevent this frame from being tail-call optimised away\n+    crate::hint::black_box(());\n+\n+    result\n+}\n+\n+/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`. Note that\n+/// this is only inline(never) when backtraces in libstd are enabled, otherwise\n+/// it's fine to optimize away.\n+#[cfg_attr(feature = \"backtrace\", inline(never))]\n+pub fn __rust_end_short_backtrace<F, T>(f: F) -> T\n+where\n+    F: FnOnce() -> T,\n+{\n+    let result = f();\n+\n+    // prevent this frame from being tail-call optimised away\n+    crate::hint::black_box(());\n+\n+    result\n }\n \n pub enum RustBacktrace {"}, {"sha": "66508f06b2884ccb4de9147d890d3f08fa35e8cb", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -172,7 +172,11 @@ macro_rules! __thread_local_inner {\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n \n-                __KEY.get(__init)\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe { __KEY.get(__init) }\n             }\n \n             unsafe {"}, {"sha": "7ca27bf0dc15e90eb0852ef98a0c62bab1e2ba5e", "filename": "library/test/src/helpers/concurrency.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fhelpers%2Fconcurrency.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,7 +4,7 @@ use std::env;\n \n #[allow(deprecated)]\n pub fn get_concurrency() -> usize {\n-    return match env::var(\"RUST_TEST_THREADS\") {\n+    match env::var(\"RUST_TEST_THREADS\") {\n         Ok(s) => {\n             let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n@@ -13,7 +13,7 @@ pub fn get_concurrency() -> usize {\n             }\n         }\n         Err(..) => num_cpus(),\n-    };\n+    }\n }\n \n cfg_if::cfg_if! {"}, {"sha": "6bd708ef48798832d5d7ccacc9e1676d623b6235", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -514,7 +514,10 @@ pub fn run_test(\n /// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n #[inline(never)]\n fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n-    f()\n+    f();\n+\n+    // prevent this frame from being tail-call optimised away\n+    black_box(());\n }\n \n fn run_test_in_process("}, {"sha": "20a2ca984057e94ff4e9045abcce3d3297b83efa", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -19,6 +19,7 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         unix,\n         windows,\n+        target_os = \"psp\",\n         target_os = \"cloudabi\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {\n@@ -32,7 +33,6 @@ cfg_if::cfg_if! {\n         // - os=uefi\n         // - os=cuda\n         // - nvptx64-nvidia-cuda\n-        // - mipsel-sony-psp\n         // - Any new targets not listed above.\n     }\n }"}, {"sha": "67f99ec4e40b923ca315e0d630f63ab22edd6ee5", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -352,8 +352,13 @@ def __init__(self, valobj, show_values=True):\n         ctrl = table[\"ctrl\"][\"pointer\"]\n \n         self.size = int(table[\"items\"])\n-        self.data_ptr = table[\"data\"][\"pointer\"]\n-        self.pair_type = self.data_ptr.dereference().type\n+        self.pair_type = table.type.template_argument(0)\n+\n+        self.new_layout = not table.type.has_key(\"data\")\n+        if self.new_layout:\n+            self.data_ptr = ctrl.cast(self.pair_type.pointer())\n+        else:\n+            self.data_ptr = table[\"data\"][\"pointer\"]\n \n         self.valid_indices = []\n         for idx in range(capacity):\n@@ -374,6 +379,8 @@ def children(self):\n \n         for index in range(self.size):\n             idx = self.valid_indices[index]\n+            if self.new_layout:\n+                idx = -(idx + 1)\n             element = (pairs_start + idx).dereference()\n             if self.show_values:\n                 yield \"key{}\".format(index), element[ZERO_FIELD]"}, {"sha": "19da75c35b456b4e12efdf826c5d61df852a35c2", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -514,6 +514,8 @@ def get_child_at_index(self, index):\n         # type: (int) -> SBValue\n         pairs_start = self.data_ptr.GetValueAsUnsigned()\n         idx = self.valid_indices[index]\n+        if self.new_layout:\n+            idx = -(idx + 1)\n         address = pairs_start + idx * self.pair_type_size\n         element = self.data_ptr.CreateValueFromAddress(\"[%s]\" % index, address, self.pair_type)\n         if self.show_values:\n@@ -529,10 +531,15 @@ def update(self):\n         ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n \n         self.size = table.GetChildMemberWithName(\"items\").GetValueAsUnsigned()\n-        self.data_ptr = table.GetChildMemberWithName(\"data\").GetChildAtIndex(0)\n-        self.pair_type = self.data_ptr.Dereference().GetType()\n+        self.pair_type = table.type.template_args[0]\n         self.pair_type_size = self.pair_type.GetByteSize()\n \n+        self.new_layout = not table.GetChildMemberWithName(\"data\").IsValid()\n+        if self.new_layout:\n+            self.data_ptr = ctrl.Cast(self.pair_type.GetPointerType())\n+        else:\n+            self.data_ptr = table.GetChildMemberWithName(\"data\").GetChildAtIndex(0)\n+\n         u8_type = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar)\n         u8_type_size = self.valobj.GetTarget().GetBasicType(eBasicTypeUnsignedChar).GetByteSize()\n "}, {"sha": "4e81173d3d0b875c47626b6269173379f1606b04", "filename": "src/etc/natvis/libstd.natvis", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Fetc%2Fnatvis%2Flibstd.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Fetc%2Fnatvis%2Flibstd.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibstd.natvis?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -30,6 +30,7 @@\n     <Expand>\n       <Item Name=\"[size]\">base.table.items</Item>\n       <Item Name=\"[capacity]\">base.table.items + base.table.growth_left</Item>\n+      <Item Name=\"[state]\">base.hash_builder</Item>\n \n       <CustomListItems>\n         <Variable Name=\"i\" InitialValue=\"0\" />\n@@ -40,7 +41,7 @@\n           <If Condition=\"(base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n             <!-- Bucket is populated -->\n             <Exec>n--</Exec>\n-            <Item Name=\"{base.table.data.pointer[i].__0}\">base.table.data.pointer[i].__1</Item>\n+            <Item Name=\"{static_cast&lt;tuple&lt;$T1, $T2&gt;*&gt;(base.table.ctrl.pointer)[-(i + 1)].__0}\">static_cast&lt;tuple&lt;$T1, $T2&gt;*&gt;(base.table.ctrl.pointer)[-(i + 1)].__1</Item>\n           </If>\n           <Exec>i++</Exec>\n         </Loop>\n@@ -53,6 +54,7 @@\n     <Expand>\n       <Item Name=\"[size]\">map.base.table.items</Item>\n       <Item Name=\"[capacity]\">map.base.table.items + map.base.table.growth_left</Item>\n+      <Item Name=\"[state]\">map.base.hash_builder</Item>\n \n       <CustomListItems>\n         <Variable Name=\"i\" InitialValue=\"0\" />\n@@ -63,36 +65,7 @@\n           <If Condition=\"(map.base.table.ctrl.pointer[i] &amp; 0x80) == 0\">\n             <!-- Bucket is populated -->\n             <Exec>n--</Exec>\n-            <Item>map.base.table.data.pointer[i].__0</Item>\n-          </If>\n-          <Exec>i++</Exec>\n-        </Loop>\n-      </CustomListItems>\n-    </Expand>\n-  </Type>\n-\n-  <Type Name=\"hashbrown::raw::RawTable&lt;*&gt;\">\n-    <!-- RawTable has a nice and simple layout.\n-      items                     Number of *populated* values in the RawTable (less than the size of ctrl.pointer / data.pointer)\n-      growth_left               Remaining capacity before growth\n-      ctrl.pointer[i] & 0x80    Indicates the bucket is empty / should be skipped / doesn't count towards items.\n-      data.pointer[i]           The (K,V) tuple, if not empty.\n-    -->\n-    <DisplayString>{{ size={items} }}</DisplayString>\n-    <Expand>\n-      <Item Name=\"[size]\">items</Item>\n-      <Item Name=\"[capacity]\">items + growth_left</Item>\n-\n-      <CustomListItems>\n-        <Variable Name=\"i\" InitialValue=\"0\" />\n-        <Variable Name=\"n\" InitialValue=\"items\" />\n-        <Size>items</Size>\n-        <Loop>\n-          <Break Condition=\"n == 0\" />\n-          <If Condition=\"(ctrl.pointer[i] &amp; 0x80) == 0\">\n-            <!-- Bucket is populated -->\n-            <Exec>n--</Exec>\n-            <Item>data.pointer[i]</Item>\n+            <Item>static_cast&lt;$T1*&gt;(map.base.table.ctrl.pointer)[-(i + 1)]</Item>\n           </If>\n           <Exec>i++</Exec>\n         </Loop>"}, {"sha": "ab0ab7244dbe4818adda88a98852d4105f88ab17", "filename": "src/librustc_ast/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FCargo.toml?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -12,7 +12,6 @@ doctest = false\n [dependencies]\n rustc_serialize = { path = \"../librustc_serialize\" }\n log = { package = \"tracing\", version = \"0.1\" }\n-scoped-tls = \"1.0\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }"}, {"sha": "83a9de84ed8414f75bc9c56bae4d0be6a0facc7f", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -23,7 +23,7 @@ pub use GenericArgs::*;\n pub use UnsafeSource::*;\n \n use crate::ptr::P;\n-use crate::token::{self, DelimToken};\n+use crate::token::{self, CommentKind, DelimToken};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n@@ -378,7 +378,7 @@ impl Default for Generics {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct WhereClause {\n     /// `true` if we ate a `where` token: this can happen\n-    /// if we parsed no predicates (e.g. `struct Foo where {}\n+    /// if we parsed no predicates (e.g. `struct Foo where {}`).\n     /// This allows us to accurately pretty-print\n     /// in `nt_to_tokenstream`\n     pub has_where_token: bool,\n@@ -1052,6 +1052,30 @@ impl Expr {\n         }\n     }\n \n+    /// Is this expr either `N`, or `{ N }`.\n+    ///\n+    /// If this is not the case, name resolution does not resolve `N` when using\n+    /// `feature(min_const_generics)` as more complex expressions are not supported.\n+    pub fn is_potential_trivial_const_param(&self) -> bool {\n+        let this = if let ExprKind::Block(ref block, None) = self.kind {\n+            if block.stmts.len() == 1 {\n+                if let StmtKind::Expr(ref expr) = block.stmts[0].kind { expr } else { self }\n+            } else {\n+                self\n+            }\n+        } else {\n+            self\n+        };\n+\n+        if let ExprKind::Path(None, ref path) = this.kind {\n+            if path.segments.len() == 1 && path.segments[0].args.is_none() {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n     pub fn to_bound(&self) -> Option<GenericBound> {\n         match &self.kind {\n             ExprKind::Path(None, path) => Some(GenericBound::Trait(\n@@ -2365,7 +2389,7 @@ pub enum AttrKind {\n     /// A doc comment (e.g. `/// ...`, `//! ...`, `/** ... */`, `/*! ... */`).\n     /// Doc attributes (e.g. `#[doc=\"...\"]`) are represented with the `Normal`\n     /// variant (which is much less compact and thus more expensive).\n-    DocComment(Symbol),\n+    DocComment(CommentKind, Symbol),\n }\n \n /// `TraitRef`s appear in impls."}, {"sha": "edcbce3e2cfd34cc2bd77563427b97bbab27db50", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 27, "deletions": 95, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -7,75 +7,33 @@ use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::mut_visit::visit_clobber;\n use crate::ptr::P;\n-use crate::token::{self, Token};\n+use crate::token::{self, CommentKind, Token};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n \n-use rustc_data_structures::sync::Lock;\n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::edition::{Edition, DEFAULT_EDITION};\n use rustc_span::source_map::{BytePos, Spanned};\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n use std::iter;\n use std::ops::DerefMut;\n \n-// Per-session global variables: this struct is stored in thread-local storage\n-// in such a way that it is accessible without any kind of handle to all\n-// threads within the compilation session, but is not accessible outside the\n-// session.\n-pub struct SessionGlobals {\n-    used_attrs: Lock<GrowableBitSet<AttrId>>,\n-    known_attrs: Lock<GrowableBitSet<AttrId>>,\n-    span_session_globals: rustc_span::SessionGlobals,\n-}\n+pub struct MarkedAttrs(GrowableBitSet<AttrId>);\n \n-impl SessionGlobals {\n-    fn new(edition: Edition) -> SessionGlobals {\n-        SessionGlobals {\n-            // We have no idea how many attributes there will be, so just\n-            // initiate the vectors with 0 bits. We'll grow them as necessary.\n-            used_attrs: Lock::new(GrowableBitSet::new_empty()),\n-            known_attrs: Lock::new(GrowableBitSet::new_empty()),\n-            span_session_globals: rustc_span::SessionGlobals::new(edition),\n-        }\n+impl MarkedAttrs {\n+    // We have no idea how many attributes there will be, so just\n+    // initiate the vectors with 0 bits. We'll grow them as necessary.\n+    pub fn new() -> Self {\n+        MarkedAttrs(GrowableBitSet::new_empty())\n     }\n-}\n-\n-pub fn with_session_globals<R>(edition: Edition, f: impl FnOnce() -> R) -> R {\n-    let ast_session_globals = SessionGlobals::new(edition);\n-    SESSION_GLOBALS.set(&ast_session_globals, || {\n-        rustc_span::SESSION_GLOBALS.set(&ast_session_globals.span_session_globals, f)\n-    })\n-}\n-\n-pub fn with_default_session_globals<R>(f: impl FnOnce() -> R) -> R {\n-    with_session_globals(DEFAULT_EDITION, f)\n-}\n \n-scoped_tls::scoped_thread_local!(pub static SESSION_GLOBALS: SessionGlobals);\n-\n-pub fn mark_used(attr: &Attribute) {\n-    debug!(\"marking {:?} as used\", attr);\n-    SESSION_GLOBALS.with(|session_globals| {\n-        session_globals.used_attrs.lock().insert(attr.id);\n-    });\n-}\n-\n-pub fn is_used(attr: &Attribute) -> bool {\n-    SESSION_GLOBALS.with(|session_globals| session_globals.used_attrs.lock().contains(attr.id))\n-}\n-\n-pub fn mark_known(attr: &Attribute) {\n-    debug!(\"marking {:?} as known\", attr);\n-    SESSION_GLOBALS.with(|session_globals| {\n-        session_globals.known_attrs.lock().insert(attr.id);\n-    });\n-}\n+    pub fn mark(&mut self, attr: &Attribute) {\n+        self.0.insert(attr.id);\n+    }\n \n-pub fn is_known(attr: &Attribute) -> bool {\n-    SESSION_GLOBALS.with(|session_globals| session_globals.known_attrs.lock().contains(attr.id))\n+    pub fn is_marked(&self, attr: &Attribute) -> bool {\n+        self.0.contains(attr.id)\n+    }\n }\n \n pub fn is_known_lint_tool(m_item: Ident) -> bool {\n@@ -169,23 +127,8 @@ impl Attribute {\n     pub fn has_name(&self, name: Symbol) -> bool {\n         match self.kind {\n             AttrKind::Normal(ref item) => item.path == name,\n-            AttrKind::DocComment(_) => false,\n-        }\n-    }\n-\n-    /// Returns `true` if the attribute's path matches the argument.\n-    /// If it matches, then the attribute is marked as used.\n-    /// Should only be used by rustc, other tools can use `has_name` instead,\n-    /// because only rustc is supposed to report the `unused_attributes` lint.\n-    /// `MetaItem` and `NestedMetaItem` are produced by \"lowering\" an `Attribute`\n-    /// and don't have identity, so they only has the `has_name` method,\n-    /// and you need to mark the original `Attribute` as used when necessary.\n-    pub fn check_name(&self, name: Symbol) -> bool {\n-        let matches = self.has_name(name);\n-        if matches {\n-            mark_used(self);\n+            AttrKind::DocComment(..) => false,\n         }\n-        matches\n     }\n \n     /// For a single-segment attribute, returns its name; otherwise, returns `None`.\n@@ -198,7 +141,7 @@ impl Attribute {\n                     None\n                 }\n             }\n-            AttrKind::DocComment(_) => None,\n+            AttrKind::DocComment(..) => None,\n         }\n     }\n     pub fn name_or_empty(&self) -> Symbol {\n@@ -218,7 +161,7 @@ impl Attribute {\n                 Some(MetaItem { kind: MetaItemKind::List(list), .. }) => Some(list),\n                 _ => None,\n             },\n-            AttrKind::DocComment(_) => None,\n+            AttrKind::DocComment(..) => None,\n         }\n     }\n \n@@ -314,13 +257,13 @@ impl Attribute {\n     pub fn is_doc_comment(&self) -> bool {\n         match self.kind {\n             AttrKind::Normal(_) => false,\n-            AttrKind::DocComment(_) => true,\n+            AttrKind::DocComment(..) => true,\n         }\n     }\n \n     pub fn doc_str(&self) -> Option<Symbol> {\n         match self.kind {\n-            AttrKind::DocComment(symbol) => Some(symbol),\n+            AttrKind::DocComment(.., data) => Some(data),\n             AttrKind::Normal(ref item) if item.path == sym::doc => {\n                 item.meta(self.span).and_then(|meta| meta.value_str())\n             }\n@@ -331,14 +274,14 @@ impl Attribute {\n     pub fn get_normal_item(&self) -> &AttrItem {\n         match self.kind {\n             AttrKind::Normal(ref item) => item,\n-            AttrKind::DocComment(_) => panic!(\"unexpected doc comment\"),\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n \n     pub fn unwrap_normal_item(self) -> AttrItem {\n         match self.kind {\n             AttrKind::Normal(item) => item,\n-            AttrKind::DocComment(_) => panic!(\"unexpected doc comment\"),\n+            AttrKind::DocComment(..) => panic!(\"unexpected doc comment\"),\n         }\n     }\n \n@@ -405,30 +348,19 @@ pub fn mk_attr_outer(item: MetaItem) -> Attribute {\n     mk_attr(AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n }\n \n-pub fn mk_doc_comment(style: AttrStyle, comment: Symbol, span: Span) -> Attribute {\n-    Attribute { kind: AttrKind::DocComment(comment), id: mk_attr_id(), style, span }\n+pub fn mk_doc_comment(\n+    comment_kind: CommentKind,\n+    style: AttrStyle,\n+    data: Symbol,\n+    span: Span,\n+) -> Attribute {\n+    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: mk_attr_id(), style, span }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n     items.iter().any(|item| item.has_name(name))\n }\n \n-pub fn contains_name(attrs: &[Attribute], name: Symbol) -> bool {\n-    attrs.iter().any(|item| item.check_name(name))\n-}\n-\n-pub fn find_by_name(attrs: &[Attribute], name: Symbol) -> Option<&Attribute> {\n-    attrs.iter().find(|attr| attr.check_name(name))\n-}\n-\n-pub fn filter_by_name(attrs: &[Attribute], name: Symbol) -> impl Iterator<Item = &Attribute> {\n-    attrs.iter().filter(move |attr| attr.check_name(name))\n-}\n-\n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: Symbol) -> Option<Symbol> {\n-    attrs.iter().find(|at| at.check_name(name)).and_then(|at| at.value_str())\n-}\n-\n impl MetaItem {\n     fn token_trees_and_joints(&self) -> Vec<TreeAndJoint> {\n         let mut idents = vec![];"}, {"sha": "290f6006de0790f25cac9f7618e061f54a92e1a7", "filename": "src/librustc_ast/entry.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fentry.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,35 +1,7 @@\n-use crate::ast::{Item, ItemKind};\n-use crate::attr;\n-use rustc_span::symbol::sym;\n-\n pub enum EntryPointType {\n     None,\n     MainNamed,\n     MainAttr,\n     Start,\n     OtherMain, // Not an entry point, but some other function named main\n }\n-\n-// Beware, this is duplicated in librustc_middle/middle/entry.rs, make sure to keep\n-// them in sync.\n-pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n-    match item.kind {\n-        ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, sym::start) {\n-                EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, sym::main) {\n-                EntryPointType::MainAttr\n-            } else if item.ident.name == sym::main {\n-                if depth == 1 {\n-                    // This is a top-level function so can be 'main'\n-                    EntryPointType::MainNamed\n-                } else {\n-                    EntryPointType::OtherMain\n-                }\n-            } else {\n-                EntryPointType::None\n-            }\n-        }\n-        _ => EntryPointType::None,\n-    }\n-}"}, {"sha": "cd27f958e4641868450fbd841313b0b006bc3176", "filename": "src/librustc_ast/expand/allocator.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,6 +1,4 @@\n-use crate::{ast, attr, visit};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n \n #[derive(Clone, Copy)]\n pub enum AllocatorKind {\n@@ -53,25 +51,3 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         output: AllocatorTy::ResultPtr,\n     },\n ];\n-\n-pub fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n-    struct Finder {\n-        name: Symbol,\n-        spans: Vec<Span>,\n-    }\n-    impl<'ast> visit::Visitor<'ast> for Finder {\n-        fn visit_item(&mut self, item: &'ast ast::Item) {\n-            if item.ident.name == self.name\n-                && attr::contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n-            {\n-                self.spans.push(item.span);\n-            }\n-            visit::walk_item(self, item)\n-        }\n-    }\n-\n-    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n-    let mut f = Finder { name, spans: Vec::new() };\n-    visit::walk_crate(&mut f, krate);\n-    f.spans\n-}"}, {"sha": "eebfc38bdf4ec56b510cd71f35c1e33a99cfabd2", "filename": "src/librustc_ast/expand/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fexpand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fexpand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fexpand%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,12 +1,3 @@\n //! Definitions shared by macros / syntax extensions and e.g. librustc_middle.\n \n-use crate::ast::Attribute;\n-use rustc_span::symbol::sym;\n-\n pub mod allocator;\n-\n-pub fn is_proc_macro_attr(attr: &Attribute) -> bool {\n-    [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n-        .iter()\n-        .any(|kind| attr.check_name(*kind))\n-}"}, {"sha": "3f876169d2236e4baddf2c305cf16a7bbaef517d", "filename": "src/librustc_ast/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -42,7 +42,6 @@ pub mod util {\n \n pub mod ast;\n pub mod attr;\n-pub use attr::{with_default_session_globals, with_session_globals, SESSION_GLOBALS};\n pub mod crate_disambiguator;\n pub mod entry;\n pub mod expand;"}, {"sha": "df6e8218f6c3ac5201a32614248c38bbe7b68061", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -582,7 +582,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n         }\n-        AttrKind::DocComment(_) => {}\n+        AttrKind::DocComment(..) => {}\n     }\n     vis.visit_span(span);\n }"}, {"sha": "bcce881ed48c5deef7423eb8bfa4a8b082c5e1b8", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -17,6 +17,12 @@ use rustc_span::{self, Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::{fmt, mem};\n \n+#[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n+pub enum CommentKind {\n+    Line,\n+    Block,\n+}\n+\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n #[derive(HashStable_Generic)]\n pub enum BinOpToken {\n@@ -238,9 +244,10 @@ pub enum TokenKind {\n \n     Interpolated(Lrc<Nonterminal>),\n \n-    // Can be expanded into several tokens.\n-    /// A doc comment.\n-    DocComment(Symbol),\n+    /// A doc comment token.\n+    /// `Symbol` is the doc comment's data excluding its \"quotes\" (`///`, `/**`, etc)\n+    /// similarly to symbols in string literal tokens.\n+    DocComment(CommentKind, ast::AttrStyle, Symbol),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for"}, {"sha": "a73891db160de9739222c96330d032732e828a3d", "filename": "src/librustc_ast/util/comments.rs", "status": "modified", "additions": 57, "deletions": 63, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fcomments.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,11 +1,7 @@\n-pub use CommentStyle::*;\n-\n-use crate::ast;\n+use crate::ast::AttrStyle;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, CharPos, FileName, Pos, Symbol};\n \n-use log::debug;\n-\n #[cfg(test)]\n mod tests;\n \n@@ -28,43 +24,48 @@ pub struct Comment {\n     pub pos: BytePos,\n }\n \n-pub fn is_line_doc_comment(s: &str) -> bool {\n-    let res = (s.starts_with(\"///\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'/')\n-        || s.starts_with(\"//!\");\n-    debug!(\"is {:?} a doc comment? {}\", s, res);\n-    res\n-}\n-\n-pub fn is_block_doc_comment(s: &str) -> bool {\n-    // Prevent `/**/` from being parsed as a doc comment\n-    let res = ((s.starts_with(\"/**\") && *s.as_bytes().get(3).unwrap_or(&b' ') != b'*')\n-        || s.starts_with(\"/*!\"))\n-        && s.len() >= 5;\n-    debug!(\"is {:?} a doc comment? {}\", s, res);\n-    res\n-}\n-\n-// FIXME(#64197): Try to privatize this again.\n-pub fn is_doc_comment(s: &str) -> bool {\n-    (s.starts_with(\"///\") && is_line_doc_comment(s))\n-        || s.starts_with(\"//!\")\n-        || (s.starts_with(\"/**\") && is_block_doc_comment(s))\n-        || s.starts_with(\"/*!\")\n+/// For a full line comment string returns its doc comment style if it's a doc comment\n+/// and returns `None` if it's a regular comment.\n+pub fn line_doc_comment_style(line_comment: &str) -> Option<AttrStyle> {\n+    let line_comment = line_comment.as_bytes();\n+    assert!(line_comment.starts_with(b\"//\"));\n+    match line_comment.get(2) {\n+        // `//!` is an inner line doc comment.\n+        Some(b'!') => Some(AttrStyle::Inner),\n+        Some(b'/') => match line_comment.get(3) {\n+            // `////` (more than 3 slashes) is not considered a doc comment.\n+            Some(b'/') => None,\n+            // Otherwise `///` is an outer line doc comment.\n+            _ => Some(AttrStyle::Outer),\n+        },\n+        _ => None,\n+    }\n }\n \n-pub fn doc_comment_style(comment: Symbol) -> ast::AttrStyle {\n-    let comment = &comment.as_str();\n-    assert!(is_doc_comment(comment));\n-    if comment.starts_with(\"//!\") || comment.starts_with(\"/*!\") {\n-        ast::AttrStyle::Inner\n-    } else {\n-        ast::AttrStyle::Outer\n+/// For a full block comment string returns its doc comment style if it's a doc comment\n+/// and returns `None` if it's a regular comment.\n+pub fn block_doc_comment_style(block_comment: &str, terminated: bool) -> Option<AttrStyle> {\n+    let block_comment = block_comment.as_bytes();\n+    assert!(block_comment.starts_with(b\"/*\"));\n+    assert!(!terminated || block_comment.ends_with(b\"*/\"));\n+    match block_comment.get(2) {\n+        // `/*!` is an inner block doc comment.\n+        Some(b'!') => Some(AttrStyle::Inner),\n+        Some(b'*') => match block_comment.get(3) {\n+            // `/***` (more than 2 stars) is not considered a doc comment.\n+            Some(b'*') => None,\n+            // `/**/` is not considered a doc comment.\n+            Some(b'/') if block_comment.len() == 4 => None,\n+            // Otherwise `/**` is an outer block doc comment.\n+            _ => Some(AttrStyle::Outer),\n+        },\n+        _ => None,\n     }\n }\n \n-pub fn strip_doc_comment_decoration(comment: Symbol) -> String {\n-    let comment = &comment.as_str();\n-\n+/// Makes a doc string more presentable to users.\n+/// Used by rustdoc and perhaps other tools, but not by rustc.\n+pub fn beautify_doc_string(data: Symbol) -> String {\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: Vec<String>) -> Vec<String> {\n         let mut i = 0;\n@@ -126,26 +127,15 @@ pub fn strip_doc_comment_decoration(comment: Symbol) -> String {\n         }\n     }\n \n-    // one-line comments lose their prefix\n-    const ONELINERS: &[&str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n-\n-    for prefix in ONELINERS {\n-        if comment.starts_with(*prefix) {\n-            return (&comment[prefix.len()..]).to_string();\n-        }\n-    }\n-\n-    if comment.starts_with(\"/*\") {\n-        let lines =\n-            comment[3..comment.len() - 2].lines().map(|s| s.to_string()).collect::<Vec<String>>();\n-\n+    let data = data.as_str();\n+    if data.contains('\\n') {\n+        let lines = data.lines().map(|s| s.to_string()).collect::<Vec<String>>();\n         let lines = vertical_trim(lines);\n         let lines = horizontal_trim(lines);\n-\n-        return lines.join(\"\\n\");\n+        lines.join(\"\\n\")\n+    } else {\n+        data.to_string()\n     }\n-\n-    panic!(\"not a doc-comment: {}\", comment);\n }\n \n /// Returns `None` if the first `col` chars of `s` contain a non-whitespace char.\n@@ -203,7 +193,7 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n \n     if let Some(shebang_len) = rustc_lexer::strip_shebang(text) {\n         comments.push(Comment {\n-            style: Isolated,\n+            style: CommentStyle::Isolated,\n             lines: vec![text[..shebang_len].to_string()],\n             pos: start_bpos,\n         });\n@@ -219,23 +209,23 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n                     while let Some(next_newline) = &token_text[idx + 1..].find('\\n') {\n                         idx = idx + 1 + next_newline;\n                         comments.push(Comment {\n-                            style: BlankLine,\n+                            style: CommentStyle::BlankLine,\n                             lines: vec![],\n                             pos: start_bpos + BytePos((pos + idx) as u32),\n                         });\n                     }\n                 }\n             }\n-            rustc_lexer::TokenKind::BlockComment { terminated: _ } => {\n-                if !is_block_doc_comment(token_text) {\n+            rustc_lexer::TokenKind::BlockComment { terminated } => {\n+                if block_doc_comment_style(token_text, terminated).is_none() {\n                     let code_to_the_right = match text[pos + token.len..].chars().next() {\n                         Some('\\r' | '\\n') => false,\n                         _ => true,\n                     };\n                     let style = match (code_to_the_left, code_to_the_right) {\n-                        (_, true) => Mixed,\n-                        (false, false) => Isolated,\n-                        (true, false) => Trailing,\n+                        (_, true) => CommentStyle::Mixed,\n+                        (false, false) => CommentStyle::Isolated,\n+                        (true, false) => CommentStyle::Trailing,\n                     };\n \n                     // Count the number of chars since the start of the line by rescanning.\n@@ -249,9 +239,13 @@ pub fn gather_comments(sm: &SourceMap, path: FileName, src: String) -> Vec<Comme\n                 }\n             }\n             rustc_lexer::TokenKind::LineComment => {\n-                if !is_doc_comment(token_text) {\n+                if line_doc_comment_style(token_text).is_none() {\n                     comments.push(Comment {\n-                        style: if code_to_the_left { Trailing } else { Isolated },\n+                        style: if code_to_the_left {\n+                            CommentStyle::Trailing\n+                        } else {\n+                            CommentStyle::Isolated\n+                        },\n                         lines: vec![token_text.to_string()],\n                         pos: start_bpos + BytePos(pos as u32),\n                     })"}, {"sha": "1919b9341aa341bf198f1331be42582dc8ade75b", "filename": "src/librustc_ast/util/comments/tests.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fcomments%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,58 +1,50 @@\n use super::*;\n-use crate::with_default_session_globals;\n+use rustc_span::with_default_session_globals;\n+\n+#[test]\n+fn line_doc_comments() {\n+    assert!(line_doc_comment_style(\"///\").is_some());\n+    assert!(line_doc_comment_style(\"/// blah\").is_some());\n+    assert!(line_doc_comment_style(\"////\").is_none());\n+}\n \n #[test]\n fn test_block_doc_comment_1() {\n     with_default_session_globals(|| {\n-        let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(comment));\n+        let comment = \"\\n * Test \\n **  Test\\n *   Test\\n\";\n+        let stripped = beautify_doc_string(Symbol::intern(comment));\n         assert_eq!(stripped, \" Test \\n*  Test\\n   Test\");\n     })\n }\n \n #[test]\n fn test_block_doc_comment_2() {\n     with_default_session_globals(|| {\n-        let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(comment));\n+        let comment = \"\\n * Test\\n *  Test\\n\";\n+        let stripped = beautify_doc_string(Symbol::intern(comment));\n         assert_eq!(stripped, \" Test\\n  Test\");\n     })\n }\n \n #[test]\n fn test_block_doc_comment_3() {\n     with_default_session_globals(|| {\n-        let comment = \"/**\\n let a: *i32;\\n *a = 5;\\n*/\";\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(comment));\n+        let comment = \"\\n let a: *i32;\\n *a = 5;\\n\";\n+        let stripped = beautify_doc_string(Symbol::intern(comment));\n         assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n     })\n }\n \n-#[test]\n-fn test_block_doc_comment_4() {\n-    with_default_session_globals(|| {\n-        let comment = \"/*******************\\n test\\n *********************/\";\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(comment));\n-        assert_eq!(stripped, \" test\");\n-    })\n-}\n-\n #[test]\n fn test_line_doc_comment() {\n     with_default_session_globals(|| {\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"/// test\"));\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"///! test\"));\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"// test\"));\n+        let stripped = beautify_doc_string(Symbol::intern(\" test\"));\n         assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"// test\"));\n-        assert_eq!(stripped, \" test\");\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"///test\"));\n-        assert_eq!(stripped, \"test\");\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"///!test\"));\n-        assert_eq!(stripped, \"test\");\n-        let stripped = strip_doc_comment_decoration(Symbol::intern(\"//test\"));\n+        let stripped = beautify_doc_string(Symbol::intern(\"! test\"));\n+        assert_eq!(stripped, \"! test\");\n+        let stripped = beautify_doc_string(Symbol::intern(\"test\"));\n         assert_eq!(stripped, \"test\");\n+        let stripped = beautify_doc_string(Symbol::intern(\"!test\"));\n+        assert_eq!(stripped, \"!test\");\n     })\n }"}, {"sha": "7ebedbcb76a3695d519018e313bd7d1f254d7f16", "filename": "src/librustc_ast/util/lev_distance/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Futil%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Futil%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Flev_distance%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -21,7 +21,7 @@ fn test_lev_distance() {\n \n #[test]\n fn test_find_best_match_for_name() {\n-    use crate::with_default_session_globals;\n+    use rustc_span::with_default_session_globals;\n     with_default_session_globals(|| {\n         let input = vec![Symbol::intern(\"aaab\"), Symbol::intern(\"aaabc\")];\n         assert_eq!("}, {"sha": "2c3d1e97df97574bb932723c861c6dd7c603a94e", "filename": "src/librustc_ast/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fvisit.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -880,7 +880,7 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n     match attr.kind {\n         AttrKind::Normal(ref item) => walk_mac_args(visitor, &item.args),\n-        AttrKind::DocComment(_) => {}\n+        AttrKind::DocComment(..) => {}\n     }\n }\n "}, {"sha": "f9e54903a661acc6734bad331f7325360317b907", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1067,7 +1067,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             .collect();\n \n         // Stop if there were any errors when lowering the register classes\n-        if operands.len() != asm.operands.len() {\n+        if operands.len() != asm.operands.len() || sess.asm_arch.is_none() {\n             return hir::ExprKind::Err;\n         }\n "}, {"sha": "5186e62fbf9bc34d866b0225f96122a7c5ed8199", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,7 +3,6 @@ use super::{ImplTraitContext, ImplTraitPosition};\n use crate::Arena;\n \n use rustc_ast::ast::*;\n-use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n@@ -205,7 +204,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n-            if !macro_rules || attr::contains_name(&i.attrs, sym::macro_export) {\n+            if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n                 let hir_id = self.lower_node_id(i.id);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {"}, {"sha": "7cfde3fc6d2dcd1e09e49b8f0dcd1ba614353de2", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -37,7 +37,6 @@\n \n use rustc_ast::ast;\n use rustc_ast::ast::*;\n-use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n@@ -574,7 +573,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .resolver\n             .trait_map()\n             .iter()\n-            .map(|(&k, v)| (self.node_id_to_hir_id[k].unwrap(), v.clone()))\n+            .filter_map(|(&k, v)| {\n+                self.node_id_to_hir_id.get(k).and_then(|id| id.as_ref()).map(|id| (*id, v.clone()))\n+            })\n             .collect();\n \n         let mut def_id_to_hir_id = IndexVec::default();\n@@ -981,7 +982,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 path: item.path.clone(),\n                 args: self.lower_mac_args(&item.args),\n             }),\n-            AttrKind::DocComment(comment) => AttrKind::DocComment(comment),\n+            AttrKind::DocComment(comment_kind, data) => AttrKind::DocComment(comment_kind, data),\n         };\n \n         Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n@@ -2215,7 +2216,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     synthetic: param\n                         .attrs\n                         .iter()\n-                        .filter(|attr| attr.check_name(sym::rustc_synthetic))\n+                        .filter(|attr| self.sess.check_name(attr, sym::rustc_synthetic))\n                         .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n                         .next(),\n                 };\n@@ -2236,7 +2237,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id: self.lower_node_id(param.id),\n             name,\n             span: param.ident.span,\n-            pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n+            pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n             attrs: self.lower_attrs(&param.attrs),\n             bounds: self.arena.alloc_from_iter(bounds),\n             kind,"}, {"sha": "45a026d4b53fb9216a67b0d82a684f4523fe9225", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -8,8 +8,6 @@\n \n use itertools::{Either, Itertools};\n use rustc_ast::ast::*;\n-use rustc_ast::attr;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::walk_list;\n@@ -776,7 +774,13 @@ fn validate_generic_param_order<'a>(\n             span,\n             &format!(\n                 \"reorder the parameters: lifetimes, then types{}\",\n-                if sess.features_untracked().const_generics { \", then consts\" } else { \"\" },\n+                if sess.features_untracked().const_generics\n+                    || sess.features_untracked().min_const_generics\n+                {\n+                    \", then consts\"\n+                } else {\n+                    \"\"\n+                },\n             ),\n             ordered_params.clone(),\n             Applicability::MachineApplicable,\n@@ -891,11 +895,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n-        if item.attrs.iter().any(|attr| is_proc_macro_attr(attr)) {\n+        if item.attrs.iter().any(|attr| self.session.is_proc_macro_attr(attr)) {\n             self.has_proc_macro_decls = true;\n         }\n \n-        if attr::contains_name(&item.attrs, sym::no_mangle) {\n+        if self.session.contains_name(&item.attrs, sym::no_mangle) {\n             self.check_nomangle_item_asciionly(item.ident, item.span);\n         }\n \n@@ -1027,7 +1031,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Mod(Mod { inline, .. }) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !attr::contains_name(&item.attrs, sym::path) {\n+                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }"}, {"sha": "ce39ceff8f3893d81a424879e601b1271e02e76f", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,40 +1,44 @@\n use rustc_ast::ast::{self, AssocTyConstraint, AssocTyConstraintKind, NodeId};\n use rustc_ast::ast::{GenericParam, GenericParamKind, PatKind, RangeEnd, VariantData};\n-use rustc_ast::attr;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n-use rustc_errors::{struct_span_err, Handler};\n+use rustc_errors::struct_span_err;\n use rustc_feature::{AttributeGate, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_feature::{Features, GateIssue, UnstableFeatures};\n-use rustc_session::parse::{feature_err, feature_err_issue, ParseSess};\n+use rustc_feature::{Features, GateIssue};\n+use rustc_session::parse::{feature_err, feature_err_issue};\n+use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n use tracing::debug;\n \n macro_rules! gate_feature_fn {\n-    ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n-        let (cx, has_feature, span, name, explain) = (&*$cx, $has_feature, $span, $name, $explain);\n-        let has_feature: bool = has_feature(&$cx.features);\n+    ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (visitor, has_feature, span, name, explain) =\n+            (&*$visitor, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(cx.parse_sess, name, span, GateIssue::Language, explain).emit();\n+            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n+                .emit();\n         }\n     }};\n }\n \n macro_rules! gate_feature_post {\n-    ($cx: expr, $feature: ident, $span: expr, $explain: expr) => {\n-        gate_feature_fn!($cx, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n+    ($visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!($visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n     };\n }\n \n-pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features: &Features) {\n-    PostExpansionVisitor { parse_sess, features }.visit_attribute(attr)\n+pub fn check_attribute(attr: &ast::Attribute, sess: &Session, features: &Features) {\n+    PostExpansionVisitor { sess, features }.visit_attribute(attr)\n }\n \n struct PostExpansionVisitor<'a> {\n-    parse_sess: &'a ParseSess,\n+    sess: &'a Session,\n+\n+    // `sess` contains a `Features`, but this might not be that one.\n     features: &'a Features,\n }\n \n@@ -138,6 +142,7 @@ impl<'a> PostExpansionVisitor<'a> {\n                 );\n             }\n             abi => self\n+                .sess\n                 .parse_sess\n                 .span_diagnostic\n                 .delay_span_bug(span, &format!(\"unrecognized ABI not caught in lowering: {}\", abi)),\n@@ -167,7 +172,7 @@ impl<'a> PostExpansionVisitor<'a> {\n \n         if !discriminant_spans.is_empty() && has_fields {\n             let mut err = feature_err(\n-                self.parse_sess,\n+                &self.sess.parse_sess,\n                 sym::arbitrary_enum_discriminant,\n                 discriminant_spans.clone(),\n                 \"custom discriminant values are not allowed in enums with tuple or struct variants\",\n@@ -240,7 +245,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_fn!(self, has_feature, attr.span, name, descr);\n         }\n         // Check unstable flavors of the `#[doc]` attribute.\n-        if attr.check_name(sym::doc) {\n+        if self.sess.check_name(attr, sym::doc) {\n             for nested_meta in attr.meta_item_list().unwrap_or_default() {\n                 macro_rules! gate_doc { ($($name:ident => $feature:ident)*) => {\n                     $(if nested_meta.has_name(sym::$name) {\n@@ -266,7 +271,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             gate_feature_post!(\n                 &self,\n                 non_ascii_idents,\n-                self.parse_sess.source_map().guess_head_span(sp),\n+                self.sess.parse_sess.source_map().guess_head_span(sp),\n                 \"non-ascii idents are not fully supported\"\n             );\n         }\n@@ -281,15 +286,15 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Fn(..) => {\n-                if attr::contains_name(&i.attrs[..], sym::plugin_registrar) {\n+                if self.sess.contains_name(&i.attrs[..], sym::plugin_registrar) {\n                     gate_feature_post!(\n                         &self,\n                         plugin_registrar,\n                         i.span,\n                         \"compiler plugins are experimental and possibly buggy\"\n                     );\n                 }\n-                if attr::contains_name(&i.attrs[..], sym::start) {\n+                if self.sess.contains_name(&i.attrs[..], sym::start) {\n                     gate_feature_post!(\n                         &self,\n                         start,\n@@ -299,7 +304,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                          over time\"\n                     );\n                 }\n-                if attr::contains_name(&i.attrs[..], sym::main) {\n+                if self.sess.contains_name(&i.attrs[..], sym::main) {\n                     gate_feature_post!(\n                         &self,\n                         main,\n@@ -312,7 +317,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemKind::Struct(..) => {\n-                for attr in attr::filter_by_name(&i.attrs[..], sym::repr) {\n+                for attr in self.sess.filter_by_name(&i.attrs[..], sym::repr) {\n                     for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n                         if item.has_name(sym::simd) {\n                             gate_feature_post!(\n@@ -391,7 +396,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_foreign_item(&mut self, i: &'a ast::ForeignItem) {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n-                let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n+                let link_name = self.sess.first_attr_value_str_by_name(&i.attrs, sym::link_name);\n                 let links_to_llvm = match link_name {\n                     Some(val) => val.as_str().starts_with(\"llvm.\"),\n                     _ => false,\n@@ -450,7 +455,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Type(..) => {\n                 // To avoid noise about type ascription in common syntax errors, only emit if it\n                 // is the *only* error.\n-                if self.parse_sess.span_diagnostic.err_count() == 0 {\n+                if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n                     gate_feature_post!(\n                         &self,\n                         type_ascription,\n@@ -526,12 +531,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n         if let GenericParamKind::Const { .. } = param.kind {\n-            gate_feature_post!(\n+            gate_feature_fn!(\n                 &self,\n-                const_generics,\n+                |x: &Features| x.const_generics || x.min_const_generics,\n                 param.ident.span,\n+                sym::min_const_generics,\n                 \"const generics are unstable\"\n-            )\n+            );\n         }\n         visit::walk_generic_param(self, param)\n     }\n@@ -599,16 +605,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n }\n \n-pub fn check_crate(\n-    krate: &ast::Crate,\n-    parse_sess: &ParseSess,\n-    features: &Features,\n-    unstable: UnstableFeatures,\n-) {\n-    maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n-    let mut visitor = PostExpansionVisitor { parse_sess, features };\n+pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n+    maybe_stage_features(sess, krate);\n+    let mut visitor = PostExpansionVisitor { sess, features: &sess.features_untracked() };\n \n-    let spans = parse_sess.gated_spans.spans.borrow();\n+    let spans = sess.parse_sess.gated_spans.spans.borrow();\n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => {\n             for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n@@ -651,18 +652,18 @@ pub fn check_crate(\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n     // To avoid noise about type ascription in common syntax errors,\n     // only emit if it is the *only* error. (Also check it last.)\n-    if parse_sess.span_diagnostic.err_count() == 0 {\n+    if sess.parse_sess.span_diagnostic.err_count() == 0 {\n         gate_all!(type_ascription, \"type ascription is experimental\");\n     }\n \n     visit::walk_crate(&mut visitor, krate);\n }\n \n-fn maybe_stage_features(span_handler: &Handler, krate: &ast::Crate, unstable: UnstableFeatures) {\n-    if !unstable.is_nightly_build() {\n-        for attr in krate.attrs.iter().filter(|attr| attr.check_name(sym::feature)) {\n+fn maybe_stage_features(sess: &Session, krate: &ast::Crate) {\n+    if !sess.opts.unstable_features.is_nightly_build() {\n+        for attr in krate.attrs.iter().filter(|attr| sess.check_name(attr, sym::feature)) {\n             struct_span_err!(\n-                span_handler,\n+                sess.parse_sess.span_diagnostic,\n                 attr.span,\n                 E0554,\n                 \"`#![feature]` may not be used on the {} release channel\","}, {"sha": "9d9ca78de558890520e6ffd931e22a53fbe8a603", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -8,10 +8,11 @@ use rustc_ast::ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_ast::attr;\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, BinOpToken, DelimToken, Nonterminal, Token, TokenKind};\n+use rustc_ast::token::{self, BinOpToken, CommentKind, DelimToken, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::util::classify;\n+use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n-use rustc_ast::util::{classify, comments};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, IdentPrinter, Symbol};\n@@ -50,27 +51,27 @@ impl PpAnn for NoAnn {}\n \n pub struct Comments<'a> {\n     sm: &'a SourceMap,\n-    comments: Vec<comments::Comment>,\n+    comments: Vec<Comment>,\n     current: usize,\n }\n \n impl<'a> Comments<'a> {\n     pub fn new(sm: &'a SourceMap, filename: FileName, input: String) -> Comments<'a> {\n-        let comments = comments::gather_comments(sm, filename, input);\n+        let comments = gather_comments(sm, filename, input);\n         Comments { sm, comments, current: 0 }\n     }\n \n-    pub fn next(&self) -> Option<comments::Comment> {\n+    pub fn next(&self) -> Option<Comment> {\n         self.comments.get(self.current).cloned()\n     }\n \n     pub fn trailing_comment(\n         &mut self,\n         span: rustc_span::Span,\n         next_pos: Option<BytePos>,\n-    ) -> Option<comments::Comment> {\n+    ) -> Option<Comment> {\n         if let Some(cmnt) = self.next() {\n-            if cmnt.style != comments::Trailing {\n+            if cmnt.style != CommentStyle::Trailing {\n                 return None;\n             }\n             let span_line = self.sm.lookup_char_pos(span.hi());\n@@ -152,8 +153,8 @@ pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n // and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n     if let TokenTree::Token(token) = prev {\n-        if let token::DocComment(s) = token.kind {\n-            return !s.as_str().starts_with(\"//\");\n+        if let token::DocComment(comment_kind, ..) = token.kind {\n+            return comment_kind != CommentKind::Line;\n         }\n     }\n     match tt {\n@@ -194,6 +195,19 @@ fn binop_to_string(op: BinOpToken) -> &'static str {\n     }\n }\n \n+fn doc_comment_to_string(\n+    comment_kind: CommentKind,\n+    attr_style: ast::AttrStyle,\n+    data: Symbol,\n+) -> String {\n+    match (comment_kind, attr_style) {\n+        (CommentKind::Line, ast::AttrStyle::Outer) => format!(\"///{}\", data),\n+        (CommentKind::Line, ast::AttrStyle::Inner) => format!(\"//!{}\", data),\n+        (CommentKind::Block, ast::AttrStyle::Outer) => format!(\"/**{}*/\", data),\n+        (CommentKind::Block, ast::AttrStyle::Inner) => format!(\"/*!{}*/\", data),\n+    }\n+}\n+\n pub fn literal_to_string(lit: token::Lit) -> String {\n     let token::Lit { kind, symbol, suffix } = lit;\n     let mut out = match kind {\n@@ -271,7 +285,9 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Lifetime(s) => s.to_string(),\n \n         /* Other */\n-        token::DocComment(s) => s.to_string(),\n+        token::DocComment(comment_kind, attr_style, data) => {\n+            doc_comment_to_string(comment_kind, attr_style, data)\n+        }\n         token::Eof => \"<eof>\".to_string(),\n         token::Whitespace => \" \".to_string(),\n         token::Comment => \"/* */\".to_string(),\n@@ -447,9 +463,9 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn print_comment(&mut self, cmnt: &comments::Comment) {\n+    fn print_comment(&mut self, cmnt: &Comment) {\n         match cmnt.style {\n-            comments::Mixed => {\n+            CommentStyle::Mixed => {\n                 if !self.is_beginning_of_line() {\n                     self.zerobreak();\n                 }\n@@ -468,7 +484,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 }\n                 self.zerobreak()\n             }\n-            comments::Isolated => {\n+            CommentStyle::Isolated => {\n                 self.hardbreak_if_not_bol();\n                 for line in &cmnt.lines {\n                     // Don't print empty lines because they will end up as trailing\n@@ -479,7 +495,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.hardbreak();\n                 }\n             }\n-            comments::Trailing => {\n+            CommentStyle::Trailing => {\n                 if !self.is_beginning_of_line() {\n                     self.word(\" \");\n                 }\n@@ -497,7 +513,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     self.end();\n                 }\n             }\n-            comments::BlankLine => {\n+            CommentStyle::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let twice = match self.last_token() {\n                     pp::Token::String(s) => \";\" == s,\n@@ -516,7 +532,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n-    fn next_comment(&mut self) -> Option<comments::Comment> {\n+    fn next_comment(&mut self) -> Option<Comment> {\n         self.comments().as_mut().and_then(|c| c.next())\n     }\n \n@@ -599,8 +615,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 self.print_attr_item(&item, attr.span);\n                 self.word(\"]\");\n             }\n-            ast::AttrKind::DocComment(comment) => {\n-                self.word(comment.to_string());\n+            ast::AttrKind::DocComment(comment_kind, data) => {\n+                self.word(doc_comment_to_string(comment_kind, attr.style, data));\n                 self.hardbreak()\n             }\n         }"}, {"sha": "fdbd073255e83cf2aaedd300be7e9496677e411b", "filename": "src/librustc_ast_pretty/pprust/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,9 +1,9 @@\n use super::*;\n \n use rustc_ast::ast;\n-use rustc_ast::with_default_session_globals;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::Ident;\n+use rustc_span::with_default_session_globals;\n \n fn fun_to_string(\n     decl: &ast::FnDecl,"}, {"sha": "552584bb4d0b9dd17920203ade73dbf12776a764", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 85, "deletions": 79, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,13 +1,12 @@\n //! Parsing and validation of builtin attributes\n \n-use super::{find_by_name, mark_used};\n-\n use rustc_ast::ast::{self, Attribute, Lit, LitKind, MetaItem, MetaItemKind, NestedMetaItem};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, Handler};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::Session;\n use rustc_span::hygiene::Transparency;\n use rustc_span::{symbol::sym, symbol::Symbol, Span};\n use std::num::NonZeroU32;\n@@ -86,9 +85,9 @@ pub enum UnwindAttr {\n }\n \n /// Determine what `#[unwind]` attribute is present in `attrs`, if any.\n-pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Option<UnwindAttr> {\n+pub fn find_unwind_attr(sess: &Session, attrs: &[Attribute]) -> Option<UnwindAttr> {\n     attrs.iter().fold(None, |ia, attr| {\n-        if attr.check_name(sym::unwind) {\n+        if sess.check_name(attr, sym::unwind) {\n             if let Some(meta) = attr.meta() {\n                 if let MetaItemKind::List(items) = meta.kind {\n                     if items.len() == 1 {\n@@ -99,19 +98,22 @@ pub fn find_unwind_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> Op\n                         }\n                     }\n \n-                    if let Some(d) = diagnostic {\n-                        struct_span_err!(d, attr.span, E0633, \"malformed `unwind` attribute input\")\n-                            .span_label(attr.span, \"invalid argument\")\n-                            .span_suggestions(\n-                                attr.span,\n-                                \"the allowed arguments are `allowed` and `aborts`\",\n-                                (vec![\"allowed\", \"aborts\"])\n-                                    .into_iter()\n-                                    .map(|s| format!(\"#[unwind({})]\", s)),\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n-                    };\n+                    struct_span_err!(\n+                        sess.diagnostic(),\n+                        attr.span,\n+                        E0633,\n+                        \"malformed `unwind` attribute input\"\n+                    )\n+                    .span_label(attr.span, \"invalid argument\")\n+                    .span_suggestions(\n+                        attr.span,\n+                        \"the allowed arguments are `allowed` and `aborts`\",\n+                        (vec![\"allowed\", \"aborts\"])\n+                            .into_iter()\n+                            .map(|s| format!(\"#[unwind({})]\", s)),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n                 }\n             }\n         }\n@@ -161,30 +163,18 @@ impl StabilityLevel {\n     }\n }\n \n-/// Checks if `attrs` contains an attribute like `#![feature(feature_name)]`.\n-/// This will not perform any \"sanity checks\" on the form of the attributes.\n-pub fn contains_feature_attr(attrs: &[Attribute], feature_name: Symbol) -> bool {\n-    attrs.iter().any(|item| {\n-        item.check_name(sym::feature)\n-            && item\n-                .meta_item_list()\n-                .map(|list| list.iter().any(|mi| mi.is_word() && mi.has_name(feature_name)))\n-                .unwrap_or(false)\n-    })\n-}\n-\n /// Collects stability info from all stability attributes in `attrs`.\n /// Returns `None` if no stability attributes are found.\n pub fn find_stability(\n-    sess: &ParseSess,\n+    sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n ) -> (Option<Stability>, Option<ConstStability>) {\n     find_stability_generic(sess, attrs.iter(), item_sp)\n }\n \n fn find_stability_generic<'a, I>(\n-    sess: &ParseSess,\n+    sess: &Session,\n     attrs_iter: I,\n     item_sp: Span,\n ) -> (Option<Stability>, Option<ConstStability>)\n@@ -197,7 +187,7 @@ where\n     let mut const_stab: Option<ConstStability> = None;\n     let mut promotable = false;\n     let mut allow_const_fn_ptr = false;\n-    let diagnostic = &sess.span_diagnostic;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n         if ![\n@@ -214,7 +204,7 @@ where\n             continue; // not a stability level\n         }\n \n-        mark_used(attr);\n+        sess.mark_attr_used(attr);\n \n         let meta = attr.meta();\n \n@@ -230,7 +220,7 @@ where\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(\n-                        sess,\n+                        &sess.parse_sess,\n                         meta.span,\n                         AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n                     );\n@@ -249,10 +239,18 @@ where\n             match meta_name {\n                 sym::rustc_const_unstable | sym::unstable => {\n                     if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     }\n \n@@ -318,13 +316,13 @@ where\n                                 sym::soft => {\n                                     if !mi.is_word() {\n                                         let msg = \"`soft` should not have any arguments\";\n-                                        sess.span_diagnostic.span_err(mi.span, msg);\n+                                        sess.parse_sess.span_diagnostic.span_err(mi.span, msg);\n                                     }\n                                     is_soft = true;\n                                 }\n                                 _ => {\n                                     handle_errors(\n-                                        sess,\n+                                        &sess.parse_sess,\n                                         meta.span(),\n                                         AttrError::UnknownMetaItem(\n                                             pprust::path_to_string(&mi.path),\n@@ -336,7 +334,7 @@ where\n                             }\n                         } else {\n                             handle_errors(\n-                                sess,\n+                                &sess.parse_sess,\n                                 meta.span(),\n                                 AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n                             );\n@@ -359,7 +357,7 @@ where\n                             }\n                         }\n                         (None, _, _) => {\n-                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n                             continue;\n                         }\n                         _ => {\n@@ -371,10 +369,18 @@ where\n                 }\n                 sym::rustc_const_stable | sym::stable => {\n                     if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(sess, attr.span, AttrError::MultipleStabilityLevels);\n+                        handle_errors(\n+                            &sess.parse_sess,\n+                            attr.span,\n+                            AttrError::MultipleStabilityLevels,\n+                        );\n                         break;\n                     }\n \n@@ -395,7 +401,7 @@ where\n                                 }\n                                 _ => {\n                                     handle_errors(\n-                                        sess,\n+                                        &sess.parse_sess,\n                                         meta.span(),\n                                         AttrError::UnknownMetaItem(\n                                             pprust::path_to_string(&mi.path),\n@@ -407,7 +413,7 @@ where\n                             },\n                             NestedMetaItem::Literal(lit) => {\n                                 handle_errors(\n-                                    sess,\n+                                    &sess.parse_sess,\n                                     lit.span,\n                                     AttrError::UnsupportedLiteral(\"unsupported literal\", false),\n                                 );\n@@ -431,11 +437,11 @@ where\n                             }\n                         }\n                         (None, _) => {\n-                            handle_errors(sess, attr.span, AttrError::MissingFeature);\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n                             continue;\n                         }\n                         _ => {\n-                            handle_errors(sess, attr.span, AttrError::MissingSince);\n+                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n                             continue;\n                         }\n                     }\n@@ -466,8 +472,8 @@ where\n     (stab, const_stab)\n }\n \n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n-    super::first_attr_value_str_by_name(attrs, sym::crate_name)\n+pub fn find_crate_name(sess: &Session, attrs: &[Attribute]) -> Option<Symbol> {\n+    sess.first_attr_value_str_by_name(attrs, sym::crate_name)\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n@@ -630,27 +636,24 @@ pub struct Deprecation {\n }\n \n /// Finds the deprecation attribute. `None` if none exists.\n-pub fn find_deprecation(\n-    sess: &ParseSess,\n-    attrs: &[Attribute],\n-    item_sp: Span,\n-) -> Option<Deprecation> {\n+pub fn find_deprecation(sess: &Session, attrs: &[Attribute], item_sp: Span) -> Option<Deprecation> {\n     find_deprecation_generic(sess, attrs.iter(), item_sp)\n }\n \n fn find_deprecation_generic<'a, I>(\n-    sess: &ParseSess,\n+    sess: &Session,\n     attrs_iter: I,\n     item_sp: Span,\n ) -> Option<Deprecation>\n where\n     I: Iterator<Item = &'a Attribute>,\n {\n     let mut depr: Option<Deprecation> = None;\n-    let diagnostic = &sess.span_diagnostic;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n \n     'outer: for attr in attrs_iter {\n-        if !(attr.check_name(sym::deprecated) || attr.check_name(sym::rustc_deprecated)) {\n+        if !(sess.check_name(attr, sym::deprecated) || sess.check_name(attr, sym::rustc_deprecated))\n+        {\n             continue;\n         }\n \n@@ -673,7 +676,7 @@ where\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n                         handle_errors(\n-                            sess,\n+                            &sess.parse_sess,\n                             meta.span,\n                             AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n                         );\n@@ -685,7 +688,7 @@ where\n                     } else {\n                         if let Some(lit) = meta.name_value_literal() {\n                             handle_errors(\n-                                sess,\n+                                &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n                                     \"literal in `deprecated` \\\n@@ -710,28 +713,28 @@ where\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::note if attr.check_name(sym::deprecated) => {\n+                            sym::note if sess.check_name(attr, sym::deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::reason if attr.check_name(sym::rustc_deprecated) => {\n+                            sym::reason if sess.check_name(attr, sym::rustc_deprecated) => {\n                                 if !get(mi, &mut note) {\n                                     continue 'outer;\n                                 }\n                             }\n-                            sym::suggestion if attr.check_name(sym::rustc_deprecated) => {\n+                            sym::suggestion if sess.check_name(attr, sym::rustc_deprecated) => {\n                                 if !get(mi, &mut suggestion) {\n                                     continue 'outer;\n                                 }\n                             }\n                             _ => {\n                                 handle_errors(\n-                                    sess,\n+                                    &sess.parse_sess,\n                                     meta.span(),\n                                     AttrError::UnknownMetaItem(\n                                         pprust::path_to_string(&mi.path),\n-                                        if attr.check_name(sym::deprecated) {\n+                                        if sess.check_name(attr, sym::deprecated) {\n                                             &[\"since\", \"note\"]\n                                         } else {\n                                             &[\"since\", \"reason\", \"suggestion\"]\n@@ -743,7 +746,7 @@ where\n                         },\n                         NestedMetaItem::Literal(lit) => {\n                             handle_errors(\n-                                sess,\n+                                &sess.parse_sess,\n                                 lit.span,\n                                 AttrError::UnsupportedLiteral(\n                                     \"item in `deprecated` must be a key/value pair\",\n@@ -757,13 +760,13 @@ where\n             }\n         }\n \n-        if suggestion.is_some() && attr.check_name(sym::deprecated) {\n+        if suggestion.is_some() && sess.check_name(attr, sym::deprecated) {\n             unreachable!(\"only allowed on rustc_deprecated\")\n         }\n \n-        if attr.check_name(sym::rustc_deprecated) {\n+        if sess.check_name(attr, sym::rustc_deprecated) {\n             if since.is_none() {\n-                handle_errors(sess, attr.span, AttrError::MissingSince);\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n                 continue;\n             }\n \n@@ -773,9 +776,9 @@ where\n             }\n         }\n \n-        mark_used(&attr);\n+        sess.mark_attr_used(&attr);\n \n-        let is_since_rustc_version = attr.check_name(sym::rustc_deprecated);\n+        let is_since_rustc_version = sess.check_name(attr, sym::rustc_deprecated);\n         depr = Some(Deprecation { since, note, suggestion, is_since_rustc_version });\n     }\n \n@@ -818,18 +821,18 @@ impl IntType {\n /// the same discriminant size that the corresponding C enum would or C\n /// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n /// concerns to the only non-ZST field.\n-pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n+pub fn find_repr_attrs(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n     use ReprAttr::*;\n \n     let mut acc = Vec::new();\n-    let diagnostic = &sess.span_diagnostic;\n+    let diagnostic = &sess.parse_sess.span_diagnostic;\n     if attr.has_name(sym::repr) {\n         if let Some(items) = attr.meta_item_list() {\n-            mark_used(attr);\n+            sess.mark_attr_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n                     handle_errors(\n-                        sess,\n+                        &sess.parse_sess,\n                         item.span(),\n                         AttrError::UnsupportedLiteral(\n                             \"meta item in `repr` must be an identifier\",\n@@ -973,13 +976,14 @@ pub enum TransparencyError {\n }\n \n pub fn find_transparency(\n+    sess: &Session,\n     attrs: &[Attribute],\n     macro_rules: bool,\n ) -> (Transparency, Option<TransparencyError>) {\n     let mut transparency = None;\n     let mut error = None;\n     for attr in attrs {\n-        if attr.check_name(sym::rustc_macro_transparency) {\n+        if sess.check_name(attr, sym::rustc_macro_transparency) {\n             if let Some((_, old_span)) = transparency {\n                 error = Some(TransparencyError::MultipleTransparencyAttrs(old_span, attr.span));\n                 break;\n@@ -1004,18 +1008,20 @@ pub fn find_transparency(\n }\n \n pub fn allow_internal_unstable<'a>(\n+    sess: &'a Session,\n     attrs: &[Attribute],\n-    diag: &'a rustc_errors::Handler,\n ) -> Option<impl Iterator<Item = Symbol> + 'a> {\n-    let attr = find_by_name(attrs, sym::allow_internal_unstable)?;\n+    let attr = sess.find_by_name(attrs, sym::allow_internal_unstable)?;\n     let list = attr.meta_item_list().or_else(|| {\n-        diag.span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n+        sess.diagnostic()\n+            .span_err(attr.span, \"allow_internal_unstable expects list of feature names\");\n         None\n     })?;\n     Some(list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n-            diag.span_err(it.span(), \"`allow_internal_unstable` expects feature names\");\n+            sess.diagnostic()\n+                .span_err(it.span(), \"`allow_internal_unstable` expects feature names\");\n         }\n         name\n     }))"}, {"sha": "0247ca329915899d82a87ca65d4c72878961194b", "filename": "src/librustc_builtin_macros/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcfg.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -19,7 +19,7 @@ pub fn expand_cfg(\n \n     match parse_cfg(cx, sp, tts) {\n         Ok(cfg) => {\n-            let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n+            let matches_cfg = attr::cfg_matches(&cfg, &cx.sess.parse_sess, cx.ecfg.features);\n             MacEager::expr(cx.expr_bool(sp, matches_cfg))\n         }\n         Err(mut err) => {"}, {"sha": "7a91dde5a9d8aaacd71233e1293be6bce6006af8", "filename": "src/librustc_builtin_macros/cfg_accessible.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fcfg_accessible.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -37,7 +37,12 @@ impl MultiItemModifier for Expander {\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         let template = AttributeTemplate { list: Some(\"path\"), ..Default::default() };\n         let attr = &ecx.attribute(meta_item.clone());\n-        validate_attr::check_builtin_attribute(ecx.parse_sess, attr, sym::cfg_accessible, template);\n+        validate_attr::check_builtin_attribute(\n+            &ecx.sess.parse_sess,\n+            attr,\n+            sym::cfg_accessible,\n+            template,\n+        );\n \n         let path = match validate_input(ecx, meta_item) {\n             Some(path) => path,"}, {"sha": "2611855a3a1b5a6709de8b446a64d7c385f41c9c", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -72,7 +72,7 @@ fn default_substructure(\n         },\n         StaticEnum(..) => {\n             struct_span_err!(\n-                cx.parse_sess.span_diagnostic,\n+                &cx.sess.parse_sess.span_diagnostic,\n                 trait_span,\n                 E0665,\n                 \"`Default` cannot be derived for enums, only structs\""}, {"sha": "908aabe902434dd402d2c9fcdadd9d127d6b2f1c", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -392,7 +392,7 @@ impl<'a> TraitDef<'a> {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n-                    for r in attr::find_repr_attrs(&cx.parse_sess, attr) {\n+                    for r in attr::find_repr_attrs(&cx.sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n                             return true;\n                         }\n@@ -677,7 +677,7 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         // Just mark it now since we know that it'll end up used downstream\n-        attr::mark_used(&attr);\n+        cx.sess.mark_attr_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n             let word = rustc_ast::attr::mk_nested_word_item(Ident::new("}, {"sha": "b6f733ee93db08666d1e18b08ecb7711f24a4b59", "filename": "src/librustc_builtin_macros/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fenv.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -23,7 +23,7 @@ pub fn expand_option_env<'cx>(\n \n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(&var.as_str()).ok().as_deref().map(Symbol::intern);\n-    cx.parse_sess.env_depinfo.borrow_mut().insert((Symbol::intern(&var), value));\n+    cx.sess.parse_sess.env_depinfo.borrow_mut().insert((Symbol::intern(&var), value));\n     let e = match value {\n         None => {\n             let lt = cx.lifetime(sp, Ident::new(kw::StaticLifetime, sp));\n@@ -81,7 +81,7 @@ pub fn expand_env<'cx>(\n \n     let sp = cx.with_def_site_ctxt(sp);\n     let value = env::var(&*var.as_str()).ok().as_deref().map(Symbol::intern);\n-    cx.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n+    cx.sess.parse_sess.env_depinfo.borrow_mut().insert((var, value));\n     let e = match value {\n         None => {\n             cx.span_err(sp, &msg.as_str());"}, {"sha": "ccff8aa90a8ad1a47f1b46590bda60559257c606", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -19,7 +19,7 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let not_static = |item: Annotatable| {\n-        ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n         vec![item]\n     };\n     let item = match item {"}, {"sha": "77fd71d58ef6b3227ca547d1bd9f39805ad0d826", "filename": "src/librustc_builtin_macros/llvm_asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fllvm_asm.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -110,7 +110,7 @@ fn parse_inline_asm<'a>(\n                     // If we already have a string with instructions,\n                     // ending up in Asm state again is an error.\n                     return Err(struct_span_err!(\n-                        cx.parse_sess.span_diagnostic,\n+                        cx.sess.parse_sess.span_diagnostic,\n                         sp,\n                         E0660,\n                         \"malformed inline assembly\"\n@@ -171,7 +171,7 @@ fn parse_inline_asm<'a>(\n                         Some('+') => Some(Symbol::intern(&format!(\"={}\", ch.as_str()))),\n                         _ => {\n                             struct_span_err!(\n-                                cx.parse_sess.span_diagnostic,\n+                                cx.sess.parse_sess.span_diagnostic,\n                                 span,\n                                 E0661,\n                                 \"output operand constraint lacks '=' or '+'\"\n@@ -201,15 +201,15 @@ fn parse_inline_asm<'a>(\n \n                     if constraint.as_str().starts_with('=') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0662,\n                             \"input operand constraint contains '='\"\n                         )\n                         .emit();\n                     } else if constraint.as_str().starts_with('+') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0663,\n                             \"input operand constraint contains '+'\"\n@@ -236,7 +236,7 @@ fn parse_inline_asm<'a>(\n                         cx.span_warn(p.prev_token.span, \"expected a clobber, found an option\");\n                     } else if s.as_str().starts_with('{') || s.as_str().ends_with('}') {\n                         struct_span_err!(\n-                            cx.parse_sess.span_diagnostic,\n+                            cx.sess.parse_sess.span_diagnostic,\n                             p.prev_token.span,\n                             E0664,\n                             \"clobber should not be surrounded by braces\""}, {"sha": "4f2f066e652f1533b5e1fc4782f4802d19206fac", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,13 +2,12 @@ use std::mem;\n \n use rustc_ast::ast::{self, NodeId};\n use rustc_ast::attr;\n-use rustc_ast::expand::is_proc_macro_attr;\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::hygiene::AstPass;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -42,6 +41,7 @@ enum ProcMacro {\n }\n \n struct CollectProcMacros<'a> {\n+    sess: &'a Session,\n     macros: Vec<ProcMacro>,\n     in_root: bool,\n     handler: &'a rustc_errors::Handler,\n@@ -51,7 +51,7 @@ struct CollectProcMacros<'a> {\n }\n \n pub fn inject(\n-    sess: &ParseSess,\n+    sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n     mut krate: ast::Crate,\n     is_proc_macro_crate: bool,\n@@ -64,6 +64,7 @@ pub fn inject(\n     let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n+        sess,\n         macros: Vec::new(),\n         in_root: true,\n         handler,\n@@ -244,7 +245,7 @@ impl<'a> CollectProcMacros<'a> {\n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n         if let ast::ItemKind::MacroDef(..) = item.kind {\n-            if self.is_proc_macro_crate && attr::contains_name(&item.attrs, sym::macro_export) {\n+            if self.is_proc_macro_crate && self.sess.contains_name(&item.attrs, sym::macro_export) {\n                 let msg =\n                     \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n                 self.handler.span_err(self.source_map.guess_head_span(item.span), msg);\n@@ -263,7 +264,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         let mut found_attr: Option<&'a ast::Attribute> = None;\n \n         for attr in &item.attrs {\n-            if is_proc_macro_attr(&attr) {\n+            if self.sess.is_proc_macro_attr(&attr) {\n                 if let Some(prev_attr) = found_attr {\n                     let prev_item = prev_attr.get_normal_item();\n                     let item = attr.get_normal_item();\n@@ -331,11 +332,11 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n             return;\n         }\n \n-        if attr.check_name(sym::proc_macro_derive) {\n+        if self.sess.check_name(attr, sym::proc_macro_derive) {\n             self.collect_custom_derive(item, attr);\n-        } else if attr.check_name(sym::proc_macro_attribute) {\n+        } else if self.sess.check_name(attr, sym::proc_macro_attribute) {\n             self.collect_attr_proc_macro(item);\n-        } else if attr.check_name(sym::proc_macro) {\n+        } else if self.sess.check_name(attr, sym::proc_macro) {\n             self.collect_bang_proc_macro(item);\n         };\n "}, {"sha": "52759fede75cefbe33b7617b99ef61333a75e023", "filename": "src/librustc_builtin_macros/standard_library_imports.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n+use rustc_ast::ast;\n use rustc_ast::ptr::P;\n-use rustc_ast::{ast, attr};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::ExpansionConfig;\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::AstPass;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -11,16 +11,16 @@ use rustc_span::DUMMY_SP;\n pub fn inject(\n     mut krate: ast::Crate,\n     resolver: &mut dyn ResolverExpand,\n-    sess: &ParseSess,\n+    sess: &Session,\n     alt_std_name: Option<Symbol>,\n ) -> (ast::Crate, Option<Symbol>) {\n-    let rust_2018 = sess.edition >= Edition::Edition2018;\n+    let rust_2018 = sess.parse_sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if sess.contains_name(&krate.attrs, sym::no_core) {\n         return (krate, None);\n-    } else if attr::contains_name(&krate.attrs, sym::no_std) {\n-        if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n+    } else if sess.contains_name(&krate.attrs, sym::no_std) {\n+        if sess.contains_name(&krate.attrs, sym::compiler_builtins) {\n             &[sym::core]\n         } else {\n             &[sym::core, sym::compiler_builtins]"}, {"sha": "00593c68cfc9a01dd03a04d1df04d872958b0cbf", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -6,6 +6,7 @@ use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::*;\n+use rustc_session::Session;\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -87,7 +88,7 @@ pub fn expand_test_or_bench(\n     };\n \n     if let ast::ItemKind::MacCall(_) = item.kind {\n-        cx.parse_sess.span_diagnostic.span_warn(\n+        cx.sess.parse_sess.span_diagnostic.span_warn(\n             item.span,\n             \"`#[test]` attribute should not be used on macros. Use `#[cfg(test)]` instead.\",\n         );\n@@ -232,9 +233,15 @@ pub fn expand_test_or_bench(\n                                         ),\n                                     ),\n                                     // ignore: true | false\n-                                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n+                                    field(\n+                                        \"ignore\",\n+                                        cx.expr_bool(sp, should_ignore(&cx.sess, &item)),\n+                                    ),\n                                     // allow_fail: true | false\n-                                    field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n+                                    field(\n+                                        \"allow_fail\",\n+                                        cx.expr_bool(sp, should_fail(&cx.sess, &item)),\n+                                    ),\n                                     // should_panic: ...\n                                     field(\n                                         \"should_panic\",\n@@ -318,18 +325,18 @@ enum ShouldPanic {\n     Yes(Option<Symbol>),\n }\n \n-fn should_ignore(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::ignore)\n+fn should_ignore(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::ignore)\n }\n \n-fn should_fail(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::allow_fail)\n+fn should_fail(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::allow_fail)\n }\n \n fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n-    match attr::find_by_name(&i.attrs, sym::should_panic) {\n+    match cx.sess.find_by_name(&i.attrs, sym::should_panic) {\n         Some(attr) => {\n-            let sd = &cx.parse_sess.span_diagnostic;\n+            let sd = &cx.sess.parse_sess.span_diagnostic;\n \n             match attr.meta_item_list() {\n                 // Handle #[should_panic(expected = \"foo\")]\n@@ -393,8 +400,8 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n }\n \n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_should_panic_attr = attr::contains_name(&i.attrs, sym::should_panic);\n-    let sd = &cx.parse_sess.span_diagnostic;\n+    let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n+    let sd = &cx.sess.parse_sess.span_diagnostic;\n     if let ast::ItemKind::Fn(_, ref sig, ref generics, _) = i.kind {\n         if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n             sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n@@ -453,7 +460,7 @@ fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     };\n \n     if !has_sig {\n-        cx.parse_sess.span_diagnostic.span_err(\n+        cx.sess.parse_sess.span_diagnostic.span_err(\n             i.span,\n             \"functions used as benches must have \\\n             signature `fn(&mut Bencher) -> impl Termination`\","}, {"sha": "a80763d6ec8e8d0439e80b39ca0a487312772807", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,13 +2,13 @@\n \n use rustc_ast::ast;\n use rustc_ast::attr;\n-use rustc_ast::entry::{self, EntryPointType};\n+use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n-use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::hygiene::{AstPass, SyntaxContext, Transparency};\n use rustc_span::source_map::respan;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -35,41 +35,35 @@ struct TestCtxt<'a> {\n \n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n-pub fn inject(\n-    sess: &ParseSess,\n-    resolver: &mut dyn ResolverExpand,\n-    should_test: bool,\n-    krate: &mut ast::Crate,\n-    span_diagnostic: &rustc_errors::Handler,\n-    features: &Features,\n-    panic_strategy: PanicStrategy,\n-    platform_panic_strategy: PanicStrategy,\n-    enable_panic_abort_tests: bool,\n-) {\n+pub fn inject(sess: &Session, resolver: &mut dyn ResolverExpand, krate: &mut ast::Crate) {\n+    let span_diagnostic = sess.diagnostic();\n+    let panic_strategy = sess.panic_strategy();\n+    let platform_panic_strategy = sess.target.target.options.panic_strategy;\n+\n     // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n     // main test function the name `some_name` without hygiene. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n+        sess.first_attr_value_str_by_name(&krate.attrs, sym::reexport_test_harness_main);\n \n     // Do this here so that the test_runner crate attribute gets marked as used\n     // even in non-test builds\n-    let test_runner = get_test_runner(span_diagnostic, &krate);\n+    let test_runner = get_test_runner(sess, span_diagnostic, &krate);\n \n-    if should_test {\n-        let panic_strategy = match (panic_strategy, enable_panic_abort_tests) {\n+    if sess.opts.test {\n+        let panic_strategy = match (panic_strategy, sess.opts.debugging_opts.panic_abort_tests) {\n             (PanicStrategy::Abort, true) => PanicStrategy::Abort,\n-            (PanicStrategy::Abort, false) if panic_strategy == platform_panic_strategy => {\n-                // Silently allow compiling with panic=abort on these platforms,\n-                // but with old behavior (abort if a test fails).\n-                PanicStrategy::Unwind\n-            }\n             (PanicStrategy::Abort, false) => {\n-                span_diagnostic.err(\n-                    \"building tests with panic=abort is not supported \\\n-                                     without `-Zpanic_abort_tests`\",\n-                );\n+                if panic_strategy == platform_panic_strategy {\n+                    // Silently allow compiling with panic=abort on these platforms,\n+                    // but with old behavior (abort if a test fails).\n+                } else {\n+                    span_diagnostic.err(\n+                        \"building tests with panic=abort is not supported \\\n+                                         without `-Zpanic_abort_tests`\",\n+                    );\n+                }\n                 PanicStrategy::Unwind\n             }\n             (PanicStrategy::Unwind, _) => PanicStrategy::Unwind,\n@@ -79,7 +73,7 @@ pub fn inject(\n             resolver,\n             reexport_test_harness_main,\n             krate,\n-            features,\n+            &sess.features_untracked(),\n             panic_strategy,\n             test_runner,\n         )\n@@ -101,7 +95,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if is_test_case(&item) {\n+        if is_test_case(&self.cx.ext_cx.sess, &item) {\n             debug!(\"this is a test item\");\n \n             let test = Test { span: item.span, ident: item.ident };\n@@ -143,15 +137,39 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     }\n }\n \n+// Beware, this is duplicated in librustc_passes/entry.rs (with\n+// `rustc_hir::Item`), so make sure to keep them in sync.\n+fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPointType {\n+    match item.kind {\n+        ast::ItemKind::Fn(..) => {\n+            if sess.contains_name(&item.attrs, sym::start) {\n+                EntryPointType::Start\n+            } else if sess.contains_name(&item.attrs, sym::main) {\n+                EntryPointType::MainAttr\n+            } else if item.ident.name == sym::main {\n+                if depth == 1 {\n+                    // This is a top-level function so can be 'main'\n+                    EntryPointType::MainNamed\n+                } else {\n+                    EntryPointType::OtherMain\n+                }\n+            } else {\n+                EntryPointType::None\n+            }\n+        }\n+        _ => EntryPointType::None,\n+    }\n+}\n /// A folder used to remove any entry points (like fn main) because the harness\n /// generator will provide its own\n-struct EntryPointCleaner {\n+struct EntryPointCleaner<'a> {\n     // Current depth in the ast\n+    sess: &'a Session,\n     depth: usize,\n     def_site: Span,\n }\n \n-impl MutVisitor for EntryPointCleaner {\n+impl<'a> MutVisitor for EntryPointCleaner<'a> {\n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         self.depth += 1;\n         let item = noop_flat_map_item(i, self).expect_one(\"noop did something\");\n@@ -160,7 +178,7 @@ impl MutVisitor for EntryPointCleaner {\n         // Remove any #[main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let item = match entry::entry_point_type(&item, self.depth) {\n+        let item = match entry_point_type(self.sess, &item, self.depth) {\n             EntryPointType::MainNamed | EntryPointType::MainAttr | EntryPointType::Start => item\n                 .map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n@@ -170,7 +188,10 @@ impl MutVisitor for EntryPointCleaner {\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n                     let attrs = attrs\n                         .into_iter()\n-                        .filter(|attr| !attr.check_name(sym::main) && !attr.check_name(sym::start))\n+                        .filter(|attr| {\n+                            !self.sess.check_name(attr, sym::main)\n+                                && !self.sess.check_name(attr, sym::start)\n+                        })\n                         .chain(iter::once(allow_dead_code))\n                         .collect();\n \n@@ -189,7 +210,7 @@ impl MutVisitor for EntryPointCleaner {\n \n /// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(\n-    sess: &ParseSess,\n+    sess: &Session,\n     resolver: &mut dyn ResolverExpand,\n     reexport_test_harness_main: Option<Symbol>,\n     krate: &mut ast::Crate,\n@@ -211,7 +232,7 @@ fn generate_test_harness(\n     let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n \n     // Remove the entry points\n-    let mut cleaner = EntryPointCleaner { depth: 0, def_site };\n+    let mut cleaner = EntryPointCleaner { sess, depth: 0, def_site };\n     cleaner.visit_crate(krate);\n \n     let cx = TestCtxt {\n@@ -339,12 +360,16 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn is_test_case(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, sym::rustc_test_marker)\n+fn is_test_case(sess: &Session, i: &ast::Item) -> bool {\n+    sess.contains_name(&i.attrs, sym::rustc_test_marker)\n }\n \n-fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n-    let test_attr = attr::find_by_name(&krate.attrs, sym::test_runner)?;\n+fn get_test_runner(\n+    sess: &Session,\n+    sd: &rustc_errors::Handler,\n+    krate: &ast::Crate,\n+) -> Option<ast::Path> {\n+    let test_attr = sess.find_by_name(&krate.attrs, sym::test_runner)?;\n     let meta_list = test_attr.meta_item_list()?;\n     let span = test_attr.span;\n     match &*meta_list {"}, {"sha": "3ee6cd739644061fa9517f5f191611f20aa4c59a", "filename": "src/librustc_builtin_macros/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_builtin_macros%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Futil.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -8,5 +8,5 @@ pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, na\n     // All the built-in macro attributes are \"words\" at the moment.\n     let template = AttributeTemplate { word: true, ..Default::default() };\n     let attr = ecx.attribute(meta_item.clone());\n-    validate_attr::check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n+    validate_attr::check_builtin_attribute(&ecx.sess.parse_sess, &attr, name, template);\n }"}, {"sha": "b977da733aa3290f2aec0f8e742b0ea9880f7f91", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -253,7 +253,7 @@ impl CodegenCx<'ll, 'tcx> {\n             debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n \n             for attr in attrs {\n-                if attr.check_name(sym::thread_local) {\n+                if self.tcx.sess.check_name(attr, sym::thread_local) {\n                     llvm::set_thread_local_mode(g, self.tls_model);\n                 }\n             }"}, {"sha": "a39234c0b7f66cecdb1ad820451583d3cfd9d050", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,7 +5,7 @@ use crate::llvm;\n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, Region};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_llvm::RustString;\n use tracing::debug;\n \n@@ -76,13 +76,12 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n }\n \n struct CoverageMapGenerator {\n-    filenames: Vec<CString>,\n-    filename_to_index: FxHashMap<CString, u32>,\n+    filenames: FxIndexSet<CString>,\n }\n \n impl CoverageMapGenerator {\n     fn new() -> Self {\n-        Self { filenames: Vec::new(), filename_to_index: FxHashMap::default() }\n+        Self { filenames: FxIndexSet::default() }\n     }\n \n     /// Using the `expressions` and `counter_regions` collected for the current function, generate\n@@ -122,16 +121,8 @@ impl CoverageMapGenerator {\n                 let c_filename =\n                     CString::new(file_name).expect(\"null error converting filename to C string\");\n                 debug!(\"  file_id: {} = '{:?}'\", current_file_id, c_filename);\n-                let filenames_index = match self.filename_to_index.get(&c_filename) {\n-                    Some(index) => *index,\n-                    None => {\n-                        let index = self.filenames.len() as u32;\n-                        self.filenames.push(c_filename.clone());\n-                        self.filename_to_index.insert(c_filename.clone(), index);\n-                        index\n-                    }\n-                };\n-                virtual_file_mapping.push(filenames_index);\n+                let (filenames_index, _) = self.filenames.insert_full(c_filename);\n+                virtual_file_mapping.push(filenames_index as u32);\n             }\n             mapping_regions.push(CounterMappingRegion::code_region(\n                 counter,"}, {"sha": "d7c98e9a62492807d717b02978007feda9fcae39", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -97,8 +97,11 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer: &RustString) {\n-    let c_str_vec = filenames.iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n+pub(crate) fn write_filenames_section_to_buffer<'a>(\n+    filenames: impl IntoIterator<Item = &'a CString>,\n+    buffer: &RustString,\n+) {\n+    let c_str_vec = filenames.into_iter().map(|cstring| cstring.as_ptr()).collect::<Vec<_>>();\n     unsafe {\n         llvm::LLVMRustCoverageWriteFilenamesSectionToBuffer(\n             c_str_vec.as_ptr(),"}, {"sha": "29edd66049cdcf1acebfa5fa50da949dabdab749", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -9,7 +9,6 @@ use rustc_codegen_ssa::traits::*;\n use rustc_middle::bug;\n use rustc_session::config::DebugInfo;\n \n-use rustc_ast::attr;\n use rustc_span::symbol::sym;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n@@ -61,8 +60,10 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>) -\n }\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n-    let omit_gdb_pretty_printer_section =\n-        attr::contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+    let omit_gdb_pretty_printer_section = cx\n+        .tcx\n+        .sess\n+        .contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     !omit_gdb_pretty_printer_section\n         && cx.sess().opts.debuginfo != DebugInfo::None"}, {"sha": "f288135596265278f54604341f720544ac8b91ce", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -960,15 +960,15 @@ fn pointer_type_metadata(\n fn param_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n     debug!(\"param_type_metadata: {:?}\", t);\n     let name = format!(\"{:?}\", t);\n-    return unsafe {\n+    unsafe {\n         llvm::LLVMRustDIBuilderCreateBasicType(\n             DIB(cx),\n             name.as_ptr().cast(),\n             name.len(),\n             Size::ZERO.bits(),\n             DW_ATE_unsigned,\n         )\n-    };\n+    }\n }\n \n pub fn compile_unit_metadata("}, {"sha": "6912667c391d0cff4a7eb815c381a9b4b833fb8a", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1295,7 +1295,9 @@ fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n         Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n         // FIXME: Find some heuristic for \"native mingw toolchain is available\",\n         // likely based on `get_crt_libs_path` (https://github.com/rust-lang/rust/pull/67429).\n-        Some(CrtObjectsFallback::Mingw) => sess.target.target.target_vendor != \"uwp\",\n+        Some(CrtObjectsFallback::Mingw) => {\n+            sess.host == sess.target.target && sess.target.target.target_vendor != \"uwp\"\n+        }\n         // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n         Some(CrtObjectsFallback::Wasm) => true,\n         None => false,"}, {"sha": "7d69bb983dd744c2f5a9bf51226c98076930866f", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -9,7 +9,6 @@ use crate::{\n \n use crate::traits::*;\n use jobserver::{Acquired, Client};\n-use rustc_ast::attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::profiling::TimingGuard;\n@@ -416,11 +415,12 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n \n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n-    let no_builtins = attr::contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n+    let no_builtins = tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_builtins);\n     let is_compiler_builtins =\n-        attr::contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n-    let subsystem =\n-        attr::first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n+        tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::compiler_builtins);\n+    let subsystem = tcx\n+        .sess\n+        .first_attr_value_str_by_name(&tcx.hir().krate().item.attrs, sym::windows_subsystem);\n     let windows_subsystem = subsystem.map(|subsystem| {\n         if subsystem != sym::windows && subsystem != sym::console {\n             tcx.sess.fatal(&format!(\n@@ -490,7 +490,7 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n     let _timer = sess.timer(\"copy_all_cgu_workproducts_to_incr_comp_cache_dir\");\n \n     for module in compiled_modules.modules.iter().filter(|m| m.kind == ModuleKind::Regular) {\n-        let path = module.object.as_ref().map(|path| path.clone());\n+        let path = module.object.as_ref().cloned();\n \n         if let Some((id, product)) =\n             copy_cgu_workproduct_to_incr_comp_cache_dir(sess, &module.name, &path)"}, {"sha": "05656774f0e9556cfefeee295ad905e548e30976", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -253,14 +253,13 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n                     bx.sub(tag, bx.cx().const_uint_big(niche_llty, niche_start))\n                 };\n                 let relative_max = niche_variants.end().as_u32() - niche_variants.start().as_u32();\n-                let is_niche = {\n-                    let relative_max = if relative_max == 0 {\n-                        // Avoid calling `const_uint`, which wouldn't work for pointers.\n-                        // FIXME(eddyb) check the actual primitive type here.\n-                        bx.cx().const_null(niche_llty)\n-                    } else {\n-                        bx.cx().const_uint(niche_llty, relative_max as u64)\n-                    };\n+                let is_niche = if relative_max == 0 {\n+                    // Avoid calling `const_uint`, which wouldn't work for pointers.\n+                    // Also use canonical == 0 instead of non-canonical u<= 0.\n+                    // FIXME(eddyb) check the actual primitive type here.\n+                    bx.icmp(IntPredicate::IntEQ, relative_discr, bx.cx().const_null(niche_llty))\n+                } else {\n+                    let relative_max = bx.cx().const_uint(niche_llty, relative_max as u64);\n                     bx.icmp(IntPredicate::IntULE, relative_discr, relative_max)\n                 };\n "}, {"sha": "fda0fc5973bef3498447d8ed99bd714d53bd4e5e", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n ena = \"0.14\"\n-indexmap = \"1\"\n+indexmap = \"1.5.1\"\n tracing = \"0.1\"\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\""}, {"sha": "7d137a55033f7ac89ee6e3a038c3f78a1c451b5f", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-use crate::fx::FxHashMap;\n+use crate::fx::FxIndexSet;\n use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n@@ -13,10 +13,7 @@ mod tests;\n #[derive(Clone, Debug)]\n pub struct TransitiveRelation<T: Eq + Hash> {\n     // List of elements. This is used to map from a T to a usize.\n-    elements: Vec<T>,\n-\n-    // Maps each element to an index.\n-    map: FxHashMap<T, Index>,\n+    elements: FxIndexSet<T>,\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n@@ -39,7 +36,6 @@ impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     fn default() -> Self {\n         TransitiveRelation {\n             elements: Default::default(),\n-            map: Default::default(),\n             edges: Default::default(),\n             closure: Default::default(),\n         }\n@@ -65,20 +61,16 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.map.get(a).cloned()\n+        self.elements.get_index_of(a).map(Index)\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        let &mut TransitiveRelation { ref mut elements, ref mut closure, ref mut map, .. } = self;\n-\n-        *map.entry(a.clone()).or_insert_with(|| {\n-            elements.push(a);\n-\n+        let (index, added) = self.elements.insert_full(a);\n+        if added {\n             // if we changed the dimensions, clear the cache\n-            *closure.get_mut() = None;\n-\n-            Index(elements.len() - 1)\n-        })\n+            *self.closure.get_mut() = None;\n+        }\n+        Index(index)\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n@@ -430,14 +422,11 @@ where\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n-            let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            let map = elements\n-                .iter()\n-                .enumerate()\n-                .map(|(index, elem)| (elem.clone(), Index(index)))\n-                .collect();\n-            Ok(TransitiveRelation { elements, edges, map, closure: Lock::new(None) })\n+            Ok(TransitiveRelation {\n+                elements: d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?,\n+                edges: d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?,\n+                closure: Lock::new(None),\n+            })\n         })\n     }\n }\n@@ -452,8 +441,6 @@ where\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n-            // \"map\" is just a copy of elements vec\n-            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _,\n         } = *self;"}, {"sha": "cc954cee9077d8df50e6cd1e52810f42506a15f5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -677,7 +677,7 @@ impl RustcDefaultCalls {\n                     let t_outputs = rustc_interface::util::build_output_filenames(\n                         input, odir, ofile, attrs, sess,\n                     );\n-                    let id = rustc_session::output::find_crate_name(Some(sess), attrs, input);\n+                    let id = rustc_session::output::find_crate_name(sess, attrs, input);\n                     if *req == PrintRequest::CrateName {\n                         println!(\"{}\", id);\n                         continue;"}, {"sha": "ddd245b1a2b1b7ea6f1ab08a8a459ed7795a2e98", "filename": "src/librustc_error_codes/error_codes/E0271.md", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,25 +5,6 @@ Erroneous code example:\n ```compile_fail,E0271\n trait Trait { type AssociatedType; }\n \n-fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-\n-foo(3_i8);\n-```\n-\n-This is because of a type mismatch between the associated type of some\n-trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n-and another type `U` that is required to be equal to `T::Bar`, but is not.\n-Examples follow.\n-\n-Here is that same example again, with some explanatory comments:\n-\n-```compile_fail,E0271\n-trait Trait { type AssociatedType; }\n-\n fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n //                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n //                        |            |\n@@ -56,11 +37,9 @@ foo(3_i8);\n // therefore the type-checker complains with this error code.\n ```\n \n-To avoid those issues, you have to make the types match correctly.\n-So we can fix the previous examples like this:\n-\n+The issue can be resolved by changing the associated type:\n+1) in the `foo` implementation:\n ```\n-// Basic Example:\n trait Trait { type AssociatedType; }\n \n fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n@@ -70,13 +49,17 @@ fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n impl Trait for i8 { type AssociatedType = &'static str; }\n \n foo(3_i8);\n+```\n \n-// For-Loop Example:\n-let vs = vec![1, 2, 3, 4];\n-for v in &vs {\n-    match v {\n-        &1 => {}\n-        _ => {}\n-    }\n+2) in the `Trait` implementation for `i8`:\n+```\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n+    println!(\"in foo\");\n }\n+\n+impl Trait for i8 { type AssociatedType = u32; }\n+\n+foo(3_i8);\n ```"}, {"sha": "dc3ffdfddd9de772a5317fca6857ccab7e52a483", "filename": "src/librustc_error_codes/error_codes/E0502.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,7 +5,7 @@ Erroneous code example:\n ```compile_fail,E0502\n fn bar(x: &mut i32) {}\n fn foo(a: &mut i32) {\n-    let ref y = a; // a is borrowed as immutable.\n+    let y = &a; // a is borrowed as immutable.\n     bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n             //        as immutable\n     println!(\"{}\", y);\n@@ -19,7 +19,7 @@ variable before trying to access it mutably:\n fn bar(x: &mut i32) {}\n fn foo(a: &mut i32) {\n     bar(a);\n-    let ref y = a; // ok!\n+    let y = &a; // ok!\n     println!(\"{}\", y);\n }\n ```"}, {"sha": "90755d47f67901188c93af03764be6c1985ab6f7", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-Return types cannot be `dyn Trait`s as they must be `Sized`.\n+An unboxed trait object was used as a return value.\n \n Erroneous code example:\n \n@@ -13,11 +13,13 @@ impl T for S {\n \n // Having the trait `T` as return type is invalid because\n // unboxed trait objects do not have a statically known size:\n-fn foo() -> dyn T {\n+fn foo() -> dyn T { // error!\n     S(42)\n }\n ```\n \n+Return types cannot be `dyn Trait`s as they must be `Sized`.\n+\n To avoid the error there are a couple of options.\n \n If there is a single type involved, you can use [`impl Trait`]:\n@@ -32,7 +34,7 @@ If there is a single type involved, you can use [`impl Trait`]:\n # }\n // The compiler will select `S(usize)` as the materialized return type of this\n // function, but callers will only know that the return type implements `T`.\n-fn foo() -> impl T {\n+fn foo() -> impl T { // ok!\n     S(42)\n }\n ```\n@@ -57,7 +59,7 @@ impl T for O {\n \n // This now returns a \"trait object\" and callers are only be able to access\n // associated items from `T`.\n-fn foo(x: bool) -> Box<dyn T> {\n+fn foo(x: bool) -> Box<dyn T> { // ok!\n     if x {\n         Box::new(S(42))\n     } else {"}, {"sha": "caf7e0fba07a343aaf1e1238b3fcd10795b87c49", "filename": "src/librustc_error_codes/error_codes/E0747.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0747.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0747.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0747.md?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-Generic arguments must be provided in the same order as the corresponding\n+Generic arguments were not provided in the same order as the corresponding\n generic parameters are declared.\n \n Erroneous code example:\n@@ -11,7 +11,7 @@ type X = S<(), 'static>; // error: the type argument is provided before the\n ```\n \n The argument order should be changed to match the parameter declaration\n-order, as in the following.\n+order, as in the following:\n \n ```\n struct S<'a, T>(&'a T);"}, {"sha": "7a1a745b53c12b606b49b93d7ae2bdb0ae158734", "filename": "src/librustc_error_codes/error_codes/E0749.md", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0749.md?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,19 @@\n-Negative impls are not allowed to have any items. Negative impls\n-declare that a trait is **not** implemented (and never will be) and\n-hence there is no need to specify the values for trait methods or\n-other items.\n+An item was added on a negative impl.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0749\n+# #![feature(negative_impls)]\n+trait MyTrait {\n+    type Foo;\n+}\n+\n+impl !MyTrait for u32 {\n+    type Foo = i32; // error!\n+}\n+# fn main() {}\n+```\n+\n+Negative impls are not allowed to have any items. Negative impls declare that a\n+trait is **not** implemented (and never will be) and hence there is no need to\n+specify the values for trait methods or other items."}, {"sha": "905e852f8d579e60e9984aa12fea4e42adb1ca81", "filename": "src/librustc_error_codes/error_codes/E0750.md", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0750.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_error_codes%2Ferror_codes%2FE0750.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0750.md?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,18 @@\n-Negative impls cannot be default impls. A default impl supplies\n-default values for the items within to be used by other impls, whereas\n-a negative impl declares that there are no other impls. These don't\n-make sense to combine.\n+A negative impl was made default impl.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0750\n+# #![feature(negative_impls)]\n+# #![feature(specialization)]\n+trait MyTrait {\n+    type Foo;\n+}\n+\n+default impl !MyTrait for u32 {} // error!\n+# fn main() {}\n+```\n+\n+Negative impls cannot be default impls. A default impl supplies default values\n+for the items within to be used by other impls, whereas a negative impl declares\n+that there are no other impls. Combining it does not make sense."}, {"sha": "5a36df8299c0b5795d5433f4c44e2886a8ad03d8", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n-use rustc_session::{parse::ParseSess, Limit};\n+use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n@@ -790,35 +790,37 @@ impl SyntaxExtension {\n     /// Constructs a syntax extension with the given properties\n     /// and other properties converted from attributes.\n     pub fn new(\n-        sess: &ParseSess,\n+        sess: &Session,\n         kind: SyntaxExtensionKind,\n         span: Span,\n         helper_attrs: Vec<Symbol>,\n         edition: Edition,\n         name: Symbol,\n         attrs: &[ast::Attribute],\n     ) -> SyntaxExtension {\n-        let allow_internal_unstable = attr::allow_internal_unstable(&attrs, &sess.span_diagnostic)\n+        let allow_internal_unstable = attr::allow_internal_unstable(sess, &attrs)\n             .map(|features| features.collect::<Vec<Symbol>>().into());\n \n         let mut local_inner_macros = false;\n-        if let Some(macro_export) = attr::find_by_name(attrs, sym::macro_export) {\n+        if let Some(macro_export) = sess.find_by_name(attrs, sym::macro_export) {\n             if let Some(l) = macro_export.meta_item_list() {\n                 local_inner_macros = attr::list_contains_name(&l, sym::local_inner_macros);\n             }\n         }\n \n-        let is_builtin = attr::contains_name(attrs, sym::rustc_builtin_macro);\n+        let is_builtin = sess.contains_name(attrs, sym::rustc_builtin_macro);\n         let (stability, const_stability) = attr::find_stability(&sess, attrs, span);\n         if const_stability.is_some() {\n-            sess.span_diagnostic.span_err(span, \"macros cannot have const stability attributes\");\n+            sess.parse_sess\n+                .span_diagnostic\n+                .span_err(span, \"macros cannot have const stability attributes\");\n         }\n \n         SyntaxExtension {\n             kind,\n             span,\n             allow_internal_unstable,\n-            allow_internal_unsafe: attr::contains_name(attrs, sym::allow_internal_unsafe),\n+            allow_internal_unsafe: sess.contains_name(attrs, sym::allow_internal_unsafe),\n             local_inner_macros,\n             stability,\n             deprecation: attr::find_deprecation(&sess, attrs, span),\n@@ -941,7 +943,7 @@ pub struct ExpansionData {\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n /// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n-    pub parse_sess: &'a ParseSess,\n+    pub sess: &'a Session,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub reduced_recursion_limit: Option<Limit>,\n     pub root_path: PathBuf,\n@@ -954,13 +956,13 @@ pub struct ExtCtxt<'a> {\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n-        parse_sess: &'a ParseSess,\n+        sess: &'a Session,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn ResolverExpand,\n         extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n-            parse_sess,\n+            sess,\n             ecfg,\n             reduced_recursion_limit: None,\n             resolver,\n@@ -988,13 +990,13 @@ impl<'a> ExtCtxt<'a> {\n         expand::MacroExpander::new(self, true)\n     }\n     pub fn new_parser_from_tts(&self, stream: TokenStream) -> parser::Parser<'a> {\n-        rustc_parse::stream_to_parser(self.parse_sess, stream, MACRO_ARGUMENTS)\n+        rustc_parse::stream_to_parser(&self.sess.parse_sess, stream, MACRO_ARGUMENTS)\n     }\n     pub fn source_map(&self) -> &'a SourceMap {\n-        self.parse_sess.source_map()\n+        self.sess.parse_sess.source_map()\n     }\n     pub fn parse_sess(&self) -> &'a ParseSess {\n-        self.parse_sess\n+        &self.sess.parse_sess\n     }\n     pub fn call_site(&self) -> Span {\n         self.current_expansion.id.expn_data().call_site\n@@ -1026,7 +1028,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn struct_span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> DiagnosticBuilder<'a> {\n-        self.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n+        self.sess.parse_sess.span_diagnostic.struct_span_err(sp, msg)\n     }\n \n     /// Emit `msg` attached to `sp`, without immediately stopping\n@@ -1035,17 +1037,17 @@ impl<'a> ExtCtxt<'a> {\n     /// Compilation will be stopped in the near future (at the end of\n     /// the macro expansion phase).\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.parse_sess.span_diagnostic.span_err(sp, msg);\n+        self.sess.parse_sess.span_diagnostic.span_err(sp, msg);\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.parse_sess.span_diagnostic.span_warn(sp, msg);\n+        self.sess.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.span_bug(sp, msg);\n+        self.sess.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }\n     pub fn trace_macros_diag(&mut self) {\n         for (sp, notes) in self.expansions.iter() {\n-            let mut db = self.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n+            let mut db = self.sess.parse_sess.span_diagnostic.span_note_diag(*sp, \"trace_macro\");\n             for note in notes {\n                 db.note(note);\n             }\n@@ -1055,7 +1057,7 @@ impl<'a> ExtCtxt<'a> {\n         self.expansions.clear();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.bug(msg);\n+        self.sess.parse_sess.span_diagnostic.bug(msg);\n     }\n     pub fn trace_macros(&self) -> bool {\n         self.ecfg.trace_mac"}, {"sha": "f6ddcd35068c86a5e35a95778bb3654728ca3e75", "filename": "src/librustc_expand/config.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fconfig.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -13,7 +13,8 @@ use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n };\n use rustc_parse::{parse_in, validate_attr};\n-use rustc_session::parse::{feature_err, ParseSess};\n+use rustc_session::parse::feature_err;\n+use rustc_session::Session;\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -22,15 +23,14 @@ use smallvec::SmallVec;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n-    pub sess: &'a ParseSess,\n+    pub sess: &'a Session,\n     pub features: Option<&'a Features>,\n }\n \n fn get_features(\n+    sess: &Session,\n     span_handler: &Handler,\n     krate_attrs: &[ast::Attribute],\n-    crate_edition: Edition,\n-    allow_features: &Option<Vec<String>>,\n ) -> Features {\n     fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n         let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n@@ -53,6 +53,7 @@ fn get_features(\n \n     let mut features = Features::default();\n     let mut edition_enabled_features = FxHashMap::default();\n+    let crate_edition = sess.edition();\n \n     for &edition in ALL_EDITIONS {\n         if edition <= crate_edition {\n@@ -70,7 +71,7 @@ fn get_features(\n     // Process the edition umbrella feature-gates first, to ensure\n     // `edition_enabled_features` is completed before it's queried.\n     for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n+        if !sess.check_name(attr, sym::feature) {\n             continue;\n         }\n \n@@ -103,7 +104,7 @@ fn get_features(\n     }\n \n     for attr in krate_attrs {\n-        if !attr.check_name(sym::feature) {\n+        if !sess.check_name(attr, sym::feature) {\n             continue;\n         }\n \n@@ -165,7 +166,7 @@ fn get_features(\n                 continue;\n             }\n \n-            if let Some(allowed) = allow_features.as_ref() {\n+            if let Some(allowed) = sess.opts.debugging_opts.allow_features.as_ref() {\n                 if allowed.iter().find(|&f| name.as_str() == *f).is_none() {\n                     struct_span_err!(\n                         span_handler,\n@@ -193,16 +194,11 @@ fn get_features(\n }\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(\n-    mut krate: ast::Crate,\n-    sess: &ParseSess,\n-    edition: Edition,\n-    allow_features: &Option<Vec<String>>,\n-) -> (ast::Crate, Features) {\n+pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features) {\n     let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n \n     let unconfigured_attrs = krate.attrs.clone();\n-    let diag = &sess.span_diagnostic;\n+    let diag = &sess.parse_sess.span_diagnostic;\n     let err_count = diag.err_count();\n     let features = match strip_unconfigured.configure(krate.attrs) {\n         None => {\n@@ -213,7 +209,7 @@ pub fn features(\n         }\n         Some(attrs) => {\n             krate.attrs = attrs;\n-            let features = get_features(diag, &krate.attrs, edition, allow_features);\n+            let features = get_features(sess, diag, &krate.attrs);\n             if err_count == diag.err_count() {\n                 // Avoid reconfiguring malformed `cfg_attr`s.\n                 strip_unconfigured.features = Some(&features);\n@@ -281,9 +277,9 @@ impl<'a> StripUnconfigured<'a> {\n         }\n \n         // At this point we know the attribute is considered used.\n-        attr::mark_used(&attr);\n+        self.sess.mark_attr_used(&attr);\n \n-        if !attr::cfg_matches(&cfg_predicate, self.sess, self.features) {\n+        if !attr::cfg_matches(&cfg_predicate, &self.sess.parse_sess, self.features) {\n             return vec![];\n         }\n \n@@ -303,8 +299,10 @@ impl<'a> StripUnconfigured<'a> {\n         match attr.get_normal_item().args {\n             ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n                 let msg = \"wrong `cfg_attr` delimiters\";\n-                validate_attr::check_meta_bad_delim(self.sess, dspan, delim, msg);\n-                match parse_in(self.sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+                validate_attr::check_meta_bad_delim(&self.sess.parse_sess, dspan, delim, msg);\n+                match parse_in(&self.sess.parse_sess, tts.clone(), \"`cfg_attr` input\", |p| {\n+                    p.parse_cfg_attr()\n+                }) {\n                     Ok(r) => return Some(r),\n                     Err(mut e) => {\n                         e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n@@ -320,6 +318,7 @@ impl<'a> StripUnconfigured<'a> {\n \n     fn error_malformed_cfg_attr_missing(&self, span: Span) {\n         self.sess\n+            .parse_sess\n             .span_diagnostic\n             .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n             .span_suggestion(\n@@ -335,18 +334,18 @@ impl<'a> StripUnconfigured<'a> {\n     /// Determines if a node with the given attributes should be included in this configuration.\n     pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n-            if !is_cfg(attr) {\n+            if !is_cfg(self.sess, attr) {\n                 return true;\n             }\n-            let meta_item = match validate_attr::parse_meta(self.sess, attr) {\n+            let meta_item = match validate_attr::parse_meta(&self.sess.parse_sess, attr) {\n                 Ok(meta_item) => meta_item,\n                 Err(mut err) => {\n                     err.emit();\n                     return true;\n                 }\n             };\n             let error = |span, msg, suggestion: &str| {\n-                let mut err = self.sess.span_diagnostic.struct_span_err(span, msg);\n+                let mut err = self.sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n                 if !suggestion.is_empty() {\n                     err.span_suggestion(\n                         span,\n@@ -364,7 +363,9 @@ impl<'a> StripUnconfigured<'a> {\n                 Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n                 Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n                 Some([single]) => match single.meta_item() {\n-                    Some(meta_item) => attr::cfg_matches(meta_item, self.sess, self.features),\n+                    Some(meta_item) => {\n+                        attr::cfg_matches(meta_item, &self.sess.parse_sess, self.features)\n+                    }\n                     None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n                 },\n             }\n@@ -383,7 +384,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(\n-                self.sess,\n+                &self.sess.parse_sess,\n                 sym::stmt_expr_attributes,\n                 attr.span,\n                 \"attributes on expressions are experimental\",\n@@ -452,9 +453,9 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(self.sess, a)) {\n             let msg = \"removing an expression is not supported in this position\";\n-            self.sess.span_diagnostic.span_err(attr.span, msg);\n+            self.sess.parse_sess.span_diagnostic.span_err(attr.span, msg);\n         }\n \n         self.process_cfg_attrs(expr)\n@@ -527,6 +528,6 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n     }\n }\n \n-fn is_cfg(attr: &Attribute) -> bool {\n-    attr.check_name(sym::cfg)\n+fn is_cfg(sess: &Session, attr: &Attribute) -> bool {\n+    sess.check_name(attr, sym::cfg)\n }"}, {"sha": "8da56dc67e59c3b14bdb397beb53ca4751ff64a9", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -527,7 +527,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn error_derive_forbidden_on_non_adt(&self, derives: &[Path], item: &Annotatable) {\n-        let attr = attr::find_by_name(item.attrs(), sym::derive);\n+        let attr = self.cx.sess.find_by_name(item.attrs(), sym::derive);\n         let span = attr.map_or(item.span(), |attr| attr.span);\n         let mut err = self\n             .cx\n@@ -566,10 +566,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let invocations = {\n             let mut collector = InvocationCollector {\n-                cfg: StripUnconfigured {\n-                    sess: self.cx.parse_sess,\n-                    features: self.cx.ecfg.features,\n-                },\n+                cfg: StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n@@ -589,8 +586,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n-        let mut cfg =\n-            StripUnconfigured { sess: self.cx.parse_sess, features: self.cx.ecfg.features };\n+        let mut cfg = StripUnconfigured { sess: &self.cx.sess, features: self.cx.ecfg.features };\n         // Since the item itself has already been configured by the InvocationCollector,\n         // we know that fold result vector will contain exactly one element\n         match item {\n@@ -706,7 +702,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let tokens = item.into_tokens(self.cx.parse_sess);\n+                    let tokens = item.into_tokens(&self.cx.sess.parse_sess);\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n@@ -719,7 +715,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.parse_ast_fragment(tok_result, fragment_kind, &attr_item.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyAttr(expander) => {\n-                    match validate_attr::parse_meta(self.cx.parse_sess, &attr) {\n+                    match validate_attr::parse_meta(&self.cx.sess.parse_sess, &attr) {\n                         Ok(meta) => {\n                             let items = match expander.expand(self.cx, span, &meta, item) {\n                                 ExpandResult::Ready(items) => items,\n@@ -748,9 +744,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     }\n                 }\n                 SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n-                    attr::mark_known(&attr);\n+                    self.cx.sess.mark_attr_known(&attr);\n                     if *mark_used {\n-                        attr::mark_used(&attr);\n+                        self.cx.sess.mark_attr_used(&attr);\n                     }\n                     item.visit_attrs(|attrs| attrs.push(attr));\n                     fragment_kind.expect_from_annotatables(iter::once(item))\n@@ -808,7 +804,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return;\n         }\n         feature_err(\n-            self.cx.parse_sess,\n+            &self.cx.sess.parse_sess,\n             sym::proc_macro_hygiene,\n             span,\n             &format!(\"custom attributes cannot be applied to {}\", kind),\n@@ -843,7 +839,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if !self.cx.ecfg.proc_macro_hygiene() {\n-            annotatable.visit_with(&mut GateProcMacroInput { parse_sess: self.cx.parse_sess });\n+            annotatable\n+                .visit_with(&mut GateProcMacroInput { parse_sess: &self.cx.sess.parse_sess });\n         }\n     }\n \n@@ -989,7 +986,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 ..ExpnData::default(\n                     ExpnKind::Macro(MacroKind::Attr, sym::derive),\n                     item.span(),\n-                    self.cx.parse_sess.edition,\n+                    self.cx.sess.parse_sess.edition,\n                     None,\n                 )\n             }),\n@@ -1049,7 +1046,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 if a.has_name(sym::derive) {\n                     *after_derive = true;\n                 }\n-                !attr::is_known(a) && !is_builtin_attr(a)\n+                !self.cx.sess.is_attr_known(a) && !is_builtin_attr(a)\n             })\n             .map(|i| attrs.remove(i));\n         if let Some(attr) = &attr {\n@@ -1058,7 +1055,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 && !attr.has_name(sym::test)\n             {\n                 feature_err(\n-                    &self.cx.parse_sess,\n+                    &self.cx.sess.parse_sess,\n                     sym::custom_inner_attributes,\n                     attr.span,\n                     \"non-builtin inner attributes are unstable\",\n@@ -1109,8 +1106,8 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn check_attributes(&mut self, attrs: &[ast::Attribute]) {\n         let features = self.cx.ecfg.features.unwrap();\n         for attr in attrs.iter() {\n-            rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.parse_sess, features);\n-            validate_attr::check_meta(self.cx.parse_sess, attr);\n+            rustc_ast_passes::feature_gate::check_attribute(attr, self.cx.sess, features);\n+            validate_attr::check_meta(&self.cx.sess.parse_sess, attr);\n \n             // macros are expanded before any lint passes so this warning has to be hardcoded\n             if attr.has_name(sym::derive) {\n@@ -1123,7 +1120,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             }\n \n             if attr.doc_str().is_some() {\n-                self.cx.parse_sess.buffer_lint_with_diagnostic(\n+                self.cx.sess.parse_sess.buffer_lint_with_diagnostic(\n                     &UNUSED_DOC_COMMENTS,\n                     attr.span,\n                     ast::CRATE_NODE_ID,\n@@ -1429,7 +1426,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n-                let sess = self.cx.parse_sess;\n+                let sess = &self.cx.sess.parse_sess;\n                 let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n \n@@ -1438,11 +1435,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 let Directory { ownership, path } = if old_mod.inline {\n                     // Inline `mod foo { ... }`, but we still need to push directories.\n                     item.attrs = attrs;\n-                    push_directory(ident, &item.attrs, dir)\n+                    push_directory(&self.cx.sess, ident, &item.attrs, dir)\n                 } else {\n                     // We have an outline `mod foo;` so we need to parse the file.\n                     let (new_mod, dir) =\n-                        parse_external_mod(sess, ident, span, dir, &mut attrs, pushed);\n+                        parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n \n                     let krate = ast::Crate {\n                         span: new_mod.inner,\n@@ -1639,7 +1636,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     fn visit_attribute(&mut self, at: &mut ast::Attribute) {\n         // turn `#[doc(include=\"filename\")]` attributes into `#[doc(include(file=\"filename\",\n         // contents=\"file contents\")]` attributes\n-        if !at.check_name(sym::doc) {\n+        if !self.cx.sess.check_name(at, sym::doc) {\n             return noop_visit_attribute(at, self);\n         }\n \n@@ -1660,9 +1657,9 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 }\n \n                 if let Some(file) = it.value_str() {\n-                    let err_count = self.cx.parse_sess.span_diagnostic.err_count();\n+                    let err_count = self.cx.sess.parse_sess.span_diagnostic.err_count();\n                     self.check_attributes(slice::from_ref(at));\n-                    if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n+                    if self.cx.sess.parse_sess.span_diagnostic.err_count() > err_count {\n                         // avoid loading the file if they haven't enabled the feature\n                         return noop_visit_attribute(at, self);\n                     }"}, {"sha": "15b2c14a2576c44ccd76af165dae3d34d3cada6f", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -19,6 +19,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n@@ -217,7 +218,7 @@ fn generic_extension<'cx>(\n     lhses: &[mbe::TokenTree],\n     rhses: &[mbe::TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n-    let sess = cx.parse_sess;\n+    let sess = &cx.sess.parse_sess;\n \n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(&arg));\n@@ -378,7 +379,7 @@ fn generic_extension<'cx>(\n \n /// Converts a macro item into a syntax extension.\n pub fn compile_declarative_macro(\n-    sess: &ParseSess,\n+    sess: &Session,\n     features: &Features,\n     def: &ast::Item,\n     edition: Edition,\n@@ -396,7 +397,7 @@ pub fn compile_declarative_macro(\n         )\n     };\n \n-    let diag = &sess.span_diagnostic;\n+    let diag = &sess.parse_sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n     let tt_spec = Some(NonterminalKind::TT);\n@@ -444,17 +445,20 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let parser = Parser::new(sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n+    let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n             let s = parse_failure_msg(&token);\n             let sp = token.span.substitute_dummy(def.span);\n-            sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n+            sess.parse_sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n             return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n         Error(sp, msg) => {\n-            sess.span_diagnostic.struct_span_err(sp.substitute_dummy(def.span), &msg).emit();\n+            sess.parse_sess\n+                .span_diagnostic\n+                .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                .emit();\n             return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n         }\n         ErrorReported => {\n@@ -471,17 +475,18 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        let tt = mbe::quoted::parse(tt.clone().into(), true, sess, def.id)\n-                            .pop()\n-                            .unwrap();\n-                        valid &= check_lhs_nt_follows(sess, features, &def.attrs, &tt);\n+                        let tt =\n+                            mbe::quoted::parse(tt.clone().into(), true, &sess.parse_sess, def.id)\n+                                .pop()\n+                                .unwrap();\n+                        valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def.attrs, &tt);\n                         return tt;\n                     }\n                 }\n-                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n+                sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n             .collect::<Vec<mbe::TokenTree>>(),\n-        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n+        _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n     let rhses = match argument_map[&MacroRulesNormalizedIdent::new(rhs_nm)] {\n@@ -490,29 +495,34 @@ pub fn compile_declarative_macro(\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n                     if let NtTT(ref tt) = **nt {\n-                        return mbe::quoted::parse(tt.clone().into(), false, sess, def.id)\n-                            .pop()\n-                            .unwrap();\n+                        return mbe::quoted::parse(\n+                            tt.clone().into(),\n+                            false,\n+                            &sess.parse_sess,\n+                            def.id,\n+                        )\n+                        .pop()\n+                        .unwrap();\n                     }\n                 }\n-                sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n+                sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n             .collect::<Vec<mbe::TokenTree>>(),\n-        _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\"),\n+        _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured rhs\"),\n     };\n \n     for rhs in &rhses {\n-        valid &= check_rhs(sess, rhs);\n+        valid &= check_rhs(&sess.parse_sess, rhs);\n     }\n \n     // don't abort iteration early, so that errors for multiple lhses can be reported\n     for lhs in &lhses {\n-        valid &= check_lhs_no_empty_seq(sess, slice::from_ref(lhs));\n+        valid &= check_lhs_no_empty_seq(&sess.parse_sess, slice::from_ref(lhs));\n     }\n \n-    valid &= macro_check::check_meta_variables(sess, def.id, def.span, &lhses, &rhses);\n+    valid &= macro_check::check_meta_variables(&sess.parse_sess, def.id, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n+    let (transparency, transparency_error) = attr::find_transparency(sess, &def.attrs, macro_rules);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) => {\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value))"}, {"sha": "12fe49ed585f06fb01b04d158a0366ec9265e43d", "filename": "src/librustc_expand/module.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmodule.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,9 @@\n use rustc_ast::ast::{Attribute, Mod};\n-use rustc_ast::{attr, token};\n+use rustc_ast::token;\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n+use rustc_session::Session;\n use rustc_span::source_map::{FileName, Span};\n use rustc_span::symbol::{sym, Ident};\n \n@@ -39,7 +40,7 @@ pub struct ModulePathSuccess {\n }\n \n crate fn parse_external_mod(\n-    sess: &ParseSess,\n+    sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n     Directory { mut ownership, path }: Directory,\n@@ -53,14 +54,15 @@ crate fn parse_external_mod(\n         ownership = mp.ownership;\n \n         // Ensure file paths are acyclic.\n-        let mut included_mod_stack = sess.included_mod_stack.borrow_mut();\n-        error_on_circular_module(sess, span, &mp.path, &included_mod_stack)?;\n+        let mut included_mod_stack = sess.parse_sess.included_mod_stack.borrow_mut();\n+        error_on_circular_module(&sess.parse_sess, span, &mp.path, &included_mod_stack)?;\n         included_mod_stack.push(mp.path.clone());\n         *pop_mod_stack = true; // We have pushed, so notify caller.\n         drop(included_mod_stack);\n \n         // Actually parse the external file as a module.\n-        let mut module = new_parser_from_file(sess, &mp.path, Some(span)).parse_mod(&token::Eof)?;\n+        let mut module =\n+            new_parser_from_file(&sess.parse_sess, &mp.path, Some(span)).parse_mod(&token::Eof)?;\n         module.0.inline = false;\n         module\n     };\n@@ -98,11 +100,12 @@ fn error_on_circular_module<'a>(\n }\n \n crate fn push_directory(\n+    sess: &Session,\n     id: Ident,\n     attrs: &[Attribute],\n     Directory { mut ownership, mut path }: Directory,\n ) -> Directory {\n-    if let Some(filename) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+    if let Some(filename) = sess.first_attr_value_str_by_name(attrs, sym::path) {\n         path.push(&*filename.as_str());\n         ownership = DirectoryOwnership::Owned { relative: None };\n     } else {\n@@ -124,14 +127,14 @@ crate fn push_directory(\n }\n \n fn submod_path<'a>(\n-    sess: &'a ParseSess,\n+    sess: &'a Session,\n     id: Ident,\n     span: Span,\n     attrs: &[Attribute],\n     ownership: DirectoryOwnership,\n     dir_path: &Path,\n ) -> PResult<'a, ModulePathSuccess> {\n-    if let Some(path) = submod_path_from_attr(attrs, dir_path) {\n+    if let Some(path) = submod_path_from_attr(sess, attrs, dir_path) {\n         let ownership = match path.file_name().and_then(|s| s.to_str()) {\n             // All `#[path]` files are treated as though they are a `mod.rs` file.\n             // This means that `mod foo;` declarations inside `#[path]`-included\n@@ -151,16 +154,16 @@ fn submod_path<'a>(\n         DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n     };\n     let ModulePath { path_exists, name, result } =\n-        default_submod_path(sess, id, span, relative, dir_path);\n+        default_submod_path(&sess.parse_sess, id, span, relative, dir_path);\n     match ownership {\n         DirectoryOwnership::Owned { .. } => Ok(result?),\n         DirectoryOwnership::UnownedViaBlock => {\n             let _ = result.map_err(|mut err| err.cancel());\n-            error_decl_mod_in_block(sess, span, path_exists, &name)\n+            error_decl_mod_in_block(&sess.parse_sess, span, path_exists, &name)\n         }\n         DirectoryOwnership::UnownedViaMod => {\n             let _ = result.map_err(|mut err| err.cancel());\n-            error_cannot_declare_mod_here(sess, span, path_exists, &name)\n+            error_cannot_declare_mod_here(&sess.parse_sess, span, path_exists, &name)\n         }\n     }\n }\n@@ -218,9 +221,13 @@ fn error_cannot_declare_mod_here<'a, T>(\n /// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n /// The provided `dir_path` is joined with the `path_string`.\n // Public for rustfmt usage.\n-pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+pub fn submod_path_from_attr(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    dir_path: &Path,\n+) -> Option<PathBuf> {\n     // Extract path string from first `#[path = \"path_string\"]` attribute.\n-    let path_string = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n+    let path_string = sess.first_attr_value_str_by_name(attrs, sym::path)?;\n     let path_string = path_string.as_str();\n \n     // On windows, the base path might have the form"}, {"sha": "0608ccfffb858b5e6601efaf421cea30c0ed2dad", "filename": "src/librustc_expand/mut_visit/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmut_visit%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,9 +2,9 @@ use crate::tests::{matches_codepattern, string_to_crate};\n \n use rustc_ast::ast;\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::with_default_session_globals;\n use rustc_ast_pretty::pprust;\n use rustc_span::symbol::Ident;\n+use rustc_span::with_default_session_globals;\n \n // This version doesn't care about getting comments or doc-strings in.\n fn fake_print_crate(s: &mut pprust::State<'_>, krate: &ast::Crate) {"}, {"sha": "871844442839cf7fd27f1a735de3cb7be9dbc7b8", "filename": "src/librustc_expand/parse/lexer/tests.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Flexer%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,12 +1,12 @@\n-use rustc_ast::token::{self, Token, TokenKind};\n-use rustc_ast::util::comments::is_doc_comment;\n-use rustc_ast::with_default_session_globals;\n+use rustc_ast::ast::AttrStyle;\n+use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{emitter::EmitterWriter, Handler};\n use rustc_parse::lexer::StringReader;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::symbol::Symbol;\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span};\n \n use std::io;\n@@ -223,13 +223,6 @@ fn literal_suffixes() {\n     })\n }\n \n-#[test]\n-fn line_doc_comments() {\n-    assert!(is_doc_comment(\"///\"));\n-    assert!(is_doc_comment(\"/// blah\"));\n-    assert!(!is_doc_comment(\"////\"));\n-}\n-\n #[test]\n fn nested_block_comments() {\n     with_default_session_globals(|| {\n@@ -251,6 +244,9 @@ fn crlf_comments() {\n         assert_eq!(comment.kind, token::Comment);\n         assert_eq!((comment.span.lo(), comment.span.hi()), (BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token(), token::Whitespace);\n-        assert_eq!(lexer.next_token(), token::DocComment(Symbol::intern(\"/// test\")));\n+        assert_eq!(\n+            lexer.next_token(),\n+            token::DocComment(CommentKind::Line, AttrStyle::Outer, Symbol::intern(\" test\"))\n+        );\n     })\n }"}, {"sha": "5c9116b2f139de8a850c33b9067a6aefbcd8451d", "filename": "src/librustc_expand/parse/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fparse%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,13 +5,13 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::visit;\n-use rustc_ast::with_default_session_globals;\n use rustc_ast_pretty::pprust::item_to_string;\n use rustc_errors::PResult;\n use rustc_parse::new_parser_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::FilePathMapping;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, FileName, Pos, Span};\n \n use std::path::PathBuf;\n@@ -244,20 +244,20 @@ fn crlf_doc_comments() {\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name_1, source, &sess).unwrap().unwrap();\n         let doc = item.attrs.iter().filter_map(|at| at.doc_str()).next().unwrap();\n-        assert_eq!(doc.as_str(), \"/// doc comment\");\n+        assert_eq!(doc.as_str(), \" doc comment\");\n \n         let name_2 = FileName::Custom(\"crlf_source_2\".to_string());\n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name_2, source, &sess).unwrap().unwrap();\n         let docs = item.attrs.iter().filter_map(|at| at.doc_str()).collect::<Vec<_>>();\n-        let b: &[_] = &[Symbol::intern(\"/// doc comment\"), Symbol::intern(\"/// line 2\")];\n+        let b: &[_] = &[Symbol::intern(\" doc comment\"), Symbol::intern(\" line 2\")];\n         assert_eq!(&docs[..], b);\n \n         let name_3 = FileName::Custom(\"clrf_source_3\".to_string());\n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name_3, source, &sess).unwrap().unwrap();\n         let doc = item.attrs.iter().filter_map(|at| at.doc_str()).next().unwrap();\n-        assert_eq!(doc.as_str(), \"/** doc comment\\n *  with CRLF */\");\n+        assert_eq!(doc.as_str(), \" doc comment\\n *  with CRLF \");\n     });\n }\n "}, {"sha": "85fbf3bc0d0b0d5a9813241275aaee512f94c541", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -107,7 +107,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let input = if item.pretty_printing_compatibility_hack() {\n             TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n         } else {\n-            nt_to_tokenstream(&item, ecx.parse_sess, DUMMY_SP)\n+            nt_to_tokenstream(&item, &ecx.sess.parse_sess, DUMMY_SP)\n         };\n \n         let server = proc_macro_server::Rustc::new(ecx);\n@@ -123,9 +123,9 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         };\n \n-        let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n+        let error_count_before = ecx.sess.parse_sess.span_diagnostic.err_count();\n         let mut parser =\n-            rustc_parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n+            rustc_parse::stream_to_parser(&ecx.sess.parse_sess, stream, Some(\"proc-macro derive\"));\n         let mut items = vec![];\n \n         loop {\n@@ -140,7 +140,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         }\n \n         // fail if there have been errors emitted\n-        if ecx.parse_sess.span_diagnostic.err_count() > error_count_before {\n+        if ecx.sess.parse_sess.span_diagnostic.err_count() > error_count_before {\n             ecx.struct_span_err(span, \"proc-macro derive produced unparseable tokens\").emit();\n         }\n "}, {"sha": "dc7ba2d0424fc437ac25c4d5078329bbc9ff3d7d", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,7 +3,6 @@ use crate::base::ExtCtxt;\n use rustc_ast::ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n-use rustc_ast::util::comments;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::Diagnostic;\n@@ -148,11 +147,9 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                 tt!(Punct::new('\\'', true))\n             }\n             Literal(lit) => tt!(Literal { lit }),\n-            DocComment(c) => {\n-                let style = comments::doc_comment_style(c);\n-                let stripped = comments::strip_doc_comment_decoration(c);\n+            DocComment(_, attr_style, data) => {\n                 let mut escaped = String::new();\n-                for ch in stripped.chars() {\n+                for ch in data.as_str().chars() {\n                     escaped.extend(ch.escape_debug());\n                 }\n                 let stream = vec![\n@@ -169,7 +166,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     span: DelimSpan::from_single(span),\n                     flatten: false,\n                 }));\n-                if style == ast::AttrStyle::Inner {\n+                if attr_style == ast::AttrStyle::Inner {\n                     stack.push(tt!(Punct::new('!', false)));\n                 }\n                 tt!(Punct::new('#', false))\n@@ -367,7 +364,7 @@ impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         let expn_data = cx.current_expansion.id.expn_data();\n         Rustc {\n-            sess: cx.parse_sess,\n+            sess: &cx.sess.parse_sess,\n             def_site: cx.with_def_site_ctxt(expn_data.def_site),\n             call_site: cx.with_call_site_ctxt(expn_data.call_site),\n             mixed_site: cx.with_mixed_site_ctxt(expn_data.call_site),"}, {"sha": "b562a690f83612bcd96bd805ed8ba922df977b51", "filename": "src/librustc_expand/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,9 +1,9 @@\n use rustc_ast::ast;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::with_default_session_globals;\n use rustc_parse::{new_parser_from_source_str, parser::Parser, source_file_to_stream};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, MultiSpan, Span};\n \n use rustc_data_structures::sync::Lrc;"}, {"sha": "4e818e9feb08b151b435bd8130749fc354cd9a34", "filename": "src/librustc_expand/tokenstream/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Ftokenstream%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,7 +2,7 @@ use crate::tests::string_to_stream;\n \n use rustc_ast::token;\n use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder, TokenTree};\n-use rustc_ast::with_default_session_globals;\n+use rustc_span::with_default_session_globals;\n use rustc_span::{BytePos, Span, Symbol};\n use smallvec::smallvec;\n "}, {"sha": "31aba8aba2515696945d70773b53292fb9220188", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -576,9 +576,12 @@ declare_features! (\n     /// Lazily evaluate constants. This allows constants to depend on type parameters.\n     (active, lazy_normalization_consts, \"1.46.0\", Some(72219), None),\n \n-    /// Alloc calling `transmute` in const fn\n+    /// Allows calling `transmute` in const fn\n     (active, const_fn_transmute, \"1.46.0\", Some(53605), None),\n \n+    /// The smallest useful subset of `const_generics`.\n+    (active, min_const_generics, \"1.47.0\", Some(74878), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "618f3e99c3f04a3a38617585c1f33bd51e551f80", "filename": "src/librustc_hir/def.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_hir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_hir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdef.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -150,7 +150,7 @@ impl DefKind {\n         }\n     }\n \n-    pub fn matches_ns(&self, ns: Namespace) -> bool {\n+    pub fn ns(&self) -> Option<Namespace> {\n         match self {\n             DefKind::Mod\n             | DefKind::Struct\n@@ -163,17 +163,17 @@ impl DefKind {\n             | DefKind::ForeignTy\n             | DefKind::TraitAlias\n             | DefKind::AssocTy\n-            | DefKind::TyParam => ns == Namespace::TypeNS,\n+            | DefKind::TyParam => Some(Namespace::TypeNS),\n \n             DefKind::Fn\n             | DefKind::Const\n             | DefKind::ConstParam\n             | DefKind::Static\n             | DefKind::Ctor(..)\n             | DefKind::AssocFn\n-            | DefKind::AssocConst => ns == Namespace::ValueNS,\n+            | DefKind::AssocConst => Some(Namespace::ValueNS),\n \n-            DefKind::Macro(..) => ns == Namespace::MacroNS,\n+            DefKind::Macro(..) => Some(Namespace::MacroNS),\n \n             // Not namespaced.\n             DefKind::AnonConst\n@@ -185,7 +185,7 @@ impl DefKind {\n             | DefKind::Use\n             | DefKind::ForeignMod\n             | DefKind::GlobalAsm\n-            | DefKind::Impl => false,\n+            | DefKind::Impl => None,\n         }\n     }\n }\n@@ -453,7 +453,7 @@ impl<Id> Res<Id> {\n \n     pub fn matches_ns(&self, ns: Namespace) -> bool {\n         match self {\n-            Res::Def(kind, ..) => kind.matches_ns(ns),\n+            Res::Def(kind, ..) => kind.ns() == Some(ns),\n             Res::PrimTy(..) | Res::SelfTy(..) | Res::ToolMod => ns == Namespace::TypeNS,\n             Res::SelfCtor(..) | Res::Local(..) => ns == Namespace::ValueNS,\n             Res::NonMacroAttr(..) => ns == Namespace::MacroNS,"}, {"sha": "7f473a458481f853975d3bef708668b4442101ed", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -141,12 +141,20 @@ impl<CTX> HashStable<CTX> for LangItem {\n /// Extracts the first `lang = \"$name\"` out of a list of attributes.\n /// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n /// are also extracted out when found.\n-pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n+///\n+/// About the `check_name` argument: passing in a `Session` would be simpler,\n+/// because then we could call `Session::check_name` directly. But we want to\n+/// avoid the need for `librustc_hir` to depend on `librustc_session`, so we\n+/// use a closure instead.\n+pub fn extract<'a, F>(check_name: F, attrs: &'a [ast::Attribute]) -> Option<(Symbol, Span)>\n+where\n+    F: Fn(&'a ast::Attribute, Symbol) -> bool,\n+{\n     attrs.iter().find_map(|attr| {\n         Some(match attr {\n-            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n+            _ if check_name(attr, sym::lang) => (attr.value_str()?, attr.span),\n+            _ if check_name(attr, sym::panic_handler) => (sym::panic_impl, attr.span),\n+            _ if check_name(attr, sym::alloc_error_handler) => (sym::oom, attr.span),\n             _ => return None,\n         })\n     })"}, {"sha": "fd64361cb3540009ed34389ce63feb292509e82d", "filename": "src/librustc_hir/weak_lang_items.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_hir%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_hir%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fweak_lang_items.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -20,8 +20,13 @@ lazy_static! {\n     };\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n-    lang_items::extract(attrs).and_then(|(name, _)| {\n+/// The `check_name` argument avoids the need for `librustc_hir` to depend on\n+/// `librustc_session`.\n+pub fn link_name<'a, F>(check_name: F, attrs: &'a [ast::Attribute]) -> Option<Symbol>\n+where\n+    F: Fn(&'a ast::Attribute, Symbol) -> bool\n+{\n+    lang_items::extract(check_name, attrs).and_then(|(name, _)| {\n         $(if name == sym::$name {\n             Some(sym::$sym)\n         } else)* {"}, {"sha": "df602d8bd1bea3762bb654a8bb3f865211bc0e37", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -117,7 +117,7 @@ impl IfThisChanged<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(hir_id);\n         let def_path_hash = self.tcx.def_path_hash(def_id.to_def_id());\n         for attr in attrs {\n-            if attr.check_name(sym::rustc_if_this_changed) {\n+            if self.tcx.sess.check_name(attr, sym::rustc_if_this_changed) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::from_def_path_hash(def_path_hash, DepKind::hir_owner),\n@@ -132,7 +132,7 @@ impl IfThisChanged<'tcx> {\n                     },\n                 };\n                 self.if_this_changed.push((attr.span, def_id.to_def_id(), dep_node));\n-            } else if attr.check_name(sym::rustc_then_this_would_need) {\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_then_this_would_need) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(n) => match DepNode::from_label_string(&n.as_str(), def_path_hash) {"}, {"sha": "ed04a947485c7d234d888276535ef3dcb4446ee8", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -39,8 +39,8 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n             .collect_and_partition_mono_items(LOCAL_CRATE)\n             .1\n             .iter()\n-            .map(|cgu| cgu.name())\n-            .collect::<BTreeSet<Symbol>>();\n+            .map(|cgu| cgu.name().to_string())\n+            .collect::<BTreeSet<String>>();\n \n         let ams = AssertModuleSource { tcx, available_cgus };\n \n@@ -52,31 +52,32 @@ pub fn assert_module_sources(tcx: TyCtxt<'_>) {\n \n struct AssertModuleSource<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    available_cgus: BTreeSet<Symbol>,\n+    available_cgus: BTreeSet<String>,\n }\n \n impl AssertModuleSource<'tcx> {\n     fn check_attr(&self, attr: &ast::Attribute) {\n-        let (expected_reuse, comp_kind) = if attr.check_name(sym::rustc_partition_reused) {\n-            (CguReuse::PreLto, ComparisonKind::AtLeast)\n-        } else if attr.check_name(sym::rustc_partition_codegened) {\n-            (CguReuse::No, ComparisonKind::Exact)\n-        } else if attr.check_name(sym::rustc_expected_cgu_reuse) {\n-            match self.field(attr, sym::kind) {\n-                sym::no => (CguReuse::No, ComparisonKind::Exact),\n-                sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n-                sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n-                sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n-                other => {\n-                    self.tcx.sess.span_fatal(\n-                        attr.span,\n-                        &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n-                    );\n+        let (expected_reuse, comp_kind) =\n+            if self.tcx.sess.check_name(attr, sym::rustc_partition_reused) {\n+                (CguReuse::PreLto, ComparisonKind::AtLeast)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_partition_codegened) {\n+                (CguReuse::No, ComparisonKind::Exact)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_expected_cgu_reuse) {\n+                match self.field(attr, sym::kind) {\n+                    sym::no => (CguReuse::No, ComparisonKind::Exact),\n+                    sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n+                    sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n+                    sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n+                    other => {\n+                        self.tcx.sess.span_fatal(\n+                            attr.span,\n+                            &format!(\"unknown cgu-reuse-kind `{}` specified\", other),\n+                        );\n+                    }\n                 }\n-            }\n-        } else {\n-            return;\n-        };\n+            } else {\n+                return;\n+            };\n \n         if !self.tcx.sess.opts.debugging_opts.query_dep_graph {\n             self.tcx.sess.span_fatal(\n@@ -121,12 +122,11 @@ impl AssertModuleSource<'tcx> {\n \n         debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, sym::module), cgu_name);\n \n-        if !self.available_cgus.contains(&cgu_name) {\n+        if !self.available_cgus.contains(&*cgu_name.as_str()) {\n             self.tcx.sess.span_err(\n                 attr.span,\n                 &format!(\n-                    \"no module named `{}` (mangled: {}). \\\n-                          Available modules: {}\",\n+                    \"no module named `{}` (mangled: {}). Available modules: {}\",\n                     user_path,\n                     cgu_name,\n                     self.available_cgus"}, {"sha": "0f254aee8e314d557002426cdbbb9d3fa0615c64", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -180,9 +180,9 @@ pub struct DirtyCleanVisitor<'tcx> {\n impl DirtyCleanVisitor<'tcx> {\n     /// Possibly \"deserialize\" the attribute into a clean/dirty assertion\n     fn assertion_maybe(&mut self, item_id: hir::HirId, attr: &Attribute) -> Option<Assertion> {\n-        let is_clean = if attr.check_name(sym::rustc_dirty) {\n+        let is_clean = if self.tcx.sess.check_name(attr, sym::rustc_dirty) {\n             false\n-        } else if attr.check_name(sym::rustc_clean) {\n+        } else if self.tcx.sess.check_name(attr, sym::rustc_clean) {\n             true\n         } else {\n             // skip: not rustc_clean/dirty\n@@ -523,7 +523,7 @@ pub struct FindAllAttrs<'tcx> {\n impl FindAllAttrs<'tcx> {\n     fn is_active_attr(&mut self, attr: &Attribute) -> bool {\n         for attr_name in &self.attr_names {\n-            if attr.check_name(*attr_name) && check_config(self.tcx, attr) {\n+            if self.tcx.sess.check_name(attr, *attr_name) && check_config(self.tcx, attr) {\n                 return true;\n             }\n         }"}, {"sha": "89142edb2dc61dc58e738062c517b888eb78aae1", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -85,11 +85,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n                 if sub == &ty::ReStatic\n-                    && v.0\n-                        .into_iter()\n-                        .filter(|t| t.span.desugaring_kind().is_none())\n-                        .next()\n-                        .is_some()\n+                    && v.0.into_iter().find(|t| t.span.desugaring_kind().is_none()).is_some()\n                 {\n                     // If the failure is due to a `'static` requirement coming from a `dyn` or\n                     // `impl` Trait that *isn't* caused by `async fn` desugaring, handle this case"}, {"sha": "7493b8b0a9f772ec7e3fbb903ca3b6cd4ba0ece5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -257,7 +257,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             param.param_ty.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );\n-                    } else if let Some(_) = opaque\n+                    } else if opaque\n                         .bounds\n                         .iter()\n                         .filter_map(|arg| match arg {\n@@ -269,6 +269,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             _ => None,\n                         })\n                         .next()\n+                        .is_some()\n                     {\n                     } else {\n                         err.span_suggestion_verbose("}, {"sha": "ccba904df9e002270f5e3655568ea091b5fecc35", "filename": "src/librustc_infer/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -50,7 +50,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n             // FIXME(#41044) -- not correct, need test\n-            ty::Bivariant => Ok(a.clone()),\n+            ty::Bivariant => Ok(a),\n             ty::Contravariant => self.fields.lub(self.a_is_expected).relate(a, b),\n         }\n     }\n@@ -97,7 +97,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         // very challenging, switch to invariance. This is obviously\n         // overly conservative but works ok in practice.\n         self.relate_with_variance(ty::Variance::Invariant, a, b)?;\n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n "}, {"sha": "3f5ed36035c1a3c38a8d27c866cffc53b1c64f85", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -719,7 +719,7 @@ where\n             self.a_scopes.pop().unwrap();\n         }\n \n-        Ok(a.clone())\n+        Ok(a)\n     }\n }\n "}, {"sha": "2d4c1e5d050baa160271b2c135b243289b3c1912", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -288,9 +288,9 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n     ) -> TypeError<'tcx> {\n         debug!(\"error: placeholder={:?}, other_region={:?}\", placeholder, other_region);\n         if self.overly_polymorphic {\n-            return TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region);\n+            TypeError::RegionsOverlyPolymorphic(placeholder.name, other_region)\n         } else {\n-            return TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region);\n+            TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, other_region)\n         }\n     }\n }"}, {"sha": "308f884f9a63fd59d88fd0acd9f5e1d831722ee6", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -68,7 +68,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         match variance {\n             ty::Invariant => self.fields.equate(self.a_is_expected).relate(a, b),\n             ty::Covariant => self.relate(a, b),\n-            ty::Bivariant => Ok(a.clone()),\n+            ty::Bivariant => Ok(a),\n             ty::Contravariant => self.with_expected_switched(|this| this.relate(b, a)),\n         }\n     }"}, {"sha": "4dccf273dd90fc69f6b17a343222a7aa13323da9", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -73,7 +73,7 @@ impl Compiler {\n \n /// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n-    rustc_ast::with_default_session_globals(move || {\n+    rustc_span::with_default_session_globals(move || {\n         let cfg = cfgspecs\n             .into_iter()\n             .map(|s| {"}, {"sha": "6c0343330c8c9a3a99b43e36168eca00b1c171c6", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -162,12 +162,7 @@ pub fn register_plugins<'a>(\n         )\n     });\n \n-    let (krate, features) = rustc_expand::config::features(\n-        krate,\n-        &sess.parse_sess,\n-        sess.edition(),\n-        &sess.opts.debugging_opts.allow_features,\n-    );\n+    let (krate, features) = rustc_expand::config::features(sess, krate);\n     // these need to be set \"early\" so that expansion sees `quote` if enabled.\n     sess.init_features(features);\n \n@@ -244,7 +239,7 @@ fn configure_and_expand_inner<'a>(\n         let (krate, name) = rustc_builtin_macros::standard_library_imports::inject(\n             krate,\n             &mut resolver,\n-            &sess.parse_sess,\n+            &sess,\n             alt_std_name,\n         );\n         if let Some(name) = name {\n@@ -253,7 +248,7 @@ fn configure_and_expand_inner<'a>(\n         krate\n     });\n \n-    util::check_attr_crate_type(&krate.attrs, &mut resolver.lint_buffer());\n+    util::check_attr_crate_type(&sess, &krate.attrs, &mut resolver.lint_buffer());\n \n     // Expand all macros\n     krate = sess.time(\"macro_expand_crate\", || {\n@@ -300,7 +295,7 @@ fn configure_and_expand_inner<'a>(\n         };\n \n         let extern_mod_loaded = |k: &ast::Crate| pre_expansion_lint(sess, lint_store, k);\n-        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n+        let mut ecx = ExtCtxt::new(&sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n@@ -312,6 +307,7 @@ fn configure_and_expand_inner<'a>(\n         });\n \n         let mut missing_fragment_specifiers: Vec<_> = ecx\n+            .sess\n             .parse_sess\n             .missing_fragment_specifiers\n             .borrow()\n@@ -341,17 +337,7 @@ fn configure_and_expand_inner<'a>(\n     })?;\n \n     sess.time(\"maybe_building_test_harness\", || {\n-        rustc_builtin_macros::test_harness::inject(\n-            &sess.parse_sess,\n-            &mut resolver,\n-            sess.opts.test,\n-            &mut krate,\n-            sess.diagnostic(),\n-            &sess.features_untracked(),\n-            sess.panic_strategy(),\n-            sess.target.target.options.panic_strategy,\n-            sess.opts.debugging_opts.panic_abort_tests,\n-        )\n+        rustc_builtin_macros::test_harness::inject(&sess, &mut resolver, &mut krate)\n     });\n \n     if let Some(PpMode::PpmSource(PpSourceMode::PpmEveryBodyLoops)) = sess.opts.pretty {\n@@ -385,7 +371,7 @@ fn configure_and_expand_inner<'a>(\n             let num_crate_types = crate_types.len();\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n-                &sess.parse_sess,\n+                &sess,\n                 &mut resolver,\n                 krate,\n                 is_proc_macro_crate,\n@@ -415,12 +401,7 @@ fn configure_and_expand_inner<'a>(\n \n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     sess.time(\"complete_gated_feature_checking\", || {\n-        rustc_ast_passes::feature_gate::check_crate(\n-            &krate,\n-            &sess.parse_sess,\n-            &sess.features_untracked(),\n-            sess.opts.unstable_features,\n-        );\n+        rustc_ast_passes::feature_gate::check_crate(&krate, sess);\n     });\n \n     // Add all buffered lints from the `ParseSess` to the `Session`."}, {"sha": "d56115fd6ac56b0c7681bcbab825cd696833c8ee", "filename": "src/librustc_interface/proc_macro_decls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fproc_macro_decls.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -13,19 +12,20 @@ pub fn find(tcx: TyCtxt<'_>) -> Option<DefId> {\n fn proc_macro_decls_static(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let mut finder = Finder { decls: None };\n+    let mut finder = Finder { tcx, decls: None };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n     finder.decls.map(|id| tcx.hir().local_def_id(id).to_def_id())\n }\n \n-struct Finder {\n+struct Finder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     decls: Option<hir::HirId>,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for Finder {\n+impl<'v> ItemLikeVisitor<'v> for Finder<'_> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if attr::contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n+        if self.tcx.sess.contains_name(&item.attrs, sym::rustc_proc_macro_decls) {\n             self.decls = Some(item.hir_id);\n         }\n     }"}, {"sha": "d1a22c69ee0419656360495aef20f7114917765a", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -159,7 +159,7 @@ impl<'tcx> Queries<'tcx> {\n                 None => {\n                     let parse_result = self.parse()?;\n                     let krate = parse_result.peek();\n-                    find_crate_name(Some(self.session()), &krate.attrs, &self.compiler.input)\n+                    find_crate_name(self.session(), &krate.attrs, &self.compiler.input)\n                 }\n             })\n         })\n@@ -294,7 +294,7 @@ impl<'tcx> Queries<'tcx> {\n         };\n \n         let attrs = &*tcx.get_attrs(def_id.to_def_id());\n-        let attrs = attrs.iter().filter(|attr| attr.check_name(sym::rustc_error));\n+        let attrs = attrs.iter().filter(|attr| tcx.sess.check_name(attr, sym::rustc_error));\n         for attr in attrs {\n             match attr.meta_item_list() {\n                 // Check if there is a `#[rustc_error(delay_span_bug_from_inside_query)]`."}, {"sha": "e94745519a496608e1c85e21c31ed0a7eb440ed6", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -73,7 +73,7 @@ fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n // When the user supplies --test we should implicitly supply --cfg test\n #[test]\n fn test_switch_implies_cfg_test() {\n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"--test\".to_string()]).unwrap();\n         let (sess, cfg) = mk_session(matches);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n@@ -84,7 +84,7 @@ fn test_switch_implies_cfg_test() {\n // When the user supplies --test and --cfg test, don't implicitly add another --cfg test\n #[test]\n fn test_switch_implies_cfg_test_unless_cfg_test() {\n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"--test\".to_string(), \"--cfg=test\".to_string()]).unwrap();\n         let (sess, cfg) = mk_session(matches);\n         let cfg = build_configuration(&sess, to_crate_config(cfg));\n@@ -96,20 +96,20 @@ fn test_switch_implies_cfg_test_unless_cfg_test() {\n \n #[test]\n fn test_can_print_warnings() {\n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n         let (sess, _) = mk_session(matches);\n         assert!(!sess.diagnostic().can_emit_warnings());\n     });\n \n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches =\n             optgroups().parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()]).unwrap();\n         let (sess, _) = mk_session(matches);\n         assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n-    rustc_ast::with_default_session_globals(|| {\n+    rustc_span::with_default_session_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n         let (sess, _) = mk_session(matches);\n         assert!(sess.diagnostic().can_emit_warnings());"}, {"sha": "e403a60ff323b3b38e3b793bb3740a810e392d2e", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -142,7 +142,7 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n     crate::callbacks::setup_callbacks();\n \n     let main_handler = move || {\n-        rustc_ast::with_session_globals(edition, || {\n+        rustc_span::with_session_globals(edition, || {\n             if let Some(stderr) = stderr {\n                 io::set_panic(Some(box Sink(stderr.clone())));\n             }\n@@ -176,27 +176,21 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n \n     let with_pool = move |pool: &rayon::ThreadPool| pool.install(move || f());\n \n-    rustc_ast::with_session_globals(edition, || {\n-        rustc_ast::SESSION_GLOBALS.with(|ast_session_globals| {\n-            rustc_span::SESSION_GLOBALS.with(|span_session_globals| {\n-                // The main handler runs for each Rayon worker thread and sets\n-                // up the thread local rustc uses. ast_session_globals and\n-                // span_session_globals are captured and set on the new\n-                // threads. ty::tls::with_thread_locals sets up thread local\n-                // callbacks from librustc_ast.\n-                let main_handler = move |thread: rayon::ThreadBuilder| {\n-                    rustc_ast::SESSION_GLOBALS.set(ast_session_globals, || {\n-                        rustc_span::SESSION_GLOBALS.set(span_session_globals, || {\n-                            if let Some(stderr) = stderr {\n-                                io::set_panic(Some(box Sink(stderr.clone())));\n-                            }\n-                            thread.run()\n-                        })\n-                    })\n-                };\n+    rustc_span::with_session_globals(edition, || {\n+        rustc_span::SESSION_GLOBALS.with(|session_globals| {\n+            // The main handler runs for each Rayon worker thread and sets up\n+            // the thread local rustc uses. `session_globals` is captured and set\n+            // on the new threads.\n+            let main_handler = move |thread: rayon::ThreadBuilder| {\n+                rustc_span::SESSION_GLOBALS.set(session_globals, || {\n+                    if let Some(stderr) = stderr {\n+                        io::set_panic(Some(box Sink(stderr.clone())));\n+                    }\n+                    thread.run()\n+                })\n+            };\n \n-                config.build_scoped(main_handler, with_pool).unwrap()\n-            })\n+            config.build_scoped(main_handler, with_pool).unwrap()\n         })\n     })\n }\n@@ -407,10 +401,14 @@ pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguat\n     CrateDisambiguator::from(hasher.finish::<Fingerprint>())\n }\n \n-pub(crate) fn check_attr_crate_type(attrs: &[ast::Attribute], lint_buffer: &mut LintBuffer) {\n+pub(crate) fn check_attr_crate_type(\n+    sess: &Session,\n+    attrs: &[ast::Attribute],\n+    lint_buffer: &mut LintBuffer,\n+) {\n     // Unconditionally collect crate types from attributes to make them used\n     for a in attrs.iter() {\n-        if a.check_name(sym::crate_type) {\n+        if sess.check_name(a, sym::crate_type) {\n             if let Some(n) = a.value_str() {\n                 if categorize_crate_type(n).is_some() {\n                     return;\n@@ -465,7 +463,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<C\n     let attr_types: Vec<CrateType> = attrs\n         .iter()\n         .filter_map(|a| {\n-            if a.check_name(sym::crate_type) {\n+            if session.check_name(a, sym::crate_type) {\n                 match a.value_str() {\n                     Some(s) => categorize_crate_type(s),\n                     _ => None,\n@@ -531,7 +529,7 @@ pub fn build_output_filenames(\n                 .opts\n                 .crate_name\n                 .clone()\n-                .or_else(|| rustc_attr::find_crate_name(attrs).map(|n| n.to_string()))\n+                .or_else(|| rustc_attr::find_crate_name(&sess, attrs).map(|n| n.to_string()))\n                 .unwrap_or_else(|| input.filestem().to_owned());\n \n             OutputFilenames::new("}, {"sha": "c42794e00b41e0c3426169af4d7c6d1ef346b243", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -41,6 +41,7 @@ use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n+use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -237,7 +238,7 @@ impl UnsafeCode {\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(sym::allow_internal_unsafe) {\n+        if cx.sess().check_name(attr, sym::allow_internal_unsafe) {\n             self.report_unsafe(cx, attr.span, |lint| {\n                 lint.build(\n                     \"`allow_internal_unsafe` allows defining \\\n@@ -315,12 +316,12 @@ pub struct MissingDoc {\n \n impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n \n-fn has_doc(attr: &ast::Attribute) -> bool {\n+fn has_doc(sess: &Session, attr: &ast::Attribute) -> bool {\n     if attr.is_doc_comment() {\n         return true;\n     }\n \n-    if !attr.check_name(sym::doc) {\n+    if !sess.check_name(attr, sym::doc) {\n         return false;\n     }\n \n@@ -377,7 +378,7 @@ impl MissingDoc {\n             }\n         }\n \n-        let has_doc = attrs.iter().any(|a| has_doc(a));\n+        let has_doc = attrs.iter().any(|a| has_doc(cx.sess(), a));\n         if !has_doc {\n             cx.struct_span_lint(\n                 MISSING_DOCS,\n@@ -391,10 +392,10 @@ impl MissingDoc {\n }\n \n impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext<'_>, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, cx: &LateContext<'_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden()\n             || attrs.iter().any(|attr| {\n-                attr.check_name(sym::doc)\n+                cx.sess().check_name(attr, sym::doc)\n                     && match attr.meta_item_list() {\n                         None => false,\n                         Some(l) => attr::list_contains_name(&l, sym::hidden),\n@@ -411,7 +412,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n-            let has_doc = macro_def.attrs.iter().any(|a| has_doc(a));\n+            let has_doc = macro_def.attrs.iter().any(|a| has_doc(cx.sess(), a));\n             if !has_doc {\n                 cx.struct_span_lint(\n                     MISSING_DOCS,\n@@ -737,7 +738,7 @@ impl EarlyLintPass for DeprecatedAttr {\n                 return;\n             }\n         }\n-        if attr.check_name(sym::no_start) || attr.check_name(sym::crate_id) {\n+        if cx.sess().check_name(attr, sym::no_start) || cx.sess().check_name(attr, sym::crate_id) {\n             let path_str = pprust::path_to_string(&attr.get_normal_item().path);\n             let msg = format!(\"use of deprecated attribute `{}`: no longer used.\", path_str);\n             lint_deprecated_attr(cx, attr, &msg, None);\n@@ -763,7 +764,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n \n         let span = sugared_span.take().unwrap_or_else(|| attr.span);\n \n-        if attr.is_doc_comment() || attr.check_name(sym::doc) {\n+        if attr.is_doc_comment() || cx.sess().check_name(attr, sym::doc) {\n             cx.struct_span_lint(UNUSED_DOC_COMMENTS, span, |lint| {\n                 let mut err = lint.build(\"unused doc comment\");\n                 err.span_label(\n@@ -819,7 +820,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n-                if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n+                if let Some(no_mangle_attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n                     for param in generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n@@ -845,7 +846,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 }\n             }\n             hir::ItemKind::Const(..) => {\n-                if attr::contains_name(&it.attrs, sym::no_mangle) {\n+                if cx.sess().contains_name(&it.attrs, sym::no_mangle) {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     cx.struct_span_lint(NO_MANGLE_CONST_ITEMS, it.span, |lint| {\n@@ -938,11 +939,11 @@ declare_lint_pass!(\n );\n \n impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n-    fn check_attribute(&mut self, ctx: &LateContext<'_>, attr: &ast::Attribute) {\n-        if attr.check_name(sym::feature) {\n+    fn check_attribute(&mut self, cx: &LateContext<'_>, attr: &ast::Attribute) {\n+        if cx.sess().check_name(attr, sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    ctx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n+                    cx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n                         lint.build(\"unstable feature\").emit()\n                     });\n                 }\n@@ -1381,7 +1382,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             return;\n         }\n \n-        if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n+        if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::rustc_test_marker) {\n             cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n                 lint.build(\"cannot test inner items\").emit()\n             });\n@@ -2131,7 +2132,7 @@ impl ClashingExternDeclarations {\n                     overridden_link_name,\n                     tcx.get_attrs(did.to_def_id())\n                         .iter()\n-                        .find(|at| at.check_name(sym::link_name))\n+                        .find(|at| tcx.sess.check_name(at, sym::link_name))\n                         .unwrap()\n                         .span,\n                 )"}, {"sha": "145a07d8dc852d27f8a1bdbd1969983c0232564a", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -125,7 +125,7 @@ impl<'s> LintLevelsBuilder<'s> {\n             };\n \n             let meta = unwrap_or!(attr.meta(), continue);\n-            attr::mark_used(attr);\n+            self.sess.mark_attr_used(attr);\n \n             let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n "}, {"sha": "5ca6f461048c3fc2b7f70f4e7ffd974d688d74fc", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -127,7 +127,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         let has_repr_c = it\n             .attrs\n             .iter()\n-            .any(|attr| attr::find_repr_attrs(&cx.sess.parse_sess, attr).contains(&attr::ReprC));\n+            .any(|attr| attr::find_repr_attrs(&cx.sess, attr).contains(&attr::ReprC));\n \n         if has_repr_c {\n             return;\n@@ -263,7 +263,8 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n+            cx.sess()\n+                .find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {\n@@ -327,7 +328,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n             },\n             FnKind::ItemFn(ident, _, header, _, attrs) => {\n                 // Skip foreign-ABI #[no_mangle] functions (Issue #31924)\n-                if header.abi != Abi::Rust && attr::contains_name(attrs, sym::no_mangle) {\n+                if header.abi != Abi::Rust && cx.sess().contains_name(attrs, sym::no_mangle) {\n                     return;\n                 }\n                 self.check_snake_case(cx, \"function\", ident);\n@@ -407,7 +408,7 @@ impl NonUpperCaseGlobals {\n impl<'tcx> LateLintPass<'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         match it.kind {\n-            hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, sym::no_mangle) => {\n+            hir::ItemKind::Static(..) if !cx.sess().contains_name(&it.attrs, sym::no_mangle) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n             }\n             hir::ItemKind::Const(..) => {"}, {"sha": "5c53e435fd76c82e92a76c999081628a405177bc", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -538,7 +538,7 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n             let guaranteed_nonnull_optimization = tcx\n                 .get_attrs(def.did)\n                 .iter()\n-                .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n+                .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed));\n \n             if guaranteed_nonnull_optimization {\n                 return true;\n@@ -556,6 +556,7 @@ fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKi\n         _ => false,\n     }\n }\n+\n /// Given a non-null scalar (or transparent) type `ty`, return the nullable version of that type.\n /// If the type passed in was not scalar, returns None.\n fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n@@ -1074,7 +1075,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n             // If `ty` is a `repr(transparent)` newtype, and the non-zero-sized type is a generic\n             // argument, which after substitution, is `()`, then this branch can be hit.\n-            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => return,\n+            FfiResult::FfiUnsafe { ty, .. } if is_return_type && ty.is_unit() => {}\n             FfiResult::FfiUnsafe { ty, reason, help } => {\n                 self.emit_ffi_unsafe_type_lint(ty, sp, &reason, help.as_deref());\n             }"}, {"sha": "5de9a16e098819e5161ec22488f6a6cf118d2e40", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,7 +2,6 @@ use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast::ast;\n use rustc_ast::ast::{ExprKind, StmtKind};\n-use rustc_ast::attr;\n use rustc_ast::util::parser;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n@@ -242,7 +241,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             for attr in cx.tcx.get_attrs(def_id).iter() {\n-                if attr.check_name(sym::must_use) {\n+                if cx.sess().check_name(attr, sym::must_use) {\n                     cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n                         let msg = format!(\n                             \"unused {}`{}`{} that must be used\",\n@@ -331,7 +330,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAttributes {\n             }\n         }\n \n-        if !attr::is_used(attr) {\n+        if !cx.sess().is_attr_used(attr) {\n             debug!(\"emitting warning for: {:?}\", attr);\n             cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n                 lint.build(\"unused attribute\").emit()"}, {"sha": "e15655e3794f53d71c5d6faca100935c0b830ea8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,8 +4,8 @@ use crate::dynamic_lib::DynamicLibrary;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n-use rustc_ast::expand::allocator::{global_allocator_spans, AllocatorKind};\n-use rustc_ast::{ast, attr};\n+use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_ast::{ast, visit};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -636,7 +636,8 @@ impl<'a> CrateLoader<'a> {\n         // compilation mode also comes into play.\n         let desired_strategy = self.sess.panic_strategy();\n         let mut runtime_found = false;\n-        let mut needs_panic_runtime = attr::contains_name(&krate.attrs, sym::needs_panic_runtime);\n+        let mut needs_panic_runtime =\n+            self.sess.contains_name(&krate.attrs, sym::needs_panic_runtime);\n \n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime || data.needs_panic_runtime();\n@@ -716,7 +717,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     fn inject_allocator_crate(&mut self, krate: &ast::Crate) {\n-        self.cstore.has_global_allocator = match &*global_allocator_spans(krate) {\n+        self.cstore.has_global_allocator = match &*global_allocator_spans(&self.sess, krate) {\n             [span1, span2, ..] => {\n                 self.sess\n                     .struct_span_err(*span2, \"cannot define multiple global allocators\")\n@@ -731,7 +732,7 @@ impl<'a> CrateLoader<'a> {\n         // Check to see if we actually need an allocator. This desire comes\n         // about through the `#![needs_allocator]` attribute and is typically\n         // written down in liballoc.\n-        let mut needs_allocator = attr::contains_name(&krate.attrs, sym::needs_allocator);\n+        let mut needs_allocator = self.sess.contains_name(&krate.attrs, sym::needs_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             needs_allocator = needs_allocator || data.needs_allocator();\n         });\n@@ -785,7 +786,7 @@ impl<'a> CrateLoader<'a> {\n         // allocator. At this point our allocator request is typically fulfilled\n         // by the standard library, denoted by the `#![default_lib_allocator]`\n         // attribute.\n-        let mut has_default = attr::contains_name(&krate.attrs, sym::default_lib_allocator);\n+        let mut has_default = self.sess.contains_name(&krate.attrs, sym::default_lib_allocator);\n         self.cstore.iter_crate_data(|_, data| {\n             if data.has_default_lib_allocator() {\n                 has_default = true;\n@@ -895,12 +896,12 @@ impl<'a> CrateLoader<'a> {\n                 );\n                 let name = match orig_name {\n                     Some(orig_name) => {\n-                        validate_crate_name(Some(self.sess), &orig_name.as_str(), Some(item.span));\n+                        validate_crate_name(self.sess, &orig_name.as_str(), Some(item.span));\n                         orig_name\n                     }\n                     None => item.ident.name,\n                 };\n-                let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n+                let dep_kind = if self.sess.contains_name(&item.attrs, sym::no_link) {\n                     CrateDepKind::MacrosOnly\n                 } else {\n                     CrateDepKind::Explicit\n@@ -945,3 +946,26 @@ impl<'a> CrateLoader<'a> {\n         self.maybe_resolve_crate(name, CrateDepKind::Explicit, None).ok()\n     }\n }\n+\n+fn global_allocator_spans(sess: &Session, krate: &ast::Crate) -> Vec<Span> {\n+    struct Finder<'a> {\n+        sess: &'a Session,\n+        name: Symbol,\n+        spans: Vec<Span>,\n+    }\n+    impl<'ast, 'a> visit::Visitor<'ast> for Finder<'a> {\n+        fn visit_item(&mut self, item: &'ast ast::Item) {\n+            if item.ident.name == self.name\n+                && self.sess.contains_name(&item.attrs, sym::rustc_std_internal_symbol)\n+            {\n+                self.spans.push(item.span);\n+            }\n+            visit::walk_item(self, item)\n+        }\n+    }\n+\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n+    let mut f = Finder { sess, name, spans: Vec::new() };\n+    visit::walk_crate(&mut f, krate);\n+    f.spans\n+}"}, {"sha": "d8f16796083f221112fefa187a5bb8f1e36ede33", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,7 +5,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n-    let mut collector = Collector { args: Vec::new() };\n+    let mut collector = Collector { tcx, args: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n     for attr in tcx.hir().krate().item.attrs.iter() {\n@@ -19,11 +19,12 @@ crate fn collect(tcx: TyCtxt<'_>) -> Vec<String> {\n     collector.args\n }\n \n-struct Collector {\n+struct Collector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     args: Vec<String>,\n }\n \n-impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n+impl<'tcx> ItemLikeVisitor<'tcx> for Collector<'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n         let fm = match it.kind {\n             hir::ItemKind::ForeignMod(ref fm) => fm,\n@@ -34,7 +35,8 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n         }\n \n         // First, add all of the custom #[link_args] attributes\n-        for m in it.attrs.iter().filter(|a| a.check_name(sym::link_args)) {\n+        let sess = &self.tcx.sess;\n+        for m in it.attrs.iter().filter(|a| sess.check_name(a, sym::link_args)) {\n             if let Some(linkarg) = m.value_str() {\n                 self.add_link_args(linkarg);\n             }\n@@ -45,7 +47,7 @@ impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_impl_item(&mut self, _it: &'tcx hir::ImplItem<'tcx>) {}\n }\n \n-impl Collector {\n+impl<'tcx> Collector<'tcx> {\n     fn add_link_args(&mut self, args: Symbol) {\n         self.args.extend(args.as_str().split(' ').filter(|s| !s.is_empty()).map(|s| s.to_string()))\n     }"}, {"sha": "3976475cb063e4b02713d983f32a90ceb9dd1e91", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -43,7 +43,8 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n         }\n \n         // Process all of the #[link(..)]-style arguments\n-        for m in it.attrs.iter().filter(|a| a.check_name(sym::link)) {\n+        let sess = &self.tcx.sess;\n+        for m in it.attrs.iter().filter(|a| sess.check_name(a, sym::link)) {\n             let items = match m.meta_item_list() {\n                 Some(item) => item,\n                 None => continue,\n@@ -71,16 +72,10 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         \"framework\" => NativeLibKind::Framework,\n                         \"raw-dylib\" => NativeLibKind::RawDylib,\n                         k => {\n-                            struct_span_err!(\n-                                self.tcx.sess,\n-                                item.span(),\n-                                E0458,\n-                                \"unknown kind: `{}`\",\n-                                k\n-                            )\n-                            .span_label(item.span(), \"unknown kind\")\n-                            .span_label(m.span, \"\")\n-                            .emit();\n+                            struct_span_err!(sess, item.span(), E0458, \"unknown kind: `{}`\", k)\n+                                .span_label(item.span(), \"unknown kind\")\n+                                .span_label(m.span, \"\")\n+                                .emit();\n                             NativeLibKind::Unspecified\n                         }\n                     };\n@@ -92,18 +87,18 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n                         None => continue, // skip like historical compilers\n                     };\n                     if cfg.is_empty() {\n-                        self.tcx.sess.span_err(item.span(), \"`cfg()` must have an argument\");\n+                        sess.span_err(item.span(), \"`cfg()` must have an argument\");\n                     } else if let cfg @ Some(..) = cfg[0].meta_item() {\n                         lib.cfg = cfg.cloned();\n                     } else {\n-                        self.tcx.sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n+                        sess.span_err(cfg[0].span(), \"invalid argument for `cfg(..)`\");\n                     }\n                 } else if item.has_name(sym::wasm_import_module) {\n                     match item.value_str() {\n                         Some(s) => lib.wasm_import_module = Some(s),\n                         None => {\n                             let msg = \"must be of the form `#[link(wasm_import_module = \\\"...\\\")]`\";\n-                            self.tcx.sess.span_err(item.span(), msg);\n+                            sess.span_err(item.span(), msg);\n                         }\n                     }\n                 } else {\n@@ -117,7 +112,7 @@ impl ItemLikeVisitor<'tcx> for Collector<'tcx> {\n             let requires_name = kind_specified || lib.wasm_import_module.is_none();\n             if lib.name.is_none() && requires_name {\n                 struct_span_err!(\n-                    self.tcx.sess,\n+                    sess,\n                     m.span,\n                     E0459,\n                     \"`#[link(...)]` specified without \\"}, {"sha": "8aea9a9f5885061312aa0c18e9710bf22bf57cb9", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -742,7 +742,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         SyntaxExtension::new(\n-            &sess.parse_sess,\n+            sess,\n             kind,\n             self.get_span(id, sess),\n             helper_attrs,\n@@ -1102,7 +1102,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                 // for other constructors correct visibilities\n                                 // were already encoded in metadata.\n                                 let attrs = self.get_item_attrs(def_id.index, sess);\n-                                if attr::contains_name(&attrs, sym::non_exhaustive) {\n+                                if sess.contains_name(&attrs, sym::non_exhaustive) {\n                                     let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n                                 }"}, {"sha": "10b89cdd15a527baf88b75007bbcbadfe30adff8", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,7 +5,6 @@ use crate::native_libs;\n use crate::rmeta::{self, encoder};\n \n use rustc_ast::ast;\n-use rustc_ast::attr;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n@@ -37,7 +36,7 @@ macro_rules! provide {\n                 def_id_arg: ty::query::query_keys::$name<$lt>,\n             ) -> ty::query::query_values::$name<$lt> {\n                 let _prof_timer =\n-                    $tcx.prof.generic_activity(\"metadata_decode_entry\");\n+                    $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n \n                 #[allow(unused_variables)]\n                 let ($def_id, $other) = def_id_arg.into_args();\n@@ -415,7 +414,7 @@ impl CStore {\n         // Mark the attrs as used\n         let attrs = data.get_item_attrs(id.index, sess);\n         for attr in attrs.iter() {\n-            attr::mark_used(attr);\n+            sess.mark_attr_used(attr);\n         }\n \n         let ident = data.item_ident(id.index, sess);"}, {"sha": "6723e236a1fe981e0fb9a9b022eb457231183eb9", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,9 +3,8 @@ use crate::rmeta::*;\n \n use log::{debug, trace};\n use rustc_ast::ast;\n-use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n@@ -49,8 +48,7 @@ struct EncodeContext<'a, 'tcx> {\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n \n-    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n-    interpret_allocs_inverse: Vec<interpret::AllocId>,\n+    interpret_allocs: FxIndexSet<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n     // The `usize` is an index into the `MonotonicVec`\n@@ -162,7 +160,7 @@ impl<'a, 'tcx> SpecializedEncoder<ExpnId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, expn: &ExpnId) -> Result<(), Self::Error> {\n         rustc_span::hygiene::raw_encode_expn_id(\n             *expn,\n-            &mut self.hygiene_ctxt,\n+            &self.hygiene_ctxt,\n             ExpnDataEncodeMode::Metadata,\n             self,\n         )\n@@ -280,6 +278,10 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // cross-crate inconsistencies (getting one behavior in the same\n         // crate, and a different behavior in another crate) due to the\n         // limited surface that proc-macros can expose.\n+        //\n+        // IMPORTANT: If this is ever changed, be sure to update\n+        // `rustc_span::hygiene::raw_encode_expn_id` to handle\n+        // encoding `ExpnData` for proc-macro crates.\n         if self.is_proc_macro {\n             SyntaxContext::root().encode(self)?;\n         } else {\n@@ -328,17 +330,7 @@ impl<'a, 'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'a, '\n \n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        use std::collections::hash_map::Entry;\n-        let index = match self.interpret_allocs.entry(*alloc_id) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                let idx = self.interpret_allocs_inverse.len();\n-                self.interpret_allocs_inverse.push(*alloc_id);\n-                e.insert(idx);\n-                idx\n-            }\n-        };\n-\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n         index.encode(self)\n     }\n }\n@@ -580,15 +572,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let mut n = 0;\n             trace!(\"beginning to encode alloc ids\");\n             loop {\n-                let new_n = self.interpret_allocs_inverse.len();\n+                let new_n = self.interpret_allocs.len();\n                 // if we have found new ids, serialize those, too\n                 if n == new_n {\n                     // otherwise, abort\n                     break;\n                 }\n                 trace!(\"encoding {} further alloc ids\", new_n - n);\n                 for idx in n..new_n {\n-                    let id = self.interpret_allocs_inverse[idx];\n+                    let id = self.interpret_allocs[idx];\n                     let pos = self.position() as u32;\n                     interpret_alloc_index.push(pos);\n                     interpret::specialized_encode_alloc_id(self, tcx, id).unwrap();\n@@ -633,7 +625,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let source_map_bytes = self.position() - i;\n \n         let attrs = tcx.hir().krate_attrs();\n-        let has_default_lib_allocator = attr::contains_name(&attrs, sym::default_lib_allocator);\n+        let has_default_lib_allocator = tcx.sess.contains_name(&attrs, sym::default_lib_allocator);\n \n         let root = self.lazy(CrateRoot {\n             name: tcx.crate_name(LOCAL_CRATE),\n@@ -659,12 +651,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             } else {\n                 None\n             },\n-            compiler_builtins: attr::contains_name(&attrs, sym::compiler_builtins),\n-            needs_allocator: attr::contains_name(&attrs, sym::needs_allocator),\n-            needs_panic_runtime: attr::contains_name(&attrs, sym::needs_panic_runtime),\n-            no_builtins: attr::contains_name(&attrs, sym::no_builtins),\n-            panic_runtime: attr::contains_name(&attrs, sym::panic_runtime),\n-            profiler_runtime: attr::contains_name(&attrs, sym::profiler_runtime),\n+            compiler_builtins: tcx.sess.contains_name(&attrs, sym::compiler_builtins),\n+            needs_allocator: tcx.sess.contains_name(&attrs, sym::needs_allocator),\n+            needs_panic_runtime: tcx.sess.contains_name(&attrs, sym::needs_panic_runtime),\n+            no_builtins: tcx.sess.contains_name(&attrs, sym::no_builtins),\n+            panic_runtime: tcx.sess.contains_name(&attrs, sym::panic_runtime),\n+            profiler_runtime: tcx.sess.contains_name(&attrs, sym::profiler_runtime),\n             symbol_mangling_version: tcx.sess.opts.debugging_opts.symbol_mangling_version,\n \n             crate_deps,\n@@ -2016,7 +2008,6 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         predicate_shorthands: Default::default(),\n         source_file_cache: (source_map_files[0].clone(), 0),\n         interpret_allocs: Default::default(),\n-        interpret_allocs_inverse: Default::default(),\n         required_source_files: Some(GrowableBitSet::with_capacity(source_map_files.len())),\n         is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n         hygiene_ctxt: &hygiene_ctxt,"}, {"sha": "e982053948479c59c8b75130b5dbeaf0021441b6", "filename": "src/librustc_middle/middle/limits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Flimits.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -27,7 +27,7 @@ fn update_limit(\n     default: usize,\n ) {\n     for attr in &krate.attrs {\n-        if !attr.check_name(name) {\n+        if !sess.check_name(attr, name) {\n             continue;\n         }\n "}, {"sha": "4b7663e9adec1364c8472f4ee0dd208c0596021a", "filename": "src/librustc_middle/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fquery.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -128,7 +128,7 @@ pub struct DropckOutlivesResult<'tcx> {\n \n impl<'tcx> DropckOutlivesResult<'tcx> {\n     pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-        if let Some(overflow_ty) = self.overflows.iter().next() {\n+        if let Some(overflow_ty) = self.overflows.get(0) {\n             let mut err = struct_span_err!(\n                 tcx.sess,\n                 span,"}, {"sha": "d6bcfbf49cff12b2c67c7800d16231d9f637bc52", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1040,7 +1040,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n         let attrs = self.get_attrs(def_id);\n         let get = |name| {\n-            let attr = match attrs.iter().find(|a| a.check_name(name)) {\n+            let attr = match attrs.iter().find(|a| self.sess.check_name(a, name)) {\n                 Some(attr) => attr,\n                 None => return Bound::Unbounded,\n             };\n@@ -1380,7 +1380,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// we still evaluate them eagerly.\n     #[inline]\n     pub fn lazy_normalization(self) -> bool {\n-        self.features().const_generics || self.features().lazy_normalization_consts\n+        let features = self.features();\n+        // Note: We do not enable lazy normalization for `features.min_const_generics`.\n+        features.const_generics || features.lazy_normalization_consts\n     }\n \n     #[inline]\n@@ -2736,11 +2738,11 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     };\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n+        tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::panic_runtime)\n     };\n     providers.is_compiler_builtins = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n-        attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n+        tcx.sess.contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins)\n     };\n     providers.has_panic_handler = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "81f7474962c8d503a6f54c7d1368ac1c592b803e", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -85,6 +85,8 @@ impl FlagComputation {\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n+                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n+\n                 let substs = substs.as_generator();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -107,6 +109,8 @@ impl FlagComputation {\n             }\n \n             &ty::Closure(_, substs) => {\n+                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n+\n                 let substs = substs.as_closure();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -192,6 +196,8 @@ impl FlagComputation {\n             }\n \n             &ty::FnDef(_, substs) => {\n+                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n+\n                 self.add_substs(substs);\n             }\n "}, {"sha": "87434f3f26777606c905d4bea721d7676aeb8846", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -150,6 +150,12 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n     }\n \n+    /// Does this value contain closures, generators or functions such that it may require\n+    /// polymorphization?\n+    fn may_polymorphize(&self) -> bool {\n+        self.has_type_flags(TypeFlags::MAY_POLYMORPHIZE)\n+    }\n+\n     /// A visitor that does not recurse into types, works like `fn walk_shallow` in `Ty`.\n     fn visit_tys_shallow(&self, visit: impl FnMut(Ty<'tcx>) -> bool) -> bool {\n         pub struct Visitor<F>(F);"}, {"sha": "cf876db26bc76a66f4e8fa7dca30ea468f32051d", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 77, "deletions": 20, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -474,26 +474,7 @@ impl<'tcx> Instance<'tcx> {\n         }\n \n         if let InstanceDef::Item(def) = self.def {\n-            let unused = tcx.unused_generic_params(def.did);\n-\n-            if unused.is_empty() {\n-                // Exit early if every parameter was used.\n-                return self;\n-            }\n-\n-            debug!(\"polymorphize: unused={:?}\", unused);\n-            let polymorphized_substs =\n-                InternalSubsts::for_item(tcx, def.did, |param, _| match param.kind {\n-                // If parameter is a const or type parameter..\n-                ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n-                    // ..and is within range and unused..\n-                    unused.contains(param.index).unwrap_or(false) =>\n-                        // ..then use the identity for this parameter.\n-                        tcx.mk_param_from_def(param),\n-                // Otherwise, use the parameter as before.\n-                _ => self.substs[param.index as usize],\n-            });\n-\n+            let polymorphized_substs = polymorphize(tcx, def.did, self.substs);\n             debug!(\"polymorphize: self={:?} polymorphized_substs={:?}\", self, polymorphized_substs);\n             Self { def: self.def, substs: polymorphized_substs }\n         } else {\n@@ -502,6 +483,82 @@ impl<'tcx> Instance<'tcx> {\n     }\n }\n \n+fn polymorphize<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    substs: SubstsRef<'tcx>,\n+) -> SubstsRef<'tcx> {\n+    debug!(\"polymorphize({:?}, {:?})\", def_id, substs);\n+    let unused = tcx.unused_generic_params(def_id);\n+    debug!(\"polymorphize: unused={:?}\", unused);\n+\n+    struct PolymorphizationFolder<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+    };\n+\n+    impl ty::TypeFolder<'tcx> for PolymorphizationFolder<'tcx> {\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+            debug!(\"fold_ty: ty={:?}\", ty);\n+            match ty.kind {\n+                ty::Closure(def_id, substs) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    if substs == polymorphized_substs {\n+                        ty\n+                    } else {\n+                        self.tcx.mk_closure(def_id, polymorphized_substs)\n+                    }\n+                }\n+                ty::FnDef(def_id, substs) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    if substs == polymorphized_substs {\n+                        ty\n+                    } else {\n+                        self.tcx.mk_fn_def(def_id, polymorphized_substs)\n+                    }\n+                }\n+                ty::Generator(def_id, substs, movability) => {\n+                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n+                    if substs == polymorphized_substs {\n+                        ty\n+                    } else {\n+                        self.tcx.mk_generator(def_id, polymorphized_substs, movability)\n+                    }\n+                }\n+                _ => ty.super_fold_with(self),\n+            }\n+        }\n+    }\n+\n+    InternalSubsts::for_item(tcx, def_id, |param, _| {\n+        let is_unused = unused.contains(param.index).unwrap_or(false);\n+        debug!(\"polymorphize: param={:?} is_unused={:?}\", param, is_unused);\n+        match param.kind {\n+            // If parameter is a const or type parameter..\n+            ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n+                // ..and is within range and unused..\n+                unused.contains(param.index).unwrap_or(false) =>\n+                    // ..then use the identity for this parameter.\n+                    tcx.mk_param_from_def(param),\n+\n+            // If the parameter does not contain any closures or generators, then use the\n+            // substitution directly.\n+            _ if !substs.may_polymorphize() => substs[param.index as usize],\n+\n+            // Otherwise, use the substitution after polymorphizing.\n+            _ => {\n+                let arg = substs[param.index as usize];\n+                let polymorphized_arg = arg.fold_with(&mut PolymorphizationFolder { tcx });\n+                debug!(\"polymorphize: arg={:?} polymorphized_arg={:?}\", arg, polymorphized_arg);\n+                ty::GenericArg::from(polymorphized_arg)\n+            }\n+        }\n+    })\n+}\n+\n fn needs_fn_once_adapter_shim(\n     actual_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,"}, {"sha": "0102225b9b56773e790a396afb30be831cb8f17f", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -575,6 +575,10 @@ bitflags! {\n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n         const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n+\n+        /// Does this value contain closures, generators or functions such that it may require\n+        /// polymorphization?\n+        const MAY_POLYMORPHIZE = 1 << 18;\n     }\n }\n \n@@ -2261,7 +2265,7 @@ impl ReprOptions {\n         let mut max_align: Option<Align> = None;\n         let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n+            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n@@ -2378,7 +2382,7 @@ impl<'tcx> AdtDef {\n         }\n \n         let attrs = tcx.get_attrs(did);\n-        if attr::contains_name(&attrs, sym::fundamental) {\n+        if tcx.sess.contains_name(&attrs, sym::fundamental) {\n             flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n@@ -3017,7 +3021,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Determines whether an item is annotated with an attribute.\n     pub fn has_attr(self, did: DefId, attr: Symbol) -> bool {\n-        attr::contains_name(&self.get_attrs(did), attr)\n+        self.sess.contains_name(&self.get_attrs(did), attr)\n     }\n \n     /// Returns `true` if this is an `auto trait`."}, {"sha": "bd2e7747b7db8abb8e46db49284c550fb294fe97", "filename": "src/librustc_middle/ty/query/job.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fjob.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -15,16 +15,12 @@ pub unsafe fn handle_deadlock() {\n     rustc_data_structures::sync::assert_sync::<tls::ImplicitCtxt<'_, '_>>();\n     let icx: &tls::ImplicitCtxt<'_, '_> = &*(context as *const tls::ImplicitCtxt<'_, '_>);\n \n-    let span_session_globals = rustc_span::SESSION_GLOBALS.with(|ssg| ssg as *const _);\n-    let span_session_globals = &*span_session_globals;\n-    let ast_session_globals = rustc_ast::attr::SESSION_GLOBALS.with(|asg| asg as *const _);\n-    let ast_session_globals = &*ast_session_globals;\n+    let session_globals = rustc_span::SESSION_GLOBALS.with(|sg| sg as *const _);\n+    let session_globals = &*session_globals;\n     thread::spawn(move || {\n         tls::enter_context(icx, |_| {\n-            rustc_ast::attr::SESSION_GLOBALS.set(ast_session_globals, || {\n-                rustc_span::SESSION_GLOBALS\n-                    .set(span_session_globals, || tls::with(|tcx| deadlock(tcx, &registry)))\n-            });\n+            rustc_span::SESSION_GLOBALS\n+                .set(session_globals, || tls::with(|tcx| deadlock(tcx, &registry)))\n         })\n     });\n }"}, {"sha": "08b0bfecf49099ec0642a466c1e3d4c80fdc8dec", "filename": "src/librustc_middle/ty/query/on_disk_cache.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fon_disk_cache.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -5,7 +5,7 @@ use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n use crate::ty::context::TyCtxt;\n use crate::ty::{self, Ty};\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, OnceCell};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n@@ -212,7 +212,6 @@ impl<'sess> OnDiskCache<'sess> {\n                 type_shorthands: Default::default(),\n                 predicate_shorthands: Default::default(),\n                 interpret_allocs: Default::default(),\n-                interpret_allocs_inverse: Vec::new(),\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n                 file_to_file_index,\n                 hygiene_context: &hygiene_encode_context,\n@@ -267,15 +266,15 @@ impl<'sess> OnDiskCache<'sess> {\n                 let mut interpret_alloc_index = Vec::new();\n                 let mut n = 0;\n                 loop {\n-                    let new_n = encoder.interpret_allocs_inverse.len();\n+                    let new_n = encoder.interpret_allocs.len();\n                     // If we have found new IDs, serialize those too.\n                     if n == new_n {\n                         // Otherwise, abort.\n                         break;\n                     }\n                     interpret_alloc_index.reserve(new_n - n);\n                     for idx in n..new_n {\n-                        let id = encoder.interpret_allocs_inverse[idx];\n+                        let id = encoder.interpret_allocs[idx];\n                         let pos = encoder.position() as u32;\n                         interpret_alloc_index.push(pos);\n                         interpret::specialized_encode_alloc_id(&mut encoder, tcx, id)?;\n@@ -767,8 +766,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n-    interpret_allocs_inverse: Vec<interpret::AllocId>,\n+    interpret_allocs: FxIndexSet<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n     hygiene_context: &'a HygieneEncodeContext,\n@@ -807,17 +805,7 @@ where\n     E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        use std::collections::hash_map::Entry;\n-        let index = match self.interpret_allocs.entry(*alloc_id) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                let idx = self.interpret_allocs_inverse.len();\n-                self.interpret_allocs_inverse.push(*alloc_id);\n-                e.insert(idx);\n-                idx\n-            }\n-        };\n-\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n         index.encode(self)\n     }\n }"}, {"sha": "b4299fbc5a1fe8128e5710c8cfb742d3d6095526", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,9 +3,8 @@ use crate::borrow_check::path_utils::allow_two_phase_borrow;\n use crate::borrow_check::place_ext::PlaceExt;\n use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Body, Local, Location};\n@@ -15,14 +14,11 @@ use std::ops::Index;\n \n crate struct BorrowSet<'tcx> {\n     /// The fundamental map relating bitvector indexes to the borrows\n-    /// in the MIR.\n-    crate borrows: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-\n-    /// Each borrow is also uniquely identified in the MIR by the\n-    /// `Location` of the assignment statement in which it appears on\n-    /// the right hand side; we map each such location to the\n-    /// corresponding `BorrowIndex`.\n-    crate location_map: FxHashMap<Location, BorrowIndex>,\n+    /// in the MIR. Each borrow is also uniquely identified in the MIR\n+    /// by the `Location` of the assignment statement in which it\n+    /// appears on the right hand side. Thus the location is the map\n+    /// key, and its position in the map corresponds to `BorrowIndex`.\n+    crate location_map: FxIndexMap<Location, BorrowData<'tcx>>,\n \n     /// Locations which activate borrows.\n     /// NOTE: a given location may activate more than one borrow in the future\n@@ -40,7 +36,7 @@ impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n     type Output = BorrowData<'tcx>;\n \n     fn index(&self, index: BorrowIndex) -> &BorrowData<'tcx> {\n-        &self.borrows[index]\n+        &self.location_map[index.as_usize()]\n     }\n }\n \n@@ -129,7 +125,6 @@ impl<'tcx> BorrowSet<'tcx> {\n         let mut visitor = GatherBorrows {\n             tcx,\n             body: &body,\n-            idx_vec: IndexVec::new(),\n             location_map: Default::default(),\n             activation_map: Default::default(),\n             local_map: Default::default(),\n@@ -146,7 +141,6 @@ impl<'tcx> BorrowSet<'tcx> {\n         }\n \n         BorrowSet {\n-            borrows: visitor.idx_vec,\n             location_map: visitor.location_map,\n             activation_map: visitor.activation_map,\n             local_map: visitor.local_map,\n@@ -157,13 +151,32 @@ impl<'tcx> BorrowSet<'tcx> {\n     crate fn activations_at_location(&self, location: Location) -> &[BorrowIndex] {\n         self.activation_map.get(&location).map(|activations| &activations[..]).unwrap_or(&[])\n     }\n+\n+    crate fn len(&self) -> usize {\n+        self.location_map.len()\n+    }\n+\n+    crate fn indices(&self) -> impl Iterator<Item = BorrowIndex> {\n+        BorrowIndex::from_usize(0)..BorrowIndex::from_usize(self.len())\n+    }\n+\n+    crate fn iter_enumerated(&self) -> impl Iterator<Item = (BorrowIndex, &BorrowData<'tcx>)> {\n+        self.indices().zip(self.location_map.values())\n+    }\n+\n+    crate fn get_index_of(&self, location: &Location) -> Option<BorrowIndex> {\n+        self.location_map.get_index_of(location).map(BorrowIndex::from)\n+    }\n+\n+    crate fn contains(&self, location: &Location) -> bool {\n+        self.location_map.contains_key(location)\n+    }\n }\n \n struct GatherBorrows<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n-    idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n-    location_map: FxHashMap<Location, BorrowIndex>,\n+    location_map: FxIndexMap<Location, BorrowData<'tcx>>,\n     activation_map: FxHashMap<Location, Vec<BorrowIndex>>,\n     local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n \n@@ -203,8 +216,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 borrowed_place: *borrowed_place,\n                 assigned_place: *assigned_place,\n             };\n-            let idx = self.idx_vec.push(borrow);\n-            self.location_map.insert(location, idx);\n+            let (idx, _) = self.location_map.insert_full(location, borrow);\n+            let idx = BorrowIndex::from(idx);\n \n             self.insert_as_pending_if_two_phase(location, assigned_place, kind, idx);\n \n@@ -224,7 +237,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         //\n         //     TMP = &mut place\n         if let Some(&borrow_index) = self.pending_activations.get(temp) {\n-            let borrow_data = &mut self.idx_vec[borrow_index];\n+            let borrow_data = &mut self.location_map[borrow_index.as_usize()];\n \n             // Watch out: the use of TMP in the borrow itself\n             // doesn't count as an activation. =)\n@@ -265,8 +278,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n             // double-check that we already registered a BorrowData for this\n \n-            let borrow_index = self.location_map[&location];\n-            let borrow_data = &self.idx_vec[borrow_index];\n+            let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n             assert_eq!(borrow_data.region, region.to_region_vid());\n@@ -316,7 +328,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         // Consider the borrow not activated to start. When we find an activation, we'll update\n         // this field.\n         {\n-            let borrow_data = &mut self.idx_vec[borrow_index];\n+            let borrow_data = &mut self.location_map[borrow_index.as_usize()];\n             borrow_data.activation_location = TwoPhaseActivation::NotActivated;\n         }\n \n@@ -332,7 +344,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n                        at borrow_index: {:?} with associated data {:?}\",\n                 temp,\n                 old_index,\n-                self.idx_vec[old_index]\n+                self.location_map[old_index.as_usize()]\n             );\n         }\n     }"}, {"sha": "33b09dcb888ed680cfa676663cd5010b850e35da", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -217,7 +217,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,\n                                 self.body,\n-                                self.borrow_set.borrows[borrow_index].borrowed_place,\n+                                self.borrow_set[borrow_index].borrowed_place,\n                                 place,\n                                 places_conflict::PlaceConflictBias::NoOverlap,\n                             );"}, {"sha": "ba74ffaa8d620f8536dda39b468ab48584061992", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -868,7 +868,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n         }\n-        return normal_ret;\n+        normal_ret\n     }\n \n     /// Finds the span of arguments of a closure (within `maybe_closure_span`)"}, {"sha": "2de2124dc5e0eaab2cc85e6590422bc2f06ec330", "filename": "src/librustc_mir/borrow_check/invalidation.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Finvalidation.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -166,8 +166,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n                 let resume = self.location_table.start_index(resume.start_location());\n-                for i in borrow_set.borrows.indices() {\n-                    if borrow_of_local_data(borrow_set.borrows[i].borrowed_place) {\n+                for (i, data) in borrow_set.iter_enumerated() {\n+                    if borrow_of_local_data(data.borrowed_place) {\n                         self.all_facts.invalidates.push((resume, i));\n                     }\n                 }\n@@ -178,8 +178,8 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n                 let start = self.location_table.start_index(location);\n-                for i in borrow_set.borrows.indices() {\n-                    if borrow_of_local_data(borrow_set.borrows[i].borrowed_place) {\n+                for (i, data) in borrow_set.iter_enumerated() {\n+                    if borrow_of_local_data(data.borrowed_place) {\n                         self.all_facts.invalidates.push((start, i));\n                     }\n                 }\n@@ -369,7 +369,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n         let tcx = self.tcx;\n         let body = self.body;\n         let borrow_set = self.borrow_set.clone();\n-        let indices = self.borrow_set.borrows.indices();\n+        let indices = self.borrow_set.indices();\n         each_borrow_involving_path(\n             self,\n             tcx,"}, {"sha": "6e211b42a052ee36575f983a59931655fa14e334", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1131,11 +1131,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 (\n                     Reservation(WriteKind::MutableBorrow(bk)),\n                     BorrowKind::Shallow | BorrowKind::Shared,\n-                ) if {\n-                    tcx.migrate_borrowck() && this.borrow_set.location_map.contains_key(&location)\n-                } =>\n-                {\n-                    let bi = this.borrow_set.location_map[&location];\n+                ) if { tcx.migrate_borrowck() && this.borrow_set.contains(&location) } => {\n+                    let bi = this.borrow_set.get_index_of(&location).unwrap();\n                     debug!(\n                         \"recording invalid reservation of place: {:?} with \\\n                          borrow index {:?} as warning\","}, {"sha": "66a17cba6bb010b225a28b8d651531fbb3c0112c", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -206,7 +206,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n         //   the `borrow_set`, their `BorrowIndex` are synthesized as the universal region index\n         //   added to the existing number of loans, as if they succeeded them in the set.\n         //\n-        let borrow_count = borrow_set.borrows.len();\n+        let borrow_count = borrow_set.len();\n         debug!(\n             \"compute_regions: polonius placeholders, num_universals={}, borrow_count={}\",\n             universal_regions.len(),"}, {"sha": "8a5a600cfdd8a76863167cc4e1dda98412b7e019", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n@@ -193,26 +193,25 @@ impl<N: Idx> LivenessValues<N> {\n /// NLL.\n #[derive(Default)]\n crate struct PlaceholderIndices {\n-    to_index: FxHashMap<ty::PlaceholderRegion, PlaceholderIndex>,\n-    from_index: IndexVec<PlaceholderIndex, ty::PlaceholderRegion>,\n+    indices: FxIndexSet<ty::PlaceholderRegion>,\n }\n \n impl PlaceholderIndices {\n     crate fn insert(&mut self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n-        let PlaceholderIndices { to_index, from_index } = self;\n-        *to_index.entry(placeholder).or_insert_with(|| from_index.push(placeholder))\n+        let (index, _) = self.indices.insert_full(placeholder);\n+        index.into()\n     }\n \n     crate fn lookup_index(&self, placeholder: ty::PlaceholderRegion) -> PlaceholderIndex {\n-        self.to_index[&placeholder]\n+        self.indices.get_index_of(&placeholder).unwrap().into()\n     }\n \n     crate fn lookup_placeholder(&self, placeholder: PlaceholderIndex) -> ty::PlaceholderRegion {\n-        self.from_index[placeholder]\n+        self.indices[placeholder.index()]\n     }\n \n     crate fn len(&self) -> usize {\n-        self.from_index.len()\n+        self.indices.len()\n     }\n }\n "}, {"sha": "ff98de5475ecff8076a2b9b64ccc64568d834466", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2469,11 +2469,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // example).\n         if let Some(all_facts) = all_facts {\n             let _prof_timer = self.infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n-            if let Some(borrow_index) = borrow_set.location_map.get(&location) {\n+            if let Some(borrow_index) = borrow_set.get_index_of(&location) {\n                 let region_vid = borrow_region.to_region_vid();\n                 all_facts.borrow_region.push((\n                     region_vid,\n-                    *borrow_index,\n+                    borrow_index,\n                     location_table.mid_index(location),\n                 ));\n             }"}, {"sha": "89e2d7088f7b6b75c29aad6438711857cead658b", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -335,7 +335,7 @@ impl RustcMirAttrs {\n \n         let rustc_mir_attrs = attrs\n             .iter()\n-            .filter(|attr| attr.check_name(sym::rustc_mir))\n+            .filter(|attr| tcx.sess.check_name(attr, sym::rustc_mir))\n             .flat_map(|attr| attr.meta_item_list().into_iter().flat_map(|v| v.into_iter()));\n \n         for attr in rustc_mir_attrs {"}, {"sha": "7e7b7f2cc76fae2849c7db753683a930a49cf2ad", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -136,9 +136,9 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n         let mut borrows_out_of_scope_at_location = FxHashMap::default();\n-        for (borrow_index, borrow_data) in borrow_set.borrows.iter_enumerated() {\n+        for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n             let borrow_region = borrow_data.region.to_region_vid();\n-            let location = borrow_set.borrows[borrow_index].reserve_location;\n+            let location = borrow_data.reserve_location;\n \n             precompute_borrows_out_of_scope(\n                 body,\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {\n-        &self.borrow_set.borrows[idx].reserve_location\n+        &self.borrow_set[idx].reserve_location\n     }\n \n     /// Add all borrows to the kill set, if those borrows are out of scope at `location`.\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n             places_conflict(\n                 self.tcx,\n                 self.body,\n-                self.borrow_set.borrows[i].borrowed_place,\n+                self.borrow_set[i].borrowed_place,\n                 place,\n                 PlaceConflictBias::NoOverlap,\n             )\n@@ -232,7 +232,7 @@ impl<'tcx> dataflow::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     const NAME: &'static str = \"borrows\";\n \n     fn bits_per_block(&self, _: &mir::Body<'tcx>) -> usize {\n-        self.borrow_set.borrows.len() * 2\n+        self.borrow_set.len() * 2\n     }\n \n     fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n@@ -271,11 +271,11 @@ impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n                     ) {\n                         return;\n                     }\n-                    let index = self.borrow_set.location_map.get(&location).unwrap_or_else(|| {\n+                    let index = self.borrow_set.get_index_of(&location).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndex for location {:?}\", location);\n                     });\n \n-                    trans.gen(*index);\n+                    trans.gen(index);\n                 }\n \n                 // Make sure there are no remaining borrows for variables"}, {"sha": "fdec5729a542591688ea7e93ecee91d67f56fd50", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,5 +1,6 @@\n use rustc_ast::ast::{self, MetaItem};\n use rustc_middle::ty;\n+use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n pub(crate) use self::drop_flag_effects::*;\n@@ -28,9 +29,13 @@ pub struct MoveDataParamEnv<'tcx> {\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n-pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n+pub(crate) fn has_rustc_mir_with(\n+    sess: &Session,\n+    attrs: &[ast::Attribute],\n+    name: Symbol,\n+) -> Option<MetaItem> {\n     for attr in attrs {\n-        if attr.check_name(sym::rustc_mir) {\n+        if sess.check_name(attr, sym::rustc_mir) {\n             let items = attr.meta_item_list();\n             for item in items.iter().flat_map(|l| l.iter()) {\n                 match item.meta_item() {"}, {"sha": "a996b6fb9d924bf2e7dfde606ce485b22765a94d", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::ty::{\n     self,\n     fold::{TypeFoldable, TypeVisitor},\n     query::Providers,\n+    subst::SubstsRef,\n     Const, Ty, TyCtxt,\n };\n use rustc_span::symbol::sym;\n@@ -170,7 +171,11 @@ fn emit_unused_generic_params_error<'tcx>(\n ) {\n     debug!(\"emit_unused_generic_params_error: def_id={:?}\", def_id);\n     let base_def_id = tcx.closure_base_def_id(def_id);\n-    if !tcx.get_attrs(base_def_id).iter().any(|a| a.check_name(sym::rustc_polymorphize_error)) {\n+    if !tcx\n+        .get_attrs(base_def_id)\n+        .iter()\n+        .any(|a| tcx.sess.check_name(a, sym::rustc_polymorphize_error))\n+    {\n         return;\n     }\n \n@@ -205,6 +210,25 @@ struct UsedGenericParametersVisitor<'a, 'tcx> {\n     unused_parameters: &'a mut FiniteBitSet<u32>,\n }\n \n+impl<'a, 'tcx> UsedGenericParametersVisitor<'a, 'tcx> {\n+    /// Invoke `unused_generic_params` on a body contained within the current item (e.g.\n+    /// a closure, generator or constant).\n+    fn visit_child_body(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) {\n+        let unused = self.tcx.unused_generic_params(def_id);\n+        debug!(\n+            \"visit_child_body: unused_parameters={:?} unused={:?}\",\n+            self.unused_parameters, unused\n+        );\n+        for (i, arg) in substs.iter().enumerate() {\n+            let i = i.try_into().unwrap();\n+            if !unused.contains(i).unwrap_or(false) {\n+                arg.visit_with(self);\n+            }\n+        }\n+        debug!(\"visit_child_body: unused_parameters={:?}\", self.unused_parameters);\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n     fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         debug!(\"visit_local_decl: local_decl={:?}\", local_decl);\n@@ -245,6 +269,17 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n                 self.unused_parameters.clear(param.index);\n                 false\n             }\n+            ty::ConstKind::Unevaluated(_, _, Some(p)) => {\n+                // If there is a promoted, don't look at the substs - since it will always contain\n+                // the generic parameters, instead, traverse the promoted MIR.\n+                let promoted = self.tcx.promoted_mir(self.def_id);\n+                self.visit_body(&promoted[p]);\n+                false\n+            }\n+            ty::ConstKind::Unevaluated(def_id, unevaluated_substs, None) => {\n+                self.visit_child_body(def_id.did, unevaluated_substs);\n+                false\n+            }\n             _ => c.super_visit_with(self),\n         }\n     }\n@@ -265,19 +300,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UsedGenericParametersVisitor<'a, 'tcx> {\n \n                 // Consider any generic parameters used by any closures/generators as used in the\n                 // parent.\n-                let unused = self.tcx.unused_generic_params(def_id);\n-                debug!(\n-                    \"visit_ty: unused_parameters={:?} unused={:?}\",\n-                    self.unused_parameters, unused\n-                );\n-                for (i, arg) in substs.iter().enumerate() {\n-                    let i = i.try_into().unwrap();\n-                    if !unused.contains(i).unwrap_or(false) {\n-                        arg.visit_with(self);\n-                    }\n-                }\n-                debug!(\"visit_ty: unused_parameters={:?}\", self.unused_parameters);\n-\n+                self.visit_child_body(def_id, substs);\n                 false\n             }\n             ty::Param(param) => {"}, {"sha": "db0b0415728aec2d699d617e22e092d6bf6b245d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 70, "deletions": 60, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -34,7 +34,9 @@ use crate::interpret::{\n };\n use crate::transform::{MirPass, MirSource};\n \n-/// The maximum number of bytes that we'll allocate space for a return value.\n+/// The maximum number of bytes that we'll allocate space for a local or the return value.\n+/// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n+/// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n \n /// Macro for machine-specific `InterpError` without allocation.\n@@ -155,14 +157,19 @@ struct ConstPropMachine<'mir, 'tcx> {\n     written_only_inside_own_block_locals: FxHashSet<Local>,\n     /// Locals that need to be cleared after every block terminates.\n     only_propagate_inside_block_locals: BitSet<Local>,\n+    can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl<'mir, 'tcx> ConstPropMachine<'mir, 'tcx> {\n-    fn new(only_propagate_inside_block_locals: BitSet<Local>) -> Self {\n+    fn new(\n+        only_propagate_inside_block_locals: BitSet<Local>,\n+        can_const_prop: IndexVec<Local, ConstPropMode>,\n+    ) -> Self {\n         Self {\n             stack: Vec::new(),\n             written_only_inside_own_block_locals: Default::default(),\n             only_propagate_inside_block_locals,\n+            can_const_prop,\n         }\n     }\n }\n@@ -241,6 +248,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         local: Local,\n     ) -> InterpResult<'tcx, Result<&'a mut LocalValue<Self::PointerTag>, MemPlace<Self::PointerTag>>>\n     {\n+        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n+            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n+        }\n         if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n             ecx.machine.written_only_inside_own_block_locals.insert(local);\n         }\n@@ -285,7 +295,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n     param_env: ParamEnv<'tcx>,\n     // FIXME(eddyb) avoid cloning these two fields more than once,\n     // by accessing them through `ecx` instead.\n@@ -331,7 +340,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let span = tcx.def_span(def_id);\n-        let can_const_prop = CanConstProp::check(body);\n+        // FIXME: `CanConstProp::check` computes the layout of all locals, return those layouts\n+        // so we can write them to `ecx.frame_mut().locals.layout, reducing the duplication in\n+        // `layout_of` query invocations.\n+        let can_const_prop = CanConstProp::check(tcx, param_env, body);\n         let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n         for (l, mode) in can_const_prop.iter_enumerated() {\n             if *mode == ConstPropMode::OnlyInsideOwnBlock {\n@@ -342,7 +354,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             tcx,\n             span,\n             param_env,\n-            ConstPropMachine::new(only_propagate_inside_block_locals),\n+            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n             (),\n         );\n \n@@ -368,7 +380,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             ecx,\n             tcx,\n             param_env,\n-            can_const_prop,\n             // FIXME(eddyb) avoid cloning these two fields more than once,\n             // by accessing them through `ecx` instead.\n             source_scopes: body.source_scopes.clone(),\n@@ -612,15 +623,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n-        place_layout: TyAndLayout<'tcx>,\n         source_info: SourceInfo,\n         place: Place<'tcx>,\n     ) -> Option<()> {\n-        // #66397: Don't try to eval into large places as that can cause an OOM\n-        if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n-            return None;\n-        }\n-\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -893,7 +898,11 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// Returns true if `local` can be propagated\n-    fn check(body: &Body<'_>) -> IndexVec<Local, ConstPropMode> {\n+    fn check(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        body: &Body<'tcx>,\n+    ) -> IndexVec<Local, ConstPropMode> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n             found_assignment: BitSet::new_empty(body.local_decls.len()),\n@@ -903,6 +912,16 @@ impl CanConstProp {\n             ),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n+            let ty = body.local_decls[local].ty;\n+            match tcx.layout_of(param_env.and(ty)) {\n+                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n+                // Either the layout fails to compute, then we can't use this local anyway\n+                // or the local is too large, then we don't want to.\n+                _ => {\n+                    *val = ConstPropMode::NoPropagation;\n+                    continue;\n+                }\n+            }\n             // Cannot use args at all\n             // Cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n@@ -1018,61 +1037,52 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n         if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n-            let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n-            if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                let can_const_prop = self.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n-                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                    // type whose creation requires no write. E.g. a generator whose initial state\n-                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                    if let Some(value) = self.get_const(place) {\n-                        if self.should_const_prop(value) {\n-                            trace!(\"replacing {:?} with {:?}\", rval, value);\n-                            self.replace_with_const(rval, value, source_info);\n-                            if can_const_prop == ConstPropMode::FullConstProp\n-                                || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                            {\n-                                trace!(\"propagated into {:?}\", place);\n-                            }\n+            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n+            if let Some(()) = self.const_prop(rval, source_info, place) {\n+                // This will return None if the above `const_prop` invocation only \"wrote\" a\n+                // type whose creation requires no write. E.g. a generator whose initial state\n+                // consists solely of uninitialized memory (so it doesn't capture any locals).\n+                if let Some(value) = self.get_const(place) {\n+                    if self.should_const_prop(value) {\n+                        trace!(\"replacing {:?} with {:?}\", rval, value);\n+                        self.replace_with_const(rval, value, source_info);\n+                        if can_const_prop == ConstPropMode::FullConstProp\n+                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                        {\n+                            trace!(\"propagated into {:?}\", place);\n                         }\n                     }\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n+                }\n+                match can_const_prop {\n+                    ConstPropMode::OnlyInsideOwnBlock => {\n+                        trace!(\n+                            \"found local restricted to its block. \\\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n+                            place.local\n+                        );\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        trace!(\"can't propagate into {:?}\", place);\n+                        if place.local != RETURN_PLACE {\n+                            Self::remove_const(&mut self.ecx, place.local);\n                         }\n-                        ConstPropMode::FullConstProp => {}\n                     }\n-                } else {\n-                    // Const prop failed, so erase the destination, ensuring that whatever happens\n-                    // from here on, does not know about the previous value.\n-                    // This is important in case we have\n-                    // ```rust\n-                    // let mut x = 42;\n-                    // x = SOME_MUTABLE_STATIC;\n-                    // // x must now be undefined\n-                    // ```\n-                    // FIXME: we overzealously erase the entire local, because that's easier to\n-                    // implement.\n-                    trace!(\n-                        \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                        place,\n-                    );\n-                    Self::remove_const(&mut self.ecx, place.local);\n+                    ConstPropMode::FullConstProp => {}\n                 }\n             } else {\n+                // Const prop failed, so erase the destination, ensuring that whatever happens\n+                // from here on, does not know about the previous value.\n+                // This is important in case we have\n+                // ```rust\n+                // let mut x = 42;\n+                // x = SOME_MUTABLE_STATIC;\n+                // // x must now be undefined\n+                // ```\n+                // FIXME: we overzealously erase the entire local, because that's easier to\n+                // implement.\n                 trace!(\n-                    \"cannot propagate into {:?}, because the type of the local is generic.\",\n+                    \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n                     place,\n                 );\n                 Self::remove_const(&mut self.ecx, place.local);"}, {"sha": "c0564105701575f20c9c00150f3be4d61ce602f9", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -130,7 +130,7 @@ impl Candidate {\n \n fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Vec<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n-    let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;\n+    let attr = attrs.iter().find(|a| tcx.sess.check_name(a, sym::rustc_args_required_const))?;\n     let mut ret = vec![];\n     for meta in attr.meta_item_list()? {\n         match meta.literal()?.kind {"}, {"sha": "dfd01e27d57c99bfbed9259f31104ae9ef2aa704", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -342,7 +342,7 @@ fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n \n@@ -362,7 +362,7 @@ pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n "}, {"sha": "729e22a94dcbb9a003dc72e40607b71a5a2fd92d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -35,47 +35,48 @@ impl<'tcx> MirPass<'tcx> for SanityCheck {\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(body, tcx, param_env).unwrap();\n         let mdpe = MoveDataParamEnv { move_data, param_env };\n+        let sess = &tcx.sess;\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_init).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_init).is_some() {\n             let flow_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_inits);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_maybe_uninit).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_maybe_uninit).is_some() {\n             let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_uninits);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_definite_init).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_definite_init).is_some() {\n             let flow_def_inits = DefinitelyInitializedPlaces::new(tcx, body, &mdpe)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_def_inits);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_indirectly_mutable).is_some() {\n             let flow_mut_borrowed = MaybeMutBorrowedLocals::mut_borrows_only(tcx, body, param_env)\n                 .into_engine(tcx, body, def_id)\n                 .iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_mut_borrowed);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::rustc_peek_liveness).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::rustc_peek_liveness).is_some() {\n             let flow_liveness =\n                 MaybeLiveLocals.into_engine(tcx, body, def_id).iterate_to_fixpoint();\n \n             sanity_check_via_rustc_peek(tcx, body, def_id, &attributes, &flow_liveness);\n         }\n \n-        if has_rustc_mir_with(&attributes, sym::stop_after_dataflow).is_some() {\n+        if has_rustc_mir_with(sess, &attributes, sym::stop_after_dataflow).is_some() {\n             tcx.sess.fatal(\"stop_after_dataflow ended compilation\");\n         }\n     }"}, {"sha": "02896d7de357ff40524e740a303f75264bec4232", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -361,7 +361,7 @@ fn optimization_applies<'tcx>(\n     }\n \n     trace!(\"SUCCESS: optimization applies!\");\n-    return true;\n+    true\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyArmIdentity {"}, {"sha": "9296e2ca7008fdb4840830992c8c052576cf9063", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -115,7 +115,7 @@ pub fn equal_up_to_regions(\n             T: Relate<'tcx>,\n         {\n             self.relate(a.skip_binder(), b.skip_binder())?;\n-            Ok(a.clone())\n+            Ok(a)\n         }\n     }\n "}, {"sha": "5f87cb364b891de29159e869aed9739529ee79d7", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -11,7 +11,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use crate::thir::{self, *};\n use rustc_data_structures::{\n-    fx::{FxHashMap, FxHashSet},\n+    fx::{FxHashSet, FxIndexMap},\n     stack::ensure_sufficient_stack,\n };\n use rustc_hir::HirId;\n@@ -817,9 +817,7 @@ enum TestKind<'tcx> {\n         ///\n         /// For `bool` we always generate two edges, one for `true` and one for\n         /// `false`.\n-        options: Vec<u128>,\n-        /// Reverse map used to ensure that the values in `options` are unique.\n-        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     },\n \n     /// Test for equality with value, possibly after an unsizing coercion to\n@@ -1396,14 +1394,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+            TestKind::SwitchInt { switch_ty, ref mut options } => {\n                 for candidate in candidates.iter() {\n                     if !self.add_cases_to_switch(\n                         &match_place,\n                         candidate,\n                         switch_ty,\n                         options,\n-                        indices,\n                     ) {\n                         break;\n                     }"}, {"sha": "87977d6fe8904e84a7996150c9ec992c82960e92", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -9,7 +9,7 @@ use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n use crate::thir::pattern::compare_const_vals;\n use crate::thir::*;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::RangeEnd;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::mir::*;\n@@ -44,8 +44,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                         // these maps are empty to start; cases are\n                         // added below in add_cases_to_switch\n-                        options: vec![],\n-                        indices: Default::default(),\n+                        options: Default::default(),\n                     },\n                 }\n             }\n@@ -83,8 +82,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test_place: &Place<'tcx>,\n         candidate: &Candidate<'pat, 'tcx>,\n         switch_ty: Ty<'tcx>,\n-        options: &mut Vec<u128>,\n-        indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: &mut FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> bool {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n             Some(match_pair) => match_pair,\n@@ -95,9 +93,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatKind::Constant { value } => {\n-                indices.entry(value).or_insert_with(|| {\n-                    options.push(value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty));\n-                    options.len() - 1\n+                options.entry(value).or_insert_with(|| {\n+                    value.eval_bits(self.hir.tcx(), self.hir.param_env, switch_ty)\n                 });\n                 true\n             }\n@@ -106,7 +103,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             PatKind::Range(range) => {\n                 // Check that none of the switch values are in the range.\n-                self.values_not_contained_in_range(range, indices).unwrap_or(false)\n+                self.values_not_contained_in_range(range, options).unwrap_or(false)\n             }\n             PatKind::Slice { .. }\n             | PatKind::Array { .. }\n@@ -216,7 +213,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 );\n             }\n \n-            TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n+            TestKind::SwitchInt { switch_ty, ref options } => {\n                 let target_blocks = make_target_blocks(self);\n                 let terminator = if switch_ty.kind == ty::Bool {\n                     assert!(!options.is_empty() && options.len() <= 2);\n@@ -236,7 +233,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     TerminatorKind::SwitchInt {\n                         discr: Operand::Copy(place),\n                         switch_ty,\n-                        values: options.clone().into(),\n+                        values: options.values().copied().collect(),\n                         targets: target_blocks,\n                     }\n                 };\n@@ -532,20 +529,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // FIXME(#29623) we could use PatKind::Range to rule\n             // things out here, in some cases.\n             (\n-                &TestKind::SwitchInt { switch_ty: _, options: _, ref indices },\n+                &TestKind::SwitchInt { switch_ty: _, ref options },\n                 &PatKind::Constant { ref value },\n             ) if is_switch_ty(match_pair.pattern.ty) => {\n-                let index = indices[value];\n+                let index = options.get_index_of(value).unwrap();\n                 self.candidate_without_match_pair(match_pair_index, candidate);\n                 Some(index)\n             }\n \n             (\n-                &TestKind::SwitchInt { switch_ty: _, ref options, ref indices },\n+                &TestKind::SwitchInt { switch_ty: _, ref options },\n                 &PatKind::Range(range),\n             ) => {\n                 let not_contained =\n-                    self.values_not_contained_in_range(range, indices).unwrap_or(false);\n+                    self.values_not_contained_in_range(range, options).unwrap_or(false);\n \n                 if not_contained {\n                     // No switch values are contained in the pattern range,\n@@ -777,9 +774,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatRange<'tcx>,\n-        indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        options: &FxIndexMap<&'tcx ty::Const<'tcx>, u128>,\n     ) -> Option<bool> {\n-        for &val in indices.keys() {\n+        for &val in options.keys() {\n             if self.const_range_contains(range, val)? {\n                 return Some(false);\n             }"}, {"sha": "f3f3c3e33a46d1f64d7191a8419bb2fb5eedfe91", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -537,7 +537,7 @@ macro_rules! unpack {\n fn should_abort_on_panic(tcx: TyCtxt<'_>, fn_def_id: LocalDefId, _abi: Abi) -> bool {\n     // Validate `#[unwind]` syntax regardless of platform-specific panic strategy.\n     let attrs = &tcx.get_attrs(fn_def_id.to_def_id());\n-    let unwind_attr = attr::find_unwind_attr(Some(tcx.sess.diagnostic()), attrs);\n+    let unwind_attr = attr::find_unwind_attr(&tcx.sess, attrs);\n \n     // We never unwind, so it's not relevant to stop an unwind.\n     if tcx.sess.panic_strategy() != PanicStrategy::Unwind {"}, {"sha": "bb814ab8248836370c5ffd0ac4ad4c7a0cdaa294", "filename": "src/librustc_mir_build/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -6,7 +6,6 @@ use crate::thir::util::UserAnnotatedTyHelpers;\n use crate::thir::*;\n \n use rustc_ast::ast;\n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::Node;\n@@ -69,7 +68,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n         // the settings for the crate they are codegened in.\n-        let mut check_overflow = attr::contains_name(attrs, sym::rustc_inherit_overflow_checks);\n+        let mut check_overflow = tcx.sess.contains_name(attrs, sym::rustc_inherit_overflow_checks);\n \n         // Respect -C overflow-checks.\n         check_overflow |= tcx.sess.overflow_checks();"}, {"sha": "c3a79660eb9b9fb15e2d6dc3c00dc532673a1771", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, CommentKind, Token, TokenKind};\n use rustc_ast::util::comments;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, FatalError};\n@@ -170,22 +170,20 @@ impl<'a> StringReader<'a> {\n         match token {\n             rustc_lexer::TokenKind::LineComment => {\n                 let string = self.str_from(start);\n-                // comments with only more \"/\"s are not doc comments\n-                if comments::is_line_doc_comment(string) {\n+                if let Some(attr_style) = comments::line_doc_comment_style(string) {\n                     self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n-                    token::DocComment(Symbol::intern(string))\n+                    // Opening delimiter of the length 3 is not included into the symbol.\n+                    token::DocComment(CommentKind::Line, attr_style, Symbol::intern(&string[3..]))\n                 } else {\n                     token::Comment\n                 }\n             }\n             rustc_lexer::TokenKind::BlockComment { terminated } => {\n                 let string = self.str_from(start);\n-                // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-                // but comments with only \"*\"s between two \"/\"s are not\n-                let is_doc_comment = comments::is_block_doc_comment(string);\n+                let attr_style = comments::block_doc_comment_style(string, terminated);\n \n                 if !terminated {\n-                    let msg = if is_doc_comment {\n+                    let msg = if attr_style.is_some() {\n                         \"unterminated block doc-comment\"\n                     } else {\n                         \"unterminated block comment\"\n@@ -202,9 +200,15 @@ impl<'a> StringReader<'a> {\n                     FatalError.raise();\n                 }\n \n-                if is_doc_comment {\n+                if let Some(attr_style) = attr_style {\n                     self.forbid_bare_cr(start, string, \"bare CR not allowed in block doc-comment\");\n-                    token::DocComment(Symbol::intern(string))\n+                    // Opening delimiter of the length 3 and closing delimiter of the length 2\n+                    // are not included into the symbol.\n+                    token::DocComment(\n+                        CommentKind::Block,\n+                        attr_style,\n+                        Symbol::intern(&string[3..string.len() - if terminated { 2 } else { 0 }]),\n+                    )\n                 } else {\n                     token::Comment\n                 }"}, {"sha": "723e4333790ae002b108b35591d9fb78d3b81788", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -486,7 +486,9 @@ fn token_probably_equal_for_proc_macro(first: &Token, other: &Token) -> bool {\n \n         (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n \n-        (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n+        (&DocComment(a1, a2, a3), &DocComment(b1, b2, b3)) => a1 == b1 && a2 == b2 && a3 == b3,\n+\n+        (&Shebang(a), &Shebang(b)) => a == b,\n \n         (&Literal(a), &Literal(b)) => a == b,\n \n@@ -524,7 +526,7 @@ fn prepend_attrs(\n \n         let item = match attr.kind {\n             ast::AttrKind::Normal(ref item) => item,\n-            ast::AttrKind::DocComment(_) => {\n+            ast::AttrKind::DocComment(..) => {\n                 let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n                 builder.push(stream);\n                 continue;"}, {"sha": "b6a8ee71beb0cc029e916498e814b295a78460dd", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,10 +2,9 @@ use super::{Parser, PathStyle};\n use rustc_ast::ast;\n use rustc_ast::attr;\n use rustc_ast::token::{self, Nonterminal};\n-use rustc_ast::util::comments;\n use rustc_ast_pretty::pprust;\n use rustc_errors::{error_code, PResult};\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n \n use log::debug;\n \n@@ -47,8 +46,8 @@ impl<'a> Parser<'a> {\n                 let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n                 attrs.push(attr);\n                 just_parsed_doc_comment = false;\n-            } else if let token::DocComment(s) = self.token.kind {\n-                let attr = self.mk_doc_comment(s);\n+            } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n+                let attr = attr::mk_doc_comment(comment_kind, attr_style, data, self.token.span);\n                 if attr.style != ast::AttrStyle::Outer {\n                     self.sess\n                         .span_diagnostic\n@@ -73,10 +72,6 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    fn mk_doc_comment(&self, s: Symbol) -> ast::Attribute {\n-        attr::mk_doc_comment(comments::doc_comment_style(s), s, self.token.span)\n-    }\n-\n     /// Matches `attribute = # ! [ meta_item ]`.\n     ///\n     /// If `permit_inner` is `true`, then a leading `!` indicates an inner\n@@ -184,9 +179,9 @@ impl<'a> Parser<'a> {\n                 let attr = self.parse_attribute(true)?;\n                 assert_eq!(attr.style, ast::AttrStyle::Inner);\n                 attrs.push(attr);\n-            } else if let token::DocComment(s) = self.token.kind {\n+            } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n                 // We need to get the position of this token before we bump.\n-                let attr = self.mk_doc_comment(s);\n+                let attr = attr::mk_doc_comment(comment_kind, attr_style, data, self.token.span);\n                 if attr.style == ast::AttrStyle::Inner {\n                     attrs.push(attr);\n                     self.bump();"}, {"sha": "2854356ab0fc6cd89582b6308bebf60d91d1bf98", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1419,7 +1419,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n-        if let token::DocComment(_) = self.token.kind {\n+        if let token::DocComment(..) = self.token.kind {\n             self.struct_span_err(\n                 self.token.span,\n                 \"documentation comments cannot be applied to a function parameter's type\","}, {"sha": "55a134ae09115ae5b32ced5f3e43e112ba03f2e1", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1733,13 +1733,20 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(lo.to(self.prev_token.span), kind, attrs))\n     }\n \n-    fn error_missing_in_for_loop(&self) {\n-        let in_span = self.prev_token.span.between(self.token.span);\n-        self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+    fn error_missing_in_for_loop(&mut self) {\n+        let (span, msg, sugg) = if self.token.is_ident_named(sym::of) {\n+            // Possibly using JS syntax (#75311).\n+            let span = self.token.span;\n+            self.bump();\n+            (span, \"try using `in` here instead\", \"in\")\n+        } else {\n+            (self.prev_token.span.between(self.token.span), \"try adding `in` here\", \" in \")\n+        };\n+        self.struct_span_err(span, \"missing `in` in `for` loop\")\n             .span_suggestion_short(\n-                in_span,\n-                \"try adding `in` here\",\n-                \" in \".into(),\n+                span,\n+                msg,\n+                sugg.into(),\n                 // Has been misleading, at least in the past (closed Issue #48492).\n                 Applicability::MaybeIncorrect,\n             )"}, {"sha": "be72ed6dffb7c6aa5a58e3ceb80bea0b5100541d", "filename": "src/librustc_parse/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fgenerics.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -54,7 +54,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.gate(sym::const_generics, const_span.to(self.prev_token.span));\n+        self.sess.gated_spans.gate(sym::min_const_generics, const_span.to(self.prev_token.span));\n \n         Ok(GenericParam {\n             ident,"}, {"sha": "10d214e52abdbdda46f4b6df3de9508b5db0abcb", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -610,7 +610,7 @@ impl<'a> Parser<'a> {\n \n     /// Recover on a doc comment before `}`.\n     fn recover_doc_comment_before_brace(&mut self) -> bool {\n-        if let token::DocComment(_) = self.token.kind {\n+        if let token::DocComment(..) = self.token.kind {\n             if self.look_ahead(1, |tok| tok == &token::CloseDelim(token::Brace)) {\n                 struct_span_err!(\n                     self.diagnostic(),\n@@ -1231,7 +1231,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n             }\n             token::CloseDelim(token::Brace) => {}\n-            token::DocComment(_) => {\n+            token::DocComment(..) => {\n                 let previous_span = self.prev_token.span;\n                 let mut err = self.span_fatal_err(self.token.span, Error::UselessDocComment);\n                 self.bump(); // consume the doc comment"}, {"sha": "b33ae4bed828b95ad518c274e778244e3f9cacef", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -22,7 +22,6 @@ use rustc_ast::ast::{\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{self, DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n-use rustc_ast::util::comments::{doc_comment_style, strip_doc_comment_decoration};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError, PResult};\n use rustc_session::parse::ParseSess;\n@@ -104,6 +103,8 @@ pub struct Parser<'a> {\n     /// error.\n     pub(super) unclosed_delims: Vec<UnmatchedBrace>,\n     last_unexpected_token_span: Option<Span>,\n+    /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n+    /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n     pub last_type_ascription: Option<(Span, bool /* likely path typo */)>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n     subparser_name: Option<&'static str>,\n@@ -209,18 +210,18 @@ impl TokenCursor {\n     }\n \n     fn next_desugared(&mut self) -> Token {\n-        let (name, sp) = match self.next() {\n-            Token { kind: token::DocComment(name), span } => (name, span),\n+        let (data, attr_style, sp) = match self.next() {\n+            Token { kind: token::DocComment(_, attr_style, data), span } => {\n+                (data, attr_style, span)\n+            }\n             tok => return tok,\n         };\n \n-        let stripped = strip_doc_comment_decoration(name);\n-\n         // Searches for the occurrences of `\"#*` and returns the minimum number of `#`s\n         // required to wrap the text.\n         let mut num_of_hashes = 0;\n         let mut count = 0;\n-        for ch in stripped.chars() {\n+        for ch in data.as_str().chars() {\n             count = match ch {\n                 '\"' => 1,\n                 '#' if count > 0 => count + 1,\n@@ -236,10 +237,7 @@ impl TokenCursor {\n             [\n                 TokenTree::token(token::Ident(sym::doc, false), sp),\n                 TokenTree::token(token::Eq, sp),\n-                TokenTree::token(\n-                    TokenKind::lit(token::StrRaw(num_of_hashes), Symbol::intern(&stripped), None),\n-                    sp,\n-                ),\n+                TokenTree::token(TokenKind::lit(token::StrRaw(num_of_hashes), data, None), sp),\n             ]\n             .iter()\n             .cloned()\n@@ -251,7 +249,7 @@ impl TokenCursor {\n             TokenCursorFrame::new(\n                 delim_span,\n                 token::NoDelim,\n-                &if doc_comment_style(name) == AttrStyle::Inner {\n+                &if attr_style == AttrStyle::Inner {\n                     [TokenTree::token(token::Pound, sp), TokenTree::token(token::Not, sp), body]\n                         .iter()\n                         .cloned()"}, {"sha": "ebb3aa3866e43641faae1f0f2e0529339b001bb5", "filename": "src/librustc_parse_format/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse_format%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_parse_format%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse_format%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -820,7 +820,7 @@ fn find_skips_from_snippet(\n     }\n \n     let r_start = str_style.map(|r| r + 1).unwrap_or(0);\n-    let r_end = str_style.map(|r| r).unwrap_or(0);\n+    let r_end = str_style.unwrap_or(0);\n     let s = &snippet[r_start + 1..snippet.len() - r_end - 1];\n     (find_skips(s, str_style.is_some()), true)\n }"}, {"sha": "d438fe35ff488481daa12be6d01e69b5640ef545", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -9,7 +9,6 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n \n use rustc_ast::ast::{Attribute, NestedMetaItem};\n-use rustc_ast::attr;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n@@ -60,17 +59,17 @@ impl CheckAttrVisitor<'tcx> {\n     ) {\n         let mut is_valid = true;\n         for attr in attrs {\n-            is_valid &= if attr.check_name(sym::inline) {\n+            is_valid &= if self.tcx.sess.check_name(attr, sym::inline) {\n                 self.check_inline(hir_id, attr, span, target)\n-            } else if attr.check_name(sym::non_exhaustive) {\n+            } else if self.tcx.sess.check_name(attr, sym::non_exhaustive) {\n                 self.check_non_exhaustive(attr, span, target)\n-            } else if attr.check_name(sym::marker) {\n+            } else if self.tcx.sess.check_name(attr, sym::marker) {\n                 self.check_marker(attr, span, target)\n-            } else if attr.check_name(sym::target_feature) {\n+            } else if self.tcx.sess.check_name(attr, sym::target_feature) {\n                 self.check_target_feature(attr, span, target)\n-            } else if attr.check_name(sym::track_caller) {\n+            } else if self.tcx.sess.check_name(attr, sym::track_caller) {\n                 self.check_track_caller(&attr.span, attrs, span, target)\n-            } else if attr.check_name(sym::doc) {\n+            } else if self.tcx.sess.check_name(attr, sym::doc) {\n                 self.check_doc_alias(attr)\n             } else {\n                 true\n@@ -144,7 +143,7 @@ impl CheckAttrVisitor<'tcx> {\n         target: Target,\n     ) -> bool {\n         match target {\n-            _ if attr::contains_name(attrs, sym::naked) => {\n+            _ if self.tcx.sess.contains_name(attrs, sym::naked) => {\n                 struct_span_err!(\n                     self.tcx.sess,\n                     *attr_span,\n@@ -262,7 +261,7 @@ impl CheckAttrVisitor<'tcx> {\n         // ```\n         let hints: Vec<_> = attrs\n             .iter()\n-            .filter(|attr| attr.check_name(sym::repr))\n+            .filter(|attr| self.tcx.sess.check_name(attr, sym::repr))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -391,10 +390,10 @@ impl CheckAttrVisitor<'tcx> {\n         // When checking statements ignore expressions, they will be checked later\n         if let hir::StmtKind::Local(ref l) = stmt.kind {\n             for attr in l.attrs.iter() {\n-                if attr.check_name(sym::inline) {\n+                if self.tcx.sess.check_name(attr, sym::inline) {\n                     self.check_inline(l.hir_id, attr, &stmt.span, Target::Statement);\n                 }\n-                if attr.check_name(sym::repr) {\n+                if self.tcx.sess.check_name(attr, sym::repr) {\n                     self.emit_repr_error(\n                         attr.span,\n                         stmt.span,\n@@ -412,10 +411,10 @@ impl CheckAttrVisitor<'tcx> {\n             _ => Target::Expression,\n         };\n         for attr in expr.attrs.iter() {\n-            if attr.check_name(sym::inline) {\n+            if self.tcx.sess.check_name(attr, sym::inline) {\n                 self.check_inline(expr.hir_id, attr, &expr.span, target);\n             }\n-            if attr.check_name(sym::repr) {\n+            if self.tcx.sess.check_name(attr, sym::repr) {\n                 self.emit_repr_error(\n                     attr.span,\n                     expr.span,\n@@ -431,7 +430,7 @@ impl CheckAttrVisitor<'tcx> {\n \n     fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n         for attr in attrs {\n-            if attr.check_name(sym::used) && target != Target::Static {\n+            if self.tcx.sess.check_name(attr, sym::used) && target != Target::Static {\n                 self.tcx\n                     .sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");"}, {"sha": "dd0bcbf208d7c1d355a4d3469f2ec9007b9b62dc", "filename": "src/librustc_passes/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_const.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n             // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n             // opt-in via `allow_internal_unstable`.\n-            attr::allow_internal_unstable(&tcx.get_attrs(def_id), &tcx.sess.diagnostic())\n+            attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n                 .map_or(false, |mut features| features.any(|name| name == feature_gate))\n         };\n "}, {"sha": "0e5298acc2cafbcd333218205c00a40ac56d5116", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::middle::privacy;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::lint;\n \n-use rustc_ast::{ast, attr};\n+use rustc_ast::ast;\n use rustc_span::symbol::{sym, Symbol};\n \n // Any local node that may call something in its body block should be\n@@ -331,17 +331,17 @@ fn has_allow_dead_code_or_lang_attr(\n     id: hir::HirId,\n     attrs: &[ast::Attribute],\n ) -> bool {\n-    if attr::contains_name(attrs, sym::lang) {\n+    if tcx.sess.contains_name(attrs, sym::lang) {\n         return true;\n     }\n \n     // Stable attribute for #[lang = \"panic_impl\"]\n-    if attr::contains_name(attrs, sym::panic_handler) {\n+    if tcx.sess.contains_name(attrs, sym::panic_handler) {\n         return true;\n     }\n \n     // (To be) stable attribute for #[lang = \"oom\"]\n-    if attr::contains_name(attrs, sym::alloc_error_handler) {\n+    if tcx.sess.contains_name(attrs, sym::alloc_error_handler) {\n         return true;\n     }\n "}, {"sha": "fa59337b0f66b69bcdf88a16cb237f2a1692de5b", "filename": "src/librustc_passes/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostic_items.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -16,6 +16,7 @@ use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n+use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n struct DiagnosticItemCollector<'tcx> {\n@@ -44,7 +45,7 @@ impl<'tcx> DiagnosticItemCollector<'tcx> {\n     }\n \n     fn observe_item(&mut self, attrs: &[ast::Attribute], hir_id: hir::HirId) {\n-        if let Some(name) = extract(attrs) {\n+        if let Some(name) = extract(&self.tcx.sess, attrs) {\n             let def_id = self.tcx.hir().local_def_id(hir_id);\n             // insert into our table\n             collect_item(self.tcx, &mut self.items, name, def_id.to_def_id());\n@@ -86,9 +87,9 @@ fn collect_item(\n }\n \n /// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n-fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+fn extract(sess: &Session, attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().find_map(|attr| {\n-        if attr.check_name(sym::rustc_diagnostic_item) { attr.value_str() } else { None }\n+        if sess.check_name(attr, sym::rustc_diagnostic_item) { attr.value_str() } else { None }\n     })\n }\n "}, {"sha": "8aa6e7936bef61b391c65891539799dc6a00b320", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,3 @@\n-use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{CrateNum, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -58,7 +57,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)\n     }\n \n     // If the user wants no main function at all, then stop here.\n-    if attr::contains_name(&tcx.hir().krate().item.attrs, sym::no_main) {\n+    if tcx.sess.contains_name(&tcx.hir().krate().item.attrs, sym::no_main) {\n         return None;\n     }\n \n@@ -76,14 +75,14 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)\n     configure_main(tcx, &ctxt)\n }\n \n-// Beware, this is duplicated in `librustc_ast/entry.rs`, so make sure to keep\n-// them in sync.\n-fn entry_point_type(item: &Item<'_>, at_root: bool) -> EntryPointType {\n+// Beware, this is duplicated in `librustc_builtin_macros/test_harness.rs`\n+// (with `ast::Item`), so make sure to keep them in sync.\n+fn entry_point_type(sess: &Session, item: &Item<'_>, at_root: bool) -> EntryPointType {\n     match item.kind {\n         ItemKind::Fn(..) => {\n-            if attr::contains_name(&item.attrs, sym::start) {\n+            if sess.contains_name(&item.attrs, sym::start) {\n                 EntryPointType::Start\n-            } else if attr::contains_name(&item.attrs, sym::main) {\n+            } else if sess.contains_name(&item.attrs, sym::main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n                 if at_root {\n@@ -101,7 +100,7 @@ fn entry_point_type(item: &Item<'_>, at_root: bool) -> EntryPointType {\n }\n \n fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n-    match entry_point_type(item, at_root) {\n+    match entry_point_type(&ctxt.session, item, at_root) {\n         EntryPointType::MainNamed => {\n             if ctxt.main_fn.is_none() {\n                 ctxt.main_fn = Some((item.hir_id, item.span));"}, {"sha": "07415870549f172d1021ae1578915bf994548142", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -56,7 +56,8 @@ impl LanguageItemCollector<'tcx> {\n     }\n \n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId, attrs: &[Attribute]) {\n-        if let Some((value, span)) = extract(&attrs) {\n+        let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n+        if let Some((value, span)) = extract(check_name, &attrs) {\n             match ITEM_REFS.get(&value).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {"}, {"sha": "9450d75620a8bc52143575848fafac9874cff598", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -29,7 +29,7 @@ impl ItemLikeVisitor<'tcx> for LayoutTest<'tcx> {\n             | ItemKind::Struct(..)\n             | ItemKind::Union(..) => {\n                 for attr in self.tcx.get_attrs(item_def_id.to_def_id()).iter() {\n-                    if attr.check_name(sym::rustc_layout) {\n+                    if self.tcx.sess.check_name(attr, sym::rustc_layout) {\n                         self.dump_layout_of(item_def_id, item, attr);\n                     }\n                 }"}, {"sha": "9a4aa6a68a6c6a5bf597ecbfe2c8256ff4f0bf5f", "filename": "src/librustc_passes/lib_features.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib_features.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -34,7 +34,9 @@ impl LibFeatureCollector<'tcx> {\n \n         // Find a stability attribute (i.e., `#[stable (..)]`, `#[unstable (..)]`,\n         // `#[rustc_const_unstable (..)]`).\n-        if let Some(stab_attr) = stab_attrs.iter().find(|stab_attr| attr.check_name(**stab_attr)) {\n+        if let Some(stab_attr) =\n+            stab_attrs.iter().find(|stab_attr| self.tcx.sess.check_name(attr, **stab_attr))\n+        {\n             let meta_item = attr.meta();\n             if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta_item {\n                 let mut feature = None;"}, {"sha": "6477f8da008adcf053c8a117fd3b0a5b6653384a", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -355,7 +355,7 @@ fn visit_fn<'tcx>(\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir().get_parent_item(id);\n         if let Some(Node::Item(i)) = ir.tcx.hir().find(parent) {\n-            if i.attrs.iter().any(|a| a.check_name(sym::automatically_derived)) {\n+            if i.attrs.iter().any(|a| ir.tcx.sess.check_name(a, sym::automatically_derived)) {\n                 return;\n             }\n         }"}, {"sha": "1af77ae61c7f4c594111f0bd48631914523048d3", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -65,11 +65,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             did_error = self.forbid_staged_api_attrs(hir_id, attrs);\n         }\n \n-        let depr = if did_error {\n-            None\n-        } else {\n-            attr::find_deprecation(&self.tcx.sess.parse_sess, attrs, item_sp)\n-        };\n+        let depr =\n+            if did_error { None } else { attr::find_deprecation(&self.tcx.sess, attrs, item_sp) };\n         let mut is_deprecated = false;\n         if let Some(depr) = &depr {\n             is_deprecated = true;\n@@ -88,7 +85,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n \n         if self.tcx.features().staged_api {\n-            if let Some(..) = attrs.iter().find(|a| a.check_name(sym::deprecated)) {\n+            if let Some(..) = attrs.iter().find(|a| self.tcx.sess.check_name(a, sym::deprecated)) {\n                 self.tcx.sess.span_err(\n                     item_sp,\n                     \"`#[deprecated]` cannot be used in staged API; \\\n@@ -105,7 +102,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab) = attr::find_stability(&self.tcx.sess.parse_sess, attrs, item_sp);\n+        let (stab, const_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n \n         let const_stab = const_stab.map(|const_stab| {\n             let const_stab = self.tcx.intern_const_stability(const_stab);\n@@ -252,7 +249,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         for attr in attrs {\n             let name = attr.name_or_empty();\n             if unstable_attrs.contains(&name) {\n-                attr::mark_used(attr);\n+                self.tcx.sess.mark_attr_used(attr);\n                 struct_span_err!(\n                     self.tcx.sess,\n                     attr.span,"}, {"sha": "2749b96bc85397be96a045dfdef9534701ae5c0b", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -100,7 +100,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        if let Some((lang_item, _)) = hir::lang_items::extract(&i.attrs) {\n+        let check_name = |attr, sym| self.tcx.sess.check_name(attr, sym);\n+        if let Some((lang_item, _)) = hir::lang_items::extract(check_name, &i.attrs) {\n             self.register(lang_item, i.span, i.hir_id);\n         }\n         intravisit::walk_foreign_item(self, i)"}, {"sha": "d16dd701a120bfa36a01133bdb112ecb99cdf4c7", "filename": "src/librustc_plugin_impl/build.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_plugin_impl%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_plugin_impl%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fbuild.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,6 +1,5 @@\n //! Used by `rustc` when compiling a plugin crate.\n \n-use rustc_ast::attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n@@ -9,14 +8,15 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-struct RegistrarFinder {\n+struct RegistrarFinder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     registrars: Vec<(hir::HirId, Span)>,\n }\n \n-impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n+impl<'v, 'tcx> ItemLikeVisitor<'v> for RegistrarFinder<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         if let hir::ItemKind::Fn(..) = item.kind {\n-            if attr::contains_name(&item.attrs, sym::plugin_registrar) {\n+            if self.tcx.sess.contains_name(&item.attrs, sym::plugin_registrar) {\n                 self.registrars.push((item.hir_id, item.span));\n             }\n         }\n@@ -35,7 +35,7 @@ pub fn find_plugin_registrar(tcx: TyCtxt<'_>) -> Option<DefId> {\n fn plugin_registrar_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<DefId> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n-    let mut finder = RegistrarFinder { registrars: Vec::new() };\n+    let mut finder = RegistrarFinder { tcx, registrars: Vec::new() };\n     tcx.hir().krate().visit_all_item_likes(&mut finder);\n \n     match finder.registrars.len() {"}, {"sha": "1eb65dd96ba57d7139b2eab9ca688a4c737c8fbf", "filename": "src/librustc_plugin_impl/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_plugin_impl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_plugin_impl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -8,6 +8,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(nll)]\n+#![recursion_limit = \"256\"]\n \n use rustc_lint::LintStore;\n "}, {"sha": "2f307302db03ed677114f15f422f52e7a831b1d7", "filename": "src/librustc_plugin_impl/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_plugin_impl%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_plugin_impl%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin_impl%2Fload.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -32,7 +32,7 @@ pub fn load_plugins(\n     let mut plugins = Vec::new();\n \n     for attr in &krate.attrs {\n-        if !attr.check_name(sym::plugin) {\n+        if !sess.check_name(attr, sym::plugin) {\n             continue;\n         }\n "}, {"sha": "2aa7780aaaf8370d84f4270714505c693b00ae23", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -232,7 +232,7 @@ fn def_id_visibility<'tcx>(\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                 Node::MacroDef(macro_def) => {\n-                    if attr::contains_name(&macro_def.attrs, sym::macro_export) {\n+                    if tcx.sess.contains_name(&macro_def.attrs, sym::macro_export) {\n                         return (ty::Visibility::Public, macro_def.span, \"public\");\n                     } else {\n                         &macro_def.vis\n@@ -271,8 +271,11 @@ fn def_id_visibility<'tcx>(\n                                 ctor_vis =\n                                     ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n                                 let attrs = tcx.get_attrs(variant.def_id);\n-                                span =\n-                                    attr::find_by_name(&attrs, sym::non_exhaustive).unwrap().span;\n+                                span = tcx\n+                                    .sess\n+                                    .find_by_name(&attrs, sym::non_exhaustive)\n+                                    .unwrap()\n+                                    .span;\n                                 descr = \"crate-visible\";\n                             }\n \n@@ -305,7 +308,9 @@ fn def_id_visibility<'tcx>(\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = attr::find_by_name(&item.attrs, sym::non_exhaustive)\n+                                    span = tcx\n+                                        .sess\n+                                        .find_by_name(&item.attrs, sym::non_exhaustive)\n                                         .unwrap()\n                                         .span;\n                                     descr = \"crate-visible\";\n@@ -914,7 +919,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        if attr::find_transparency(&md.attrs, md.ast.macro_rules).0 != Transparency::Opaque {\n+        if attr::find_transparency(&self.tcx.sess, &md.attrs, md.ast.macro_rules).0\n+            != Transparency::Opaque\n+        {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return;\n         }"}, {"sha": "11c7793b3ad9a3903471f69ee7595883e70a4e5a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -541,7 +541,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n-                    is_prelude: attr::contains_name(&item.attrs, sym::prelude_import),\n+                    is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n@@ -712,7 +712,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let module_kind = ModuleKind::Def(DefKind::Mod, def_id.to_def_id(), ident.name);\n                 let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n-                        attr::contains_name(&item.attrs, sym::no_implicit_prelude)\n+                        self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n                     ..ModuleData::new(\n                         Some(parent),\n@@ -789,7 +789,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     // If the structure is marked as non_exhaustive then lower the visibility\n                     // to within the crate.\n                     let mut ctor_vis = if vis == ty::Visibility::Public\n-                        && attr::contains_name(&item.attrs, sym::non_exhaustive)\n+                        && self.r.session.contains_name(&item.attrs, sym::non_exhaustive)\n                     {\n                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n                     } else {\n@@ -991,7 +991,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n-            if attr.check_name(sym::macro_use) {\n+            if self.r.session.check_name(attr, sym::macro_use) {\n                 if self.parent_scope.module.parent.is_some() {\n                     struct_span_err!(\n                         self.r.session,\n@@ -1097,15 +1097,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     /// Returns `true` if this attribute list contains `macro_use`.\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n-            if attr.check_name(sym::macro_escape) {\n+            if self.r.session.check_name(attr, sym::macro_escape) {\n                 let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n                 let mut err = self.r.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n                     err.emit();\n                 }\n-            } else if !attr.check_name(sym::macro_use) {\n+            } else if !self.r.session.check_name(attr, sym::macro_use) {\n                 continue;\n             }\n \n@@ -1129,12 +1129,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         MacroRulesScope::Invocation(invoc_id)\n     }\n \n-    fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n-        if attr::contains_name(&item.attrs, sym::proc_macro) {\n+    fn proc_macro_stub(&self, item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n+        if self.r.session.contains_name(&item.attrs, sym::proc_macro) {\n             return Some((MacroKind::Bang, item.ident, item.span));\n-        } else if attr::contains_name(&item.attrs, sym::proc_macro_attribute) {\n+        } else if self.r.session.contains_name(&item.attrs, sym::proc_macro_attribute) {\n             return Some((MacroKind::Attr, item.ident, item.span));\n-        } else if let Some(attr) = attr::find_by_name(&item.attrs, sym::proc_macro_derive) {\n+        } else if let Some(attr) = self.r.session.find_by_name(&item.attrs, sym::proc_macro_derive)\n+        {\n             if let Some(nested_meta) = attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                 if let Some(ident) = nested_meta.ident() {\n                     return Some((MacroKind::Derive, ident, ident.span));\n@@ -1168,7 +1169,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.macro_rules)\n             }\n-            ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n+            ItemKind::Fn(..) => match self.proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n                     self.r.proc_macro_stubs.insert(def_id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n@@ -1185,7 +1186,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         if macro_rules {\n             let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n-            let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n+            let is_macro_export = self.r.session.contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n             } else {\n@@ -1416,7 +1417,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.attrs, sym::non_exhaustive);\n+        let has_non_exhaustive = self.r.session.contains_name(&variant.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }"}, {"sha": "9502be728de06a4052110ec2cfc35ec865bbcc35", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -466,6 +466,23 @@ impl<'a> Resolver<'a> {\n                 );\n                 err\n             }\n+            ResolutionError::ParamInNonTrivialAnonConst(name) => {\n+                let mut err = self.session.struct_span_err(\n+                    span,\n+                    \"generic parameters must not be used inside of non trivial constant values\",\n+                );\n+                err.span_label(\n+                    span,\n+                    &format!(\n+                        \"non-trivial anonymous constants must not depend on the parameter `{}`\",\n+                        name\n+                    ),\n+                );\n+                err.help(\n+                    &format!(\"it is currently only allowed to use either `{0}` or `{{ {0} }}` as generic constants\", name)\n+                );\n+                err\n+            }\n             ResolutionError::SelfInTyParamDefault => {\n                 let mut err = struct_span_err!(\n                     self.session,\n@@ -1075,10 +1092,9 @@ impl<'a> Resolver<'a> {\n         ) = binding.kind\n         {\n             let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n-            if let Some(fields) = self.field_names.get(&def_id) {\n-                let first_field = fields.first().expect(\"empty field list in the map\");\n-                return Some(fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)));\n-            }\n+            let fields = self.field_names.get(&def_id)?;\n+            let first_field = fields.first()?; // Handle `struct Foo()`\n+            return Some(fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)));\n         }\n         None\n     }"}, {"sha": "7ecfe2554ec8ab04e0d6bf7da75c21429dc0a5e7", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -111,7 +111,7 @@ crate enum RibKind<'a> {\n     ItemRibKind(HasGenericParams),\n \n     /// We're in a constant item. Can't refer to dynamic stuff.\n-    ConstantItemRibKind,\n+    ConstantItemRibKind(bool),\n \n     /// We passed through a module.\n     ModuleRibKind(Module<'a>),\n@@ -137,7 +137,7 @@ impl RibKind<'_> {\n             NormalRibKind\n             | ClosureOrAsyncRibKind\n             | FnItemRibKind\n-            | ConstantItemRibKind\n+            | ConstantItemRibKind(_)\n             | ModuleRibKind(_)\n             | MacroDefinition(_)\n             | ConstParamTyRibKind => false,\n@@ -226,7 +226,7 @@ impl<'a> PathSource<'a> {\n                 ValueNS => \"method or associated constant\",\n                 MacroNS => bug!(\"associated macro\"),\n             },\n-            PathSource::Expr(parent) => match &parent.as_ref().map(|p| &p.kind) {\n+            PathSource::Expr(parent) => match parent.as_ref().map(|p| &p.kind) {\n                 // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(ExprKind::Call(call_expr, _)) => match &call_expr.kind {\n@@ -426,7 +426,7 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n     }\n     fn visit_anon_const(&mut self, constant: &'ast AnonConst) {\n         debug!(\"visit_anon_const {:?}\", constant);\n-        self.with_constant_rib(|this| {\n+        self.with_constant_rib(constant.value.is_potential_trivial_const_param(), |this| {\n             visit::walk_anon_const(this, constant);\n         });\n     }\n@@ -628,7 +628,7 @@ impl<'a, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         if !check_ns(TypeNS) && check_ns(ValueNS) {\n                             // This must be equivalent to `visit_anon_const`, but we cannot call it\n                             // directly due to visitor lifetimes so we have to copy-paste some code.\n-                            self.with_constant_rib(|this| {\n+                            self.with_constant_rib(true, |this| {\n                                 this.smart_resolve_path(\n                                     ty.id,\n                                     qself.as_ref(),\n@@ -829,7 +829,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 | ClosureOrAsyncRibKind\n                 | FnItemRibKind\n                 | ItemRibKind(..)\n-                | ConstantItemRibKind\n+                | ConstantItemRibKind(_)\n                 | ModuleRibKind(..)\n                 | ForwardTyParamBanRibKind\n                 | ConstParamTyRibKind => {\n@@ -948,7 +948,14 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                         // Only impose the restrictions of `ConstRibKind` for an\n                                         // actual constant expression in a provided default.\n                                         if let Some(expr) = default {\n-                                            this.with_constant_rib(|this| this.visit_expr(expr));\n+                                            // We allow arbitrary const expressions inside of associated consts,\n+                                            // even if they are potentially not const evaluatable.\n+                                            //\n+                                            // Type parameters can already be used and as associated consts are\n+                                            // not used as part of the type system, this is far less surprising.\n+                                            this.with_constant_rib(true, |this| {\n+                                                this.visit_expr(expr)\n+                                            });\n                                         }\n                                     }\n                                     AssocItemKind::Fn(_, _, generics, _) => {\n@@ -989,7 +996,9 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n                     if let Some(expr) = expr {\n-                        this.with_constant_rib(|this| this.visit_expr(expr));\n+                        this.with_constant_rib(expr.is_potential_trivial_const_param(), |this| {\n+                            this.visit_expr(expr)\n+                        });\n                     }\n                 });\n             }\n@@ -1086,11 +1095,11 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         self.with_rib(ValueNS, kind, |this| this.with_rib(TypeNS, kind, f))\n     }\n \n-    fn with_constant_rib(&mut self, f: impl FnOnce(&mut Self)) {\n+    fn with_constant_rib(&mut self, trivial: bool, f: impl FnOnce(&mut Self)) {\n         debug!(\"with_constant_rib\");\n-        self.with_rib(ValueNS, ConstantItemRibKind, |this| {\n-            this.with_rib(TypeNS, ConstantItemRibKind, |this| {\n-                this.with_label_rib(ConstantItemRibKind, f);\n+        self.with_rib(ValueNS, ConstantItemRibKind(trivial), |this| {\n+            this.with_rib(TypeNS, ConstantItemRibKind(trivial), |this| {\n+                this.with_label_rib(ConstantItemRibKind(trivial), f);\n             })\n         });\n     }\n@@ -1220,7 +1229,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                 for item in impl_items {\n                                     use crate::ResolutionError::*;\n                                     match &item.kind {\n-                                        AssocItemKind::Const(..) => {\n+                                        AssocItemKind::Const(_default, _ty, _expr) => {\n                                             debug!(\"resolve_implementation AssocItemKind::Const\",);\n                                             // If this is a trait impl, ensure the const\n                                             // exists in trait\n@@ -1231,7 +1240,12 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                 |n, s| ConstNotMemberOfTrait(n, s),\n                                             );\n \n-                                            this.with_constant_rib(|this| {\n+                                            // We allow arbitrary const expressions inside of associated consts,\n+                                            // even if they are potentially not const evaluatable.\n+                                            //\n+                                            // Type parameters can already be used and as associated consts are\n+                                            // not used as part of the type system, this is far less surprising.\n+                                            this.with_constant_rib(true, |this| {\n                                                 visit::walk_assoc_item(this, item, AssocCtxt::Impl)\n                                             });\n                                         }"}, {"sha": "0b881b089deaa830e12826c21f743a1f7b1a8f52", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -6,7 +6,6 @@\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n-use rustc_ast::attr;\n use rustc_ast::walk_list;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n@@ -1179,7 +1178,7 @@ fn compute_object_lifetime_defaults(tcx: TyCtxt<'_>) -> HirIdMap<Vec<ObjectLifet\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n-                if attr::contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n+                if tcx.sess.contains_name(&item.attrs, sym::rustc_object_lifetime_default) {\n                     let object_lifetime_default_reprs: String = result\n                         .iter()\n                         .map(|set| match *set {\n@@ -1540,13 +1539,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             if let Some(def_id) = parent_def_id.as_local() {\n                                 let parent_hir_id = self.tcx.hir().as_local_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n-                                if self\n-                                    .tcx\n-                                    .hir()\n-                                    .attrs(parent_hir_id)\n-                                    .iter()\n-                                    .any(|attr| attr.check_name(sym::automatically_derived))\n-                                {\n+                                if self.tcx.hir().attrs(parent_hir_id).iter().any(|attr| {\n+                                    self.tcx.sess.check_name(attr, sym::automatically_derived)\n+                                }) {\n                                     continue;\n                                 }\n                             }"}, {"sha": "79f5a27bb28ed178f7635f0d926d2dae2d969c98", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -23,7 +23,6 @@ use rustc_arena::TypedArena;\n use rustc_ast::ast::{self, FloatTy, IntTy, NodeId, UintTy};\n use rustc_ast::ast::{Crate, CRATE_NODE_ID};\n use rustc_ast::ast::{ItemKind, Path};\n-use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n@@ -218,6 +217,10 @@ enum ResolutionError<'a> {\n     ParamInTyOfConstParam(Symbol),\n     /// constant values inside of type parameter defaults must not depend on generic parameters.\n     ParamInAnonConstInTyDefault(Symbol),\n+    /// generic parameters must not be used inside of non trivial constant values.\n+    ///\n+    /// This error is only emitted when using `min_const_generics`.\n+    ParamInNonTrivialAnonConst(Symbol),\n     /// Error E0735: type parameters with a default cannot use `Self`\n     SelfInTyParamDefault,\n     /// Error E0767: use of unreachable label\n@@ -1194,7 +1197,7 @@ impl<'a> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n         let graph_root = arenas.alloc_module(ModuleData {\n-            no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n+            no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n         let empty_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n@@ -1232,9 +1235,9 @@ impl<'a> Resolver<'a> {\n             .map(|(name, _)| (Ident::from_str(name), Default::default()))\n             .collect();\n \n-        if !attr::contains_name(&krate.attrs, sym::no_core) {\n+        if !session.contains_name(&krate.attrs, sym::no_core) {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n-            if !attr::contains_name(&krate.attrs, sym::no_std) {\n+            if !session.contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n                 if session.rust_2018() {\n                     extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());\n@@ -2507,7 +2510,7 @@ impl<'a> Resolver<'a> {\n                                 res_err = Some(CannotCaptureDynamicEnvironmentInFnItem);\n                             }\n                         }\n-                        ConstantItemRibKind => {\n+                        ConstantItemRibKind(_) => {\n                             // Still doesn't deal with upvars\n                             if record_used {\n                                 self.report_error(span, AttemptToUseNonConstantValueInConstant);\n@@ -2546,7 +2549,18 @@ impl<'a> Resolver<'a> {\n                             in_ty_param_default = true;\n                             continue;\n                         }\n-                        ConstantItemRibKind => {\n+                        ConstantItemRibKind(trivial) => {\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !trivial && self.session.features_untracked().min_const_generics {\n+                                if record_used {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst(rib_ident.name),\n+                                    );\n+                                }\n+                                return Res::Err;\n+                            }\n+\n                             if in_ty_param_default {\n                                 if record_used {\n                                     self.report_error(\n@@ -2612,7 +2626,18 @@ impl<'a> Resolver<'a> {\n                             in_ty_param_default = true;\n                             continue;\n                         }\n-                        ConstantItemRibKind => {\n+                        ConstantItemRibKind(trivial) => {\n+                            // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n+                            if !trivial && self.session.features_untracked().min_const_generics {\n+                                if record_used {\n+                                    self.report_error(\n+                                        span,\n+                                        ResolutionError::ParamInNonTrivialAnonConst(rib_ident.name),\n+                                    );\n+                                }\n+                                return Res::Err;\n+                            }\n+\n                             if in_ty_param_default {\n                                 if record_used {\n                                     self.report_error("}, {"sha": "542025ac1f4990ad8e7db150d00aa25b7f4d2998", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -9,7 +9,7 @@ use crate::{ModuleKind, ModuleOrUniformRoot, NameBinding, PathResult, Segment, T\n use rustc_ast::ast::{self, NodeId};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n-use rustc_attr::{self as attr, StabilityLevel};\n+use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::{Indeterminate, InvocationRes, ResolverExpand, SyntaxExtension};\n use rustc_expand::compile_declarative_macro;\n@@ -105,7 +105,7 @@ fn registered_idents(\n     descr: &str,\n ) -> FxHashSet<Ident> {\n     let mut registered = FxHashSet::default();\n-    for attr in attr::filter_by_name(attrs, attr_name) {\n+    for attr in sess.filter_by_name(attrs, attr_name) {\n         for nested_meta in attr.meta_item_list().unwrap_or_default() {\n             match nested_meta.ident() {\n                 Some(ident) => {\n@@ -1068,7 +1068,7 @@ impl<'a> Resolver<'a> {\n     /// its expander to a pre-defined one for built-in macros.\n     crate fn compile_macro(&mut self, item: &ast::Item, edition: Edition) -> SyntaxExtension {\n         let mut result = compile_declarative_macro(\n-            &self.session.parse_sess,\n+            &self.session,\n             self.session.features_untracked(),\n             item,\n             edition,"}, {"sha": "6469971fce830e4ff7e5692a80cac0f767ba25c9", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -10,7 +10,7 @@ mod span_utils;\n mod sig;\n \n use rustc_ast::ast::{self};\n-use rustc_ast::util::comments::strip_doc_comment_decoration;\n+use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast_pretty::pprust::attribute_to_string;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n@@ -702,7 +702,7 @@ impl<'tcx> SaveContext<'tcx> {\n             Res::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref { kind: RefKind::Variable, span, ref_id: id_from_def_id(def_id) })\n             }\n-            Res::Def(HirDefKind::Ctor(_, ..), def_id) => {\n+            Res::Def(HirDefKind::Ctor(..), def_id) => {\n                 // This is a reference to a tuple struct or an enum variant where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct or enum variant itself.\n@@ -822,13 +822,10 @@ impl<'tcx> SaveContext<'tcx> {\n \n         for attr in attrs {\n             if let Some(val) = attr.doc_str() {\n-                if attr.is_doc_comment() {\n-                    result.push_str(&strip_doc_comment_decoration(val));\n-                } else {\n-                    result.push_str(&val.as_str());\n-                }\n+                // FIXME: Should save-analysis beautify doc strings itself or leave it to users?\n+                result.push_str(&beautify_doc_string(val));\n                 result.push('\\n');\n-            } else if attr.check_name(sym::doc) {\n+            } else if self.tcx.sess.check_name(attr, sym::doc) {\n                 if let Some(meta_list) = attr.meta_item_list() {\n                     meta_list\n                         .into_iter()"}, {"sha": "8fe71b71caed1f92944ef66db883b4b2b6d9a30d", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -98,7 +98,7 @@ impl<'a> FileSearch<'a> {\n         p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n-        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p.clone()] }\n+        if self_contained { vec![p.clone(), p.join(\"self-contained\")] } else { vec![p] }\n     }\n }\n "}, {"sha": "e4bce435c4b6d91e99922774f0288f35598cea02", "filename": "src/librustc_session/output.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_session%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_session%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foutput.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,7 @@\n //! Related to out filenames of compilation (e.g. save analysis, binaries).\n use crate::config::{CrateType, Input, OutputFilenames, OutputType};\n use crate::Session;\n-use rustc_ast::{ast, attr};\n+use rustc_ast::ast;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use std::path::{Path, PathBuf};\n@@ -45,7 +45,7 @@ fn is_writeable(p: &Path) -> bool {\n     }\n }\n \n-pub fn find_crate_name(sess: Option<&Session>, attrs: &[ast::Attribute], input: &Input) -> String {\n+pub fn find_crate_name(sess: &Session, attrs: &[ast::Attribute], input: &Input) -> String {\n     let validate = |s: String, span: Option<Span>| {\n         validate_crate_name(sess, &s, span);\n         s\n@@ -56,22 +56,20 @@ pub fn find_crate_name(sess: Option<&Session>, attrs: &[ast::Attribute], input:\n     // the command line over one found in the #[crate_name] attribute. If we\n     // find both we ensure that they're the same later on as well.\n     let attr_crate_name =\n-        attr::find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n-\n-    if let Some(sess) = sess {\n-        if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, name)) = attr_crate_name {\n-                if name.as_str() != *s {\n-                    let msg = format!(\n-                        \"`--crate-name` and `#[crate_name]` are \\\n-                                       required to match, but `{}` != `{}`\",\n-                        s, name\n-                    );\n-                    sess.span_err(attr.span, &msg);\n-                }\n+        sess.find_by_name(attrs, sym::crate_name).and_then(|at| at.value_str().map(|s| (at, s)));\n+\n+    if let Some(ref s) = sess.opts.crate_name {\n+        if let Some((attr, name)) = attr_crate_name {\n+            if name.as_str() != *s {\n+                let msg = format!(\n+                    \"`--crate-name` and `#[crate_name]` are \\\n+                                   required to match, but `{}` != `{}`\",\n+                    s, name\n+                );\n+                sess.span_err(attr.span, &msg);\n             }\n-            return validate(s.clone(), None);\n         }\n+        return validate(s.clone(), None);\n     }\n \n     if let Some((attr, s)) = attr_crate_name {\n@@ -85,9 +83,7 @@ pub fn find_crate_name(sess: Option<&Session>, attrs: &[ast::Attribute], input:\n                                    `{}` has a leading hyphen\",\n                     s\n                 );\n-                if let Some(sess) = sess {\n-                    sess.err(&msg);\n-                }\n+                sess.err(&msg);\n             } else {\n                 return validate(s.replace(\"-\", \"_\"), None);\n             }\n@@ -97,14 +93,13 @@ pub fn find_crate_name(sess: Option<&Session>, attrs: &[ast::Attribute], input:\n     \"rust_out\".to_string()\n }\n \n-pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n+pub fn validate_crate_name(sess: &Session, s: &str, sp: Option<Span>) {\n     let mut err_count = 0;\n     {\n         let mut say = |s: &str| {\n-            match (sp, sess) {\n-                (_, None) => panic!(\"{}\", s),\n-                (Some(sp), Some(sess)) => sess.span_err(sp, s),\n-                (None, Some(sess)) => sess.err(s),\n+            match sp {\n+                Some(sp) => sess.span_err(sp, s),\n+                None => sess.err(s),\n             }\n             err_count += 1;\n         };\n@@ -123,7 +118,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     }\n \n     if err_count > 0 {\n-        sess.unwrap().abort_if_errors();\n+        sess.abort_if_errors();\n     }\n }\n "}, {"sha": "9191f7e8d76be85458c205e8c585432af937322b", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -7,6 +7,8 @@ use crate::lint;\n use crate::parse::ParseSess;\n use crate::search_paths::{PathKind, SearchPath};\n \n+pub use rustc_ast::ast::Attribute;\n+pub use rustc_ast::attr::MarkedAttrs;\n pub use rustc_ast::crate_disambiguator::CrateDisambiguator;\n use rustc_data_structures::flock;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -22,7 +24,7 @@ use rustc_errors::registry::Registry;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorReported};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::{FileLoader, MultiSpan, RealFileLoader, SourceMap, Span};\n-use rustc_span::{SourceFileHashAlgorithm, Symbol};\n+use rustc_span::{sym, SourceFileHashAlgorithm, Symbol};\n use rustc_target::asm::InlineAsmArch;\n use rustc_target::spec::{CodeModel, PanicStrategy, RelocModel, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple, TlsModel};\n@@ -208,6 +210,9 @@ pub struct Session {\n \n     /// Set of enabled features for the current target.\n     pub target_features: FxHashSet<Symbol>,\n+\n+    known_attrs: Lock<MarkedAttrs>,\n+    used_attrs: Lock<MarkedAttrs>,\n }\n \n pub struct PerfStats {\n@@ -1020,6 +1025,76 @@ impl Session {\n         // MemorySanitizer uses lifetimes to detect use of uninitialized stack variables.\n         || self.opts.debugging_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY)\n     }\n+\n+    pub fn mark_attr_known(&self, attr: &Attribute) {\n+        self.known_attrs.lock().mark(attr)\n+    }\n+\n+    pub fn is_attr_known(&self, attr: &Attribute) -> bool {\n+        self.known_attrs.lock().is_marked(attr)\n+    }\n+\n+    pub fn mark_attr_used(&self, attr: &Attribute) {\n+        self.used_attrs.lock().mark(attr)\n+    }\n+\n+    pub fn is_attr_used(&self, attr: &Attribute) -> bool {\n+        self.used_attrs.lock().is_marked(attr)\n+    }\n+\n+    /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n+    /// attribute is marked as used.\n+\n+    /// Returns `true` if the attribute's path matches the argument. If it\n+    /// matches, then the attribute is marked as used.\n+    ///\n+    /// This method should only be used by rustc, other tools can use\n+    /// `Attribute::has_name` instead, because only rustc is supposed to report\n+    /// the `unused_attributes` lint. (`MetaItem` and `NestedMetaItem` are\n+    /// produced by lowering an `Attribute` and don't have identity, so they\n+    /// only have the `has_name` method, and you need to mark the original\n+    /// `Attribute` as used when necessary.)\n+    pub fn check_name(&self, attr: &Attribute, name: Symbol) -> bool {\n+        let matches = attr.has_name(name);\n+        if matches {\n+            self.mark_attr_used(attr);\n+        }\n+        matches\n+    }\n+\n+    pub fn is_proc_macro_attr(&self, attr: &Attribute) -> bool {\n+        [sym::proc_macro, sym::proc_macro_attribute, sym::proc_macro_derive]\n+            .iter()\n+            .any(|kind| self.check_name(attr, *kind))\n+    }\n+\n+    pub fn contains_name(&self, attrs: &[Attribute], name: Symbol) -> bool {\n+        attrs.iter().any(|item| self.check_name(item, name))\n+    }\n+\n+    pub fn find_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> Option<&'a Attribute> {\n+        attrs.iter().find(|attr| self.check_name(attr, name))\n+    }\n+\n+    pub fn filter_by_name<'a>(\n+        &'a self,\n+        attrs: &'a [Attribute],\n+        name: Symbol,\n+    ) -> impl Iterator<Item = &'a Attribute> {\n+        attrs.iter().filter(move |attr| self.check_name(attr, name))\n+    }\n+\n+    pub fn first_attr_value_str_by_name(\n+        &self,\n+        attrs: &[Attribute],\n+        name: Symbol,\n+    ) -> Option<Symbol> {\n+        attrs.iter().find(|at| self.check_name(at, name)).and_then(|at| at.value_str())\n+    }\n }\n \n fn default_emitter(\n@@ -1283,6 +1358,8 @@ pub fn build_session(\n         real_rust_source_base_dir,\n         asm_arch,\n         target_features: FxHashSet::default(),\n+        known_attrs: Lock::new(MarkedAttrs::new()),\n+        used_attrs: Lock::new(MarkedAttrs::new()),\n     };\n \n     validate_commandline_args_with_session_available(&sess);"}, {"sha": "f52b2195c2f6e25d6bc797e24511808c43a08374", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -80,8 +80,6 @@ pub enum Transparency {\n     Opaque,\n }\n \n-pub(crate) const NUM_TRANSPARENCIES: usize = 3;\n-\n impl ExpnId {\n     pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n         HygieneData::with(|data| data.fresh_expn(expn_data))\n@@ -618,6 +616,11 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n+    #[inline]\n+    pub fn outer_mark(self) -> (ExpnId, Transparency) {\n+        HygieneData::with(|data| data.outer_mark(self))\n+    }\n+\n     #[inline]\n     pub fn outer_mark_with_data(self) -> (ExpnId, Transparency, ExpnData) {\n         HygieneData::with(|data| {\n@@ -667,7 +670,6 @@ pub struct ExpnData {\n     /// The kind of this expansion - macro or compiler desugaring.\n     pub kind: ExpnKind,\n     /// The expansion that produced this expansion.\n-    #[stable_hasher(ignore)]\n     pub parent: ExpnId,\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n@@ -1030,7 +1032,7 @@ pub fn decode_expn_id<\n         drop(expns);\n         expn_id\n     });\n-    return Ok(expn_id);\n+    Ok(expn_id)\n }\n \n // Decodes `SyntaxContext`, using the provided `HygieneDecodeContext`\n@@ -1103,7 +1105,7 @@ pub fn decode_syntax_context<\n         assert_eq!(dummy.dollar_crate_name, kw::Invalid);\n     });\n \n-    return Ok(new_ctxt);\n+    Ok(new_ctxt)\n }\n \n pub fn num_syntax_ctxts() -> usize {\n@@ -1170,13 +1172,30 @@ pub fn raw_encode_expn_id<E: Encoder>(\n     mode: ExpnDataEncodeMode,\n     e: &mut E,\n ) -> Result<(), E::Error> {\n-    if !context.serialized_expns.lock().contains(&expn) {\n-        context.latest_expns.lock().insert(expn);\n-    }\n+    // Record the fact that we need to serialize the corresponding\n+    // `ExpnData`\n+    let needs_data = || {\n+        if !context.serialized_expns.lock().contains(&expn) {\n+            context.latest_expns.lock().insert(expn);\n+        }\n+    };\n+\n     match mode {\n-        ExpnDataEncodeMode::IncrComp => expn.0.encode(e),\n+        ExpnDataEncodeMode::IncrComp => {\n+            // Always serialize the `ExpnData` in incr comp mode\n+            needs_data();\n+            expn.0.encode(e)\n+        }\n         ExpnDataEncodeMode::Metadata => {\n             let data = expn.expn_data();\n+            // We only need to serialize the ExpnData\n+            // if it comes from this crate.\n+            // We currently don't serialize any hygiene information data for\n+            // proc-macro crates: see the `SpecializedEncoder<Span>` impl\n+            // for crate metadata.\n+            if data.krate == LOCAL_CRATE {\n+                needs_data();\n+            }\n             data.orig_id.expect(\"Missing orig_id\").encode(e)?;\n             data.krate.encode(e)\n         }"}, {"sha": "697d88ad0639598ea392fa345260a1eac0749ce0", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 43, "deletions": 30, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -32,8 +32,8 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n pub use hygiene::SyntaxContext;\n+use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n-use hygiene::{Transparency, NUM_TRANSPARENCIES};\n pub mod def_id;\n use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;\n@@ -87,6 +87,15 @@ impl SessionGlobals {\n     }\n }\n \n+pub fn with_session_globals<R>(edition: Edition, f: impl FnOnce() -> R) -> R {\n+    let session_globals = SessionGlobals::new(edition);\n+    SESSION_GLOBALS.set(&session_globals, f)\n+}\n+\n+pub fn with_default_session_globals<R>(f: impl FnOnce() -> R) -> R {\n+    with_session_globals(edition::DEFAULT_EDITION, f)\n+}\n+\n // If this ever becomes non thread-local, `decode_syntax_context`\n // and `decode_expn_id` will need to be updated to handle concurrent\n // deserialization.\n@@ -1814,47 +1823,51 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n             TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n         } else {\n             TAG_EXPANSION.hash_stable(ctx, hasher);\n+            let (expn_id, transparency) = self.outer_mark();\n+            expn_id.hash_stable(ctx, hasher);\n+            transparency.hash_stable(ctx, hasher);\n+        }\n+    }\n+}\n \n-            // Since the same expansion context is usually referenced many\n-            // times, we cache a stable hash of it and hash that instead of\n-            // recursing every time.\n-            thread_local! {\n-                static CACHE: RefCell<Vec<Option<[Option<u64>; NUM_TRANSPARENCIES]>>> = Default::default();\n-            }\n+impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        // Since the same expansion context is usually referenced many\n+        // times, we cache a stable hash of it and hash that instead of\n+        // recursing every time.\n+        thread_local! {\n+            static CACHE: RefCell<Vec<Option<Fingerprint>>> = Default::default();\n+        }\n \n-            let sub_hash: u64 = CACHE.with(|cache| {\n-                let (expn_id, transparency, _) = self.outer_mark_with_data();\n-                let index = expn_id.as_u32() as usize;\n+        const TAG_ROOT: u8 = 0;\n+        const TAG_NOT_ROOT: u8 = 1;\n \n-                if let Some(sub_hash_cache) = cache.borrow().get(index).copied().flatten() {\n-                    if let Some(sub_hash) = sub_hash_cache[transparency as usize] {\n-                        return sub_hash;\n-                    }\n-                }\n+        if *self == ExpnId::root() {\n+            TAG_ROOT.hash_stable(ctx, hasher);\n+            return;\n+        }\n \n-                let new_len = index + 1;\n+        TAG_NOT_ROOT.hash_stable(ctx, hasher);\n+        let index = self.as_u32() as usize;\n \n-                let mut hasher = StableHasher::new();\n-                expn_id.expn_data().hash_stable(ctx, &mut hasher);\n-                transparency.hash_stable(ctx, &mut hasher);\n+        let res = CACHE.with(|cache| cache.borrow().get(index).copied().flatten());\n \n-                let sub_hash: Fingerprint = hasher.finish();\n-                let sub_hash = sub_hash.to_smaller_hash();\n+        if let Some(res) = res {\n+            res.hash_stable(ctx, hasher);\n+        } else {\n+            let new_len = index + 1;\n \n+            let mut sub_hasher = StableHasher::new();\n+            self.expn_data().hash_stable(ctx, &mut sub_hasher);\n+            let sub_hash: Fingerprint = sub_hasher.finish();\n+\n+            CACHE.with(|cache| {\n                 let mut cache = cache.borrow_mut();\n                 if cache.len() < new_len {\n                     cache.resize(new_len, None);\n                 }\n-                if let Some(mut sub_hash_cache) = cache[index] {\n-                    sub_hash_cache[transparency as usize] = Some(sub_hash);\n-                } else {\n-                    let mut sub_hash_cache = [None; NUM_TRANSPARENCIES];\n-                    sub_hash_cache[transparency as usize] = Some(sub_hash);\n-                    cache[index] = Some(sub_hash_cache);\n-                }\n-                sub_hash\n+                cache[index].replace(sub_hash).expect_none(\"Cache slot was filled\");\n             });\n-\n             sub_hash.hash_stable(ctx, hasher);\n         }\n     }"}, {"sha": "b05e01d666bd6917e32f4451640c4c4748a7f0ce", "filename": "src/librustc_span/span_encoding.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fspan_encoding.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -8,7 +8,7 @@ use crate::hygiene::SyntaxContext;\n use crate::SESSION_GLOBALS;\n use crate::{BytePos, SpanData};\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxIndexSet;\n \n /// A compressed span.\n ///\n@@ -111,25 +111,18 @@ impl Span {\n \n #[derive(Default)]\n pub struct SpanInterner {\n-    spans: FxHashMap<SpanData, u32>,\n-    span_data: Vec<SpanData>,\n+    spans: FxIndexSet<SpanData>,\n }\n \n impl SpanInterner {\n     fn intern(&mut self, span_data: &SpanData) -> u32 {\n-        if let Some(index) = self.spans.get(span_data) {\n-            return *index;\n-        }\n-\n-        let index = self.spans.len() as u32;\n-        self.span_data.push(*span_data);\n-        self.spans.insert(*span_data, index);\n-        index\n+        let (index, _) = self.spans.insert_full(*span_data);\n+        index as u32\n     }\n \n     #[inline]\n     fn get(&self, index: u32) -> &SpanData {\n-        &self.span_data[index as usize]\n+        &self.spans[index as usize]\n     }\n }\n "}, {"sha": "caa6de09664bcf1a38607114bcd31d980c3b89ae", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -672,6 +672,7 @@ symbols! {\n         min_align_of,\n         min_align_of_val,\n         min_const_fn,\n+        min_const_generics,\n         min_const_unsafe_fn,\n         min_specialization,\n         minnumf32,\n@@ -736,6 +737,7 @@ symbols! {\n         not,\n         note,\n         object_safe_for_dispatch,\n+        of,\n         offset,\n         omit_gdb_pretty_printer_section,\n         on,\n@@ -1480,6 +1482,10 @@ impl<CTX> ToStableHashKey<CTX> for Symbol {\n }\n \n // The `&'static str`s in this type actually point into the arena.\n+//\n+// The `FxHashMap`+`Vec` pair could be replaced by `FxIndexSet`, but #75278\n+// found that to regress performance up to 2% in some cases. This might be\n+// revisited after further improvements to `indexmap`.\n #[derive(Default)]\n pub struct Interner {\n     arena: DroplessArena,"}, {"sha": "24850a8a0d2533a17ad06914272d9e6657f8c89d", "filename": "src/librustc_symbol_mangling/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_symbol_mangling%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_symbol_mangling%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Ftest.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -34,16 +34,16 @@ impl SymbolNamesTest<'tcx> {\n         let tcx = self.tcx;\n         let def_id = tcx.hir().local_def_id(hir_id);\n         for attr in tcx.get_attrs(def_id.to_def_id()).iter() {\n-            if attr.check_name(SYMBOL_NAME) {\n+            if tcx.sess.check_name(attr, SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id.to_def_id());\n-                let mangled = self.tcx.symbol_name(instance);\n+                let mangled = tcx.symbol_name(instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", mangled));\n                 if let Ok(demangling) = rustc_demangle::try_demangle(mangled.name) {\n                     tcx.sess.span_err(attr.span, &format!(\"demangling({})\", demangling));\n                     tcx.sess.span_err(attr.span, &format!(\"demangling-alt({:#})\", demangling));\n                 }\n-            } else if attr.check_name(DEF_PATH) {\n+            } else if tcx.sess.check_name(attr, DEF_PATH) {\n                 let path = tcx.def_path_str(def_id.to_def_id());\n                 tcx.sess.span_err(attr.span, &format!(\"def-path({})\", path));\n             }"}, {"sha": "02eefe5622384a8e4319a99c196466b2027f7897", "filename": "src/librustc_trait_selection/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fautoderef.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -187,7 +187,7 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n     }\n \n     pub fn span(&self) -> Span {\n-        self.span.clone()\n+        self.span\n     }\n \n     pub fn reached_recursion_limit(&self) -> bool {"}, {"sha": "e29e740f136697c58c7527ce184085e9ebd07f33", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         // Don't care about `&mut` because `DerefMut` is used less\n                         // often and user will not expect autoderef happens.\n-                        if src.starts_with(\"&\") && !src.starts_with(\"&mut \") {\n+                        if src.starts_with('&') && !src.starts_with(\"&mut \") {\n                             let derefs = \"*\".repeat(steps);\n                             err.span_suggestion(\n                                 span,"}, {"sha": "7a9ed4b72dd03820a56388560c648c87532ee07f", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> OnUnimplementedDirective {\n     ) -> Result<Option<Self>, ErrorReported> {\n         let attrs = tcx.get_attrs(impl_def_id);\n \n-        let attr = if let Some(item) = attr::find_by_name(&attrs, sym::rustc_on_unimplemented) {\n+        let attr = if let Some(item) = tcx.sess.find_by_name(&attrs, sym::rustc_on_unimplemented) {\n             item\n         } else {\n             return Ok(None);"}, {"sha": "4c575f1c6ac4eab4a088a6da3e55bed75a8d7eec", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -24,7 +24,6 @@ use super::{Overflow, SelectionError, Unimplemented};\n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::project::ProjectionCacheKeyExt;\n-use rustc_ast::attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorReported;\n@@ -440,7 +439,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation\n         );\n \n-        // `previous_stack` stores a `TraitObligatiom`, while `obligation` is\n+        // `previous_stack` stores a `TraitObligation`, while `obligation` is\n         // a `PredicateObligation`. These are distinct types, so we can't\n         // use any `Option` combinator method that would force them to be\n         // the same.\n@@ -980,7 +979,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         &mut self.intercrate_ambiguity_causes\n                     {\n                         let attrs = tcx.get_attrs(def_id);\n-                        let attr = attr::find_by_name(&attrs, sym::rustc_reservation_impl);\n+                        let attr = tcx.sess.find_by_name(&attrs, sym::rustc_reservation_impl);\n                         let value = attr.and_then(|a| a.value_str());\n                         if let Some(value) = value {\n                             debug!("}, {"sha": "4c8be8eb610103d620c97e941f1b8befca09217e", "filename": "src/librustc_traits/chalk/db.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_traits%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Fdb.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let predicates = self.tcx.predicates_of(adt_def.did).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner))\n             .collect();\n@@ -174,7 +174,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                 phantom_data: adt_def.is_phantom_data(),\n             },\n         });\n-        return struct_datum;\n+        struct_datum\n     }\n \n     fn fn_def_datum(\n@@ -187,7 +187,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let predicates = self.tcx.predicates_defined_on(def_id).predicates;\n         let where_clauses: Vec<_> = predicates\n-            .into_iter()\n+            .iter()\n             .map(|(wc, _)| wc.subst(self.tcx, &bound_vars))\n             .filter_map(|wc| LowerInto::<Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>>::lower_into(wc, &self.interner)).collect();\n \n@@ -276,7 +276,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             parameters[0].assert_ty_ref(&self.interner).could_match(&self.interner, &lowered_ty)\n         });\n \n-        let impls = matched_impls.map(|matched_impl| chalk_ir::ImplId(matched_impl)).collect();\n+        let impls = matched_impls.map(chalk_ir::ImplId).collect();\n         impls\n     }\n \n@@ -379,7 +379,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         ty::AdtKind::Struct | ty::AdtKind::Union => None,\n                         ty::AdtKind::Enum => {\n                             let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n-                            if constraint.0.len() > 0 { unimplemented!() } else { Some(true) }\n+                            if !constraint.0.is_empty() { unimplemented!() } else { Some(true) }\n                         }\n                     },\n                     _ => None,\n@@ -398,7 +398,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                         ty::AdtKind::Struct | ty::AdtKind::Union => None,\n                         ty::AdtKind::Enum => {\n                             let constraint = self.tcx.adt_sized_constraint(adt_def.did);\n-                            if constraint.0.len() > 0 { unimplemented!() } else { Some(true) }\n+                            if !constraint.0.is_empty() { unimplemented!() } else { Some(true) }\n                         }\n                     },\n                     _ => None,\n@@ -440,7 +440,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             FnOnce => self.tcx.lang_items().fn_once_trait(),\n             Unsize => self.tcx.lang_items().unsize_trait(),\n         };\n-        def_id.map(|t| chalk_ir::TraitId(t))\n+        def_id.map(chalk_ir::TraitId)\n     }\n \n     fn is_object_safe(&self, trait_id: chalk_ir::TraitId<RustInterner<'tcx>>) -> bool {"}, {"sha": "b31f9f3c7b14f9c30f6fb91f103be0df2775f268", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -443,7 +443,7 @@ fn opaque_type_projection_predicates(\n \n     let bounds = tcx.predicates_of(def_id);\n     let predicates =\n-        util::elaborate_predicates(tcx, bounds.predicates.into_iter().map(|&(pred, _)| pred));\n+        util::elaborate_predicates(tcx, bounds.predicates.iter().map(|&(pred, _)| pred));\n \n     let filtered_predicates = predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;"}, {"sha": "258c5b77df25bc21c938fdee530147ba7f4b4a3c", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     //\n                     // FIXME? Other potential candidate methods: `as_ref` and\n                     // `as_mut`?\n-                    .any(|a| a.check_name(sym::rustc_conversion_suggestion))\n+                    .any(|a| self.sess().check_name(a, sym::rustc_conversion_suggestion))\n         });\n \n         methods"}, {"sha": "9ef9164191675cf6432dd918200323153b8fc085", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -368,6 +368,6 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         let anon_b = self.tcx.anonymize_late_bound_regions(&b);\n         self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n \n-        Ok(a.clone())\n+        Ok(a)\n     }\n }"}, {"sha": "93fdf93e9e3944af3f8d8eecbf5f2dda7e267e46", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,7 +4,7 @@\n //! types computed here.\n \n use super::FnCtxt;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -16,7 +16,7 @@ use rustc_span::Span;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    types: FxHashMap<ty::GeneratorInteriorTypeCause<'tcx>, usize>,\n+    types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n@@ -88,18 +88,15 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                     .span_note(yield_data.span, &*note)\n                     .emit();\n             } else {\n-                // Map the type to the number of types added before it\n-                let entries = self.types.len();\n+                // Insert the type into the ordered set.\n                 let scope_span = scope.map(|s| s.span(self.fcx.tcx, self.region_scope_tree));\n-                self.types\n-                    .entry(ty::GeneratorInteriorTypeCause {\n-                        span: source_span,\n-                        ty: &ty,\n-                        scope_span,\n-                        yield_span: yield_data.span,\n-                        expr: expr.map(|e| e.hir_id),\n-                    })\n-                    .or_insert(entries);\n+                self.types.insert(ty::GeneratorInteriorTypeCause {\n+                    span: source_span,\n+                    ty: &ty,\n+                    scope_span,\n+                    yield_span: yield_data.span,\n+                    expr: expr.map(|e| e.hir_id),\n+                });\n             }\n         } else {\n             debug!(\n@@ -132,7 +129,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n-        types: FxHashMap::default(),\n+        types: FxIndexSet::default(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n         expr_count: 0,\n         kind,\n@@ -144,10 +141,8 @@ pub fn resolve_interior<'a, 'tcx>(\n     let region_expr_count = visitor.region_scope_tree.body_expr_count(body_id).unwrap();\n     assert_eq!(region_expr_count, visitor.expr_count);\n \n-    let mut types: Vec<_> = visitor.types.drain().collect();\n-\n-    // Sort types by insertion order\n-    types.sort_by_key(|t| t.1);\n+    // The types are already kept in insertion order.\n+    let types = visitor.types;\n \n     // The types in the generator interior contain lifetimes local to the generator itself,\n     // which should not be exposed outside of the generator. Therefore, we replace these\n@@ -164,7 +159,7 @@ pub fn resolve_interior<'a, 'tcx>(\n     let mut captured_tys = FxHashSet::default();\n     let type_causes: Vec<_> = types\n         .into_iter()\n-        .filter_map(|(mut cause, _)| {\n+        .filter_map(|mut cause| {\n             // Erase regions and canonicalize late-bound regions to deduplicate as many types as we\n             // can.\n             let erased = fcx.tcx.erase_regions(&cause.ty);"}, {"sha": "3d58fb30d91e409b75a30562712e54fad71ec512", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2603,7 +2603,7 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def: &ty::AdtDef) {\n     let repr = def.repr;\n     if repr.packed() {\n         for attr in tcx.get_attrs(def.did).iter() {\n-            for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n+            for r in attr::find_repr_attrs(&tcx.sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n                     if let Some(repr_pack) = repr.pack {\n                         if pack as u64 != repr_pack.bytes() {\n@@ -2814,7 +2814,7 @@ pub fn check_enum<'tcx>(\n \n     if vs.is_empty() {\n         let attributes = tcx.get_attrs(def_id.to_def_id());\n-        if let Some(attr) = attr::find_by_name(&attributes, sym::repr) {\n+        if let Some(attr) = tcx.sess.find_by_name(&attributes, sym::repr) {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "f598ada900feecfd2f6062cac615917acfecfa41", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1114,7 +1114,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n         } else if !etc && !unmentioned_fields.is_empty() {\n-            unmentioned_err = Some(self.error_unmentioned_fields(pat.span, &unmentioned_fields));\n+            unmentioned_err = Some(self.error_unmentioned_fields(pat, &unmentioned_fields));\n         }\n         match (inexistent_fields_err, unmentioned_err) {\n             (Some(mut i), Some(mut u)) => {\n@@ -1237,13 +1237,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"This error indicates that a struct pattern attempted to \\\n-                    extract a non-existent field from a struct. Struct fields \\\n-                    are identified by the name used before the colon : so struct \\\n-                    patterns should resemble the declaration of the struct type \\\n-                    being matched.\\n\\n\\\n-                    If you are using shorthand field patterns but want to refer \\\n-                    to the struct field by a different name, you should rename \\\n-                    it explicitly.\",\n+                 extract a non-existent field from a struct. Struct fields \\\n+                 are identified by the name used before the colon : so struct \\\n+                 patterns should resemble the declaration of the struct type \\\n+                 being matched.\\n\\n\\\n+                 If you are using shorthand field patterns but want to refer \\\n+                 to the struct field by a different name, you should rename \\\n+                 it explicitly.\",\n             );\n         }\n         err\n@@ -1299,7 +1299,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn error_unmentioned_fields(\n         &self,\n-        span: Span,\n+        pat: &Pat<'_>,\n         unmentioned_fields: &[Ident],\n     ) -> DiagnosticBuilder<'tcx> {\n         let field_names = if unmentioned_fields.len() == 1 {\n@@ -1312,23 +1312,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .join(\", \");\n             format!(\"fields {}\", fields)\n         };\n-        let mut diag = struct_span_err!(\n+        let mut err = struct_span_err!(\n             self.tcx.sess,\n-            span,\n+            pat.span,\n             E0027,\n             \"pattern does not mention {}\",\n             field_names\n         );\n-        diag.span_label(span, format!(\"missing {}\", field_names));\n-        if self.tcx.sess.teach(&diag.get_code().unwrap()) {\n-            diag.note(\n+        err.span_label(pat.span, format!(\"missing {}\", field_names));\n+        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n                 \"This error indicates that a pattern for a struct fails to specify a \\\n-                    sub-pattern for every one of the struct's fields. Ensure that each field \\\n-                    from the struct's definition is mentioned in the pattern, or use `..` to \\\n-                    ignore unwanted fields.\",\n+                 sub-pattern for every one of the struct's fields. Ensure that each field \\\n+                 from the struct's definition is mentioned in the pattern, or use `..` to \\\n+                 ignore unwanted fields.\",\n             );\n         }\n-        diag\n+        err\n     }\n \n     fn check_pat_box("}, {"sha": "84f34c0039a0a11c2c4bd90b52bd0f0457180818", "filename": "src/librustc_typeck/check/place_op.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fplace_op.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -200,13 +200,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Gather up expressions we want to munge.\n         let mut exprs = vec![expr];\n \n-        loop {\n-            match exprs.last().unwrap().kind {\n-                hir::ExprKind::Field(ref expr, _)\n-                | hir::ExprKind::Index(ref expr, _)\n-                | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) => exprs.push(&expr),\n-                _ => break,\n-            }\n+        while let hir::ExprKind::Field(ref expr, _)\n+        | hir::ExprKind::Index(ref expr, _)\n+        | hir::ExprKind::Unary(hir::UnOp::UnDeref, ref expr) = exprs.last().unwrap().kind\n+        {\n+            exprs.push(&expr);\n         }\n \n         debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);"}, {"sha": "b47ef34600404c1c7e5d37d48af1fb8fca744eee", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -20,9 +20,9 @@ use crate::constrained_generic_params as cgp;\n use crate::middle::resolve_lifetime as rl;\n use rustc_ast::ast;\n use rustc_ast::ast::MetaItemKind;\n-use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n+use rustc_attr::{list_contains_name, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -1238,6 +1238,9 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n                 // HACK(eddyb) this provides the correct generics when\n                 // `feature(const_generics)` is enabled, so that const expressions\n                 // used with const generics, e.g. `Foo<{N+1}>`, can work at all.\n+                //\n+                // Note that we do not supply the parent generics when using\n+                // `feature(min_const_generics)`.\n                 Some(parent_def_id.to_def_id())\n             } else {\n                 let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n@@ -1715,21 +1718,17 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     /// A data structure with unique elements, which preserves order of insertion.\n     /// Preserving the order of insertion is important here so as not to break\n     /// compile-fail UI tests.\n-    // FIXME(eddyb) just use `IndexSet` from `indexmap`.\n     struct UniquePredicates<'tcx> {\n-        predicates: Vec<(ty::Predicate<'tcx>, Span)>,\n-        uniques: FxHashSet<(ty::Predicate<'tcx>, Span)>,\n+        predicates: FxIndexSet<(ty::Predicate<'tcx>, Span)>,\n     }\n \n     impl<'tcx> UniquePredicates<'tcx> {\n         fn new() -> Self {\n-            UniquePredicates { predicates: vec![], uniques: FxHashSet::default() }\n+            UniquePredicates { predicates: FxIndexSet::default() }\n         }\n \n         fn push(&mut self, value: (ty::Predicate<'tcx>, Span)) {\n-            if self.uniques.insert(value) {\n-                self.predicates.push(value);\n-            }\n+            self.predicates.insert(value);\n         }\n \n         fn extend<I: IntoIterator<Item = (ty::Predicate<'tcx>, Span)>>(&mut self, iter: I) {\n@@ -2011,7 +2010,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }))\n     }\n \n-    let mut predicates = predicates.predicates;\n+    let mut predicates: Vec<_> = predicates.predicates.into_iter().collect();\n \n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n@@ -2351,13 +2350,13 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     let mut link_ordinal_span = None;\n     let mut no_sanitize_span = None;\n     for attr in attrs.iter() {\n-        if attr.check_name(sym::cold) {\n+        if tcx.sess.check_name(attr, sym::cold) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.check_name(sym::rustc_allocator) {\n+        } else if tcx.sess.check_name(attr, sym::rustc_allocator) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.check_name(sym::unwind) {\n+        } else if tcx.sess.check_name(attr, sym::unwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::UNWIND;\n-        } else if attr.check_name(sym::ffi_returns_twice) {\n+        } else if tcx.sess.check_name(attr, sym::ffi_returns_twice) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n             } else {\n@@ -2370,9 +2369,9 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if attr.check_name(sym::ffi_pure) {\n+        } else if tcx.sess.check_name(attr, sym::ffi_pure) {\n             if tcx.is_foreign_item(id) {\n-                if attrs.iter().any(|a| a.check_name(sym::ffi_const)) {\n+                if attrs.iter().any(|a| tcx.sess.check_name(a, sym::ffi_const)) {\n                     // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n                     struct_span_err!(\n                         tcx.sess,\n@@ -2394,7 +2393,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if attr.check_name(sym::ffi_const) {\n+        } else if tcx.sess.check_name(attr, sym::ffi_const) {\n             if tcx.is_foreign_item(id) {\n                 codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n             } else {\n@@ -2407,25 +2406,25 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 )\n                 .emit();\n             }\n-        } else if attr.check_name(sym::rustc_allocator_nounwind) {\n+        } else if tcx.sess.check_name(attr, sym::rustc_allocator_nounwind) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_ALLOCATOR_NOUNWIND;\n-        } else if attr.check_name(sym::naked) {\n+        } else if tcx.sess.check_name(attr, sym::naked) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.check_name(sym::no_mangle) {\n+        } else if tcx.sess.check_name(attr, sym::no_mangle) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.check_name(sym::rustc_std_internal_symbol) {\n+        } else if tcx.sess.check_name(attr, sym::rustc_std_internal_symbol) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.check_name(sym::used) {\n+        } else if tcx.sess.check_name(attr, sym::used) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-        } else if attr.check_name(sym::thread_local) {\n+        } else if tcx.sess.check_name(attr, sym::thread_local) {\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.check_name(sym::track_caller) {\n+        } else if tcx.sess.check_name(attr, sym::track_caller) {\n             if tcx.is_closure(id) || tcx.fn_sig(id).abi() != abi::Abi::Rust {\n                 struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n                     .emit();\n             }\n             codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.check_name(sym::export_name) {\n+        } else if tcx.sess.check_name(attr, sym::export_name) {\n             if let Some(s) = attr.value_str() {\n                 if s.as_str().contains('\\0') {\n                     // `#[export_name = ...]` will be converted to a null-terminated string,\n@@ -2440,7 +2439,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 }\n                 codegen_fn_attrs.export_name = Some(s);\n             }\n-        } else if attr.check_name(sym::target_feature) {\n+        } else if tcx.sess.check_name(attr, sym::target_feature) {\n             if !tcx.features().target_feature_11 {\n                 check_target_feature_safe_fn(tcx, id, attr.span);\n             } else if let Some(local_id) = id.as_local() {\n@@ -2455,11 +2454,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 &supported_target_features,\n                 &mut codegen_fn_attrs.target_features,\n             );\n-        } else if attr.check_name(sym::linkage) {\n+        } else if tcx.sess.check_name(attr, sym::linkage) {\n             if let Some(val) = attr.value_str() {\n                 codegen_fn_attrs.linkage = Some(linkage_by_name(tcx, id, &val.as_str()));\n             }\n-        } else if attr.check_name(sym::link_section) {\n+        } else if tcx.sess.check_name(attr, sym::link_section) {\n             if let Some(val) = attr.value_str() {\n                 if val.as_str().bytes().any(|b| b == 0) {\n                     let msg = format!(\n@@ -2472,14 +2471,14 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     codegen_fn_attrs.link_section = Some(val);\n                 }\n             }\n-        } else if attr.check_name(sym::link_name) {\n+        } else if tcx.sess.check_name(attr, sym::link_name) {\n             codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.check_name(sym::link_ordinal) {\n+        } else if tcx.sess.check_name(attr, sym::link_ordinal) {\n             link_ordinal_span = Some(attr.span);\n             if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n                 codegen_fn_attrs.link_ordinal = ordinal;\n             }\n-        } else if attr.check_name(sym::no_sanitize) {\n+        } else if tcx.sess.check_name(attr, sym::no_sanitize) {\n             no_sanitize_span = Some(attr.span);\n             if let Some(list) = attr.meta_item_list() {\n                 for item in list.iter() {\n@@ -2506,11 +2505,11 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         }\n         match attr.meta().map(|i| i.kind) {\n             Some(MetaItemKind::Word) => {\n-                mark_used(attr);\n+                tcx.sess.mark_attr_used(attr);\n                 InlineAttr::Hint\n             }\n             Some(MetaItemKind::List(ref items)) => {\n-                mark_used(attr);\n+                tcx.sess.mark_attr_used(attr);\n                 inline_span = Some(attr.span);\n                 if items.len() != 1 {\n                     struct_span_err!(\n@@ -2553,7 +2552,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 ia\n             }\n             Some(MetaItemKind::List(ref items)) => {\n-                mark_used(attr);\n+                tcx.sess.mark_attr_used(attr);\n                 inline_span = Some(attr.span);\n                 if items.len() != 1 {\n                     err(attr.span, \"expected one argument\");\n@@ -2614,7 +2613,8 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if tcx.is_weak_lang_item(id) {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n-    if let Some(name) = weak_lang_items::link_name(&attrs) {\n+    let check_name = |attr, sym| tcx.sess.check_name(attr, sym);\n+    if let Some(name) = weak_lang_items::link_name(check_name, &attrs) {\n         codegen_fn_attrs.export_name = Some(name);\n         codegen_fn_attrs.link_name = Some(name);\n     }"}, {"sha": "17444c6d0ac957442c7760123e1a2f47bf7638a7", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -326,21 +326,39 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n             GenericParamKind::Const { ty: ref hir_ty, .. } => {\n                 let ty = icx.to_ty(hir_ty);\n-                let err = match ty.peel_refs().kind {\n-                    ty::FnPtr(_) => Some(\"function pointers\"),\n-                    ty::RawPtr(_) => Some(\"raw pointers\"),\n-                    _ => None,\n+                let err_ty_str;\n+                let err = if tcx.features().min_const_generics {\n+                    match ty.kind {\n+                        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n+                        ty::FnPtr(_) => Some(\"function pointers\"),\n+                        ty::RawPtr(_) => Some(\"raw pointers\"),\n+                        _ => {\n+                            err_ty_str = format!(\"`{}`\", ty);\n+                            Some(err_ty_str.as_str())\n+                        }\n+                    }\n+                } else {\n+                    match ty.peel_refs().kind {\n+                        ty::FnPtr(_) => Some(\"function pointers\"),\n+                        ty::RawPtr(_) => Some(\"raw pointers\"),\n+                        _ => None,\n+                    }\n                 };\n                 if let Some(unsupported_type) = err {\n-                    tcx.sess\n-                        .struct_span_err(\n-                            hir_ty.span,\n-                            &format!(\n-                                \"using {} as const generic parameters is forbidden\",\n-                                unsupported_type\n-                            ),\n-                        )\n-                        .emit();\n+                    let mut err = tcx.sess.struct_span_err(\n+                        hir_ty.span,\n+                        &format!(\n+                            \"using {} as const generic parameters is forbidden\",\n+                            unsupported_type\n+                        ),\n+                    );\n+\n+                    if tcx.features().min_const_generics {\n+                        err.note(\"the only supported types are integers, `bool` and `char`\")\n+                        .note(\"more complex types are supported with `#[feature(const_generics)]`\").emit()\n+                    } else {\n+                        err.emit();\n+                    }\n                 };\n                 if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n                     .is_some()"}, {"sha": "a8247e2f494ccf1a3fd6b2a2bc1c09c8e86dc7f9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -196,7 +196,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n                     }\n \n                     for attr in it.attrs {\n-                        if attr.check_name(sym::track_caller) {\n+                        if tcx.sess.check_name(attr, sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err(\n                                     attr.span,\n@@ -293,7 +293,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                     }\n \n                     for attr in it.attrs {\n-                        if attr.check_name(sym::track_caller) {\n+                        if tcx.sess.check_name(attr, sym::track_caller) {\n                             tcx.sess\n                                 .struct_span_err(\n                                     attr.span,"}, {"sha": "8a6fe620af7a319758cf4d3c26960f2f908e2388", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -583,7 +583,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 self.tcx()\n                     .sess\n                     .delay_span_bug(span, \"struct or tuple struct pattern not applied to an ADT\");\n-                return Err(());\n+                Err(())\n             }\n         }\n     }\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             ty::Tuple(substs) => Ok(substs.len()),\n             _ => {\n                 self.tcx().sess.delay_span_bug(span, \"tuple pattern not applied to a tuple\");\n-                return Err(());\n+                Err(())\n             }\n         }\n     }"}, {"sha": "b4ced412e5e5565dbb01e51ca0fc28f7dd975603", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,8 +2,8 @@ use super::*;\n \n use rustc_ast::ast::*;\n use rustc_ast::attr;\n-use rustc_ast::with_default_session_globals;\n use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::with_default_session_globals;\n use rustc_span::DUMMY_SP;\n \n fn word_cfg(s: &str) -> Cfg {"}, {"sha": "7b1dd5b11ed0e014b97cc46674a2782eb3e5a6df", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1395,10 +1395,13 @@ impl Clean<Type> for hir::Ty<'_> {\n                                             _ => None,\n                                         });\n                                     if let Some(lt) = lifetime.cloned() {\n-                                        if !lt.is_elided() {\n-                                            let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                            lt_substs.insert(lt_def_id.to_def_id(), lt.clean(cx));\n-                                        }\n+                                        let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                        let cleaned = if !lt.is_elided() {\n+                                            lt.clean(cx)\n+                                        } else {\n+                                            self::types::Lifetime::elided()\n+                                        };\n+                                        lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n                                     }\n                                     indices.lifetimes += 1;\n                                 }\n@@ -1957,21 +1960,17 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n                 output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None },\n             }\n         } else {\n-            let elide_lifetimes = self.args.iter().all(|arg| match arg {\n-                hir::GenericArg::Lifetime(lt) => lt.is_elided(),\n-                _ => true,\n-            });\n             GenericArgs::AngleBracketed {\n                 args: self\n                     .args\n                     .iter()\n-                    .filter_map(|arg| match arg {\n-                        hir::GenericArg::Lifetime(lt) if !elide_lifetimes => {\n-                            Some(GenericArg::Lifetime(lt.clean(cx)))\n+                    .map(|arg| match arg {\n+                        hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n+                            GenericArg::Lifetime(lt.clean(cx))\n                         }\n-                        hir::GenericArg::Lifetime(_) => None,\n-                        hir::GenericArg::Type(ty) => Some(GenericArg::Type(ty.clean(cx))),\n-                        hir::GenericArg::Const(ct) => Some(GenericArg::Const(ct.clean(cx))),\n+                        hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n+                        hir::GenericArg::Type(ty) => GenericArg::Type(ty.clean(cx)),\n+                        hir::GenericArg::Const(ct) => GenericArg::Const(ct.clean(cx)),\n                     })\n                     .collect(),\n                 bindings: self.bindings.clean(cx),"}, {"sha": "50eca75d7cab2cc211e19f0d6b5986b18326c3c7", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -10,7 +10,7 @@ use std::{slice, vec};\n \n use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::attr;\n-use rustc_ast::util::comments::strip_doc_comment_decoration;\n+use rustc_ast::util::comments::beautify_doc_string;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -506,10 +506,11 @@ impl Attributes {\n             .iter()\n             .filter_map(|attr| {\n                 if let Some(value) = attr.doc_str() {\n-                    let (value, mk_fragment): (_, fn(_, _, _) -> _) = if attr.is_doc_comment() {\n-                        (strip_doc_comment_decoration(value), DocFragment::SugaredDoc)\n+                    let value = beautify_doc_string(value);\n+                    let mk_fragment: fn(_, _, _) -> _ = if attr.is_doc_comment() {\n+                        DocFragment::SugaredDoc\n                     } else {\n-                        (value.to_string(), DocFragment::RawDoc)\n+                        DocFragment::RawDoc\n                     };\n \n                     let line = doc_line;\n@@ -749,6 +750,10 @@ impl Lifetime {\n     pub fn statik() -> Lifetime {\n         Lifetime(\"'static\".to_string())\n     }\n+\n+    pub fn elided() -> Lifetime {\n+        Lifetime(\"'_\".to_string())\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "c22538f21f69fbefb567942de1fc61e8bbdb63ee", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2,9 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, Deprecation, ExternalCrate, FnDecl, FnRetTy, Generic, GenericArg,\n-    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, MacroKind, Path,\n-    PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type, TypeBinding,\n-    TypeKind, Visibility, WherePredicate,\n+    GenericArgs, GenericBound, Generics, GetDefId, ImportSource, Item, ItemEnum, Lifetime,\n+    MacroKind, Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Span, Stability, Type,\n+    TypeBinding, TypeKind, Visibility, WherePredicate,\n };\n use crate::core::DocContext;\n \n@@ -121,7 +121,10 @@ pub fn external_generic_args(\n     let args: Vec<_> = substs\n         .iter()\n         .filter_map(|kind| match kind.unpack() {\n-            GenericArgKind::Lifetime(lt) => lt.clean(cx).map(GenericArg::Lifetime),\n+            GenericArgKind::Lifetime(lt) => match lt {\n+                ty::ReLateBound(_, ty::BrAnon(_)) => Some(GenericArg::Lifetime(Lifetime::elided())),\n+                _ => lt.clean(cx).map(GenericArg::Lifetime),\n+            },\n             GenericArgKind::Type(_) if skip_self => {\n                 skip_self = false;\n                 None\n@@ -607,6 +610,9 @@ pub fn register_res(cx: &DocContext<'_>, res: Res) -> DefId {\n         Res::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n         Res::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n         Res::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Res::Def(DefKind::AssocTy | DefKind::AssocFn | DefKind::AssocConst, i) => {\n+            (cx.tcx.parent(i).unwrap(), TypeKind::Trait)\n+        }\n         Res::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n         Res::Def(DefKind::Union, i) => (i, TypeKind::Union),\n         Res::Def(DefKind::Mod, i) => (i, TypeKind::Module),"}, {"sha": "8b52ce710a45fd329c59d5eac30cfe5eec1b1860", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -69,14 +69,14 @@ impl DocFS {\n             let sender = self.errors.clone().expect(\"can't write after closing\");\n             rayon::spawn(move || {\n                 fs::write(&path, contents).unwrap_or_else(|e| {\n-                    sender\n-                        .send(format!(\"\\\"{}\\\": {}\", path.display(), e))\n-                        .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                    sender.send(format!(\"\\\"{}\\\": {}\", path.display(), e)).unwrap_or_else(|_| {\n+                        panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n+                    })\n                 });\n             });\n-            Ok(())\n         } else {\n-            Ok(try_err!(fs::write(&path, contents), path))\n+            try_err!(fs::write(&path, contents), path);\n         }\n+        Ok(())\n     }\n }"}, {"sha": "21e476cbe06883bf43b8b5511d47db3177bf6879", "filename": "src/librustdoc/html/highlight/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight%2Ftests.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,6 +1,6 @@\n-use rustc_ast::attr::with_session_globals;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n+use rustc_span::with_session_globals;\n use rustc_span::FileName;\n \n use super::Classifier;"}, {"sha": "4cbc56333b1553476ad7bef1b58793ad7e9830e8", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3450,7 +3450,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n                 if impl_.trait_.def_id().map_or(false, |d| c.traits[&d].is_spotlight) {\n                     if out.is_empty() {\n                         out.push_str(&format!(\n-                            \"<h3 class=\\\"important\\\">Important traits for {}</h3>\\\n+                            \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n                                       <code class=\\\"content\\\">\",\n                             impl_.for_.print()\n                         ));\n@@ -3485,7 +3485,7 @@ fn spotlight_decl(decl: &clean::FnDecl) -> String {\n     if !out.is_empty() {\n         out.insert_str(\n             0,\n-            \"<span class=\\\"important-traits\\\"><span class=\\\"important-traits-tooltip\\\">\u24d8<div class='important-traits-tooltiptext'><span class=\\\"docblock\\\">\"\n+            \"<span class=\\\"notable-traits\\\"><span class=\\\"notable-traits-tooltip\\\">\u24d8<div class='notable-traits-tooltiptext'><span class=\\\"docblock\\\">\"\n \n         );\n         out.push_str(\"</code></span></div></span></span>\");"}, {"sha": "19284018a30db91372837389dde62fb02769945f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -2636,9 +2636,9 @@ function defocusSearchBar() {\n         });\n     }());\n \n-    onEachLazy(document.getElementsByClassName(\"important-traits\"), function(e) {\n+    onEachLazy(document.getElementsByClassName(\"notable-traits\"), function(e) {\n         e.onclick = function() {\n-            this.getElementsByClassName('important-traits-tooltiptext')[0]\n+            this.getElementsByClassName('notable-traits-tooltiptext')[0]\n                 .classList.toggle(\"force-tooltip\");\n         };\n     });"}, {"sha": "db0e4f4d31df81c8ad81fa5025d7ab26c1fdf3d1", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -91,7 +91,7 @@ h2 {\n h3 {\n \tfont-size: 1.3em;\n }\n-h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod):not(.important),\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod):not(.notable),\n h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n \tfont-weight: 500;\n \tmargin: 20px 0 15px 0;\n@@ -528,7 +528,7 @@ h4 > code, h3 > code, .invisible > code {\n \tfont-size: 0.8em;\n }\n \n-.content .methods > div:not(.important-traits) {\n+.content .methods > div:not(.notable-traits) {\n \tmargin-left: 40px;\n \tmargin-bottom: 15px;\n }\n@@ -1099,17 +1099,17 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \tfont-size: 20px;\n }\n \n-.important-traits-tooltip {\n+.notable-traits-tooltip {\n \tdisplay: inline-block;\n \tcursor: pointer;\n }\n \n-.important-traits:hover .important-traits-tooltiptext,\n-.important-traits .important-traits-tooltiptext.force-tooltip {\n+.notable-traits:hover .notable-traits-tooltiptext,\n+.notable-traits .notable-traits-tooltiptext.force-tooltip {\n \tdisplay: inline-block;\n }\n \n-.important-traits .important-traits-tooltiptext {\n+.notable-traits .notable-traits-tooltiptext {\n \tdisplay: none;\n \tpadding: 5px 3px 3px 3px;\n \tborder-radius: 6px;\n@@ -1121,18 +1121,18 @@ h3 > .collapse-toggle, h4 > .collapse-toggle {\n \tborder: 1px solid;\n }\n \n-.important-traits-tooltip::after {\n+.notable-traits-tooltip::after {\n \t/* The margin on the tooltip does not capture hover events,\n \t   this extends the area of hover enough so that mouse hover is not\n \t   lost when moving the mouse to the tooltip */\n \tcontent: \"\\00a0\\00a0\\00a0\";\n }\n \n-.important-traits .important, .important-traits .docblock {\n+.notable-traits .notable, .notable-traits .docblock {\n \tmargin: 0;\n }\n \n-.important-traits .docblock code.content{\n+.notable-traits .docblock code.content{\n \tmargin: 0;\n \tpadding: 0;\n \tfont-size: 20px;\n@@ -1183,13 +1183,13 @@ pre.rust {\n \tfont-size: 16px;\n }\n \n-.important-traits {\n+.notable-traits {\n \tcursor: pointer;\n \tz-index: 2;\n \tmargin-left: 5px;\n }\n \n-h4 > .important-traits {\n+h4 > .notable-traits {\n \tposition: absolute;\n \tleft: -44px;\n \ttop: 2px;\n@@ -1431,7 +1431,7 @@ h4 > .important-traits {\n \t\tz-index: 1;\n \t}\n \n-\th4 > .important-traits {\n+\th4 > .notable-traits {\n \t\tposition: absolute;\n \t\tleft: -22px;\n \t\ttop: 24px;\n@@ -1522,7 +1522,7 @@ h4 > .important-traits {\n \t\tmargin-top: 0;\n \t}\n \n-\t.important-traits .important-traits-tooltiptext {\n+\t.notable-traits .notable-traits-tooltiptext {\n \t\tleft: 0;\n \t\ttop: 100%;\n \t}\n@@ -1544,7 +1544,7 @@ h4 > .important-traits {\n \t}\n }\n \n-h3.important {\n+h3.notable {\n \tmargin: 0;\n \tmargin-bottom: 13px;\n \tfont-size: 19px;"}, {"sha": "60f0d25b219e7a6d62c2f9f26994477e85a9b619", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -389,7 +389,7 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tborder-color: transparent #314559 transparent transparent;\n }\n \n-.important-traits-tooltiptext {\n+.notable-traits-tooltiptext {\n \tbackground-color: #314559;\n \tborder-color: #5c6773;\n }"}, {"sha": "34c6cbbf4fa21e1dcc668c435a0999fa9ed561bd", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -339,7 +339,7 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tborder-color: transparent black transparent transparent;\n }\n \n-.important-traits-tooltiptext {\n+.notable-traits-tooltiptext {\n \tbackground-color: #111;\n \tborder-color: #777;\n }"}, {"sha": "137aad4ed4398ed23220ac0ba9f00e2449d62d3e", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -333,7 +333,7 @@ pre.ignore:hover, .information:hover + pre.ignore {\n \tborder-color: transparent black transparent transparent;\n }\n \n-.important-traits-tooltiptext {\n+.notable-traits-tooltiptext {\n \tbackground-color: #eee;\n \tborder-color: #999;\n }"}, {"sha": "b722cfc8f7521f9bb3d46912cba0b8f145a40e15", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,7 +4,6 @@ use crate::core::DocContext;\n use crate::fold::{self, DocFolder};\n use crate::passes::Pass;\n \n-use rustc_ast::attr;\n use rustc_span::symbol::sym;\n use rustc_span::FileName;\n use serde::Serialize;\n@@ -155,7 +154,10 @@ impl fold::DocFolder for CoverageCalculator {\n                 return Some(i);\n             }\n             clean::ImplItem(ref impl_)\n-                if attr::contains_name(&i.attrs.other_attrs, sym::automatically_derived)\n+                if i.attrs\n+                    .other_attrs\n+                    .iter()\n+                    .any(|item| item.has_name(sym::automatically_derived))\n                     || impl_.synthetic\n                     || impl_.blanket_impl.is_some() =>\n             {"}, {"sha": "062bd61a7d00279b22ac8a581da9698fbf8e256e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 149, "deletions": 45, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -17,6 +17,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n \n+use std::cell::Cell;\n use std::ops::Range;\n \n use crate::clean::*;\n@@ -62,11 +63,15 @@ struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     // NOTE: this may not necessarily be a module in the current crate\n     mod_ids: Vec<DefId>,\n+    /// This is used to store the kind of associated items,\n+    /// because `clean` and the disambiguator code expect them to be different.\n+    /// See the code for associated items on inherent impls for details.\n+    kind_side_channel: Cell<Option<DefKind>>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        LinkCollector { cx, mod_ids: Vec::new() }\n+        LinkCollector { cx, mod_ids: Vec::new(), kind_side_channel: Cell::new(None) }\n     }\n \n     fn variant_field(\n@@ -174,7 +179,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve(\n         &self,\n         path_str: &str,\n-        disambiguator: Option<&str>,\n+        disambiguator: Option<Disambiguator>,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n@@ -212,9 +217,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         return Ok((res, Some(path_str.to_owned())));\n                     }\n                     Res::Def(DefKind::Mod, _) => {\n-                        // This resolved to a module, but if we were passed `type@`,\n-                        // we want primitive types to take precedence instead.\n-                        if disambiguator == Some(\"type\") {\n+                        // This resolved to a module, but we want primitive types to take precedence instead.\n+                        if matches!(\n+                            disambiguator,\n+                            None | Some(Disambiguator::Namespace(Namespace::TypeNS))\n+                        ) {\n                             if let Some(prim) = is_primitive(path_str, ns) {\n                                 if extra_fragment.is_some() {\n                                     return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n@@ -347,6 +354,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 AnchorFailure::AssocConstant\n                             }))\n                         } else {\n+                            // HACK(jynelson): `clean` expects the type, not the associated item.\n+                            // but the disambiguator logic expects the associated item.\n+                            // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                            self.kind_side_channel.replace(Some(item.kind.as_def_kind()));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n                         }\n                     } else {\n@@ -415,7 +426,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                 AnchorFailure::Method\n                             }))\n                         } else {\n-                            Ok((ty_res, Some(format!(\"{}.{}\", kind, item_name))))\n+                            let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                            Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n                         }\n                     } else {\n                         self.variant_field(path_str, current_item, module_id)\n@@ -574,46 +586,14 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             };\n             let resolved_self;\n             let mut path_str;\n+            let disambiguator;\n             let (res, fragment) = {\n-                let mut kind = None;\n-                let mut disambiguator = None;\n-                path_str = if let Some(prefix) =\n-                    [\"struct@\", \"enum@\", \"type@\", \"trait@\", \"union@\", \"module@\", \"mod@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(TypeNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if let Some(prefix) =\n-                    [\"const@\", \"static@\", \"value@\", \"function@\", \"fn@\", \"method@\"]\n-                        .iter()\n-                        .find(|p| link.starts_with(**p))\n-                {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(&prefix[..prefix.len() - 1]);\n-                    link.trim_start_matches(prefix)\n-                } else if link.ends_with(\"!()\") {\n-                    kind = Some(MacroNS);\n-                    link.trim_end_matches(\"!()\")\n-                } else if link.ends_with(\"()\") {\n-                    kind = Some(ValueNS);\n-                    disambiguator = Some(\"fn\");\n-                    link.trim_end_matches(\"()\")\n-                } else if link.starts_with(\"macro@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_start_matches(\"macro@\")\n-                } else if link.starts_with(\"derive@\") {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"derive\");\n-                    link.trim_start_matches(\"derive@\")\n-                } else if link.ends_with('!') {\n-                    kind = Some(MacroNS);\n-                    disambiguator = Some(\"macro\");\n-                    link.trim_end_matches('!')\n+                path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n+                    disambiguator = Some(d);\n+                    path\n                 } else {\n-                    &link[..]\n+                    disambiguator = None;\n+                    &link\n                 }\n                 .trim();\n \n@@ -646,7 +626,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n \n-                match kind {\n+                match disambiguator.map(Disambiguator::ns) {\n                     Some(ns @ ValueNS) => {\n                         match self.resolve(\n                             path_str,\n@@ -789,6 +769,42 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             } else {\n                 debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n+                // Disallow e.g. linking to enums with `struct@`\n+                if let Res::Def(kind, id) = res {\n+                    debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+                    match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n+                        | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+                        // NOTE: this allows 'method' to mean both normal functions and associated functions\n+                        // This can't cause ambiguity because both are in the same namespace.\n+                        | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+                        // These are namespaces; allow anything in the namespace to match\n+                        | (_, Some(Disambiguator::Namespace(_)))\n+                        // If no disambiguator given, allow anything\n+                        | (_, None)\n+                        // All of these are valid, so do nothing\n+                        => {}\n+                        (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+                        (_, Some(Disambiguator::Kind(expected))) => {\n+                            // The resolved item did not match the disambiguator; give a better error than 'not found'\n+                            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+                            report_diagnostic(cx, &msg, &item, &dox, link_range, |diag, sp| {\n+                                // HACK(jynelson): by looking at the source I saw the DefId we pass\n+                                // for `expected.descr()` doesn't matter, since it's not a crate\n+                                let note = format!(\"this link resolved to {} {}, which is not {} {}\", kind.article(), kind.descr(id), expected.article(), expected.descr(id));\n+                                let suggestion = Disambiguator::display_for(kind, path_str);\n+                                let help_msg = format!(\"to link to the {}, use its disambiguator\", kind.descr(id));\n+                                diag.note(&note);\n+                                if let Some(sp) = sp {\n+                                    diag.span_suggestion(sp, &help_msg, suggestion, Applicability::MaybeIncorrect);\n+                                } else {\n+                                    diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n+                                }\n+                            });\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n                 // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n                 if let Some((src_id, dst_id)) = res\n                     .opt_def_id()\n@@ -837,6 +853,94 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum Disambiguator {\n+    Kind(DefKind),\n+    Namespace(Namespace),\n+}\n+\n+impl Disambiguator {\n+    /// (disambiguator, path_str)\n+    fn from_str(link: &str) -> Result<(Self, &str), ()> {\n+        use Disambiguator::{Kind, Namespace as NS};\n+\n+        let find_suffix = || {\n+            let suffixes = [\n+                (\"!()\", DefKind::Macro(MacroKind::Bang)),\n+                (\"()\", DefKind::Fn),\n+                (\"!\", DefKind::Macro(MacroKind::Bang)),\n+            ];\n+            for &(suffix, kind) in &suffixes {\n+                if link.ends_with(suffix) {\n+                    return Ok((Kind(kind), link.trim_end_matches(suffix)));\n+                }\n+            }\n+            Err(())\n+        };\n+\n+        if let Some(idx) = link.find('@') {\n+            let (prefix, rest) = link.split_at(idx);\n+            let d = match prefix {\n+                \"struct\" => Kind(DefKind::Struct),\n+                \"enum\" => Kind(DefKind::Enum),\n+                \"trait\" => Kind(DefKind::Trait),\n+                \"union\" => Kind(DefKind::Union),\n+                \"module\" | \"mod\" => Kind(DefKind::Mod),\n+                \"const\" | \"constant\" => Kind(DefKind::Const),\n+                \"static\" => Kind(DefKind::Static),\n+                \"function\" | \"fn\" | \"method\" => Kind(DefKind::Fn),\n+                \"derive\" => Kind(DefKind::Macro(MacroKind::Derive)),\n+                \"type\" => NS(Namespace::TypeNS),\n+                \"value\" => NS(Namespace::ValueNS),\n+                \"macro\" => NS(Namespace::MacroNS),\n+                _ => return find_suffix(),\n+            };\n+            Ok((d, &rest[1..]))\n+        } else {\n+            find_suffix()\n+        }\n+    }\n+\n+    fn display_for(kind: DefKind, path_str: &str) -> String {\n+        if kind == DefKind::Macro(MacroKind::Bang) {\n+            return format!(\"{}!\", path_str);\n+        } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n+            return format!(\"{}()\", path_str);\n+        }\n+        let prefix = match kind {\n+            DefKind::Struct => \"struct\",\n+            DefKind::Enum => \"enum\",\n+            DefKind::Trait => \"trait\",\n+            DefKind::Union => \"union\",\n+            DefKind::Mod => \"mod\",\n+            DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst => {\n+                \"const\"\n+            }\n+            DefKind::Static => \"static\",\n+            DefKind::Macro(MacroKind::Derive) => \"derive\",\n+            // Now handle things that don't have a specific disambiguator\n+            _ => match kind\n+                .ns()\n+                .expect(\"tried to calculate a disambiguator for a def without a namespace?\")\n+            {\n+                Namespace::TypeNS => \"type\",\n+                Namespace::ValueNS => \"value\",\n+                Namespace::MacroNS => \"macro\",\n+            },\n+        };\n+        format!(\"{}@{}\", prefix, path_str)\n+    }\n+\n+    fn ns(self) -> Namespace {\n+        match self {\n+            Self::Namespace(n) => n,\n+            Self::Kind(k) => {\n+                k.ns().expect(\"only DefKinds with a valid namespace can be disambiguators\")\n+            }\n+        }\n+    }\n+}\n+\n /// Reports a diagnostic for an intra-doc link.\n ///\n /// If no link range is provided, or the source span of the link cannot be determined, the span of"}, {"sha": "62f52ea5213f357d445f04ada98ba219dc2c77e2", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -398,7 +398,7 @@ pub fn make_test(\n     // Uses librustc_ast to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n     let result = rustc_driver::catch_fatal_errors(|| {\n-        rustc_ast::with_session_globals(edition, || {\n+        rustc_span::with_session_globals(edition, || {\n             use rustc_errors::emitter::EmitterWriter;\n             use rustc_errors::Handler;\n             use rustc_parse::maybe_new_parser_from_source_str;\n@@ -943,7 +943,12 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         // The collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us.\n         if let Some(doc) = attrs.collapsed_doc_value() {\n-            self.collector.set_position(attrs.span.unwrap_or(DUMMY_SP));\n+            // Use the outermost invocation, so that doctest names come from where the docs were written.\n+            let span = attrs\n+                .span\n+                .map(|span| span.ctxt().outer_expn().expansion_cause().unwrap_or(span))\n+                .unwrap_or(DUMMY_SP);\n+            self.collector.set_position(span);\n             markdown::find_testable_code(\n                 &doc,\n                 self.collector,"}, {"sha": "af47b440640afdf36530efd9d64c361cdb9c8088", "filename": "src/test/codegen-units/polymorphization/pr-75255.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,52 @@\n+// compile-flags:-Zpolymorphize=on -Zprint-mono-items=lazy -Copt-level=1\n+// ignore-tidy-linelength\n+\n+#![crate_type = \"rlib\"]\n+\n+// Test that only one copy of `Iter::map` and `iter::repeat` are generated.\n+\n+fn unused<T>() -> u64 {\n+    42\n+}\n+\n+fn foo<T>() {\n+    let x = [1, 2, 3, std::mem::size_of::<T>()];\n+    x.iter().map(|_| ());\n+}\n+\n+//~ MONO_ITEM fn core::iter[0]::adapters[0]::{{impl}}[29]::new[0]<core::slice[0]::Iter[0]<usize>, pr_75255::foo[0]::{{closure}}[0]<T>> @@ pr_75255-cgu.0[External]\n+//~ MONO_ITEM fn core::iter[0]::traits[0]::iterator[0]::Iterator[0]::map[0]<core::slice[0]::Iter[0]<usize>, (), pr_75255::foo[0]::{{closure}}[0]<T>> @@ pr_75255-cgu.1[Internal]\n+\n+fn bar<T>() {\n+    std::iter::repeat(unused::<T>);\n+}\n+\n+//~ MONO_ITEM fn core::iter[0]::sources[0]::repeat[0]<fn() -> u64> @@ pr_75255-cgu.1[Internal]\n+\n+pub fn dispatch() {\n+    foo::<String>();\n+    foo::<Vec<String>>();\n+\n+    bar::<String>();\n+    bar::<Vec<String>>();\n+}\n+\n+// These are all the items that aren't relevant to the test.\n+//~ MONO_ITEM fn core::mem[0]::size_of[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::mem[0]::size_of[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::mem[0]::size_of[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::add[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::is_null[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::offset[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::wrapping_add[0]<u8> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::wrapping_offset[0]<u8> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::non_null[0]::{{impl}}[3]::new_unchecked[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::null[0]<u8> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::as_ptr[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::iter[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::len[0]<usize> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::dispatch[0] @@ pr_75255-cgu.1[External]\n+//~ MONO_ITEM fn pr_75255::foo[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::foo[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::bar[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n+//~ MONO_ITEM fn pr_75255::bar[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]"}, {"sha": "59c47de4129c5043f70bf684d418fa5069353b7b", "filename": "src/test/codegen/some-global-nonnull.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fcodegen%2Fsome-global-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fcodegen%2Fsome-global-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsome-global-nonnull.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,25 @@\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @test\n+// CHECK-NEXT: start:\n+// CHECK-NEXT: tail call void @ext_fn0()\n+#[no_mangle]\n+pub fn test() {\n+    test_inner(Some(inner0));\n+}\n+\n+fn test_inner(f_maybe: Option<fn()>) {\n+    if let Some(f) = f_maybe {\n+        f();\n+    }\n+}\n+\n+fn inner0() {\n+    unsafe { ext_fn0() };\n+}\n+\n+extern \"C\" {\n+    fn ext_fn0();\n+}"}, {"sha": "5f3a1eb44e4e55179eeb49b90ae3182d6198aed7", "filename": "src/test/debuginfo/function-arguments-naked.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fdebuginfo%2Ffunction-arguments-naked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fdebuginfo%2Ffunction-arguments-naked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arguments-naked.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,6 +3,9 @@\n // We have to ignore android because of this issue:\n // https://github.com/rust-lang/rust/issues/74847\n // ignore-android\n+//\n+// We need to use inline assembly, so just use one platform\n+// only-x86_64\n \n // compile-flags:-g\n \n@@ -24,6 +27,7 @@\n // lldb-command:continue\n \n \n+#![feature(asm)]\n #![feature(naked_functions)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n@@ -33,8 +37,6 @@ fn main() {\n }\n \n #[naked]\n-fn naked(x: usize, y: usize) {\n-    zzz(); // #break\n+extern \"C\" fn naked(x: usize, y: usize) {\n+    unsafe { asm!(\"ret\"); } // #break\n }\n-\n-fn zzz() { () }"}, {"sha": "e8f52deabd80917992bbe3c43ccd0defabe45f64", "filename": "src/test/debuginfo/pretty-std-collections-hash.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections-hash.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -9,35 +9,35 @@\n // cdb-check:hash_set,d [...] : { size=15 } [Type: [...]::HashSet<u64, [...]>]\n // cdb-check:    [size]           : 15 [Type: [...]]\n // cdb-check:    [capacity]       : [...]\n-// cdb-check:    [[...]] [...]    : 0 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 0 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 1 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 1 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 2 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 2 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 3 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 3 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 4 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 4 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 5 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 5 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 6 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 6 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 7 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 7 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 8 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 8 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 9 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 9 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 10 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 10 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 11 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 11 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 12 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 12 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 13 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 13 [Type: u64]\n // cdb-command: dx hash_set,d\n-// cdb-check:    [[...]] [...]    : 14 [Type: unsigned __int64]\n+// cdb-check:    [[...]] [...]    : 14 [Type: u64]\n \n // cdb-command: dx hash_map,d\n // cdb-check:hash_map,d [...] : { size=15 } [Type: [...]::HashMap<u64, u64, [...]>]"}, {"sha": "9c30e0400312adc9889242428cc402a1394a421f", "filename": "src/test/mir-opt/const-promotion-extern-static.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst-promotion-extern-static.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,7 @@\n+// ignore-endian-big\n extern \"C\" {\n     static X: i32;\n }\n-\n static Y: i32 = 42;\n \n // EMIT_MIR const_promotion_extern_static.BAR.PromoteTemps.diff"}, {"sha": "b0fcb86fcee0f25f6567ca42849cc90844f1929d", "filename": "src/test/mir-opt/const_allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,5 +1,5 @@\n+// ignore-endian-big\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n-\n static FOO: &[(Option<i32>, &[&str])] =\n     &[(None, &[]), (None, &[\"foo\", \"bar\"]), (Some(42), &[\"meh\", \"mop\", \"m\u00f6p\"])];\n "}, {"sha": "30afedffb39b3d817b0124701c56f8ede105c5a6", "filename": "src/test/mir-opt/const_allocation2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_allocation2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_allocation2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,5 +1,5 @@\n+// ignore-endian-big\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n-\n // EMIT_MIR const_allocation2.main.ConstProp.after.mir\n fn main() {\n     FOO;"}, {"sha": "ddeb32ab9a583132579c132fcb1238bd97de3504", "filename": "src/test/mir-opt/const_allocation3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_allocation3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_allocation3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation3.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,5 +1,5 @@\n+// ignore-endian-big\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n-\n // EMIT_MIR const_allocation3.main.ConstProp.after.mir\n fn main() {\n     FOO;"}, {"sha": "721766f9849710050ef7685f85478765cf600ea9", "filename": "src/test/mir-opt/const_prop/large_array_index.main.ConstProp.diff.32bit", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.32bit", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.32bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.32bit?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,85 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/large_array_index.rs:4:11: 4:11\n+      let _1: u8;                          // in scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+      let mut _2: [u8; 5000];              // in scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+      let _3: usize;                       // in scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+      let mut _4: usize;                   // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      let mut _5: bool;                    // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/large_array_index.rs:6:9: 6:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+          StorageLive(_2);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+          _2 = [const 0_u8; 5000];         // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:18: 6:22\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          StorageLive(_3);                 // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+          _3 = const 2_usize;              // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x00000002))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:30: 6:31\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x00000002)) }\n+          _4 = const 5000_usize;           // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x00001388))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:17: 6:32\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x00001388)) }\n+-         _5 = Lt(_3, _4);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+-         assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++         _5 = const true;                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++         assert(const true, \"index out of bounds: the len is {} but the index is {}\", const 5000_usize, const 2_usize) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x00001388))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00001388)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x00000002))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000002)) }\n+      }\n+  \n+      bb1: {\n+          _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+          StorageDead(_3);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          StorageDead(_2);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          _0 = const ();                   // scope 0 at $DIR/large_array_index.rs:4:11: 7:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:4:11: 7:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/large_array_index.rs:7:1: 7:2\n+          return;                          // scope 0 at $DIR/large_array_index.rs:7:2: 7:2\n+      }\n+  }\n+  "}, {"sha": "eae2ce6671cc15b5ee7283ac1e32686ffdd1e2cf", "filename": "src/test/mir-opt/const_prop/large_array_index.main.ConstProp.diff.64bit", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.64bit", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.64bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.main.ConstProp.diff.64bit?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,85 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/large_array_index.rs:4:11: 4:11\n+      let _1: u8;                          // in scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+      let mut _2: [u8; 5000];              // in scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+      let _3: usize;                       // in scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+      let mut _4: usize;                   // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      let mut _5: bool;                    // in scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/large_array_index.rs:6:9: 6:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/large_array_index.rs:6:9: 6:10\n+          StorageLive(_2);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+          _2 = [const 0_u8; 5000];         // scope 0 at $DIR/large_array_index.rs:6:17: 6:29\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:18: 6:22\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          StorageLive(_3);                 // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+          _3 = const 2_usize;              // scope 0 at $DIR/large_array_index.rs:6:30: 6:31\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x0000000000000002))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:30: 6:31\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000002)) }\n+          _4 = const 5000_usize;           // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x0000000000001388))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:6:17: 6:32\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000001388)) }\n+-         _5 = Lt(_3, _4);                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+-         assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++         _5 = const true;                 // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++         assert(const true, \"index out of bounds: the len is {} but the index is {}\", const 5000_usize, const 2_usize) -> bb1; // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x0000000000001388))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000001388)) }\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x0000000000000002))\n++                                          // mir::Constant\n++                                          // + span: $DIR/large_array_index.rs:6:17: 6:32\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000002)) }\n+      }\n+  \n+      bb1: {\n+          _1 = _2[_3];                     // scope 0 at $DIR/large_array_index.rs:6:17: 6:32\n+          StorageDead(_3);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          StorageDead(_2);                 // scope 0 at $DIR/large_array_index.rs:6:32: 6:33\n+          _0 = const ();                   // scope 0 at $DIR/large_array_index.rs:4:11: 7:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/large_array_index.rs:4:11: 7:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/large_array_index.rs:7:1: 7:2\n+          return;                          // scope 0 at $DIR/large_array_index.rs:7:2: 7:2\n+      }\n+  }\n+  "}, {"sha": "48d134376db62653edb63f3d55a29b59bb7657ca", "filename": "src/test/mir-opt/const_prop/large_array_index.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Flarge_array_index.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,7 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+\n+// EMIT_MIR large_array_index.main.ConstProp.diff\n+fn main() {\n+    // check that we don't propagate this, because it's too large\n+    let x: u8 = [0_u8; 5000][2];\n+}"}, {"sha": "6e2ee0957ab332bd88a5f7f7b270221067eacab8", "filename": "src/test/mir-opt/const_prop/mutable_variable_aggregate_mut_ref.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmutable_variable_aggregate_mut_ref.main.ConstProp.diff?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -23,15 +23,13 @@\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002a))\n                                            // mir::Constant\n--                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:18: 5:20\n-+                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:17: 5:25\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:18: 5:20\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002a)) }\n                                            // ty::Const\n                                            // + ty: i32\n                                            // + val: Value(Scalar(0x0000002b))\n                                            // mir::Constant\n--                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:22: 5:24\n-+                                          // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:17: 5:25\n+                                           // + span: $DIR/mutable_variable_aggregate_mut_ref.rs:5:22: 5:24\n                                            // + literal: Const { ty: i32, val: Value(Scalar(0x0000002b)) }\n           StorageLive(_2);                 // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:9: 6:10\n           _2 = &mut _1;                    // scope 1 at $DIR/mutable_variable_aggregate_mut_ref.rs:6:13: 6:19"}, {"sha": "57298605b18737546c5e7ee7ea3800d54a10ee3d", "filename": "src/test/mir-opt/inline/inline-into-box-place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n+// ignore-endian-big\n // ignore-wasm32-bare compiled with panic=abort by default\n // compile-flags: -Z mir-opt-level=3\n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n #![feature(box_syntax)]\n-\n // EMIT_MIR inline_into_box_place.main.Inline.diff\n fn main() {\n     let _x: Box<Vec<u32>> = box Vec::new();"}, {"sha": "ee1fec4c5c2191e7fdcefe9290176fb03454e737", "filename": "src/test/rustdoc-ui/auxiliary/extern_macros.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fextern_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fextern_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Fextern_macros.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,7 @@\n+#[macro_export]\n+macro_rules! attrs_on_struct {\n+    ( $( #[$attr:meta] )* ) => {\n+        $( #[$attr] )*\n+        pub struct ExpandedStruct;\n+    }\n+}"}, {"sha": "e0e1e061ac7dc43454f566b5ee5559d609123a84", "filename": "src/test/rustdoc-ui/doctest-output.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fdoctest-output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fdoctest-output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoctest-output.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,3 +1,5 @@\n+// edition:2018\n+// aux-build:extern_macros.rs\n // compile-flags:--test --test-args=--test-threads=1\n // normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n // check-pass\n@@ -6,10 +8,20 @@\n //! assert_eq!(1 + 1, 2);\n //! ```\n \n+extern crate extern_macros as macros;\n+\n+use macros::attrs_on_struct;\n+\n pub mod foo {\n \n     /// ```\n     /// assert_eq!(1 + 1, 2);\n     /// ```\n     pub fn bar() {}\n }\n+\n+attrs_on_struct! {\n+    /// ```\n+    /// assert!(true);\n+    /// ```\n+}"}, {"sha": "c72bd91d1dd13b5225909d02a591ea3c798257b4", "filename": "src/test/rustdoc-ui/doctest-output.stdout", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fdoctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fdoctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoctest-output.stdout?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,8 @@\n \n-running 2 tests\n-test $DIR/doctest-output.rs - (line 5) ... ok\n-test $DIR/doctest-output.rs - foo::bar (line 11) ... ok\n+running 3 tests\n+test $DIR/doctest-output.rs - (line 7) ... ok\n+test $DIR/doctest-output.rs - ExpandedStruct (line 23) ... ok\n+test $DIR/doctest-output.rs - foo::bar (line 17) ... ok\n \n-test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n+test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "1a7a2fce7a3f22afb2718df3b32777a713c1fa21", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,68 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+pub enum S {}\n+\n+macro_rules! m {\n+    () => {};\n+}\n+\n+static s: usize = 0;\n+const c: usize = 0;\n+\n+trait T {}\n+\n+/// Link to [struct@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [mod@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [union@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [trait@S]\n+//~^ ERROR incompatible link kind for `S`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [struct@T]\n+//~^ ERROR incompatible link kind for `T`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [derive@m]\n+//~^ ERROR incompatible link kind for `m`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [const@s]\n+//~^ ERROR incompatible link kind for `s`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [static@c]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [fn@c]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [c()]\n+//~^ ERROR incompatible link kind for `c`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+\n+/// Link to [const@f]\n+//~^ ERROR incompatible link kind for `f`\n+//~| NOTE this link resolved\n+//~| HELP use its disambiguator\n+pub fn f() {}"}, {"sha": "9edf838f9d88b7d6e62f32e154c82f8b48bb2d55", "filename": "src/test/rustdoc-ui/intra-links-disambiguator-mismatch.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-disambiguator-mismatch.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,95 @@\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:14:14\n+   |\n+LL | /// Link to [struct@S]\n+   |              ^^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this link resolved to an enum, which is not a struct\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:19:14\n+   |\n+LL | /// Link to [mod@S]\n+   |              ^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a module\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:24:14\n+   |\n+LL | /// Link to [union@S]\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a union\n+\n+error: incompatible link kind for `S`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:29:14\n+   |\n+LL | /// Link to [trait@S]\n+   |              ^^^^^^^ help: to link to the enum, use its disambiguator: `enum@S`\n+   |\n+   = note: this link resolved to an enum, which is not a trait\n+\n+error: incompatible link kind for `T`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:34:14\n+   |\n+LL | /// Link to [struct@T]\n+   |              ^^^^^^^^ help: to link to the trait, use its disambiguator: `trait@T`\n+   |\n+   = note: this link resolved to a trait, which is not a struct\n+\n+error: incompatible link kind for `m`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:39:14\n+   |\n+LL | /// Link to [derive@m]\n+   |              ^^^^^^^^ help: to link to the macro, use its disambiguator: `m!`\n+   |\n+   = note: this link resolved to a macro, which is not a derive macro\n+\n+error: incompatible link kind for `s`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:44:14\n+   |\n+LL | /// Link to [const@s]\n+   |              ^^^^^^^ help: to link to the static, use its disambiguator: `static@s`\n+   |\n+   = note: this link resolved to a static, which is not a constant\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:49:14\n+   |\n+LL | /// Link to [static@c]\n+   |              ^^^^^^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a static\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:54:14\n+   |\n+LL | /// Link to [fn@c]\n+   |              ^^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a function\n+\n+error: incompatible link kind for `c`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:59:14\n+   |\n+LL | /// Link to [c()]\n+   |              ^^^ help: to link to the constant, use its disambiguator: `const@c`\n+   |\n+   = note: this link resolved to a constant, which is not a function\n+\n+error: incompatible link kind for `f`\n+  --> $DIR/intra-links-disambiguator-mismatch.rs:64:14\n+   |\n+LL | /// Link to [const@f]\n+   |              ^^^^^^^ help: to link to the function, use its disambiguator: `f()`\n+   |\n+   = note: this link resolved to a function, which is not a constant\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "4f2c93379d88e88c33f3b3417a0b8054722ddae3", "filename": "src/test/rustdoc/auxiliary/elided-lifetime.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Fauxiliary%2Felided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Fauxiliary%2Felided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Felided-lifetime.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,11 @@\n+#![crate_name = \"bar\"]\n+\n+pub struct Ref<'a>(&'a u32);\n+\n+pub fn test5(a: &u32) -> Ref {\n+    Ref(a)\n+}\n+\n+pub fn test6(a: &u32) -> Ref<'_> {\n+    Ref(a)\n+}"}, {"sha": "5a32554f972b726bdc9a9343bd2d018b97324761", "filename": "src/test/rustdoc/elided-lifetime.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Felided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Felided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Felided-lifetime.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,43 @@\n+// aux-build:elided-lifetime.rs\n+//\n+// rust-lang/rust#75225\n+//\n+// Since Rust 2018 we encourage writing out <'_> explicitly to make it clear\n+// that borrowing is occuring. Make sure rustdoc is following the same idiom.\n+\n+#![crate_name = \"foo\"]\n+\n+pub struct Ref<'a>(&'a u32);\n+type ARef<'a> = Ref<'a>;\n+\n+// @has foo/fn.test1.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test1(a: &u32) -> Ref {\n+    Ref(a)\n+}\n+\n+// @has foo/fn.test2.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test2(a: &u32) -> Ref<'_> {\n+    Ref(a)\n+}\n+\n+// @has foo/fn.test3.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test3(a: &u32) -> ARef {\n+    Ref(a)\n+}\n+\n+// @has foo/fn.test4.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+pub fn test4(a: &u32) -> ARef<'_> {\n+    Ref(a)\n+}\n+\n+// Ensure external paths in inlined docs also display elided lifetime\n+// @has foo/bar/fn.test5.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+// @has foo/bar/fn.test6.html\n+// @matches - \"Ref</a>&lt;'_&gt;\"\n+#[doc(inline)]\n+pub extern crate bar;"}, {"sha": "15ea1232fd6fb826b746ac042e88eaca15aa0caa", "filename": "src/test/rustdoc/intra-link-prim-precedence.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -8,5 +8,10 @@ pub mod char {}\n pub struct MyString;\n \n /// See also [char]\n-// @has intra_link_prim_precedence/struct.MyString2.html '//a/@href' 'intra_link_prim_precedence/char/index.html'\n+// @has intra_link_prim_precedence/struct.MyString2.html '//a/@href' 'https://doc.rust-lang.org/nightly/std/primitive.char.html'\n pub struct MyString2;\n+\n+/// See also [crate::char] and [mod@char]\n+// @has intra_link_prim_precedence/struct.MyString3.html '//*[@href=\"../intra_link_prim_precedence/char/index.html\"]' 'crate::char'\n+// @has - '//*[@href=\"../intra_link_prim_precedence/char/index.html\"]' 'mod@char'\n+pub struct MyString3;"}, {"sha": "54270414c9dfe818e9ab51b5fc6c115ca6727ef8", "filename": "src/test/rustdoc/intra-link-trait-item.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-trait-item.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,12 @@\n+// ignore-tidy-linelength\n+#![deny(broken_intra_doc_links)]\n+\n+/// Link to [S::assoc_fn()]\n+/// Link to [Default::default()]\n+// @has intra_link_trait_item/struct.S.html '//*[@href=\"../intra_link_trait_item/struct.S.html#method.assoc_fn\"]' 'S::assoc_fn()'\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\"]' 'Default::default()'\n+pub struct S;\n+\n+impl S {\n+    pub fn assoc_fn() {}\n+}"}, {"sha": "736a8633dac53c24d7ee909637340847fdabcb30", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate-rpass.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -29,7 +29,7 @@ macro_rules! fake_lint_pass {\n         impl LateLintPass<'_> for $struct {\n             fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n                 $(\n-                    if !attr::contains_name(&krate.item.attrs, $attr) {\n+                    if !cx.sess().contains_name(&krate.item.attrs, $attr) {\n                         cx.lint(CRATE_NOT_OKAY, |lint| {\n                              let msg = format!(\"crate is not marked with #![{}]\", $attr);\n                              lint.build(&msg).set_span(krate.item.span).emit()"}, {"sha": "bd477b793fc709a9a986e7617b20db24f92dd60a", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -27,7 +27,7 @@ declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n \n impl<'tcx> LateLintPass<'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &rustc_hir::Crate) {\n-        if !attr::contains_name(&krate.item.attrs, Symbol::intern(\"crate_okay\")) {\n+        if !cx.sess().contains_name(&krate.item.attrs, Symbol::intern(\"crate_okay\")) {\n             cx.lint(CRATE_NOT_OKAY, |lint| {\n                 lint.build(\"crate is not marked with #![crate_okay]\")\n                     .set_span(krate.item.span)"}, {"sha": "448c57da754a0c31d374ec146834913acae39f02", "filename": "src/test/ui-fulldeps/mod_dir_path_canonicalized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmod_dir_path_canonicalized.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -19,7 +19,7 @@ use std::path::Path;\n mod gravy;\n \n pub fn main() {\n-    rustc_ast::with_default_session_globals(|| parse());\n+    rustc_span::with_default_session_globals(|| parse());\n \n     assert_eq!(gravy::foo(), 10);\n }"}, {"sha": "f0e3ab308e9177eff2fff072982ff329ad978dea", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -208,7 +208,7 @@ impl MutVisitor for AddParens {\n }\n \n fn main() {\n-    rustc_ast::with_default_session_globals(|| run());\n+    rustc_span::with_default_session_globals(|| run());\n }\n \n fn run() {"}, {"sha": "1d21ae8df24fa044971f28b775930c044e03c3cb", "filename": "src/test/ui/asm/bad-arch.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fasm%2Fbad-arch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fasm%2Fbad-arch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-arch.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: --target wasm32-unknown-unknown\n+// needs-llvm-components: webassembly\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+fn main() {\n+    unsafe {\n+        asm!(\"\");\n+        //~^ ERROR asm! is unsupported on this target\n+    }\n+}"}, {"sha": "cb876f28650aaa7600feff0542033e9b4b94d87e", "filename": "src/test/ui/asm/bad-arch.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fasm%2Fbad-arch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fasm%2Fbad-arch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fbad-arch.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,8 @@\n+error[E0472]: asm! is unsupported on this target\n+  --> $DIR/bad-arch.rs:16:9\n+   |\n+LL |         asm!(\"\");\n+   |         ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "fda825bc65e8080cda0417d2b80dc11415232335", "filename": "src/test/ui/btreemap/btreemap_into_iterator_lifetime.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_into_iterator_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_into_iterator_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap_into_iterator_lifetime.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+use std::collections::{BTreeMap, HashMap};\n+\n+trait Map\n+where\n+    for<'a> &'a Self: IntoIterator<Item = (&'a Self::Key, &'a Self::Value)>,\n+{\n+    type Key;\n+    type Value;\n+}\n+\n+impl<K, V> Map for HashMap<K, V> {\n+    type Key = K;\n+    type Value = V;\n+}\n+\n+impl<K, V> Map for BTreeMap<K, V> {\n+  type Key = K;\n+  type Value = V;\n+}\n+\n+fn main() {}"}, {"sha": "d53a4ac2d4c2359eb159565125c6bc2f88c1b6e6", "filename": "src/test/ui/const-generics/const-param-in-trait-ungated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-in-trait-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-in-trait-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-in-trait-ungated.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,8 +4,8 @@ error[E0658]: const generics are unstable\n LL | trait Trait<const T: ()> {}\n    |                   ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "5d379ff083ca70642f5ee8925f068e5a84c5fbb0", "filename": "src/test/ui/const-generics/const-param-type-depends-on-type-param-ungated.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-type-param-ungated.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -10,8 +10,8 @@ error[E0658]: const generics are unstable\n LL | struct B<T, const N: T>(PhantomData<[T; N]>);\n    |                   ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c51028d5b2001e96ef6c4c593f0aec737c2d0d93", "filename": "src/test/ui/const-generics/defaults/wrong-order.full.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,16 +1,16 @@\n error: type parameters with a default must be trailing\n-  --> $DIR/wrong-order.rs:3:10\n+  --> $DIR/wrong-order.rs:5:10\n    |\n LL | struct A<T = u32, const N: usize> {\n    |          ^\n    |\n    = note: using type defaults and const parameters in the same parameter list is currently not permitted\n \n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/wrong-order.rs:1:12\n+  --> $DIR/wrong-order.rs:2:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information", "previous_filename": "src/test/ui/const-generics/defaults/wrong-order.stderr"}, {"sha": "29a46367004d44b3a6185858f5d5a5f0069d38ee", "filename": "src/test/ui/const-generics/defaults/wrong-order.min.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.min.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,10 @@\n+error: type parameters with a default must be trailing\n+  --> $DIR/wrong-order.rs:5:10\n+   |\n+LL | struct A<T = u32, const N: usize> {\n+   |          ^\n+   |\n+   = note: using type defaults and const parameters in the same parameter list is currently not permitted\n+\n+error: aborting due to previous error\n+"}, {"sha": "cb36d456f3887de7f91e2c6c629649fb7b06b716", "filename": "src/test/ui/const-generics/defaults/wrong-order.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwrong-order.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,6 @@\n-#![feature(const_generics)] //~ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n struct A<T = u32, const N: usize> {\n     //~^ ERROR type parameters with a default must be trailing"}, {"sha": "d853ec5015ed268cddfa0c44a79d1967e768ef0a", "filename": "src/test/ui/const-generics/issues/issue-56445.full.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-56445.rs:3:12\n+  --> $DIR/issue-56445.rs:3:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information", "previous_filename": "src/test/ui/const-generics/issues/issue-56445.stderr"}, {"sha": "ca35ee5b2905d216e26ad1ea6ff406e29c77487c", "filename": "src/test/ui/const-generics/issues/issue-56445.min.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.min.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,20 @@\n+error[E0771]: use of non-static lifetime `'a` in const generic\n+  --> $DIR/issue-56445.rs:9:26\n+   |\n+LL | struct Bug<'a, const S: &'a str>(PhantomData<&'a ()>);\n+   |                          ^^\n+   |\n+   = note: for more information, see issue #74052 <https://github.com/rust-lang/rust/issues/74052>\n+\n+error: using `&'static str` as const generic parameters is forbidden\n+  --> $DIR/issue-56445.rs:9:25\n+   |\n+LL | struct Bug<'a, const S: &'a str>(PhantomData<&'a ()>);\n+   |                         ^^^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0771`."}, {"sha": "174eb16abfc5f44755243dce1a80cc719f0ee140", "filename": "src/test/ui/const-generics/issues/issue-56445.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,12 +1,13 @@\n // Regression test for https://github.com/rust-lang/rust/issues/56445#issuecomment-518402995.\n-\n-#![feature(const_generics)]\n-//~^ WARN: the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n #![crate_type = \"lib\"]\n \n use std::marker::PhantomData;\n \n struct Bug<'a, const S: &'a str>(PhantomData<&'a ()>);\n //~^ ERROR: use of non-static lifetime `'a` in const generic\n+//[min]~| ERROR: using `&'static str` as const\n \n impl Bug<'_, \"\"> {}"}, {"sha": "aeef296f38526eeff33552629e820df374fcfa1c", "filename": "src/test/ui/const-generics/issues/issue-60263.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60263.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60263.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60263.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,8 +4,8 @@ error[E0658]: const generics are unstable\n LL | struct B<const I: u8>;\n    |                ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error: aborting due to previous error\n "}, {"sha": "c03b7252a3c8530895ac946e0fb03026dab57ada", "filename": "src/test/ui/const-generics/issues/issue-60818-struct-constructors.full.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60818-struct-constructors.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60818-struct-constructors.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60818-struct-constructors.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61336-1.rs:1:12\n+  --> $DIR/issue-60818-struct-constructors.rs:3:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information", "previous_filename": "src/test/ui/const-generics/issues/issue-61336-1.stderr"}, {"sha": "ae2b0520fb1c1ee47885195a2120fcb9c2f930b6", "filename": "src/test/ui/const-generics/issues/issue-60818-struct-constructors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60818-struct-constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60818-struct-constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-60818-struct-constructors.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,7 @@\n // check-pass\n-\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n struct Generic<const V: usize>;\n "}, {"sha": "f18728eabbb437b7dca909166d01f1197f109da8", "filename": "src/test/ui/const-generics/issues/issue-61336-1.full.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-60818-struct-constructors.rs:3:12\n+  --> $DIR/issue-61336-1.rs:3:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information", "previous_filename": "src/test/ui/const-generics/issues/issue-60818-struct-constructors.stderr"}, {"sha": "201c0d039d98f3dab979ece6c25def3d44a86586", "filename": "src/test/ui/const-generics/issues/issue-61336-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,7 @@\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n-\n // build-pass\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]"}, {"sha": "d21cd9df054c1ec9b8a8c2e89a30a55f293da705", "filename": "src/test/ui/const-generics/issues/issue-61336-2.full.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,14 +1,14 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61336-2.rs:1:12\n+  --> $DIR/issue-61336-2.rs:2:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n-  --> $DIR/issue-61336-2.rs:9:5\n+  --> $DIR/issue-61336-2.rs:10:5\n    |\n LL |     [x; { N }]\n    |     ^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`", "previous_filename": "src/test/ui/const-generics/issues/issue-61336-2.stderr"}, {"sha": "29ab7b1305e38659ba16d228d1bd788cc16dd0ab", "filename": "src/test/ui/const-generics/issues/issue-61336-2.min.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.min.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336-2.rs:10:5\n+   |\n+LL |     [x; { N }]\n+   |     ^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn g<T: std::marker::Copy, const N: usize>(x: T) -> [T; N] {\n+   |       ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "25b9271105e245c9a58a0862427c0df9fcb272ca", "filename": "src/test/ui/const-generics/issues/issue-61336-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,5 +1,6 @@\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; { N }]"}, {"sha": "d1b5d5eb9417f9ed0be93e12a1291b364b7c1ffe", "filename": "src/test/ui/const-generics/issues/issue-61336.full.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,24 @@\n+warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/issue-61336.rs:2:27\n+   |\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336.rs:10:5\n+   |\n+LL |     [x; N]\n+   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn g<T: std::marker::Copy, const N: usize>(x: T) -> [T; N] {\n+   |       ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "bced8bbd82ff6df7b758babec1dc6a335c75c335", "filename": "src/test/ui/const-generics/issues/issue-61336.min.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.min.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336.rs:10:5\n+   |\n+LL |     [x; N]\n+   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = note: the `Copy` trait is required because the repeated element will be copied\n+help: consider restricting type parameter `T`\n+   |\n+LL | fn g<T: std::marker::Copy, const N: usize>(x: T) -> [T; N] {\n+   |       ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "fb55542a1c9931dc5b89d6b66a82c5bd79cd5091", "filename": "src/test/ui/const-generics/issues/issue-61336.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,5 +1,6 @@\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]"}, {"sha": "ac6c378295d3144ed85071ddbfe38412be0ce3a1", "filename": "src/test/ui/const-generics/issues/issue-61422.full.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61432.rs:3:12\n+  --> $DIR/issue-61422.rs:3:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information", "previous_filename": "src/test/ui/const-generics/issues/issue-61432.stderr"}, {"sha": "649f8b4255b1216adb4d4f5461c4998fe86b9c7c", "filename": "src/test/ui/const-generics/issues/issue-61422.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61422.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,7 @@\n // check-pass\n-\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n use std::mem;\n "}, {"sha": "82b36de45a2aac033883f54ee5e33b87b3dbc3bd", "filename": "src/test/ui/const-generics/issues/issue-61432.full.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61432.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61432.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61432.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,8 +1,8 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61422.rs:3:12\n+  --> $DIR/issue-61432.rs:3:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information", "previous_filename": "src/test/ui/const-generics/issues/issue-61422.stderr"}, {"sha": "91a4794099c073bd463cc52e84678bceeb5abac8", "filename": "src/test/ui/const-generics/issues/issue-61432.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61432.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n-\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n fn promote<const N: i32>() {\n     // works:"}, {"sha": "3ccce5675fcba19aee39f1382e20152a44d4dc71", "filename": "src/test/ui/const-generics/issues/issue-61747.full.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.full.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,14 +1,14 @@\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-61747.rs:1:12\n+  --> $DIR/issue-61747.rs:2:27\n    |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n+LL | #![cfg_attr(full, feature(const_generics))]\n+   |                           ^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n    = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n \n error: constant expression depends on a generic parameter\n-  --> $DIR/issue-61747.rs:7:23\n+  --> $DIR/issue-61747.rs:8:23\n    |\n LL |     fn successor() -> Const<{C + 1}> {\n    |                       ^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/const-generics/issues/issue-61747.stderr"}, {"sha": "2061b6c55bb7b2a67677ace3402e07b559a17506", "filename": "src/test/ui/const-generics/issues/issue-61747.min.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.min.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,10 @@\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/issue-61747.rs:8:30\n+   |\n+LL |     fn successor() -> Const<{C + 1}> {\n+   |                              ^ non-trivial anonymous constants must not depend on the parameter `C`\n+   |\n+   = help: it is currently only allowed to use either `C` or `{ C }` as generic constants\n+\n+error: aborting due to previous error\n+"}, {"sha": "4e5cde17f39a963a9ccd7b68f5d6b6059174ab5d", "filename": "src/test/ui/const-generics/issues/issue-61747.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,11 +1,13 @@\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))] //[full]~WARN the feature `const_generics` is incomplete\n+#![cfg_attr(min, feature(min_const_generics))]\n \n struct Const<const N: usize>;\n \n impl<const C: usize> Const<{C}> {\n     fn successor() -> Const<{C + 1}> {\n-        //~^ ERROR constant expression depends on a generic parameter\n+        //[full]~^ ERROR constant expression depends on a generic parameter\n+        //[min]~^^ ERROR generic parameters must not be used\n         Const\n     }\n }"}, {"sha": "fa75613d9ddc1d621394e259ee308dd9e6be4b53", "filename": "src/test/ui/const-generics/min_const_generics/assoc_const.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fassoc_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fassoc_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fassoc_const.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+#![feature(min_const_generics)]\n+\n+struct Foo<const N: usize>;\n+\n+impl<const N: usize> Foo<N> {\n+    const VALUE: usize = N * 2;\n+}\n+\n+trait Bar {\n+    const ASSOC: usize;\n+}\n+\n+impl<const N: usize> Bar for Foo<N> {\n+    const ASSOC: usize = N * 3;\n+}\n+\n+fn main() {}"}, {"sha": "f9cb0d2829d6ea84e8f5630cd12335710be16aaa", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,29 @@\n+#![feature(min_const_generics)]\n+\n+fn test<const N: usize>() {}\n+\n+fn ok<const M: usize>() -> [u8; M] {\n+    [0; { M }]\n+}\n+\n+struct Break0<const N: usize>([u8; { N + 1 }]);\n+//~^ ERROR generic parameters must not be used inside of non trivial constant values\n+\n+struct Break1<const N: usize>([u8; { { N } }]);\n+//~^ ERROR generic parameters must not be used inside of non trivial constant values\n+\n+fn break2<const N: usize>() {\n+    let _: [u8; N + 1];\n+    //~^ ERROR generic parameters must not be used inside of non trivial constant values\n+}\n+\n+fn break3<const N: usize>() {\n+    let _ = [0; N + 1];\n+    //~^ ERROR generic parameters must not be used inside of non trivial constant values\n+}\n+\n+trait Foo {\n+    const ASSOC: usize;\n+}\n+\n+fn main() {}"}, {"sha": "baed8d13f00f1f6d2c934df21f30799f4757ca06", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,34 @@\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/complex-expression.rs:9:38\n+   |\n+LL | struct Break0<const N: usize>([u8; { N + 1 }]);\n+   |                                      ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/complex-expression.rs:12:40\n+   |\n+LL | struct Break1<const N: usize>([u8; { { N } }]);\n+   |                                        ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/complex-expression.rs:16:17\n+   |\n+LL |     let _: [u8; N + 1];\n+   |                 ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: generic parameters must not be used inside of non trivial constant values\n+  --> $DIR/complex-expression.rs:21:17\n+   |\n+LL |     let _ = [0; N + 1];\n+   |                 ^ non-trivial anonymous constants must not depend on the parameter `N`\n+   |\n+   = help: it is currently only allowed to use either `N` or `{ N }` as generic constants\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a396fa83aa629c014070723fb3ae32c37bca3815", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,18 @@\n+#![feature(min_const_generics)]\n+\n+struct Foo<const N: [u8; 0]>;\n+//~^ ERROR using `[u8; 0]` as const generic parameters is forbidden\n+\n+struct Bar<const N: ()>;\n+//~^ ERROR using `()` as const generic parameters is forbidden\n+\n+#[derive(PartialEq, Eq)]\n+struct No;\n+\n+struct Fez<const N: No>;\n+//~^ ERROR using `No` as const generic parameters is forbidden\n+\n+struct Faz<const N: &'static u8>;\n+//~^ ERROR using `&'static u8` as const generic parameters is forbidden\n+\n+fn main() {}"}, {"sha": "835b1f1a3e8675aba34724349605ed824d3b8f4c", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,38 @@\n+error: using `[u8; 0]` as const generic parameters is forbidden\n+  --> $DIR/complex-types.rs:3:21\n+   |\n+LL | struct Foo<const N: [u8; 0]>;\n+   |                     ^^^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: using `()` as const generic parameters is forbidden\n+  --> $DIR/complex-types.rs:6:21\n+   |\n+LL | struct Bar<const N: ()>;\n+   |                     ^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: using `No` as const generic parameters is forbidden\n+  --> $DIR/complex-types.rs:12:21\n+   |\n+LL | struct Fez<const N: No>;\n+   |                     ^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: using `&'static u8` as const generic parameters is forbidden\n+  --> $DIR/complex-types.rs:15:21\n+   |\n+LL | struct Faz<const N: &'static u8>;\n+   |                     ^^^^^^^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "423deae4600836407185614dc3498d1cbef99f30", "filename": "src/test/ui/const-generics/min_const_generics/feature-gate-min_const_generics.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ffeature-gate-min_const_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ffeature-gate-min_const_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ffeature-gate-min_const_generics.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,4 @@\n+fn test<const N: usize>() {}\n+//~^ ERROR const generics are unstable\n+\n+fn main() {}"}, {"sha": "7f82a960da2553dcfc9c6c87d34debad76fcef17", "filename": "src/test/ui/const-generics/min_const_generics/feature-gate-min_const_generics.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ffeature-gate-min_const_generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ffeature-gate-min_const_generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ffeature-gate-min_const_generics.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: const generics are unstable\n+  --> $DIR/feature-gate-min_const_generics.rs:1:15\n+   |\n+LL | fn test<const N: usize>() {}\n+   |               ^\n+   |\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "3ccdd472613728351b030ba9bff54bce1f3aa9a8", "filename": "src/test/ui/const-generics/type-dependent/const-arg-in-const-arg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fconst-arg-in-const-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fconst-arg-in-const-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fconst-arg-in-const-arg.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,7 +1,8 @@\n // run-pass\n-#![feature(const_generics)]\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(min, feature(min_const_generics))]\n #![allow(incomplete_features)]\n-#![feature(const_fn)]\n \n struct Foo;\n "}, {"sha": "59f04372fff19218f45d30c178dde71c9349c31e", "filename": "src/test/ui/feature-gates/feature-gate-asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-// ignore-emscripten\n+// only-x86_64\n \n fn main() {\n     unsafe {"}, {"sha": "aa63aff1c5e3384a3c80d65bf102211d1f45a173", "filename": "src/test/ui/feature-gates/feature-gate-asm2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-asm2.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -1,4 +1,4 @@\n-// ignore-emscripten\n+// only-x86_64\n \n fn main() {\n     unsafe {"}, {"sha": "eef465318a390665f2a781ff2ebcf95c863039f3", "filename": "src/test/ui/feature-gates/feature-gate-const_generics-ptr.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics-ptr.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,17 +4,17 @@ error[E0658]: const generics are unstable\n LL | struct ConstFn<const F: fn()>;\n    |                      ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error[E0658]: const generics are unstable\n   --> $DIR/feature-gate-const_generics-ptr.rs:5:23\n    |\n LL | struct ConstPtr<const P: *const u32>;\n    |                       ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error: using function pointers as const generic parameters is forbidden\n   --> $DIR/feature-gate-const_generics-ptr.rs:1:25"}, {"sha": "f80362252f9236cfb09ea62ad58fd65124c9dfe5", "filename": "src/test/ui/feature-gates/feature-gate-const_generics.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-const_generics.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -4,17 +4,17 @@ error[E0658]: const generics are unstable\n LL | fn foo<const X: ()>() {}\n    |              ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error[E0658]: const generics are unstable\n   --> $DIR/feature-gate-const_generics.rs:3:18\n    |\n LL | struct Foo<const X: usize>([(); X]);\n    |                  ^\n    |\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-   = help: add `#![feature(const_generics)]` to the crate attributes to enable\n+   = note: see issue #74878 <https://github.com/rust-lang/rust/issues/74878> for more information\n+   = help: add `#![feature(min_const_generics)]` to the crate attributes to enable\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1e1241c7f83c54c767a4e2b5422ad0f5e1ff0bee", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for #59311. The test is taken from\n+// rust-lang/rust/issues/71546#issuecomment-620638437\n+// as they seem to have the same cause.\n+\n+// FIXME: It's not clear that this code ought to report\n+// an error, but the regression test is here to ensure\n+// that it does not ICE. See discussion on #74889 for details.\n+\n+pub trait T {\n+    fn t<F: Fn()>(&self, _: F) {}\n+}\n+\n+pub fn crash<V>(v: &V)\n+where\n+    for<'a> &'a V: T + 'static,\n+{\n+    v.t(|| {}); //~ ERROR: higher-ranked subtype error\n+}\n+\n+fn main() {}"}, {"sha": "ca6326292672bad2768752986330e77f4ec7c219", "filename": "src/test/ui/higher-rank-trait-bounds/issue-59311.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhigher-rank-trait-bounds%2Fissue-59311.stderr?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/issue-59311.rs:17:9\n+   |\n+LL |     v.t(|| {});\n+   |         ^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "305a9c3292a4cc5e61d4df6d2da86c7cc2d77d0f", "filename": "src/test/ui/issues/issue-40782.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fissues%2Fissue-40782.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fissues%2Fissue-40782.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40782.fixed?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,4 +3,6 @@\n fn main() {\n     for _i in 0..2 { //~ ERROR missing `in`\n     }\n+    for _i in 0..2 { //~ ERROR missing `in`\n+    }\n }"}, {"sha": "43460ec1535ce44b85b9157acfa70ac563801109", "filename": "src/test/ui/issues/issue-40782.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fissues%2Fissue-40782.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b/src%2Ftest%2Fui%2Fissues%2Fissue-40782.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40782.rs?ref=7c4ef37e19c0f9f501c04dd7bb1d5b864f0b6a2b", "patch": "@@ -3,4 +3,6 @@\n fn main() {\n     for _i 0..2 { //~ ERROR missing `in`\n     }\n+    for _i of 0..2 { //~ ERROR missing `in`\n+    }\n }"}]}