{"sha": "4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiOWQ4MDMyNWE2NWIwMzc1ZWVhNTI2NDA5YTBmM2FhZjFjYmMyM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-28T23:07:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-28T23:07:19Z"}, "message": "Auto merge of #61296 - Centril:rollup-5ad68b0, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #60742 (Allow const parameters in array sizes to be unified)\n - #60756 (Add better tests for hidden lifetimes in impl trait)\n - #60928 (Changes the type `mir::Mir` into `mir::Body`)\n - #61024 (tests: Centralize proc macros commonly used for testing)\n - #61157 (BufReader: In Seek impl, remove extra discard_buffer call)\n - #61195 (Special-case `.llvm` in mangler)\n - #61202 (Print PermissionExt::mode() in octal in Documentation Examples)\n - #61259 (Mailmap fixes)\n - #61273 (mention that MaybeUninit is a bit like Option)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "eed0f81053a76faca4275c4fba888362e2ea8896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eed0f81053a76faca4275c4fba888362e2ea8896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "html_url": "https://github.com/rust-lang/rust/commit/4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "721268583759224d0f6476e0b8b196cc8afbdea0", "url": "https://api.github.com/repos/rust-lang/rust/commits/721268583759224d0f6476e0b8b196cc8afbdea0", "html_url": "https://github.com/rust-lang/rust/commit/721268583759224d0f6476e0b8b196cc8afbdea0"}, {"sha": "9121a73ab1d474d5cdba44b566c782eb2581e60b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9121a73ab1d474d5cdba44b566c782eb2581e60b", "html_url": "https://github.com/rust-lang/rust/commit/9121a73ab1d474d5cdba44b566c782eb2581e60b"}], "stats": {"total": 2882, "additions": 1573, "deletions": 1309}, "files": [{"sha": "679aa55d314585e447c68c07e8c3fa011cdd45c8", "filename": ".mailmap", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,8 +5,8 @@\n # email addresses.\n #\n \n-Aaron Todd <github@opprobrio.us>\n Aaron Power <theaaronepower@gmail.com> Erin Power <xampprocky@gmail.com>\n+Aaron Todd <github@opprobrio.us>\n Abhishek Chanda <abhishek.becs@gmail.com> Abhishek Chanda <abhishek@cloudscaling.com>\n Adolfo Ochagav\u00eda <aochagavia92@gmail.com>\n Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n@@ -29,8 +29,8 @@ Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> Ariel Ben-Yehuda <ariel.byd@gmail.com>\n Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> arielb1 <arielb1@mail.tau.ac.il>\n Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n Aydin Kim <ladinjin@hanmail.net> aydin.kim <aydin.kim@samsung.com>\n-Bastian Kauschke <bastian_kauschke@hotmail.de>\n Barosl Lee <vcs@barosl.com> Barosl LEE <github@barosl.com>\n+Bastian Kauschke <bastian_kauschke@hotmail.de>\n Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@bsago.me>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@users.noreply.github.com>\n@@ -46,22 +46,23 @@ Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n-Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n Christian Poveda <christianpoveda@protonmail.com> <cn.poveda.ruiz@gmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n Cyryl P\u0142otnicki <cyplo@cyplo.net>\n Damien Schoof <damien.schoof@gmail.com>\n-Daniel Ramos <dan@daramos.com>\n Daniel J Rollins <drollins@financialforce.com>\n+Daniel Ramos <dan@daramos.com>\n David Klein <david.klein@baesystemsdetica.com>\n David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n@@ -70,18 +71,18 @@ Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n E. Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>\n+Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n-Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n Eric Holmes <eric@ejholmes.net>\n Eric Reed <ecreed@cs.washington.edu> <ereed@mozilla.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com> <etryzelaar@iqt.org>\n-Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <esteban@commure.com>\n+Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <github@kuber.com.ar>\n Evgeny Sologubov\n Falco Hirschenberger <falco.hirschenberger@gmail.com> <hirschen@itwm.fhg.de>\n@@ -102,9 +103,9 @@ Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtk\n Ilyong Cho <ilyoan@gmail.com>\n Ivan Ivaschenko <defuz.net@gmail.com>\n J. J. Weber <jjweber@gmail.com>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub@jakub.cc>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakubw@jakubw.net>\n-Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>\n@@ -119,6 +120,7 @@ Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n Jihyun Yu <j.yu@navercorp.com> Jihyun Yu <jihyun@nclab.kaist.ac.kr>\n+Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n Johann Hofmann <git@johann-hofmann.com> Johann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n@@ -129,7 +131,8 @@ Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n Jonathan Turner <probata@hotmail.com>\n Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n Joseph Martin <pythoner6@gmail.com>\n-Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n+Joseph T. Lyons <JosephTLyons@gmail.com> <josephtlyons@gmail.com>\n+Joseph T. Lyons <JosephTLyons@gmail.com> <JosephTLyons@users.noreply.github.com>\n Junyoung Cho <june0.cho@samsung.com>\n Jyun-Yan You <jyyou.tw@gmail.com> <jyyou@cs.nctu.edu.tw>\n Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n@@ -145,8 +148,6 @@ Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>\n Luqman Aden <me@luqman.ca> <laden@csclub.uwaterloo.ca>\n Luqman Aden <me@luqman.ca> <laden@mozilla.com>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Marcell Pardavi <marcell.pardavi@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n Mark Rousskov <mark.simulacrum@gmail.com>\n@@ -167,12 +168,14 @@ Michael Woerister <michaelwoerister@posteo> <michaelwoerister@gmail>\n Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com> m-r-r <raybaudroigm@gmail.com>\n Ms2ger <ms2ger@gmail.com> <Ms2ger@gmail.com>\n Mukilan Thiagarajan <mukilanthiagarajan@gmail.com>\n+NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n+NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Nathan West <Lucretiel@gmail.com> <lucretiel@gmail.com>\n Nathan Wilson <wilnathan@gmail.com>\n Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.harvard.edu>\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n-Nicole Mazzuca <npmazzuca@gmail.com>\n Nick Platt <platt.nicholas@gmail.com>\n+Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>\n Oliver Schneider <oliver.schneider@kit.edu> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n@@ -230,8 +233,8 @@ Tim JIANG <p90eri@gmail.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n Ty Overby <ty@pre-alpha.com>\n-Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com>\n+Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>\n Ulrik Sverdrup <bluss@users.noreply.github.com> Ulrik Sverdrup <root@localhost>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com> petrochenkov <vadim.petrochenkov@gmail.com>"}, {"sha": "40f4354213b40849bf253c7d1bb10bab04a86761", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -966,6 +966,9 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n ///\n /// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n ///\n+/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n+/// any of the run-time tracking and without any of the safety checks.\n+///\n /// ## out-pointers\n ///\n /// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data"}, {"sha": "f87c6977f33d0261ea99cd3339b5184aa5c4a1ad", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -652,7 +652,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         for sp in prior_arms {\n                             err.span_label(*sp, format!(\n                                 \"this is found to be of type `{}`\",\n-                                self.resolve_type_vars_if_possible(&last_ty),\n+                                self.resolve_vars_if_possible(&last_ty),\n                             ));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {\n@@ -1278,7 +1278,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }\n@@ -1291,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>,\n     ) -> Option<(DiagnosticStyledString, DiagnosticStyledString)> {\n-        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        let exp_found = self.resolve_vars_if_possible(exp_found);\n         if exp_found.references_error() {\n             return None;\n         }"}, {"sha": "972ffbe1820a5569ee59ae336b4f89652e4dcce2", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n         });\n         match ty_opt {\n             Some(ty) => {\n-                let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                let ty = self.infcx.resolve_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n                         (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n@@ -94,7 +94,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>\n     ) -> DiagnosticBuilder<'gcx> {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err_span = span;\n@@ -166,7 +166,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         ty: Ty<'tcx>\n     ) -> DiagnosticBuilder<'gcx> {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n         let mut err = struct_span_err!(self.tcx.sess,"}, {"sha": "1dd391950254dd55db1ea4b198d84138489ef6f7", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -210,11 +210,11 @@ impl NiceRegionError<'me, 'gcx, 'tcx> {\n             _ => (),\n         }\n \n-        let expected_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n+        let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: expected_substs,\n         });\n-        let actual_trait_ref = self.infcx.resolve_type_vars_if_possible(&ty::TraitRef {\n+        let actual_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n             substs: actual_substs,\n         });"}, {"sha": "7461d8bc72860ec7ffbe44a23004bf1d0c84095c", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let (mut fudger, value) = self.probe(|snapshot| {\n             match f() {\n                 Ok(value) => {\n-                    let value = self.resolve_type_vars_if_possible(&value);\n+                    let value = self.resolve_vars_if_possible(&value);\n \n                     // At this point, `value` could in principle refer\n                     // to inference variables that have been created during"}, {"sha": "a4a7efdbc9e3e204d9687b9afeffba6b46dae0fa", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1174,7 +1174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Process the region constraints and report any errors that\n     /// result. After this, no more unification operations should be\n     /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_type_vars_if_possible` as well as `fully_resolve`.\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n     pub fn resolve_regions_and_report_errors(\n         &self,\n         region_context: DefId,\n@@ -1262,7 +1262,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(&t).to_string()\n+        self.resolve_vars_if_possible(&t).to_string()\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -1271,7 +1271,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_type_vars_if_possible(t).to_string()\n+        self.resolve_vars_if_possible(t).to_string()\n     }\n \n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n@@ -1297,28 +1297,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.type_variables.borrow_mut().root_var(var)\n     }\n \n-    /// Where possible, replaces type/int/float variables in\n+    /// Where possible, replaces type/const variables in\n     /// `value` with their final value. Note that region variables\n-    /// are unaffected. If a type variable has not been unified, it\n+    /// are unaffected. If a type/const variable has not been unified, it\n     /// is left as is. This is an idempotent operation that does\n     /// not affect inference state in any way and so you can do it\n     /// at will.\n-    pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n             return value.clone(); // avoid duplicated subst-folding\n         }\n-        let mut r = resolve::OpportunisticTypeResolver::new(self);\n+        let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n     /// Returns first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n-    /// `resolve_type_vars_if_possible()`.\n+    /// `resolve_vars_if_possible()`.\n     pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -1389,7 +1389,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     where\n         M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n-        let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n+        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is `Error`.\n@@ -1446,7 +1446,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         span: Span,\n     ) -> bool {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n \n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only."}, {"sha": "220b7b5fa67feeb45eb52358ab561c00929e6a59", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let concrete_ty = self.resolve_type_vars_if_possible(&opaque_defn.concrete_ty);\n+        let concrete_ty = self.resolve_vars_if_possible(&opaque_defn.concrete_ty);\n \n         debug!(\"constrain_opaque_type: concrete_ty={:?}\", concrete_ty);\n "}, {"sha": "3e626999200fea98900e671761c1feea6d703efc", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         debug!(\"add_implied_bounds()\");\n \n         for &ty in fn_sig_tys {\n-            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            let ty = infcx.resolve_vars_if_possible(&ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n             let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n             self.add_outlives_bounds(Some(infcx), implied_bounds)"}, {"sha": "90b3be213854c93e0b0059f24e323c2c40569409", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -177,7 +177,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 sup_type, sub_region, origin\n             );\n \n-            let sup_type = self.resolve_type_vars_if_possible(&sup_type);\n+            let sup_type = self.resolve_vars_if_possible(&sup_type);\n \n             if let Some(region_bound_pairs) = region_bound_pairs_map.get(&body_id) {\n                 let outlives = &mut TypeOutlives::new(\n@@ -215,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             implicit_region_bound,\n             param_env,\n         );\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let ty = self.resolve_vars_if_possible(&ty);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n }"}, {"sha": "95bae8f2bd1afb7b4326f18be4ecf1dd3f4f296e", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,28 +1,28 @@\n use super::{InferCtxt, FixupError, FixupResult, Span, type_variable::TypeVariableOrigin};\n use crate::mir::interpret::ConstValue;\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable, InferConst};\n+use crate::ty::{self, Ty, Const, TyCtxt, TypeFoldable, InferConst, TypeFlags};\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n \n ///////////////////////////////////////////////////////////////////////////\n-// OPPORTUNISTIC TYPE RESOLVER\n+// OPPORTUNISTIC VAR RESOLVER\n \n-/// The opportunistic type resolver can be used at any time. It simply replaces\n-/// type variables that have been unified with the things they have\n+/// The opportunistic resolver can be used at any time. It simply replaces\n+/// type/const variables that have been unified with the things they have\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct OpportunisticVarResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        OpportunisticTypeResolver { infcx }\n+        OpportunisticVarResolver { infcx }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticVarResolver<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n@@ -31,8 +31,17 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeResolver<'a, 'g\n         if !t.has_infer_types() {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n         } else {\n-            let t0 = self.infcx.shallow_resolve(t);\n-            t0.super_fold_with(self)\n+            let t = self.infcx.shallow_resolve(t);\n+            t.super_fold_with(self)\n+        }\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx Const<'tcx>) -> &'tcx Const<'tcx> {\n+        if !ct.has_type_flags(TypeFlags::HAS_CT_INFER) {\n+            ct // micro-optimize -- if there is nothing in this const that this fold affects...\n+        } else {\n+            let ct = self.infcx.shallow_resolve(ct);\n+            ct.super_fold_with(self)\n         }\n     }\n }"}, {"sha": "8d7c6f18a854f23913db941643cdeabcdd977a70", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -458,10 +458,10 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             .unwrap_or(true)\n     }\n \n-    fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+    fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.infcx.map(|infcx| infcx.resolve_type_vars_if_possible(value))\n+        self.infcx.map(|infcx| infcx.resolve_vars_if_possible(value))\n             .unwrap_or_else(|| value.clone())\n     }\n \n@@ -475,7 +475,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                   -> McResult<Ty<'tcx>> {\n         match ty {\n             Some(ty) => {\n-                let ty = self.resolve_type_vars_if_possible(&ty);\n+                let ty = self.resolve_vars_if_possible(&ty);\n                 if ty.references_error() || ty.is_ty_var() {\n                     debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n                     Err(())\n@@ -602,7 +602,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         where F: FnOnce() -> McResult<cmt_<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.resolve_type_vars_if_possible(&adjustment.target);\n+        let target = self.resolve_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar."}, {"sha": "007013f8f8287f108d93e6a55fbf42c6ccf7a117", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::sync::{RwLock, MappedReadGuard, ReadGuard};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use crate::ich::StableHashingContext;\n-use crate::mir::{Mir, BasicBlock};\n+use crate::mir::{Body, BasicBlock};\n \n use crate::rustc_serialize as serialize;\n \n@@ -47,7 +47,7 @@ impl Cache {\n \n     pub fn predecessors(\n         &self,\n-        mir: &Mir<'_>\n+        mir: &Body<'_>\n     ) -> MappedReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n         if self.predecessors.borrow().is_none() {\n             *self.predecessors.borrow_mut() = Some(calculate_predecessors(mir));\n@@ -57,7 +57,7 @@ impl Cache {\n     }\n }\n \n-fn calculate_predecessors(mir: &Mir<'_>) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n+fn calculate_predecessors(mir: &Body<'_>) -> IndexVec<BasicBlock, Vec<BasicBlock>> {\n     let mut result = IndexVec::from_elem(vec![], mir.basic_blocks());\n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n         if let Some(ref term) = data.terminator {"}, {"sha": "7985af914ff93e314b9b7ccc8b251772a4a8fcdf", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -47,7 +47,7 @@ pub struct GlobalId<'tcx> {\n     /// For a promoted global, the `Instance` of the function they belong to.\n     pub instance: ty::Instance<'tcx>,\n \n-    /// The index for promoted globals within their function's `Mir`.\n+    /// The index for promoted globals within their function's `mir::Body`.\n     pub promoted: Option<mir::Promoted>,\n }\n "}, {"sha": "a703a396b023a9407f2ecfaef081d9283aeef15f", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> HasLocalDecls<'tcx> for LocalDecls<'tcx> {\n     }\n }\n \n-impl<'tcx> HasLocalDecls<'tcx> for Mir<'tcx> {\n+impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n     fn local_decls(&self) -> &LocalDecls<'tcx> {\n         &self.local_decls\n     }\n@@ -86,7 +86,7 @@ impl MirPhase {\n \n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Mir<'tcx> {\n+pub struct Body<'tcx> {\n     /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n@@ -107,15 +107,15 @@ pub struct Mir<'tcx> {\n     pub source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n \n     /// Rvalues promoted from this function, such as borrows of constants.\n-    /// Each of them is the Mir of a constant with the fn's type parameters\n+    /// Each of them is the Body of a constant with the fn's type parameters\n     /// in scope, but a separate set of locals.\n-    pub promoted: IndexVec<Promoted, Mir<'tcx>>,\n+    pub promoted: IndexVec<Promoted, Body<'tcx>>,\n \n     /// Yields type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n     /// Generator drop glue\n-    pub generator_drop: Option<Box<Mir<'tcx>>>,\n+    pub generator_drop: Option<Box<Body<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n@@ -167,12 +167,12 @@ pub struct Mir<'tcx> {\n     cache: cache::Cache,\n }\n \n-impl<'tcx> Mir<'tcx> {\n+impl<'tcx> Body<'tcx> {\n     pub fn new(\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        promoted: IndexVec<Promoted, Mir<'tcx>>,\n+        promoted: IndexVec<Promoted, Body<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n@@ -189,7 +189,7 @@ impl<'tcx> Mir<'tcx> {\n             local_decls.len()\n         );\n \n-        Mir {\n+        Body {\n             phase: MirPhase::Build,\n             basic_blocks,\n             source_scopes,\n@@ -423,7 +423,7 @@ pub enum Safety {\n     ExplicitUnsafe(hir::HirId),\n }\n \n-impl_stable_hash_for!(struct Mir<'tcx> {\n+impl_stable_hash_for!(struct Body<'tcx> {\n     phase,\n     basic_blocks,\n     source_scopes,\n@@ -442,7 +442,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     cache\n });\n \n-impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n+impl<'tcx> Index<BasicBlock> for Body<'tcx> {\n     type Output = BasicBlockData<'tcx>;\n \n     #[inline]\n@@ -451,7 +451,7 @@ impl<'tcx> Index<BasicBlock> for Mir<'tcx> {\n     }\n }\n \n-impl<'tcx> IndexMut<BasicBlock> for Mir<'tcx> {\n+impl<'tcx> IndexMut<BasicBlock> for Body<'tcx> {\n     #[inline]\n     fn index_mut(&mut self, index: BasicBlock) -> &mut BasicBlockData<'tcx> {\n         &mut self.basic_blocks_mut()[index]\n@@ -599,7 +599,7 @@ newtype_index! {\n     }\n }\n \n-/// Classifies locals into categories. See `Mir::local_kind`.\n+/// Classifies locals into categories. See `Body::local_kind`.\n #[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n     /// User-declared variable binding\n@@ -2828,23 +2828,23 @@ impl<'tcx> Display for Constant<'tcx> {\n     }\n }\n \n-impl<'tcx> graph::DirectedGraph for Mir<'tcx> {\n+impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n     type Node = BasicBlock;\n }\n \n-impl<'tcx> graph::WithNumNodes for Mir<'tcx> {\n+impl<'tcx> graph::WithNumNodes for Body<'tcx> {\n     fn num_nodes(&self) -> usize {\n         self.basic_blocks.len()\n     }\n }\n \n-impl<'tcx> graph::WithStartNode for Mir<'tcx> {\n+impl<'tcx> graph::WithStartNode for Body<'tcx> {\n     fn start_node(&self) -> Self::Node {\n         START_BLOCK\n     }\n }\n \n-impl<'tcx> graph::WithPredecessors for Mir<'tcx> {\n+impl<'tcx> graph::WithPredecessors for Body<'tcx> {\n     fn predecessors<'graph>(\n         &'graph self,\n         node: Self::Node,\n@@ -2853,7 +2853,7 @@ impl<'tcx> graph::WithPredecessors for Mir<'tcx> {\n     }\n }\n \n-impl<'tcx> graph::WithSuccessors for Mir<'tcx> {\n+impl<'tcx> graph::WithSuccessors for Body<'tcx> {\n     fn successors<'graph>(\n         &'graph self,\n         node: Self::Node,\n@@ -2862,12 +2862,12 @@ impl<'tcx> graph::WithSuccessors for Mir<'tcx> {\n     }\n }\n \n-impl<'a, 'b> graph::GraphPredecessors<'b> for Mir<'a> {\n+impl<'a, 'b> graph::GraphPredecessors<'b> for Body<'a> {\n     type Item = BasicBlock;\n     type Iter = IntoIter<BasicBlock>;\n }\n \n-impl<'a, 'b> graph::GraphSuccessors<'b> for Mir<'a> {\n+impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n     type Item = BasicBlock;\n     type Iter = iter::Cloned<Successors<'b>>;\n }\n@@ -2906,7 +2906,7 @@ impl Location {\n     }\n \n     /// Returns `true` if `other` is earlier in the control flow graph than `self`.\n-    pub fn is_predecessor_of<'tcx>(&self, other: Location, mir: &Mir<'tcx>) -> bool {\n+    pub fn is_predecessor_of<'tcx>(&self, other: Location, mir: &Body<'tcx>) -> bool {\n         // If we are in the same block as the other location and are an earlier statement\n         // then we are a predecessor of `other`.\n         if self.block == other.block && self.statement_index < other.statement_index {\n@@ -3159,7 +3159,7 @@ CloneTypeFoldableAndLiftImpls! {\n }\n \n BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for Mir<'tcx> {\n+    impl<'tcx> TypeFoldable<'tcx> for Body<'tcx> {\n         phase,\n         basic_blocks,\n         source_scopes,"}, {"sha": "75d995d801d7853d6234fb2c551332fb18325fea", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -21,14 +21,14 @@ use super::*;\n /// A preorder traversal of this graph is either `A B D C` or `A C D B`\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Preorder<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Preorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Body<'tcx>, root: BasicBlock) -> Preorder<'a, 'tcx> {\n         let worklist = vec![root];\n \n         Preorder {\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> Preorder<'a, 'tcx> {\n     }\n }\n \n-pub fn preorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> Preorder<'a, 'tcx> {\n+pub fn preorder<'a, 'tcx>(mir: &'a Body<'tcx>) -> Preorder<'a, 'tcx> {\n     Preorder::new(mir, START_BLOCK)\n }\n \n@@ -99,14 +99,14 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n ///\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Body<'tcx>, root: BasicBlock) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {\n             mir,\n             visited: BitSet::new_empty(mir.basic_blocks().len()),\n@@ -194,7 +194,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     }\n }\n \n-pub fn postorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> Postorder<'a, 'tcx> {\n+pub fn postorder<'a, 'tcx>(mir: &'a Body<'tcx>) -> Postorder<'a, 'tcx> {\n     Postorder::new(mir, START_BLOCK)\n }\n \n@@ -252,13 +252,13 @@ impl<'a, 'tcx> Iterator for Postorder<'a, 'tcx> {\n /// to re-use the traversal\n #[derive(Clone)]\n pub struct ReversePostorder<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     blocks: Vec<BasicBlock>,\n     idx: usize\n }\n \n impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n+    pub fn new(mir: &'a Body<'tcx>, root: BasicBlock) -> ReversePostorder<'a, 'tcx> {\n         let blocks : Vec<_> = Postorder::new(mir, root).map(|(bb, _)| bb).collect();\n \n         let len = blocks.len();\n@@ -276,7 +276,7 @@ impl<'a, 'tcx> ReversePostorder<'a, 'tcx> {\n }\n \n \n-pub fn reverse_postorder<'a, 'tcx>(mir: &'a Mir<'tcx>) -> ReversePostorder<'a, 'tcx> {\n+pub fn reverse_postorder<'a, 'tcx>(mir: &'a Body<'tcx>) -> ReversePostorder<'a, 'tcx> {\n     ReversePostorder::new(mir, START_BLOCK)\n }\n "}, {"sha": "dd33fae0d6197ed509cd86a7d0d863bff3ad65a2", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -71,8 +71,8 @@ macro_rules! make_mir_visitor {\n             // Override these, and call `self.super_xxx` to revert back to the\n             // default behavior.\n \n-            fn visit_mir(&mut self, mir: & $($mutability)? Mir<'tcx>) {\n-                self.super_mir(mir);\n+            fn visit_body(&mut self, mir: & $($mutability)? Body<'tcx>) {\n+                self.super_body(mir);\n             }\n \n             fn visit_basic_block_data(&mut self,\n@@ -251,8 +251,8 @@ macro_rules! make_mir_visitor {\n             // The `super_xxx` methods comprise the default behavior and are\n             // not meant to be overridden.\n \n-            fn super_mir(&mut self,\n-                         mir: & $($mutability)? Mir<'tcx>) {\n+            fn super_body(&mut self,\n+                         mir: & $($mutability)? Body<'tcx>) {\n                 if let Some(yield_ty) = &$($mutability)? mir.yield_ty {\n                     self.visit_ty(yield_ty, TyContext::YieldTy(SourceInfo {\n                         span: mir.span,\n@@ -261,7 +261,7 @@ macro_rules! make_mir_visitor {\n                 }\n \n                 // for best performance, we want to use an iterator rather\n-                // than a for-loop, to avoid calling Mir::invalidate for\n+                // than a for-loop, to avoid calling `mir::Body::invalidate` for\n                 // each basic block.\n                 macro_rules! basic_blocks {\n                     (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n@@ -825,7 +825,7 @@ macro_rules! make_mir_visitor {\n \n             // Convenience methods\n \n-            fn visit_location(&mut self, mir: & $($mutability)? Mir<'tcx>, location: Location) {\n+            fn visit_location(&mut self, mir: & $($mutability)? Body<'tcx>, location: Location) {\n                 let basic_block = & $($mutability)? mir[location.block];\n                 if basic_block.statements.len() == location.statement_index {\n                     if let Some(ref $($mutability)? terminator) = basic_block.terminator {"}, {"sha": "81aa8d434d37fa04e918f53c9a1b2aa69e5933b7", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -88,7 +88,7 @@ rustc_queries! {\n             desc { \"getting a list of all mir_keys\" }\n         }\n \n-        /// Maps DefId's that have an associated Mir to the result\n+        /// Maps DefId's that have an associated `mir::Body` to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n         query mir_const_qualif(key: DefId) -> (u8, &'tcx BitSet<mir::Local>) {\n@@ -97,26 +97,26 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::Mir<'tcx>> {}\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {}\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        query mir_const(_: DefId) -> &'tcx Steal<mir::Mir<'tcx>> {\n+        query mir_const(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n             no_hash\n         }\n \n-        query mir_validated(_: DefId) -> &'tcx Steal<mir::Mir<'tcx>> {\n+        query mir_validated(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n             no_hash\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        query optimized_mir(key: DefId) -> &'tcx mir::Mir<'tcx> {\n+        query optimized_mir(key: DefId) -> &'tcx mir::Body<'tcx> {\n             cache { key.is_local() }\n             load_cached(tcx, id) {\n-                let mir: Option<crate::mir::Mir<'tcx>> = tcx.queries.on_disk_cache\n+                let mir: Option<crate::mir::Body<'tcx>> = tcx.queries.on_disk_cache\n                                                             .try_load_query_result(tcx, id);\n                 mir.map(|x| tcx.alloc_mir(x))\n             }\n@@ -456,7 +456,7 @@ rustc_queries! {\n         /// in the case of closures, this will be redirected to the enclosing function.\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n-        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx> {\n+        query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::Body<'tcx> {\n             no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }"}, {"sha": "7505b3c1be8444b1995938f93b80c259bb4e2716", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -307,9 +307,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 continue;\n             }\n \n-            // Call infcx.resolve_type_vars_if_possible to see if we can\n+            // Call infcx.resolve_vars_if_possible to see if we can\n             // get rid of any inference variables.\n-            let obligation = infcx.resolve_type_vars_if_possible(\n+            let obligation = infcx.resolve_vars_if_possible(\n                 &Obligation::new(dummy_cause.clone(), new_env, pred)\n             );\n             let result = select.select(&obligation);\n@@ -642,7 +642,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            predicate = select.infcx().resolve_type_vars_if_possible(&predicate);\n+            predicate = select.infcx().resolve_vars_if_possible(&predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain"}, {"sha": "a7b5e6cf41b779981a49d74ff4f09b1fa0c0775d", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -33,7 +33,7 @@ fn in_environment(\n     obligation: PredicateObligation<'tcx>\n ) -> InEnvironment<'tcx, PredicateObligation<'tcx>> {\n     assert!(!infcx.is_in_snapshot());\n-    let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+    let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n     let environment = match obligation.param_env.def_id {\n         Some(def_id) => infcx.tcx.environment(def_id),"}, {"sha": "591557eb2bea5785efbea87f5f0883a0f498d7d7", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -153,11 +153,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n         }\n \n-        let result = self.resolve_type_vars_if_possible(result);\n+        let result = self.resolve_vars_if_possible(result);\n         let result = self.tcx.erase_regions(&result);\n \n         self.tcx.lift_to_global(&result).unwrap_or_else(||\n-            bug!(\"Uninferred types/regions in `{:?}`\", result)\n+            bug!(\"Uninferred types/regions/consts in `{:?}`\", result)\n         )\n     }\n }"}, {"sha": "c6521a931bb29b0876e5f003ad40ece17beecabd", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -155,7 +155,7 @@ fn overlap_within_probe(\n         a_impl_header.predicates\n                      .iter()\n                      .chain(&b_impl_header.predicates)\n-                     .map(|p| infcx.resolve_type_vars_if_possible(p))\n+                     .map(|p| infcx.resolve_vars_if_possible(p))\n                      .map(|p| Obligation { cause: ObligationCause::dummy(),\n                                            param_env,\n                                            recursion_depth: 0,\n@@ -171,7 +171,7 @@ fn overlap_within_probe(\n         return None\n     }\n \n-    let impl_header = selcx.infcx().resolve_type_vars_if_possible(&a_impl_header);\n+    let impl_header = selcx.infcx().resolve_vars_if_possible(&a_impl_header);\n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n "}, {"sha": "5a2bf07b065f8747ea20c2898718afa7da71a5a2", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                error: &MismatchedProjectionTypes<'tcx>)\n     {\n         let predicate =\n-            self.resolve_type_vars_if_possible(&obligation.predicate);\n+            self.resolve_vars_if_possible(&obligation.predicate);\n \n         if predicate.references_error() {\n             return\n@@ -531,7 +531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         where T: fmt::Display + TypeFoldable<'tcx>\n     {\n         let predicate =\n-            self.resolve_type_vars_if_possible(&obligation.predicate);\n+            self.resolve_vars_if_possible(&obligation.predicate);\n         let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0275,\n                                        \"overflow evaluating the requirement `{}`\",\n                                        predicate);\n@@ -553,7 +553,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n     pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_type_vars_if_possible(&cycle.to_owned());\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n         assert!(cycle.len() > 0);\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n@@ -589,7 +589,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn get_parent_trait_ref(&self, code: &ObligationCauseCode<'tcx>) -> Option<String> {\n         match code {\n             &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(\n+                let parent_trait_ref = self.resolve_vars_if_possible(\n                     &data.parent_trait_ref);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n@@ -625,7 +625,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 match obligation.predicate {\n                     ty::Predicate::Trait(ref trait_predicate) => {\n                         let trait_predicate =\n-                            self.resolve_type_vars_if_possible(trait_predicate);\n+                            self.resolve_vars_if_possible(trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -749,7 +749,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self.region_outlives_predicate(&obligation.cause,\n                                                                  &predicate).err().unwrap();\n                         struct_span_err!(\n@@ -761,7 +761,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n                     ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                         let predicate =\n-                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                            self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(self.tcx.sess, span, E0280,\n                             \"the requirement `{}` is not satisfied\",\n                             predicate)\n@@ -852,8 +852,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_type_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_type_vars_if_possible(&*expected_trait_ref);\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n \n                 if expected_trait_ref.self_ty().references_error() {\n                     return;\n@@ -1345,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // ambiguous impls. The latter *ought* to be a\n         // coherence violation, so we don't report it here.\n \n-        let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n         let span = obligation.cause.span;\n \n         debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n@@ -1617,7 +1617,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 err.note(&format!(\"required because it appears within the type `{}`\", ty));\n                 obligated_types.push(ty);\n@@ -1631,7 +1631,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 err.note(\n                     &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n                              parent_trait_ref,\n@@ -1672,7 +1672,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n                                cause_code: &ObligationCauseCode<'tcx>) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_type_vars_if_possible(&data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n \n             if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n                 return true;"}, {"sha": "c7943d16885bd018e134b4d4e48051dc5305e22d", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -178,7 +178,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n     {\n         // this helps to reduce duplicate errors, as well as making\n         // debug output much nicer to read and so on.\n-        let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n+        let obligation = infcx.resolve_vars_if_possible(&obligation);\n \n         debug!(\"register_predicate_obligation(obligation={:?})\", obligation);\n \n@@ -261,7 +261,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }) {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()\n-                           .resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                           .resolve_vars_if_possible(&pending_obligation.obligation),\n                        pending_obligation.stalled_on);\n                 return ProcessResult::Unchanged;\n             }\n@@ -272,7 +272,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n \n         if obligation.predicate.has_infer_types() {\n             obligation.predicate =\n-                self.selcx.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+                self.selcx.infcx().resolve_vars_if_possible(&obligation.predicate);\n         }\n \n         debug!(\"process_obligation: obligation = {:?}\", obligation);\n@@ -318,7 +318,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                             trait_ref_type_vars(self.selcx, data.to_poly_trait_ref());\n \n                         debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                               self.selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                               self.selcx.infcx().resolve_vars_if_possible(obligation),\n                                pending_obligation.stalled_on);\n \n                         ProcessResult::Unchanged\n@@ -519,7 +519,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n      .input_types()\n-     .map(|t| selcx.infcx().resolve_type_vars_if_possible(&t))\n+     .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n      .filter(|t| t.has_infer_types())\n      .flat_map(|t| t.walk())\n      .filter(|t| match t.sty { ty::Infer(_) => true, _ => false })"}, {"sha": "c135b0b759c6f2d3574917667d4e8db90c41a72a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -927,7 +927,7 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(\n     debug!(\"fully_normalize: select_all_or_error start\");\n     fulfill_cx.select_all_or_error(infcx)?;\n     debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n     debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n     Ok(resolved_value)\n }"}, {"sha": "88bb3172c5e79f84edea0de30cca5d111c2b0653", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'b, 'gcx, 'tcx> AssocTypeNormalizer<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn fold<T:TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n-        let value = self.selcx.infcx().resolve_type_vars_if_possible(value);\n+        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n \n         if !value.has_projections() {\n             value\n@@ -508,7 +508,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n {\n     let infcx = selcx.infcx();\n \n-    let projection_ty = infcx.resolve_type_vars_if_possible(&projection_ty);\n+    let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n     let cache_key = ProjectionCacheKey { ty: projection_ty };\n \n     debug!(\"opt_normalize_projection_type(\\\n@@ -1614,7 +1614,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n                 // from a specific call to `opt_normalize_projection_type` - if\n                 // there's no precise match, the original cache entry is \"stranded\"\n                 // anyway.\n-                ty: infcx.resolve_type_vars_if_possible(&predicate.projection_ty)\n+                ty: infcx.resolve_vars_if_possible(&predicate.projection_ty)\n             })\n     }\n }"}, {"sha": "c4aa14d2b7ebcb69472d82ab5d0db1e3db695668", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -54,7 +54,7 @@ impl<'cx, 'gcx, 'tcx> At<'cx, 'gcx, 'tcx> {\n                     &orig_values,\n                     result)\n                 {\n-                    let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                    let ty = self.infcx.resolve_vars_if_possible(&ty);\n                     let kinds = value.into_kinds_reporting_overflows(tcx, span, ty);\n                     return InferOk {\n                         value: kinds,"}, {"sha": "5933d2366e81c337a16652a2a5faa0e935d11a59", "filename": "src/librustc/traits/query/type_op/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -97,7 +97,7 @@ fn scrape_region_constraints<'gcx, 'tcx, R>(\n         region_obligations\n             .iter()\n             .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n-            .map(|(ty, r)| (infcx.resolve_type_vars_if_possible(&ty), r)),\n+            .map(|(ty, r)| (infcx.resolve_vars_if_possible(&ty), r)),\n         &region_constraint_data,\n     );\n "}, {"sha": "ba96233b85328191b0491c8e5c0793f410313b62", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1463,7 +1463,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let obligation = &stack.obligation;\n         let predicate = self.infcx()\n-            .resolve_type_vars_if_possible(&obligation.predicate);\n+            .resolve_vars_if_possible(&obligation.predicate);\n \n         // OK to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n@@ -1621,7 +1621,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             cause: obligation.cause.clone(),\n             recursion_depth: obligation.recursion_depth,\n             predicate: self.infcx()\n-                .resolve_type_vars_if_possible(&obligation.predicate),\n+                .resolve_vars_if_possible(&obligation.predicate),\n         };\n \n         if obligation.predicate.skip_binder().self_ty().is_ty_var() {\n@@ -1737,7 +1737,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> bool {\n         let poly_trait_predicate = self.infcx()\n-            .resolve_type_vars_if_possible(&obligation.predicate);\n+            .resolve_vars_if_possible(&obligation.predicate);\n         let (placeholder_trait_predicate, placeholder_map) = self.infcx()\n             .replace_bound_vars_with_placeholders(&poly_trait_predicate);\n         debug!("}, {"sha": "b5d45d040fb99e25382a9876e1f2d34bb85b4f5b", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -278,7 +278,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n                 // Now resolve the *substitution* we built for the target earlier, replacing\n                 // the inference variables inside with whatever we got from fulfillment.\n-                Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+                Ok(infcx.resolve_vars_if_possible(&target_substs))\n             }\n         }\n     })"}, {"sha": "ff218911ffb8197afca886679b666f392fca5cf2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -23,7 +23,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{self, Mir, interpret, ProjectionKind};\n+use crate::mir::{self, Body, interpret, ProjectionKind};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -103,8 +103,8 @@ pub struct GlobalArenas<'tcx> {\n     generics: TypedArena<ty::Generics>,\n     trait_def: TypedArena<ty::TraitDef>,\n     adt_def: TypedArena<ty::AdtDef>,\n-    steal_mir: TypedArena<Steal<Mir<'tcx>>>,\n-    mir: TypedArena<Mir<'tcx>>,\n+    steal_mir: TypedArena<Steal<Body<'tcx>>>,\n+    mir: TypedArena<Body<'tcx>>,\n     tables: TypedArena<ty::TypeckTables<'tcx>>,\n     /// miri allocations\n     const_allocs: TypedArena<interpret::Allocation>,\n@@ -1154,11 +1154,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.generics.alloc(generics)\n     }\n \n-    pub fn alloc_steal_mir(self, mir: Mir<'gcx>) -> &'gcx Steal<Mir<'gcx>> {\n+    pub fn alloc_steal_mir(self, mir: Body<'gcx>) -> &'gcx Steal<Body<'gcx>> {\n         self.global_arenas.steal_mir.alloc(Steal::new(mir))\n     }\n \n-    pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx Mir<'gcx> {\n+    pub fn alloc_mir(self, mir: Body<'gcx>) -> &'gcx Body<'gcx> {\n         self.global_arenas.mir.alloc(mir)\n     }\n "}, {"sha": "09426fe19e11eac2c21991aae10fc21dd6c9dc01", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -80,6 +80,12 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         };\n \n+        macro_rules! pluralise {\n+            ($x:expr) => {\n+                if $x != 1 { \"s\" } else { \"\" }\n+            };\n+        }\n+\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -94,17 +100,21 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.found)\n             }\n             Mutability => write!(f, \"types differ in mutability\"),\n-            FixedArraySize(values) => {\n-                write!(f, \"expected an array with a fixed size of {} elements, \\\n-                           found one with {} elements\",\n+            TupleSize(values) => {\n+                write!(f, \"expected a tuple with {} element{}, \\\n+                           found one with {} element{}\",\n                        values.expected,\n-                       values.found)\n+                       pluralise!(values.expected),\n+                       values.found,\n+                       pluralise!(values.found))\n             }\n-            TupleSize(values) => {\n-                write!(f, \"expected a tuple with {} elements, \\\n-                           found one with {} elements\",\n+            FixedArraySize(values) => {\n+                write!(f, \"expected an array with a fixed size of {} element{}, \\\n+                           found one with {} element{}\",\n                        values.expected,\n-                       values.found)\n+                       pluralise!(values.expected),\n+                       values.found,\n+                       pluralise!(values.found))\n             }\n             ArgCount => {\n                 write!(f, \"incorrect number of function parameters\")\n@@ -157,16 +167,17 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        tcx.def_path_str(values.found))\n             }),\n             ProjectionBoundsLength(ref values) => {\n-                write!(f, \"expected {} associated type bindings, found {}\",\n+                write!(f, \"expected {} associated type binding{}, found {}\",\n                        values.expected,\n+                       pluralise!(values.expected),\n                        values.found)\n             },\n             ExistentialMismatch(ref values) => {\n                 report_maybe_different(f, &format!(\"trait `{}`\", values.expected),\n                                        &format!(\"trait `{}`\", values.found))\n             }\n             ConstMismatch(ref values) => {\n-                write!(f, \"expected `{:?}`, found `{:?}`\", values.expected, values.found)\n+                write!(f, \"expected `{}`, found `{}`\", values.expected, values.found)\n             }\n         }\n     }"}, {"sha": "fa993325e271233e362d6c850626eb58f6e631f5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -19,7 +19,7 @@ use crate::ich::StableHashingContext;\n use crate::infer::canonical::Canonical;\n use crate::middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n-use crate::mir::Mir;\n+use crate::mir::Body;\n use crate::mir::interpret::{GlobalId, ErrorHandled};\n use crate::mir::GeneratorLayout;\n use crate::session::CrateDisambiguator;\n@@ -3002,7 +3002,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Returns the possibly-auto-generated MIR of a `(DefId, Subst)` pair.\n     pub fn instance_mir(self, instance: ty::InstanceDef<'gcx>)\n-                        -> &'gcx Mir<'gcx>\n+                        -> &'gcx Body<'gcx>\n     {\n         match instance {\n             ty::InstanceDef::Item(did) => {"}, {"sha": "0440be13a7271faa361d58ee08ba859f74937170", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 46, "deletions": 56, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -8,9 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n-use crate::util::common::ErrorReported;\n-use syntax_pos::DUMMY_SP;\n+use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -474,55 +472,19 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            let to_u64 = |x: ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n-                match x.val {\n-                    // FIXME(const_generics): this doesn't work right now,\n-                    // because it tries to relate an `Infer` to a `Param`.\n-                    ConstValue::Unevaluated(def_id, substs) => {\n-                        // FIXME(eddyb) get the right param_env.\n-                        let param_env = ty::ParamEnv::empty();\n-                        if let Some(substs) = tcx.lift_to_global(&substs) {\n-                            let instance = ty::Instance::resolve(\n-                                tcx.global_tcx(),\n-                                param_env,\n-                                def_id,\n-                                substs,\n-                            );\n-                            if let Some(instance) = instance {\n-                                let cid = GlobalId {\n-                                    instance,\n-                                    promoted: None,\n-                                };\n-                                if let Some(s) = tcx.const_eval(param_env.and(cid))\n-                                                    .ok()\n-                                                    .map(|c| c.unwrap_usize(tcx)) {\n-                                    return Ok(s)\n-                                }\n-                            }\n+            match relation.relate(&sz_a, &sz_b) {\n+                Ok(sz) => Ok(tcx.mk_ty(ty::Array(t, sz))),\n+                Err(err) => {\n+                    // Check whether the lengths are both concrete/known values,\n+                    // but are unequal, for better diagnostics.\n+                    match (sz_a.assert_usize(tcx), sz_b.assert_usize(tcx)) {\n+                        (Some(sz_a_val), Some(sz_b_val)) => {\n+                            Err(TypeError::FixedArraySize(\n+                                expected_found(relation, &sz_a_val, &sz_b_val)\n+                            ))\n                         }\n-                        tcx.sess.delay_span_bug(tcx.def_span(def_id),\n-                            \"array length could not be evaluated\");\n-                        Err(ErrorReported)\n+                        _ => return Err(err),\n                     }\n-                    _ => x.assert_usize(tcx).ok_or_else(|| {\n-                        tcx.sess.delay_span_bug(DUMMY_SP,\n-                            \"array length could not be evaluated\");\n-                        ErrorReported\n-                    })\n-                }\n-            };\n-            match (to_u64(*sz_a), to_u64(*sz_b)) {\n-                (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n-                    if sz_a_u64 == sz_b_u64 {\n-                        Ok(tcx.mk_ty(ty::Array(t, sz_a)))\n-                    } else {\n-                        Err(TypeError::FixedArraySize(\n-                            expected_found(relation, &sz_a_u64, &sz_b_u64)))\n-                    }\n-                }\n-                // We reported an error or will ICE, so we can return Error.\n-                (Err(ErrorReported), _) | (_, Err(ErrorReported)) => {\n-                    Ok(tcx.types.err)\n                 }\n             }\n         }\n@@ -598,11 +560,36 @@ where\n {\n     let tcx = relation.tcx();\n \n+    let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n+        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n+            // FIXME(eddyb) get the right param_env.\n+            let param_env = ty::ParamEnv::empty();\n+            if let Some(substs) = tcx.lift_to_global(&substs) {\n+                let instance = ty::Instance::resolve(\n+                    tcx.global_tcx(),\n+                    param_env,\n+                    def_id,\n+                    substs,\n+                );\n+                if let Some(instance) = instance {\n+                    let cid = GlobalId {\n+                        instance,\n+                        promoted: None,\n+                    };\n+                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n+                        return ct.val;\n+                    }\n+                }\n+            }\n+        }\n+        x.val\n+    };\n+\n     // Currently, the values that can be unified are those that\n     // implement both `PartialEq` and `Eq`, corresponding to\n     // `structural_match` types.\n     // FIXME(const_generics): check for `structural_match` synthetic attribute.\n-    match (a.val, b.val) {\n+    match (eagerly_eval(a), eagerly_eval(b)) {\n         (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n             // The caller should handle these cases!\n             bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n@@ -613,8 +600,13 @@ where\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n             Ok(a)\n         }\n-        (ConstValue::Scalar(Scalar::Raw { .. }), _) if a == b => {\n-            Ok(a)\n+        (a_val @ ConstValue::Scalar(Scalar::Raw { .. }), b_val @ _)\n+            if a.ty == b.ty && a_val == b_val =>\n+        {\n+            Ok(tcx.mk_const(ty::Const {\n+                val: a_val,\n+                ty: a.ty,\n+            }))\n         }\n         (ConstValue::ByRef(..), _) => {\n             bug!(\n@@ -635,9 +627,7 @@ where\n                 }))\n             }\n \n-            _ => {\n-            Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n-        }\n+        _ => Err(TypeError::ConstMismatch(expected_found(relation, &a, &b))),\n     }\n }\n "}, {"sha": "711e59dbcc9d2752b3c35b9a1b7bbcdb36fdc787", "filename": "src/librustc/ty/steal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Fsteal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc%2Fty%2Fsteal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsteal.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -7,9 +7,9 @@ use rustc_data_structures::sync::{RwLock, ReadGuard, MappedReadGuard};\n /// optimization, but that'd be expensive. And yet we don't just want\n /// to mutate it in place, because that would spoil the idea that\n /// queries are these pure functions that produce an immutable value\n-/// (since if you did the query twice, you could observe the\n-/// mutations). So instead we have the query produce a `&'tcx\n-/// Steal<Mir<'tcx>>` (to be very specific). Now we can read from this\n+/// (since if you did the query twice, you could observe the mutations).\n+/// So instead we have the query produce a `&'tcx Steal<mir::Body<'tcx>>`\n+/// (to be very specific). Now we can read from this\n /// as much as we want (using `borrow()`), but you can also\n /// `steal()`. Once you steal, any further attempt to read will panic.\n /// Therefore, we know that -- assuming no ICE -- nobody is observing"}, {"sha": "8b3ed5b0c623a5533bf9ec0047c8cda51b2617e8", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,7 +5,7 @@ use super::utils::{DIB, span_start};\n use crate::llvm;\n use crate::llvm::debuginfo::{DIScope, DISubprogram};\n use crate::common::CodegenCx;\n-use rustc::mir::{Mir, SourceScope};\n+use rustc::mir::{Body, SourceScope};\n \n use libc::c_uint;\n \n@@ -20,7 +20,7 @@ use syntax_pos::BytePos;\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n-    mir: &Mir<'_>,\n+    mir: &Body<'_>,\n     debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n ) -> IndexVec<SourceScope, MirDebugScope<&'ll DIScope>> {\n     let null_scope = MirDebugScope {\n@@ -55,7 +55,7 @@ pub fn create_mir_scopes(\n }\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n-                  mir: &Mir<'_>,\n+                  mir: &Body<'_>,\n                   has_variables: &BitSet<SourceScope>,\n                   debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n                   scope: SourceScope,"}, {"sha": "6fa594d44530004bbd7a1df51d0d4fb73db1795a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -239,7 +239,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: &'ll Value,\n-        mir: &mir::Mir<'_>,\n+        mir: &mir::Body<'_>,\n     ) -> FunctionDebugContext<&'ll DISubprogram> {\n         if self.sess().opts.debuginfo == DebugInfo::None {\n             return FunctionDebugContext::DebugInfoDisabled;\n@@ -523,7 +523,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn create_mir_scopes(\n         &self,\n-        mir: &mir::Mir<'_>,\n+        mir: &mir::Body<'_>,\n         debug_context: &mut FunctionDebugContext<&'ll DISubprogram>,\n     ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n         create_scope_map::create_mir_scopes(self, mir, debug_context)"}, {"sha": "bb6a13ed15a52cdeb3f3485ac6c69b56825456e4", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -18,7 +18,7 @@ pub fn non_ssa_locals<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n-    analyzer.visit_mir(mir);\n+    analyzer.visit_body(mir);\n \n     for (index, ty) in mir.local_decls.iter().map(|l| l.ty).enumerate() {\n         let ty = fx.monomorphize(&ty);\n@@ -272,9 +272,9 @@ impl CleanupKind {\n     }\n }\n \n-pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n+pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Body<'tcx>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n-                              mir: &mir::Mir<'tcx>) {\n+                              mir: &mir::Body<'tcx>) {\n         for (bb, data) in mir.basic_blocks().iter_enumerated() {\n             match data.terminator().kind {\n                 TerminatorKind::Goto { .. } |\n@@ -304,7 +304,7 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n     }\n \n     fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n-                       mir: &mir::Mir<'tcx>) {\n+                       mir: &mir::Body<'tcx>) {\n         let mut funclet_succs = IndexVec::from_elem(None, mir.basic_blocks());\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| {"}, {"sha": "4a43201dedf3716979d9dbd9791664273f47822a", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, TypeFoldable, UpvarSubsts};\n use rustc::ty::layout::{TyLayout, HasTyCtxt, FnTypeExt};\n-use rustc::mir::{self, Mir};\n+use rustc::mir::{self, Body};\n use rustc::session::config::DebugInfo;\n use rustc_mir::monomorphize::Instance;\n use rustc_target::abi::call::{FnType, PassMode, IgnoreMode};\n@@ -27,7 +27,7 @@ use self::operand::{OperandRef, OperandValue};\n pub struct FunctionCx<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n \n-    mir: &'a mir::Mir<'tcx>,\n+    mir: &'a mir::Body<'tcx>,\n \n     debug_context: FunctionDebugContext<Bx::DIScope>,\n \n@@ -196,7 +196,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> LocalRef<'tcx, V> {\n pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     cx: &'a Bx::CodegenCx,\n     llfn: Bx::Value,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     instance: Instance<'tcx>,\n     sig: ty::FnSig<'tcx>,\n ) {\n@@ -360,7 +360,7 @@ pub fn codegen_mir<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n }\n \n fn create_funclets<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     bx: &mut Bx,\n     cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n     block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>)"}, {"sha": "37b7a15e2ba5e3331ea4da590cf17d02bdee7e35", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -22,12 +22,12 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: Self::Value,\n-        mir: &mir::Mir<'_>,\n+        mir: &mir::Body<'_>,\n     ) -> FunctionDebugContext<Self::DIScope>;\n \n     fn create_mir_scopes(\n         &self,\n-        mir: &mir::Mir<'_>,\n+        mir: &mir::Body<'_>,\n         debug_context: &mut FunctionDebugContext<Self::DIScope>,\n     ) -> IndexVec<mir::SourceScope, MirDebugScope<Self::DIScope>>;\n     fn extend_scope_to_file("}, {"sha": "211d725e39d57a824ede97f95eb3cc4b97a9ffc3", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -629,6 +629,9 @@ impl fmt::Write for SymbolPrinter<'_, '_> {\n                 // for ':' and '-'\n                 '-' | ':' => self.path.temp_buf.push('.'),\n \n+                // Avoid segmentation fault on some platforms, see #60925.\n+                'm' if self.path.temp_buf.ends_with(\".llv\") => self.path.temp_buf.push_str(\"$6d$\"),\n+\n                 // These are legal symbols\n                 'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '.' | '$' => self.path.temp_buf.push(c),\n "}, {"sha": "10ff606b013a75e582296f04908e2bc5bd6c9644", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::interpret::AllocDecodingSession;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::codec::TyDecoder;\n-use rustc::mir::Mir;\n+use rustc::mir::Body;\n use rustc::util::captures::Captures;\n \n use std::io;\n@@ -887,7 +887,7 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn maybe_get_optimized_mir(&self,\n                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    id: DefIndex)\n-                                   -> Option<Mir<'tcx>> {\n+                                   -> Option<Body<'tcx>> {\n         match self.is_proc_macro(id) {\n             true => None,\n             false => self.entry(id).mir.map(|mir| mir.decode((self, tcx))),"}, {"sha": "588682a2420a94b38437a7a6f8ad0e4b54db2dfb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1026,7 +1026,7 @@ impl EncodeContext<'_, 'tcx> {\n         self.lazy_seq(param_names.iter().map(|ident| ident.name))\n     }\n \n-    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {\n+    fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Body<'tcx>>> {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n             let mir = self.tcx.optimized_mir(def_id);"}, {"sha": "2c3291a41d32b6f7f06effc94ed529e1b8de2d86", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -222,7 +222,7 @@ pub struct Entry<'tcx> {\n     pub predicates: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n     pub predicates_defined_on: Option<Lazy<ty::GenericPredicates<'tcx>>>,\n \n-    pub mir: Option<Lazy<mir::Mir<'tcx>>>,\n+    pub mir: Option<Lazy<mir::Body<'tcx>>>,\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]"}, {"sha": "d9d6fe0affb32ee82ed8b29b6a829f2f0e0bf381", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,7 +5,7 @@ use crate::dataflow::indexes::BorrowIndex;\n use crate::dataflow::move_paths::MoveData;\n use rustc::mir::traversal;\n use rustc::mir::visit::{PlaceContext, Visitor, NonUseContext, MutatingUseContext};\n-use rustc::mir::{self, Location, Mir, Local};\n+use rustc::mir::{self, Location, Body, Local};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -90,7 +90,7 @@ crate enum LocalsStateAtExit {\n impl LocalsStateAtExit {\n     fn build(\n         locals_are_invalidated_at_exit: bool,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n         struct HasStorageDead(BitSet<Local>);\n@@ -107,7 +107,7 @@ impl LocalsStateAtExit {\n             LocalsStateAtExit::AllAreInvalidated\n         } else {\n             let mut has_storage_dead = HasStorageDead(BitSet::new_empty(mir.local_decls.len()));\n-            has_storage_dead.visit_mir(mir);\n+            has_storage_dead.visit_body(mir);\n             let mut has_storage_dead_or_moved = has_storage_dead.0;\n             for move_out in &move_data.moves {\n                 if let Some(index) = move_data.base_local(move_out.path) {\n@@ -123,7 +123,7 @@ impl LocalsStateAtExit {\n impl<'tcx> BorrowSet<'tcx> {\n     pub fn build(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         locals_are_invalidated_at_exit: bool,\n         move_data: &MoveData<'tcx>\n     ) -> Self {\n@@ -163,7 +163,7 @@ impl<'tcx> BorrowSet<'tcx> {\n \n struct GatherBorrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     idx_vec: IndexVec<BorrowIndex, BorrowData<'tcx>>,\n     location_map: FxHashMap<Location, BorrowIndex>,\n     activation_map: FxHashMap<Location, Vec<BorrowIndex>>,"}, {"sha": "feade0d2a4aeea4f8c992a8815a184f18804800e", "filename": "src/librustc_mir/borrow_check/location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Flocation.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::mir::{BasicBlock, Location, Body};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n /// Maps between a MIR Location, which identifies a particular\n@@ -30,7 +30,7 @@ crate enum RichLocation {\n }\n \n impl LocationTable {\n-    crate fn new(mir: &Mir<'_>) -> Self {\n+    crate fn new(mir: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = mir.basic_blocks()\n             .iter()"}, {"sha": "82be2405701d516d971bc8ce1db456d4afd4a770", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -10,7 +10,9 @@ use rustc::lint::builtin::{MUTABLE_BORROW_RESERVATION_CONFLICT};\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{\n-    ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase, Static, StaticKind\n+    ClearCrossCrate, Local, Location, Body, Mutability, Operand, Place, PlaceBase, Static,\n+\n+    StaticKind\n };\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -118,7 +120,7 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n     }\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n-        let input_mir: &Mir<'_> = &input_mir.borrow();\n+        let input_mir: &Body<'_> = &input_mir.borrow();\n         do_mir_borrowck(&infcx, input_mir, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n@@ -128,7 +130,7 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> BorrowC\n \n fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    input_mir: &Mir<'gcx>,\n+    input_mir: &Body<'gcx>,\n     def_id: DefId,\n ) -> BorrowCheckResult<'gcx> {\n     debug!(\"do_mir_borrowck(def_id = {:?})\", def_id);\n@@ -175,7 +177,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     // requires first making our own copy of the MIR. This copy will\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n-    let mut mir: Mir<'tcx> = input_mir.clone();\n+    let mut mir: Body<'tcx> = input_mir.clone();\n     let free_regions = nll::replace_regions_in_mir(infcx, def_id, param_env, &mut mir);\n     let mir = &mir; // no further changes\n     let location_table = &LocationTable::new(mir);\n@@ -451,7 +453,7 @@ fn downgrade_if_error(diag: &mut Diagnostic) {\n \n pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    mir: &'cx Mir<'tcx>,\n+    mir: &'cx Body<'tcx>,\n     mir_def_id: DefId,\n     move_data: &'cx MoveData<'tcx>,\n \n@@ -537,7 +539,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     type FlowState = Flows<'cx, 'gcx, 'tcx>;\n \n-    fn mir(&self) -> &'cx Mir<'tcx> {\n+    fn mir(&self) -> &'cx Body<'tcx> {\n         self.mir\n     }\n "}, {"sha": "a292115707d8eee80957ffa28ec2af5d5262bacf", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Mir};\n+use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Body};\n use rustc::mir::{\n     Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind,\n };\n@@ -562,7 +562,7 @@ fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n     opt_ty_info: Option<Span>,"}, {"sha": "b485f37b78c2d8c5bfe35e6caf42b799c3e8cbc4", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -6,7 +6,7 @@ use crate::borrow_check::nll::region_infer::values::LivenessValues;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, PlaceBase, Rvalue};\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Body, Place, PlaceBase, Rvalue};\n use rustc::mir::{SourceInfo, Statement, Terminator};\n use rustc::mir::UserTypeProjection;\n use rustc::ty::fold::TypeFoldable;\n@@ -18,7 +18,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {"}, {"sha": "3921246b06d388a8d12fc206b2b5dc5d0696c750", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/find_use.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Ffind_use.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,12 +5,12 @@ use crate::borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n use crate::borrow_check::nll::ToRegionVid;\n use crate::util::liveness::{self, DefUse};\n use rustc::mir::visit::{MirVisitable, PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Mir};\n+use rustc::mir::{Local, Location, Body};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n crate fn find<'tcx>(\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'_, '_, 'tcx>,\n     region_vid: RegionVid,\n@@ -28,7 +28,7 @@ crate fn find<'tcx>(\n }\n \n struct UseFinder<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    mir: &'cx Mir<'tcx>,\n+    mir: &'cx Body<'tcx>,\n     regioncx: &'cx Rc<RegionInferenceContext<'tcx>>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> UseFinder<'cx, 'gcx, 'tcx> {\n }\n \n struct DefUseVisitor<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    mir: &'cx Mir<'tcx>,\n+    mir: &'cx Body<'tcx>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     region_vid: RegionVid,\n     def_use_result: Option<DefUseResult>,"}, {"sha": "60c46b36f5f06bca6e025bb0b5c8a9147f2ad954", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -6,7 +6,7 @@ use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, PlaceBase,\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, PlaceBase,\n     Projection, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::{self, TyCtxt};\n@@ -54,7 +54,7 @@ impl BorrowExplanation {\n     pub(in crate::borrow_check) fn add_explanation_to_diagnostic<'cx, 'gcx, 'tcx>(\n         &self,\n         tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         borrow_desc: &str,\n         borrow_span: Option<Span>,"}, {"sha": "017f4d48c120050d2d833539a246913634e15933", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,7 +11,7 @@ use crate::borrow_check::path_utils::*;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::ty::TyCtxt;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Mir, Place, PlaceBase, Rvalue};\n+use rustc::mir::{BasicBlock, Location, Body, Place, PlaceBase, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::TerminatorKind;\n use rustc::mir::{Operand, BorrowKind};\n@@ -21,7 +21,7 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n ) {\n     if all_facts.is_none() {\n@@ -39,15 +39,15 @@ pub(super) fn generate_invalidates<'cx, 'gcx, 'tcx>(\n             mir,\n             dominators,\n         };\n-        ig.visit_mir(mir);\n+        ig.visit_body(mir);\n     }\n }\n \n struct InvalidationGenerator<'cx, 'tcx: 'cx, 'gcx: 'tcx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n-    mir: &'cx Mir<'tcx>,\n+    mir: &'cx Body<'tcx>,\n     dominators: Dominators<BasicBlock>,\n     borrow_set: &'cx BorrowSet<'tcx>,\n }"}, {"sha": "0fb1705c8c294748864f778bd6bfa2521360de72", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,7 +11,7 @@ use crate::transform::MirSource;\n use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n+use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Body};\n use rustc::ty::{self, RegionKind, RegionVid};\n use rustc_errors::Diagnostic;\n use std::fmt::Debug;\n@@ -50,7 +50,7 @@ pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n     param_env: ty::ParamEnv<'tcx>,\n-    mir: &mut Mir<'tcx>,\n+    mir: &mut Body<'tcx>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n@@ -73,7 +73,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n     universal_regions: UniversalRegions<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     upvars: &[Upvar],\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'gcx>,\n@@ -213,7 +213,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'_>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n ) {\n@@ -273,7 +273,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n \n fn dump_annotation<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     mir_def_id: DefId,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,"}, {"sha": "db43ea0558cc7b6b4a3f82c362421f1cb3c4de0b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::mir::{ConstraintCategory, Location, Mir};\n+use rustc::mir::{ConstraintCategory, Location, Body};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n@@ -62,7 +62,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// path to blame.\n     fn best_blame_constraint(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, bool, Span) {\n@@ -237,7 +237,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n     pub(super) fn report_error(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -357,7 +357,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -422,7 +422,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -514,7 +514,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         mir_def_id: DefId,\n@@ -667,7 +667,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     crate fn free_region_constraint_info(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n@@ -724,7 +724,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n     crate fn find_outlives_blame_span(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n@@ -735,7 +735,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn retrieve_closure_constraint_info(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         constraint: &OutlivesConstraint,\n     ) -> (ConstraintCategory, bool, Span) {\n         let loc = match constraint.locations {"}, {"sha": "25415039fc80a7b29f731dd2b2b9918f235b6b35", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -7,7 +7,7 @@ use rustc::hir;\n use rustc::hir::def::{Res, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::mir::Mir;\n+use rustc::mir::Body;\n use rustc::ty::subst::{SubstsRef, UnpackedKind};\n use rustc::ty::{self, RegionKind, RegionVid, Ty, TyCtxt};\n use rustc::ty::print::RegionHighlightMode;\n@@ -152,7 +152,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn give_region_a_name(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         fr: RegionVid,\n@@ -332,7 +332,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -360,7 +360,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         mir_def_id: DefId,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n@@ -406,7 +406,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         counter: &mut usize,\n@@ -676,7 +676,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_output(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n@@ -736,7 +736,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,"}, {"sha": "c02a492c34100295380e27095bf8a16570957eec", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::nll::region_infer::RegionInferenceContext;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n-use rustc::mir::{Local, Mir};\n+use rustc::mir::{Local, Body};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax::source_map::Span;\n@@ -11,7 +11,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn get_var_name_and_span_for_region(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n@@ -120,7 +120,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// declared.\n     crate fn get_argument_name_and_span_for_region(\n         &self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();"}, {"sha": "4a00571feb11045c59749994892ca7e0fc16aeeb", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -13,7 +13,7 @@ use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, Mir,\n+    ConstraintCategory, Local, Location, Body,\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n@@ -185,7 +185,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_regions: Rc<UniversalRegions<'tcx>>,\n         placeholder_indices: Rc<PlaceholderIndices>,\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n-        _mir: &Mir<'tcx>,\n+        _mir: &Body<'tcx>,\n         outlives_constraints: ConstraintSet,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n@@ -400,7 +400,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(super) fn solve<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -416,7 +416,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn solve_inner<'gcx>(\n         &mut self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -468,7 +468,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, _mir: &Mir<'tcx>) {\n+    fn propagate_constraints(&mut self, _mir: &Body<'tcx>) {\n         debug!(\"propagate_constraints()\");\n \n         debug!(\"propagate_constraints: constraints={:#?}\", {\n@@ -581,7 +581,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_type_tests<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n@@ -725,7 +725,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn try_promote_type_test<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n     ) -> bool {\n@@ -944,7 +944,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_verify_bound(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n@@ -977,7 +977,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_if_eq(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n         test_ty: Ty<'tcx>,\n@@ -1037,7 +1037,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,\n-        _mir: &Mir<'tcx>,\n+        _mir: &Body<'tcx>,\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n     ) -> bool {\n@@ -1105,7 +1105,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1150,7 +1150,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n@@ -1216,7 +1216,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         shorter_fr: RegionVid,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -1282,7 +1282,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_bound_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         _mir_def_id: DefId,\n         longer_fr: RegionVid,\n         placeholder: ty::PlaceholderRegion,"}, {"sha": "8822d7bb373934b4fb3129ca492a41c854e399d7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::mir::{BasicBlock, Location, Body};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::bit_set::{HybridBitSet, SparseBitMatrix};\n use rustc_data_structures::fx::FxHashMap;\n@@ -20,7 +20,7 @@ crate struct RegionValueElements {\n }\n \n impl RegionValueElements {\n-    crate fn new(mir: &Mir<'_>) -> Self {\n+    crate fn new(mir: &Body<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block: IndexVec<BasicBlock, usize> = mir.basic_blocks()\n             .iter()\n@@ -92,7 +92,7 @@ impl RegionValueElements {\n     /// Pushes all predecessors of `index` onto `stack`.\n     crate fn push_predecessors(\n         &self,\n-        mir: &Mir<'_>,\n+        mir: &Body<'_>,\n         index: PointIndex,\n         stack: &mut Vec<PointIndex>,\n     ) {"}, {"sha": "a3b142c2ffcc309fa7e4c398ce53d4a4de8dbc20", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,17 +1,17 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Mir};\n+use rustc::mir::{Location, Body};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, mir: &mut Mir<'tcx>) {\n+pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, mir: &mut Body<'tcx>) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n-    visitor.visit_mir(mir);\n+    visitor.visit_body(mir);\n }\n \n /// Replaces all regions appearing in `value` with fresh inference\n@@ -47,12 +47,12 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_mir(&mut self, mir: &mut Mir<'tcx>) {\n+    fn visit_body(&mut self, mir: &mut Body<'tcx>) {\n         for promoted in mir.promoted.iter_mut() {\n-            self.visit_mir(promoted);\n+            self.visit_body(promoted);\n         }\n \n-        self.super_mir(mir);\n+        self.super_body(mir);\n     }\n \n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {"}, {"sha": "120088e1784d432d44407764847d557e33296c9e", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -20,7 +20,7 @@ use super::{Locations, TypeChecker};\n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         universal_regions: &UniversalRegions<'tcx>,\n         normalized_inputs_and_output: &[Ty<'tcx>],\n     ) {"}, {"sha": "e1a7b9babd48a7f16b08c5c4488335f0b3ce58a1", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n use crate::util::liveness::{categorize, DefUse};\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{Local, Location, Mir};\n+use rustc::mir::{Local, Location, Body};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::vec_linked_list as vll;\n \n@@ -60,7 +60,7 @@ impl LocalUseMap {\n     crate fn build(\n         live_locals: &Vec<Local>,\n         elements: &RegionValueElements,\n-        mir: &Mir<'_>,\n+        mir: &Body<'_>,\n     ) -> Self {\n         let nones = IndexVec::from_elem_n(None, mir.local_decls.len());\n         let mut local_use_map = LocalUseMap {\n@@ -81,7 +81,7 @@ impl LocalUseMap {\n             elements,\n             locals_with_use_data,\n         }\n-        .visit_mir(mir);\n+        .visit_body(mir);\n \n         local_use_map\n     }"}, {"sha": "3cefab36e23516575649f6d14ebdef2c732f9644", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -7,7 +7,7 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use rustc::mir::{Local, Mir};\n+use rustc::mir::{Local, Body};\n use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n@@ -27,7 +27,7 @@ mod trace;\n /// performed before\n pub(super) fn generate<'gcx, 'tcx>(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -77,7 +77,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n fn compute_live_locals(\n     tcx: TyCtxt<'_, '_, 'tcx>,\n     free_regions: &FxHashSet<RegionVid>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n ) -> Vec<Local> {\n     let live_locals: Vec<Local> = mir\n         .local_decls"}, {"sha": "345780c4760eb45a642e45625d32993f29df5231", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -7,7 +7,7 @@ use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, Mir};\n+use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, Body};\n use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc::traits::query::type_op::outlives::DropckOutlives;\n use rustc::traits::query::type_op::TypeOp;\n@@ -32,7 +32,7 @@ use std::rc::Rc;\n /// this respects `#[may_dangle]` annotations).\n pub(super) fn trace(\n     typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<'tcx, MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n@@ -72,7 +72,7 @@ where\n     elements: &'me RegionValueElements,\n \n     /// MIR we are analyzing.\n-    mir: &'me Mir<'tcx>,\n+    mir: &'me Body<'tcx>,\n \n     /// Mapping to/from the various indices used for initialization tracking.\n     move_data: &'me MoveData<'tcx>,"}, {"sha": "ad3b2f985d7023cf0dae1d51fea3918b237e2203", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -112,7 +112,7 @@ mod relate_tys;\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     mir_def_id: DefId,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n@@ -179,7 +179,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     mir_def_id: DefId,\n     param_env: ty::ParamEnv<'gcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n@@ -198,7 +198,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n-        verifier.visit_mir(mir);\n+        verifier.visit_body(mir);\n         verifier.errors_reported\n     };\n \n@@ -253,7 +253,7 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n-    mir: &'b Mir<'tcx>,\n+    mir: &'b Body<'tcx>,\n     last_span: Span,\n     mir_def_id: DefId,\n     errors_reported: bool,\n@@ -368,20 +368,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n+    fn visit_body(&mut self, mir: &Body<'tcx>) {\n         self.sanitize_type(&\"return type\", mir.return_ty());\n         for local_decl in &mir.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }\n         if self.errors_reported {\n             return;\n         }\n-        self.super_mir(mir);\n+        self.super_body(mir);\n     }\n }\n \n impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'b Mir<'tcx>) -> Self {\n+    fn new(cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>, mir: &'b Body<'tcx>) -> Self {\n         TypeVerifier {\n             mir,\n             mir_def_id: cx.mir_def_id,\n@@ -538,7 +538,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn sanitize_promoted(&mut self, promoted_mir: &'b Mir<'tcx>, location: Location) {\n+    fn sanitize_promoted(&mut self, promoted_mir: &'b Body<'tcx>, location: Location) {\n         // Determine the constraints from the promoted MIR by running the type\n         // checker on the promoted MIR, then transfer the constraints back to\n         // the main MIR, changing the locations to the provided location.\n@@ -562,7 +562,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             &mut closure_bounds\n         );\n \n-        self.visit_mir(promoted_mir);\n+        self.visit_body(promoted_mir);\n \n         if !self.errors_reported {\n             // if verifier failed, don't do further checks to avoid ICEs\n@@ -969,7 +969,7 @@ impl Locations {\n     }\n \n     /// Gets a span representing the location.\n-    pub fn span(&self, mir: &Mir<'_>) -> Span {\n+    pub fn span(&self, mir: &Body<'_>) -> Span {\n         match self {\n             Locations::All(span) => *span,\n             Locations::Single(l) => mir.source_info(*l).span,\n@@ -980,7 +980,7 @@ impl Locations {\n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn new(\n         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Mir<'tcx>,\n+        mir: &'a Body<'tcx>,\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n@@ -1263,7 +1263,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         debug!(\n                             \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n                             opaque_decl.concrete_ty,\n-                            infcx.resolve_type_vars_if_possible(&opaque_decl.concrete_ty),\n+                            infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n                             opaque_defn_ty\n                         );\n                         obligations.add(infcx\n@@ -1317,7 +1317,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn check_stmt(&mut self, mir: &Mir<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n+    fn check_stmt(&mut self, mir: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         debug!(\"check_stmt: {:?}\", stmt);\n         let tcx = self.tcx();\n         match stmt.kind {\n@@ -1456,7 +1456,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_terminator(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         term_location: Location,\n     ) {\n@@ -1618,7 +1618,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_call_dest(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         destination: &Option<(Place<'tcx>, BasicBlock)>,\n@@ -1687,7 +1687,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_call_inputs(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         term: &Terminator<'tcx>,\n         sig: &ty::FnSig<'tcx>,\n         args: &[Operand<'tcx>],\n@@ -1728,7 +1728,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_iscleanup(&mut self, mir: &Mir<'tcx>, block_data: &BasicBlockData<'tcx>) {\n+    fn check_iscleanup(&mut self, mir: &Body<'tcx>, block_data: &BasicBlockData<'tcx>) {\n         let is_cleanup = block_data.is_cleanup;\n         self.last_span = block_data.terminator().source_info.span;\n         match block_data.terminator().kind {\n@@ -1820,7 +1820,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn assert_iscleanup(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         ctxt: &dyn fmt::Debug,\n         bb: BasicBlock,\n         iscleanuppad: bool,\n@@ -1836,7 +1836,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n+    fn check_local(&mut self, mir: &Body<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1938,7 +1938,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_rvalue(&mut self, mir: &Mir<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+    fn check_rvalue(&mut self, mir: &Body<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n         let tcx = self.tcx();\n \n         match rvalue {\n@@ -2274,7 +2274,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn check_aggregate_rvalue(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         rvalue: &Rvalue<'tcx>,\n         aggregate_kind: &AggregateKind<'tcx>,\n         operands: &[Operand<'tcx>],\n@@ -2332,7 +2332,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// - `borrowed_place`: the place `P` being borrowed\n     fn add_reborrow_constraint(\n         &mut self,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         location: Location,\n         borrow_region: ty::Region<'tcx>,\n         borrowed_place: &Place<'tcx>,\n@@ -2621,7 +2621,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+    fn typeck_mir(&mut self, mir: &Body<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n "}, {"sha": "557d235c23f0555b8ced991aa4b5b93d61f7edef", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseActivation}\n use crate::borrow_check::places_conflict;\n use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n-use rustc::mir::{BasicBlock, Location, Mir, Place, PlaceBase};\n+use rustc::mir::{BasicBlock, Location, Body, Place, PlaceBase};\n use rustc::mir::{ProjectionElem, BorrowKind};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -25,7 +25,7 @@ pub(super) enum Control {\n pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     s: &mut S,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,"}, {"sha": "9306e88e9ae9c804704a2a015a31700566d86c22", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Mir, Place, PlaceBase, Mutability, Static, StaticKind};\n+use rustc::mir::{Body, Place, PlaceBase, Mutability, Static, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -13,7 +13,7 @@ crate trait PlaceExt<'tcx> {\n     fn ignore_borrow(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n         ) -> bool;\n }\n@@ -22,7 +22,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n     fn ignore_borrow(\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n         self.iterate(|place_base, place_projection| {"}, {"sha": "74da3f96653e4314612c044c4f3e1414528e1cbc", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,7 +3,7 @@ use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n use rustc::mir::{\n-    BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, ProjectionsIter,\n+    BorrowKind, Body, Place, PlaceBase, Projection, ProjectionElem, ProjectionsIter,\n     StaticKind\n };\n use rustc::ty::{self, TyCtxt};\n@@ -26,7 +26,7 @@ crate enum PlaceConflictBias {\n /// dataflow).\n crate fn places_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     access_place: &Place<'tcx>,\n     bias: PlaceConflictBias,\n@@ -48,7 +48,7 @@ crate fn places_conflict<'gcx, 'tcx>(\n /// order to make the conservative choice and preserve soundness.\n pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     borrow_place: &Place<'tcx>,\n     borrow_kind: BorrowKind,\n     access_place: &Place<'tcx>,\n@@ -85,7 +85,7 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n \n fn place_components_conflict<'gcx, 'tcx>(\n     tcx: TyCtxt<'_, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     borrow_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n     borrow_kind: BorrowKind,\n     access_projections: (&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>),\n@@ -367,7 +367,7 @@ fn place_base_conflict<'a, 'gcx: 'tcx, 'tcx>(\n // between `elem1` and `elem2`.\n fn place_projection_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     pi1: &Projection<'tcx>,\n     pi2: &Projection<'tcx>,\n     bias: PlaceConflictBias,"}, {"sha": "0e1abeba70dffb0a834faa654fcea54c746905bc", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,7 +11,7 @@ use super::MirBorrowckCtxt;\n \n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{Mir, Place, PlaceBase, ProjectionElem};\n+use rustc::mir::{Body, Place, PlaceBase, ProjectionElem};\n \n pub trait IsPrefixOf<'tcx> {\n     fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n@@ -38,7 +38,7 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n \n \n pub(super) struct Prefixes<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    mir: &'cx Mir<'tcx>,\n+    mir: &'cx Body<'tcx>,\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     kind: PrefixSet,\n     next: Option<&'cx Place<'tcx>>,"}, {"sha": "abfc2f9466c8ed74aca33687e7b421ec51aff0cc", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -34,7 +34,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 never_initialized_mut_locals: &mut never_initialized_mut_locals,\n                 mbcx: self,\n             };\n-            visitor.visit_mir(visitor.mbcx.mir);\n+            visitor.visit_body(visitor.mbcx.mir);\n         }\n \n         // Take the union of the existed `used_mut` set with those variables we've found were"}, {"sha": "5797f9c34786617d01d834d833da6768e8212f74", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::Span;\n use super::lints;\n \n /// Construct the MIR for a given `DefId`.\n-pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'tcx> {\n+pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Body<'tcx> {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n@@ -164,14 +164,14 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        // Convert the Mir to global types.\n+        // Convert the `mir::Body` to global types.\n         let mut globalizer = GlobalizeMir {\n             tcx,\n             span: mir.span\n         };\n-        globalizer.visit_mir(&mut mir);\n+        globalizer.visit_body(&mut mir);\n         let mir = unsafe {\n-            mem::transmute::<Mir<'_>, Mir<'tcx>>(mir)\n+            mem::transmute::<Body<'_>, Body<'tcx>>(mir)\n         };\n \n         mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n@@ -236,22 +236,22 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      ctor_id: hir::HirId,\n                                      v: &'tcx hir::VariantData)\n-                                     -> Mir<'tcx>\n+                                     -> Body<'tcx>\n {\n     let span = tcx.hir().span_by_hir_id(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut mir = shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n \n-            // Convert the Mir to global types.\n+            // Convert the `mir::Body` to global types.\n             let tcx = infcx.tcx.global_tcx();\n             let mut globalizer = GlobalizeMir {\n                 tcx,\n                 span: mir.span\n             };\n-            globalizer.visit_mir(&mut mir);\n+            globalizer.visit_body(&mut mir);\n             let mir = unsafe {\n-                mem::transmute::<Mir<'_>, Mir<'tcx>>(mir)\n+                mem::transmute::<Body<'_>, Body<'tcx>>(mir)\n             };\n \n             mir_util::dump_mir(tcx, None, \"mir_map\", &0,\n@@ -628,7 +628,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    yield_ty: Option<Ty<'gcx>>,\n                                    return_ty_span: Span,\n                                    body: &'gcx hir::Body)\n-                                   -> Mir<'tcx>\n+                                   -> Body<'tcx>\n     where A: Iterator<Item=ArgInfo<'gcx>>\n {\n     let arguments: Vec<_> = arguments.collect();\n@@ -748,7 +748,7 @@ fn construct_const<'a, 'gcx, 'tcx>(\n     body_id: hir::BodyId,\n     const_ty: Ty<'tcx>,\n     const_ty_span: Span,\n-) -> Mir<'tcx> {\n+) -> Body<'tcx> {\n     let tcx = hir.tcx();\n     let owner_id = tcx.hir().body_owner(body_id);\n     let span = tcx.hir().span(owner_id);\n@@ -787,7 +787,7 @@ fn construct_const<'a, 'gcx, 'tcx>(\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    body_id: hir::BodyId)\n-                                   -> Mir<'tcx> {\n+                                   -> Body<'tcx> {\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n@@ -849,14 +849,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn finish(self,\n               yield_ty: Option<Ty<'tcx>>)\n-              -> Mir<'tcx> {\n+              -> Body<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n             if block.terminator.is_none() {\n                 span_bug!(self.fn_span, \"no terminator on block {:?}\", index);\n             }\n         }\n \n-        Mir::new(\n+        Body::new(\n             self.cfg.basic_blocks,\n             self.source_scopes,\n             ClearCrossCrate::Set(self.source_scope_local_data),"}, {"sha": "0637c7b0588827de149d11319a5176731e1fb8fc", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -55,7 +55,7 @@ pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n-    mir: &'mir mir::Mir<'tcx>,\n+    mir: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     let span = tcx.def_span(cid.instance.def_id());\n@@ -137,7 +137,7 @@ fn op_to_const<'tcx>(\n fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n-    mir: &'mir mir::Mir<'tcx>,\n+    mir: &'mir mir::Body<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n     debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n@@ -331,7 +331,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         // Only check non-glue functions\n         if let ty::InstanceDef::Item(def_id) = instance.def {"}, {"sha": "f9d88ab879596f916438b9d240730ad324ac80ba", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,4 +1,4 @@\n-use rustc::mir::{self, Mir, Location};\n+use rustc::mir::{self, Body, Location};\n use rustc::ty::{self, TyCtxt};\n use crate::util::elaborate_drops::DropFlagState;\n \n@@ -47,7 +47,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n //\n // FIXME: we have to do something for moving slice patterns.\n fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                            mir: &Mir<'tcx>,\n+                                                            mir: &Body<'tcx>,\n                                                             place: &mir::Place<'tcx>) -> bool {\n     let ty = place.ty(mir, tcx).ty;\n     match ty.sty {\n@@ -74,7 +74,7 @@ fn place_contents_drop_state_cannot_differ<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx,\n \n pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     lookup_result: LookupResult,\n     each_child: F)\n@@ -92,15 +92,15 @@ pub(crate) fn on_lookup_result_bits<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     move_path_index: MovePathIndex,\n     mut each_child: F)\n     where F: FnMut(MovePathIndex)\n {\n     fn is_terminal_path<'a, 'gcx, 'tcx>(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         path: MovePathIndex) -> bool\n     {\n@@ -110,7 +110,7 @@ pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n \n     fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &Mir<'tcx>,\n+        mir: &Body<'tcx>,\n         move_data: &MoveData<'tcx>,\n         move_path_index: MovePathIndex,\n         each_child: &mut F)\n@@ -133,7 +133,7 @@ pub(crate) fn on_all_children_bits<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     path: MovePathIndex,\n     mut each_child: F)\n@@ -156,7 +156,7 @@ pub(crate) fn on_all_drop_children_bits<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     mut callback: F)\n     where F: FnMut(MovePathIndex, DropFlagState)\n@@ -173,7 +173,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     ctxt: &MoveDataParamEnv<'gcx, 'tcx>,\n     loc: Location,\n     mut callback: F)\n@@ -205,7 +205,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'gcx, 'tcx, F>(\n \n pub(crate) fn for_location_inits<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     move_data: &MoveData<'tcx>,\n     loc: Location,\n     mut callback: F)"}, {"sha": "4965f1a585d482aad4e9d6f2b0569d047879ae39", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,7 +1,7 @@\n //! Hook into libgraphviz for rendering dataflow graphs for MIR.\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::{BasicBlock, Mir};\n+use rustc::mir::{BasicBlock, Body};\n \n use std::fs;\n use std::io;\n@@ -17,7 +17,7 @@ use super::DebugFormatted;\n pub trait MirWithFlowState<'tcx> {\n     type BD: BitDenotation<'tcx>;\n     fn def_id(&self) -> DefId;\n-    fn mir(&self) -> &Mir<'tcx>;\n+    fn mir(&self) -> &Body<'tcx>;\n     fn flow_state(&self) -> &DataflowState<'tcx, Self::BD>;\n }\n \n@@ -26,7 +26,7 @@ impl<'a, 'tcx, BD> MirWithFlowState<'tcx> for DataflowBuilder<'a, 'tcx, BD>\n {\n     type BD = BD;\n     fn def_id(&self) -> DefId { self.def_id }\n-    fn mir(&self) -> &Mir<'tcx> { self.flow_state.mir() }\n+    fn mir(&self) -> &Body<'tcx> { self.flow_state.mir() }\n     fn flow_state(&self) -> &DataflowState<'tcx, Self::BD> { &self.flow_state.flow_state }\n }\n \n@@ -59,7 +59,7 @@ pub type Node = BasicBlock;\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct Edge { source: BasicBlock, index: usize }\n \n-fn outgoing(mir: &Mir<'_>, bb: BasicBlock) -> Vec<Edge> {\n+fn outgoing(mir: &Body<'_>, bb: BasicBlock) -> Vec<Edge> {\n     (0..mir[bb].terminator().successors().count())\n         .map(|index| Edge { source: bb, index: index}).collect()\n }\n@@ -124,7 +124,7 @@ where MWF: MirWithFlowState<'tcx>,\n                                          n: &Node,\n                                          w: &mut W,\n                                          block: BasicBlock,\n-                                         mir: &Mir<'_>) -> io::Result<()> {\n+                                         mir: &Body<'_>) -> io::Result<()> {\n         // Header rows\n         const HDRS: [&str; 4] = [\"ENTRY\", \"MIR\", \"BLOCK GENS\", \"BLOCK KILLS\"];\n         const HDR_FMT: &str = \"bgcolor=\\\"grey\\\"\";\n@@ -149,7 +149,7 @@ where MWF: MirWithFlowState<'tcx>,\n                                             n: &Node,\n                                             w: &mut W,\n                                             block: BasicBlock,\n-                                            mir: &Mir<'_>)\n+                                            mir: &Body<'_>)\n                                             -> io::Result<()> {\n         let i = n.index();\n \n@@ -199,7 +199,7 @@ where MWF: MirWithFlowState<'tcx>,\n                                           n: &Node,\n                                           w: &mut W,\n                                           block: BasicBlock,\n-                                          mir: &Mir<'_>)\n+                                          mir: &Body<'_>)\n                                           -> io::Result<()> {\n         let i = n.index();\n "}, {"sha": "47af10a1c5023072d6431a02073a8514e6263d44", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -12,16 +12,16 @@ use crate::dataflow::BitDenotation;\n /// immovable generators.\n #[derive(Copy, Clone)]\n pub struct HaveBeenBorrowedLocals<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> HaveBeenBorrowedLocals<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>)\n+    pub fn new(mir: &'a Body<'tcx>)\n                -> Self {\n         HaveBeenBorrowedLocals { mir }\n     }\n \n-    pub fn mir(&self) -> &Mir<'tcx> {\n+    pub fn mir(&self) -> &Body<'tcx> {\n         self.mir\n     }\n }"}, {"sha": "99051fb37f1488b9e91ada1e849971d2a75d4326", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::borrow_set::{BorrowSet, BorrowData};\n use crate::borrow_check::place_ext::PlaceExt;\n \n-use rustc::mir::{self, Location, Place, PlaceBase, Mir};\n+use rustc::mir::{self, Location, Place, PlaceBase, Body};\n use rustc::ty::TyCtxt;\n use rustc::ty::RegionVid;\n \n@@ -31,7 +31,7 @@ newtype_index! {\n /// borrows in compact bitvectors.\n pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n \n     borrow_set: Rc<BorrowSet<'tcx>>,\n     borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n@@ -48,7 +48,7 @@ struct StackEntry {\n }\n \n fn precompute_borrows_out_of_scope<'tcx>(\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     regioncx: &Rc<RegionInferenceContext<'tcx>>,\n     borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n     borrow_index: BorrowIndex,\n@@ -136,7 +136,7 @@ fn precompute_borrows_out_of_scope<'tcx>(\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Mir<'tcx>,\n+        mir: &'a Body<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n         borrow_set: &Rc<BorrowSet<'tcx>>,\n     ) -> Self {"}, {"sha": "4f3b180edd111812323a536db9e87da2cc3a7a09", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,7 +3,7 @@\n //! zero-sized structure.\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::{self, Mir, Location};\n+use rustc::mir::{self, Body, Location};\n use rustc_data_structures::bit_set::{BitSet, BitSetOperator};\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -65,13 +65,13 @@ pub(super) mod borrows;\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n+               mir: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n@@ -120,13 +120,13 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx\n /// places that would require a dynamic drop-flag at that statement.\n pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n+               mir: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n@@ -174,13 +174,13 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 't\n /// that would require a dynamic drop-flag at that statement.\n pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n+               mir: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n@@ -223,13 +223,13 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, '\n /// ```\n pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n+               mir: &'a Body<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {"}, {"sha": "ab79d6cc947e8146279b67ac8f8de11148e8ed4c", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,16 +5,16 @@ use crate::dataflow::BitDenotation;\n \n #[derive(Copy, Clone)]\n pub struct MaybeStorageLive<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n }\n \n impl<'a, 'tcx: 'a> MaybeStorageLive<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>)\n+    pub fn new(mir: &'a Body<'tcx>)\n                -> Self {\n         MaybeStorageLive { mir }\n     }\n \n-    pub fn mir(&self) -> &Mir<'tcx> {\n+    pub fn mir(&self) -> &Body<'tcx> {\n         self.mir\n     }\n }"}, {"sha": "26bad0cb04d7061271f9b85deefd1b2bae33aff3", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::work_queue::WorkQueue;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n+use rustc::mir::{self, Body, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::mir::traversal;\n use rustc::session::Session;\n \n@@ -122,7 +122,7 @@ pub struct MoveDataParamEnv<'gcx, 'tcx> {\n }\n \n pub(crate) fn do_dataflow<'a, 'gcx, 'tcx, BD, P>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                 mir: &'a Mir<'tcx>,\n+                                                 mir: &'a Body<'tcx>,\n                                                  def_id: DefId,\n                                                  attributes: &[ast::Attribute],\n                                                  dead_unwinds: &BitSet<BasicBlock>,\n@@ -343,13 +343,13 @@ pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n \n     // Delegated Hooks: Provide access to the MIR and process the flow state.\n \n-    fn mir(&self) -> &'a Mir<'tcx>;\n+    fn mir(&self) -> &'a Body<'tcx>;\n }\n \n pub fn state_for_location<'tcx, T: BitDenotation<'tcx>>(loc: Location,\n                                                         analysis: &T,\n                                                         result: &DataflowResults<'tcx, T>,\n-                                                        mir: &Mir<'tcx>)\n+                                                        mir: &Body<'tcx>)\n     -> BitSet<T::Idx> {\n     let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n     let mut kill_set = on_entry.to_hybrid();\n@@ -384,7 +384,7 @@ pub struct DataflowAnalysis<'a, 'tcx: 'a, O> where O: BitDenotation<'tcx>\n {\n     flow_state: DataflowState<'tcx, O>,\n     dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n }\n \n impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation<'tcx>\n@@ -393,7 +393,7 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation<'tcx>\n         DataflowResults(self.flow_state)\n     }\n \n-    pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n+    pub fn mir(&self) -> &'a Body<'tcx> { self.mir }\n }\n \n pub struct DataflowResults<'tcx, O>(pub(crate) DataflowState<'tcx, O>) where O: BitDenotation<'tcx>;\n@@ -697,7 +697,7 @@ pub trait BitDenotation<'tcx>: BitSetOperator {\n \n impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation<'tcx>\n {\n-    pub fn new(mir: &'a Mir<'tcx>,\n+    pub fn new(mir: &'a Body<'tcx>,\n                dead_unwinds: &'a BitSet<mir::BasicBlock>,\n                denotation: D) -> Self where D: InitialFlow {\n         let bits_per_block = denotation.bits_per_block();"}, {"sha": "816a269625399e7706a946a4658287c1c816c0f1", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -13,14 +13,14 @@ use super::{MoveError, InitIndex, Init, InitLocation, LookupResult, InitKind};\n use super::IllegalMoveOriginKind::*;\n \n struct MoveDataBuilder<'a, 'gcx: 'tcx, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     data: MoveData<'tcx>,\n     errors: Vec<(Place<'tcx>, MoveError<'tcx>)>,\n }\n \n impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(mir: &'a Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n         let mut move_paths = IndexVec::new();\n         let mut path_map = IndexVec::new();\n         let mut init_path_map = IndexVec::new();\n@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n }\n \n pub(super) fn gather_moves<'a, 'gcx, 'tcx>(\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>\n ) -> Result<MoveData<'tcx>, (MoveData<'tcx>, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n     let mut builder = MoveDataBuilder::new(mir, tcx);"}, {"sha": "0d20040d0d2d7d187fec366870ef3bc0129dcca9", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -138,7 +138,7 @@ impl<T> IndexMut<Location> for LocationMap<T> {\n }\n \n impl<T> LocationMap<T> where T: Default + Clone {\n-    fn new(mir: &Mir<'_>) -> Self {\n+    fn new(mir: &Body<'_>) -> Self {\n         LocationMap {\n             map: mir.basic_blocks().iter().map(|block| {\n                 vec![T::default(); block.statements.len()+1]\n@@ -205,7 +205,7 @@ impl fmt::Debug for Init {\n }\n \n impl Init {\n-    crate fn span<'gcx>(&self, mir: &Mir<'gcx>) -> Span {\n+    crate fn span<'gcx>(&self, mir: &Body<'gcx>) -> Span {\n         match self.location {\n             InitLocation::Argument(local) => mir.local_decls[local].source_info.span,\n             InitLocation::Statement(location) => mir.source_info(location).span,\n@@ -306,7 +306,7 @@ impl<'tcx> MoveError<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+    pub fn gather_moves(mir: &Body<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n                         -> Result<Self, (Self, Vec<(Place<'tcx>, MoveError<'tcx>)>)> {\n         builder::gather_moves(mir, tcx)\n     }"}, {"sha": "80f64e85f9cf9201c11937dd66bbcfc24a8afaeb", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -44,7 +44,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     /// Whether this constant/function needs overflow checks.\n     check_overflow: bool,\n \n-    /// See field with the same name on `Mir`.\n+    /// See field with the same name on `mir::Body`.\n     control_flow_destroyed: Vec<(Span, String)>,\n }\n "}, {"sha": "d3cbd2bcc03a52e0cd688805be5ff89862494b08", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -53,7 +53,7 @@ pub struct Frame<'mir, 'tcx: 'mir, Tag=(), Extra=()> {\n     // Function and callsite information\n     ////////////////////////////////////////////////////////////////////////////////\n     /// The MIR for the function called on this frame.\n-    pub mir: &'mir mir::Mir<'tcx>,\n+    pub mir: &'mir mir::Body<'tcx>,\n \n     /// The def_id and substs of the current function.\n     pub instance: ty::Instance<'tcx>,\n@@ -244,7 +244,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     }\n \n     #[inline(always)]\n-    pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n+    pub(super) fn mir(&self) -> &'mir mir::Body<'tcx> {\n         self.frame().mir\n     }\n \n@@ -294,7 +294,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n-    ) -> EvalResult<'tcx, &'tcx mir::Mir<'tcx>> {\n+    ) -> EvalResult<'tcx, &'tcx mir::Body<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n         if did.is_local()\n@@ -472,7 +472,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         span: source_map::Span,\n-        mir: &'mir mir::Mir<'tcx>,\n+        mir: &'mir mir::Body<'tcx>,\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {"}, {"sha": "873c2d2ec6088b1e01e94947b7770e3b6cdecb55", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -117,7 +117,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block."}, {"sha": "cbfc89934718600c9337c4b40e0b81fab9bc4a6b", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,12 +3,12 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::lint::builtin::UNCONDITIONAL_RECURSION;\n-use rustc::mir::{self, Mir, TerminatorKind};\n+use rustc::mir::{self, Body, TerminatorKind};\n use rustc::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-             mir: &Mir<'tcx>,\n+             mir: &Body<'tcx>,\n              def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n \n@@ -19,7 +19,7 @@ pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         fn_kind: FnKind<'_>,\n-                                        mir: &Mir<'tcx>,\n+                                        mir: &Body<'tcx>,\n                                         def_id: DefId) {\n     if let FnKind::Closure(_) = fn_kind {\n         // closures can't recur, so they don't matter."}, {"sha": "c1131336f3636a08606c48c619eba604eaec4464", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -517,7 +517,7 @@ fn check_type_length_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct MirNeighborCollector<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a mir::Mir<'tcx>,\n+    mir: &'a mir::Body<'tcx>,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n     param_substs: SubstsRef<'tcx>,\n }\n@@ -1218,7 +1218,7 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         mir: &mir,\n         output,\n         param_substs: instance.substs,\n-    }.visit_mir(&mir);\n+    }.visit_body(&mir);\n     let param_env = ty::ParamEnv::reveal_all();\n     for i in 0..mir.promoted.len() {\n         use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "087f8779b6916fb896a82e47525dba45bf040694", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -28,7 +28,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n \n fn make_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        instance: ty::InstanceDef<'tcx>)\n-                       -> &'tcx Mir<'tcx>\n+                       -> &'tcx Body<'tcx>\n {\n     debug!(\"make_shim({:?})\", instance);\n \n@@ -169,7 +169,7 @@ fn local_decls_for_sig<'tcx>(sig: &ty::FnSig<'tcx>, span: Span)\n fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              def_id: DefId,\n                              ty: Option<Ty<'tcx>>)\n-                             -> Mir<'tcx>\n+                             -> Body<'tcx>\n {\n     debug!(\"build_drop_shim(def_id={:?}, ty={:?})\", def_id, ty);\n \n@@ -202,7 +202,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     block(&mut blocks, TerminatorKind::Goto { target: return_block });\n     block(&mut blocks, TerminatorKind::Return);\n \n-    let mut mir = Mir::new(\n+    let mut mir = Body::new(\n         blocks,\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1\n@@ -256,7 +256,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n pub struct DropShimElaborator<'a, 'tcx: 'a> {\n-    pub mir: &'a Mir<'tcx>,\n+    pub mir: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     type Path = ();\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx> { &mut self.patch }\n-    fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n+    fn mir(&self) -> &'a Body<'tcx> { self.mir }\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n     fn param_env(&self) -> ty::ParamEnv<'tcx> { self.param_env }\n \n@@ -309,7 +309,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId,\n                               self_ty: Ty<'tcx>)\n-                              -> Mir<'tcx>\n+                              -> Body<'tcx>\n {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n@@ -371,8 +371,8 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn into_mir(self) -> Mir<'tcx> {\n-        Mir::new(\n+    fn into_mir(self) -> Body<'tcx> {\n+        Body::new(\n             self.blocks,\n             IndexVec::from_elem_n(\n                 SourceScopeData { span: self.span, parent_scope: None }, 1\n@@ -696,7 +696,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              rcvr_adjustment: Adjustment,\n                              call_kind: CallKind,\n                              untuple_args: Option<&[Ty<'tcx>]>)\n-                             -> Mir<'tcx>\n+                             -> Body<'tcx>\n {\n     debug!(\"build_call_shim(def_id={:?}, rcvr_adjustment={:?}, \\\n             call_kind={:?}, untuple_args={:?})\",\n@@ -821,7 +821,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         block(&mut blocks, vec![], TerminatorKind::Resume, true);\n     }\n \n-    let mut mir = Mir::new(\n+    let mut mir = Body::new(\n         blocks,\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1\n@@ -846,7 +846,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                       ctor_id: hir::HirId,\n                                       fields: &[hir::StructField],\n                                       span: Span)\n-                                      -> Mir<'tcx>\n+                                      -> Body<'tcx>\n {\n     let tcx = infcx.tcx;\n     let gcx = tcx.global_tcx();\n@@ -900,7 +900,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         is_cleanup: false\n     };\n \n-    Mir::new(\n+    Body::new(\n         IndexVec::from_elem_n(start_block, 1),\n         IndexVec::from_elem_n(\n             SourceScopeData { span: span, parent_scope: None }, 1"}, {"sha": "712e9b1fe25059021e4d0275d73bc2dd42d503ac", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -34,13 +34,13 @@ impl MirPass for AddCallGuards {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         self.add_call_guards(mir);\n     }\n }\n \n impl AddCallGuards {\n-    pub fn add_call_guards(&self, mir: &mut Mir<'_>) {\n+    pub fn add_call_guards(&self, mir: &mut Body<'_>) {\n         let pred_count: IndexVec<_, _> =\n             mir.predecessors().iter().map(|ps| ps.len()).collect();\n "}, {"sha": "f7a4bf759545cf9903cd22997e2d42226839ccea", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -43,7 +43,7 @@ impl MirPass for AddMovesForPackedDrops {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>)\n+                          mir: &mut Body<'tcx>)\n     {\n         debug!(\"add_moves_for_packed_drops({:?} @ {:?})\", src, mir.span);\n         add_moves_for_packed_drops(tcx, mir, src.def_id());\n@@ -52,7 +52,7 @@ impl MirPass for AddMovesForPackedDrops {\n \n pub fn add_moves_for_packed_drops<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &mut Mir<'tcx>,\n+    mir: &mut Body<'tcx>,\n     def_id: DefId)\n {\n     let patch = add_moves_for_packed_drops_patch(tcx, mir, def_id);\n@@ -61,7 +61,7 @@ pub fn add_moves_for_packed_drops<'a, 'tcx>(\n \n fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     def_id: DefId)\n     -> MirPatch<'tcx>\n {\n@@ -92,7 +92,7 @@ fn add_moves_for_packed_drops_patch<'a, 'tcx>(\n \n fn add_move_for_packed_drop<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     patch: &mut MirPatch<'tcx>,\n     terminator: &Terminator<'tcx>,\n     loc: Location,"}, {"sha": "23319f7055183e2ceb3360705d560fa00a87c3b9", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -77,7 +77,7 @@ impl MirPass for AddRetag {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>)\n+                          mir: &mut Body<'tcx>)\n     {\n         if !tcx.sess.opts.debugging_opts.mir_emit_retag {\n             return;"}, {"sha": "8ec8a8fa12eeced2231e51515b8268f3e83397fc", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -19,7 +19,7 @@ use std::ops::Bound;\n use crate::util;\n \n pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     const_context: bool,\n     min_const_fn: bool,\n     source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     fn new(\n         const_context: bool,\n         min_const_fn: bool,\n-        mir: &'a Mir<'tcx>,\n+        mir: &'a Body<'tcx>,\n         source_scope_local_data: &'a IndexVec<SourceScope, SourceScopeLocalData>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -538,7 +538,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     let mut checker = UnsafetyChecker::new(\n         const_context, min_const_fn,\n         mir, source_scope_local_data, tcx, param_env);\n-    checker.visit_mir(mir);\n+    checker.visit_body(mir);\n \n     check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n     UnsafetyCheckResult {"}, {"sha": "63a1b059d90178ed14e8f63a2d49cae988c30c9d", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -16,7 +16,7 @@\n //! [`FakeRead`]: rustc::mir::StatementKind::FakeRead\n //! [`Nop`]: rustc::mir::StatementKind::Nop\n \n-use rustc::mir::{BorrowKind, Rvalue, Location, Mir};\n+use rustc::mir::{BorrowKind, Rvalue, Location, Body};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -30,9 +30,9 @@ impl MirPass for CleanupNonCodegenStatements {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         let mut delete = DeleteNonCodegenStatements;\n-        delete.visit_mir(mir);\n+        delete.visit_body(mir);\n     }\n }\n "}, {"sha": "728ea41a9d8e9534d31535061a33e34266a59df6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,7 +3,7 @@\n \n use rustc::hir::def::DefKind;\n use rustc::mir::{\n-    AggregateKind, Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local,\n     NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n     TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp, ProjectionElem,\n     SourceScope, SourceScopeLocalData, LocalDecl, Promoted,\n@@ -33,7 +33,7 @@ impl MirPass for ConstProp {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         // will be evaluated by miri and produce its errors there\n         if source.promoted.is_some() {\n             return;\n@@ -63,7 +63,7 @@ impl MirPass for ConstProp {\n         // That would require an uniform one-def no-mutation analysis\n         // and RPO (or recursing when needing the value of a local).\n         let mut optimization_finder = ConstPropagator::new(mir, tcx, source);\n-        optimization_finder.visit_mir(mir);\n+        optimization_finder.visit_body(mir);\n \n         // put back the data we stole from `mir`\n         std::mem::replace(\n@@ -91,7 +91,7 @@ struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     param_env: ParamEnv<'tcx>,\n     source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n-    promoted: IndexVec<Promoted, Mir<'tcx>>,\n+    promoted: IndexVec<Promoted, Body<'tcx>>,\n }\n \n impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n@@ -119,7 +119,7 @@ impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n \n impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn new(\n-        mir: &mut Mir<'tcx>,\n+        mir: &mut Body<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n@@ -143,7 +143,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             can_const_prop,\n             places: IndexVec::from_elem(None, &mir.local_decls),\n             source_scope_local_data,\n-            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_mir()` needs it\n+            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: mir.local_decls.clone(),\n             promoted,\n         }\n@@ -569,7 +569,7 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// returns true if `local` can be propagated\n-    fn check(mir: &Mir<'_>) -> IndexVec<Local, bool> {\n+    fn check(mir: &Body<'_>) -> IndexVec<Local, bool> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(true, &mir.local_decls),\n             found_assignment: IndexVec::from_elem(false, &mir.local_decls),\n@@ -586,7 +586,7 @@ impl CanConstProp {\n                 trace!(\"local {:?} can't be propagated because it's not a temporary\", local);\n             }\n         }\n-        cpv.visit_mir(mir);\n+        cpv.visit_body(mir);\n         cpv.can_const_prop\n     }\n }"}, {"sha": "c48d2d295711a495f59d94713a15566a64cfa755", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -20,7 +20,7 @@\n //! future.\n \n use rustc::mir::{\n-    Constant, Local, LocalKind, Location, Place, PlaceBase, Mir, Operand, Rvalue, StatementKind\n+    Constant, Local, LocalKind, Location, Place, PlaceBase, Body, Operand, Rvalue, StatementKind\n };\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n@@ -33,7 +33,7 @@ impl MirPass for CopyPropagation {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         // We only run when the MIR optimization level is > 1.\n         // This avoids a slow pass, and messing up debug info.\n         if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n@@ -135,7 +135,7 @@ impl MirPass for CopyPropagation {\n }\n \n fn eliminate_self_assignments(\n-    mir: &mut Mir<'_>,\n+    mir: &mut Body<'_>,\n     def_use_analysis: &DefUseAnalysis,\n ) -> bool {\n     let mut changed = false;\n@@ -177,7 +177,7 @@ enum Action<'tcx> {\n }\n \n impl<'tcx> Action<'tcx> {\n-    fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n+    fn local_copy(mir: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n         let src_local = if let Place::Base(PlaceBase::Local(local)) = *src_place {\n@@ -232,7 +232,7 @@ impl<'tcx> Action<'tcx> {\n     }\n \n     fn perform(self,\n-               mir: &mut Mir<'tcx>,\n+               mir: &mut Body<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n                location: Location)"}, {"sha": "7da37f956cedd2fc23c0468acd17caaaac5514c3", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -10,7 +10,7 @@ impl MirPass for Deaggregator {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         let (basic_blocks, local_decls) = mir.basic_blocks_and_local_decls_mut();\n         let local_decls = &*local_decls;\n         for bb in basic_blocks {"}, {"sha": "ebb65094a306df2681a4cfdef5dbb4e24fd29eff", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,7 +5,7 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n \n-use rustc::mir::Mir;\n+use rustc::mir::Body;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -21,7 +21,7 @@ impl MirPass for Marker {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource<'tcx>,\n-                          _mir: &mut Mir<'tcx>)\n+                          _mir: &mut Body<'tcx>)\n     {\n     }\n }\n@@ -42,7 +42,7 @@ pub fn on_mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              pass_num: &dyn fmt::Display,\n                              pass_name: &str,\n                              source: MirSource<'tcx>,\n-                             mir: &Mir<'tcx>,\n+                             mir: &Body<'tcx>,\n                              is_after: bool) {\n     if mir_util::dump_enabled(tcx, pass_name, source) {\n         mir_util::dump_mir(tcx,"}, {"sha": "c833af29c36f0ed1427be0ac03b7830649d52ee1", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -24,7 +24,7 @@ impl MirPass for ElaborateDrops {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>)\n+                          mir: &mut Body<'tcx>)\n     {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, mir.span);\n \n@@ -79,7 +79,7 @@ impl MirPass for ElaborateDrops {\n /// that can't drop anything.\n fn find_dead_unwinds<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     def_id: hir::def_id::DefId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n     -> BitSet<BasicBlock>\n@@ -143,7 +143,7 @@ struct InitializationData {\n impl InitializationData {\n     fn apply_location<'a,'tcx>(&mut self,\n                                tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               mir: &Mir<'tcx>,\n+                               mir: &Body<'tcx>,\n                                env: &MoveDataParamEnv<'tcx, 'tcx>,\n                                loc: Location)\n     {\n@@ -186,7 +186,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n         &mut self.ctxt.patch\n     }\n \n-    fn mir(&self) -> &'a Mir<'tcx> {\n+    fn mir(&self) -> &'a Body<'tcx> {\n         self.ctxt.mir\n     }\n \n@@ -291,7 +291,7 @@ impl<'a, 'b, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, 'b, 'tcx> {\n \n struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n     flow_inits: DataflowResults<'tcx, MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n     flow_uninits:  DataflowResults<'tcx, MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,"}, {"sha": "ffc5bba6d608660c4b10e4f6df4f448a314ec729", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -53,7 +53,7 @@ impl MirPass for EraseRegions {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n-        EraseRegionsVisitor::new(tcx).visit_mir(mir);\n+                          mir: &mut Body<'tcx>) {\n+        EraseRegionsVisitor::new(tcx).visit_body(mir);\n     }\n }"}, {"sha": "f36ede4e8d9cdcce31ae31210a718efafd986b2a", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n     }\n \n     // Create a statement which reads the discriminant into a temporary\n-    fn get_discr(&self, mir: &mut Mir<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n+    fn get_discr(&self, mir: &mut Body<'tcx>) -> (Statement<'tcx>, Place<'tcx>) {\n         let temp_decl = LocalDecl::new_internal(self.tcx.types.isize, mir.span);\n         let local_decls_len = mir.local_decls.push(temp_decl);\n         let temp = Place::Base(PlaceBase::Local(local_decls_len));\n@@ -304,7 +304,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n fn make_generator_state_argument_indirect<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 def_id: DefId,\n-                mir: &mut Mir<'tcx>) {\n+                mir: &mut Body<'tcx>) {\n     let gen_ty = mir.local_decls.raw[1].ty;\n \n     let region = ty::ReFree(ty::FreeRegion {\n@@ -323,12 +323,12 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n     mir.local_decls.raw[1].ty = ref_gen_ty;\n \n     // Add a deref to accesses of the generator state\n-    DerefArgVisitor.visit_mir(mir);\n+    DerefArgVisitor.visit_body(mir);\n }\n \n fn make_generator_state_argument_pinned<'a, 'tcx>(\n                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                mir: &mut Mir<'tcx>) {\n+                mir: &mut Body<'tcx>) {\n     let ref_gen_ty = mir.local_decls.raw[1].ty;\n \n     let pin_did = tcx.lang_items().pin_type().unwrap();\n@@ -340,12 +340,12 @@ fn make_generator_state_argument_pinned<'a, 'tcx>(\n     mir.local_decls.raw[1].ty = pin_ref_gen_ty;\n \n     // Add the Pin field access to accesses of the generator state\n-    PinArgVisitor { ref_gen_ty }.visit_mir(mir);\n+    PinArgVisitor { ref_gen_ty }.visit_body(mir);\n }\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n-    mir: &mut Mir<'tcx>,\n+    mir: &mut Body<'tcx>,\n ) -> Local {\n     let source_info = source_info(mir);\n     let new_ret = LocalDecl {\n@@ -366,7 +366,7 @@ fn replace_result_variable<'tcx>(\n     RenameLocalVisitor {\n         from: RETURN_PLACE,\n         to: new_ret_local,\n-    }.visit_mir(mir);\n+    }.visit_body(mir);\n \n     new_ret_local\n }\n@@ -387,7 +387,7 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n \n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> (\n@@ -408,7 +408,7 @@ fn locals_live_across_suspend_points(\n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n     let mut ignored = StorageIgnored(BitSet::new_filled(mir.local_decls.len()));\n-    ignored.visit_mir(mir);\n+    ignored.visit_body(mir);\n \n     // Calculate the MIR locals which have been previously\n     // borrowed (even if they are still active).\n@@ -503,7 +503,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             upvars: &Vec<Ty<'tcx>>,\n                             interior: Ty<'tcx>,\n                             movable: bool,\n-                            mir: &mut Mir<'tcx>)\n+                            mir: &mut Body<'tcx>)\n     -> (FxHashMap<Local, (Ty<'tcx>, VariantIdx, usize)>,\n         GeneratorLayout<'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n@@ -576,7 +576,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     (remap, layout, storage_liveness)\n }\n \n-fn insert_switch<'a, 'tcx>(mir: &mut Mir<'tcx>,\n+fn insert_switch<'a, 'tcx>(mir: &mut Body<'tcx>,\n                            cases: Vec<(usize, BasicBlock)>,\n                            transform: &TransformVisitor<'a, 'tcx>,\n                            default: TerminatorKind<'tcx>) {\n@@ -608,7 +608,7 @@ fn insert_switch<'a, 'tcx>(mir: &mut Mir<'tcx>,\n \n fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        def_id: DefId,\n-                                       mir: &mut Mir<'tcx>) {\n+                                       mir: &mut Body<'tcx>) {\n     use crate::util::elaborate_drops::{elaborate_drop, Unwind};\n     use crate::util::patch::MirPatch;\n     use crate::shim::DropShimElaborator;\n@@ -663,8 +663,8 @@ fn create_generator_drop_shim<'a, 'tcx>(\n                 def_id: DefId,\n                 source: MirSource<'tcx>,\n                 gen_ty: Ty<'tcx>,\n-                mir: &Mir<'tcx>,\n-                drop_clean: BasicBlock) -> Mir<'tcx> {\n+                mir: &Body<'tcx>,\n+                drop_clean: BasicBlock) -> Body<'tcx> {\n     let mut mir = mir.clone();\n \n     let source_info = source_info(&mir);\n@@ -734,7 +734,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     mir\n }\n \n-fn insert_term_block<'tcx>(mir: &mut Mir<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n+fn insert_term_block<'tcx>(mir: &mut Body<'tcx>, kind: TerminatorKind<'tcx>) -> BasicBlock {\n     let term_block = BasicBlock::new(mir.basic_blocks().len());\n     let source_info = source_info(mir);\n     mir.basic_blocks_mut().push(BasicBlockData {\n@@ -749,7 +749,7 @@ fn insert_term_block<'tcx>(mir: &mut Mir<'tcx>, kind: TerminatorKind<'tcx>) -> B\n }\n \n fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                mir: &mut Mir<'tcx>,\n+                                mir: &mut Body<'tcx>,\n                                 message: AssertMessage<'tcx>) -> BasicBlock {\n     let assert_block = BasicBlock::new(mir.basic_blocks().len());\n     let term = TerminatorKind::Assert {\n@@ -783,7 +783,7 @@ fn create_generator_resume_function<'a, 'tcx>(\n         transform: TransformVisitor<'a, 'tcx>,\n         def_id: DefId,\n         source: MirSource<'tcx>,\n-        mir: &mut Mir<'tcx>) {\n+        mir: &mut Body<'tcx>) {\n     // Poison the generator when it unwinds\n     for block in mir.basic_blocks_mut() {\n         let source_info = block.terminator().source_info;\n@@ -821,14 +821,14 @@ fn create_generator_resume_function<'a, 'tcx>(\n     dump_mir(tcx, None, \"generator_resume\", &0, source, mir, |_, _| Ok(()) );\n }\n \n-fn source_info<'a, 'tcx>(mir: &Mir<'tcx>) -> SourceInfo {\n+fn source_info<'a, 'tcx>(mir: &Body<'tcx>) -> SourceInfo {\n     SourceInfo {\n         span: mir.span,\n         scope: OUTERMOST_SOURCE_SCOPE,\n     }\n }\n \n-fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n+fn insert_clean_drop<'a, 'tcx>(mir: &mut Body<'tcx>) -> BasicBlock {\n     let return_block = insert_term_block(mir, TerminatorKind::Return);\n \n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n@@ -851,7 +851,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     drop_clean\n }\n \n-fn create_cases<'a, 'tcx, F>(mir: &mut Mir<'tcx>,\n+fn create_cases<'a, 'tcx, F>(mir: &mut Body<'tcx>,\n                           transform: &TransformVisitor<'a, 'tcx>,\n                           target: F) -> Vec<(usize, BasicBlock)>\n     where F: Fn(&SuspensionPoint) -> Option<BasicBlock> {\n@@ -895,7 +895,7 @@ impl MirPass for StateTransform {\n     fn run_pass<'a, 'tcx>(&self,\n                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     source: MirSource<'tcx>,\n-                    mir: &mut Mir<'tcx>) {\n+                    mir: &mut Body<'tcx>) {\n         let yield_ty = if let Some(yield_ty) = mir.yield_ty {\n             yield_ty\n         } else {\n@@ -959,7 +959,7 @@ impl MirPass for StateTransform {\n             new_ret_local,\n             discr_ty,\n         };\n-        transform.visit_mir(mir);\n+        transform.visit_body(mir);\n \n         // Update our MIR struct to reflect the changed we've made\n         mir.yield_ty = None;"}, {"sha": "0fac6868f57d3cd5900fbf51e5609a5b5d5325dd", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -41,7 +41,7 @@ impl MirPass for Inline {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n             Inliner { tcx, source }.run_pass(mir);\n         }\n@@ -54,7 +54,7 @@ struct Inliner<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Inliner<'a, 'tcx> {\n-    fn run_pass(&self, caller_mir: &mut Mir<'tcx>) {\n+    fn run_pass(&self, caller_mir: &mut Body<'tcx>) {\n         // Keep a queue of callsites to try inlining on. We take\n         // advantage of the fact that queries detect cycles here to\n         // allow us to try and fetch the fully optimized MIR of a\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n     fn get_valid_function_call(&self,\n                                bb: BasicBlock,\n                                bb_data: &BasicBlockData<'tcx>,\n-                               caller_mir: &Mir<'tcx>,\n+                               caller_mir: &Body<'tcx>,\n                                param_env: ParamEnv<'tcx>,\n     ) -> Option<CallSite<'tcx>> {\n         // Don't inline calls that are in cleanup blocks.\n@@ -204,7 +204,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n     fn consider_optimizing(&self,\n                            callsite: CallSite<'tcx>,\n-                           callee_mir: &Mir<'tcx>)\n+                           callee_mir: &Body<'tcx>)\n                            -> bool\n     {\n         debug!(\"consider_optimizing({:?})\", callsite);\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n     fn should_inline(&self,\n                      callsite: CallSite<'tcx>,\n-                     callee_mir: &Mir<'tcx>)\n+                     callee_mir: &Body<'tcx>)\n                      -> bool\n     {\n         debug!(\"should_inline({:?})\", callsite);\n@@ -394,8 +394,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n     fn inline_call(&self,\n                    callsite: CallSite<'tcx>,\n-                   caller_mir: &mut Mir<'tcx>,\n-                   mut callee_mir: Mir<'tcx>) -> bool {\n+                   caller_mir: &mut Body<'tcx>,\n+                   mut callee_mir: Body<'tcx>) -> bool {\n         let terminator = caller_mir[callsite.bb].terminator.take().unwrap();\n         match terminator.kind {\n             // FIXME: Handle inlining of diverging calls\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         &self,\n         args: Vec<Operand<'tcx>>,\n         callsite: &CallSite<'tcx>,\n-        caller_mir: &mut Mir<'tcx>,\n+        caller_mir: &mut Body<'tcx>,\n     ) -> Vec<Local> {\n         let tcx = self.tcx;\n \n@@ -601,7 +601,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         &self,\n         arg: Operand<'tcx>,\n         callsite: &CallSite<'tcx>,\n-        caller_mir: &mut Mir<'tcx>,\n+        caller_mir: &mut Body<'tcx>,\n     ) -> Local {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries."}, {"sha": "1b92b1acac55d6e46eb11960f330305473cac2a7", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,6 +1,7 @@\n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, ProjectionElem, Rvalue, Local};\n+use rustc::mir::{Constant, Location, Place, PlaceBase, Body, Operand, ProjectionElem, Rvalue,\n+    Local};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -14,7 +15,7 @@ impl MirPass for InstCombine {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         // We only run when optimizing MIR (at any level).\n         if tcx.sess.opts.debugging_opts.mir_opt_level == 0 {\n             return\n@@ -25,12 +26,12 @@ impl MirPass for InstCombine {\n         // `Place::ty()`).\n         let optimizations = {\n             let mut optimization_finder = OptimizationFinder::new(mir, tcx);\n-            optimization_finder.visit_mir(mir);\n+            optimization_finder.visit_body(mir);\n             optimization_finder.optimizations\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_mir(&mut InstCombineVisitor { optimizations }, mir);\n+        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations }, mir);\n     }\n }\n \n@@ -63,13 +64,13 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n \n /// Finds optimization opportunities on the MIR.\n struct OptimizationFinder<'b, 'a, 'tcx:'a+'b> {\n-    mir: &'b Mir<'tcx>,\n+    mir: &'b Body<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     optimizations: OptimizationList<'tcx>,\n }\n \n impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n-    fn new(mir: &'b Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n+    fn new(mir: &'b Body<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> OptimizationFinder<'b, 'a, 'tcx> {\n         OptimizationFinder {\n             mir,\n             tcx,"}, {"sha": "8c19637a955f158885aabacc815831111d391ec3", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -13,7 +13,7 @@ impl MirPass for Lower128Bit {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         let debugging_override = tcx.sess.opts.debugging_opts.lower_128bit_ops;\n         let target_default = tcx.sess.host.options.i128_lowering;\n         if !debugging_override.unwrap_or(target_default) {\n@@ -25,7 +25,7 @@ impl MirPass for Lower128Bit {\n }\n \n impl Lower128Bit {\n-    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+    fn lower_128bit_ops<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Body<'tcx>) {\n         let mut new_blocks = Vec::new();\n         let cur_len = mir.basic_blocks().len();\n "}, {"sha": "22b96a9db4750cfbc9033f1c8c8146ddcd7d4117", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,6 +1,6 @@\n use crate::build;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc::mir::{Mir, MirPhase, Promoted};\n+use rustc::mir::{Body, MirPhase, Promoted};\n use rustc::ty::{TyCtxt, InstanceDef};\n use rustc::ty::query::Providers;\n use rustc::ty::steal::Steal;\n@@ -95,12 +95,12 @@ fn mir_keys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, krate: CrateNum)\n     tcx.arena.alloc(set)\n }\n \n-fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+fn mir_built<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let mir = build::mir_build(tcx, def_id);\n     tcx.alloc_steal_mir(mir)\n }\n \n-/// Where a specific Mir comes from.\n+/// Where a specific `mir::Body` comes from.\n #[derive(Debug, Copy, Clone)]\n pub struct MirSource<'tcx> {\n     pub instance: InstanceDef<'tcx>,\n@@ -145,19 +145,19 @@ pub trait MirPass {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           source: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>);\n+                          mir: &mut Body<'tcx>);\n }\n \n pub fn run_passes(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &mut Mir<'tcx>,\n+    mir: &mut Body<'tcx>,\n     instance: InstanceDef<'tcx>,\n     mir_phase: MirPhase,\n     passes: &[&dyn MirPass],\n ) {\n     let phase_index = mir_phase.phase_index();\n \n-    let run_passes = |mir: &mut Mir<'tcx>, promoted| {\n+    let run_passes = |mir: &mut Body<'tcx>, promoted| {\n         if mir.phase >= mir_phase {\n             return;\n         }\n@@ -196,7 +196,7 @@ pub fn run_passes(\n     }\n }\n \n-fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n@@ -210,7 +210,7 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     tcx.alloc_steal_mir(mir)\n }\n \n-fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n+fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n@@ -227,8 +227,8 @@ fn mir_validated<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n     tcx.alloc_steal_mir(mir)\n }\n \n-fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Mir<'tcx> {\n-    // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n+fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Body<'tcx> {\n+    // `mir_borrowck` uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n     tcx.ensure().mir_borrowck(def_id);\n "}, {"sha": "719e22ca1502380b8139279c2afb6579d5f9aea3", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -12,14 +12,14 @@ impl MirPass for NoLandingPads {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         no_landing_pads(tcx, mir)\n     }\n }\n \n-pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+pub fn no_landing_pads<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n-        NoLandingPads.visit_mir(mir);\n+        NoLandingPads.visit_body(mir);\n     }\n }\n "}, {"sha": "4b95fbf4b7d2f500cb2a6b100e6eeef33c38d339", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -71,7 +71,7 @@ pub enum Candidate {\n struct TempCollector<'tcx> {\n     temps: IndexVec<Local, TempState>,\n     span: Span,\n-    mir: &'tcx Mir<'tcx>,\n+    mir: &'tcx Body<'tcx>,\n }\n \n impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n@@ -134,7 +134,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector<'tcx> {\n     }\n }\n \n-pub fn collect_temps(mir: &Mir<'_>,\n+pub fn collect_temps(mir: &Body<'_>,\n                      rpo: &mut ReversePostorder<'_, '_>) -> IndexVec<Local, TempState> {\n     let mut collector = TempCollector {\n         temps: IndexVec::from_elem(TempState::Undefined, &mir.local_decls),\n@@ -149,8 +149,8 @@ pub fn collect_temps(mir: &Mir<'_>,\n \n struct Promoter<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    source: &'a mut Mir<'tcx>,\n-    promoted: Mir<'tcx>,\n+    source: &'a mut Body<'tcx>,\n+    promoted: Body<'tcx>,\n     temps: &'a mut IndexVec<Local, TempState>,\n \n     /// If true, all nested temps are also kept in the\n@@ -369,7 +369,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n     }\n }\n \n-pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n+pub fn promote_candidates<'a, 'tcx>(mir: &mut Body<'tcx>,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     mut temps: IndexVec<Local, TempState>,\n                                     candidates: Vec<Candidate>) {\n@@ -393,13 +393,13 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         }\n \n \n-        // Declare return place local so that `Mir::new` doesn't complain.\n+        // Declare return place local so that `mir::Body::new` doesn't complain.\n         let initial_locals = iter::once(\n             LocalDecl::new_return_place(tcx.types.never, mir.span)\n         ).collect();\n \n         let promoter = Promoter {\n-            promoted: Mir::new(\n+            promoted: Body::new(\n                 IndexVec::new(),\n                 // FIXME: maybe try to filter this to avoid blowing up\n                 // memory usage?"}, {"sha": "a416792101f73d5d3ac57015b6b9ff93a1ecda2a", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -113,7 +113,7 @@ struct ConstCx<'a, 'tcx> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     mode: Mode,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n \n     per_local: PerQualif<BitSet<Local>>,\n }\n@@ -619,7 +619,7 @@ impl Deref for Checker<'a, 'tcx> {\n impl<'a, 'tcx> Checker<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            def_id: DefId,\n-           mir: &'a Mir<'tcx>,\n+           mir: &'a Body<'tcx>,\n            mode: Mode)\n            -> Self {\n         assert!(def_id.is_local());\n@@ -1431,7 +1431,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mir = &tcx.mir_const(def_id).borrow();\n \n     if mir.return_ty().references_error() {\n-        tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n+        tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: MIR had errors\");\n         return (1 << IsNotPromotable::IDX, tcx.arena.alloc(BitSet::new_empty(0)));\n     }\n \n@@ -1444,10 +1444,10 @@ impl MirPass for QualifyAndPromoteConstants {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         // There's not really any point in promoting errorful MIR.\n         if mir.return_ty().references_error() {\n-            tcx.sess.delay_span_bug(mir.span, \"QualifyAndPromoteConstants: Mir had errors\");\n+            tcx.sess.delay_span_bug(mir.span, \"QualifyAndPromoteConstants: MIR had errors\");\n             return;\n         }\n "}, {"sha": "4811380e238603bec257fef91a51a5595cf37ec4", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,7 +11,7 @@ type McfResult = Result<(), (Span, Cow<'static, str>)>;\n pub fn is_min_const_fn(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n ) -> McfResult {\n     let mut current = def_id;\n     loop {\n@@ -130,7 +130,7 @@ fn check_ty(\n \n fn check_rvalue(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     rvalue: &Rvalue<'tcx>,\n     span: Span,\n ) -> McfResult {\n@@ -210,7 +210,7 @@ fn check_rvalue(\n \n fn check_statement(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     statement: &Statement<'tcx>,\n ) -> McfResult {\n     let span = statement.source_info.span;\n@@ -250,7 +250,10 @@ fn check_operand(\n     }\n }\n \n-fn check_place(place: &Place<'tcx>, span: Span) -> McfResult {\n+fn check_place(\n+    place: &Place<'tcx>,\n+    span: Span,\n+) -> McfResult {\n     place.iterate(|place_base, place_projection| {\n         for proj in place_projection {\n             match proj.elem {\n@@ -277,7 +280,7 @@ fn check_place(place: &Place<'tcx>, span: Span) -> McfResult {\n \n fn check_terminator(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     terminator: &Terminator<'tcx>,\n ) -> McfResult {\n     let span = terminator.source_info.span;"}, {"sha": "42818a571151e1a25efb409ec527de390c8b6e8c", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,7 +11,7 @@ pub struct RemoveNoopLandingPads;\n \n pub fn remove_noop_landing_pads<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &mut Mir<'tcx>)\n+    mir: &mut Body<'tcx>)\n {\n     if tcx.sess.no_landing_pads() {\n         return\n@@ -25,7 +25,7 @@ impl MirPass for RemoveNoopLandingPads {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         remove_noop_landing_pads(tcx, mir);\n     }\n }\n@@ -34,7 +34,7 @@ impl RemoveNoopLandingPads {\n     fn is_nop_landing_pad(\n         &self,\n         bb: BasicBlock,\n-        mir: &Mir<'_>,\n+        mir: &Body<'_>,\n         nop_landing_pads: &BitSet<BasicBlock>,\n     ) -> bool {\n         for stmt in &mir[bb].statements {\n@@ -86,7 +86,7 @@ impl RemoveNoopLandingPads {\n         }\n     }\n \n-    fn remove_nop_landing_pads(&self, mir: &mut Mir<'_>) {\n+    fn remove_nop_landing_pads(&self, mir: &mut Body<'_>) {\n         // make sure there's a single resume block\n         let resume_block = {\n             let patch = MirPatch::new(mir);"}, {"sha": "2b3eb9e1edf307ce91a9bef2f3dbe70dee72ac10", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,7 +5,7 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{self, Mir, Location};\n+use rustc::mir::{self, Body, Location};\n use rustc_data_structures::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n \n@@ -26,7 +26,7 @@ pub struct SanityCheck;\n \n impl MirPass for SanityCheck {\n     fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          src: MirSource<'tcx>, mir: &mut Mir<'tcx>) {\n+                          src: MirSource<'tcx>, mir: &mut Body<'tcx>) {\n         let def_id = src.def_id();\n         if !tcx.has_attr(def_id, sym::rustc_mir) {\n             debug!(\"skipping rustc_peek::SanityCheck on {}\", tcx.def_path_str(def_id));\n@@ -85,7 +85,7 @@ impl MirPass for SanityCheck {\n /// expression form above, then that emits an error as well, but those\n /// errors are not intended to be used for unit tests.)\n pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                mir: &Mir<'tcx>,\n+                                                mir: &Body<'tcx>,\n                                                 def_id: DefId,\n                                                 _attributes: &[ast::Attribute],\n                                                 results: &DataflowResults<'tcx, O>)\n@@ -102,7 +102,7 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           mir: &Mir<'tcx>,\n+                           mir: &Body<'tcx>,\n                            results: &DataflowResults<'tcx, O>,\n                            bb: mir::BasicBlock) where\n     O: BitDenotation<'tcx, Idx=MovePathIndex> + HasMoveData<'tcx>"}, {"sha": "e7be238e850f22a70dfffa9eb72294c51691a9d0", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -44,7 +44,7 @@ impl SimplifyCfg {\n     }\n }\n \n-pub fn simplify_cfg(mir: &mut Mir<'_>) {\n+pub fn simplify_cfg(mir: &mut Body<'_>) {\n     CfgSimplifier::new(mir).simplify();\n     remove_dead_blocks(mir);\n \n@@ -60,7 +60,7 @@ impl MirPass for SimplifyCfg {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         debug!(\"SimplifyCfg({:?}) - simplifying {:?}\", self.label, mir);\n         simplify_cfg(mir);\n     }\n@@ -72,7 +72,7 @@ pub struct CfgSimplifier<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n-    pub fn new(mir: &'a mut Mir<'tcx>) -> Self {\n+    pub fn new(mir: &'a mut Body<'tcx>) -> Self {\n         let mut pred_count = IndexVec::from_elem(0u32, mir.basic_blocks());\n \n         // we can't use mir.predecessors() here because that counts\n@@ -263,7 +263,7 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n-pub fn remove_dead_blocks(mir: &mut Mir<'_>) {\n+pub fn remove_dead_blocks(mir: &mut Body<'_>) {\n     let mut seen = BitSet::new_empty(mir.basic_blocks().len());\n     for (bb, _) in traversal::preorder(mir) {\n         seen.insert(bb.index());\n@@ -299,9 +299,9 @@ impl MirPass for SimplifyLocals {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         let mut marker = DeclMarker { locals: BitSet::new_empty(mir.local_decls.len()) };\n-        marker.visit_mir(mir);\n+        marker.visit_body(mir);\n         // Return pointer and arguments are always live\n         marker.locals.insert(RETURN_PLACE);\n         for arg in mir.args_iter() {\n@@ -317,7 +317,7 @@ impl MirPass for SimplifyLocals {\n \n         let map = make_local_map(&mut mir.local_decls, marker.locals);\n         // Update references to all vars and tmps now\n-        LocalUpdater { map }.visit_mir(mir);\n+        LocalUpdater { map }.visit_body(mir);\n         mir.local_decls.shrink_to_fit();\n     }\n }"}, {"sha": "53949bcfcd707737340477b2943aba88c9915a52", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -22,7 +22,7 @@ impl MirPass for SimplifyBranches {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         for block in mir.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "ee1d2ca2a891ce1907e303fe7e730076d4ea97dd", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -40,18 +40,18 @@ impl MirPass for UniformArrayMoveOut {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(mir);\n         {\n             let mut visitor = UniformArrayMoveOutVisitor{mir, patch: &mut patch, tcx};\n-            visitor.visit_mir(mir);\n+            visitor.visit_body(mir);\n         }\n         patch.apply(mir);\n     }\n }\n \n struct UniformArrayMoveOutVisitor<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n+    mir: &'a Body<'tcx>,\n     patch: &'a mut MirPatch<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n@@ -165,14 +165,14 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource<'tcx>,\n-                          mir: &mut Mir<'tcx>) {\n+                          mir: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(mir);\n         {\n             let mut visitor = RestoreDataCollector {\n                 locals_use: IndexVec::from_elem(LocalUse::new(), &mir.local_decls),\n                 candidates: vec![],\n             };\n-            visitor.visit_mir(mir);\n+            visitor.visit_body(mir);\n \n             for candidate in &visitor.candidates {\n                 let statement = &mir[candidate.block].statements[candidate.statement_index];\n@@ -254,7 +254,7 @@ impl RestoreSubsliceArrayMoveOut {\n     }\n \n     fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n-                                     mir: &'a Mir<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n+                                     mir: &'a Body<'tcx>) -> Option<(u32, &'a Place<'tcx>)> {\n         if let Some(location) = local_use.first_use {\n             let block = &mir[location.block];\n             if block.statements.len() > location.statement_index {"}, {"sha": "c8804dfbaf2619dd5f77099d85c14e713f4d3a13", "filename": "src/librustc_mir/util/collect_writes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fcollect_writes.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::{Local, Location};\n-use rustc::mir::Mir;\n+use rustc::mir::Body;\n use rustc::mir::visit::PlaceContext;\n use rustc::mir::visit::Visitor;\n \n@@ -9,10 +9,10 @@ crate trait FindAssignments {\n     fn find_assignments(&self, local: Local) -> Vec<Location>;\n }\n \n-impl<'tcx> FindAssignments for Mir<'tcx>{\n+impl<'tcx> FindAssignments for Body<'tcx>{\n     fn find_assignments(&self, local: Local) -> Vec<Location>{\n             let mut visitor = FindLocalAssignmentVisitor{ needle: local, locations: vec![]};\n-            visitor.visit_mir(self);\n+            visitor.visit_body(self);\n             visitor.locations\n     }\n }"}, {"sha": "ba0190756c54277c43b1f0906d7b2ee5c87c4bc2", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,6 +1,6 @@\n //! Def-use analysis.\n \n-use rustc::mir::{Local, Location, Mir};\n+use rustc::mir::{Local, Location, Body};\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::mem;\n@@ -21,19 +21,19 @@ pub struct Use {\n }\n \n impl DefUseAnalysis {\n-    pub fn new(mir: &Mir<'_>) -> DefUseAnalysis {\n+    pub fn new(mir: &Body<'_>) -> DefUseAnalysis {\n         DefUseAnalysis {\n             info: IndexVec::from_elem_n(Info::new(), mir.local_decls.len()),\n         }\n     }\n \n-    pub fn analyze(&mut self, mir: &Mir<'_>) {\n+    pub fn analyze(&mut self, mir: &Body<'_>) {\n         self.clear();\n \n         let mut finder = DefUseFinder {\n             info: mem::replace(&mut self.info, IndexVec::new()),\n         };\n-        finder.visit_mir(mir);\n+        finder.visit_body(mir);\n         self.info = finder.info\n     }\n \n@@ -47,7 +47,7 @@ impl DefUseAnalysis {\n         &self.info[local]\n     }\n \n-    fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'_>, mut callback: F)\n+    fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Body<'_>, mut callback: F)\n                                where F: for<'a> FnMut(&'a mut Local,\n                                                       PlaceContext,\n                                                       Location) {\n@@ -61,7 +61,7 @@ impl DefUseAnalysis {\n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          mir: &mut Mir<'_>,\n+                                          mir: &mut Body<'_>,\n                                           new_local: Local) {\n         self.mutate_defs_and_uses(local, mir, |local, _, _| *local = new_local)\n     }\n@@ -123,7 +123,7 @@ struct MutateUseVisitor<F> {\n }\n \n impl<F> MutateUseVisitor<F> {\n-    fn new(query: Local, callback: F, _: &Mir<'_>)\n+    fn new(query: Local, callback: F, _: &Body<'_>)\n            -> MutateUseVisitor<F>\n            where F: for<'a> FnMut(&'a mut Local, PlaceContext, Location) {\n         MutateUseVisitor {"}, {"sha": "076ba60c6441c5da540fda8630424784236511de", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -74,7 +74,7 @@ pub trait DropElaborator<'a, 'tcx: 'a> : fmt::Debug {\n     type Path : Copy + fmt::Debug;\n \n     fn patch(&mut self) -> &mut MirPatch<'tcx>;\n-    fn mir(&self) -> &'a Mir<'tcx>;\n+    fn mir(&self) -> &'a Body<'tcx>;\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n "}, {"sha": "20d92da9ba330e86e6635e145fbf1f3b221e4edd", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -34,7 +34,7 @@ pub fn graphviz_safe_def_name(def_id: DefId) -> String {\n /// Write a graphviz DOT graph of the MIR.\n pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n                                       def_id: DefId,\n-                                      mir: &Mir<'_>,\n+                                      mir: &Body<'_>,\n                                       w: &mut W) -> io::Result<()>\n     where W: Write\n {\n@@ -68,7 +68,7 @@ pub fn write_mir_fn_graphviz<'tcx, W>(tcx: TyCtxt<'_, '_, 'tcx>,\n /// `init` and `fini` are callbacks for emitting additional rows of\n /// data (using HTML enclosed with `<tr>` in the emitted text).\n pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n-                                              mir: &Mir<'_>,\n+                                              mir: &Body<'_>,\n                                               w: &mut W,\n                                               num_cols: u32,\n                                               init: INIT,\n@@ -110,7 +110,7 @@ pub fn write_node_label<W: Write, INIT, FINI>(block: BasicBlock,\n }\n \n /// Write a graphviz DOT node for the given basic block.\n-fn write_node<W: Write>(block: BasicBlock, mir: &Mir<'_>, w: &mut W) -> io::Result<()> {\n+fn write_node<W: Write>(block: BasicBlock, mir: &Body<'_>, w: &mut W) -> io::Result<()> {\n     // Start a new node with the label to follow, in one of DOT's pseudo-HTML tables.\n     write!(w, r#\"    {} [shape=\"none\", label=<\"#, node(block))?;\n     write_node_label(block, mir, w, 1, |_| Ok(()), |_| Ok(()))?;\n@@ -119,7 +119,7 @@ fn write_node<W: Write>(block: BasicBlock, mir: &Mir<'_>, w: &mut W) -> io::Resu\n }\n \n /// Write graphviz DOT edges with labels between the given basic block and all of its successors.\n-fn write_edges<W: Write>(source: BasicBlock, mir: &Mir<'_>, w: &mut W) -> io::Result<()> {\n+fn write_edges<W: Write>(source: BasicBlock, mir: &Body<'_>, w: &mut W) -> io::Result<()> {\n     let terminator = mir[source].terminator();\n     let labels = terminator.kind.fmt_successor_labels();\n \n@@ -135,7 +135,7 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir<'_>, w: &mut W) -> io::Re\n /// all the variables and temporaries.\n fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                                def_id: DefId,\n-                                               mir: &Mir<'_>,\n+                                               mir: &Body<'_>,\n                                                w: &mut W)\n                                                -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.def_path_str(def_id)))?;"}, {"sha": "a3317d3956be43015ffbc99766df5c963fd0beda", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -57,7 +57,7 @@ pub struct LivenessResult {\n /// Computes which local variables are live within the given function\n /// `mir`, including drops.\n pub fn liveness_of_locals<'tcx>(\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n ) -> LivenessResult {\n     let num_live_vars = mir.local_decls.len();\n \n@@ -258,7 +258,7 @@ pub fn dump_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     result: &LivenessResult,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n@@ -276,7 +276,7 @@ fn dump_matched_mir_node<'a, 'tcx>(\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     result: &LivenessResult,\n ) {\n     let mut file_path = PathBuf::new();\n@@ -297,7 +297,7 @@ fn dump_matched_mir_node<'a, 'tcx>(\n pub fn write_mir_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     w: &mut dyn Write,\n     result: &LivenessResult,\n ) -> io::Result<()> {"}, {"sha": "974dda867bc9df5e7a7f0b5fef6dc6e337ee6e98", "filename": "src/librustc_mir/util/patch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpatch.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -17,7 +17,7 @@ pub struct MirPatch<'tcx> {\n }\n \n impl<'tcx> MirPatch<'tcx> {\n-    pub fn new(mir: &Mir<'tcx>) -> Self {\n+    pub fn new(mir: &Body<'tcx>) -> Self {\n         let mut result = MirPatch {\n             patch_map: IndexVec::from_elem(None, mir.basic_blocks()),\n             new_blocks: vec![],\n@@ -75,7 +75,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.patch_map[bb].is_some()\n     }\n \n-    pub fn terminator_loc(&self, mir: &Mir<'tcx>, bb: BasicBlock) -> Location {\n+    pub fn terminator_loc(&self, mir: &Body<'tcx>, bb: BasicBlock) -> Location {\n         let offset = match bb.index().checked_sub(mir.basic_blocks().len()) {\n             Some(index) => self.new_blocks[index].statements.len(),\n             None => mir[bb].statements.len()\n@@ -127,7 +127,7 @@ impl<'tcx> MirPatch<'tcx> {\n         self.make_nop.push(loc);\n     }\n \n-    pub fn apply(self, mir: &mut Mir<'tcx>) {\n+    pub fn apply(self, mir: &mut Body<'tcx>) {\n         debug!(\"MirPatch: make nops at: {:?}\", self.make_nop);\n         for loc in self.make_nop {\n             mir.make_statement_nop(loc);\n@@ -177,7 +177,7 @@ impl<'tcx> MirPatch<'tcx> {\n         }\n     }\n \n-    pub fn source_info_for_location(&self, mir: &Mir<'_>, loc: Location) -> SourceInfo {\n+    pub fn source_info_for_location(&self, mir: &Body<'_>, loc: Location) -> SourceInfo {\n         let data = match loc.block.index().checked_sub(mir.basic_blocks().len()) {\n             Some(new) => &self.new_blocks[new],\n             None => &mir[loc.block]"}, {"sha": "aec8ce7ced6c7609ee3eb62a6dc4b439c6597d4d", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -68,7 +68,7 @@ pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n     pass_name: &str,\n     disambiguator: &dyn Display,\n     source: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     extra_data: F,\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n@@ -124,7 +124,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n     node_path: &str,\n     disambiguator: &dyn Display,\n     source: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     mut extra_data: F,\n ) where\n     F: FnMut(PassWhere, &mut dyn Write) -> io::Result<()>,\n@@ -282,7 +282,7 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     extra_data: &mut F,\n     w: &mut dyn Write,\n ) -> io::Result<()>\n@@ -306,7 +306,7 @@ where\n pub fn write_basic_block<'cx, 'gcx, 'tcx, F>(\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     block: BasicBlock,\n-    mir: &Mir<'tcx>,\n+    mir: &Body<'tcx>,\n     extra_data: &mut F,\n     w: &mut dyn Write,\n ) -> io::Result<()>\n@@ -464,7 +464,7 @@ fn comment(tcx: TyCtxt<'_, '_, '_>, SourceInfo { span, scope }: SourceInfo) -> S\n /// Prints local variables in a scope tree.\n fn write_scope_tree(\n     tcx: TyCtxt<'_, '_, '_>,\n-    mir: &Mir<'_>,\n+    mir: &Body<'_>,\n     scope_tree: &FxHashMap<SourceScope, Vec<SourceScope>>,\n     w: &mut dyn Write,\n     parent: SourceScope,\n@@ -541,7 +541,7 @@ fn write_scope_tree(\n pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     src: MirSource<'tcx>,\n-    mir: &Mir<'_>,\n+    mir: &Body<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n@@ -572,7 +572,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n fn write_mir_sig(\n     tcx: TyCtxt<'_, '_, '_>,\n     src: MirSource<'tcx>,\n-    mir: &Mir<'_>,\n+    mir: &Body<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n     use rustc::hir::def::DefKind;\n@@ -629,7 +629,7 @@ fn write_mir_sig(\n     Ok(())\n }\n \n-fn write_user_type_annotations(mir: &Mir<'_>, w: &mut dyn Write) -> io::Result<()> {\n+fn write_user_type_annotations(mir: &Body<'_>, w: &mut dyn Write) -> io::Result<()> {\n     if !mir.user_type_annotations.is_empty() {\n         writeln!(w, \"| User Type Annotations\")?;\n     }"}, {"sha": "96c647ca31e6fca339194abb83faba601471d514", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -411,7 +411,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     }\n \n     fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {\n-        let string = format!(\"{:?}\", self.infcx.resolve_type_vars_if_possible(value));\n+        let string = format!(\"{:?}\", self.infcx.resolve_vars_if_possible(value));\n         Box::new(string)\n     }\n "}, {"sha": "c1f14cd3f8ed51e182382e2fc33ede2103625ca7", "filename": "src/librustc_traits/chalk_context/program_clauses/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -57,7 +57,7 @@ impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n         use rustc::traits::WhereClause::*;\n         use rustc::infer::canonical::OriginalQueryValues;\n \n-        let goal = self.infcx.resolve_type_vars_if_possible(goal);\n+        let goal = self.infcx.resolve_vars_if_possible(goal);\n \n         debug!(\"program_clauses(goal = {:?})\", goal);\n "}, {"sha": "f1b8588790b72a4fe3fbbdb3c2399b17c95e6594", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -111,8 +111,8 @@ impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n     ) -> Fallible<ChalkExClause<'tcx>> {\n         debug!(\n             \"apply_answer_subst(ex_clause = {:?}, selected_goal = {:?})\",\n-            self.infcx.resolve_type_vars_if_possible(&ex_clause),\n-            self.infcx.resolve_type_vars_if_possible(selected_goal)\n+            self.infcx.resolve_vars_if_possible(&ex_clause),\n+            self.infcx.resolve_vars_if_possible(selected_goal)\n         );\n \n         let (answer_subst, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars("}, {"sha": "73bb3fb5b9a2de6972ccf3e3b86f1a0d4091b250", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -121,7 +121,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                        let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                        let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n                         let mut components = smallvec![];\n                         tcx.push_outlives_components(ty_a, &mut components);\n                         implied_bounds_from_components(r_b, components)"}, {"sha": "24fa5e97752a67e84e526e67219402bdb473876f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -36,7 +36,7 @@ fn normalize_ty_after_erasing_regions<'tcx>(\n                     None,\n                 );\n \n-                let normalized_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n+                let normalized_value = infcx.resolve_vars_if_possible(&normalized_value);\n                 let normalized_value = infcx.tcx.erase_regions(&normalized_value);\n                 tcx.lift_to_global(&normalized_value).unwrap()\n             }"}, {"sha": "5a84e0cb85a6ec0643c7153be6ee40daf9731ffc", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // Now that we know the types can be unified we find the unified type and use\n                 // it to type the entire expression.\n-                let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n+                let common_type = self.resolve_vars_if_possible(&lhs_ty);\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype_pat(pat.span, expected, lhs_ty, discrim_span);"}, {"sha": "38c3ee776369aa49c750803067fef773a4e08f46", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -98,7 +98,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n             body_id,\n             param_env,\n             steps: vec![],\n-            cur_ty: infcx.resolve_type_vars_if_possible(&base_ty),\n+            cur_ty: infcx.resolve_vars_if_possible(&base_ty),\n             obligations: vec![],\n             at_start: true,\n             include_raw_pointers: false,\n@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                ty, normalized_ty, obligations);\n         self.obligations.extend(obligations);\n \n-        Some(self.infcx.resolve_type_vars_if_possible(&normalized_ty))\n+        Some(self.infcx.resolve_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an\n@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     /// Returns the final type we ended up with, which may well be an\n     /// inference variable (we will resolve it first, if possible).\n     pub fn maybe_ambiguous_final_ty(&self) -> Ty<'tcx> {\n-        self.infcx.resolve_type_vars_if_possible(&self.cur_ty)\n+        self.infcx.resolve_vars_if_possible(&self.cur_ty)\n     }\n \n     pub fn step_count(&self) -> usize {"}, {"sha": "f8cad733ca1c87abcc292ab32d8998dc58d3f52f", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"pointer_kind({:?}, {:?})\", t, span);\n \n-        let t = self.resolve_type_vars_if_possible(&t);\n+        let t = self.resolve_vars_if_possible(&t);\n \n         if t.references_error() {\n             return Err(ErrorReported);\n@@ -334,7 +334,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = type_error_struct!(fcx.tcx.sess, self.span, self.expr_ty, E0620,\n                                          \"cast to unsized type: `{}` as `{}`\",\n-                                         fcx.resolve_type_vars_if_possible(&self.expr_ty),\n+                                         fcx.resolve_vars_if_possible(&self.expr_ty),\n                                          tstr);\n         match self.expr_ty.sty {\n             ty::Ref(_, _, mt) => {"}, {"sha": "419f61b0ee2c061444fcedd18eeb585f45eb9a7b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let input_tys = if is_fn {\n             let arg_param_ty = trait_ref.skip_binder().substs.type_at(1);\n-            let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n+            let arg_param_ty = self.resolve_vars_if_possible(&arg_param_ty);\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n             match arg_param_ty.sty {\n@@ -295,7 +295,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let ret_param_ty = projection.skip_binder().ty;\n-        let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n+        let ret_param_ty = self.resolve_vars_if_possible(&ret_param_ty);\n         debug!(\"deduce_sig_from_projection: ret_param_ty={:?}\", ret_param_ty);\n \n         let sig = self.tcx.mk_fn_sig("}, {"sha": "d64be24f7538f548fbb0eedc44b8110bf1a623bf", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -575,7 +575,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // Uncertain or unimplemented.\n                 Ok(None) => {\n                     if trait_ref.def_id() == unsize_did {\n-                        let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                        let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n                         let self_ty = trait_ref.skip_binder().self_ty();\n                         let unsize_ty = trait_ref.skip_binder().input_types().nth(1).unwrap();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_ref);"}, {"sha": "3785c3c8684b4961ba835a0636c8e9fcb1e0cf8c", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> InteriorVisitor<'a, 'gcx, 'tcx> {\n         });\n \n         if let Some(yield_span) = live_across_yield {\n-            let ty = self.fcx.resolve_type_vars_if_possible(&ty);\n+            let ty = self.fcx.resolve_vars_if_possible(&ty);\n \n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n                    expr, scope, ty, self.expr_count, yield_span);"}, {"sha": "493486321ac2fed0e8dacfb92024984370e0617a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -511,7 +511,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n-        let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n+        let base_ty = self.resolve_vars_if_possible(&base_ty);\n \n         // Need to deref because overloaded place ops take self by-reference.\n         let base_ty = base_ty.builtin_deref(false)"}, {"sha": "213d53cf48254a38ca10619e1c8d2e6a0f10cc13", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     scope: ProbeScope)\n                     -> probe::PickResult<'tcx> {\n         let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        let self_ty = self.resolve_vars_if_possible(&self_ty);\n         self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n                             self_ty, call_expr.hir_id, scope)\n     }"}, {"sha": "d78e013708277f15f2a1260df49e8b3f28a2dce5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1338,7 +1338,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                             // and point at it rather than reporting the entire\n                             // trait-ref?\n                             result = ProbeResult::NoMatch;\n-                            let trait_ref = self.resolve_type_vars_if_possible(&trait_ref);\n+                            let trait_ref = self.resolve_vars_if_possible(&trait_ref);\n                             possibly_unsatisfied_predicates.push(trait_ref);\n                         }\n                     }\n@@ -1351,7 +1351,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n             // Evaluate those obligations to see if they might possibly hold.\n             for o in candidate_obligations.into_iter().chain(sub_obligations) {\n-                let o = self.resolve_type_vars_if_possible(&o);\n+                let o = self.resolve_vars_if_possible(&o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n                     if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n@@ -1364,7 +1364,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if let (Some(return_ty), Some(xform_ret_ty)) =\n                     (self.return_type, probe.xform_ret_ty)\n                 {\n-                    let xform_ret_ty = self.resolve_type_vars_if_possible(&xform_ret_ty);\n+                    let xform_ret_ty = self.resolve_vars_if_possible(&xform_ret_ty);\n                     debug!(\"comparing return_ty {:?} with xform ret ty {:?}\",\n                            return_ty,\n                            probe.xform_ret_ty);"}, {"sha": "d2fcb987bc2d853958a187c9b1778a64bb4735d9", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_type_vars_if_possible(&rcvr_ty);\n+                let actual = self.resolve_vars_if_possible(&rcvr_ty);\n                 let ty_str = self.ty_to_string(actual);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {"}, {"sha": "8701d751f2d91aefb234162a2282496254aab30a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -330,13 +330,13 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n         match self {\n             NoExpectation => NoExpectation,\n             ExpectCastableToType(t) => {\n-                ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectCastableToType(fcx.resolve_vars_if_possible(&t))\n             }\n             ExpectHasType(t) => {\n-                ExpectHasType(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectHasType(fcx.resolve_vars_if_possible(&t))\n             }\n             ExpectRvalueLikeUnsized(t) => {\n-                ExpectRvalueLikeUnsized(fcx.resolve_type_vars_if_possible(&t))\n+                ExpectRvalueLikeUnsized(fcx.resolve_vars_if_possible(&t))\n             }\n         }\n     }\n@@ -2067,7 +2067,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n-    /// version (resolve_type_vars_if_possible), this version will\n+    /// version (resolve_vars_if_possible), this version will\n     /// also select obligations if it seems useful, in an effort\n     /// to get more type information.\n     fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -2080,7 +2080,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n-        ty = self.resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(&ty);\n         if !ty.has_infer_types() {\n             debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n@@ -2091,7 +2091,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         self.select_obligations_where_possible(false);\n-        ty = self.resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_vars_if_possible(&ty);\n \n         debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n         ty\n@@ -2127,7 +2127,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     #[inline]\n     pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n-               id, self.resolve_type_vars_if_possible(&ty), self.tag());\n+               id, self.resolve_vars_if_possible(&ty), self.tag());\n         self.tables.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n@@ -2950,9 +2950,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         } else {\n             // is the missing argument of type `()`?\n             let sugg_unit = if expected_arg_tys.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&expected_arg_tys[0]).is_unit()\n+                self.resolve_vars_if_possible(&expected_arg_tys[0]).is_unit()\n             } else if fn_inputs.len() == 1 && supplied_arg_count == 0 {\n-                self.resolve_type_vars_if_possible(&fn_inputs[0]).is_unit()\n+                self.resolve_vars_if_possible(&fn_inputs[0]).is_unit()\n             } else {\n                 false\n             };\n@@ -3063,7 +3063,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     ty::FnDef(..) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n+                        let ptr_ty = self.resolve_vars_if_possible(&ptr_ty);\n                         variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n                     }\n                     _ => {}\n@@ -3253,7 +3253,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Record all the argument types, with the substitutions\n             // produced from the above subtyping unification.\n             Ok(formal_args.iter().map(|ty| {\n-                self.resolve_type_vars_if_possible(ty)\n+                self.resolve_vars_if_possible(ty)\n             }).collect())\n         }).unwrap_or_default();\n         debug!(\"expected_inputs_for_expected_output(formal={:?} -> {:?}, expected={:?} -> {:?})\",\n@@ -4333,9 +4333,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Find the type of `e`. Supply hints based on the type we are casting to,\n                 // if appropriate.\n                 let t_cast = self.to_ty_saving_user_provided_ty(t);\n-                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n                 let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-                let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n+                let t_cast = self.resolve_vars_if_possible(&t_cast);\n \n                 // Eagerly check for some obvious errors.\n                 if t_expr.references_error() || t_cast.references_error() {"}, {"sha": "0bab63582aaa1830dad70f7819b96036a1192b79", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 method.sig.output()\n             }\n             Err(()) => {\n-                let actual = self.resolve_type_vars_if_possible(&operand_ty);\n+                let actual = self.resolve_vars_if_possible(&operand_ty);\n                 if !actual.references_error() {\n                     let mut err = struct_span_err!(self.tcx.sess, ex.span, E0600,\n                                      \"cannot apply unary operator `{}` to type `{}`\","}, {"sha": "62c9c7c8b1c37d9446dd2c565d5f79e620a9a2e1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_type_vars_if_possible(&unresolved_ty)\n+        self.resolve_vars_if_possible(&unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node."}, {"sha": "a856013b719fea3708e40c6f5d60454fadb7f950", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -138,7 +138,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             hir::ExprKind::Unary(hir::UnNeg, ref inner)\n             | hir::ExprKind::Unary(hir::UnNot, ref inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n-                let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n+                let inner_ty = self.fcx.resolve_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n@@ -149,10 +149,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n             | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n-                let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n+                let lhs_ty = self.fcx.resolve_vars_if_possible(&lhs_ty);\n \n                 let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n-                let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n+                let rhs_ty = self.fcx.resolve_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n@@ -192,7 +192,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             // All valid indexing looks like this; might encounter non-valid indexes at this point\n             if let ty::Ref(_, base_ty, _) = tables.expr_ty_adjusted(&base).sty {\n                 let index_ty = tables.expr_ty_adjusted(&index);\n-                let index_ty = self.fcx.resolve_type_vars_if_possible(&index_ty);\n+                let index_ty = self.fcx.resolve_vars_if_possible(&index_ty);\n \n                 if base_ty.builtin_index().is_some() && index_ty == self.fcx.tcx.types.usize {\n                     // Remove the method call record"}, {"sha": "d0e56acc8fb272a6833659db20a9fd2041aa4122", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1162,6 +1162,41 @@ mod tests {\n         assert_eq!(reader.get_ref().pos, expected);\n     }\n \n+    #[test]\n+    fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n+        // gimmick reader that returns Err after first seek\n+        struct ErrAfterFirstSeekReader {\n+            first_seek: bool,\n+        }\n+        impl Read for ErrAfterFirstSeekReader {\n+            fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+                for x in &mut *buf {\n+                    *x = 0;\n+                }\n+                Ok(buf.len())\n+            }\n+        }\n+        impl Seek for ErrAfterFirstSeekReader {\n+            fn seek(&mut self, _: SeekFrom) -> io::Result<u64> {\n+                if self.first_seek {\n+                    self.first_seek = false;\n+                    Ok(0)\n+                } else {\n+                    Err(io::Error::new(io::ErrorKind::Other, \"oh no!\"))\n+                }\n+            }\n+        }\n+\n+        let mut reader = BufReader::with_capacity(5, ErrAfterFirstSeekReader { first_seek: true });\n+        assert_eq!(reader.fill_buf().ok(), Some(&[0, 0, 0, 0, 0][..]));\n+\n+        // The following seek will require two underlying seeks.  The first will\n+        // succeed but the second will fail.  This should still invalidate the\n+        // buffer.\n+        assert!(reader.seek(SeekFrom::Current(i64::min_value())).is_err());\n+        assert_eq!(reader.buffer().len(), 0);\n+    }\n+\n     #[test]\n     fn test_buffered_writer() {\n         let inner = Vec::new();"}, {"sha": "4ddc1f09a319bab3c02a2ce518a6e6b3e6d00d55", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -27,7 +27,7 @@ pub trait PermissionsExt {\n     ///     let metadata = f.metadata()?;\n     ///     let permissions = metadata.permissions();\n     ///\n-    ///     println!(\"permissions: {}\", permissions.mode());\n+    ///     println!(\"permissions: {:o}\", permissions.mode());\n     ///     Ok(())\n     /// }\n     /// ```"}, {"sha": "c033c60cbe9e1b8ce15a370c8bb142b50c99131c", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -238,7 +238,7 @@ pub trait PermissionsExt {\n     ///     let metadata = f.metadata()?;\n     ///     let permissions = metadata.permissions();\n     ///\n-    ///     println!(\"permissions: {}\", permissions.mode());\n+    ///     println!(\"permissions: {:o}\", permissions.mode());\n     ///     Ok(()) }\n     /// ```\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]"}, {"sha": "e2171a84e23002b154160472fa8d3dd7ec6eb447", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -727,6 +727,11 @@ impl SourceMap {\n         debug!(\"find_width_of_character_at_span: local_begin=`{:?}`, local_end=`{:?}`\",\n                local_begin, local_end);\n \n+        if local_begin.sf.start_pos != local_end.sf.start_pos {\n+            debug!(\"find_width_of_character_at_span: begin and end are in different files\");\n+            return 1;\n+        }\n+\n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n         debug!(\"find_width_of_character_at_span: start_index=`{:?}`, end_index=`{:?}`\","}, {"sha": "96c71b084b13e941688d9a7f99738fddcbaf7cbf", "filename": "src/test/run-pass/regions/regions-lub-ref-ref-rc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Frun-pass%2Fregions%2Fregions-lub-ref-ref-rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Frun-pass%2Fregions%2Fregions-lub-ref-ref-rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions%2Fregions-lub-ref-ref-rc.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,16 +11,16 @@\n use std::rc::Rc;\n \n #[derive(Clone)]\n-enum CachedMir<'mir> {\n+enum Cached<'mir> {\n     Ref(&'mir String),\n     Owned(Rc<String>),\n }\n \n-impl<'mir> CachedMir<'mir> {\n+impl<'mir> Cached<'mir> {\n     fn get_ref<'a>(&'a self) -> &'a String {\n         match *self {\n-            CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => &rc,\n+            Cached::Ref(r) => r,\n+            Cached::Owned(ref rc) => &rc,\n         }\n     }\n }"}, {"sha": "2696aea5e89931bfa7e6287a80fe4db5464f3e36", "filename": "src/test/ui/array-break-length.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Farray-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Farray-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,9 +1,11 @@\n fn main() {\n     loop {\n         |_: [_; break]| {} //~ ERROR: `break` outside of loop\n+        //~^ ERROR mismatched types\n     }\n \n     loop {\n         |_: [_; continue]| {} //~ ERROR: `continue` outside of loop\n+        //~^ ERROR mismatched types\n     }\n }"}, {"sha": "0e0dc8f623e6815cd98feaae98cf9605198ea1cf", "filename": "src/test/ui/array-break-length.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Farray-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Farray-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-break-length.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -5,11 +5,30 @@ LL |         |_: [_; break]| {}\n    |                 ^^^^^ cannot break outside of a loop\n \n error[E0268]: `continue` outside of loop\n-  --> $DIR/array-break-length.rs:7:17\n+  --> $DIR/array-break-length.rs:8:17\n    |\n LL |         |_: [_; continue]| {}\n    |                 ^^^^^^^^ cannot break outside of a loop\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/array-break-length.rs:3:9\n+   |\n+LL |         |_: [_; break]| {}\n+   |         ^^^^^^^^^^^^^^^^^^ expected (), found closure\n+   |\n+   = note: expected type `()`\n+              found type `[closure@$DIR/array-break-length.rs:3:9: 3:27]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/array-break-length.rs:8:9\n+   |\n+LL |         |_: [_; continue]| {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^ expected (), found closure\n+   |\n+   = note: expected type `()`\n+              found type `[closure@$DIR/array-break-length.rs:8:9: 8:30]`\n+\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0268`.\n+Some errors have detailed explanations: E0268, E0308.\n+For more information about an error, try `rustc --explain E0268`."}, {"sha": "a7f16d70ba8600d083f246acc285f0f9c6fb24d7", "filename": "src/test/ui/closures/closure-array-break-length.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -2,6 +2,8 @@ fn main() {\n     |_: [_; continue]| {}; //~ ERROR: `continue` outside of loop\n \n     while |_: [_; continue]| {} {} //~ ERROR: `continue` outside of loop\n+    //~^ ERROR mismatched types\n \n     while |_: [_; break]| {} {} //~ ERROR: `break` outside of loop\n+    //~^ ERROR mismatched types\n }"}, {"sha": "46fbd3e0fae0be8d7b980ff9971850bc3d23b502", "filename": "src/test/ui/closures/closure-array-break-length.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-array-break-length.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,11 +11,30 @@ LL |     while |_: [_; continue]| {} {}\n    |                   ^^^^^^^^ cannot break outside of a loop\n \n error[E0268]: `break` outside of loop\n-  --> $DIR/closure-array-break-length.rs:6:19\n+  --> $DIR/closure-array-break-length.rs:7:19\n    |\n LL |     while |_: [_; break]| {} {}\n    |                   ^^^^^ cannot break outside of a loop\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/closure-array-break-length.rs:4:11\n+   |\n+LL |     while |_: [_; continue]| {} {}\n+   |           ^^^^^^^^^^^^^^^^^^^^^ expected bool, found closure\n+   |\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/closure-array-break-length.rs:4:11: 4:32]`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/closure-array-break-length.rs:7:11\n+   |\n+LL |     while |_: [_; break]| {} {}\n+   |           ^^^^^^^^^^^^^^^^^^ expected bool, found closure\n+   |\n+   = note: expected type `bool`\n+              found type `[closure@$DIR/closure-array-break-length.rs:7:11: 7:29]`\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0268`.\n+Some errors have detailed explanations: E0268, E0308.\n+For more information about an error, try `rustc --explain E0268`."}, {"sha": "9a11bd3d0313a5802d6c9a292d6bd792be8cbd97", "filename": "src/test/ui/const-generics/broken-mir-1.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+pub trait Foo {\n+    fn foo(&self);\n+}\n+\n+\n+impl<T, const N: usize> Foo for [T; N] {\n+    fn foo(&self) {\n+        let _ = &self;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "55dc7fcb7cc722a2e08cb88bbfc78ba5cac0f6f5", "filename": "src/test/ui/const-generics/broken-mir-1.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-1.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/broken-mir-1.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "fb9a63ea738fa8767a768be2ec300bc50bb336a4", "filename": "src/test/ui/const-generics/broken-mir-2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,9 @@\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt::Debug;\n+\n+#[derive(Debug)]\n+struct S<T: Debug, const N: usize>([T; N]); //~ ERROR `[T; _]` doesn't implement `std::fmt::Debug`\n+\n+fn main() {}"}, {"sha": "fb9b88bde0a259ebc88e6822c61740b98d1d5b90", "filename": "src/test/ui/const-generics/broken-mir-2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fbroken-mir-2.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/broken-mir-2.rs:1:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+\n+error[E0277]: `[T; _]` doesn't implement `std::fmt::Debug`\n+  --> $DIR/broken-mir-2.rs:7:36\n+   |\n+LL | struct S<T: Debug, const N: usize>([T; N]);\n+   |                                    ^^^^^^ `[T; _]` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n+   |\n+   = help: the trait `std::fmt::Debug` is not implemented for `[T; _]`\n+   = note: required because of the requirements on the impl of `std::fmt::Debug` for `&[T; _]`\n+   = note: required for the cast to the object type `dyn std::fmt::Debug`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "26496ec4a90b9d7f80d82cc7dac1547be37249c1", "filename": "src/test/ui/const-generics/cannot-infer-type-for-const-param.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -8,4 +8,5 @@ struct Foo<const NUM_BYTES: usize>(pub [u8; NUM_BYTES]);\n \n fn main() {\n     let _ = Foo::<3>([1, 2, 3]); //~ ERROR type annotations needed\n+    //~^ ERROR mismatched types\n }"}, {"sha": "fb151648f2f9b9b3d0e9e5aa14f83b6b2b74650b", "filename": "src/test/ui/const-generics/cannot-infer-type-for-const-param.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcannot-infer-type-for-const-param.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -10,6 +10,16 @@ error[E0282]: type annotations needed\n LL |     let _ = Foo::<3>([1, 2, 3]);\n    |                   ^ cannot infer type for `{integer}`\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/cannot-infer-type-for-const-param.rs:10:22\n+   |\n+LL |     let _ = Foo::<3>([1, 2, 3]);\n+   |                      ^^^^^^^^^ expected `3`, found `3usize`\n+   |\n+   = note: expected type `[u8; _]`\n+              found type `[u8; 3]`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0282`.\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "d3d17cca4da27a7e65c022f4c766e439d71079f2", "filename": "src/test/ui/const-generics/fn-taking-const-generic-array.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt::Display;\n+\n+fn print_slice<T: Display, const N: usize>(slice: &[T; N]) {\n+    for x in slice.iter() {\n+        println!(\"{}\", x);\n+    }\n+}\n+\n+fn main() {\n+    print_slice(&[1, 2, 3]);\n+}"}, {"sha": "367041283251fcf5fb6c298d0cf7158831f4f524", "filename": "src/test/ui/const-generics/fn-taking-const-generic-array.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-taking-const-generic-array.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/fn-taking-const-generic-array.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "1e064fbd970640044e53cd22a2d2d9a0fa6b6d50", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt;\n+\n+struct Array<T, const N: usize>([T; N]);\n+\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for Array<T, {N}> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list().entries(self.0.iter()).finish()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(format!(\"{:?}\", Array([1, 2, 3])), \"[1, 2, 3]\");\n+}"}, {"sha": "eb2e446396c3380448e3b24cd40dca8ca597e592", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-1.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-1.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/uninferred-consts-during-codegen-1.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "0cf505906f626ee873e8d0df42ef26c993169753", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+use std::fmt;\n+\n+struct Array<T>(T);\n+\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for Array<[T; N]> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_list().entries((&self.0 as &[T]).iter()).finish()\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(format!(\"{:?}\", Array([1, 2, 3])), \"[1, 2, 3]\");\n+}"}, {"sha": "eaa20bb7892226204560f5cc3f0da9cbcbcbb420", "filename": "src/test/ui/const-generics/uninferred-consts-during-codegen-2.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funinferred-consts-during-codegen-2.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,6 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/uninferred-consts-during-codegen-2.rs:3:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+"}, {"sha": "2f5661e32a90e37dde994653e5b6472649e4e423", "filename": "src/test/ui/consts/const-array-oob-arith.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -4,8 +4,12 @@ const ARR: [i32; 6] = [42, 43, 44, 45, 46, 47];\n const IDX: usize = 3;\n const VAL: i32 = ARR[IDX];\n const BONG: [i32; (ARR[0] - 41) as usize] = [5];\n-const BLUB: [i32; (ARR[0] - 40) as usize] = [5]; //~ ERROR: mismatched types\n-const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99]; //~ ERROR: mismatched types\n+const BLUB: [i32; (ARR[0] - 40) as usize] = [5];\n+//~^ ERROR: mismatched types\n+//~| expected an array with a fixed size of 2 elements, found one with 1 element\n+const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99];\n+//~^ ERROR: mismatched types\n+//~| expected an array with a fixed size of 1 element, found one with 2 elements\n \n fn main() {\n     let _ = VAL;"}, {"sha": "987e7ddf4d91e66ce42ee0236319ac6b1fa8fd2b", "filename": "src/test/ui/consts/const-array-oob-arith.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-array-oob-arith.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -2,16 +2,16 @@ error[E0308]: mismatched types\n   --> $DIR/const-array-oob-arith.rs:7:45\n    |\n LL | const BLUB: [i32; (ARR[0] - 40) as usize] = [5];\n-   |                                             ^^^ expected an array with a fixed size of 2 elements, found one with 1 elements\n+   |                                             ^^^ expected an array with a fixed size of 2 elements, found one with 1 element\n    |\n    = note: expected type `[i32; 2]`\n               found type `[i32; 1]`\n \n error[E0308]: mismatched types\n-  --> $DIR/const-array-oob-arith.rs:8:44\n+  --> $DIR/const-array-oob-arith.rs:10:44\n    |\n LL | const BOO: [i32; (ARR[0] - 41) as usize] = [5, 99];\n-   |                                            ^^^^^^^ expected an array with a fixed size of 1 elements, found one with 2 elements\n+   |                                            ^^^^^^^ expected an array with a fixed size of 1 element, found one with 2 elements\n    |\n    = note: expected type `[i32; 1]`\n               found type `[i32; 2]`"}, {"sha": "5e500de607c1aae7e56bc2e873bc23be925d92fb", "filename": "src/test/ui/custom-derive/auxiliary/plugin.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fauxiliary%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fauxiliary%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fauxiliary%2Fplugin.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,28 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(Foo)]\n-pub fn derive_foo(input: TokenStream) -> TokenStream {\n-    input\n-}\n-\n-#[proc_macro_derive(Bar)]\n-pub fn derive_bar(input: TokenStream) -> TokenStream {\n-    panic!(\"lolnope\");\n-}\n-\n-#[proc_macro_derive(WithHelper, attributes(helper))]\n-pub fn with_helper(input: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}\n-\n-#[proc_macro_attribute]\n-pub fn helper(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "8478ff1a6ae6c7616833547b4f4323bd5a1a6a18", "filename": "src/test/ui/custom-derive/derive-in-mod.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fderive-in-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fderive-in-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fderive-in-mod.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// compile-pass\n-// aux-build:plugin.rs\n-\n-extern crate plugin;\n-\n-mod inner {\n-    use plugin::WithHelper;\n-\n-    #[derive(WithHelper)]\n-    struct S;\n-}\n-\n-fn main() {}"}, {"sha": "ba072ba3568b7aac6ad2f8a3889eaa74100af974", "filename": "src/test/ui/custom-derive/helper-attr-blocked-by-import-ambig.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,12 +0,0 @@\n-// aux-build:plugin.rs\n-\n-#[macro_use(WithHelper)]\n-extern crate plugin;\n-\n-use plugin::helper;\n-\n-#[derive(WithHelper)]\n-#[helper] //~ ERROR `helper` is ambiguous\n-struct S;\n-\n-fn main() {}"}, {"sha": "e83c291c9bfe4ed5cc23a89e309e8e4e9640f221", "filename": "src/test/ui/custom-derive/helper-attr-blocked-by-import-ambig.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,21 +0,0 @@\n-error[E0659]: `helper` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/helper-attr-blocked-by-import-ambig.rs:9:3\n-   |\n-LL | #[helper]\n-   |   ^^^^^^ ambiguous name\n-   |\n-note: `helper` could refer to the derive helper attribute defined here\n-  --> $DIR/helper-attr-blocked-by-import-ambig.rs:8:10\n-   |\n-LL | #[derive(WithHelper)]\n-   |          ^^^^^^^^^^\n-note: `helper` could also refer to the attribute macro imported here\n-  --> $DIR/helper-attr-blocked-by-import-ambig.rs:6:5\n-   |\n-LL | use plugin::helper;\n-   |     ^^^^^^^^^^^^^^\n-   = help: use `crate::helper` to refer to this attribute macro unambiguously\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0659`."}, {"sha": "abbf014f55337483f2fb9ee31a53e00c5086d533", "filename": "src/test/ui/custom-derive/helper-attr-blocked-by-import.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fhelper-attr-blocked-by-import.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,28 +0,0 @@\n-// compile-pass\n-// aux-build:plugin.rs\n-\n-#[macro_use(WithHelper)]\n-extern crate plugin;\n-\n-use self::one::*;\n-use self::two::*;\n-\n-mod helper {}\n-\n-mod one {\n-    use helper;\n-\n-    #[derive(WithHelper)]\n-    #[helper]\n-    struct One;\n-}\n-\n-mod two {\n-    use helper;\n-\n-    #[derive(WithHelper)]\n-    #[helper]\n-    struct Two;\n-}\n-\n-fn main() {}"}, {"sha": "7a5d19f771f3ca5a8ebc33f5b645ff9490a2dbe5", "filename": "src/test/ui/custom-derive/issue-36935.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,12 +0,0 @@\n-// aux-build:plugin.rs\n-\n-\n-#[macro_use] extern crate plugin;\n-\n-#[derive(Foo, Bar)] //~ ERROR proc-macro derive panicked\n-struct Baz {\n-    a: i32,\n-    b: i32,\n-}\n-\n-fn main() {}"}, {"sha": "2875bc5fce99b69604953df61ae6079db7a530f6", "filename": "src/test/ui/custom-derive/issue-36935.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,10 +0,0 @@\n-error: proc-macro derive panicked\n-  --> $DIR/issue-36935.rs:6:15\n-   |\n-LL | #[derive(Foo, Bar)]\n-   |               ^^^\n-   |\n-   = help: message: lolnope\n-\n-error: aborting due to previous error\n-"}, {"sha": "2ee004a37a6fc2568a37afbdc387d45f5f368ba5", "filename": "src/test/ui/impl-trait/hidden-lifetimes.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,63 @@\n+// Test to show what happens if we were not careful and allowed invariant\n+// lifetimes to escape though an impl trait.\n+//\n+// Specifically we swap a long lived and short lived reference, giving us a\n+// dangling pointer.\n+\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+trait Swap: Sized {\n+    fn swap(self, other: Self);\n+}\n+\n+impl<T> Swap for &mut T {\n+    fn swap(self, other: Self) {\n+        std::mem::swap(self, other);\n+    }\n+}\n+\n+impl<T> Swap for Rc<RefCell<T>> {\n+    fn swap(self, other: Self) {\n+        <RefCell<T>>::swap(&self, &other);\n+    }\n+}\n+\n+// Here we are hiding `'b` making the caller believe that `&'a mut &'s T` and\n+// `&'a mut &'l T` are the same type.\n+fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n+    //~^ ERROR hidden type\n+    x\n+}\n+\n+fn dangle_ref() -> &'static [i32; 3] {\n+    let mut res = &[4, 5, 6];\n+    let x = [1, 2, 3];\n+    hide_ref(&mut res).swap(hide_ref(&mut &x));\n+    res\n+}\n+\n+// Here we are hiding `'b` making the caller believe that `Rc<RefCell<&'s T>>`\n+// and `Rc<RefCell<&'l T>>` are the same type.\n+//\n+// This is different to the previous example because the concrete return type\n+// only has a single lifetime.\n+fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n+    //~^ ERROR hidden type\n+    x\n+}\n+\n+fn dangle_rc_refcell() -> &'static [i32; 3] {\n+    let long = Rc::new(RefCell::new(&[4, 5, 6]));\n+    let x = [1, 2, 3];\n+    let short = Rc::new(RefCell::new(&x));\n+    hide_rc_refcell(long.clone()).swap(hide_rc_refcell(short));\n+    let res: &'static [i32; 3] = *long.borrow();\n+    res\n+}\n+\n+fn main() {\n+    // both will print nonsense values.\n+    println!(\"{:?}\", dangle_ref());\n+    println!(\"{:?}\", dangle_rc_refcell())\n+}"}, {"sha": "650161753d1e5171193fd5b7a2b2ad0bbbb98fc8", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,27 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/hidden-lifetimes.rs:28:54\n+   |\n+LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n+   |                                                      ^^^^^^^^^^^^^^\n+   |\n+note: hidden type `&'a mut &'b T` captures the lifetime 'b as defined on the function body at 28:17\n+  --> $DIR/hidden-lifetimes.rs:28:17\n+   |\n+LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n+   |                 ^^\n+\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/hidden-lifetimes.rs:45:70\n+   |\n+LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n+   |                                                                      ^^^^^^^^^^^^^^\n+   |\n+note: hidden type `std::rc::Rc<std::cell::RefCell<&'b T>>` captures the lifetime 'b as defined on the function body at 45:24\n+  --> $DIR/hidden-lifetimes.rs:45:24\n+   |\n+LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a {\n+   |                        ^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "8346542135becfc93c61d5ac02c844f392f2f1e8", "filename": "src/test/ui/impl-trait/multiple-lifetimes.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,12 @@\n+// Test that multiple liftimes are allowed in impl trait types.\n+// compile-pass\n+\n+trait X<'x>: Sized {}\n+\n+impl<U> X<'_> for U {}\n+\n+fn multiple_lifeteimes<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl X<'b> + 'a {\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "d2347c3077cf33a11bc191c161fdea8b4acbc939", "filename": "src/test/ui/issue-53912.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fissue-53912.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fissue-53912.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-53912.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,37 @@\n+// compile-pass\n+\n+// This test is the same code as in ui/symbol-names/issue-60925.rs but this checks that the\n+// reproduction compiles successfully and doesn't segfault, whereas that test just checks that the\n+// symbol mangling fix produces the correct result.\n+\n+fn dummy() {}\n+\n+mod llvm {\n+    pub(crate) struct Foo;\n+}\n+mod foo {\n+    pub(crate) struct Foo<T>(T);\n+\n+    impl Foo<::llvm::Foo> {\n+        pub(crate) fn foo() {\n+            for _ in 0..0 {\n+                for _ in &[::dummy()] {\n+                    ::dummy();\n+                    ::dummy();\n+                    ::dummy();\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn foo() {\n+        Foo::foo();\n+        Foo::foo();\n+    }\n+}\n+\n+pub fn foo() {\n+    foo::foo();\n+}\n+\n+fn main() {}"}, {"sha": "a3d4d23450ca6f1e44c346c667e1ad97bfef83cf", "filename": "src/test/ui/proc-macro/attribute-order-restricted.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,14 +1,14 @@\n-// aux-build:attr_proc_macro.rs\n+// aux-build:test-macros.rs\n \n-extern crate attr_proc_macro;\n-use attr_proc_macro::*;\n+#[macro_use]\n+extern crate test_macros;\n \n-#[attr_proc_macro] // OK\n+#[identity_attr] // OK\n #[derive(Clone)]\n struct Before;\n \n #[derive(Clone)]\n-#[attr_proc_macro] //~ ERROR macro attributes must be placed before `#[derive]`\n+#[identity_attr] //~ ERROR macro attributes must be placed before `#[derive]`\n struct After;\n \n fn main() {}"}, {"sha": "9ca8a443e40fbb5cf1fcb8015e279b10b4954ac6", "filename": "src/test/ui/proc-macro/attribute-order-restricted.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-order-restricted.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,8 +1,8 @@\n error: macro attributes must be placed before `#[derive]`\n   --> $DIR/attribute-order-restricted.rs:11:1\n    |\n-LL | #[attr_proc_macro]\n-   | ^^^^^^^^^^^^^^^^^^\n+LL | #[identity_attr]\n+   | ^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "aaa6c07dddbbd402440a524a6cf102cb813bcd1a", "filename": "src/test/ui/proc-macro/attribute-with-error.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,12 +1,11 @@\n-// aux-build:attribute-with-error.rs\n+// aux-build:test-macros.rs\n \n #![feature(custom_inner_attributes)]\n \n-extern crate attribute_with_error;\n+#[macro_use]\n+extern crate test_macros;\n \n-use attribute_with_error::foo;\n-\n-#[foo]\n+#[recollect_attr]\n fn test1() {\n     let a: i32 = \"foo\";\n     //~^ ERROR: mismatched types\n@@ -15,13 +14,13 @@ fn test1() {\n }\n \n fn test2() {\n-    #![foo]\n+    #![recollect_attr]\n \n     // FIXME: should have a type error here and assert it works but it doesn't\n }\n \n trait A {\n-    // FIXME: should have a #[foo] attribute here and assert that it works\n+    // FIXME: should have a #[recollect_attr] attribute here and assert that it works\n     fn foo(&self) {\n         let a: i32 = \"foo\";\n         //~^ ERROR: mismatched types\n@@ -31,13 +30,13 @@ trait A {\n struct B;\n \n impl A for B {\n-    #[foo]\n+    #[recollect_attr]\n     fn foo(&self) {\n         let a: i32 = \"foo\";\n         //~^ ERROR: mismatched types\n     }\n }\n \n-#[foo]\n+#[recollect_attr]\n fn main() {\n }"}, {"sha": "937d47ff089798e66f2d8be8e423cbf76ed7e08f", "filename": "src/test/ui/proc-macro/attribute-with-error.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute-with-error.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/attribute-with-error.rs:11:18\n+  --> $DIR/attribute-with-error.rs:10:18\n    |\n LL |     let a: i32 = \"foo\";\n    |                  ^^^^^ expected i32, found reference\n@@ -8,7 +8,7 @@ LL |     let a: i32 = \"foo\";\n               found type `&'static str`\n \n error[E0308]: mismatched types\n-  --> $DIR/attribute-with-error.rs:13:18\n+  --> $DIR/attribute-with-error.rs:12:18\n    |\n LL |     let b: i32 = \"f'oo\";\n    |                  ^^^^^^ expected i32, found reference\n@@ -17,7 +17,7 @@ LL |     let b: i32 = \"f'oo\";\n               found type `&'static str`\n \n error[E0308]: mismatched types\n-  --> $DIR/attribute-with-error.rs:26:22\n+  --> $DIR/attribute-with-error.rs:25:22\n    |\n LL |         let a: i32 = \"foo\";\n    |                      ^^^^^ expected i32, found reference\n@@ -26,7 +26,7 @@ LL |         let a: i32 = \"foo\";\n               found type `&'static str`\n \n error[E0308]: mismatched types\n-  --> $DIR/attribute-with-error.rs:36:22\n+  --> $DIR/attribute-with-error.rs:35:22\n    |\n LL |         let a: i32 = \"foo\";\n    |                      ^^^^^ expected i32, found reference"}, {"sha": "b1f54be6bac4b0ca4a3cccd5066d4c48dc427e9c", "filename": "src/test/ui/proc-macro/auxiliary/attr_proc_macro.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr_proc_macro.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_attribute]\n-pub fn attr_proc_macro(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "c073be003101983bc3b83d1d420b08ab75bf71de", "filename": "src/test/ui/proc-macro/auxiliary/attribute-with-error.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_attribute]\n-pub fn foo(_attr: TokenStream, input: TokenStream) -> TokenStream {\n-    input.into_iter().collect()\n-}"}, {"sha": "16f3b7640290d42dc282302913432fece5604d33", "filename": "src/test/ui/proc-macro/auxiliary/bang_proc_macro.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fbang_proc_macro.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro]\n-pub fn bang_proc_macro(input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "64d4e0f7b7ae597a3c1dbe647cea58f000cf2178", "filename": "src/test/ui/proc-macro/auxiliary/derive-a-b.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a-b.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,17 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(A)]\n-pub fn derive_a(_: TokenStream) -> TokenStream {\n-    \"\".parse().unwrap()\n-}\n-\n-#[proc_macro_derive(B)]\n-pub fn derive_b(_: TokenStream) -> TokenStream {\n-    \"\".parse().unwrap()\n-}"}, {"sha": "c9d94aba9f7564391250b152415768affd1ebd9e", "filename": "src/test/ui/proc-macro/auxiliary/derive-a.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(A)]\n-pub fn derive_a(input: TokenStream) -> TokenStream {\n-    \"\".parse().unwrap()\n-}"}, {"sha": "ab532da2992247ca5e6a7fb8fe45d79897bedd74", "filename": "src/test/ui/proc-macro/auxiliary/derive-helper-shadowed-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowed-2.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,2 +1,2 @@\n #[macro_export]\n-macro_rules! my_attr { () => () }\n+macro_rules! empty_helper { () => () }"}, {"sha": "5b5243dd60ee3b89847a0bddd8c09d0909464648", "filename": "src/test/ui/proc-macro/auxiliary/derive-helper-shadowed.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowed.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,12 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::*;\n-\n-#[proc_macro_derive(MyTrait, attributes(my_attr))]\n-pub fn foo(_: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}"}, {"sha": "6e0bdcba9c50f11b39a90826b6d9c7aa635859c2", "filename": "src/test/ui/proc-macro/auxiliary/derive-helper-shadowing.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,17 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::*;\n-\n-#[proc_macro_attribute]\n-pub fn my_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input\n-}\n-\n-#[proc_macro_derive(MyTrait, attributes(my_attr))]\n-pub fn derive(input: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}"}, {"sha": "e2afa7affa30223fd81dfe2b02f4aa27eb02e443", "filename": "src/test/ui/proc-macro/auxiliary/derive-panic.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-panic.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_derive(A)]\n-pub fn derive_a(_input: TokenStream) -> TokenStream {\n-    panic!(\"nope!\");\n-}"}, {"sha": "d5d393b5a6457df34cddb74fd0ad058a1694affa", "filename": "src/test/ui/proc-macro/auxiliary/dollar-crate-external.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate-external.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,14 +3,14 @@ pub type S = u8;\n #[macro_export]\n macro_rules! external {\n     () => {\n-        dollar_crate::m! {\n+        print_bang! {\n             struct M($crate::S);\n         }\n \n-        #[dollar_crate::a]\n+        #[print_attr]\n         struct A($crate::S);\n \n-        #[derive(dollar_crate::d)]\n+        #[derive(Print)]\n         struct D($crate::S);\n     };\n }"}, {"sha": "c5347d2e81a6b3401df6cc795cd91978f27755b2", "filename": "src/test/ui/proc-macro/auxiliary/dollar-crate.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdollar-crate.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,35 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::TokenStream;\n-\n-#[proc_macro]\n-pub fn m_empty(input: TokenStream) -> TokenStream {\n-    println!(\"PROC MACRO INPUT (PRETTY-PRINTED): {}\", input);\n-    println!(\"PROC MACRO INPUT: {:#?}\", input);\n-    TokenStream::new()\n-}\n-\n-#[proc_macro]\n-pub fn m(input: TokenStream) -> TokenStream {\n-    println!(\"PROC MACRO INPUT (PRETTY-PRINTED): {}\", input);\n-    println!(\"PROC MACRO INPUT: {:#?}\", input);\n-    input.into_iter().collect()\n-}\n-\n-#[proc_macro_attribute]\n-pub fn a(_args: TokenStream, input: TokenStream) -> TokenStream {\n-    println!(\"ATTRIBUTE INPUT (PRETTY-PRINTED): {}\", input);\n-    println!(\"ATTRIBUTE INPUT: {:#?}\", input);\n-    input.into_iter().collect()\n-}\n-\n-#[proc_macro_derive(d)]\n-pub fn d(input: TokenStream) -> TokenStream {\n-    println!(\"DERIVE INPUT (PRETTY-PRINTED): {}\", input);\n-    println!(\"DERIVE INPUT: {:#?}\", input);\n-    input.into_iter().collect()\n-}"}, {"sha": "db946e7f331ca706584188335a92ce8a1602f664", "filename": "src/test/ui/proc-macro/auxiliary/issue-41211.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fissue-41211.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,12 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_attribute]\n-pub fn emit_unchanged(_args: TokenStream, input: TokenStream) -> TokenStream {\n-    input\n-}"}, {"sha": "d9f290dec7ef928db64d19dd994a5826300e3b88", "filename": "src/test/ui/proc-macro/auxiliary/issue-53481.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fissue-53481.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fissue-53481.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fissue-53481.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::*;\n-\n-#[proc_macro_derive(MyTrait, attributes(my_attr))]\n-pub fn foo(_: TokenStream) -> TokenStream {\n-    TokenStream::new()\n-}"}, {"sha": "f2c62ab1b5ef0c8f40e2b27c023e26ec7ff70fd2", "filename": "src/test/ui/proc-macro/auxiliary/macro-brackets.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmacro-brackets.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,12 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-use proc_macro::*;\n-\n-#[proc_macro_attribute]\n-pub fn doit(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input.into_iter().collect()\n-}"}, {"sha": "8f720b4574dde7b36f3a7bda42140a3f8b5f0f97", "filename": "src/test/ui/proc-macro/auxiliary/nested-item-spans.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-item-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-item-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-item-spans.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::*;\n-\n-#[proc_macro_attribute]\n-pub fn foo(_: TokenStream, item: TokenStream) -> TokenStream {\n-    item.into_iter().collect()\n-}"}, {"sha": "c7c7167eca0d536d6632f118281a5e3abbfd3f66", "filename": "src/test/ui/proc-macro/auxiliary/proc-macro-gates.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fproc-macro-gates.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,18 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::*;\n-\n-#[proc_macro]\n-pub fn m(a: TokenStream) -> TokenStream {\n-    a\n-}\n-\n-#[proc_macro_attribute]\n-pub fn a(_a: TokenStream, b: TokenStream) -> TokenStream {\n-    b\n-}"}, {"sha": "33c7968104b72c6be01dfb3f8c1409552804deeb", "filename": "src/test/ui/proc-macro/auxiliary/span-preservation.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fspan-preservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721268583759224d0f6476e0b8b196cc8afbdea0/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fspan-preservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fspan-preservation.rs?ref=721268583759224d0f6476e0b8b196cc8afbdea0", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-// no-prefer-dynamic\n-\n-#![crate_type = \"proc-macro\"]\n-\n-extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n-\n-#[proc_macro_attribute]\n-pub fn foo(_: TokenStream, input: TokenStream) -> TokenStream {\n-    input.into_iter().collect()\n-}"}, {"sha": "27efa44f980323a5948d336d6e88a788d3bf7959", "filename": "src/test/ui/proc-macro/auxiliary/test-macros.rs", "status": "modified", "additions": 95, "deletions": 9, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,26 +1,112 @@\n // force-host\n // no-prefer-dynamic\n \n+// Proc macros commonly used by tests.\n+// `panic`/`print` -> `panic_bang`/`print_bang` to avoid conflicts with standard macros.\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;\n-\n use proc_macro::TokenStream;\n \n+// Macro that return empty token stream.\n+\n+#[proc_macro]\n+pub fn empty(_: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n #[proc_macro_attribute]\n-pub fn nop_attr(_attr: TokenStream, input: TokenStream) -> TokenStream {\n-    assert!(_attr.to_string().is_empty());\n-    input\n+pub fn empty_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+#[proc_macro_derive(Empty, attributes(empty_helper))]\n+pub fn empty_derive(_: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+// Macro that panics.\n+\n+#[proc_macro]\n+pub fn panic_bang(_: TokenStream) -> TokenStream {\n+    panic!(\"panic-bang\");\n }\n \n #[proc_macro_attribute]\n-pub fn no_output(_attr: TokenStream, _input: TokenStream) -> TokenStream {\n-    assert!(_attr.to_string().is_empty());\n-    assert!(!_input.to_string().is_empty());\n-    \"\".parse().unwrap()\n+pub fn panic_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n+    panic!(\"panic-attr\");\n+}\n+\n+#[proc_macro_derive(Panic, attributes(panic_helper))]\n+pub fn panic_derive(_: TokenStream) -> TokenStream {\n+    panic!(\"panic-derive\");\n }\n \n+// Macros that return the input stream.\n+\n #[proc_macro]\n-pub fn emit_input(input: TokenStream) -> TokenStream {\n+pub fn identity(input: TokenStream) -> TokenStream {\n     input\n }\n+\n+#[proc_macro_attribute]\n+pub fn identity_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(Identity, attributes(identity_helper))]\n+pub fn identity_derive(input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+// Macros that iterate and re-collect the input stream.\n+\n+#[proc_macro]\n+pub fn recollect(input: TokenStream) -> TokenStream {\n+    input.into_iter().collect()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn recollect_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input.into_iter().collect()\n+}\n+\n+#[proc_macro_derive(Recollect, attributes(recollect_helper))]\n+pub fn recollect_derive(input: TokenStream) -> TokenStream {\n+    input.into_iter().collect()\n+}\n+\n+// Macros that print their input in the original and re-collected forms (if they differ).\n+\n+fn print_helper(input: TokenStream, kind: &str) -> TokenStream {\n+    let input_display = format!(\"{}\", input);\n+    let input_debug = format!(\"{:#?}\", input);\n+    let recollected = input.into_iter().collect();\n+    let recollected_display = format!(\"{}\", recollected);\n+    let recollected_debug = format!(\"{:#?}\", recollected);\n+    println!(\"PRINT-{} INPUT (DISPLAY): {}\", kind, input_display);\n+    if recollected_display != input_display {\n+        println!(\"PRINT-{} RE-COLLECTED (DISPLAY): {}\", kind, recollected_display);\n+    }\n+    println!(\"PRINT-{} INPUT (DEBUG): {}\", kind, input_debug);\n+    if recollected_debug != input_debug {\n+        println!(\"PRINT-{} RE-COLLECTED (DEBUG): {}\", kind, recollected_debug);\n+    }\n+    recollected\n+}\n+\n+#[proc_macro]\n+pub fn print_bang(input: TokenStream) -> TokenStream {\n+    print_helper(input, \"BANG\")\n+}\n+\n+#[proc_macro_attribute]\n+pub fn print_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    print_helper(input, \"ATTR\")\n+}\n+\n+#[proc_macro_derive(Print, attributes(print_helper))]\n+pub fn print_derive(input: TokenStream) -> TokenStream {\n+    print_helper(input, \"DERIVE\")\n+}"}, {"sha": "0388e647b58aad7691f334de67c39ab8202380f8", "filename": "src/test/ui/proc-macro/derive-helper-shadowed.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowed.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,16 +1,16 @@\n // compile-pass\n-// aux-build:derive-helper-shadowed.rs\n+// aux-build:test-macros.rs\n // aux-build:derive-helper-shadowed-2.rs\n \n #[macro_use]\n-extern crate derive_helper_shadowed;\n-#[macro_use(my_attr)]\n+extern crate test_macros;\n+#[macro_use(empty_helper)]\n extern crate derive_helper_shadowed_2;\n \n-macro_rules! my_attr { () => () }\n+macro_rules! empty_helper { () => () }\n \n-#[derive(MyTrait)]\n-#[my_attr] // OK\n+#[derive(Empty)]\n+#[empty_helper] // OK\n struct S;\n \n fn main() {}"}, {"sha": "cdc0d6da94695c018f3752c1248b911d699606ac", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,23 +1,25 @@\n-// aux-build:derive-helper-shadowing.rs\n+// aux-build:test-macros.rs\n \n-extern crate derive_helper_shadowing;\n-use derive_helper_shadowing::*;\n+#[macro_use]\n+extern crate test_macros;\n \n-#[my_attr] //~ ERROR `my_attr` is ambiguous\n-#[derive(MyTrait)]\n+use test_macros::empty_attr as empty_helper;\n+\n+#[empty_helper] //~ ERROR `empty_helper` is ambiguous\n+#[derive(Empty)]\n struct S {\n     // FIXME No ambiguity, attributes in non-macro positions are not resolved properly\n-    #[my_attr]\n+    #[empty_helper]\n     field: [u8; {\n         // FIXME No ambiguity, derive helpers are not put into scope for non-attributes\n-        use my_attr;\n+        use empty_helper;\n \n         // FIXME No ambiguity, derive helpers are not put into scope for inner items\n-        #[my_attr]\n+        #[empty_helper]\n         struct U;\n \n         mod inner {\n-            #[my_attr] //~ ERROR attribute `my_attr` is currently unknown\n+            #[empty_helper] //~ ERROR attribute `empty_helper` is currently unknown\n             struct V;\n         }\n "}, {"sha": "ed6d30516562d5e50f17a425b385fed724776ad6", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,29 +1,29 @@\n-error[E0658]: The attribute `my_attr` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/derive-helper-shadowing.rs:20:15\n+error[E0658]: The attribute `empty_helper` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/derive-helper-shadowing.rs:22:15\n    |\n-LL |             #[my_attr]\n-   |               ^^^^^^^\n+LL |             #[empty_helper]\n+   |               ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n-error[E0659]: `my_attr` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/derive-helper-shadowing.rs:6:3\n+error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n+  --> $DIR/derive-helper-shadowing.rs:8:3\n    |\n-LL | #[my_attr]\n-   |   ^^^^^^^ ambiguous name\n+LL | #[empty_helper]\n+   |   ^^^^^^^^^^^^ ambiguous name\n    |\n-note: `my_attr` could refer to the derive helper attribute defined here\n-  --> $DIR/derive-helper-shadowing.rs:7:10\n+note: `empty_helper` could refer to the derive helper attribute defined here\n+  --> $DIR/derive-helper-shadowing.rs:9:10\n    |\n-LL | #[derive(MyTrait)]\n-   |          ^^^^^^^\n-note: `my_attr` could also refer to the attribute macro imported here\n-  --> $DIR/derive-helper-shadowing.rs:4:5\n+LL | #[derive(Empty)]\n+   |          ^^^^^\n+note: `empty_helper` could also refer to the attribute macro imported here\n+  --> $DIR/derive-helper-shadowing.rs:6:5\n    |\n-LL | use derive_helper_shadowing::*;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: use `crate::my_attr` to refer to this attribute macro unambiguously\n+LL | use test_macros::empty_attr as empty_helper;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e6b91324f95d0828856413fdad655d189c17e9d3", "filename": "src/test/ui/proc-macro/derive-in-mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-in-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-in-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-in-mod.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,13 @@\n+// compile-pass\n+// aux-build:test-macros.rs\n+\n+extern crate test_macros;\n+\n+mod inner {\n+    use test_macros::Empty;\n+\n+    #[derive(Empty)]\n+    struct S;\n+}\n+\n+fn main() {}"}, {"sha": "d895d26f26763385c630034d1fe31ecfba78bdb6", "filename": "src/test/ui/proc-macro/derive-still-gated.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,11 +1,9 @@\n-// aux-build:derive-a.rs\n-\n-#![allow(warnings)]\n+// aux-build:test-macros.rs\n \n #[macro_use]\n-extern crate derive_a;\n+extern crate test_macros;\n \n-#[derive_A] //~ ERROR attribute `derive_A` is currently unknown\n+#[derive_Empty] //~ ERROR attribute `derive_Empty` is currently unknown\n struct A;\n \n fn main() {}"}, {"sha": "f299b5abdbc6be5d14a2e173593d78d4106be627", "filename": "src/test/ui/proc-macro/derive-still-gated.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-still-gated.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,8 +1,8 @@\n-error[E0658]: The attribute `derive_A` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/derive-still-gated.rs:8:3\n+error[E0658]: The attribute `derive_Empty` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/derive-still-gated.rs:6:3\n    |\n-LL | #[derive_A]\n-   |   ^^^^^^^^ help: a built-in attribute with a similar name exists: `derive`\n+LL | #[derive_Empty]\n+   |   ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable"}, {"sha": "2615db3e119f1366d9495631ba1a2e55f42c9fb1", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,22 +1,23 @@\n // compile-pass\n // edition:2018\n-// aux-build:dollar-crate.rs\n+// aux-build:test-macros.rs\n \n // Anonymize unstable non-dummy spans while still showing dummy spans `0..0`.\n // normalize-stdout-test \"bytes\\([^0]\\w*\\.\\.(\\w+)\\)\" -> \"bytes(LO..$1)\"\n // normalize-stdout-test \"bytes\\((\\w+)\\.\\.[^0]\\w*\\)\" -> \"bytes($1..HI)\"\n \n-extern crate dollar_crate;\n+#[macro_use]\n+extern crate test_macros;\n \n type S = u8;\n \n macro_rules! m {\n     () => {\n-        dollar_crate::m_empty! {\n+        print_bang! {\n             struct M($crate::S);\n         }\n \n-        #[dollar_crate::a]\n+        #[print_attr]\n         struct A($crate::S);\n     };\n }"}, {"sha": "0611fcb13f267dc17f471345ce1976df45be51b0", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,5 +1,5 @@\n-PROC MACRO INPUT (PRETTY-PRINTED): struct M ( $crate :: S ) ;\n-PROC MACRO INPUT: TokenStream [\n+PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #2 bytes(LO..HI),\n@@ -38,8 +38,9 @@ PROC MACRO INPUT: TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-ATTRIBUTE INPUT (PRETTY-PRINTED): struct A(crate::S);\n-ATTRIBUTE INPUT: TokenStream [\n+PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #2 bytes(LO..HI),"}, {"sha": "aadd87ffaf203e86d9af6bc23ebbc1c0058f3822", "filename": "src/test/ui/proc-macro/dollar-crate.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,29 +1,28 @@\n // edition:2018\n-// aux-build:dollar-crate.rs\n+// aux-build:test-macros.rs\n // aux-build:dollar-crate-external.rs\n \n // Anonymize unstable non-dummy spans while still showing dummy spans `0..0`.\n // normalize-stdout-test \"bytes\\([^0]\\w*\\.\\.(\\w+)\\)\" -> \"bytes(LO..$1)\"\n // normalize-stdout-test \"bytes\\((\\w+)\\.\\.[^0]\\w*\\)\" -> \"bytes($1..HI)\"\n \n-extern crate dollar_crate;\n+#[macro_use]\n+extern crate test_macros;\n extern crate dollar_crate_external;\n \n type S = u8;\n \n mod local {\n-    use crate::dollar_crate;\n-\n     macro_rules! local {\n         () => {\n-            dollar_crate::m! {\n+            print_bang! {\n                 struct M($crate::S);\n             }\n \n-            #[dollar_crate::a]\n+            #[print_attr]\n             struct A($crate::S);\n \n-            #[derive(dollar_crate::d)]\n+            #[derive(Print)]\n             struct D($crate::S); //~ ERROR the name `D` is defined multiple times\n         };\n     }"}, {"sha": "5d78a8e1987292fa1cbd1149f10989a29b28e5b9", "filename": "src/test/ui/proc-macro/dollar-crate.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,5 +1,5 @@\n error[E0428]: the name `D` is defined multiple times\n-  --> $DIR/dollar-crate.rs:27:13\n+  --> $DIR/dollar-crate.rs:26:13\n    |\n LL |             struct D($crate::S);\n    |             ^^^^^^^^^^^^^^^^^^^^\n@@ -13,7 +13,7 @@ LL |     local!();\n    = note: `D` must be defined only once in the type namespace of this module\n \n error[E0428]: the name `D` is defined multiple times\n-  --> $DIR/dollar-crate.rs:37:5\n+  --> $DIR/dollar-crate.rs:36:5\n    |\n LL |     dollar_crate_external::external!();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "3c88ee99842a26e27f2e717fc08ce453e0372c4d", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,5 +1,5 @@\n-PROC MACRO INPUT (PRETTY-PRINTED): struct M ( $crate :: S ) ;\n-PROC MACRO INPUT: TokenStream [\n+PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #2 bytes(LO..HI),\n@@ -38,8 +38,9 @@ PROC MACRO INPUT: TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-ATTRIBUTE INPUT (PRETTY-PRINTED): struct A(crate::S);\n-ATTRIBUTE INPUT: TokenStream [\n+PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #2 bytes(LO..HI),\n@@ -78,8 +79,9 @@ ATTRIBUTE INPUT: TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-DERIVE INPUT (PRETTY-PRINTED): struct D(crate::S);\n-DERIVE INPUT: TokenStream [\n+PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #2 bytes(LO..HI),\n@@ -118,8 +120,8 @@ DERIVE INPUT: TokenStream [\n         span: #2 bytes(LO..HI),\n     },\n ]\n-PROC MACRO INPUT (PRETTY-PRINTED): struct M ( $crate :: S ) ;\n-PROC MACRO INPUT: TokenStream [\n+PRINT-BANG INPUT (DISPLAY): struct M ( $crate :: S ) ;\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #10 bytes(LO..HI),\n@@ -158,8 +160,9 @@ PROC MACRO INPUT: TokenStream [\n         span: #10 bytes(LO..HI),\n     },\n ]\n-ATTRIBUTE INPUT (PRETTY-PRINTED): struct A(::dollar_crate_external::S);\n-ATTRIBUTE INPUT: TokenStream [\n+PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n+PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ( $crate :: S ) ;\n+PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #10 bytes(LO..HI),\n@@ -198,8 +201,9 @@ ATTRIBUTE INPUT: TokenStream [\n         span: #10 bytes(LO..HI),\n     },\n ]\n-DERIVE INPUT (PRETTY-PRINTED): struct D(::dollar_crate_external::S);\n-DERIVE INPUT: TokenStream [\n+PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n+PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ( $crate :: S ) ;\n+PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n         span: #10 bytes(LO..HI),"}, {"sha": "3a1c56efce8c268f1a307583e2850bab41778f98", "filename": "src/test/ui/proc-macro/helper-attr-blocked-by-import-ambig.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,11 @@\n+// aux-build:test-macros.rs\n+\n+#[macro_use(Empty)]\n+extern crate test_macros;\n+use test_macros::empty_attr as empty_helper;\n+\n+#[derive(Empty)]\n+#[empty_helper] //~ ERROR `empty_helper` is ambiguous\n+struct S;\n+\n+fn main() {}"}, {"sha": "012fb105b128d47b89cc4e6143c43b8fcbba9785", "filename": "src/test/ui/proc-macro/helper-attr-blocked-by-import-ambig.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,21 @@\n+error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:8:3\n+   |\n+LL | #[empty_helper]\n+   |   ^^^^^^^^^^^^ ambiguous name\n+   |\n+note: `empty_helper` could refer to the derive helper attribute defined here\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:10\n+   |\n+LL | #[derive(Empty)]\n+   |          ^^^^^\n+note: `empty_helper` could also refer to the attribute macro imported here\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:5:5\n+   |\n+LL | use test_macros::empty_attr as empty_helper;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "6d3e5ec198d8557d8a0c9b67c7e18db7c2ef930d", "filename": "src/test/ui/proc-macro/helper-attr-blocked-by-import.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fhelper-attr-blocked-by-import.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,28 @@\n+// compile-pass\n+// aux-build:test-macros.rs\n+\n+#[macro_use(Empty)]\n+extern crate test_macros;\n+\n+use self::one::*;\n+use self::two::*;\n+\n+mod empty_helper {}\n+\n+mod one {\n+    use empty_helper;\n+\n+    #[derive(Empty)]\n+    #[empty_helper]\n+    struct One;\n+}\n+\n+mod two {\n+    use empty_helper;\n+\n+    #[derive(Empty)]\n+    #[empty_helper]\n+    struct Two;\n+}\n+\n+fn main() {}"}, {"sha": "d1b1ff350695f10f2ca5aa63f316e910d549baa6", "filename": "src/test/ui/proc-macro/import.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fimport.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,11 +1,8 @@\n-// aux-build:derive-a.rs\n+// aux-build:test-macros.rs\n \n-#![allow(warnings)]\n+extern crate test_macros;\n \n-#[macro_use]\n-extern crate derive_a;\n-\n-use derive_a::derive_a;\n-//~^ ERROR: unresolved import `derive_a::derive_a`\n+use test_macros::empty_derive;\n+//~^ ERROR: unresolved import `test_macros::empty_derive`\n \n fn main() {}"}, {"sha": "aae621193ab9f3ea329765a7d36729560e88459e", "filename": "src/test/ui/proc-macro/import.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fimport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fimport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fimport.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,8 +1,8 @@\n-error[E0432]: unresolved import `derive_a::derive_a`\n-  --> $DIR/import.rs:8:5\n+error[E0432]: unresolved import `test_macros::empty_derive`\n+  --> $DIR/import.rs:5:5\n    |\n-LL | use derive_a::derive_a;\n-   |     ^^^^^^^^^^^^^^^^^^ no `derive_a` in the root\n+LL | use test_macros::empty_derive;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ no `empty_derive` in the root\n \n error: aborting due to previous error\n "}, {"sha": "f809592d5f449c280902c85f07e4289822d3def6", "filename": "src/test/ui/proc-macro/issue-36935.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[derive(Identity, Panic)] //~ ERROR proc-macro derive panicked\n+struct Baz {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn main() {}"}, {"sha": "da4366eb668d64d672139c7bd93c8440080c3816", "filename": "src/test/ui/proc-macro/issue-36935.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-36935.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,10 @@\n+error: proc-macro derive panicked\n+  --> $DIR/issue-36935.rs:6:20\n+   |\n+LL | #[derive(Identity, Panic)]\n+   |                    ^^^^^\n+   |\n+   = help: message: panic-derive\n+\n+error: aborting due to previous error\n+"}, {"sha": "73b1f0d58c8371a5f6599204af953e51d0953117", "filename": "src/test/ui/proc-macro/issue-37788.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-37788.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-37788.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-37788.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,7 +1,7 @@\n-// aux-build:derive-a-b.rs\n+// aux-build:test-macros.rs\n \n #[macro_use]\n-extern crate derive_a_b;\n+extern crate test_macros;\n \n fn main() {\n     // Test that constructing the `visible_parent_map` (in `cstore_impl.rs`) does not ICE."}, {"sha": "ee9246e1c9b5cf25b24b106b46696e4dd4164022", "filename": "src/test/ui/proc-macro/issue-41211.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,14 +1,14 @@\n-// aux-build:issue-41211.rs\n+// aux-build:test-macros.rs\n \n // FIXME: https://github.com/rust-lang/rust/issues/41430\n // This is a temporary regression test for the ICE reported in #41211\n \n #![feature(custom_inner_attributes)]\n \n-#![emit_unchanged]\n-//~^ ERROR attribute `emit_unchanged` is currently unknown to the compiler\n+#![identity_attr]\n+//~^ ERROR attribute `identity_attr` is currently unknown to the compiler\n //~| ERROR inconsistent resolution for a macro: first custom attribute, then attribute macro\n-extern crate issue_41211;\n-use issue_41211::emit_unchanged;\n+extern crate test_macros;\n+use test_macros::identity_attr;\n \n fn main() {}"}, {"sha": "1de6b293ecfb8601633338a52fcd2f2538355a45", "filename": "src/test/ui/proc-macro/issue-41211.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-41211.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: The attribute `emit_unchanged` is currently unknown to the compiler and may have meaning added to it in the future\n+error[E0658]: The attribute `identity_attr` is currently unknown to the compiler and may have meaning added to it in the future\n   --> $DIR/issue-41211.rs:8:4\n    |\n-LL | #![emit_unchanged]\n-   |    ^^^^^^^^^^^^^^\n+LL | #![identity_attr]\n+   |    ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n error: inconsistent resolution for a macro: first custom attribute, then attribute macro\n   --> $DIR/issue-41211.rs:8:4\n    |\n-LL | #![emit_unchanged]\n-   |    ^^^^^^^^^^^^^^\n+LL | #![identity_attr]\n+   |    ^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2fbde5fedb95b7527c9157f61a62fdeb6935b524", "filename": "src/test/ui/proc-macro/issue-53481.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-53481.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fissue-53481.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-53481.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,21 +1,21 @@\n // compile-pass\n-// aux-build:issue-53481.rs\n+// aux-build:test-macros.rs\n \n #[macro_use]\n-extern crate issue_53481;\n+extern crate test_macros;\n \n mod m1 {\n-    use m2::MyTrait;\n+    use m2::Empty;\n \n-    #[derive(MyTrait)]\n+    #[derive(Empty)]\n     struct A {}\n }\n \n mod m2 {\n-    pub type MyTrait = u8;\n+    pub type Empty = u8;\n \n-    #[derive(MyTrait)]\n-    #[my_attr]\n+    #[derive(Empty)]\n+    #[empty_helper]\n     struct B {}\n }\n "}, {"sha": "2e9a311d882bd3019f107d6e11a4a28b1546e0bf", "filename": "src/test/ui/proc-macro/load-panic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,10 +1,9 @@\n-// aux-build:derive-panic.rs\n-// compile-flags:--error-format human\n+// aux-build:test-macros.rs\n \n #[macro_use]\n-extern crate derive_panic;\n+extern crate test_macros;\n \n-#[derive(A)]\n+#[derive(Panic)]\n //~^ ERROR: proc-macro derive panicked\n struct Foo;\n "}, {"sha": "40cc4ee0e3d373246c2f41583dd90472b567e13d", "filename": "src/test/ui/proc-macro/load-panic.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fload-panic.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,10 +1,10 @@\n error: proc-macro derive panicked\n-  --> $DIR/load-panic.rs:7:10\n+  --> $DIR/load-panic.rs:6:10\n    |\n-LL | #[derive(A)]\n-   |          ^\n+LL | #[derive(Panic)]\n+   |          ^^^^^\n    |\n-   = help: message: nope!\n+   = help: message: panic-derive\n \n error: aborting due to previous error\n "}, {"sha": "aa0046f458229caeb5b6b58a7538a3b364017d8b", "filename": "src/test/ui/proc-macro/macro-brackets.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-brackets.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,13 +1,13 @@\n-// aux-build:macro-brackets.rs\n+// aux-build:test-macros.rs\n \n-extern crate macro_brackets as bar;\n-use bar::doit;\n+#[macro_use]\n+extern crate test_macros;\n \n macro_rules! id {\n     ($($t:tt)*) => ($($t)*)\n }\n \n-#[doit]\n+#[identity_attr]\n id![static X: u32 = 'a';]; //~ ERROR: mismatched types\n \n "}, {"sha": "d1b1430fb5d034f5effb78dc6a711cfec95c0ddc", "filename": "src/test/ui/proc-macro/macro-use-attr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-use-attr.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,9 +1,10 @@\n // compile-pass\n-// aux-build:attr_proc_macro.rs\n+// aux-build:test-macros.rs\n \n-#[macro_use] extern crate attr_proc_macro;\n+#[macro_use]\n+extern crate test_macros;\n \n-#[attr_proc_macro]\n+#[identity_attr]\n struct Foo;\n \n fn main() {"}, {"sha": "d39c42267fb96003d48941acaf05efdffe98c475", "filename": "src/test/ui/proc-macro/macro-use-bang.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-use-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-use-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-use-bang.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,11 +1,11 @@\n // compile-pass\n-// aux-build:bang_proc_macro.rs\n+// aux-build:test-macros.rs\n \n #![feature(proc_macro_hygiene)]\n \n #[macro_use]\n-extern crate bang_proc_macro;\n+extern crate test_macros;\n \n fn main() {\n-    bang_proc_macro!(println!(\"Hello, world!\"));\n+    identity!(println!(\"Hello, world!\"));\n }"}, {"sha": "0477b5c48ecc9600bf5b67493f2736875d76d1cd", "filename": "src/test/ui/proc-macro/macros-in-extern.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,25 +1,24 @@\n // aux-build:test-macros.rs\n // ignore-wasm32\n \n+#[macro_use]\n extern crate test_macros;\n \n-use test_macros::{nop_attr, no_output, emit_input};\n-\n fn main() {\n     assert_eq!(unsafe { rust_get_test_int() }, 0isize);\n     assert_eq!(unsafe { rust_dbg_extern_identity_u32(0xDEADBEEF) }, 0xDEADBEEF);\n }\n \n #[link(name = \"rust_test_helpers\", kind = \"static\")]\n extern {\n-    #[no_output]\n+    #[empty_attr]\n     //~^ ERROR macro invocations in `extern {}` blocks are experimental\n     fn some_definitely_unknown_symbol_which_should_be_removed();\n \n-    #[nop_attr]\n+    #[identity_attr]\n     //~^ ERROR macro invocations in `extern {}` blocks are experimental\n     fn rust_get_test_int() -> isize;\n \n-    emit_input!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n+    identity!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n     //~^ ERROR macro invocations in `extern {}` blocks are experimental\n }"}, {"sha": "592c91553aa8cf6972a4100408365699bf9c0e8a", "filename": "src/test/ui/proc-macro/macros-in-extern.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacros-in-extern.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,26 +1,26 @@\n error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:15:5\n+  --> $DIR/macros-in-extern.rs:14:5\n    |\n-LL |     #[no_output]\n-   |     ^^^^^^^^^^^^\n+LL |     #[empty_attr]\n+   |     ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n    = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n \n error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:19:5\n+  --> $DIR/macros-in-extern.rs:18:5\n    |\n-LL |     #[nop_attr]\n-   |     ^^^^^^^^^^^\n+LL |     #[identity_attr]\n+   |     ^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n    = help: add #![feature(macros_in_extern)] to the crate attributes to enable\n \n error[E0658]: macro invocations in `extern {}` blocks are experimental\n-  --> $DIR/macros-in-extern.rs:23:5\n+  --> $DIR/macros-in-extern.rs:22:5\n    |\n-LL |     emit_input!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     identity!(fn rust_dbg_extern_identity_u32(arg: u32) -> u32;);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/49476\n    = help: add #![feature(macros_in_extern)] to the crate attributes to enable"}, {"sha": "63da170d0bbb263c130eccc5502cc5373e80886e", "filename": "src/test/ui/proc-macro/nested-item-spans.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fnested-item-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fnested-item-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-item-spans.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,10 +1,9 @@\n-// aux-build:nested-item-spans.rs\n+// aux-build:test-macros.rs\n \n-extern crate nested_item_spans;\n+#[macro_use]\n+extern crate test_macros;\n \n-use nested_item_spans::foo;\n-\n-#[foo]\n+#[recollect_attr]\n fn another() {\n     fn bar() {\n         let x: u32 = \"x\"; //~ ERROR: mismatched types\n@@ -14,7 +13,7 @@ fn another() {\n }\n \n fn main() {\n-    #[foo]\n+    #[recollect_attr]\n     fn bar() {\n         let x: u32 = \"x\"; //~ ERROR: mismatched types\n     }"}, {"sha": "bef80311f38e5fa5f85c44b619d758ce975fba0f", "filename": "src/test/ui/proc-macro/nested-item-spans.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fnested-item-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fnested-item-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-item-spans.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/nested-item-spans.rs:10:22\n+  --> $DIR/nested-item-spans.rs:9:22\n    |\n LL |         let x: u32 = \"x\";\n    |                      ^^^ expected u32, found reference\n@@ -8,7 +8,7 @@ LL |         let x: u32 = \"x\";\n               found type `&'static str`\n \n error[E0308]: mismatched types\n-  --> $DIR/nested-item-spans.rs:19:22\n+  --> $DIR/nested-item-spans.rs:18:22\n    |\n LL |         let x: u32 = \"x\";\n    |                      ^^^ expected u32, found reference"}, {"sha": "15ab431fe754af5576fbaf600ba08e8635b649f0", "filename": "src/test/ui/proc-macro/no-macro-use-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,9 +1,9 @@\n-// aux-build:derive-a.rs\n+// aux-build:test-macros.rs\n \n #![feature(rustc_attrs)]\n #![warn(unused_extern_crates)]\n \n-extern crate derive_a;\n+extern crate test_macros;\n //~^ WARN unused extern crate\n \n #[rustc_error]"}, {"sha": "87487bcc7d6627526ecf15dcf57366d613c5a4ed", "filename": "src/test/ui/proc-macro/no-macro-use-attr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fno-macro-use-attr.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,8 +1,8 @@\n warning: unused extern crate\n   --> $DIR/no-macro-use-attr.rs:6:1\n    |\n-LL | extern crate derive_a;\n-   | ^^^^^^^^^^^^^^^^^^^^^^ help: remove it\n+LL | extern crate test_macros;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove it\n    |\n note: lint level defined here\n   --> $DIR/no-macro-use-attr.rs:4:9"}, {"sha": "678dc83b753b5f7b5143b846833c62c37698b4d9", "filename": "src/test/ui/proc-macro/proc-macro-gates.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,61 +1,62 @@\n-// aux-build:proc-macro-gates.rs\n+// aux-build:test-macros.rs\n // gate-test-proc_macro_hygiene\n \n #![feature(stmt_expr_attributes)]\n \n-extern crate proc_macro_gates as foo;\n-\n-use foo::*;\n+#[macro_use]\n+extern crate test_macros;\n \n fn _test_inner() {\n-    #![a] //~ ERROR: non-builtin inner attributes are unstable\n+    #![empty_attr] //~ ERROR: non-builtin inner attributes are unstable\n }\n \n-#[a] //~ ERROR: custom attributes cannot be applied to modules\n+#[empty_attr] //~ ERROR: custom attributes cannot be applied to modules\n mod _test2 {}\n \n mod _test2_inner {\n-    #![a] //~ ERROR: custom attributes cannot be applied to modules\n+    #![empty_attr] //~ ERROR: custom attributes cannot be applied to modules\n           //~| ERROR: non-builtin inner attributes are unstable\n }\n \n-#[a = \"y\"] //~ ERROR: must only be followed by a delimiter token\n+#[empty_attr = \"y\"] //~ ERROR: must only be followed by a delimiter token\n fn _test3() {}\n \n fn attrs() {\n     // Statement, item\n-    #[a] // OK\n+    #[empty_attr] // OK\n     struct S;\n \n     // Statement, macro\n-    #[a] //~ ERROR: custom attributes cannot be applied to statements\n+    #[empty_attr] //~ ERROR: custom attributes cannot be applied to statements\n     println!();\n \n     // Statement, semi\n-    #[a] //~ ERROR: custom attributes cannot be applied to statements\n+    #[empty_attr] //~ ERROR: custom attributes cannot be applied to statements\n     S;\n \n     // Statement, local\n-    #[a] //~ ERROR: custom attributes cannot be applied to statements\n+    #[empty_attr] //~ ERROR: custom attributes cannot be applied to statements\n     let _x = 2;\n \n     // Expr\n-    let _x = #[a] 2; //~ ERROR: custom attributes cannot be applied to expressions\n+    let _x = #[identity_attr] 2; //~ ERROR: custom attributes cannot be applied to expressions\n \n     // Opt expr\n-    let _x = [#[a] 2]; //~ ERROR: custom attributes cannot be applied to expressions\n+    let _x = [#[identity_attr] 2]; //~ ERROR: custom attributes cannot be applied to expressions\n \n     // Expr macro\n-    let _x = #[a] println!(); //~ ERROR: custom attributes cannot be applied to expressions\n+    let _x = #[identity_attr] println!();\n+    //~^ ERROR: custom attributes cannot be applied to expressions\n }\n \n fn main() {\n-    let _x: m!(u32) = 3; //~ ERROR: procedural macros cannot be expanded to types\n-    if let m!(Some(_x)) = Some(3) {} //~ ERROR: procedural macros cannot be expanded to patterns\n+    let _x: identity!(u32) = 3; //~ ERROR: procedural macros cannot be expanded to types\n+    if let identity!(Some(_x)) = Some(3) {}\n+    //~^ ERROR: procedural macros cannot be expanded to patterns\n \n-    m!(struct S;); //~ ERROR: procedural macros cannot be expanded to statements\n-    m!(let _x = 3;); //~ ERROR: procedural macros cannot be expanded to statements\n+    empty!(struct S;); //~ ERROR: procedural macros cannot be expanded to statements\n+    empty!(let _x = 3;); //~ ERROR: procedural macros cannot be expanded to statements\n \n-    let _x = m!(3); //~ ERROR: procedural macros cannot be expanded to expressions\n-    let _x = [m!(3)]; //~ ERROR: procedural macros cannot be expanded to expressions\n+    let _x = identity!(3); //~ ERROR: procedural macros cannot be expanded to expressions\n+    let _x = [empty!(3)]; //~ ERROR: procedural macros cannot be expanded to expressions\n }"}, {"sha": "f53ad222a036811c09746a32255496ccb8d98dfa", "filename": "src/test/ui/proc-macro/proc-macro-gates.stderr", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,149 +1,149 @@\n error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/proc-macro-gates.rs:11:5\n+  --> $DIR/proc-macro-gates.rs:10:5\n    |\n-LL |     #![a]\n-   |     ^^^^^\n+LL |     #![empty_attr]\n+   |     ^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54726\n    = help: add #![feature(custom_inner_attributes)] to the crate attributes to enable\n \n error[E0658]: non-builtin inner attributes are unstable\n-  --> $DIR/proc-macro-gates.rs:18:5\n+  --> $DIR/proc-macro-gates.rs:17:5\n    |\n-LL |     #![a]\n-   |     ^^^^^\n+LL |     #![empty_attr]\n+   |     ^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54726\n    = help: add #![feature(custom_inner_attributes)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to modules\n-  --> $DIR/proc-macro-gates.rs:14:1\n+  --> $DIR/proc-macro-gates.rs:13:1\n    |\n-LL | #[a]\n-   | ^^^^\n+LL | #[empty_attr]\n+   | ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to modules\n-  --> $DIR/proc-macro-gates.rs:18:5\n+  --> $DIR/proc-macro-gates.rs:17:5\n    |\n-LL |     #![a]\n-   |     ^^^^^\n+LL |     #![empty_attr]\n+   |     ^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error: custom attribute invocations must be of the form #[foo] or #[foo(..)], the macro name must only be followed by a delimiter token\n-  --> $DIR/proc-macro-gates.rs:22:1\n+  --> $DIR/proc-macro-gates.rs:21:1\n    |\n-LL | #[a = \"y\"]\n-   | ^^^^^^^^^^\n+LL | #[empty_attr = \"y\"]\n+   | ^^^^^^^^^^^^^^^^^^^\n \n error[E0658]: custom attributes cannot be applied to statements\n-  --> $DIR/proc-macro-gates.rs:31:5\n+  --> $DIR/proc-macro-gates.rs:30:5\n    |\n-LL |     #[a]\n-   |     ^^^^\n+LL |     #[empty_attr]\n+   |     ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to statements\n-  --> $DIR/proc-macro-gates.rs:35:5\n+  --> $DIR/proc-macro-gates.rs:34:5\n    |\n-LL |     #[a]\n-   |     ^^^^\n+LL |     #[empty_attr]\n+   |     ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to statements\n-  --> $DIR/proc-macro-gates.rs:39:5\n+  --> $DIR/proc-macro-gates.rs:38:5\n    |\n-LL |     #[a]\n-   |     ^^^^\n+LL |     #[empty_attr]\n+   |     ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to expressions\n-  --> $DIR/proc-macro-gates.rs:43:14\n+  --> $DIR/proc-macro-gates.rs:42:14\n    |\n-LL |     let _x = #[a] 2;\n-   |              ^^^^\n+LL |     let _x = #[identity_attr] 2;\n+   |              ^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to expressions\n-  --> $DIR/proc-macro-gates.rs:46:15\n+  --> $DIR/proc-macro-gates.rs:45:15\n    |\n-LL |     let _x = [#[a] 2];\n-   |               ^^^^\n+LL |     let _x = [#[identity_attr] 2];\n+   |               ^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: custom attributes cannot be applied to expressions\n-  --> $DIR/proc-macro-gates.rs:49:14\n+  --> $DIR/proc-macro-gates.rs:48:14\n    |\n-LL |     let _x = #[a] println!();\n-   |              ^^^^\n+LL |     let _x = #[identity_attr] println!();\n+   |              ^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to types\n   --> $DIR/proc-macro-gates.rs:53:13\n    |\n-LL |     let _x: m!(u32) = 3;\n-   |             ^^^^^^^\n+LL |     let _x: identity!(u32) = 3;\n+   |             ^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to patterns\n   --> $DIR/proc-macro-gates.rs:54:12\n    |\n-LL |     if let m!(Some(_x)) = Some(3) {}\n-   |            ^^^^^^^^^^^^\n+LL |     if let identity!(Some(_x)) = Some(3) {}\n+   |            ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to statements\n-  --> $DIR/proc-macro-gates.rs:56:5\n+  --> $DIR/proc-macro-gates.rs:57:5\n    |\n-LL |     m!(struct S;);\n-   |     ^^^^^^^^^^^^^^\n+LL |     empty!(struct S;);\n+   |     ^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to statements\n-  --> $DIR/proc-macro-gates.rs:57:5\n+  --> $DIR/proc-macro-gates.rs:58:5\n    |\n-LL |     m!(let _x = 3;);\n-   |     ^^^^^^^^^^^^^^^^\n+LL |     empty!(let _x = 3;);\n+   |     ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to expressions\n-  --> $DIR/proc-macro-gates.rs:59:14\n+  --> $DIR/proc-macro-gates.rs:60:14\n    |\n-LL |     let _x = m!(3);\n-   |              ^^^^^\n+LL |     let _x = identity!(3);\n+   |              ^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable\n \n error[E0658]: procedural macros cannot be expanded to expressions\n-  --> $DIR/proc-macro-gates.rs:60:15\n+  --> $DIR/proc-macro-gates.rs:61:15\n    |\n-LL |     let _x = [m!(3)];\n-   |               ^^^^^\n+LL |     let _x = [empty!(3)];\n+   |               ^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/54727\n    = help: add #![feature(proc_macro_hygiene)] to the crate attributes to enable"}, {"sha": "35d7fc8042a3d838038b13df0ebf02893069e0a1", "filename": "src/test/ui/proc-macro/proc-macro-gates2.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,21 +1,20 @@\n-// aux-build:proc-macro-gates.rs\n+// aux-build:test-macros.rs\n \n #![feature(stmt_expr_attributes)]\n \n-extern crate proc_macro_gates as foo;\n-\n-use foo::*;\n+#[macro_use]\n+extern crate test_macros;\n \n // NB. these errors aren't the best errors right now, but they're definitely\n // intended to be errors. Somehow using a custom attribute in these positions\n // should either require a feature gate or not be allowed on stable.\n \n-fn _test6<#[a] T>() {}\n+fn _test6<#[empty_attr] T>() {}\n //~^ ERROR: unknown to the compiler\n \n fn _test7() {\n     match 1 {\n-        #[a] //~ ERROR: unknown to the compiler\n+        #[empty_attr] //~ ERROR: unknown to the compiler\n         0 => {}\n         _ => {}\n     }"}, {"sha": "8eeca99ab39849723675650240eed6a9e946d12b", "filename": "src/test/ui/proc-macro/proc-macro-gates2.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fproc-macro-gates2.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,17 +1,17 @@\n-error[E0658]: The attribute `a` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/proc-macro-gates2.rs:13:11\n+error[E0658]: The attribute `empty_attr` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/proc-macro-gates2.rs:12:11\n    |\n-LL | fn _test6<#[a] T>() {}\n-   |           ^^^^\n+LL | fn _test6<#[empty_attr] T>() {}\n+   |           ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable\n \n-error[E0658]: The attribute `a` is currently unknown to the compiler and may have meaning added to it in the future\n-  --> $DIR/proc-macro-gates2.rs:18:9\n+error[E0658]: The attribute `empty_attr` is currently unknown to the compiler and may have meaning added to it in the future\n+  --> $DIR/proc-macro-gates2.rs:17:9\n    |\n-LL |         #[a]\n-   |         ^^^^\n+LL |         #[empty_attr]\n+   |         ^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/29642\n    = help: add #![feature(custom_attribute)] to the crate attributes to enable"}, {"sha": "82607136f0b6f2d87ee4ff3dc3f6d162ab3ceacc", "filename": "src/test/ui/proc-macro/resolve-error.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,19 +1,17 @@\n // aux-build:derive-foo.rs\n // aux-build:derive-clona.rs\n-// aux-build:attr_proc_macro.rs\n-// aux-build:bang_proc_macro.rs\n+// aux-build:test-macros.rs\n \n #![feature(custom_attribute)]\n \n #[macro_use]\n extern crate derive_foo;\n #[macro_use]\n extern crate derive_clona;\n-extern crate attr_proc_macro;\n-extern crate bang_proc_macro;\n+extern crate test_macros;\n \n-use attr_proc_macro::attr_proc_macro;\n-use bang_proc_macro::bang_proc_macro;\n+use test_macros::empty as bang_proc_macro;\n+use test_macros::empty_attr as attr_proc_macro;\n \n macro_rules! FooWithLongNam {\n     () => {}"}, {"sha": "705ef6006a049929573175538a1497428fab5fd4", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,47 +1,47 @@\n error: cannot find derive macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:26:10\n+  --> $DIR/resolve-error.rs:24:10\n    |\n LL | #[derive(FooWithLongNan)]\n    |          ^^^^^^^^^^^^^^ help: try: `FooWithLongName`\n \n error: cannot find derive macro `Dlone` in this scope\n-  --> $DIR/resolve-error.rs:36:10\n+  --> $DIR/resolve-error.rs:34:10\n    |\n LL | #[derive(Dlone)]\n    |          ^^^^^ help: try: `Clone`\n \n error: cannot find derive macro `Dlona` in this scope\n-  --> $DIR/resolve-error.rs:40:10\n+  --> $DIR/resolve-error.rs:38:10\n    |\n LL | #[derive(Dlona)]\n    |          ^^^^^ help: try: `Clona`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n-  --> $DIR/resolve-error.rs:44:10\n+  --> $DIR/resolve-error.rs:42:10\n    |\n LL | #[derive(attr_proc_macra)]\n    |          ^^^^^^^^^^^^^^^\n \n error: cannot find macro `FooWithLongNama!` in this scope\n-  --> $DIR/resolve-error.rs:49:5\n+  --> $DIR/resolve-error.rs:47:5\n    |\n LL |     FooWithLongNama!();\n    |     ^^^^^^^^^^^^^^^ help: you could try the macro: `FooWithLongNam`\n \n error: cannot find macro `attr_proc_macra!` in this scope\n-  --> $DIR/resolve-error.rs:52:5\n+  --> $DIR/resolve-error.rs:50:5\n    |\n LL |     attr_proc_macra!();\n    |     ^^^^^^^^^^^^^^^ help: you could try the macro: `attr_proc_mac`\n \n error: cannot find macro `Dlona!` in this scope\n-  --> $DIR/resolve-error.rs:55:5\n+  --> $DIR/resolve-error.rs:53:5\n    |\n LL |     Dlona!();\n    |     ^^^^^\n \n error: cannot find macro `bang_proc_macrp!` in this scope\n-  --> $DIR/resolve-error.rs:58:5\n+  --> $DIR/resolve-error.rs:56:5\n    |\n LL |     bang_proc_macrp!();\n    |     ^^^^^^^^^^^^^^^ help: you could try the macro: `bang_proc_macro`"}, {"sha": "61959594c7981b3c6386ce30916d06f58f16e943", "filename": "src/test/ui/proc-macro/shadow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fshadow.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,8 +1,8 @@\n-// aux-build:derive-a.rs\n+// aux-build:test-macros.rs\n \n #[macro_use]\n-extern crate derive_a;\n+extern crate test_macros;\n #[macro_use]\n-extern crate derive_a; //~ ERROR the name `derive_a` is defined multiple times\n+extern crate test_macros; //~ ERROR the name `test_macros` is defined multiple times\n \n fn main() {}"}, {"sha": "e7d95cc8358117d0c24f480b3cba9b40758845d3", "filename": "src/test/ui/proc-macro/shadow.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fshadow.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,13 +1,13 @@\n-error[E0259]: the name `derive_a` is defined multiple times\n+error[E0259]: the name `test_macros` is defined multiple times\n   --> $DIR/shadow.rs:6:1\n    |\n-LL | extern crate derive_a;\n-   | ---------------------- previous import of the extern crate `derive_a` here\n+LL | extern crate test_macros;\n+   | ------------------------- previous import of the extern crate `test_macros` here\n LL | #[macro_use]\n-LL | extern crate derive_a;\n-   | ^^^^^^^^^^^^^^^^^^^^^^ `derive_a` reimported here\n+LL | extern crate test_macros;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^ `test_macros` reimported here\n    |\n-   = note: `derive_a` must be defined only once in the type namespace of this module\n+   = note: `test_macros` must be defined only once in the type namespace of this module\n \n error: aborting due to previous error\n "}, {"sha": "0a82d28e9e544f830964545c26fc85348233effd", "filename": "src/test/ui/proc-macro/span-preservation.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -1,27 +1,26 @@\n //~ ERROR mismatched types\n-// aux-build:span-preservation.rs\n+// aux-build:test-macros.rs\n \n // For each of these, we should get the appropriate type mismatch error message,\n // and the function should be echoed.\n \n-extern crate span_preservation as foo;\n+#[macro_use]\n+extern crate test_macros;\n \n-use foo::foo;\n-\n-#[foo]\n+#[recollect_attr]\n fn a() {\n     let x: usize = \"hello\";;;;; //~ ERROR mismatched types\n }\n \n-#[foo]\n+#[recollect_attr]\n fn b(x: Option<isize>) -> usize {\n     match x {\n         Some(x) => { return x }, //~ ERROR mismatched types\n         None => 10\n     }\n }\n \n-#[foo]\n+#[recollect_attr]\n fn c() {\n     struct Foo {\n         a: usize\n@@ -39,12 +38,12 @@ fn c() {\n // FIXME: This doesn't work at the moment. See the one below. The pretty-printer\n // injects a \"C\" between `extern` and `fn` which causes a \"probably_eq\"\n // `TokenStream` mismatch. The lack of `\"C\"` should be preserved in the AST.\n-#[foo]\n+#[recollect_attr]\n extern fn bar() {\n     0\n }\n \n-#[foo]\n+#[recollect_attr]\n extern \"C\" fn baz() {\n     0 //~ ERROR mismatched types\n }"}, {"sha": "cf03deee7e44554dd2003cfe1a7a723f156c8f01", "filename": "src/test/ui/proc-macro/span-preservation.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n               found type `{integer}`\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:13:20\n+  --> $DIR/span-preservation.rs:12:20\n    |\n LL |     let x: usize = \"hello\";;;;;\n    |                    ^^^^^^^ expected usize, found reference\n@@ -13,7 +13,7 @@ LL |     let x: usize = \"hello\";;;;;\n               found type `&'static str`\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:19:29\n+  --> $DIR/span-preservation.rs:18:29\n    |\n LL | fn b(x: Option<isize>) -> usize {\n    |                           ----- expected `usize` because of return type\n@@ -22,21 +22,21 @@ LL |         Some(x) => { return x },\n    |                             ^ expected usize, found isize\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:35:22\n+  --> $DIR/span-preservation.rs:34:22\n    |\n LL |     let x = Foo { a: 10isize };\n    |                      ^^^^^^^ expected usize, found isize\n \n error[E0560]: struct `c::Foo` has no field named `b`\n-  --> $DIR/span-preservation.rs:36:26\n+  --> $DIR/span-preservation.rs:35:26\n    |\n LL |     let y = Foo { a: 10, b: 10isize };\n    |                          ^ `c::Foo` does not have this field\n    |\n    = note: available fields are: `a`\n \n error[E0308]: mismatched types\n-  --> $DIR/span-preservation.rs:49:5\n+  --> $DIR/span-preservation.rs:48:5\n    |\n LL | extern \"C\" fn baz() {\n    |                     - possibly return type missing here?"}, {"sha": "e9f763ad7cf67ca425d8c2911e5c7e5e803fa4b4", "filename": "src/test/ui/symbol-names/issue-60925.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,39 @@\n+#![feature(rustc_attrs)]\n+\n+// This test is the same code as in ui/issue-53912.rs but this test checks that the symbol mangling\n+// fix produces the correct result, whereas that test just checks that the reproduction compiles\n+// successfully and doesn't segfault\n+\n+fn dummy() {}\n+\n+mod llvm {\n+    pub(crate) struct Foo;\n+}\n+mod foo {\n+    pub(crate) struct Foo<T>(T);\n+\n+    impl Foo<::llvm::Foo> {\n+        #[rustc_symbol_name]\n+//~^ ERROR _ZN11issue_609253foo36Foo$LT$issue_60925..llv$6d$..Foo$GT$3foo17h059a991a004536adE\n+        pub(crate) fn foo() {\n+            for _ in 0..0 {\n+                for _ in &[::dummy()] {\n+                    ::dummy();\n+                    ::dummy();\n+                    ::dummy();\n+                }\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn foo() {\n+        Foo::foo();\n+        Foo::foo();\n+    }\n+}\n+\n+pub fn foo() {\n+    foo::foo();\n+}\n+\n+fn main() {}"}, {"sha": "84a18745e2ea7cce95fb722ed783603012bfb70d", "filename": "src/test/ui/symbol-names/issue-60925.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -0,0 +1,8 @@\n+error: symbol-name(_ZN11issue_609253foo36Foo$LT$issue_60925..llv$6d$..Foo$GT$3foo17h059a991a004536adE)\n+  --> $DIR/issue-60925.rs:16:9\n+   |\n+LL |         #[rustc_symbol_name]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4f505c05a6a2ce9021d7c263138a573318988007", "filename": "src/test/ui/tuple/tuple-arity-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -13,5 +13,5 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| expected type `(isize, f64)`\n     //~| found type `(isize,)`\n-    //~| expected a tuple with 2 elements, found one with 1 elements\n+    //~| expected a tuple with 2 elements, found one with 1 element\n }"}, {"sha": "6946a60c59af9b1e6a0bef1a55cf9d86369b7514", "filename": "src/test/ui/tuple/tuple-arity-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Ftuple-arity-mismatch.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -11,7 +11,7 @@ error[E0308]: mismatched types\n   --> $DIR/tuple-arity-mismatch.rs:12:20\n    |\n LL |     let y = first ((1,));\n-   |                    ^^^^ expected a tuple with 2 elements, found one with 1 elements\n+   |                    ^^^^ expected a tuple with 2 elements, found one with 1 element\n    |\n    = note: expected type `(isize, f64)`\n               found type `(isize,)`"}, {"sha": "5ad50ffcbc389cabdef2eba58d1d284275495aed", "filename": "src/test/ui/type/type-dependent-def-issue-49241.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.rs?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -3,4 +3,5 @@ fn main() {\n     const l: usize = v.count(); //~ ERROR attempt to use a non-constant value in a constant\n     let s: [u32; l] = v.into_iter().collect();\n     //~^ ERROR evaluation of constant value failed\n+    //~^^ ERROR a collection of type\n }"}, {"sha": "851004d10589712426b56cbdf720aba562b201fb", "filename": "src/test/ui/type/type-dependent-def-issue-49241.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b9d80325a65b0375eea526409a0f3aaf1cbc23c/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-dependent-def-issue-49241.stderr?ref=4b9d80325a65b0375eea526409a0f3aaf1cbc23c", "patch": "@@ -10,7 +10,15 @@ error[E0080]: evaluation of constant value failed\n LL |     let s: [u32; l] = v.into_iter().collect();\n    |                  ^ referenced constant has errors\n \n-error: aborting due to 2 previous errors\n+error[E0277]: a collection of type `[u32; _]` cannot be built from an iterator over elements of type `{integer}`\n+  --> $DIR/type-dependent-def-issue-49241.rs:4:37\n+   |\n+LL |     let s: [u32; l] = v.into_iter().collect();\n+   |                                     ^^^^^^^ a collection of type `[u32; _]` cannot be built from `std::iter::Iterator<Item={integer}>`\n+   |\n+   = help: the trait `std::iter::FromIterator<{integer}>` is not implemented for `[u32; _]`\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0080, E0435.\n+Some errors have detailed explanations: E0080, E0277, E0435.\n For more information about an error, try `rustc --explain E0080`."}]}