{"sha": "7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiOTUxOWE1ZDQ3ODc5YzM3ZjBhYzY4NzFjZWUyZTFjYjhlY2ExY2M=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-08T16:45:27Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-06-14T20:33:47Z"}, "message": "suppress trait errors that are implied by other errors\n\nInstead of suppressing only trait errors that are \"exact duplicates\",\ndisplay only the \"most high-level\" error when there are multiple trait\nerrors with the same span that imply each-other.\n\ne.g. when there are both `[closure]: Fn` and `[closure]: FnOnce`, omit\ndisplaying the `[closure]: FnOnce` bound.", "tree": {"sha": "1b8bb3473a2bb99d18f8a84e2a1ae5643672a8aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8bb3473a2bb99d18f8a84e2a1ae5643672a8aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "html_url": "https://github.com/rust-lang/rust/commit/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfa7e21e4ee555d04c0fb86069f5acffee3550ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfa7e21e4ee555d04c0fb86069f5acffee3550ad", "html_url": "https://github.com/rust-lang/rust/commit/dfa7e21e4ee555d04c0fb86069f5acffee3550ad"}], "stats": {"total": 542, "additions": 277, "deletions": 265}, "files": [{"sha": "11bac21bc429e99b661f56908fc553796f44c16f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -74,6 +74,7 @@ use syntax_pos::{Pos, Span};\n use errors::{DiagnosticBuilder, DiagnosticStyledString};\n \n mod note;\n+mod need_type_info;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,"}, {"sha": "7361d66428f6d94cb052590dbe07fd6828ae652f", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -0,0 +1,153 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::{self, map, Local, Pat, Body};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use infer::InferCtxt;\n+use infer::type_variable::TypeVariableOrigin;\n+use ty::{self, Ty, TyInfer, TyVar};\n+\n+use syntax::ast::NodeId;\n+use syntax_pos::Span;\n+\n+struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    target_ty: &'a Ty<'tcx>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    found_local_pattern: Option<&'gcx Pat>,\n+    found_arg_pattern: Option<&'gcx Pat>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n+        let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n+            tables.borrow().node_id_to_type_opt(node_id)\n+        });\n+        match ty_opt {\n+            Some(ty) => {\n+                let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                ty.walk().any(|inner_ty| {\n+                    inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n+                        (&TyInfer(TyVar(a_vid)), &TyInfer(TyVar(b_vid))) => {\n+                            self.infcx\n+                                .type_variables\n+                                .borrow_mut()\n+                                .sub_unified(a_vid, b_vid)\n+                        }\n+                        _ => false,\n+                    }\n+                })\n+            }\n+            None => false,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+    }\n+\n+    fn visit_local(&mut self, local: &'gcx Local) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n+            self.found_local_pattern = Some(&*local.pat);\n+        }\n+        intravisit::walk_local(self, local);\n+    }\n+\n+    fn visit_body(&mut self, body: &'gcx Body) {\n+        for argument in &body.arguments {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n+                self.found_arg_pattern = Some(&*argument.pat);\n+            }\n+        }\n+        intravisit::walk_body(self, body);\n+    }\n+}\n+\n+\n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n+        if let ty::TyInfer(ty::TyVar(ty_vid)) = (*ty).sty {\n+            let ty_vars = self.type_variables.borrow();\n+            if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n+                *ty_vars.var_origin(ty_vid) {\n+                name.to_string()\n+            } else {\n+                ty.to_string()\n+            }\n+        } else {\n+            ty.to_string()\n+        }\n+    }\n+\n+    pub fn need_type_info(&self, body_id: hir::BodyId, span: Span, ty: Ty<'tcx>) {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let name = self.extract_type_name(&ty);\n+\n+        let mut err_span = span;\n+        let mut labels = vec![(span, format!(\"cannot infer type for `{}`\", name))];\n+\n+        let mut local_visitor = FindLocalByTypeVisitor {\n+            infcx: &self,\n+            target_ty: &ty,\n+            hir_map: &self.tcx.hir,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n+        };\n+\n+        // #40294: cause.body_id can also be a fn declaration.\n+        // Currently, if it's anything other than NodeExpr, we just ignore it\n+        match self.tcx.hir.find(body_id.node_id) {\n+            Some(map::NodeExpr(expr)) => local_visitor.visit_expr(expr),\n+            _ => ()\n+        }\n+\n+        if let Some(pattern) = local_visitor.found_arg_pattern {\n+            err_span = pattern.span;\n+            // We don't want to show the default label for closures.\n+            //\n+            // So, before clearing, the output would look something like this:\n+            // ```\n+            // let x = |_| {  };\n+            //          -  ^^^^ cannot infer type for `[_; 0]`\n+            //          |\n+            //          consider giving this closure parameter a type\n+            // ```\n+            //\n+            // After clearing, it looks something like this:\n+            // ```\n+            // let x = |_| {  };\n+            //          ^ consider giving this closure parameter a type\n+            // ```\n+            labels.clear();\n+            labels.push((pattern.span, format!(\"consider giving this closure parameter a type\")));\n+        }\n+\n+        if let Some(pattern) = local_visitor.found_local_pattern {\n+            if let Some(simple_name) = pattern.simple_name() {\n+                labels.push((pattern.span, format!(\"consider giving `{}` a type\", simple_name)));\n+            } else {\n+                labels.push((pattern.span, format!(\"consider giving the pattern a type\")));\n+            }\n+        }\n+\n+        let mut err = struct_span_err!(self.tcx.sess,\n+                                       err_span,\n+                                       E0282,\n+                                       \"type annotations needed\");\n+\n+        for (target_span, label_message) in labels {\n+            err.span_label(target_span, label_message);\n+        }\n+\n+        err.emit();\n+    }\n+}"}, {"sha": "f96e8c389d68d87db962994d2941e56309572e54", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -36,7 +36,7 @@ use std::fmt;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n-use util::nodemap::{FxHashMap, FxHashSet};\n+use util::nodemap::FxHashMap;\n use arena::DroplessArena;\n \n use self::combine::CombineFields;\n@@ -110,7 +110,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // the set of predicates on which errors have been reported, to\n     // avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FxHashSet<traits::TraitErrorKey<'tcx>>>,\n+    pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n \n     // When an error occurs, we want to avoid reporting \"derived\"\n     // errors that are due to this original failure. Normally, we\n@@ -350,6 +350,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n             fresh_tables: None,\n+\n         }\n     }\n }\n@@ -381,7 +382,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             region_vars: RegionVarBindings::new(tcx),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FxHashSet()),\n+            reported_trait_errors: RefCell::new(FxHashMap()),\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),"}, {"sha": "247fb079fe7ee68d0d3ac4204d299cf81ea550dc", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 92, "deletions": 154, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -18,23 +18,22 @@ use super::{\n     OutputTypeParameterMismatch,\n     TraitNotObjectSafe,\n     PredicateObligation,\n+    Reveal,\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n };\n \n use errors::DiagnosticBuilder;\n use fmt_macros::{Parser, Piece, Position};\n-use hir::{self, intravisit, Local, Pat, Body};\n-use hir::intravisit::{Visitor, NestedVisitorMap};\n-use hir::map::NodeExpr;\n+use hir;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n-use syntax::ast::{self, NodeId};\n-use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable, TyInfer, TyVar};\n+use syntax::ast;\n+use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n@@ -44,96 +43,113 @@ use util::nodemap::{FxHashMap, FxHashSet};\n \n use syntax_pos::{DUMMY_SP, Span};\n \n+impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n+    pub fn report_fulfillment_errors(&self,\n+                                     errors: &Vec<FulfillmentError<'tcx>>) {\n+        #[derive(Debug)]\n+        struct ErrorDescriptor<'tcx> {\n+            predicate: ty::Predicate<'tcx>,\n+            index: Option<usize>, // None if this is an old error\n+        }\n \n-#[derive(Debug, PartialEq, Eq, Hash)]\n-pub struct TraitErrorKey<'tcx> {\n-    span: Span,\n-    predicate: ty::Predicate<'tcx>\n-}\n+        let mut error_map : FxHashMap<_, _> =\n+            self.reported_trait_errors.borrow().iter().map(|(&span, predicates)| {\n+                (span, predicates.iter().map(|predicate| ErrorDescriptor {\n+                    predicate: predicate.clone(),\n+                    index: None\n+                }).collect())\n+            }).collect();\n+\n+        for (index, error) in errors.iter().enumerate() {\n+            error_map.entry(error.obligation.cause.span).or_insert(Vec::new()).push(\n+                ErrorDescriptor {\n+                    predicate: error.obligation.predicate.clone(),\n+                    index: Some(index)\n+                });\n \n-impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n-    fn from_error(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                  e: &FulfillmentError<'tcx>) -> Self {\n-        let predicate =\n-            infcx.resolve_type_vars_if_possible(&e.obligation.predicate);\n-        TraitErrorKey {\n-            span: e.obligation.cause.span,\n-            predicate: infcx.tcx.erase_regions(&predicate)\n+            self.reported_trait_errors.borrow_mut()\n+                .entry(error.obligation.cause.span).or_insert(Vec::new())\n+                .push(error.obligation.predicate.clone());\n         }\n-    }\n-}\n \n-struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    target_ty: &'a Ty<'tcx>,\n-    hir_map: &'a hir::map::Map<'gcx>,\n-    found_local_pattern: Option<&'gcx Pat>,\n-    found_arg_pattern: Option<&'gcx Pat>,\n-}\n+        // We do this in 2 passes because we want to display errors in order, tho\n+        // maybe it *is* better to sort errors by span or something.\n+        let mut is_suppressed: Vec<bool> = errors.iter().map(|_| false).collect();\n+        for (_, error_set) in error_map.iter() {\n+            // We want to suppress \"duplicate\" errors with the same span.\n+            for error in error_set {\n+                if let Some(index) = error.index {\n+                    // Suppress errors that are either:\n+                    // 1) strictly implied by another error.\n+                    // 2) implied by an error with a smaller index.\n+                    for error2 in error_set {\n+                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                            // Avoid errors being suppressed by already-suppressed\n+                            // errors, to prevent all errors from being suppressed\n+                            // at once.\n+                            continue\n+                        }\n \n-impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n-        let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n-            tables.borrow().node_id_to_type_opt(node_id)\n-        });\n-        match ty_opt {\n-            Some(ty) => {\n-                let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n-                ty.walk().any(|inner_ty| {\n-                    inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n-                        (&TyInfer(TyVar(a_vid)), &TyInfer(TyVar(b_vid))) => {\n-                            self.infcx\n-                                .type_variables\n-                                .borrow_mut()\n-                                .sub_unified(a_vid, b_vid)\n+                        if self.error_implies(&error2.predicate, &error.predicate) &&\n+                            !(error2.index >= error.index &&\n+                              self.error_implies(&error.predicate, &error2.predicate))\n+                        {\n+                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n+                            is_suppressed[index] = true;\n+                            break\n                         }\n-                        _ => false,\n                     }\n-                })\n+                }\n             }\n-            None => false,\n         }\n-    }\n-}\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::OnlyBodies(&self.hir_map)\n+        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+            if !suppressed {\n+                self.report_fulfillment_error(error);\n+            }\n+        }\n     }\n \n-    fn visit_local(&mut self, local: &'gcx Local) {\n-        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n-            self.found_local_pattern = Some(&*local.pat);\n+    // returns if `cond` not occuring implies that `error` does not occur - i.e. that\n+    // `error` occuring implies that `cond` occurs.\n+    fn error_implies(&self,\n+                     cond: &ty::Predicate<'tcx>,\n+                     error: &ty::Predicate<'tcx>)\n+                     -> bool\n+    {\n+        if cond == error {\n+            return true\n         }\n-        intravisit::walk_local(self, local);\n-    }\n \n-    fn visit_body(&mut self, body: &'gcx Body) {\n-        for argument in &body.arguments {\n-            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n-                self.found_arg_pattern = Some(&*argument.pat);\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error))\n+                => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false\n             }\n-        }\n-        intravisit::walk_body(self, body);\n-    }\n-}\n+        };\n \n-impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n-        for error in errors {\n-            self.report_fulfillment_error(error);\n+        for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n+            if let ty::Predicate::Trait(implication) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n+                if let Ok(_) = self.can_sub(param_env, error, implication) {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true\n+                }\n+            }\n         }\n+\n+        false\n     }\n \n-    fn report_fulfillment_error(&self,\n-                                error: &FulfillmentError<'tcx>) {\n-        let error_key = TraitErrorKey::from_error(self, error);\n-        debug!(\"report_fulfillment_errors({:?}) - key={:?}\",\n-               error, error_key);\n-        if !self.reported_trait_errors.borrow_mut().insert(error_key) {\n-            debug!(\"report_fulfillment_errors: skipping duplicate\");\n-            return;\n-        }\n+    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>) {\n+        debug!(\"report_fulfillment_errors({:?})\", error);\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref e) => {\n                 self.report_selection_error(&error.obligation, e);\n@@ -1008,83 +1024,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn extract_type_name(&self, ty: &'a Ty<'tcx>) -> String {\n-        if let ty::TyInfer(ty::TyVar(ty_vid)) = (*ty).sty {\n-            let ty_vars = self.type_variables.borrow();\n-            if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n-                *ty_vars.var_origin(ty_vid) {\n-                name.to_string()\n-            } else {\n-                ty.to_string()\n-            }\n-        } else {\n-            ty.to_string()\n-        }\n-    }\n-\n-    pub fn need_type_info(&self, body_id: hir::BodyId, span: Span, ty: Ty<'tcx>) {\n-        let ty = self.resolve_type_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty);\n-\n-        let mut err_span = span;\n-        let mut labels = vec![(span, format!(\"cannot infer type for `{}`\", name))];\n-\n-        let mut local_visitor = FindLocalByTypeVisitor {\n-            infcx: &self,\n-            target_ty: &ty,\n-            hir_map: &self.tcx.hir,\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-        };\n-\n-        // #40294: cause.body_id can also be a fn declaration.\n-        // Currently, if it's anything other than NodeExpr, we just ignore it\n-        match self.tcx.hir.find(body_id.node_id) {\n-            Some(NodeExpr(expr)) => local_visitor.visit_expr(expr),\n-            _ => ()\n-        }\n-\n-        if let Some(pattern) = local_visitor.found_arg_pattern {\n-            err_span = pattern.span;\n-            // We don't want to show the default label for closures.\n-            //\n-            // So, before clearing, the output would look something like this:\n-            // ```\n-            // let x = |_| {  };\n-            //          -  ^^^^ cannot infer type for `[_; 0]`\n-            //          |\n-            //          consider giving this closure parameter a type\n-            // ```\n-            //\n-            // After clearing, it looks something like this:\n-            // ```\n-            // let x = |_| {  };\n-            //          ^ consider giving this closure parameter a type\n-            // ```\n-            labels.clear();\n-            labels.push((pattern.span, format!(\"consider giving this closure parameter a type\")));\n-        }\n-\n-        if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_name) = pattern.simple_name() {\n-                labels.push((pattern.span, format!(\"consider giving `{}` a type\", simple_name)));\n-            } else {\n-                labels.push((pattern.span, format!(\"consider giving the pattern a type\")));\n-            }\n-        }\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                                       err_span,\n-                                       E0282,\n-                                       \"type annotations needed\");\n-\n-        for (target_span, label_message) in labels {\n-            err.span_label(target_span, label_message);\n-        }\n-\n-        err.emit();\n-    }\n-\n     fn note_obligation_cause<T>(&self,\n                                 err: &mut DiagnosticBuilder,\n                                 obligation: &Obligation<'tcx, T>)\n@@ -1205,4 +1144,3 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                           suggested_limit));\n     }\n }\n-"}, {"sha": "e9196cd12431bc825b13e3ffde7bf5edd5a883f4", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -28,7 +28,6 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub use self::error_reporting::TraitErrorKey;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;"}, {"sha": "8bd992b12e625b048e72dd9e62643d97c038031f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -1101,7 +1101,10 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n             }\n \n             let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n-                      format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n+                      format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL),\n+                      format!(\"rustc {} running on {}\",\n+                              option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+                              config::host_triple())];\n             for note in &xs {\n                 handler.emit(&MultiSpan::new(),\n                              &note,"}, {"sha": "66b06c505e476768cd64fd62b8685fd154e7d629", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -18,5 +18,4 @@ fn main() {\n     let _x: extern \"C\" fn() = f; // OK\n     is_fn(f);\n     //~^ ERROR `extern \"C\" fn() {f}: std::ops::Fn<()>` is not satisfied\n-    //~| ERROR `extern \"C\" fn() {f}: std::ops::FnOnce<()>` is not satisfied\n }"}, {"sha": "6d70f54edb4292a680f2ca0f5c0daf302934f987", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -28,5 +28,4 @@ fn main() {\n \n     needs_fn(1);\n     //~^ ERROR : std::ops::Fn<(isize,)>`\n-    //~| ERROR : std::ops::FnOnce<(isize,)>`\n }"}, {"sha": "5271ea79917841658ac2b6ca58e60b9d3f49b602", "filename": "src/test/compile-fail/issue-22034.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22034.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -17,6 +17,5 @@ fn main() {\n     let _: &mut Fn() = unsafe {\n         &mut *(ptr as *mut Fn())\n         //~^ ERROR `(): std::ops::Fn<()>` is not satisfied\n-        //~| ERROR `(): std::ops::FnOnce<()>` is not satisfied\n     };\n }"}, {"sha": "544d3c8af2054700464aa13d3e1ec645738caab3", "filename": "src/test/compile-fail/issue-23966.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fissue-23966.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fissue-23966.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23966.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -11,5 +11,4 @@\n fn main() {\n     \"\".chars().fold(|_, _| (), ());\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }"}, {"sha": "cf5c40bd1761d5098c42cba3725b0eb78a816790", "filename": "src/test/compile-fail/range_traits-1.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange_traits-1.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -17,77 +17,70 @@ use std::ops::*;\n struct AllTheRanges {\n     a: Range<usize>,\n     //~^ ERROR PartialOrd\n-    //~^^ ERROR PartialOrd\n-    //~^^^ ERROR Ord\n+    //~^^ ERROR Ord\n+    //~^^^ ERROR binary operation\n     //~^^^^ ERROR binary operation\n     //~^^^^^ ERROR binary operation\n     //~^^^^^^ ERROR binary operation\n     //~^^^^^^^ ERROR binary operation\n     //~^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^^ ERROR binary operation\n-    //~^^^^^^^^^^^ ERROR binary operation\n     b: RangeTo<usize>,\n     //~^ ERROR PartialOrd\n-    //~^^ ERROR PartialOrd\n-    //~^^^ ERROR Ord\n+    //~^^ ERROR Ord\n+    //~^^^ ERROR binary operation\n     //~^^^^ ERROR binary operation\n     //~^^^^^ ERROR binary operation\n     //~^^^^^^ ERROR binary operation\n     //~^^^^^^^ ERROR binary operation\n     //~^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^^ ERROR binary operation\n-    //~^^^^^^^^^^^ ERROR binary operation\n     c: RangeFrom<usize>,\n     //~^ ERROR PartialOrd\n-    //~^^ ERROR PartialOrd\n-    //~^^^ ERROR Ord\n+    //~^^ ERROR Ord\n+    //~^^^ ERROR binary operation\n     //~^^^^ ERROR binary operation\n     //~^^^^^ ERROR binary operation\n     //~^^^^^^ ERROR binary operation\n     //~^^^^^^^ ERROR binary operation\n     //~^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^^ ERROR binary operation\n-    //~^^^^^^^^^^^ ERROR binary operation\n     d: RangeFull,\n     //~^ ERROR PartialOrd\n-    //~^^ ERROR PartialOrd\n-    //~^^^ ERROR Ord\n+    //~^^ ERROR Ord\n+    //~^^^ ERROR binary operation\n     //~^^^^ ERROR binary operation\n     //~^^^^^ ERROR binary operation\n     //~^^^^^^ ERROR binary operation\n     //~^^^^^^^ ERROR binary operation\n     //~^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^^ ERROR binary operation\n-    //~^^^^^^^^^^^ ERROR binary operation\n     e: RangeInclusive<usize>,\n     //~^ ERROR PartialOrd\n-    //~^^ ERROR PartialOrd\n-    //~^^^ ERROR Ord\n+    //~^^ ERROR Ord\n+    //~^^^ ERROR binary operation\n     //~^^^^ ERROR binary operation\n     //~^^^^^ ERROR binary operation\n     //~^^^^^^ ERROR binary operation\n     //~^^^^^^^ ERROR binary operation\n     //~^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^^ ERROR binary operation\n-    //~^^^^^^^^^^^ ERROR binary operation\n     f: RangeToInclusive<usize>,\n     //~^ ERROR PartialOrd\n-    //~^^ ERROR PartialOrd\n-    //~^^^ ERROR Ord\n+    //~^^ ERROR Ord\n+    //~^^^ ERROR binary operation\n     //~^^^^ ERROR binary operation\n     //~^^^^^ ERROR binary operation\n     //~^^^^^^ ERROR binary operation\n     //~^^^^^^^ ERROR binary operation\n     //~^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^ ERROR binary operation\n     //~^^^^^^^^^^ ERROR binary operation\n-    //~^^^^^^^^^^^ ERROR binary operation\n }\n \n fn main() {}\n-"}, {"sha": "219fcdfd7026531d935abbe1354da050de769ef0", "filename": "src/test/compile-fail/str-mut-idx.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstr-mut-idx.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -15,8 +15,7 @@ fn mutate(s: &mut str) {\n     //~^ ERROR `str: std::marker::Sized` is not satisfied\n     //~| ERROR `str: std::marker::Sized` is not satisfied\n     s[1usize] = bot();\n-    //~^ ERROR `str: std::ops::Index<usize>` is not satisfied\n-    //~| ERROR `str: std::ops::IndexMut<usize>` is not satisfied\n+    //~^ ERROR `str: std::ops::IndexMut<usize>` is not satisfied\n }\n \n pub fn main() {}"}, {"sha": "5ba93bf483f2d87753bef82690b89e7e5e29c8eb", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -21,13 +21,11 @@ fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n fn a() {\n     let x = call_it(&square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }\n \n fn b() {\n     let y = call_it_mut(&mut square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }\n \n fn c() {"}, {"sha": "ff06f7c559b2a9f8bb4041be8cad727416c2d4e4", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -21,13 +21,11 @@ fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n fn a() {\n     let x = call_it(&square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }\n \n fn b() {\n     let y = call_it_mut(&mut square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }\n \n fn c() {"}, {"sha": "d77750d2a04099d9fb9a7fb505036c8cc05d4db1", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -22,13 +22,11 @@ fn call_it_once<F:FnOnce(&isize)->isize>(_: F, _: isize) -> isize { 0 }\n fn a() {\n     let x = call_it(&square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }\n \n fn b() {\n     let y = call_it_mut(&mut square, 22);\n     //~^ ERROR E0277\n-    //~| ERROR E0277\n }\n \n fn c() {"}, {"sha": "dec8699f46e3b3542b67f6f22377d0292b08f691", "filename": "src/test/compile-fail/unsized6.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fcompile-fail%2Funsized6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized6.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -12,15 +12,15 @@\n \n trait T {}\n \n-fn f1<X: ?Sized>(x: &X) {\n-    let _: X; // <-- this is OK, no bindings created, no initializer.\n+fn f1<W: ?Sized, X: ?Sized, Y: ?Sized, Z: ?Sized>(x: &X) {\n+    let _: W; // <-- this is OK, no bindings created, no initializer.\n     let _: (isize, (X, isize)); //~ERROR `X: std::marker::Sized` is not satisfie\n-    let y: X; //~ERROR `X: std::marker::Sized` is not satisfied\n-    let y: (isize, (X, usize));\n+    let y: Y; //~ERROR `Y: std::marker::Sized` is not satisfied\n+    let y: (isize, (Z, usize)); //~ERROR `Z: std::marker::Sized` is not satisfied\n }\n-fn f2<X: ?Sized + T>(x: &X) {\n+fn f2<X: ?Sized, Y: ?Sized>(x: &X) {\n     let y: X; //~ERROR `X: std::marker::Sized` is not satisfied\n-    let y: (isize, (X, isize)); //~ERROR `X: std::marker::Sized` is not satisfied\n+    let y: (isize, (Y, isize)); //~ERROR `Y: std::marker::Sized` is not satisfied\n }\n \n fn f3<X: ?Sized>(x1: Box<X>, x2: Box<X>, x3: Box<X>) {"}, {"sha": "3eb5c125789fc3ae44410541c6e244ae8e8d95c9", "filename": "src/test/ui/mismatched_types/E0281.stderr", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2FE0281.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2FE0281.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0281.stderr?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -9,16 +9,5 @@ error[E0281]: type mismatch: `[closure@$DIR/E0281.rs:14:9: 14:24]` implements th\n    |\n    = note: required by `foo`\n \n-error[E0281]: type mismatch: `[closure@$DIR/E0281.rs:14:9: 14:24]` implements the trait `std::ops::FnOnce<(std::string::String,)>`, but the trait `std::ops::FnOnce<(usize,)>` is required\n-  --> $DIR/E0281.rs:14:5\n-   |\n-14 |     foo(|y: String| { });\n-   |     ^^^ --------------- implements `std::ops::FnOnce<(std::string::String,)>`\n-   |     |\n-   |     requires `std::ops::FnOnce<(usize,)>`\n-   |     expected usize, found struct `std::string::String`\n-   |\n-   = note: required by `foo`\n-\n error: aborting due to previous error(s)\n "}, {"sha": "cebdc12f5684d73331c50860163000f4f9d23ebc", "filename": "src/test/ui/mismatched_types/binops.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -30,14 +30,6 @@ error[E0277]: the trait bound `{integer}: std::ops::Div<&str>` is not satisfied\n    |\n    = help: the trait `std::ops::Div<&str>` is not implemented for `{integer}`\n \n-error[E0277]: the trait bound `{integer}: std::cmp::PartialEq<std::string::String>` is not satisfied\n-  --> $DIR/binops.rs:16:7\n-   |\n-16 |     5 < String::new();\n-   |       ^ can't compare `{integer}` with `std::string::String`\n-   |\n-   = help: the trait `std::cmp::PartialEq<std::string::String>` is not implemented for `{integer}`\n-\n error[E0277]: the trait bound `{integer}: std::cmp::PartialOrd<std::string::String>` is not satisfied\n   --> $DIR/binops.rs:16:7\n    |"}, {"sha": "85734dfac70d92f88679bab35e289ed9f77e934c", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -6,22 +6,6 @@ error[E0593]: closure takes 0 arguments but 2 arguments are required\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure takes 0 arguments but 2 arguments are required\n-  --> $DIR/closure-arg-count.rs:12:15\n-   |\n-12 |     [1, 2, 3].sort_by(|| panic!());\n-   |               ^^^^^^^ ----------- takes 0 arguments\n-   |               |\n-   |               expected closure that takes 2 arguments\n-\n-error[E0593]: closure takes 1 argument but 2 arguments are required\n-  --> $DIR/closure-arg-count.rs:13:15\n-   |\n-13 |     [1, 2, 3].sort_by(|tuple| panic!());\n-   |               ^^^^^^^ ---------------- takes 1 argument\n-   |               |\n-   |               expected closure that takes 2 arguments\n-\n error[E0593]: closure takes 1 argument but 2 arguments are required\n   --> $DIR/closure-arg-count.rs:13:15\n    |\n@@ -47,13 +31,5 @@ error[E0593]: closure takes 1 argument but 2 arguments are required\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure takes 1 argument but 2 arguments are required\n-  --> $DIR/closure-arg-count.rs:14:15\n-   |\n-14 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |               ^^^^^^^ -------------------------- takes 1 argument\n-   |               |\n-   |               expected closure that takes 2 arguments\n-\n error: aborting due to previous error(s)\n "}, {"sha": "f818bd8bcb1bbf60d6cf30694788551b36b82ea4", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -17,14 +17,5 @@ error[E0281]: type mismatch: `[closure@$DIR/issue-36053-2.rs:17:39: 17:53]` impl\n    |                                requires `for<'r> std::ops::FnMut<(&'r &str,)>`\n    |                                expected &str, found str\n \n-error[E0281]: type mismatch: `[closure@$DIR/issue-36053-2.rs:17:39: 17:53]` implements the trait `for<'r> std::ops::FnOnce<(&'r str,)>`, but the trait `for<'r> std::ops::FnOnce<(&'r &str,)>` is required\n-  --> $DIR/issue-36053-2.rs:17:32\n-   |\n-17 |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n-   |                                ^^^^^^ -------------- implements `for<'r> std::ops::FnOnce<(&'r str,)>`\n-   |                                |\n-   |                                requires `for<'r> std::ops::FnOnce<(&'r &str,)>`\n-   |                                expected &str, found str\n-\n error: aborting due to previous error(s)\n "}, {"sha": "693a1585320eea02abde9b9202e27c09eb3f0307", "filename": "src/test/ui/mismatched_types/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Funboxed-closures-vtable-mismatch.rs?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -24,7 +24,6 @@ pub fn main() {\n     //~| NOTE implements\n     let z = call_it(3, f);\n     //~^ ERROR type mismatch\n-    //~| ERROR type mismatch\n     //~| NOTE expected isize, found usize\n     //~| NOTE expected isize, found usize\n     //~| NOTE requires"}, {"sha": "643c9b36dbd513dbc7beae5ee123b8a5769c17b4", "filename": "src/test/ui/mismatched_types/unboxed-closures-vtable-mismatch.stderr", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Funboxed-closures-vtable-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Fmismatched_types%2Funboxed-closures-vtable-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Funboxed-closures-vtable-mismatch.stderr?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -12,19 +12,5 @@ error[E0281]: type mismatch: `[closure@$DIR/unboxed-closures-vtable-mismatch.rs:\n    |\n    = note: required by `call_it`\n \n-error[E0281]: type mismatch: `[closure@$DIR/unboxed-closures-vtable-mismatch.rs:22:23: 22:73]` implements the trait `std::ops::FnOnce<(usize, isize)>`, but the trait `std::ops::FnOnce<(isize, isize)>` is required\n-  --> $DIR/unboxed-closures-vtable-mismatch.rs:25:13\n-   |\n-22 |     let f = to_fn_mut(|x: usize, y: isize| -> isize { (x as isize) + y });\n-   |                       -------------------------------------------------- implements `std::ops::FnOnce<(usize, isize)>`\n-...\n-25 |     let z = call_it(3, f);\n-   |             ^^^^^^^\n-   |             |\n-   |             requires `std::ops::FnOnce<(isize, isize)>`\n-   |             expected isize, found usize\n-   |\n-   = note: required by `call_it`\n-\n error: aborting due to previous error(s)\n "}, {"sha": "cd474b14193f1096e9258f2e5f0a3d7be447fbae", "filename": "src/test/ui/type-check/issue-40294.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-40294.stderr?ref=7b9519a5d47879c37f0ac6871cee2e1cb8eca1cc", "patch": "@@ -1,4 +1,4 @@\n-error[E0282]: type annotations needed\n+error[E0283]: type annotations required: cannot resolve `&'a T: Foo`\n   --> $DIR/issue-40294.rs:15:1\n    |\n 15 | / fn foo<'a,'b,T>(x: &'a T, y: &'b T)\n@@ -8,7 +8,9 @@ error[E0282]: type annotations needed\n 19 | |     x.foo();\n 20 | |     y.foo();\n 21 | | }\n-   | |_^ cannot infer type for `&'a T`\n+   | |_^\n+   |\n+   = note: required by `Foo`\n \n error: aborting due to previous error(s)\n "}]}