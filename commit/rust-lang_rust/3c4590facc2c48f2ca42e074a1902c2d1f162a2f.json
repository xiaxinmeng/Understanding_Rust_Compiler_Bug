{"sha": "3c4590facc2c48f2ca42e074a1902c2d1f162a2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNDU5MGZhY2MyYzQ4ZjJjYTQyZTA3NGExOTAyYzJkMWYxNjJhMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-17T03:24:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-17T03:24:53Z"}, "message": "Auto merge of #68781 - ssomers:btree_miri_relief, r=RalfJung\n\nBTree: lighten the load on Miri\n\nReduce the amount of work Miri ploughs through in btree code, in particular on `test_clone_from` (which takes up 5 minutes on my machine).\n\nr? @crgl", "tree": {"sha": "c24c02cb05d5674d7eefb36fddfec543e987d4a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c24c02cb05d5674d7eefb36fddfec543e987d4a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c4590facc2c48f2ca42e074a1902c2d1f162a2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4590facc2c48f2ca42e074a1902c2d1f162a2f", "html_url": "https://github.com/rust-lang/rust/commit/3c4590facc2c48f2ca42e074a1902c2d1f162a2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c4590facc2c48f2ca42e074a1902c2d1f162a2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "html_url": "https://github.com/rust-lang/rust/commit/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5"}, {"sha": "da226dd9dcff81aba6a6bd032057816e88555abf", "url": "https://api.github.com/repos/rust-lang/rust/commits/da226dd9dcff81aba6a6bd032057816e88555abf", "html_url": "https://github.com/rust-lang/rust/commit/da226dd9dcff81aba6a6bd032057816e88555abf"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "74069bbf8a3e5a271cbc15949ec46705d13e9365", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3c4590facc2c48f2ca42e074a1902c2d1f162a2f/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4590facc2c48f2ca42e074a1902c2d1f162a2f/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=3c4590facc2c48f2ca42e074a1902c2d1f162a2f", "patch": "@@ -227,7 +227,7 @@ impl<K: Clone, V: Clone> BTreeClone for BTreeMap<K, V> {\n impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n     fn clone_from(&mut self, other: &Self) {\n         // This truncates `self` to `other.len()` by calling `split_off` on\n-        // the first key after `other.len()` elements if it exists\n+        // the first key after `other.len()` elements if it exists.\n         let split_off_key = if self.len() > other.len() {\n             let diff = self.len() - other.len();\n             if diff <= other.len() {\n@@ -247,19 +247,18 @@ impl<K: Clone + Ord, V: Clone> BTreeClone for BTreeMap<K, V> {\n         // After truncation, `self` is at most as long as `other` so this loop\n         // replaces every key-value pair in `self`. Since `oiter` is in sorted\n         // order and the structure of the `BTreeMap` stays the same,\n-        // the BTree invariants are maintained at the end of the loop\n+        // the BTree invariants are maintained at the end of the loop.\n         while !siter.is_empty() {\n             if let Some((ok, ov)) = oiter.next() {\n-                // SAFETY: This is safe because the `siter.front != siter.back` check\n-                // ensures that `siter` is nonempty\n+                // SAFETY: This is safe because `siter` is nonempty.\n                 let (sk, sv) = unsafe { siter.next_unchecked() };\n                 sk.clone_from(ok);\n                 sv.clone_from(ov);\n             } else {\n                 break;\n             }\n         }\n-        // If `other` is longer than `self`, the remaining elements are inserted\n+        // If `other` is longer than `self`, the remaining elements are inserted.\n         self.extend(oiter.map(|(k, v)| ((*k).clone(), (*v).clone())));\n     }\n }"}, {"sha": "4a9af64f9d4d1be3b7d7b4bc20df6adc56f185f8", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3c4590facc2c48f2ca42e074a1902c2d1f162a2f/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4590facc2c48f2ca42e074a1902c2d1f162a2f/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=3c4590facc2c48f2ca42e074a1902c2d1f162a2f", "patch": "@@ -15,7 +15,7 @@ fn test_basic_large() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 10000;\n     #[cfg(miri)]\n-    let size = 200;\n+    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -381,8 +381,8 @@ fn test_range_small() {\n }\n \n #[test]\n-fn test_range_depth_2() {\n-    // Assuming that node.CAPACITY is 11, having 12 pairs implies a depth 2 tree\n+fn test_range_height_2() {\n+    // Assuming that node.CAPACITY is 11, having 12 pairs implies a height 2 tree\n     // with 2 leaves. Depending on details we don't want or need to rely upon,\n     // the single key at the root will be 6 or 7.\n \n@@ -524,7 +524,7 @@ fn test_range_1000() {\n     #[cfg(not(miri))] // Miri is too slow\n     let size = 1000;\n     #[cfg(miri)]\n-    let size = 200;\n+    let size = 144; // to obtain height 3 tree (having edges to both kinds of nodes)\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test(map: &BTreeMap<u32, u32>, size: u32, min: Bound<&u32>, max: Bound<&u32>) {\n@@ -561,14 +561,15 @@ fn test_range_borrowed_key() {\n \n #[test]\n fn test_range() {\n-    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(not(miri))] // Miri is too slow\n+    let step = 1;\n     #[cfg(miri)]\n-    let size = 30;\n+    let step = 66;\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-    for i in 0..size {\n-        for j in i..size {\n+    for i in (0..size).step_by(step) {\n+        for j in (i..size).step_by(step) {\n             let mut kvs = map.range((Included(&i), Included(&j))).map(|(&k, &v)| (k, v));\n             let mut pairs = (i..=j).map(|i| (i, i));\n \n@@ -583,14 +584,15 @@ fn test_range() {\n \n #[test]\n fn test_range_mut() {\n-    #[cfg(not(miri))] // Miri is too slow\n     let size = 200;\n+    #[cfg(not(miri))] // Miri is too slow\n+    let step = 1;\n     #[cfg(miri)]\n-    let size = 30;\n+    let step = 66;\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n-    for i in 0..size {\n-        for j in i..size {\n+    for i in (0..size).step_by(step) {\n+        for j in (i..size).step_by(step) {\n             let mut kvs = map.range_mut((Included(&i), Included(&j))).map(|(&k, &mut v)| (k, v));\n             let mut pairs = (i..=j).map(|i| (i, i));\n \n@@ -758,10 +760,7 @@ fn test_bad_zst() {\n #[test]\n fn test_clone() {\n     let mut map = BTreeMap::new();\n-    #[cfg(not(miri))] // Miri is too slow\n-    let size = 100;\n-    #[cfg(miri)]\n-    let size = 30;\n+    let size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -788,24 +787,36 @@ fn test_clone() {\n         assert_eq!(map.len(), size / 2 - i - 1);\n         assert_eq!(map, map.clone());\n     }\n+\n+    // Full 2-level and minimal 3-level tree (sizes 143, 144 -- the only ones we clone for).\n+    for i in 1..=144 {\n+        assert_eq!(map.insert(i, i), None);\n+        assert_eq!(map.len(), i);\n+        if i >= 143 {\n+            assert_eq!(map, map.clone());\n+        }\n+    }\n }\n \n #[test]\n fn test_clone_from() {\n     let mut map1 = BTreeMap::new();\n-    let size = 30;\n+    let max_size = 12; // to obtain height 2 tree (having edges to leaf nodes)\n \n-    for i in 0..size {\n+    // Range to max_size inclusive, because i is the size of map1 being tested.\n+    for i in 0..=max_size {\n         let mut map2 = BTreeMap::new();\n         for j in 0..i {\n             let mut map1_copy = map2.clone();\n-            map1_copy.clone_from(&map1);\n+            map1_copy.clone_from(&map1); // small cloned from large\n             assert_eq!(map1_copy, map1);\n             let mut map2_copy = map1.clone();\n-            map2_copy.clone_from(&map2);\n+            map2_copy.clone_from(&map2); // large cloned from small\n             assert_eq!(map2_copy, map2);\n             map2.insert(100 * j + 1, 2 * j + 1);\n         }\n+        map2.clone_from(&map1); // same length\n+        assert_eq!(map2, map1);\n         map1.insert(i, 10 * i);\n     }\n }\n@@ -956,6 +967,7 @@ create_append_test!(test_append_145, 145);\n // Tests for several randomly chosen sizes.\n create_append_test!(test_append_170, 170);\n create_append_test!(test_append_181, 181);\n+#[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_239, 239);\n #[cfg(not(miri))] // Miri is too slow\n create_append_test!(test_append_1700, 1700);"}]}