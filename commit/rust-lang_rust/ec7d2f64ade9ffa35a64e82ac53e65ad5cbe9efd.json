{"sha": "ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjN2QyZjY0YWRlOWZmYTM1YTY0ZTgyYWM1M2U2NWFkNWNiZTllZmQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-15T12:45:58Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-15T12:45:58Z"}, "message": "Merge #1278\n\n1278: Apply T! macro where posible r=matklad a=pasa\n\napply T! macro implemented in #1248\n\nCo-authored-by: Sergey Parilin <sergey.parilin@fxdd.com>", "tree": {"sha": "b8693ce808a9ca2e7eaae5013644a1082fc7bb17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8693ce808a9ca2e7eaae5013644a1082fc7bb17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "html_url": "https://github.com/rust-lang/rust/commit/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "64ab5ab10d32e7e8ec085af818d3d94211aea39b", "url": "https://api.github.com/repos/rust-lang/rust/commits/64ab5ab10d32e7e8ec085af818d3d94211aea39b", "html_url": "https://github.com/rust-lang/rust/commit/64ab5ab10d32e7e8ec085af818d3d94211aea39b"}, {"sha": "993abedd77cf23ce2281b6c8e60cab49ab4fa97e", "url": "https://api.github.com/repos/rust-lang/rust/commits/993abedd77cf23ce2281b6c8e60cab49ab4fa97e", "html_url": "https://github.com/rust-lang/rust/commit/993abedd77cf23ce2281b6c8e60cab49ab4fa97e"}], "stats": {"total": 1248, "additions": 622, "deletions": 626}, "files": [{"sha": "f3ed74b7fb2332b3a44b80dc9cb4a9872eebc801", "filename": "crates/ra_assists/src/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fadd_explicit_type.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -3,7 +3,7 @@ use hir::{\n     db::HirDatabase,\n };\n use ra_syntax::{\n-    SyntaxKind,\n+    T,\n     ast::{LetStmt, PatKind, NameOwner, AstNode}\n };\n \n@@ -24,7 +24,7 @@ pub(crate) fn add_explicit_type(mut ctx: AssistCtx<impl HirDatabase>) -> Option<\n     let name = pat.name()?;\n     let name_range = name.syntax().range();\n     // Assist not applicable if the type has already been specified\n-    if stmt.syntax().children_with_tokens().any(|child| child.kind() == SyntaxKind::COLON) {\n+    if stmt.syntax().children_with_tokens().any(|child| child.kind() == T![:]) {\n         return None;\n     }\n     // Infer type"}, {"sha": "9afcac01aa8b1a434e8b0c425b79b74f0d43a5a8", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -2,7 +2,7 @@ use std::{iter, ops::RangeInclusive};\n \n use arrayvec::ArrayVec;\n use ra_text_edit::TextEditBuilder;\n-use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction};\n+use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction, T};\n use ra_fmt::leading_indent;\n use hir::Name;\n \n@@ -49,7 +49,7 @@ impl<N: AstNode> AstEditor<N> {\n \n     fn do_make_multiline(&mut self) {\n         let l_curly =\n-            match self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY) {\n+            match self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{']) {\n                 Some(it) => it,\n                 None => return,\n             };\n@@ -124,7 +124,7 @@ impl AstEditor<ast::NamedFieldList> {\n                 if let Some(comma) = $anchor\n                     .syntax()\n                     .siblings_with_tokens(Direction::Next)\n-                    .find(|it| it.kind() == COMMA)\n+                    .find(|it| it.kind() == T![,])\n                 {\n                     InsertPosition::After(comma)\n                 } else {\n@@ -154,7 +154,7 @@ impl AstEditor<ast::NamedFieldList> {\n     }\n \n     fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY)\n+        self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n     }\n }\n \n@@ -188,7 +188,7 @@ impl AstEditor<ast::ItemList> {\n     }\n \n     fn l_curly(&self) -> Option<SyntaxElement> {\n-        self.ast().syntax().children_with_tokens().find(|it| it.kind() == L_CURLY)\n+        self.ast().syntax().children_with_tokens().find(|it| it.kind() == T!['{'])\n     }\n }\n \n@@ -290,7 +290,7 @@ fn ast_node_from_file_text<N: AstNode>(text: &str) -> TreeArc<N> {\n \n mod tokens {\n     use once_cell::sync::Lazy;\n-    use ra_syntax::{AstNode, SourceFile, TreeArc, SyntaxToken, SyntaxKind::*};\n+    use ra_syntax::{AstNode, SourceFile, TreeArc, SyntaxToken, SyntaxKind::*, T};\n \n     static SOURCE_FILE: Lazy<TreeArc<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n \n@@ -299,7 +299,7 @@ mod tokens {\n             .syntax()\n             .descendants_with_tokens()\n             .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == COMMA)\n+            .find(|it| it.kind() == T![,])\n             .unwrap()\n     }\n "}, {"sha": "1566cf17911d88f774e03082c9dca09da00aefd4", "filename": "crates/ra_assists/src/auto_import.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -2,8 +2,9 @@ use ra_text_edit::TextEditBuilder;\n use hir::{ self, db::HirDatabase};\n \n use ra_syntax::{\n+    T,\n     ast::{ self, NameOwner }, AstNode, SyntaxNode, Direction, TextRange, SmolStr,\n-    SyntaxKind::{ PATH, PATH_SEGMENT, COLONCOLON, COMMA }\n+    SyntaxKind::{ PATH, PATH_SEGMENT }\n };\n use crate::{\n     AssistId,\n@@ -23,7 +24,7 @@ fn collect_path_segments_raw<'a>(\n             children.next().map(|n| (n, n.kind())),\n         );\n         match (first, second, third) {\n-            (Some((subpath, PATH)), Some((_, COLONCOLON)), Some((segment, PATH_SEGMENT))) => {\n+            (Some((subpath, PATH)), Some((_, T![::])), Some((segment, PATH_SEGMENT))) => {\n                 path = ast::Path::cast(subpath.as_node()?)?;\n                 segments.push(ast::PathSegment::cast(segment.as_node()?)?);\n             }\n@@ -421,7 +422,7 @@ fn make_assist_add_in_tree_list(\n     let last = tree_list.use_trees().last();\n     if let Some(last) = last {\n         let mut buf = String::new();\n-        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == COMMA);\n+        let comma = last.syntax().siblings(Direction::Next).find(|n| n.kind() == T![,]);\n         let offset = if let Some(comma) = comma {\n             comma.range().end()\n         } else {"}, {"sha": "620f534b5d8413f8c6917c0cc47797cebb8088f8", "filename": "crates/ra_assists/src/change_visibility.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fchange_visibility.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,8 +1,9 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n+    T,\n     AstNode, SyntaxNode, TextUnit,\n     ast::{self, VisibilityOwner, NameOwner},\n-    SyntaxKind::{VISIBILITY, FN_KW, MOD_KW, STRUCT_KW, ENUM_KW, TRAIT_KW, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF, IDENT, WHITESPACE, COMMENT, ATTR},\n+    SyntaxKind::{VISIBILITY, FN_DEF, MODULE, STRUCT_DEF, ENUM_DEF, TRAIT_DEF, IDENT, WHITESPACE, COMMENT, ATTR},\n };\n \n use crate::{AssistCtx, Assist, AssistId};\n@@ -16,7 +17,7 @@ pub(crate) fn change_visibility(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n \n fn add_vis(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let item_keyword = ctx.token_at_offset().find(|leaf| match leaf.kind() {\n-        FN_KW | MOD_KW | STRUCT_KW | ENUM_KW | TRAIT_KW => true,\n+        T![fn] | T![mod] | T![struct] | T![enum] | T![trait] => true,\n         _ => false,\n     });\n "}, {"sha": "7626ffad32335ea2926b83c08d2ef5f74371bed8", "filename": "crates/ra_assists/src/flip_comma.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fflip_comma.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,14 +1,14 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n+    T,\n     Direction,\n-    SyntaxKind::COMMA,\n     algo::non_trivia_sibling,\n };\n \n use crate::{AssistCtx, Assist, AssistId};\n \n pub(crate) fn flip_comma(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let comma = ctx.token_at_offset().find(|leaf| leaf.kind() == COMMA)?;\n+    let comma = ctx.token_at_offset().find(|leaf| leaf.kind() == T![,])?;\n     let prev = non_trivia_sibling(comma.into(), Direction::Prev)?;\n     let next = non_trivia_sibling(comma.into(), Direction::Next)?;\n     ctx.add_action(AssistId(\"flip_comma\"), \"flip comma\", |edit| {"}, {"sha": "6e900f8ef03eea539a5e94192ed4d58aee2a3d50", "filename": "crates/ra_assists/src/remove_dbg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fremove_dbg.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -2,9 +2,7 @@ use hir::db::HirDatabase;\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextUnit,\n-    SyntaxKind::{\n-        L_PAREN, R_PAREN, L_CURLY, R_CURLY, L_BRACK, R_BRACK, EXCL\n-    },\n+    T\n };\n use crate::{AssistCtx, Assist, AssistId};\n \n@@ -64,7 +62,7 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n     // Make sure it is actually a dbg-macro call, dbg followed by !\n     let excl = path.syntax().next_sibling_or_token()?;\n \n-    if name_ref.text() != macro_name || excl.kind() != EXCL {\n+    if name_ref.text() != macro_name || excl.kind() != T![!] {\n         return None;\n     }\n \n@@ -73,7 +71,7 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n     let last_child = node.last_child_or_token()?;\n \n     match (first_child.kind(), last_child.kind()) {\n-        (L_PAREN, R_PAREN) | (L_BRACK, R_BRACK) | (L_CURLY, R_CURLY) => Some(true),\n+        (T!['('], T![')']) | (T!['['], T![']']) | (T!['{'], T!['}']) => Some(true),\n         _ => Some(false),\n     }\n }"}, {"sha": "881c5ecdc109953603617a434cc4ca5841b19699", "filename": "crates/ra_assists/src/split_import.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fsplit_import.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -2,14 +2,15 @@ use std::iter::successors;\n \n use hir::db::HirDatabase;\n use ra_syntax::{\n-    TextUnit, AstNode, SyntaxKind::COLONCOLON,\n+    T,\n+    TextUnit, AstNode,\n     ast,\n };\n \n use crate::{AssistCtx, Assist, AssistId};\n \n pub(crate) fn split_import(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let colon_colon = ctx.token_at_offset().find(|leaf| leaf.kind() == COLONCOLON)?;\n+    let colon_colon = ctx.token_at_offset().find(|leaf| leaf.kind() == T![::])?;\n     let path = ast::Path::cast(colon_colon.parent())?;\n     let top_path = successors(Some(path), |it| it.parent_path()).last()?;\n "}, {"sha": "aac5a1d235c909ce7c463a739dfd77dd09cc6320", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -3,7 +3,7 @@\n use std::iter::successors;\n use itertools::Itertools;\n use ra_syntax::{\n-    SyntaxNode, SyntaxKind::*, SyntaxToken, SyntaxKind,\n+    SyntaxNode, SyntaxKind::*, SyntaxToken, SyntaxKind, T,\n     ast::{self, AstNode, AstToken},\n };\n \n@@ -38,7 +38,7 @@ pub fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n         return None;\n     }\n     let non_trivial_children = block.syntax().children().filter(|it| match it.kind() {\n-        WHITESPACE | L_CURLY | R_CURLY => false,\n+        WHITESPACE | T!['{'] | T!['}'] => false,\n         _ => it != &expr.syntax(),\n     });\n     if non_trivial_children.count() > 0 {\n@@ -49,22 +49,22 @@ pub fn extract_trivial_expression(block: &ast::Block) -> Option<&ast::Expr> {\n \n pub fn compute_ws(left: SyntaxKind, right: SyntaxKind) -> &'static str {\n     match left {\n-        L_PAREN | L_BRACK => return \"\",\n-        L_CURLY => {\n+        T!['('] | T!['['] => return \"\",\n+        T!['{'] => {\n             if let USE_TREE = right {\n                 return \"\";\n             }\n         }\n         _ => (),\n     }\n     match right {\n-        R_PAREN | R_BRACK => return \"\",\n-        R_CURLY => {\n+        T![')'] | T![']'] => return \"\",\n+        T!['}'] => {\n             if let USE_TREE = left {\n                 return \"\";\n             }\n         }\n-        DOT => return \"\",\n+        T![.] => return \"\",\n         _ => (),\n     }\n     \" \""}, {"sha": "9a0eb2c1418ba58af5c711a7b4b66b647c012e4e", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -4,7 +4,7 @@ use itertools::Itertools;\n use hir::{source_binder, diagnostics::{Diagnostic as _, DiagnosticSink}};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n-    Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n+    T, Location, SourceFile, TextRange, SyntaxNode,\n     ast::{self, AstNode, NamedFieldList, NamedField},\n };\n use ra_assists::ast_editor::{AstEditor, AstBuilder};\n@@ -130,9 +130,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     single_use_tree: &ast::UseTree,\n ) -> Option<TextEdit> {\n     let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree.path()?.segment()?.syntax().first_child_or_token()?.kind()\n-        == SyntaxKind::SELF_KW\n-    {\n+    if single_use_tree.path()?.segment()?.syntax().first_child_or_token()?.kind() == T![self] {\n         let start = use_tree_list_node.prev_sibling_or_token()?.range().start();\n         let end = use_tree_list_node.range().end();\n         let range = TextRange::from_to(start, end);"}, {"sha": "4553faad0e769a64165d69daf599c6e212451f55", "filename": "crates/ra_ide_api/src/extend_selection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fextend_selection.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -157,7 +157,7 @@ fn extend_list_item(node: &SyntaxNode) -> Option<TextRange> {\n             })\n             .next()\n             .and_then(|it| it.as_token())\n-            .filter(|node| node.kind() == COMMA)\n+            .filter(|node| node.kind() == T![,])\n     }\n \n     if let Some(comma_node) = nearby_comma(node, Direction::Prev) {"}, {"sha": "4ca005466152019241b1c1a11d3d3e481550a385", "filename": "crates/ra_ide_api/src/join_lines.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fjoin_lines.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,7 +1,8 @@\n use itertools::Itertools;\n use ra_syntax::{\n+    T,\n     SourceFile, TextRange, TextUnit, SyntaxNode, SyntaxElement, SyntaxToken,\n-    SyntaxKind::{self, WHITESPACE, COMMA, R_CURLY, R_PAREN, R_BRACK},\n+    SyntaxKind::{self, WHITESPACE},\n     algo::{find_covering_element, non_trivia_sibling},\n     ast::{self, AstNode, AstToken},\n     Direction,\n@@ -89,7 +90,7 @@ fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUn\n     if is_trailing_comma(prev.kind(), next.kind()) {\n         // Removes: trailing comma, newline (incl. surrounding whitespace)\n         edit.delete(TextRange::from_to(prev.range().start(), token.range().end()));\n-    } else if prev.kind() == COMMA && next.kind() == R_CURLY {\n+    } else if prev.kind() == T![,] && next.kind() == T!['}'] {\n         // Removes: comma, newline (incl. surrounding whitespace)\n         let space = if let Some(left) = prev.prev_sibling_or_token() {\n             compute_ws(left.kind(), next.kind())\n@@ -116,7 +117,7 @@ fn remove_newline(edit: &mut TextEditBuilder, token: SyntaxToken, offset: TextUn\n \n fn has_comma_after(node: &SyntaxNode) -> bool {\n     match non_trivia_sibling(node.into(), Direction::Next) {\n-        Some(n) => n.kind() == COMMA,\n+        Some(n) => n.kind() == T![,],\n         _ => false,\n     }\n }\n@@ -150,7 +151,7 @@ fn join_single_use_tree(edit: &mut TextEditBuilder, token: SyntaxToken) -> Optio\n \n fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     match (left, right) {\n-        (COMMA, R_PAREN) | (COMMA, R_BRACK) => true,\n+        (T![,], T![')']) | (T![,], T![']']) => true,\n         _ => false,\n     }\n }"}, {"sha": "eaa4b620cee049eee162c7cf3660c347cbc4cefc", "filename": "crates/ra_ide_api/src/matching_brace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmatching_brace.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,13 +1,14 @@\n use ra_syntax::{\n     SourceFile, TextUnit,\n     algo::find_token_at_offset,\n-    SyntaxKind::{self, *},\n+    SyntaxKind::{self},\n     ast::AstNode,\n+    T\n };\n \n pub fn matching_brace(file: &SourceFile, offset: TextUnit) -> Option<TextUnit> {\n     const BRACES: &[SyntaxKind] =\n-        &[L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE];\n+        &[T!['{'], T!['}'], T!['['], T![']'], T!['('], T![')'], T![<], T![>]];\n     let (brace_node, brace_idx) = find_token_at_offset(file.syntax(), offset)\n         .filter_map(|node| {\n             let idx = BRACES.iter().position(|&brace| brace == node.kind())?;"}, {"sha": "a03b13839be7c31eeb8a1217fe183cb861373df2", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,6 +1,6 @@\n use rustc_hash::FxHashSet;\n \n-use ra_syntax::{ast, AstNode, TextRange, Direction, SyntaxKind::*, SyntaxElement};\n+use ra_syntax::{ast, AstNode, TextRange, Direction, SyntaxKind::*, SyntaxElement, T};\n use ra_db::SourceDatabase;\n \n use crate::{FileId, db::RootDatabase};\n@@ -40,7 +40,7 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                                 let mut range_end = name_ref.syntax().range().end();\n                                 for sibling in path.syntax().siblings_with_tokens(Direction::Next) {\n                                     match sibling.kind() {\n-                                        EXCL | IDENT => range_end = sibling.range().end(),\n+                                        T![!] | IDENT => range_end = sibling.range().end(),\n                                         _ => (),\n                                     }\n                                 }"}, {"sha": "c938acf6438829915721f90d76538cb7ae8cbb8d", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,5 +1,5 @@\n use ra_parser::{TokenSource};\n-use ra_syntax::{classify_literal, SmolStr, SyntaxKind, SyntaxKind::*};\n+use ra_syntax::{classify_literal, SmolStr, SyntaxKind, SyntaxKind::*, T};\n use std::cell::{RefCell};\n \n // A Sequece of Token,\n@@ -284,9 +284,9 @@ impl<'a> TokenSource for SubtreeTokenSource<'a> {\n \n fn convert_delim(d: tt::Delimiter, closing: bool) -> TtToken {\n     let (kinds, texts) = match d {\n-        tt::Delimiter::Parenthesis => ([L_PAREN, R_PAREN], \"()\"),\n-        tt::Delimiter::Brace => ([L_CURLY, R_CURLY], \"{}\"),\n-        tt::Delimiter::Bracket => ([L_BRACK, R_BRACK], \"[]\"),\n+        tt::Delimiter::Parenthesis => ([T!['('], T![')']], \"()\"),\n+        tt::Delimiter::Brace => ([T!['{'], T!['}']], \"{}\"),\n+        tt::Delimiter::Bracket => ([T!['['], T![']']], \"[]\"),\n         tt::Delimiter::None => ([L_DOLLAR, R_DOLLAR], \"\"),\n     };\n \n@@ -299,8 +299,8 @@ fn convert_delim(d: tt::Delimiter, closing: bool) -> TtToken {\n fn convert_literal(l: &tt::Literal) -> TtToken {\n     let kind =\n         classify_literal(&l.text).map(|tkn| tkn.kind).unwrap_or_else(|| match l.text.as_ref() {\n-            \"true\" => SyntaxKind::TRUE_KW,\n-            \"false\" => SyntaxKind::FALSE_KW,\n+            \"true\" => T![true],\n+            \"false\" => T![false],\n             _ => panic!(\"Fail to convert given literal {:#?}\", &l),\n         });\n \n@@ -320,11 +320,11 @@ fn convert_ident(ident: &tt::Ident) -> TtToken {\n fn convert_punct(p: &tt::Punct) -> TtToken {\n     let kind = match p.char {\n         // lexer may produce compound tokens for these ones\n-        '.' => DOT,\n-        ':' => COLON,\n-        '=' => EQ,\n-        '!' => EXCL,\n-        '-' => MINUS,\n+        '.' => T![.],\n+        ':' => T![:],\n+        '=' => T![=],\n+        '!' => T![!],\n+        '-' => T![-],\n         c => SyntaxKind::from_char(c).unwrap(),\n     };\n     let text = {"}, {"sha": "d8e344557ae6edd7faaadbe6239b9bd9da9a0a62", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,7 +1,7 @@\n use ra_parser::{TreeSink, ParseError};\n use ra_syntax::{\n     AstNode, SyntaxNode, TextRange, SyntaxKind, SmolStr, SyntaxTreeBuilder, TreeArc, SyntaxElement,\n-    ast, SyntaxKind::*, TextUnit\n+    ast, SyntaxKind::*, TextUnit, T\n };\n \n use crate::subtree_source::{SubtreeTokenSource, Querier};\n@@ -211,9 +211,9 @@ fn convert_tt(\n     let first_child = tt.first_child_or_token()?;\n     let last_child = tt.last_child_or_token()?;\n     let (delimiter, skip_first) = match (first_child.kind(), last_child.kind()) {\n-        (L_PAREN, R_PAREN) => (tt::Delimiter::Parenthesis, true),\n-        (L_CURLY, R_CURLY) => (tt::Delimiter::Brace, true),\n-        (L_BRACK, R_BRACK) => (tt::Delimiter::Bracket, true),\n+        (T!['('], T![')']) => (tt::Delimiter::Parenthesis, true),\n+        (T!['{'], T!['}']) => (tt::Delimiter::Brace, true),\n+        (T!['['], T![']']) => (tt::Delimiter::Bracket, true),\n         _ => (tt::Delimiter::None, false),\n     };\n \n@@ -248,23 +248,22 @@ fn convert_tt(\n \n                     token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n                 } else {\n-                    let child: tt::TokenTree = if token.kind() == SyntaxKind::TRUE_KW\n-                        || token.kind() == SyntaxKind::FALSE_KW\n-                    {\n-                        tt::Leaf::from(tt::Literal { text: token.text().clone() }).into()\n-                    } else if token.kind().is_keyword()\n-                        || token.kind() == IDENT\n-                        || token.kind() == LIFETIME\n-                    {\n-                        let relative_range = token.range() - global_offset;\n-                        let id = token_map.alloc(relative_range);\n-                        let text = token.text().clone();\n-                        tt::Leaf::from(tt::Ident { text, id }).into()\n-                    } else if token.kind().is_literal() {\n-                        tt::Leaf::from(tt::Literal { text: token.text().clone() }).into()\n-                    } else {\n-                        return None;\n-                    };\n+                    let child: tt::TokenTree =\n+                        if token.kind() == T![true] || token.kind() == T![false] {\n+                            tt::Leaf::from(tt::Literal { text: token.text().clone() }).into()\n+                        } else if token.kind().is_keyword()\n+                            || token.kind() == IDENT\n+                            || token.kind() == LIFETIME\n+                        {\n+                            let relative_range = token.range() - global_offset;\n+                            let id = token_map.alloc(relative_range);\n+                            let text = token.text().clone();\n+                            tt::Leaf::from(tt::Ident { text, id }).into()\n+                        } else if token.kind().is_literal() {\n+                            tt::Leaf::from(tt::Literal { text: token.text().clone() }).into()\n+                        } else {\n+                            return None;\n+                        };\n                     token_trees.push(child);\n                 }\n             }\n@@ -305,10 +304,8 @@ impl<'a, Q: Querier> TtTreeSink<'a, Q> {\n }\n \n fn is_delimiter(kind: SyntaxKind) -> bool {\n-    use SyntaxKind::*;\n-\n     match kind {\n-        L_PAREN | L_BRACK | L_CURLY | R_PAREN | R_BRACK | R_CURLY => true,\n+        T!['('] | T!['['] | T!['{'] | T![')'] | T![']'] | T!['}'] => true,\n         _ => false,\n     }\n }"}, {"sha": "51beb086688026d3d21a64d011fc8af2a01845b2", "filename": "crates/ra_parser/src/event.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fevent.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -38,7 +38,7 @@ pub(crate) enum Event {\n     /// The events for it would look like this:\n     ///\n     ///\n-    /// START(PATH) IDENT('foo') FINISH START(PATH) COLONCOLON IDENT('bar') FINISH\n+    /// START(PATH) IDENT('foo') FINISH START(PATH) T![::] IDENT('bar') FINISH\n     ///       |                          /\\\n     ///       |                          |\n     ///       +------forward-parent------+"}, {"sha": "cf603eba1dc38991ffd1484b55fc2911a3d44546", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -59,7 +59,7 @@ pub(crate) fn macro_stmts(p: &mut Parser) {\n     let m = p.start();\n \n     while !p.at(EOF) {\n-        if p.current() == SEMI {\n+        if p.current() == T![;] {\n             p.bump();\n             continue;\n         }\n@@ -103,7 +103,7 @@ pub(crate) fn block(p: &mut Parser) {\n pub(crate) fn meta_item(p: &mut Parser) {\n     fn is_delimiter(p: &mut Parser) -> bool {\n         match p.current() {\n-            L_CURLY | L_PAREN | L_BRACK => true,\n+            T!['{'] | T!['('] | T!['['] => true,\n             _ => false,\n         }\n     }\n@@ -123,12 +123,12 @@ pub(crate) fn meta_item(p: &mut Parser) {\n             // https://doc.rust-lang.org/reference/paths.html#simple-paths\n             // The start of an meta must be a simple path\n             match p.current() {\n-                IDENT | COLONCOLON | SUPER_KW | SELF_KW | CRATE_KW => p.bump(),\n-                EQ => {\n+                IDENT | T![::] | T![super] | T![self] | T![crate] => p.bump(),\n+                T![=] => {\n                     p.bump();\n                     match p.current() {\n                         c if c.is_literal() => p.bump(),\n-                        TRUE_KW | FALSE_KW => p.bump(),\n+                        T![true] | T![false] => p.bump(),\n                         _ => {}\n                     }\n                     break;\n@@ -158,7 +158,7 @@ pub(crate) fn reparser(\n         MATCH_ARM_LIST => items::match_arm_list,\n         USE_TREE_LIST => items::use_tree_list,\n         EXTERN_ITEM_LIST => items::extern_item_list,\n-        TOKEN_TREE if first_child? == L_CURLY => items::token_tree,\n+        TOKEN_TREE if first_child? == T!['{'] => items::token_tree,\n         ITEM_LIST => match parent? {\n             IMPL_BLOCK => items::impl_item_list,\n             TRAIT_DEF => items::trait_item_list,\n@@ -184,26 +184,26 @@ impl BlockLike {\n \n pub(crate) fn opt_visibility(p: &mut Parser) -> bool {\n     match p.current() {\n-        PUB_KW => {\n+        T![pub] => {\n             let m = p.start();\n             p.bump();\n-            if p.at(L_PAREN) {\n+            if p.at(T!['(']) {\n                 match p.nth(1) {\n                     // test crate_visibility\n                     // pub(crate) struct S;\n                     // pub(self) struct S;\n                     // pub(self) struct S;\n                     // pub(self) struct S;\n-                    CRATE_KW | SELF_KW | SUPER_KW => {\n+                    T![crate] | T![self] | T![super] => {\n                         p.bump();\n                         p.bump();\n-                        p.expect(R_PAREN);\n+                        p.expect(T![')']);\n                     }\n-                    IN_KW => {\n+                    T![in] => {\n                         p.bump();\n                         p.bump();\n                         paths::use_path(p);\n-                        p.expect(R_PAREN);\n+                        p.expect(T![')']);\n                     }\n                     _ => (),\n                 }\n@@ -217,7 +217,7 @@ pub(crate) fn opt_visibility(p: &mut Parser) -> bool {\n         //\n         // test crate_keyword_path\n         // fn foo() { crate::foo(); }\n-        CRATE_KW if p.nth(1) != COLONCOLON => {\n+        T![crate] if p.nth(1) != T![::] => {\n             let m = p.start();\n             p.bump();\n             m.complete(p, VISIBILITY);\n@@ -228,18 +228,18 @@ pub(crate) fn opt_visibility(p: &mut Parser) -> bool {\n }\n \n fn opt_alias(p: &mut Parser) {\n-    if p.at(AS_KW) {\n+    if p.at(T![as]) {\n         let m = p.start();\n         p.bump();\n-        if !p.eat(UNDERSCORE) {\n+        if !p.eat(T![_]) {\n             name(p);\n         }\n         m.complete(p, ALIAS);\n     }\n }\n \n fn abi(p: &mut Parser) {\n-    assert!(p.at(EXTERN_KW));\n+    assert!(p.at(T![extern]));\n     let abi = p.start();\n     p.bump();\n     match p.current() {\n@@ -250,7 +250,7 @@ fn abi(p: &mut Parser) {\n }\n \n fn opt_fn_ret_type(p: &mut Parser) -> bool {\n-    if p.at(THIN_ARROW) {\n+    if p.at(T![->]) {\n         let m = p.start();\n         p.bump();\n         types::type_(p);\n@@ -280,21 +280,21 @@ fn name_ref(p: &mut Parser) {\n         let m = p.start();\n         p.bump();\n         m.complete(p, NAME_REF);\n-    } else if p.at(SELF_KW) {\n+    } else if p.at(T![self]) {\n         let m = p.start();\n         p.bump();\n-        m.complete(p, SELF_KW);\n+        m.complete(p, T![self]);\n     } else {\n         p.err_and_bump(\"expected identifier\");\n     }\n }\n \n fn error_block(p: &mut Parser, message: &str) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.error(message);\n     p.bump();\n     expressions::expr_block_contents(p);\n-    p.eat(R_CURLY);\n+    p.eat(T!['}']);\n     m.complete(p, ERROR);\n }"}, {"sha": "20d58445f1513d8cdba8d7bbe9f22220ed18d9c8", "filename": "crates/ra_parser/src/grammar/attributes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,28 +1,28 @@\n use super::*;\n \n pub(super) fn inner_attributes(p: &mut Parser) {\n-    while p.current() == POUND && p.nth(1) == EXCL {\n+    while p.current() == T![#] && p.nth(1) == T![!] {\n         attribute(p, true)\n     }\n }\n \n pub(super) fn outer_attributes(p: &mut Parser) {\n-    while p.at(POUND) {\n+    while p.at(T![#]) {\n         attribute(p, false)\n     }\n }\n \n fn attribute(p: &mut Parser, inner: bool) {\n     let attr = p.start();\n-    assert!(p.at(POUND));\n+    assert!(p.at(T![#]));\n     p.bump();\n \n     if inner {\n-        assert!(p.at(EXCL));\n+        assert!(p.at(T![!]));\n         p.bump();\n     }\n \n-    if p.at(L_BRACK) {\n+    if p.at(T!['[']) {\n         items::token_tree(p);\n     } else {\n         p.error(\"expected `[`\");"}, {"sha": "bb6c78b5fba639a52b73fc53bbe5429b531485bb", "filename": "crates/ra_parser/src/grammar/expressions.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -36,14 +36,14 @@ fn expr_no_struct(p: &mut Parser) {\n // fn c() { 1; 2; }\n // fn d() { 1; 2 }\n pub(crate) fn block(p: &mut Parser) {\n-    if !p.at(L_CURLY) {\n+    if !p.at(T!['{']) {\n         p.error(\"expected a block\");\n         return;\n     }\n     let m = p.start();\n     p.bump();\n     expr_block_contents(p);\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, BLOCK);\n }\n \n@@ -65,10 +65,10 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     //     #[C] #[D] {}\n     //     #[D] return ();\n     // }\n-    let has_attrs = p.at(POUND);\n+    let has_attrs = p.at(T![#]);\n     attributes::outer_attributes(p);\n \n-    if p.at(LET_KW) {\n+    if p.at(T![let]) {\n         let_stmt(p, m, with_semi);\n         return;\n     }\n@@ -90,7 +90,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n         p.error(format!(\"attributes are not allowed on {:?}\", kind));\n     }\n \n-    if p.at(R_CURLY) {\n+    if p.at(T!['}']) {\n         // test attr_on_last_expr_in_block\n         // fn foo() {\n         //     { #[A] bar!()? }\n@@ -121,15 +121,15 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n         match with_semi {\n             StmtWithSemi::Yes => {\n                 if blocklike.is_block() {\n-                    p.eat(SEMI);\n+                    p.eat(T![;]);\n                 } else {\n-                    p.expect(SEMI);\n+                    p.expect(T![;]);\n                 }\n             }\n             StmtWithSemi::No => {}\n             StmtWithSemi::Optional => {\n-                if p.at(SEMI) {\n-                    p.eat(SEMI);\n+                if p.at(T![;]) {\n+                    p.eat(T![;]);\n                 }\n             }\n         }\n@@ -145,24 +145,24 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     //     let d: i32 = 92;\n     // }\n     fn let_stmt(p: &mut Parser, m: Marker, with_semi: StmtWithSemi) {\n-        assert!(p.at(LET_KW));\n+        assert!(p.at(T![let]));\n         p.bump();\n         patterns::pattern(p);\n-        if p.at(COLON) {\n+        if p.at(T![:]) {\n             types::ascription(p);\n         }\n-        if p.eat(EQ) {\n+        if p.eat(T![=]) {\n             expressions::expr(p);\n         }\n \n         match with_semi {\n             StmtWithSemi::Yes => {\n-                p.expect(SEMI);\n+                p.expect(T![;]);\n             }\n             StmtWithSemi::No => {}\n             StmtWithSemi::Optional => {\n-                if p.at(SEMI) {\n-                    p.eat(SEMI);\n+                if p.at(T![;]) {\n+                    p.eat(T![;]);\n                 }\n             }\n         }\n@@ -174,12 +174,12 @@ pub(crate) fn expr_block_contents(p: &mut Parser) {\n     // This is checked by a validator\n     attributes::inner_attributes(p);\n \n-    while !p.at(EOF) && !p.at(R_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n         // test nocontentexpr\n         // fn foo(){\n         //     ;;;some_expr();;;;{;;;};;;;Ok(())\n         // }\n-        if p.current() == SEMI {\n+        if p.current() == T![;] {\n             p.bump();\n             continue;\n         }\n@@ -202,41 +202,41 @@ enum Op {\n fn current_op(p: &Parser) -> (u8, Op) {\n     if let Some(t) = p.current3() {\n         match t {\n-            (L_ANGLE, L_ANGLE, EQ) => return (1, Op::Composite(SHLEQ, 3)),\n-            (R_ANGLE, R_ANGLE, EQ) => return (1, Op::Composite(SHREQ, 3)),\n+            (T![<], T![<], T![=]) => return (1, Op::Composite(T![<<=], 3)),\n+            (T![>], T![>], T![=]) => return (1, Op::Composite(T![>>=], 3)),\n             _ => (),\n         }\n     }\n \n     if let Some(t) = p.current2() {\n         match t {\n-            (PLUS, EQ) => return (1, Op::Composite(PLUSEQ, 2)),\n-            (MINUS, EQ) => return (1, Op::Composite(MINUSEQ, 2)),\n-            (STAR, EQ) => return (1, Op::Composite(STAREQ, 2)),\n-            (PERCENT, EQ) => return (1, Op::Composite(PERCENTEQ, 2)),\n-            (SLASH, EQ) => return (1, Op::Composite(SLASHEQ, 2)),\n-            (PIPE, EQ) => return (1, Op::Composite(PIPEEQ, 2)),\n-            (AMP, EQ) => return (1, Op::Composite(AMPEQ, 2)),\n-            (CARET, EQ) => return (1, Op::Composite(CARETEQ, 2)),\n-            (PIPE, PIPE) => return (3, Op::Composite(PIPEPIPE, 2)),\n-            (AMP, AMP) => return (4, Op::Composite(AMPAMP, 2)),\n-            (L_ANGLE, EQ) => return (5, Op::Composite(LTEQ, 2)),\n-            (R_ANGLE, EQ) => return (5, Op::Composite(GTEQ, 2)),\n-            (L_ANGLE, L_ANGLE) => return (9, Op::Composite(SHL, 2)),\n-            (R_ANGLE, R_ANGLE) => return (9, Op::Composite(SHR, 2)),\n+            (T![+], T![=]) => return (1, Op::Composite(T![+=], 2)),\n+            (T![-], T![=]) => return (1, Op::Composite(T![-=], 2)),\n+            (T![*], T![=]) => return (1, Op::Composite(T![*=], 2)),\n+            (T![%], T![=]) => return (1, Op::Composite(T![%=], 2)),\n+            (T![/], T![=]) => return (1, Op::Composite(T![/=], 2)),\n+            (T![|], T![=]) => return (1, Op::Composite(T![|=], 2)),\n+            (T![&], T![=]) => return (1, Op::Composite(T![&=], 2)),\n+            (T![^], T![=]) => return (1, Op::Composite(T![^=], 2)),\n+            (T![|], T![|]) => return (3, Op::Composite(T![||], 2)),\n+            (T![&], T![&]) => return (4, Op::Composite(T![&&], 2)),\n+            (T![<], T![=]) => return (5, Op::Composite(T![<=], 2)),\n+            (T![>], T![=]) => return (5, Op::Composite(T![>=], 2)),\n+            (T![<], T![<]) => return (9, Op::Composite(T![<<], 2)),\n+            (T![>], T![>]) => return (9, Op::Composite(T![>>], 2)),\n             _ => (),\n         }\n     }\n \n     let bp = match p.current() {\n-        EQ => 1,\n-        DOTDOT | DOTDOTEQ => 2,\n-        EQEQ | NEQ | L_ANGLE | R_ANGLE => 5,\n-        PIPE => 6,\n-        CARET => 7,\n-        AMP => 8,\n-        MINUS | PLUS => 10,\n-        STAR | SLASH | PERCENT => 11,\n+        T![=] => 1,\n+        T![..] | T![..=] => 2,\n+        T![==] | T![!=] | T![<] | T![>] => 5,\n+        T![|] => 6,\n+        T![^] => 7,\n+        T![&] => 8,\n+        T![-] | T![+] => 10,\n+        T![*] | T![/] | T![%] => 11,\n         _ => 0,\n     };\n     (bp, Op::Simple)\n@@ -284,7 +284,7 @@ fn expr_bp(\n             newly_dollar_open = false;\n         }\n \n-        let is_range = p.current() == DOTDOT || p.current() == DOTDOTEQ;\n+        let is_range = p.current() == T![..] || p.current() == T![..=];\n         let (op_bp, op) = current_op(p);\n         if op_bp < bp {\n             break;\n@@ -318,10 +318,10 @@ fn lhs(\n         //     let _ = &1;\n         //     let _ = &mut &f();\n         // }\n-        AMP => {\n+        T![&] => {\n             m = p.start();\n             p.bump();\n-            p.eat(MUT_KW);\n+            p.eat(T![mut]);\n             REF_EXPR\n         }\n         // test unary_expr\n@@ -330,14 +330,14 @@ fn lhs(\n         //     !!true;\n         //     --1;\n         // }\n-        STAR | EXCL | MINUS => {\n+        T![*] | T![!] | T![-] => {\n             m = p.start();\n             p.bump();\n             PREFIX_EXPR\n         }\n         // test full_range_expr\n         // fn foo() { xs[..]; }\n-        DOTDOT | DOTDOTEQ => {\n+        T![..] | T![..=] => {\n             m = p.start();\n             p.bump();\n             if p.at_ts(EXPR_FIRST) {\n@@ -375,21 +375,21 @@ fn postfix_expr(\n             //         [] => {}\n             //     }\n             // }\n-            L_PAREN if allow_calls => call_expr(p, lhs),\n-            L_BRACK if allow_calls => index_expr(p, lhs),\n-            DOT if p.nth(1) == IDENT && (p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON) => {\n+            T!['('] if allow_calls => call_expr(p, lhs),\n+            T!['['] if allow_calls => index_expr(p, lhs),\n+            T![.] if p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]) => {\n                 method_call_expr(p, lhs)\n             }\n-            DOT => field_expr(p, lhs),\n+            T![.] => field_expr(p, lhs),\n             // test postfix_range\n             // fn foo() { let x = 1..; }\n-            DOTDOT | DOTDOTEQ if !EXPR_FIRST.contains(p.nth(1)) => {\n+            T![..] | T![..=] if !EXPR_FIRST.contains(p.nth(1)) => {\n                 let m = lhs.precede(p);\n                 p.bump();\n                 m.complete(p, RANGE_EXPR)\n             }\n-            QUESTION => try_expr(p, lhs),\n-            AS_KW => cast_expr(p, lhs),\n+            T![?] => try_expr(p, lhs),\n+            T![as] => cast_expr(p, lhs),\n             _ => break,\n         };\n         allow_calls = true\n@@ -405,7 +405,7 @@ fn postfix_expr(\n //     f(<Foo as Trait>::func());\n // }\n fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     let m = lhs.precede(p);\n     arg_list(p);\n     m.complete(p, CALL_EXPR)\n@@ -416,11 +416,11 @@ fn call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x[1][2];\n // }\n fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(L_BRACK));\n+    assert!(p.at(T!['[']));\n     let m = lhs.precede(p);\n     p.bump();\n     expr(p);\n-    p.expect(R_BRACK);\n+    p.expect(T![']']);\n     m.complete(p, INDEX_EXPR)\n }\n \n@@ -430,12 +430,12 @@ fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     y.bar::<T>(1, 2,);\n // }\n fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(DOT) && p.nth(1) == IDENT && (p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON));\n+    assert!(p.at(T![.]) && p.nth(1) == IDENT && (p.nth(2) == T!['('] || p.nth(2) == T![::]));\n     let m = lhs.precede(p);\n     p.bump();\n     name_ref(p);\n     type_args::opt_type_arg_list(p, true);\n-    if p.at(L_PAREN) {\n+    if p.at(T!['(']) {\n         arg_list(p);\n     }\n     m.complete(p, METHOD_CALL_EXPR)\n@@ -455,15 +455,15 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x.0x01;\n // }\n fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(DOT));\n+    assert!(p.at(T![.]));\n     let m = lhs.precede(p);\n     p.bump();\n     if p.at(IDENT) {\n         name_ref(p)\n     } else if p.at(INT_NUMBER) {\n         p.bump();\n     } else if p.at(FLOAT_NUMBER) {\n-        // FIXME: How to recover and instead parse INT + DOT?\n+        // FIXME: How to recover and instead parse INT + T![.]?\n         p.bump();\n     } else {\n         p.error(\"expected field name or number\")\n@@ -476,7 +476,7 @@ fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x?;\n // }\n fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(QUESTION));\n+    assert!(p.at(T![?]));\n     let m = lhs.precede(p);\n     p.bump();\n     m.complete(p, TRY_EXPR)\n@@ -490,7 +490,7 @@ fn try_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     0x36 as u8 <= 0x37;\n // }\n fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(AS_KW));\n+    assert!(p.at(T![as]));\n     let m = lhs.precede(p);\n     p.bump();\n     // Use type_no_bounds(), because cast expressions are not\n@@ -500,20 +500,20 @@ fn cast_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n }\n \n fn arg_list(p: &mut Parser) {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(R_PAREN) && !p.at(EOF) {\n+    while !p.at(T![')']) && !p.at(EOF) {\n         if !p.at_ts(EXPR_FIRST) {\n             p.error(\"expected expression\");\n             break;\n         }\n         expr(p);\n-        if !p.at(R_PAREN) && !p.expect(COMMA) {\n+        if !p.at(T![')']) && !p.expect(T![,]) {\n             break;\n         }\n     }\n-    p.eat(R_PAREN);\n+    p.eat(T![')']);\n     m.complete(p, ARG_LIST);\n }\n \n@@ -525,15 +525,15 @@ fn arg_list(p: &mut Parser) {\n //     let _ = format!();\n // }\n fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n-    assert!(paths::is_path_start(p) || p.at(L_ANGLE));\n+    assert!(paths::is_path_start(p) || p.at(T![<]));\n     let m = p.start();\n     paths::expr_path(p);\n     match p.current() {\n-        L_CURLY if !r.forbid_structs => {\n+        T!['{'] if !r.forbid_structs => {\n             named_field_list(p);\n             (m.complete(p, STRUCT_LIT), BlockLike::NotBlock)\n         }\n-        EXCL => {\n+        T![!] => {\n             let block_like = items::macro_call_after_excl(p);\n             (m.complete(p, MACRO_CALL), block_like)\n         }\n@@ -548,35 +548,35 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n //     S { x, y: 32, ..Default::default() };\n // }\n pub(crate) fn named_field_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n             // test struct_literal_field_with_attr\n             // fn main() {\n             //     S { #[cfg(test)] field: 1 }\n             // }\n-            IDENT | POUND => {\n+            IDENT | T![#] => {\n                 let m = p.start();\n                 attributes::outer_attributes(p);\n                 name_ref(p);\n-                if p.eat(COLON) {\n+                if p.eat(T![:]) {\n                     expr(p);\n                 }\n                 m.complete(p, NAMED_FIELD);\n             }\n-            DOTDOT => {\n+            T![..] => {\n                 p.bump();\n                 expr(p);\n             }\n-            L_CURLY => error_block(p, \"expected a field\"),\n+            T!['{'] => error_block(p, \"expected a field\"),\n             _ => p.err_and_bump(\"expected identifier\"),\n         }\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n+        if !p.at(T!['}']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, NAMED_FIELD_LIST);\n }"}, {"sha": "8b1a1de4950f9fbebafd7c33f7ba71a96d49dec8", "filename": "crates/ra_parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -60,29 +60,29 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n     if let Some(m) = literal(p) {\n         return Some((m, BlockLike::NotBlock));\n     }\n-    if paths::is_path_start(p) || p.at(L_ANGLE) {\n+    if paths::is_path_start(p) || p.at(T![<]) {\n         return Some(path_expr(p, r));\n     }\n     let la = p.nth(1);\n     let done = match p.current() {\n-        L_PAREN => tuple_expr(p),\n-        L_BRACK => array_expr(p),\n-        PIPE => lambda_expr(p),\n-        MOVE_KW if la == PIPE => lambda_expr(p),\n-        ASYNC_KW if la == PIPE || (la == MOVE_KW && p.nth(2) == PIPE) => lambda_expr(p),\n-        IF_KW => if_expr(p),\n+        T!['('] => tuple_expr(p),\n+        T!['['] => array_expr(p),\n+        T![|] => lambda_expr(p),\n+        T![move] if la == T![|] => lambda_expr(p),\n+        T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => lambda_expr(p),\n+        T![if] => if_expr(p),\n \n-        LOOP_KW => loop_expr(p, None),\n-        FOR_KW => for_expr(p, None),\n-        WHILE_KW => while_expr(p, None),\n-        LIFETIME if la == COLON => {\n+        T![loop] => loop_expr(p, None),\n+        T![for] => for_expr(p, None),\n+        T![while] => while_expr(p, None),\n+        LIFETIME if la == T![:] => {\n             let m = p.start();\n             label(p);\n             match p.current() {\n-                LOOP_KW => loop_expr(p, Some(m)),\n-                FOR_KW => for_expr(p, Some(m)),\n-                WHILE_KW => while_expr(p, Some(m)),\n-                L_CURLY => block_expr(p, Some(m)),\n+                T![loop] => loop_expr(p, Some(m)),\n+                T![for] => for_expr(p, Some(m)),\n+                T![while] => while_expr(p, Some(m)),\n+                T!['{'] => block_expr(p, Some(m)),\n                 _ => {\n                     // test_err misplaced_label_err\n                     // fn main() {\n@@ -94,22 +94,22 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n                 }\n             }\n         }\n-        ASYNC_KW if la == L_CURLY || (la == MOVE_KW && p.nth(2) == L_CURLY) => {\n+        T![async] if la == T!['{'] || (la == T![move] && p.nth(2) == T!['{']) => {\n             let m = p.start();\n             p.bump();\n-            p.eat(MOVE_KW);\n+            p.eat(T![move]);\n             block_expr(p, Some(m))\n         }\n-        MATCH_KW => match_expr(p),\n-        UNSAFE_KW if la == L_CURLY => {\n+        T![match] => match_expr(p),\n+        T![unsafe] if la == T!['{'] => {\n             let m = p.start();\n             p.bump();\n             block_expr(p, Some(m))\n         }\n-        L_CURLY => block_expr(p, None),\n-        RETURN_KW => return_expr(p),\n-        CONTINUE_KW => continue_expr(p),\n-        BREAK_KW => break_expr(p, r),\n+        T!['{'] => block_expr(p, None),\n+        T![return] => return_expr(p),\n+        T![continue] => continue_expr(p),\n+        T![break] => break_expr(p, r),\n         _ => {\n             p.err_recover(\"expected expression\", EXPR_RECOVERY_SET);\n             return None;\n@@ -129,25 +129,25 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n //     (1,);\n // }\n fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     let m = p.start();\n-    p.expect(L_PAREN);\n+    p.expect(T!['(']);\n \n     let mut saw_comma = false;\n     let mut saw_expr = false;\n-    while !p.at(EOF) && !p.at(R_PAREN) {\n+    while !p.at(EOF) && !p.at(T![')']) {\n         saw_expr = true;\n         if !p.at_ts(EXPR_FIRST) {\n             p.error(\"expected expression\");\n             break;\n         }\n         expr(p);\n-        if !p.at(R_PAREN) {\n+        if !p.at(T![')']) {\n             saw_comma = true;\n-            p.expect(COMMA);\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_PAREN);\n+    p.expect(T![')']);\n     m.complete(p, if saw_expr && !saw_comma { PAREN_EXPR } else { TUPLE_EXPR })\n }\n \n@@ -159,21 +159,21 @@ fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n //     [1; 2];\n // }\n fn array_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(L_BRACK));\n+    assert!(p.at(T!['[']));\n     let m = p.start();\n     p.bump();\n-    if p.eat(R_BRACK) {\n+    if p.eat(T![']']) {\n         return m.complete(p, ARRAY_EXPR);\n     }\n     expr(p);\n-    if p.eat(SEMI) {\n+    if p.eat(T![;]) {\n         expr(p);\n-        p.expect(R_BRACK);\n+        p.expect(T![']']);\n         return m.complete(p, ARRAY_EXPR);\n     }\n-    while !p.at(EOF) && !p.at(R_BRACK) {\n-        p.expect(COMMA);\n-        if p.at(R_BRACK) {\n+    while !p.at(EOF) && !p.at(T![']']) {\n+        p.expect(T![,]);\n+        if p.at(T![']']) {\n             break;\n         }\n         if !p.at_ts(EXPR_FIRST) {\n@@ -182,7 +182,7 @@ fn array_expr(p: &mut Parser) -> CompletedMarker {\n         }\n         expr(p);\n     }\n-    p.expect(R_BRACK);\n+    p.expect(T![']']);\n     m.complete(p, ARRAY_EXPR)\n }\n \n@@ -198,17 +198,17 @@ fn array_expr(p: &mut Parser) -> CompletedMarker {\n // }\n fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(\n-        p.at(PIPE)\n-            || (p.at(MOVE_KW) && p.nth(1) == PIPE)\n-            || (p.at(ASYNC_KW) && p.nth(1) == PIPE)\n-            || (p.at(ASYNC_KW) && p.nth(1) == MOVE_KW && p.nth(2) == PIPE)\n+        p.at(T![|])\n+            || (p.at(T![move]) && p.nth(1) == T![|])\n+            || (p.at(T![async]) && p.nth(1) == T![|])\n+            || (p.at(T![async]) && p.nth(1) == T![move] && p.nth(2) == T![|])\n     );\n     let m = p.start();\n-    p.eat(ASYNC_KW);\n-    p.eat(MOVE_KW);\n+    p.eat(T![async]);\n+    p.eat(T![move]);\n     params::param_list_opt_types(p);\n     if opt_fn_ret_type(p) {\n-        if !p.at(L_CURLY) {\n+        if !p.at(T!['{']) {\n             p.error(\"expected `{`\");\n         }\n     }\n@@ -224,14 +224,14 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n //     if S {};\n // }\n fn if_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(IF_KW));\n+    assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump();\n     cond(p);\n     block(p);\n-    if p.at(ELSE_KW) {\n+    if p.at(T![else]) {\n         p.bump();\n-        if p.at(IF_KW) {\n+        if p.at(T![if]) {\n             if_expr(p);\n         } else {\n             block(p);\n@@ -247,7 +247,7 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n //     'c: for x in () {}\n // }\n fn label(p: &mut Parser) {\n-    assert!(p.at(LIFETIME) && p.nth(1) == COLON);\n+    assert!(p.at(LIFETIME) && p.nth(1) == T![:]);\n     let m = p.start();\n     p.bump();\n     p.bump();\n@@ -259,7 +259,7 @@ fn label(p: &mut Parser) {\n //     loop {};\n // }\n fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n-    assert!(p.at(LOOP_KW));\n+    assert!(p.at(T![loop]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump();\n     block(p);\n@@ -272,7 +272,7 @@ fn loop_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     while let Some(x) = it.next() {};\n // }\n fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n-    assert!(p.at(WHILE_KW));\n+    assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump();\n     cond(p);\n@@ -285,11 +285,11 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     for x in [] {};\n // }\n fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n-    assert!(p.at(FOR_KW));\n+    assert!(p.at(T![for]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump();\n     patterns::pattern(p);\n-    p.expect(IN_KW);\n+    p.expect(T![in]);\n     expr_no_struct(p);\n     block(p);\n     m.complete(p, FOR_EXPR)\n@@ -305,9 +305,9 @@ fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n // }\n fn cond(p: &mut Parser) {\n     let m = p.start();\n-    if p.eat(LET_KW) {\n+    if p.eat(T![let]) {\n         patterns::pattern_list(p);\n-        p.expect(EQ);\n+        p.expect(T![=]);\n     }\n     expr_no_struct(p);\n     m.complete(p, CONDITION);\n@@ -319,11 +319,11 @@ fn cond(p: &mut Parser) {\n //     match S {};\n // }\n fn match_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(MATCH_KW));\n+    assert!(p.at(T![match]));\n     let m = p.start();\n     p.bump();\n     expr_no_struct(p);\n-    if p.at(L_CURLY) {\n+    if p.at(T!['{']) {\n         match_arm_list(p);\n     } else {\n         p.error(\"expected `{`\")\n@@ -332,9 +332,9 @@ fn match_expr(p: &mut Parser) -> CompletedMarker {\n }\n \n pub(crate) fn match_arm_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n-    p.eat(L_CURLY);\n+    p.eat(T!['{']);\n \n     // test match_arms_inner_attribute\n     // fn foo() {\n@@ -347,8 +347,8 @@ pub(crate) fn match_arm_list(p: &mut Parser) {\n     // }\n     attributes::inner_attributes(p);\n \n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        if p.at(L_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n+        if p.at(T!['{']) {\n             error_block(p, \"expected match arm\");\n             continue;\n         }\n@@ -362,12 +362,12 @@ pub(crate) fn match_arm_list(p: &mut Parser) {\n         //     }\n         // }\n         if match_arm(p).is_block() {\n-            p.eat(COMMA);\n-        } else if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n+            p.eat(T![,]);\n+        } else if !p.at(T!['}']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, MATCH_ARM_LIST);\n }\n \n@@ -399,10 +399,10 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n     attributes::outer_attributes(p);\n \n     patterns::pattern_list_r(p, TokenSet::empty());\n-    if p.at(IF_KW) {\n+    if p.at(T![if]) {\n         match_guard(p);\n     }\n-    p.expect(FAT_ARROW);\n+    p.expect(T![=>]);\n     let blocklike = expr_stmt(p).1;\n     m.complete(p, MATCH_ARM);\n     blocklike\n@@ -415,7 +415,7 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n //     }\n // }\n fn match_guard(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(IF_KW));\n+    assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump();\n     expr(p);\n@@ -429,7 +429,7 @@ fn match_guard(p: &mut Parser) -> CompletedMarker {\n //     'label: {};\n // }\n fn block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = m.unwrap_or_else(|| p.start());\n     block(p);\n     m.complete(p, BLOCK_EXPR)\n@@ -441,7 +441,7 @@ fn block_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     return 92;\n // }\n fn return_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(RETURN_KW));\n+    assert!(p.at(T![return]));\n     let m = p.start();\n     p.bump();\n     if p.at_ts(EXPR_FIRST) {\n@@ -458,7 +458,7 @@ fn return_expr(p: &mut Parser) -> CompletedMarker {\n //     }\n // }\n fn continue_expr(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(CONTINUE_KW));\n+    assert!(p.at(T![continue]));\n     let m = p.start();\n     p.bump();\n     p.eat(LIFETIME);\n@@ -475,7 +475,7 @@ fn continue_expr(p: &mut Parser) -> CompletedMarker {\n //     }\n // }\n fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n-    assert!(p.at(BREAK_KW));\n+    assert!(p.at(T![break]));\n     let m = p.start();\n     p.bump();\n     p.eat(LIFETIME);\n@@ -486,7 +486,7 @@ fn break_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n     //     for i in break {}\n     //     match break {}\n     // }\n-    if p.at_ts(EXPR_FIRST) && !(r.forbid_structs && p.at(L_CURLY)) {\n+    if p.at_ts(EXPR_FIRST) && !(r.forbid_structs && p.at(T!['{'])) {\n         expr(p);\n     }\n     m.complete(p, BREAK_EXPR)"}, {"sha": "6728e395fa244371e48c44c2388a1d3a9f9225ad", "filename": "crates/ra_parser/src/grammar/items.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -19,7 +19,7 @@ use super::*;\n // struct S;\n pub(super) fn mod_contents(p: &mut Parser, stop_on_r_curly: bool) {\n     attributes::inner_attributes(p);\n-    while !p.at(EOF) && !(stop_on_r_curly && p.at(R_CURLY)) {\n+    while !p.at(EOF) && !(stop_on_r_curly && p.at(T!['}'])) {\n         item_or_macro(p, stop_on_r_curly, ItemFlavor::Mod)\n     }\n }\n@@ -45,20 +45,20 @@ pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool, flavor: ItemF\n         match macro_call(p) {\n             BlockLike::Block => (),\n             BlockLike::NotBlock => {\n-                p.expect(SEMI);\n+                p.expect(T![;]);\n             }\n         }\n         m.complete(p, MACRO_CALL);\n     } else {\n         m.abandon(p);\n-        if p.at(L_CURLY) {\n+        if p.at(T!['{']) {\n             error_block(p, \"expected an item\");\n-        } else if p.at(R_CURLY) && !stop_on_r_curly {\n+        } else if p.at(T!['}']) && !stop_on_r_curly {\n             let e = p.start();\n             p.error(\"unmatched `}`\");\n             p.bump();\n             e.complete(p, ERROR);\n-        } else if !p.at(EOF) && !p.at(R_CURLY) {\n+        } else if !p.at(EOF) && !p.at(T!['}']) {\n             p.err_and_bump(\"expected an item\");\n         } else {\n             p.error(\"expected an item\");\n@@ -79,32 +79,32 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n     let mut has_mods = false;\n \n     // modifiers\n-    has_mods |= p.eat(CONST_KW);\n+    has_mods |= p.eat(T![const]);\n \n     // test_err unsafe_block_in_mod\n     // fn foo(){} unsafe { } fn bar(){}\n-    if p.at(UNSAFE_KW) && p.nth(1) != L_CURLY {\n-        p.eat(UNSAFE_KW);\n+    if p.at(T![unsafe]) && p.nth(1) != T!['{'] {\n+        p.eat(T![unsafe]);\n         has_mods = true;\n     }\n \n     // test_err async_without_semicolon\n     // fn foo() { let _ = async {} }\n-    if p.at(ASYNC_KW) && p.nth(1) != L_CURLY && p.nth(1) != MOVE_KW && p.nth(1) != PIPE {\n-        p.eat(ASYNC_KW);\n+    if p.at(T![async]) && p.nth(1) != T!['{'] && p.nth(1) != T![move] && p.nth(1) != T![|] {\n+        p.eat(T![async]);\n         has_mods = true;\n     }\n \n-    if p.at(EXTERN_KW) {\n+    if p.at(T![extern]) {\n         has_mods = true;\n         abi(p);\n     }\n-    if p.at(IDENT) && p.at_contextual_kw(\"auto\") && p.nth(1) == TRAIT_KW {\n-        p.bump_remap(AUTO_KW);\n+    if p.at(IDENT) && p.at_contextual_kw(\"auto\") && p.nth(1) == T![trait] {\n+        p.bump_remap(T![auto]);\n         has_mods = true;\n     }\n-    if p.at(IDENT) && p.at_contextual_kw(\"default\") && p.nth(1) == IMPL_KW {\n-        p.bump_remap(DEFAULT_KW);\n+    if p.at(IDENT) && p.at_contextual_kw(\"default\") && p.nth(1) == T![impl ] {\n+        p.bump_remap(T![default]);\n         has_mods = true;\n     }\n \n@@ -135,7 +135,7 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n         // test_err wrong_order_fns\n         // async unsafe fn foo() {}\n         // unsafe const fn bar() {}\n-        FN_KW => {\n+        T![fn] => {\n             fn_def(p, flavor);\n             m.complete(p, FN_DEF);\n         }\n@@ -148,7 +148,7 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n \n         // test unsafe_auto_trait\n         // unsafe auto trait T {}\n-        TRAIT_KW => {\n+        T![trait] => {\n             traits::trait_def(p);\n             m.complete(p, TRAIT_DEF);\n         }\n@@ -161,7 +161,7 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n \n         // test unsafe_default_impl\n         // unsafe default impl Foo {}\n-        IMPL_KW => {\n+        T![impl ] => {\n             traits::impl_block(p);\n             m.complete(p, IMPL_BLOCK);\n         }\n@@ -186,10 +186,10 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     match p.current() {\n         // test extern_crate\n         // extern crate foo;\n-        EXTERN_KW if la == CRATE_KW => extern_crate_item(p, m),\n-        TYPE_KW => type_def(p, m),\n-        MOD_KW => mod_item(p, m),\n-        STRUCT_KW => {\n+        T![extern] if la == T![crate] => extern_crate_item(p, m),\n+        T![type] => type_def(p, m),\n+        T![mod] => mod_item(p, m),\n+        T![struct] => {\n             // test struct_items\n             // struct Foo;\n             // struct Foo {}\n@@ -199,7 +199,7 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            nominal::struct_def(p, m, STRUCT_KW);\n+            nominal::struct_def(p, m, T![struct]);\n         }\n         IDENT if p.at_contextual_kw(\"union\") && p.nth(1) == IDENT => {\n             // test union_items\n@@ -208,24 +208,24 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            nominal::struct_def(p, m, UNION_KW);\n+            nominal::struct_def(p, m, T![union]);\n         }\n-        ENUM_KW => nominal::enum_def(p, m),\n-        USE_KW => use_item::use_item(p, m),\n-        CONST_KW if (la == IDENT || la == MUT_KW) => consts::const_def(p, m),\n-        STATIC_KW => consts::static_def(p, m),\n+        T![enum] => nominal::enum_def(p, m),\n+        T![use] => use_item::use_item(p, m),\n+        T![const] if (la == IDENT || la == T![mut]) => consts::const_def(p, m),\n+        T![static] => consts::static_def(p, m),\n         // test extern_block\n         // extern {}\n-        EXTERN_KW\n-            if la == L_CURLY || ((la == STRING || la == RAW_STRING) && p.nth(2) == L_CURLY) =>\n+        T![extern]\n+            if la == T!['{'] || ((la == STRING || la == RAW_STRING) && p.nth(2) == T!['{']) =>\n         {\n             abi(p);\n             extern_item_list(p);\n             m.complete(p, EXTERN_BLOCK);\n         }\n         _ => return Err(m),\n     };\n-    if p.at(SEMI) {\n+    if p.at(T![;]) {\n         p.err_and_bump(\n             \"expected item, found `;`\\n\\\n              consider removing this semicolon\",\n@@ -235,35 +235,35 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n }\n \n fn extern_crate_item(p: &mut Parser, m: Marker) {\n-    assert!(p.at(EXTERN_KW));\n+    assert!(p.at(T![extern]));\n     p.bump();\n-    assert!(p.at(CRATE_KW));\n+    assert!(p.at(T![crate]));\n     p.bump();\n     name_ref(p);\n     opt_alias(p);\n-    p.expect(SEMI);\n+    p.expect(T![;]);\n     m.complete(p, EXTERN_CRATE_ITEM);\n }\n \n pub(crate) fn extern_item_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n     mod_contents(p, true);\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n-    assert!(p.at(FN_KW));\n+    assert!(p.at(T![fn]));\n     p.bump();\n \n     name_r(p, ITEM_RECOVERY_SET);\n     // test function_type_params\n     // fn foo<T: Clone + Copy>(){}\n     type_params::opt_type_param_list(p);\n \n-    if p.at(L_PAREN) {\n+    if p.at(T!['(']) {\n         match flavor {\n             ItemFlavor::Mod => params::param_list(p),\n             ItemFlavor::Trait => params::param_list_opt_patterns(p),\n@@ -282,7 +282,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n \n     // test fn_decl\n     // trait T { fn foo(); }\n-    if p.at(SEMI) {\n+    if p.at(T![;]) {\n         p.bump();\n     } else {\n         expressions::block(p)\n@@ -292,7 +292,7 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n // test type_item\n // type Foo = Bar;\n fn type_def(p: &mut Parser, m: Marker) {\n-    assert!(p.at(TYPE_KW));\n+    assert!(p.at(T![type]));\n     p.bump();\n \n     name(p);\n@@ -301,40 +301,40 @@ fn type_def(p: &mut Parser, m: Marker) {\n     // type Result<T> = ();\n     type_params::opt_type_param_list(p);\n \n-    if p.at(COLON) {\n+    if p.at(T![:]) {\n         type_params::bounds(p);\n     }\n \n     // test type_item_where_clause\n     // type Foo where Foo: Copy = ();\n     type_params::opt_where_clause(p);\n \n-    if p.eat(EQ) {\n+    if p.eat(T![=]) {\n         types::type_(p);\n     }\n-    p.expect(SEMI);\n+    p.expect(T![;]);\n     m.complete(p, TYPE_ALIAS_DEF);\n }\n \n pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n-    assert!(p.at(MOD_KW));\n+    assert!(p.at(T![mod]));\n     p.bump();\n \n     name(p);\n-    if p.at(L_CURLY) {\n+    if p.at(T!['{']) {\n         mod_item_list(p);\n-    } else if !p.eat(SEMI) {\n+    } else if !p.eat(T![;]) {\n         p.error(\"expected `;` or `{`\");\n     }\n     m.complete(p, MODULE);\n }\n \n pub(crate) fn mod_item_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n     mod_contents(p, true);\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, ITEM_LIST);\n }\n \n@@ -345,16 +345,16 @@ fn macro_call(p: &mut Parser) -> BlockLike {\n }\n \n pub(super) fn macro_call_after_excl(p: &mut Parser) -> BlockLike {\n-    p.expect(EXCL);\n+    p.expect(T![!]);\n     if p.at(IDENT) {\n         name(p);\n     }\n     match p.current() {\n-        L_CURLY => {\n+        T!['{'] => {\n             token_tree(p);\n             BlockLike::Block\n         }\n-        L_PAREN | L_BRACK => {\n+        T!['('] | T!['['] => {\n             token_tree(p);\n             BlockLike::NotBlock\n         }\n@@ -367,22 +367,22 @@ pub(super) fn macro_call_after_excl(p: &mut Parser) -> BlockLike {\n \n pub(crate) fn token_tree(p: &mut Parser) {\n     let closing_paren_kind = match p.current() {\n-        L_CURLY => R_CURLY,\n-        L_PAREN => R_PAREN,\n-        L_BRACK => R_BRACK,\n+        T!['{'] => T!['}'],\n+        T!['('] => T![')'],\n+        T!['['] => T![']'],\n         _ => unreachable!(),\n     };\n     let m = p.start();\n     p.bump();\n     while !p.at(EOF) && !p.at(closing_paren_kind) {\n         match p.current() {\n-            L_CURLY | L_PAREN | L_BRACK => token_tree(p),\n-            R_CURLY => {\n+            T!['{'] | T!['('] | T!['['] => token_tree(p),\n+            T!['}'] => {\n                 p.error(\"unmatched `}`\");\n                 m.complete(p, TOKEN_TREE);\n                 return;\n             }\n-            R_PAREN | R_BRACK => p.err_and_bump(\"unmatched brace\"),\n+            T![')'] | T![']'] => p.err_and_bump(\"unmatched brace\"),\n             _ => p.bump_raw(),\n         }\n     }"}, {"sha": "b4908ebbaa786cf5514b8d6947cb9e207c553e57", "filename": "crates/ra_parser/src/grammar/items/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,22 +1,22 @@\n use super::*;\n \n pub(super) fn static_def(p: &mut Parser, m: Marker) {\n-    const_or_static(p, m, STATIC_KW, STATIC_DEF)\n+    const_or_static(p, m, T![static], STATIC_DEF)\n }\n \n pub(super) fn const_def(p: &mut Parser, m: Marker) {\n-    const_or_static(p, m, CONST_KW, CONST_DEF)\n+    const_or_static(p, m, T![const], CONST_DEF)\n }\n \n fn const_or_static(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     assert!(p.at(kw));\n     p.bump();\n-    p.eat(MUT_KW); // FIXME: validator to forbid const mut\n+    p.eat(T![mut]); // FIXME: validator to forbid const mut\n     name(p);\n     types::ascription(p);\n-    if p.eat(EQ) {\n+    if p.eat(T![=]) {\n         expressions::expr(p);\n     }\n-    p.expect(SEMI);\n+    p.expect(T![;]);\n     m.complete(p, def);\n }"}, {"sha": "bd4edab89020e8c7891c3b08f47cab44f8cd88fd", "filename": "crates/ra_parser/src/grammar/items/nominal.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fnominal.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,38 +1,38 @@\n use super::*;\n \n pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n-    assert!(p.at(STRUCT_KW) || p.at_contextual_kw(\"union\"));\n+    assert!(p.at(T![struct]) || p.at_contextual_kw(\"union\"));\n     p.bump_remap(kind);\n \n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     match p.current() {\n-        WHERE_KW => {\n+        T![where] => {\n             type_params::opt_where_clause(p);\n             match p.current() {\n-                SEMI => {\n+                T![;] => {\n                     p.bump();\n                 }\n-                L_CURLY => named_field_def_list(p),\n+                T!['{'] => named_field_def_list(p),\n                 _ => {\n                     //FIXME: special case `(` error message\n                     p.error(\"expected `;` or `{`\");\n                 }\n             }\n         }\n-        SEMI if kind == STRUCT_KW => {\n+        T![;] if kind == T![struct] => {\n             p.bump();\n         }\n-        L_CURLY => named_field_def_list(p),\n-        L_PAREN if kind == STRUCT_KW => {\n+        T!['{'] => named_field_def_list(p),\n+        T!['('] if kind == T![struct] => {\n             pos_field_def_list(p);\n             // test tuple_struct_where\n             // struct Test<T>(T) where T: Clone;\n             // struct Test<T>(T);\n             type_params::opt_where_clause(p);\n-            p.expect(SEMI);\n+            p.expect(T![;]);\n         }\n-        _ if kind == STRUCT_KW => {\n+        _ if kind == T![struct] => {\n             p.error(\"expected `;`, `{`, or `(`\");\n         }\n         _ => {\n@@ -43,12 +43,12 @@ pub(super) fn struct_def(p: &mut Parser, m: Marker, kind: SyntaxKind) {\n }\n \n pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n-    assert!(p.at(ENUM_KW));\n+    assert!(p.at(T![enum]));\n     p.bump();\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n     type_params::opt_where_clause(p);\n-    if p.at(L_CURLY) {\n+    if p.at(T!['{']) {\n         enum_variant_list(p);\n     } else {\n         p.error(\"expected `{`\")\n@@ -57,11 +57,11 @@ pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n }\n \n pub(crate) fn enum_variant_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        if p.at(L_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n+        if p.at(T!['{']) {\n             error_block(p, \"expected enum variant\");\n             continue;\n         }\n@@ -70,9 +70,9 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n         if p.at(IDENT) {\n             name(p);\n             match p.current() {\n-                L_CURLY => named_field_def_list(p),\n-                L_PAREN => pos_field_def_list(p),\n-                EQ => {\n+                T!['{'] => named_field_def_list(p),\n+                T!['('] => pos_field_def_list(p),\n+                T![=] => {\n                     p.bump();\n                     expressions::expr(p);\n                 }\n@@ -83,29 +83,29 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n             var.abandon(p);\n             p.err_and_bump(\"expected enum variant\");\n         }\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n+        if !p.at(T!['}']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, ENUM_VARIANT_LIST);\n }\n \n pub(crate) fn named_field_def_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(R_CURLY) && !p.at(EOF) {\n-        if p.at(L_CURLY) {\n+    while !p.at(T!['}']) && !p.at(EOF) {\n+        if p.at(T!['{']) {\n             error_block(p, \"expected field\");\n             continue;\n         }\n         named_field_def(p);\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n+        if !p.at(T!['}']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, NAMED_FIELD_DEF_LIST);\n \n     fn named_field_def(p: &mut Parser) {\n@@ -119,7 +119,7 @@ pub(crate) fn named_field_def_list(p: &mut Parser) {\n         opt_visibility(p);\n         if p.at(IDENT) {\n             name(p);\n-            p.expect(COLON);\n+            p.expect(T![:]);\n             types::type_(p);\n             m.complete(p, NAMED_FIELD_DEF);\n         } else {\n@@ -130,12 +130,12 @@ pub(crate) fn named_field_def_list(p: &mut Parser) {\n }\n \n fn pos_field_def_list(p: &mut Parser) {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     let m = p.start();\n-    if !p.expect(L_PAREN) {\n+    if !p.expect(T!['(']) {\n         return;\n     }\n-    while !p.at(R_PAREN) && !p.at(EOF) {\n+    while !p.at(T![')']) && !p.at(EOF) {\n         let m = p.start();\n         // test pos_field_attrs\n         // struct S (\n@@ -156,10 +156,10 @@ fn pos_field_def_list(p: &mut Parser) {\n         types::type_(p);\n         m.complete(p, POS_FIELD_DEF);\n \n-        if !p.at(R_PAREN) {\n-            p.expect(COMMA);\n+        if !p.at(T![')']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_PAREN);\n+    p.expect(T![')']);\n     m.complete(p, POS_FIELD_DEF_LIST);\n }"}, {"sha": "09ab3bfd4ee83495a2c2549b2676f9d8012baa92", "filename": "crates/ra_parser/src/grammar/items/traits.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -4,15 +4,15 @@ use super::*;\n // trait T<U>: Hash + Clone where U: Copy {}\n // trait X<U: Debug + Display>: Hash + Clone where U: Copy {}\n pub(super) fn trait_def(p: &mut Parser) {\n-    assert!(p.at(TRAIT_KW));\n+    assert!(p.at(T![trait]));\n     p.bump();\n     name_r(p, ITEM_RECOVERY_SET);\n     type_params::opt_type_param_list(p);\n-    if p.at(COLON) {\n+    if p.at(T![:]) {\n         type_params::bounds(p);\n     }\n     type_params::opt_where_clause(p);\n-    if p.at(L_CURLY) {\n+    if p.at(T!['{']) {\n         trait_item_list(p);\n     } else {\n         p.error(\"expected `{`\");\n@@ -27,24 +27,24 @@ pub(super) fn trait_def(p: &mut Parser) {\n //     fn bar(&self);\n // }\n pub(crate) fn trait_item_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        if p.at(L_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n+        if p.at(T!['{']) {\n             error_block(p, \"expected an item\");\n             continue;\n         }\n         item_or_macro(p, true, ItemFlavor::Trait);\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, ITEM_LIST);\n }\n \n // test impl_block\n // impl Foo {}\n pub(super) fn impl_block(p: &mut Parser) {\n-    assert!(p.at(IMPL_KW));\n+    assert!(p.at(T![impl ]));\n     p.bump();\n     if choose_type_params_over_qpath(p) {\n         type_params::opt_type_param_list(p);\n@@ -55,13 +55,13 @@ pub(super) fn impl_block(p: &mut Parser) {\n \n     // test impl_block_neg\n     // impl !Send for X {}\n-    p.eat(EXCL);\n+    p.eat(T![!]);\n     impl_type(p);\n-    if p.eat(FOR_KW) {\n+    if p.eat(T![for]) {\n         impl_type(p);\n     }\n     type_params::opt_where_clause(p);\n-    if p.at(L_CURLY) {\n+    if p.at(T!['{']) {\n         impl_item_list(p);\n     } else {\n         p.error(\"expected `{`\");\n@@ -76,7 +76,7 @@ pub(super) fn impl_block(p: &mut Parser) {\n //     fn bar(&self) {}\n // }\n pub(crate) fn impl_item_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n     // test impl_inner_attributes\n@@ -87,14 +87,14 @@ pub(crate) fn impl_item_list(p: &mut Parser) {\n     // }\n     attributes::inner_attributes(p);\n \n-    while !p.at(EOF) && !p.at(R_CURLY) {\n-        if p.at(L_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n+        if p.at(T!['{']) {\n             error_block(p, \"expected an item\");\n             continue;\n         }\n         item_or_macro(p, true, ItemFlavor::Mod);\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, ITEM_LIST);\n }\n \n@@ -114,14 +114,14 @@ fn choose_type_params_over_qpath(p: &Parser) -> bool {\n     // we disambiguate it in favor of generics (`impl<T> ::absolute::Path<T> { ... }`)\n     // because this is what almost always expected in practice, qualified paths in impls\n     // (`impl <Type>::AssocTy { ... }`) aren't even allowed by type checker at the moment.\n-    if !p.at(L_ANGLE) {\n+    if !p.at(T![<]) {\n         return false;\n     }\n-    if p.nth(1) == POUND || p.nth(1) == R_ANGLE {\n+    if p.nth(1) == T![#] || p.nth(1) == T![>] {\n         return true;\n     }\n     (p.nth(1) == LIFETIME || p.nth(1) == IDENT)\n-        && (p.nth(2) == R_ANGLE || p.nth(2) == COMMA || p.nth(2) == COLON || p.nth(2) == EQ)\n+        && (p.nth(2) == T![>] || p.nth(2) == T![,] || p.nth(2) == T![:] || p.nth(2) == T![=])\n }\n \n // test_err impl_type\n@@ -130,7 +130,7 @@ fn choose_type_params_over_qpath(p: &Parser) -> bool {\n // impl impl NotType {}\n // impl Trait2 for impl NotType {}\n pub(crate) fn impl_type(p: &mut Parser) {\n-    if p.at(IMPL_KW) {\n+    if p.at(T![impl ]) {\n         p.error(\"expected trait or type\");\n         return;\n     }"}, {"sha": "c3a0b4410dbc1fe97e07af26c11ca75da97bbfe6", "filename": "crates/ra_parser/src/grammar/items/use_item.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,10 +1,10 @@\n use super::*;\n \n pub(super) fn use_item(p: &mut Parser, m: Marker) {\n-    assert!(p.at(USE_KW));\n+    assert!(p.at(T![use]));\n     p.bump();\n     use_tree(p);\n-    p.expect(SEMI);\n+    p.expect(T![;]);\n     m.complete(p, USE_ITEM);\n }\n \n@@ -28,8 +28,8 @@ fn use_tree(p: &mut Parser) {\n         // use ::*;\n         // use some::path::{*};\n         // use some::path::{::*};\n-        (STAR, _) => p.bump(),\n-        (COLONCOLON, STAR) => {\n+        (T![*], _) => p.bump(),\n+        (T![::], T![*]) => {\n             // Parse `use ::*;`, which imports all from the crate root in Rust 2015\n             // This is invalid inside a use_tree_list, (e.g. `use some::path::{::*}`)\n             // but still parses and errors later: ('crate root in paths can only be used in start position')\n@@ -47,8 +47,8 @@ fn use_tree(p: &mut Parser) {\n         // use {path::from::root}; // Rust 2015\n         // use ::{some::arbritrary::path}; // Rust 2015\n         // use ::{{{crate::export}}}; // Nonsensical but perfectly legal nestnig\n-        (L_CURLY, _) | (COLONCOLON, L_CURLY) => {\n-            if p.at(COLONCOLON) {\n+        (T!['{'], _) | (T![::], T!['{']) => {\n+            if p.at(T![::]) {\n                 p.bump();\n             }\n             use_tree_list(p);\n@@ -68,7 +68,7 @@ fn use_tree(p: &mut Parser) {\n         _ if paths::is_path_start(p) => {\n             paths::use_path(p);\n             match p.current() {\n-                AS_KW => {\n+                T![as] => {\n                     // test use_alias\n                     // use some::path as some_name;\n                     // use some::{\n@@ -80,16 +80,16 @@ fn use_tree(p: &mut Parser) {\n                     // use Trait as _;\n                     opt_alias(p);\n                 }\n-                COLONCOLON => {\n+                T![::] => {\n                     p.bump();\n                     match p.current() {\n-                        STAR => {\n+                        T![*] => {\n                             p.bump();\n                         }\n                         // test use_tree_list_after_path\n                         // use crate::{Item};\n                         // use self::{Item};\n-                        L_CURLY => use_tree_list(p),\n+                        T!['{'] => use_tree_list(p),\n                         _ => {\n                             // is this unreachable?\n                             p.error(\"expected `{` or `*`\");\n@@ -109,15 +109,15 @@ fn use_tree(p: &mut Parser) {\n }\n \n pub(crate) fn use_tree_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n         use_tree(p);\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n+        if !p.at(T!['}']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, USE_TREE_LIST);\n }"}, {"sha": "723b5634325f27358a55b510f4ad2c18eb03bebd", "filename": "crates/ra_parser/src/grammar/params.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fparams.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -36,27 +36,27 @@ impl Flavor {\n }\n \n fn list_(p: &mut Parser, flavor: Flavor) {\n-    let (bra, ket) = if flavor.type_required() { (L_PAREN, R_PAREN) } else { (PIPE, PIPE) };\n+    let (bra, ket) = if flavor.type_required() { (T!['('], T![')']) } else { (T![|], T![|]) };\n     assert!(p.at(bra));\n     let m = p.start();\n     p.bump();\n     if flavor.type_required() {\n         opt_self_param(p);\n     }\n-    while !p.at(EOF) && !p.at(ket) && !(flavor.type_required() && p.at(DOTDOTDOT)) {\n+    while !p.at(EOF) && !p.at(ket) && !(flavor.type_required() && p.at(T![...])) {\n         if !p.at_ts(VALUE_PARAMETER_FIRST) {\n             p.error(\"expected value parameter\");\n             break;\n         }\n         value_parameter(p, flavor);\n         if !p.at(ket) {\n-            p.expect(COMMA);\n+            p.expect(T![,]);\n         }\n     }\n     // test param_list_vararg\n     // extern \"C\" { fn printf(format: *const i8, ...) -> i32; }\n     if flavor.type_required() {\n-        p.eat(DOTDOTDOT);\n+        p.eat(T![...]);\n     }\n     p.expect(ket);\n     m.complete(p, PARAM_LIST);\n@@ -69,7 +69,7 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n     match flavor {\n         Flavor::OptionalType | Flavor::Normal => {\n             patterns::pattern(p);\n-            if p.at(COLON) || flavor.type_required() {\n+            if p.at(T![:]) || flavor.type_required() {\n                 types::ascription(p)\n             }\n         }\n@@ -85,10 +85,10 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n             // trait Foo {\n             //     fn bar(_: u64, mut x: i32);\n             // }\n-            if (la0 == IDENT || la0 == UNDERSCORE) && la1 == COLON\n-                || la0 == MUT_KW && la1 == IDENT && la2 == COLON\n-                || la0 == AMP && la1 == IDENT && la2 == COLON\n-                || la0 == AMP && la1 == MUT_KW && la2 == IDENT && la3 == COLON\n+            if (la0 == IDENT || la0 == T![_]) && la1 == T![:]\n+                || la0 == T![mut] && la1 == IDENT && la2 == T![:]\n+                || la0 == T![&] && la1 == IDENT && la2 == T![:]\n+                || la0 == T![&] && la1 == T![mut] && la2 == IDENT && la3 == T![:]\n             {\n                 patterns::pattern(p);\n                 types::ascription(p);\n@@ -110,27 +110,27 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n // }\n fn opt_self_param(p: &mut Parser) {\n     let m;\n-    if p.at(SELF_KW) || p.at(MUT_KW) && p.nth(1) == SELF_KW {\n+    if p.at(T![self]) || p.at(T![mut]) && p.nth(1) == T![self] {\n         m = p.start();\n-        p.eat(MUT_KW);\n-        p.eat(SELF_KW);\n+        p.eat(T![mut]);\n+        p.eat(T![self]);\n         // test arb_self_types\n         // impl S {\n         //     fn a(self: &Self) {}\n         //     fn b(mut self: Box<Self>) {}\n         // }\n-        if p.at(COLON) {\n+        if p.at(T![:]) {\n             types::ascription(p);\n         }\n     } else {\n         let la1 = p.nth(1);\n         let la2 = p.nth(2);\n         let la3 = p.nth(3);\n         let n_toks = match (p.current(), la1, la2, la3) {\n-            (AMP, SELF_KW, _, _) => 2,\n-            (AMP, MUT_KW, SELF_KW, _) => 3,\n-            (AMP, LIFETIME, SELF_KW, _) => 3,\n-            (AMP, LIFETIME, MUT_KW, SELF_KW) => 4,\n+            (T![&], T![self], _, _) => 2,\n+            (T![&], T![mut], T![self], _) => 3,\n+            (T![&], LIFETIME, T![self], _) => 3,\n+            (T![&], LIFETIME, T![mut], T![self]) => 4,\n             _ => return,\n         };\n         m = p.start();\n@@ -139,7 +139,7 @@ fn opt_self_param(p: &mut Parser) {\n         }\n     }\n     m.complete(p, SELF_PARAM);\n-    if !p.at(R_PAREN) {\n-        p.expect(COMMA);\n+    if !p.at(T![')']) {\n+        p.expect(T![,]);\n     }\n }"}, {"sha": "3537b0da117390bdf8049e06ddb2ffdf2d034bdd", "filename": "crates/ra_parser/src/grammar/paths.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -5,7 +5,7 @@ pub(super) const PATH_FIRST: TokenSet =\n \n pub(super) fn is_path_start(p: &Parser) -> bool {\n     match p.current() {\n-        IDENT | SELF_KW | SUPER_KW | CRATE_KW | COLONCOLON => true,\n+        IDENT | T![self] | T![super] | T![crate] | T![::] => true,\n         _ => false,\n     }\n }\n@@ -35,10 +35,10 @@ fn path(p: &mut Parser, mode: Mode) {\n     let mut qual = path.complete(p, PATH);\n     loop {\n         let use_tree = match p.nth(1) {\n-            STAR | L_CURLY => true,\n+            T![*] | T!['{'] => true,\n             _ => false,\n         };\n-        if p.at(COLONCOLON) && !use_tree {\n+        if p.at(T![::]) && !use_tree {\n             let path = qual.precede(p);\n             p.bump();\n             path_segment(p, mode, false);\n@@ -55,19 +55,19 @@ fn path_segment(p: &mut Parser, mode: Mode, first: bool) {\n     // test qual_paths\n     // type X = <A as B>::Output;\n     // fn foo() { <usize as Default>::default(); }\n-    if first && p.eat(L_ANGLE) {\n+    if first && p.eat(T![<]) {\n         types::type_(p);\n-        if p.eat(AS_KW) {\n+        if p.eat(T![as]) {\n             if is_path_start(p) {\n                 types::path_type(p);\n             } else {\n                 p.error(\"expected a trait\");\n             }\n         }\n-        p.expect(R_ANGLE);\n+        p.expect(T![>]);\n     } else {\n         if first {\n-            p.eat(COLONCOLON);\n+            p.eat(T![::]);\n         }\n         match p.current() {\n             IDENT => {\n@@ -76,7 +76,7 @@ fn path_segment(p: &mut Parser, mode: Mode, first: bool) {\n             }\n             // test crate_path\n             // use crate::foo;\n-            SELF_KW | SUPER_KW | CRATE_KW => p.bump(),\n+            T![self] | T![super] | T![crate] => p.bump(),\n             _ => {\n                 p.err_recover(\"expected identifier\", items::ITEM_RECOVERY_SET);\n             }\n@@ -91,7 +91,7 @@ fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n         Mode::Type => {\n             // test path_fn_trait_args\n             // type F = Box<Fn(x: i32) -> ()>;\n-            if p.at(L_PAREN) {\n+            if p.at(T!['(']) {\n                 params::param_list_opt_patterns(p);\n                 opt_fn_ret_type(p);\n             } else {"}, {"sha": "16ae9da631f4a7750a4e7b6f2ed53873ccaa6fe9", "filename": "crates/ra_parser/src/grammar/patterns.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -16,10 +16,10 @@ pub(super) fn pattern_list(p: &mut Parser) {\n /// Parses a pattern list separated by pipes `|`\n /// using the given `recovery_set`\n pub(super) fn pattern_list_r(p: &mut Parser, recovery_set: TokenSet) {\n-    p.eat(PIPE);\n+    p.eat(T![|]);\n     pattern_r(p, recovery_set);\n \n-    while p.eat(PIPE) {\n+    while p.eat(T![|]) {\n         pattern_r(p, recovery_set);\n     }\n }\n@@ -34,7 +34,7 @@ pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n         //         200 .. 301=> (),\n         //     }\n         // }\n-        if p.at(DOTDOTDOT) || p.at(DOTDOTEQ) || p.at(DOTDOT) {\n+        if p.at(T![...]) || p.at(T![..=]) || p.at(T![..]) {\n             let m = lhs.precede(p);\n             p.bump();\n             atom_pat(p, recovery_set);\n@@ -44,7 +44,7 @@ pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n         // fn main() {\n         //     let m!(x) = 0;\n         // }\n-        else if lhs.kind() == PATH_PAT && p.at(EXCL) {\n+        else if lhs.kind() == PATH_PAT && p.at(T![!]) {\n             let m = lhs.precede(p);\n             items::macro_call_after_excl(p);\n             m.complete(p, MACRO_CALL);\n@@ -58,9 +58,9 @@ const PAT_RECOVERY_SET: TokenSet =\n fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let la0 = p.nth(0);\n     let la1 = p.nth(1);\n-    if la0 == REF_KW\n-        || la0 == MUT_KW\n-        || (la0 == IDENT && !(la1 == COLONCOLON || la1 == L_PAREN || la1 == L_CURLY || la1 == EXCL))\n+    if la0 == T![ref]\n+        || la0 == T![mut]\n+        || (la0 == IDENT && !(la1 == T![::] || la1 == T!['('] || la1 == T!['{'] || la1 == T![!]))\n     {\n         return Some(bind_pat(p, true));\n     }\n@@ -73,10 +73,10 @@ fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     }\n \n     let m = match la0 {\n-        UNDERSCORE => placeholder_pat(p),\n-        AMP => ref_pat(p),\n-        L_PAREN => tuple_pat(p),\n-        L_BRACK => slice_pat(p),\n+        T![_] => placeholder_pat(p),\n+        T![&] => ref_pat(p),\n+        T!['('] => tuple_pat(p),\n+        T!['['] => slice_pat(p),\n         _ => {\n             p.err_recover(\"expected pattern\", recovery_set);\n             return None;\n@@ -86,7 +86,7 @@ fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n }\n \n fn is_literal_pat_start(p: &mut Parser) -> bool {\n-    p.at(MINUS) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER)\n+    p.at(T![-]) && (p.nth(1) == INT_NUMBER || p.nth(1) == FLOAT_NUMBER)\n         || p.at_ts(expressions::LITERAL_FIRST)\n }\n \n@@ -102,7 +102,7 @@ fn is_literal_pat_start(p: &mut Parser) -> bool {\n fn literal_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(is_literal_pat_start(p));\n     let m = p.start();\n-    if p.at(MINUS) {\n+    if p.at(T![-]) {\n         p.bump();\n     }\n     expressions::literal(p);\n@@ -121,11 +121,11 @@ fn path_pat(p: &mut Parser) -> CompletedMarker {\n     let m = p.start();\n     paths::expr_path(p);\n     let kind = match p.current() {\n-        L_PAREN => {\n+        T!['('] => {\n             tuple_pat_fields(p);\n             TUPLE_STRUCT_PAT\n         }\n-        L_CURLY => {\n+        T!['{'] => {\n             field_pat_list(p);\n             STRUCT_PAT\n         }\n@@ -142,10 +142,10 @@ fn path_pat(p: &mut Parser) -> CompletedMarker {\n //     let S(_, .. , x) = ();\n // }\n fn tuple_pat_fields(p: &mut Parser) {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     p.bump();\n-    pat_list(p, R_PAREN);\n-    p.expect(R_PAREN);\n+    pat_list(p, T![')']);\n+    p.expect(T![')']);\n }\n \n // test field_pat_list\n@@ -156,29 +156,29 @@ fn tuple_pat_fields(p: &mut Parser) {\n //     let S { h: _, } = ();\n // }\n fn field_pat_list(p: &mut Parser) {\n-    assert!(p.at(L_CURLY));\n+    assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump();\n-    while !p.at(EOF) && !p.at(R_CURLY) {\n+    while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n-            DOTDOT => p.bump(),\n-            IDENT if p.nth(1) == COLON => field_pat(p),\n-            L_CURLY => error_block(p, \"expected ident\"),\n+            T![..] => p.bump(),\n+            IDENT if p.nth(1) == T![:] => field_pat(p),\n+            T!['{'] => error_block(p, \"expected ident\"),\n             _ => {\n                 bind_pat(p, false);\n             }\n         }\n-        if !p.at(R_CURLY) {\n-            p.expect(COMMA);\n+        if !p.at(T!['}']) {\n+            p.expect(T![,]);\n         }\n     }\n-    p.expect(R_CURLY);\n+    p.expect(T!['}']);\n     m.complete(p, FIELD_PAT_LIST);\n }\n \n fn field_pat(p: &mut Parser) {\n     assert!(p.at(IDENT));\n-    assert!(p.nth(1) == COLON);\n+    assert!(p.nth(1) == T![:]);\n \n     let m = p.start();\n     name(p);\n@@ -190,7 +190,7 @@ fn field_pat(p: &mut Parser) {\n // test placeholder_pat\n // fn main() { let _ = (); }\n fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(UNDERSCORE));\n+    assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump();\n     m.complete(p, PLACEHOLDER_PAT)\n@@ -202,10 +202,10 @@ fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n //     let &mut b = ();\n // }\n fn ref_pat(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(AMP));\n+    assert!(p.at(T![&]));\n     let m = p.start();\n     p.bump();\n-    p.eat(MUT_KW);\n+    p.eat(T![mut]);\n     pattern(p);\n     m.complete(p, REF_PAT)\n }\n@@ -215,7 +215,7 @@ fn ref_pat(p: &mut Parser) -> CompletedMarker {\n //     let (a, b, ..) = ();\n // }\n fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     let m = p.start();\n     tuple_pat_fields(p);\n     m.complete(p, TUPLE_PAT)\n@@ -226,18 +226,18 @@ fn tuple_pat(p: &mut Parser) -> CompletedMarker {\n //     let [a, b, ..] = [];\n // }\n fn slice_pat(p: &mut Parser) -> CompletedMarker {\n-    assert!(p.at(L_BRACK));\n+    assert!(p.at(T!['[']));\n     let m = p.start();\n     p.bump();\n-    pat_list(p, R_BRACK);\n-    p.expect(R_BRACK);\n+    pat_list(p, T![']']);\n+    p.expect(T![']']);\n     m.complete(p, SLICE_PAT)\n }\n \n fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n     while !p.at(EOF) && !p.at(ket) {\n         match p.current() {\n-            DOTDOT => p.bump(),\n+            T![..] => p.bump(),\n             _ => {\n                 if !p.at_ts(PATTERN_FIRST) {\n                     p.error(\"expected a pattern\");\n@@ -247,7 +247,7 @@ fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n             }\n         }\n         if !p.at(ket) {\n-            p.expect(COMMA);\n+            p.expect(T![,]);\n         }\n     }\n }\n@@ -263,10 +263,10 @@ fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n // }\n fn bind_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n     let m = p.start();\n-    p.eat(REF_KW);\n-    p.eat(MUT_KW);\n+    p.eat(T![ref]);\n+    p.eat(T![mut]);\n     name(p);\n-    if with_at && p.eat(AT) {\n+    if with_at && p.eat(T![@]) {\n         pattern(p);\n     }\n     m.complete(p, BIND_PAT)"}, {"sha": "f391b63db4ecb9f36008e40abc2f874c145dff9c", "filename": "crates/ra_parser/src/grammar/type_args.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -3,26 +3,26 @@ use super::*;\n pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     let m;\n     match (colon_colon_required, p.nth(0), p.nth(1)) {\n-        (_, COLONCOLON, L_ANGLE) => {\n+        (_, T![::], T![<]) => {\n             m = p.start();\n             p.bump();\n             p.bump();\n         }\n-        (false, L_ANGLE, EQ) => return,\n-        (false, L_ANGLE, _) => {\n+        (false, T![<], T![=]) => return,\n+        (false, T![<], _) => {\n             m = p.start();\n             p.bump();\n         }\n         _ => return,\n     };\n \n-    while !p.at(EOF) && !p.at(R_ANGLE) {\n+    while !p.at(EOF) && !p.at(T![>]) {\n         type_arg(p);\n-        if !p.at(R_ANGLE) && !p.expect(COMMA) {\n+        if !p.at(T![>]) && !p.expect(T![,]) {\n             break;\n         }\n     }\n-    p.expect(R_ANGLE);\n+    p.expect(T![>]);\n     m.complete(p, TYPE_ARG_LIST);\n }\n \n@@ -35,7 +35,7 @@ fn type_arg(p: &mut Parser) {\n             p.bump();\n             m.complete(p, LIFETIME_ARG);\n         }\n-        IDENT if p.nth(1) == EQ => {\n+        IDENT if p.nth(1) == T![=] => {\n             name_ref(p);\n             p.bump();\n             types::type_(p);"}, {"sha": "4bbfed7803e38907339f194e045d7167e1f9782c", "filename": "crates/ra_parser/src/grammar/type_params.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -1,18 +1,18 @@\n use super::*;\n \n pub(super) fn opt_type_param_list(p: &mut Parser) {\n-    if !p.at(L_ANGLE) {\n+    if !p.at(T![<]) {\n         return;\n     }\n     type_param_list(p);\n }\n \n fn type_param_list(p: &mut Parser) {\n-    assert!(p.at(L_ANGLE));\n+    assert!(p.at(T![<]));\n     let m = p.start();\n     p.bump();\n \n-    while !p.at(EOF) && !p.at(R_ANGLE) {\n+    while !p.at(EOF) && !p.at(T![>]) {\n         let m = p.start();\n \n         // test generic_lifetime_type_attribute\n@@ -28,18 +28,18 @@ fn type_param_list(p: &mut Parser) {\n                 p.err_and_bump(\"expected type parameter\")\n             }\n         }\n-        if !p.at(R_ANGLE) && !p.expect(COMMA) {\n+        if !p.at(T![>]) && !p.expect(T![,]) {\n             break;\n         }\n     }\n-    p.expect(R_ANGLE);\n+    p.expect(T![>]);\n     m.complete(p, TYPE_PARAM_LIST);\n }\n \n fn lifetime_param(p: &mut Parser, m: Marker) {\n     assert!(p.at(LIFETIME));\n     p.bump();\n-    if p.at(COLON) {\n+    if p.at(T![:]) {\n         lifetime_bounds(p);\n     }\n     m.complete(p, LIFETIME_PARAM);\n@@ -48,12 +48,12 @@ fn lifetime_param(p: &mut Parser, m: Marker) {\n fn type_param(p: &mut Parser, m: Marker) {\n     assert!(p.at(IDENT));\n     name(p);\n-    if p.at(COLON) {\n+    if p.at(T![:]) {\n         bounds(p);\n     }\n     // test type_param_default\n     // struct S<T = i32>;\n-    if p.at(EQ) {\n+    if p.at(T![=]) {\n         p.bump();\n         types::type_(p)\n     }\n@@ -63,25 +63,25 @@ fn type_param(p: &mut Parser, m: Marker) {\n // test type_param_bounds\n // struct S<T: 'a + ?Sized + (Copy)>;\n pub(super) fn bounds(p: &mut Parser) {\n-    assert!(p.at(COLON));\n+    assert!(p.at(T![:]));\n     p.bump();\n     bounds_without_colon(p);\n }\n \n fn lifetime_bounds(p: &mut Parser) {\n-    assert!(p.at(COLON));\n+    assert!(p.at(T![:]));\n     p.bump();\n     while p.at(LIFETIME) {\n         p.bump();\n-        if !p.eat(PLUS) {\n+        if !p.eat(T![+]) {\n             break;\n         }\n     }\n }\n \n pub(super) fn bounds_without_colon_m(p: &mut Parser, marker: Marker) -> CompletedMarker {\n     while type_bound(p) {\n-        if !p.eat(PLUS) {\n+        if !p.eat(T![+]) {\n             break;\n         }\n     }\n@@ -96,19 +96,19 @@ pub(super) fn bounds_without_colon(p: &mut Parser) {\n \n fn type_bound(p: &mut Parser) -> bool {\n     let m = p.start();\n-    let has_paren = p.eat(L_PAREN);\n-    p.eat(QUESTION);\n+    let has_paren = p.eat(T!['(']);\n+    p.eat(T![?]);\n     match p.current() {\n         LIFETIME => p.bump(),\n-        FOR_KW => types::for_type(p),\n+        T![for] => types::for_type(p),\n         _ if paths::is_path_start(p) => types::path_type_(p, false),\n         _ => {\n             m.abandon(p);\n             return false;\n         }\n     }\n     if has_paren {\n-        p.expect(R_PAREN);\n+        p.expect(T![')']);\n     }\n     m.complete(p, TYPE_BOUND);\n \n@@ -124,7 +124,7 @@ fn type_bound(p: &mut Parser) -> bool {\n //    <T as Iterator>::Item: 'a\n // {}\n pub(super) fn opt_where_clause(p: &mut Parser) {\n-    if !p.at(WHERE_KW) {\n+    if !p.at(T![where]) {\n         return;\n     }\n     let m = p.start();\n@@ -133,7 +133,7 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n     while is_where_predicate(p) {\n         where_predicate(p);\n \n-        let comma = p.eat(COMMA);\n+        let comma = p.eat(T![,]);\n \n         if is_where_clause_end(p) {\n             break;\n@@ -150,27 +150,27 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n fn is_where_predicate(p: &mut Parser) -> bool {\n     match p.current() {\n         LIFETIME => true,\n-        IMPL_KW => false,\n+        T![impl ] => false,\n         token => types::TYPE_FIRST.contains(token),\n     }\n }\n \n fn is_where_clause_end(p: &mut Parser) -> bool {\n-    p.current() == L_CURLY || p.current() == SEMI || p.current() == EQ\n+    p.current() == T!['{'] || p.current() == T![;] || p.current() == T![=]\n }\n \n fn where_predicate(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {\n             p.bump();\n-            if p.at(COLON) {\n+            if p.at(T![:]) {\n                 bounds(p);\n             } else {\n                 p.error(\"expected colon\");\n             }\n         }\n-        IMPL_KW => {\n+        T![impl ] => {\n             p.error(\"expected lifetime or type\");\n         }\n         _ => {\n@@ -181,7 +181,7 @@ fn where_predicate(p: &mut Parser) {\n             // { }\n             types::type_(p);\n \n-            if p.at(COLON) {\n+            if p.at(T![:]) {\n                 bounds(p);\n             } else {\n                 p.error(\"expected colon\");"}, {"sha": "438e3ab0e4758a9603961bde387a7e028761c7aa", "filename": "crates/ra_parser/src/grammar/types.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -17,18 +17,18 @@ pub(super) fn type_no_bounds(p: &mut Parser) {\n \n fn type_with_bounds_cond(p: &mut Parser, allow_bounds: bool) {\n     match p.current() {\n-        L_PAREN => paren_or_tuple_type(p),\n-        EXCL => never_type(p),\n-        STAR => pointer_type(p),\n-        L_BRACK => array_or_slice_type(p),\n-        AMP => reference_type(p),\n-        UNDERSCORE => placeholder_type(p),\n-        FN_KW | UNSAFE_KW | EXTERN_KW => fn_pointer_type(p),\n-        FOR_KW => for_type(p),\n-        IMPL_KW => impl_trait_type(p),\n-        DYN_KW => dyn_trait_type(p),\n+        T!['('] => paren_or_tuple_type(p),\n+        T![!] => never_type(p),\n+        T![*] => pointer_type(p),\n+        T!['['] => array_or_slice_type(p),\n+        T![&] => reference_type(p),\n+        T![_] => placeholder_type(p),\n+        T![fn] | T![unsafe] | T![extern] => fn_pointer_type(p),\n+        T![for] => for_type(p),\n+        T![impl ] => impl_trait_type(p),\n+        T![dyn ] => dyn_trait_type(p),\n         // Some path types are not allowed to have bounds (no plus)\n-        L_ANGLE => path_type_(p, allow_bounds),\n+        T![<] => path_type_(p, allow_bounds),\n         _ if paths::is_path_start(p) => path_or_macro_type_(p, allow_bounds),\n         _ => {\n             p.err_recover(\"expected type\", TYPE_RECOVERY_SET);\n@@ -37,27 +37,27 @@ fn type_with_bounds_cond(p: &mut Parser, allow_bounds: bool) {\n }\n \n pub(super) fn ascription(p: &mut Parser) {\n-    p.expect(COLON);\n+    p.expect(T![:]);\n     type_(p)\n }\n \n fn paren_or_tuple_type(p: &mut Parser) {\n-    assert!(p.at(L_PAREN));\n+    assert!(p.at(T!['(']));\n     let m = p.start();\n     p.bump();\n     let mut n_types: u32 = 0;\n     let mut trailing_comma: bool = false;\n-    while !p.at(EOF) && !p.at(R_PAREN) {\n+    while !p.at(EOF) && !p.at(T![')']) {\n         n_types += 1;\n         type_(p);\n-        if p.eat(COMMA) {\n+        if p.eat(T![,]) {\n             trailing_comma = true;\n         } else {\n             trailing_comma = false;\n             break;\n         }\n     }\n-    p.expect(R_PAREN);\n+    p.expect(T![')']);\n \n     let kind = if n_types == 1 && !trailing_comma {\n         // test paren_type\n@@ -77,22 +77,22 @@ fn paren_or_tuple_type(p: &mut Parser) {\n // test never_type\n // type Never = !;\n fn never_type(p: &mut Parser) {\n-    assert!(p.at(EXCL));\n+    assert!(p.at(T![!]));\n     let m = p.start();\n     p.bump();\n     m.complete(p, NEVER_TYPE);\n }\n \n fn pointer_type(p: &mut Parser) {\n-    assert!(p.at(STAR));\n+    assert!(p.at(T![*]));\n     let m = p.start();\n     p.bump();\n \n     match p.current() {\n         // test pointer_type_mut\n         // type M = *mut ();\n         // type C = *mut ();\n-        MUT_KW | CONST_KW => p.bump(),\n+        T![mut] | T![const] => p.bump(),\n         _ => {\n             // test_err pointer_type_no_mutability\n             // type T = *();\n@@ -108,25 +108,25 @@ fn pointer_type(p: &mut Parser) {\n }\n \n fn array_or_slice_type(p: &mut Parser) {\n-    assert!(p.at(L_BRACK));\n+    assert!(p.at(T!['[']));\n     let m = p.start();\n     p.bump();\n \n     type_(p);\n     let kind = match p.current() {\n         // test slice_type\n         // type T = [()];\n-        R_BRACK => {\n+        T![']'] => {\n             p.bump();\n             SLICE_TYPE\n         }\n \n         // test array_type\n         // type T = [(); 92];\n-        SEMI => {\n+        T![;] => {\n             p.bump();\n             expressions::expr(p);\n-            p.expect(R_BRACK);\n+            p.expect(T![']']);\n             ARRAY_TYPE\n         }\n         // test_err array_type_missing_semi\n@@ -144,19 +144,19 @@ fn array_or_slice_type(p: &mut Parser) {\n // type B = &'static ();\n // type C = &mut ();\n fn reference_type(p: &mut Parser) {\n-    assert!(p.at(AMP));\n+    assert!(p.at(T![&]));\n     let m = p.start();\n     p.bump();\n     p.eat(LIFETIME);\n-    p.eat(MUT_KW);\n+    p.eat(T![mut]);\n     type_no_bounds(p);\n     m.complete(p, REFERENCE_TYPE);\n }\n \n // test placeholder_type\n // type Placeholder = _;\n fn placeholder_type(p: &mut Parser) {\n-    assert!(p.at(UNDERSCORE));\n+    assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump();\n     m.complete(p, PLACEHOLDER_TYPE);\n@@ -169,18 +169,18 @@ fn placeholder_type(p: &mut Parser) {\n // type D = extern \"C\" fn ( u8 , ... ) -> u8;\n fn fn_pointer_type(p: &mut Parser) {\n     let m = p.start();\n-    p.eat(UNSAFE_KW);\n-    if p.at(EXTERN_KW) {\n+    p.eat(T![unsafe]);\n+    if p.at(T![extern]) {\n         abi(p);\n     }\n     // test_err fn_pointer_type_missing_fn\n     // type F = unsafe ();\n-    if !p.eat(FN_KW) {\n+    if !p.eat(T![fn]) {\n         m.abandon(p);\n         p.error(\"expected `fn`\");\n         return;\n     }\n-    if p.at(L_PAREN) {\n+    if p.at(T!['(']) {\n         params::param_list_opt_patterns(p);\n     } else {\n         p.error(\"expected parameters\")\n@@ -192,9 +192,9 @@ fn fn_pointer_type(p: &mut Parser) {\n }\n \n pub(super) fn for_binder(p: &mut Parser) {\n-    assert!(p.at(FOR_KW));\n+    assert!(p.at(T![for]));\n     p.bump();\n-    if p.at(L_ANGLE) {\n+    if p.at(T![<]) {\n         type_params::opt_type_param_list(p);\n     } else {\n         p.error(\"expected `<`\");\n@@ -206,12 +206,12 @@ pub(super) fn for_binder(p: &mut Parser) {\n // fn foo<T>(_t: &T) where for<'a> &'a T: Iterator {}\n // fn bar<T>(_t: &T) where for<'a> &'a mut T: Iterator {}\n pub(super) fn for_type(p: &mut Parser) {\n-    assert!(p.at(FOR_KW));\n+    assert!(p.at(T![for]));\n     let m = p.start();\n     for_binder(p);\n     match p.current() {\n-        FN_KW | UNSAFE_KW | EXTERN_KW => fn_pointer_type(p),\n-        AMP => reference_type(p),\n+        T![fn] | T![unsafe] | T![extern] => fn_pointer_type(p),\n+        T![&] => reference_type(p),\n         _ if paths::is_path_start(p) => path_type_(p, false),\n         _ => p.error(\"expected a path\"),\n     }\n@@ -221,7 +221,7 @@ pub(super) fn for_type(p: &mut Parser) {\n // test impl_trait_type\n // type A = impl Iterator<Item=Foo<'a>> + 'a;\n fn impl_trait_type(p: &mut Parser) {\n-    assert!(p.at(IMPL_KW));\n+    assert!(p.at(T![impl ]));\n     let m = p.start();\n     p.bump();\n     type_params::bounds_without_colon(p);\n@@ -231,7 +231,7 @@ fn impl_trait_type(p: &mut Parser) {\n // test dyn_trait_type\n // type A = dyn Iterator<Item=Foo<'a>> + 'a;\n fn dyn_trait_type(p: &mut Parser) {\n-    assert!(p.at(DYN_KW));\n+    assert!(p.at(T![dyn ]));\n     let m = p.start();\n     p.bump();\n     type_params::bounds_without_colon(p);\n@@ -251,11 +251,11 @@ pub(super) fn path_type(p: &mut Parser) {\n // type A = foo!();\n // type B = crate::foo!();\n fn path_or_macro_type_(p: &mut Parser, allow_bounds: bool) {\n-    assert!(paths::is_path_start(p) || p.at(L_ANGLE));\n+    assert!(paths::is_path_start(p) || p.at(T![<]));\n     let m = p.start();\n     paths::type_path(p);\n \n-    let kind = if p.at(EXCL) {\n+    let kind = if p.at(T![!]) {\n         items::macro_call_after_excl(p);\n         MACRO_CALL\n     } else {\n@@ -270,7 +270,7 @@ fn path_or_macro_type_(p: &mut Parser, allow_bounds: bool) {\n }\n \n pub(super) fn path_type_(p: &mut Parser, allow_bounds: bool) {\n-    assert!(paths::is_path_start(p) || p.at(L_ANGLE));\n+    assert!(paths::is_path_start(p) || p.at(T![<]));\n     let m = p.start();\n     paths::type_path(p);\n \n@@ -286,7 +286,7 @@ pub(super) fn path_type_(p: &mut Parser, allow_bounds: bool) {\n /// This turns a parsed PATH_TYPE optionally into a DYN_TRAIT_TYPE\n /// with a TYPE_BOUND_LIST\n fn opt_path_type_bounds_as_dyn_trait_type(p: &mut Parser, path_type_marker: CompletedMarker) {\n-    if !p.at(PLUS) {\n+    if !p.at(T![+]) {\n         return;\n     }\n \n@@ -298,7 +298,7 @@ fn opt_path_type_bounds_as_dyn_trait_type(p: &mut Parser, path_type_marker: Comp\n \n     // This gets consumed here so it gets properly set\n     // in the TYPE_BOUND_LIST\n-    p.eat(PLUS);\n+    p.eat(T![+]);\n \n     // Parse rest of the bounds into the TYPE_BOUND_LIST\n     let m = type_params::bounds_without_colon_m(p, m);"}, {"sha": "4434dfb0964a391792c8c07beefbe00a4c2ef2a1", "filename": "crates/ra_parser/src/parser.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fparser.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -6,6 +6,7 @@ use crate::{\n     SyntaxKind::{self, ERROR, EOF, TOMBSTONE},\n     TokenSource, ParseError, TokenSet,\n     event::Event,\n+    T\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -155,10 +156,10 @@ impl<'t> Parser<'t> {\n \n         // Handle parser composites\n         match kind {\n-            DOTDOTDOT | DOTDOTEQ => {\n+            T![...] | T![..=] => {\n                 self.bump_compound(kind, 3);\n             }\n-            DOTDOT | COLONCOLON | EQEQ | FAT_ARROW | NEQ | THIN_ARROW => {\n+            T![..] | T![::] | T![==] | T![=>] | T![!=] | T![->] => {\n                 self.bump_compound(kind, 2);\n             }\n             _ => {\n@@ -223,7 +224,7 @@ impl<'t> Parser<'t> {\n \n     /// Create an error node and consume the next token.\n     pub(crate) fn err_recover(&mut self, message: &str, recovery: TokenSet) {\n-        if self.at(SyntaxKind::L_CURLY) || self.at(SyntaxKind::R_CURLY) || self.at_ts(recovery) {\n+        if self.at(T!['{']) || self.at(T!['}']) || self.at_ts(recovery) {\n             self.error(message);\n         } else {\n             let m = self.start();\n@@ -253,19 +254,17 @@ impl<'t> Parser<'t> {\n         let jn2 = self.token_source.is_token_joint_to_next(self.token_pos + n + 1);\n         let la3 = self.token_source.token_kind(self.token_pos + n + 2);\n \n-        use SyntaxKind::*;\n-\n         match kind {\n-            DOT if jn1 && la2 == DOT && jn2 && la3 == DOT => Some((DOTDOTDOT, 3)),\n-            DOT if jn1 && la2 == DOT && la3 == EQ => Some((DOTDOTEQ, 3)),\n-            DOT if jn1 && la2 == DOT => Some((DOTDOT, 2)),\n+            T![.] if jn1 && la2 == T![.] && jn2 && la3 == T![.] => Some((T![...], 3)),\n+            T![.] if jn1 && la2 == T![.] && la3 == T![=] => Some((T![..=], 3)),\n+            T![.] if jn1 && la2 == T![.] => Some((T![..], 2)),\n \n-            COLON if jn1 && la2 == COLON => Some((COLONCOLON, 2)),\n-            EQ if jn1 && la2 == EQ => Some((EQEQ, 2)),\n-            EQ if jn1 && la2 == R_ANGLE => Some((FAT_ARROW, 2)),\n+            T![:] if jn1 && la2 == T![:] => Some((T![::], 2)),\n+            T![=] if jn1 && la2 == T![=] => Some((T![==], 2)),\n+            T![=] if jn1 && la2 == T![>] => Some((T![=>], 2)),\n \n-            EXCL if la2 == EQ => Some((NEQ, 2)),\n-            MINUS if la2 == R_ANGLE => Some((THIN_ARROW, 2)),\n+            T![!] if la2 == T![=] => Some((T![!=], 2)),\n+            T![-] if la2 == T![>] => Some((T![->], 2)),\n             _ => None,\n         }\n     }"}, {"sha": "d7926bd9130489a78b2b163f041d81926f697834", "filename": "crates/ra_parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -245,8 +245,8 @@ use self::SyntaxKind::*;\n macro_rules! T {\n     (;) => { $crate::SyntaxKind::SEMI };\n     (,) => { $crate::SyntaxKind::COMMA };\n-    (() => { $crate::SyntaxKind::L_PAREN };\n-    ()) => { $crate::SyntaxKind::R_PAREN };\n+    ('(') => { $crate::SyntaxKind::L_PAREN };\n+    (')') => { $crate::SyntaxKind::R_PAREN };\n     ('{') => { $crate::SyntaxKind::L_CURLY };\n     ('}') => { $crate::SyntaxKind::R_CURLY };\n     ('[') => { $crate::SyntaxKind::L_BRACK };"}, {"sha": "f5abbec4bcf97c10058aa5ce2b301ae7286678c6", "filename": "crates/ra_parser/src/syntax_kind/generated.rs.tera", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs.tera?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -36,7 +36,7 @@ use self::SyntaxKind::*;\n #[macro_export]\n macro_rules! T {\n {%- for t in concat(a=single_byte_tokens, b=multi_byte_tokens) %}\n-    {%- if t.0 == '{' or t.0 == '}' or t.0 == '[' or t.0 == ']' %}\n+    {%- if t.0 == '{' or t.0 == '}' or t.0 == '[' or t.0 == ']' or t.0 == '(' or t.0 == ')' %}\n     ('{{t.0}}') => { $crate::SyntaxKind::{{t.1}} };\n     {%- else %}\n     ({{t.0}}) => { $crate::SyntaxKind::{{t.1}} };"}, {"sha": "17763809da916488c3f4858b8a419de6614f72c3", "filename": "crates/ra_syntax/src/ast/expr_extensions.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fexpr_extensions.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -3,7 +3,8 @@\n use crate::{\n     SyntaxToken, SyntaxElement, SmolStr,\n     ast::{self, AstNode, AstChildren, children, child_opt},\n-    SyntaxKind::*\n+    SyntaxKind::*,\n+    T\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -34,7 +35,7 @@ impl ast::IfExpr {\n \n impl ast::RefExpr {\n     pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n }\n \n@@ -51,9 +52,9 @@ pub enum PrefixOp {\n impl ast::PrefixExpr {\n     pub fn op_kind(&self) -> Option<PrefixOp> {\n         match self.op_token()?.kind() {\n-            STAR => Some(PrefixOp::Deref),\n-            EXCL => Some(PrefixOp::Not),\n-            MINUS => Some(PrefixOp::Neg),\n+            T![*] => Some(PrefixOp::Deref),\n+            T![!] => Some(PrefixOp::Not),\n+            T![-] => Some(PrefixOp::Neg),\n             _ => None,\n         }\n     }\n@@ -133,37 +134,37 @@ impl ast::BinExpr {\n     fn op_details(&self) -> Option<(SyntaxToken, BinOp)> {\n         self.syntax().children_with_tokens().filter_map(|it| it.as_token()).find_map(|c| {\n             match c.kind() {\n-                PIPEPIPE => Some((c, BinOp::BooleanOr)),\n-                AMPAMP => Some((c, BinOp::BooleanAnd)),\n-                EQEQ => Some((c, BinOp::EqualityTest)),\n-                NEQ => Some((c, BinOp::NegatedEqualityTest)),\n-                LTEQ => Some((c, BinOp::LesserEqualTest)),\n-                GTEQ => Some((c, BinOp::GreaterEqualTest)),\n-                L_ANGLE => Some((c, BinOp::LesserTest)),\n-                R_ANGLE => Some((c, BinOp::GreaterTest)),\n-                PLUS => Some((c, BinOp::Addition)),\n-                STAR => Some((c, BinOp::Multiplication)),\n-                MINUS => Some((c, BinOp::Subtraction)),\n-                SLASH => Some((c, BinOp::Division)),\n-                PERCENT => Some((c, BinOp::Remainder)),\n-                SHL => Some((c, BinOp::LeftShift)),\n-                SHR => Some((c, BinOp::RightShift)),\n-                CARET => Some((c, BinOp::BitwiseXor)),\n-                PIPE => Some((c, BinOp::BitwiseOr)),\n-                AMP => Some((c, BinOp::BitwiseAnd)),\n-                DOTDOT => Some((c, BinOp::RangeRightOpen)),\n-                DOTDOTEQ => Some((c, BinOp::RangeRightClosed)),\n-                EQ => Some((c, BinOp::Assignment)),\n-                PLUSEQ => Some((c, BinOp::AddAssign)),\n-                SLASHEQ => Some((c, BinOp::DivAssign)),\n-                STAREQ => Some((c, BinOp::MulAssign)),\n-                PERCENTEQ => Some((c, BinOp::RemAssign)),\n-                SHREQ => Some((c, BinOp::ShrAssign)),\n-                SHLEQ => Some((c, BinOp::ShlAssign)),\n-                MINUSEQ => Some((c, BinOp::SubAssign)),\n-                PIPEEQ => Some((c, BinOp::BitOrAssign)),\n-                AMPEQ => Some((c, BinOp::BitAndAssign)),\n-                CARETEQ => Some((c, BinOp::BitXorAssign)),\n+                T![||] => Some((c, BinOp::BooleanOr)),\n+                T![&&] => Some((c, BinOp::BooleanAnd)),\n+                T![==] => Some((c, BinOp::EqualityTest)),\n+                T![!=] => Some((c, BinOp::NegatedEqualityTest)),\n+                T![<=] => Some((c, BinOp::LesserEqualTest)),\n+                T![>=] => Some((c, BinOp::GreaterEqualTest)),\n+                T![<] => Some((c, BinOp::LesserTest)),\n+                T![>] => Some((c, BinOp::GreaterTest)),\n+                T![+] => Some((c, BinOp::Addition)),\n+                T![*] => Some((c, BinOp::Multiplication)),\n+                T![-] => Some((c, BinOp::Subtraction)),\n+                T![/] => Some((c, BinOp::Division)),\n+                T![%] => Some((c, BinOp::Remainder)),\n+                T![<<] => Some((c, BinOp::LeftShift)),\n+                T![>>] => Some((c, BinOp::RightShift)),\n+                T![^] => Some((c, BinOp::BitwiseXor)),\n+                T![|] => Some((c, BinOp::BitwiseOr)),\n+                T![&] => Some((c, BinOp::BitwiseAnd)),\n+                T![..] => Some((c, BinOp::RangeRightOpen)),\n+                T![..=] => Some((c, BinOp::RangeRightClosed)),\n+                T![=] => Some((c, BinOp::Assignment)),\n+                T![+=] => Some((c, BinOp::AddAssign)),\n+                T![/=] => Some((c, BinOp::DivAssign)),\n+                T![*=] => Some((c, BinOp::MulAssign)),\n+                T![%=] => Some((c, BinOp::RemAssign)),\n+                T![>>=] => Some((c, BinOp::ShrAssign)),\n+                T![<<=] => Some((c, BinOp::ShlAssign)),\n+                T![-=] => Some((c, BinOp::SubAssign)),\n+                T![|=] => Some((c, BinOp::BitOrAssign)),\n+                T![&=] => Some((c, BinOp::BitAndAssign)),\n+                T![^=] => Some((c, BinOp::BitXorAssign)),\n                 _ => None,\n             }\n         })\n@@ -211,7 +212,7 @@ impl ast::ArrayExpr {\n     }\n \n     fn is_repeat(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == SEMI)\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![;])\n     }\n }\n \n@@ -258,7 +259,7 @@ impl ast::Literal {\n                 LiteralKind::FloatNumber { suffix: suffix }\n             }\n             STRING | RAW_STRING => LiteralKind::String,\n-            TRUE_KW | FALSE_KW => LiteralKind::Bool,\n+            T![true] | T![false] => LiteralKind::Bool,\n             BYTE_STRING | RAW_BYTE_STRING => LiteralKind::ByteString,\n             CHAR => LiteralKind::Char,\n             BYTE => LiteralKind::Byte,"}, {"sha": "f030e0df8029ec61257a6d27d1df279d91ae5b18", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -3,7 +3,7 @@\n \n use itertools::Itertools;\n \n-use crate::{SmolStr, SyntaxToken, ast::{self, AstNode, children, child_opt}, SyntaxKind::*, SyntaxElement};\n+use crate::{SmolStr, SyntaxToken, ast::{self, AstNode, children, child_opt}, SyntaxKind::*, SyntaxElement, T};\n use ra_parser::SyntaxKind;\n \n impl ast::Name {\n@@ -32,7 +32,7 @@ impl ast::Attr {\n             Some(prev) => prev,\n         };\n \n-        prev.kind() == EXCL\n+        prev.kind() == T![!]\n     }\n \n     pub fn as_atom(&self) -> Option<SmolStr> {\n@@ -102,9 +102,9 @@ impl ast::PathSegment {\n             PathSegmentKind::Name(name_ref)\n         } else {\n             match self.syntax().first_child_or_token()?.kind() {\n-                SELF_KW => PathSegmentKind::SelfKw,\n-                SUPER_KW => PathSegmentKind::SuperKw,\n-                CRATE_KW => PathSegmentKind::CrateKw,\n+                T![self] => PathSegmentKind::SelfKw,\n+                T![super] => PathSegmentKind::SuperKw,\n+                T![crate] => PathSegmentKind::CrateKw,\n                 _ => return None,\n             }\n         };\n@@ -113,7 +113,7 @@ impl ast::PathSegment {\n \n     pub fn has_colon_colon(&self) -> bool {\n         match self.syntax.first_child_or_token().map(|s| s.kind()) {\n-            Some(COLONCOLON) => true,\n+            Some(T![::]) => true,\n             _ => false,\n         }\n     }\n@@ -129,14 +129,14 @@ impl ast::Module {\n     pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child_or_token() {\n             None => false,\n-            Some(node) => node.kind() == SEMI,\n+            Some(node) => node.kind() == T![;],\n         }\n     }\n }\n \n impl ast::UseTree {\n     pub fn has_star(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == STAR)\n+        self.syntax().children_with_tokens().any(|it| it.kind() == T![*])\n     }\n }\n \n@@ -172,7 +172,7 @@ impl ast::ImplBlock {\n     }\n \n     pub fn is_negative(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|t| t.kind() == EXCL)\n+        self.syntax().children_with_tokens().any(|t| t.kind() == T![!])\n     }\n }\n \n@@ -219,15 +219,15 @@ impl ast::FnDef {\n         self.syntax()\n             .last_child_or_token()\n             .and_then(|it| it.as_token())\n-            .filter(|it| it.kind() == SEMI)\n+            .filter(|it| it.kind() == T![;])\n     }\n }\n \n impl ast::LetStmt {\n     pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child_or_token() {\n             None => false,\n-            Some(node) => node.kind() == SEMI,\n+            Some(node) => node.kind() == T![;],\n         }\n     }\n }\n@@ -236,7 +236,7 @@ impl ast::ExprStmt {\n     pub fn has_semi(&self) -> bool {\n         match self.syntax().last_child_or_token() {\n             None => false,\n-            Some(node) => node.kind() == SEMI,\n+            Some(node) => node.kind() == T![;],\n         }\n     }\n }\n@@ -270,29 +270,29 @@ impl ast::FieldExpr {\n \n impl ast::RefPat {\n     pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n }\n \n impl ast::BindPat {\n     pub fn is_mutable(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n \n     pub fn is_ref(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == REF_KW)\n+        self.syntax().children_with_tokens().any(|n| n.kind() == T![ref])\n     }\n }\n \n impl ast::PointerType {\n     pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n }\n \n impl ast::ReferenceType {\n     pub fn is_mut(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|n| n.kind() == MUT_KW)\n+        self.syntax().children_with_tokens().any(|n| n.kind() == T![mut])\n     }\n }\n \n@@ -311,19 +311,19 @@ impl ast::SelfParam {\n         self.syntax()\n             .children_with_tokens()\n             .filter_map(|it| it.as_token())\n-            .find(|it| it.kind() == SELF_KW)\n+            .find(|it| it.kind() == T![self])\n             .expect(\"invalid tree: self param must have self\")\n     }\n \n     pub fn kind(&self) -> SelfParamKind {\n-        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == AMP);\n+        let borrowed = self.syntax().children_with_tokens().any(|n| n.kind() == T![&]);\n         if borrowed {\n             // check for a `mut` coming after the & -- `mut &self` != `&mut self`\n             if self\n                 .syntax()\n                 .children_with_tokens()\n-                .skip_while(|n| n.kind() != AMP)\n-                .any(|n| n.kind() == MUT_KW)\n+                .skip_while(|n| n.kind() != T![&])\n+                .any(|n| n.kind() == T![mut])\n             {\n                 SelfParamKind::MutRef\n             } else {\n@@ -355,6 +355,6 @@ impl ast::WherePred {\n \n impl ast::TraitDef {\n     pub fn is_auto(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|t| t.kind() == AUTO_KW)\n+        self.syntax().children_with_tokens().any(|t| t.kind() == T![auto])\n     }\n }"}, {"sha": "0ceabc203f6dbae9f0efa438d72511a47fba7dc9", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -179,10 +179,7 @@ fn api_walkthrough() {\n \n     // There's a bunch of traversal methods on `SyntaxNode`:\n     assert_eq!(expr_syntax.parent(), Some(block.syntax()));\n-    assert_eq!(\n-        block.syntax().first_child_or_token().map(|it| it.kind()),\n-        Some(SyntaxKind::L_CURLY)\n-    );\n+    assert_eq!(block.syntax().first_child_or_token().map(|it| it.kind()), Some(T!['{']));\n     assert_eq!(\n         expr_syntax.next_sibling_or_token().map(|it| it.kind()),\n         Some(SyntaxKind::WHITESPACE)\n@@ -191,9 +188,7 @@ fn api_walkthrough() {\n     // As well as some iterator helpers:\n     let f = expr_syntax.ancestors().find_map(ast::FnDef::cast);\n     assert_eq!(f, Some(&*func));\n-    assert!(expr_syntax\n-        .siblings_with_tokens(Direction::Next)\n-        .any(|it| it.kind() == SyntaxKind::R_CURLY));\n+    assert!(expr_syntax.siblings_with_tokens(Direction::Next).any(|it| it.kind() == T!['}']));\n     assert_eq!(\n         expr_syntax.descendants_with_tokens().count(),\n         8, // 5 tokens `1`, ` `, `+`, ` `, `!`"}, {"sha": "6eb96f03da089cc8ec6d349af0bc220d58b6eb43", "filename": "crates/ra_syntax/src/parsing/lexer.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Flexer.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -7,6 +7,7 @@ mod strings;\n use crate::{\n     SyntaxKind::{self, *},\n     TextUnit,\n+    T,\n };\n \n use self::{\n@@ -90,16 +91,16 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     match c {\n         // Possiblily multi-byte tokens,\n         // but we only produce single byte token now\n-        // DOTDOTDOT, DOTDOT, DOTDOTEQ, DOT\n-        '.' => return DOT,\n-        // COLONCOLON COLON\n-        ':' => return COLON,\n-        // EQEQ FATARROW EQ\n-        '=' => return EQ,\n-        // NEQ EXCL\n-        '!' => return EXCL,\n-        // THIN_ARROW MINUS\n-        '-' => return MINUS,\n+        // T![...], T![..], T![..=], T![.]\n+        '.' => return T![.],\n+        // T![::] T![:]\n+        ':' => return T![:],\n+        // T![==] FATARROW T![=]\n+        '=' => return T![=],\n+        // T![!=] T![!]\n+        '!' => return T![!],\n+        // T![->] T![-]\n+        '-' => return T![-],\n \n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n@@ -148,8 +149,8 @@ fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             ptr.bump();\n             true\n         }\n-        ('_', None) => return UNDERSCORE,\n-        ('_', Some(c)) if !is_ident_continue(c) => return UNDERSCORE,\n+        ('_', None) => return T![_],\n+        ('_', Some(c)) if !is_ident_continue(c) => return T![_],\n         _ => false,\n     };\n     ptr.bump_while(is_ident_continue);"}, {"sha": "6de02a15a7c23d5e1ce9ee7bada095e48fbfb782", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -17,7 +17,8 @@ use crate::{\n         text_token_source::TextTokenSource,\n         text_tree_sink::TextTreeSink,\n         lexer::{tokenize, Token},\n-    }\n+    },\n+    T,\n };\n \n pub(crate) fn incremental_reparse(\n@@ -122,16 +123,16 @@ fn find_reparsable_node(node: &SyntaxNode, range: TextRange) -> Option<(&SyntaxN\n \n fn is_balanced(tokens: &[Token]) -> bool {\n     if tokens.is_empty()\n-        || tokens.first().unwrap().kind != L_CURLY\n-        || tokens.last().unwrap().kind != R_CURLY\n+        || tokens.first().unwrap().kind != T!['{']\n+        || tokens.last().unwrap().kind != T!['}']\n     {\n         return false;\n     }\n     let mut balance = 0usize;\n     for t in &tokens[1..tokens.len() - 1] {\n         match t.kind {\n-            L_CURLY => balance += 1,\n-            R_CURLY => {\n+            T!['{'] => balance += 1,\n+            T!['}'] => {\n                 balance = match balance.checked_sub(1) {\n                     Some(b) => b,\n                     None => return false,"}, {"sha": "b53900a4bbf9fdfdb74cb3e3940306bc1589e242", "filename": "crates/ra_syntax/src/validation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=ec7d2f64ade9ffa35a64e82ac53e65ad5cbe9efd", "patch": "@@ -5,9 +5,10 @@ mod field_expr;\n \n use crate::{\n     SourceFile, SyntaxError, AstNode, SyntaxNode, TextUnit,\n-    SyntaxKind::{L_CURLY, R_CURLY, BYTE, BYTE_STRING, STRING, CHAR},\n+    SyntaxKind::{BYTE, BYTE_STRING, STRING, CHAR},\n     ast,\n     algo::visit::{visitor_ctx, VisitorCtx},\n+    T,\n };\n \n pub(crate) use unescape::EscapeError;\n@@ -83,8 +84,8 @@ pub(crate) fn validate_block_structure(root: &SyntaxNode) {\n     let mut stack = Vec::new();\n     for node in root.descendants() {\n         match node.kind() {\n-            L_CURLY => stack.push(node),\n-            R_CURLY => {\n+            T!['{'] => stack.push(node),\n+            T!['}'] => {\n                 if let Some(pair) = stack.pop() {\n                     assert_eq!(\n                         node.parent(),"}]}