{"sha": "f06b76122cde7ddd4f6778d77952b63baa70bdfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNmI3NjEyMmNkZTdkZGQ0ZjY3NzhkNzc5NTJiNjNiYWE3MGJkZmU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-06-12T01:21:53Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-06-14T20:40:10Z"}, "message": "review comments: move diagnostic code out of happy path", "tree": {"sha": "432b095af362b1e3632640f072a0cc7950923d33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/432b095af362b1e3632640f072a0cc7950923d33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f06b76122cde7ddd4f6778d77952b63baa70bdfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f06b76122cde7ddd4f6778d77952b63baa70bdfe", "html_url": "https://github.com/rust-lang/rust/commit/f06b76122cde7ddd4f6778d77952b63baa70bdfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f06b76122cde7ddd4f6778d77952b63baa70bdfe/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56e30e1f3f953f3b8b88f46e32a2ec1f5573943c", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e30e1f3f953f3b8b88f46e32a2ec1f5573943c", "html_url": "https://github.com/rust-lang/rust/commit/56e30e1f3f953f3b8b88f46e32a2ec1f5573943c"}], "stats": {"total": 93, "additions": 53, "deletions": 40}, "files": [{"sha": "2cb955c7c2ef0bfa5c1223dd3df5c15475c21502", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 53, "deletions": 40, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/f06b76122cde7ddd4f6778d77952b63baa70bdfe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06b76122cde7ddd4f6778d77952b63baa70bdfe/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f06b76122cde7ddd4f6778d77952b63baa70bdfe", "patch": "@@ -1789,6 +1789,52 @@ fn check_packed_inner<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, stack: &mut Vec<De\n     false\n }\n \n+/// Emit an error when encountering more or less than one variant in a transparent enum.\n+fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, did: DefId) {\n+    let variant_spans: Vec<_> = adt.variants.iter().map(|variant| {\n+        tcx.hir().span_if_local(variant.def_id).unwrap()\n+    }).collect();\n+    let msg = format!(\n+        \"needs exactly one variant, but has {}\",\n+        adt.variants.len(),\n+    );\n+    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n+    err.span_label(sp, &msg);\n+    if let &[ref start.., ref end] = &variant_spans[..] {\n+        for variant_span in start {\n+            err.span_label(*variant_span, \"\");\n+        }\n+        err.span_label(*end, &format!(\"too many variants in `{}`\", tcx.def_path_str(did)));\n+    }\n+    err.emit();\n+}\n+\n+/// Emit an error when encountering more or less than one non-zero-sized field in a transparent\n+/// enum.\n+fn bad_non_zero_sized_fields<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    adt: &'tcx ty::AdtDef,\n+    field_count: usize,\n+    field_spans: impl Iterator<Item = Span>,\n+    sp: Span,\n+) {\n+    let msg = format!(\"needs exactly one non-zero-sized field, but has {}\", field_count);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        sp,\n+        E0690,\n+        \"{}transparent {} {}\",\n+        if adt.is_enum() { \"the variant of a \" } else { \"\" },\n+        adt.descr(),\n+        msg,\n+    );\n+    err.span_label(sp, &msg);\n+    for sp in field_spans {\n+        err.span_label(sp, \"this field is non-zero-sized\");\n+    }\n+    err.emit();\n+}\n+\n fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n     let adt = tcx.adt_def(def_id);\n     if !adt.repr.transparent() {\n@@ -1807,28 +1853,7 @@ fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n             );\n         }\n         if adt.variants.len() != 1 {\n-            let variant_spans: Vec<_> = adt.variants.iter().map(|variant| {\n-                tcx.hir().span_if_local(variant.def_id).unwrap()\n-            }).collect();\n-            let msg = format!(\n-                \"needs exactly one variant, but has {}\",\n-                adt.variants.len(),\n-            );\n-            let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n-            err.span_label(sp, &msg);\n-            match &variant_spans[..] {\n-                &[] => {},\n-                &[ref start.., ref end] => {\n-                    for variant_span in start {\n-                        err.span_label(*variant_span, \"\");\n-                    }\n-                    err.span_label(*end, &format!(\n-                        \"too many variants in `{}`\",\n-                        tcx.def_path_str(def_id),\n-                    ));\n-                },\n-            }\n-            err.emit();\n+            bad_variant_count(tcx, adt, sp, def_id);\n             if adt.variants.is_empty() {\n                 // Don't bother checking the fields. No variants (and thus no fields) exist.\n                 return;\n@@ -1856,26 +1881,14 @@ fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n         (span, zst, align1)\n     });\n \n-    let non_zst_fields = field_infos.clone().filter(|(_span, zst, _align1)| !*zst);\n+    let non_zst_fields = field_infos.clone().filter_map(|(span, zst, _align1)| if !zst {\n+        Some(span)\n+    } else {\n+        None\n+    });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count != 1 {\n-        let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| span).collect();\n-\n-        let msg = format!(\"needs exactly one non-zero-sized field, but has {}\", non_zst_count);\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            sp,\n-            E0690,\n-            \"{}transparent {} {}\",\n-            if adt.is_enum() { \"the variant of a \" } else { \"\" },\n-            adt.descr(),\n-            msg,\n-        );\n-        err.span_label(sp, &msg);\n-        for sp in &field_spans {\n-            err.span_label(*sp, \"this field is non-zero-sized\");\n-        }\n-        err.emit();\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n     }\n     for (span, zst, align1) in field_infos {\n         if zst && !align1 {"}]}