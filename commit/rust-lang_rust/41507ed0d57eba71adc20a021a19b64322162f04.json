{"sha": "41507ed0d57eba71adc20a021a19b64322162f04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNTA3ZWQwZDU3ZWJhNzFhZGMyMGEwMjFhMTliNjQzMjIxNjJmMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T11:02:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-20T11:02:36Z"}, "message": "Auto merge of #76964 - RalfJung:rollup-ybn06fs, r=RalfJung\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #76722 (Test and fix Send and Sync traits of BTreeMap artefacts)\n - #76766 (Extract some intrinsics out of rustc_codegen_llvm)\n - #76800 (Don't generate bootstrap usage unless it's needed)\n - #76809 (simplfy condition in ItemLowerer::with_trait_impl_ref())\n - #76815 (Fix wording in mir doc)\n - #76818 (Don't compile regex at every function call.)\n - #76821 (Remove redundant nightly features)\n - #76823 (black_box: silence unused_mut warning when building with cfg(miri))\n - #76825 (use `array_windows` instead of `windows` in the compiler)\n - #76827 (fix array_windows docs)\n - #76828 (use strip_prefix over starts_with and manual slicing based on pattern length (clippy::manual_strip))\n - #76840 (Move to intra doc links in core/src/future)\n - #76845 (Use intra docs links in core::{ascii, option, str, pattern, hash::map})\n - #76853 (Use intra-doc links in library/core/src/task/wake.rs)\n - #76871 (support panic=abort in Miri)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "16057bdc84087f24f271440fe9e303afc98fe235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16057bdc84087f24f271440fe9e303afc98fe235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41507ed0d57eba71adc20a021a19b64322162f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41507ed0d57eba71adc20a021a19b64322162f04", "html_url": "https://github.com/rust-lang/rust/commit/41507ed0d57eba71adc20a021a19b64322162f04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41507ed0d57eba71adc20a021a19b64322162f04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e449b9adff463455743291b0c1f76feec092992", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e449b9adff463455743291b0c1f76feec092992", "html_url": "https://github.com/rust-lang/rust/commit/5e449b9adff463455743291b0c1f76feec092992"}, {"sha": "e5be14c2721ed4f4bf8b4c5c01a68de18cfd31a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5be14c2721ed4f4bf8b4c5c01a68de18cfd31a3", "html_url": "https://github.com/rust-lang/rust/commit/e5be14c2721ed4f4bf8b4c5c01a68de18cfd31a3"}], "stats": {"total": 1559, "additions": 862, "deletions": 697}, "files": [{"sha": "6f9cccf58dd01fb165047ca8d8f5cadbd20f6a9f", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -11,7 +11,6 @@\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n     test(no_crate_inject, attr(deny(warnings)))\n )]\n-#![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(new_uninit)]\n #![feature(maybe_uninit_slice)]\n@@ -24,7 +23,6 @@ use smallvec::SmallVec;\n use std::alloc::Layout;\n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::intrinsics;\n use std::marker::{PhantomData, Send};\n use std::mem::{self, MaybeUninit};\n use std::ptr;\n@@ -122,7 +120,7 @@ impl<T> TypedArena<T> {\n \n         unsafe {\n             if mem::size_of::<T>() == 0 {\n-                self.ptr.set(intrinsics::arith_offset(self.ptr.get() as *mut u8, 1) as *mut T);\n+                self.ptr.set((self.ptr.get() as *mut u8).wrapping_offset(1) as *mut T);\n                 let ptr = mem::align_of::<T>() as *mut T;\n                 // Don't drop the object. This `write` is equivalent to `forget`.\n                 ptr::write(ptr, object);"}, {"sha": "76b84d9da83348bad7abc43cc26ea8e7cef7e16c", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -5,17 +5,13 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n-#![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(const_fn)] // For the `transmute` in `P::new`\n #![feature(const_panic)]\n-#![feature(const_fn_transmute)]\n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]\n #![feature(nll)]\n #![feature(or_patterns)]\n-#![feature(try_trait)]\n-#![feature(unicode_internals)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "617cacee0e7f1d580a2003e6b68931a632fc587b", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -27,7 +27,7 @@ pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n impl ItemLowerer<'_, '_, '_> {\n     fn with_trait_impl_ref(&mut self, impl_ref: &Option<TraitRef>, f: impl FnOnce(&mut Self)) {\n         let old = self.lctx.is_in_trait_impl;\n-        self.lctx.is_in_trait_impl = if let &None = impl_ref { false } else { true };\n+        self.lctx.is_in_trait_impl = impl_ref.is_some();\n         f(self);\n         self.lctx.is_in_trait_impl = old;\n     }"}, {"sha": "7f5b09eac4f9e0215e054bcfe42ca24abbb4702d", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 520, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -7,15 +7,12 @@ use crate::type_of::LayoutLlvmExt;\n use crate::va_arg::emit_va_arg;\n use crate::value::Value;\n \n-use rustc_ast as ast;\n use rustc_codegen_ssa::base::{compare_simd_types, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::glue;\n-use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n+use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n-use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n@@ -71,8 +68,6 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<&'ll Va\n         sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n         sym::roundf32 => \"llvm.round.f32\",\n         sym::roundf64 => \"llvm.round.f64\",\n-        sym::assume => \"llvm.assume\",\n-        sym::abort => \"llvm.trap\",\n         _ => return None,\n     };\n     Some(cx.get_intrinsic(&llvm_name))\n@@ -112,9 +107,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                 None,\n             ),\n-            sym::unreachable => {\n-                return;\n-            }\n             sym::likely => {\n                 let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n                 self.call(expect, &[args[0].immediate(), self.const_bool(true)], None)\n@@ -137,8 +129,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n-            sym::va_start => self.va_start(args[0].immediate()),\n-            sym::va_end => self.va_end(args[0].immediate()),\n             sym::va_copy => {\n                 let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n                 self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n@@ -169,123 +159,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => bug!(\"the va_arg intrinsic does not work with non-scalar types\"),\n                 }\n             }\n-            sym::size_of_val => {\n-                let tp_ty = substs.type_at(0);\n-                if let OperandValue::Pair(_, meta) = args[0].val {\n-                    let (llsize, _) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n-                    llsize\n-                } else {\n-                    self.const_usize(self.size_of(tp_ty).bytes())\n-                }\n-            }\n-            sym::min_align_of_val => {\n-                let tp_ty = substs.type_at(0);\n-                if let OperandValue::Pair(_, meta) = args[0].val {\n-                    let (_, llalign) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n-                    llalign\n-                } else {\n-                    self.const_usize(self.align_of(tp_ty).bytes())\n-                }\n-            }\n-            sym::size_of\n-            | sym::pref_align_of\n-            | sym::min_align_of\n-            | sym::needs_drop\n-            | sym::type_id\n-            | sym::type_name\n-            | sym::variant_count => {\n-                let value = self\n-                    .tcx\n-                    .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n-                    .unwrap();\n-                OperandRef::from_const(self, value, ret_ty).immediate_or_packed_pair(self)\n-            }\n-            // Effectively no-op\n-            sym::forget => {\n-                return;\n-            }\n-            sym::offset => {\n-                let ptr = args[0].immediate();\n-                let offset = args[1].immediate();\n-                self.inbounds_gep(ptr, &[offset])\n-            }\n-            sym::arith_offset => {\n-                let ptr = args[0].immediate();\n-                let offset = args[1].immediate();\n-                self.gep(ptr, &[offset])\n-            }\n-\n-            sym::copy_nonoverlapping => {\n-                copy_intrinsic(\n-                    self,\n-                    false,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::copy => {\n-                copy_intrinsic(\n-                    self,\n-                    true,\n-                    false,\n-                    substs.type_at(0),\n-                    args[1].immediate(),\n-                    args[0].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::write_bytes => {\n-                memset_intrinsic(\n-                    self,\n-                    false,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n \n-            sym::volatile_copy_nonoverlapping_memory => {\n-                copy_intrinsic(\n-                    self,\n-                    false,\n-                    true,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::volatile_copy_memory => {\n-                copy_intrinsic(\n-                    self,\n-                    true,\n-                    true,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n-            sym::volatile_set_memory => {\n-                memset_intrinsic(\n-                    self,\n-                    true,\n-                    substs.type_at(0),\n-                    args[0].immediate(),\n-                    args[1].immediate(),\n-                    args[2].immediate(),\n-                );\n-                return;\n-            }\n             sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let mut ptr = args[0].immediate();\n@@ -343,20 +217,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             | sym::ctpop\n             | sym::bswap\n             | sym::bitreverse\n-            | sym::add_with_overflow\n-            | sym::sub_with_overflow\n-            | sym::mul_with_overflow\n-            | sym::wrapping_add\n-            | sym::wrapping_sub\n-            | sym::wrapping_mul\n-            | sym::unchecked_div\n-            | sym::unchecked_rem\n-            | sym::unchecked_shl\n-            | sym::unchecked_shr\n-            | sym::unchecked_add\n-            | sym::unchecked_sub\n-            | sym::unchecked_mul\n-            | sym::exact_div\n             | sym::rotate_left\n             | sym::rotate_right\n             | sym::saturating_add\n@@ -396,84 +256,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             &[args[0].immediate()],\n                             None,\n                         ),\n-                        sym::add_with_overflow\n-                        | sym::sub_with_overflow\n-                        | sym::mul_with_overflow => {\n-                            let intrinsic = format!(\n-                                \"llvm.{}{}.with.overflow.i{}\",\n-                                if signed { 's' } else { 'u' },\n-                                &name_str[..3],\n-                                width\n-                            );\n-                            let llfn = self.get_intrinsic(&intrinsic);\n-\n-                            // Convert `i1` to a `bool`, and write it to the out parameter\n-                            let pair =\n-                                self.call(llfn, &[args[0].immediate(), args[1].immediate()], None);\n-                            let val = self.extract_value(pair, 0);\n-                            let overflow = self.extract_value(pair, 1);\n-                            let overflow = self.zext(overflow, self.type_bool());\n-\n-                            let dest = result.project_field(self, 0);\n-                            self.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(self, 1);\n-                            self.store(overflow, dest.llval, dest.align);\n-\n-                            return;\n-                        }\n-                        sym::wrapping_add => self.add(args[0].immediate(), args[1].immediate()),\n-                        sym::wrapping_sub => self.sub(args[0].immediate(), args[1].immediate()),\n-                        sym::wrapping_mul => self.mul(args[0].immediate(), args[1].immediate()),\n-                        sym::exact_div => {\n-                            if signed {\n-                                self.exactsdiv(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.exactudiv(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_div => {\n-                            if signed {\n-                                self.sdiv(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.udiv(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_rem => {\n-                            if signed {\n-                                self.srem(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.urem(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_shl => self.shl(args[0].immediate(), args[1].immediate()),\n-                        sym::unchecked_shr => {\n-                            if signed {\n-                                self.ashr(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.lshr(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_add => {\n-                            if signed {\n-                                self.unchecked_sadd(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.unchecked_uadd(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_sub => {\n-                            if signed {\n-                                self.unchecked_ssub(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.unchecked_usub(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n-                        sym::unchecked_mul => {\n-                            if signed {\n-                                self.unchecked_smul(args[0].immediate(), args[1].immediate())\n-                            } else {\n-                                self.unchecked_umul(args[0].immediate(), args[1].immediate())\n-                            }\n-                        }\n                         sym::rotate_left | sym::rotate_right => {\n                             let is_left = name == sym::rotate_left;\n                             let val = args[0].immediate();\n@@ -513,250 +295,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     }\n                 }\n             }\n-            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n-                match float_type_width(arg_tys[0]) {\n-                    Some(_width) => match name {\n-                        sym::fadd_fast => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::fsub_fast => self.fsub_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::fmul_fast => self.fmul_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::fdiv_fast => self.fdiv_fast(args[0].immediate(), args[1].immediate()),\n-                        sym::frem_fast => self.frem_fast(args[0].immediate(), args[1].immediate()),\n-                        _ => bug!(),\n-                    },\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic float type, found `{}`\",\n-                                name, arg_tys[0]\n-                            ),\n-                        );\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            sym::float_to_int_unchecked => {\n-                if float_type_width(arg_tys[0]).is_none() {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                  intrinsic: expected basic float type, \\\n-                                  found `{}`\",\n-                            arg_tys[0]\n-                        ),\n-                    );\n-                    return;\n-                }\n-                let (width, signed) = match int_type_width_signed(ret_ty, self.cx) {\n-                    Some(pair) => pair,\n-                    None => {\n-                        span_invalid_monomorphization_error(\n-                            tcx.sess,\n-                            span,\n-                            &format!(\n-                                \"invalid monomorphization of `float_to_int_unchecked` \\\n-                                      intrinsic:  expected basic integer type, \\\n-                                      found `{}`\",\n-                                ret_ty\n-                            ),\n-                        );\n-                        return;\n-                    }\n-                };\n-                if signed {\n-                    self.fptosi(args[0].immediate(), self.cx.type_ix(width))\n-                } else {\n-                    self.fptoui(args[0].immediate(), self.cx.type_ix(width))\n-                }\n-            }\n-\n-            sym::discriminant_value => {\n-                if ret_ty.is_integral() {\n-                    args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n-                } else {\n-                    span_bug!(span, \"Invalid discriminant type for `{:?}`\", arg_tys[0])\n-                }\n-            }\n \n             _ if name_str.starts_with(\"simd_\") => {\n                 match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                     Ok(llval) => llval,\n                     Err(()) => return,\n                 }\n             }\n-            // This requires that atomic intrinsics follow a specific naming pattern:\n-            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-            name if name_str.starts_with(\"atomic_\") => {\n-                use rustc_codegen_ssa::common::AtomicOrdering::*;\n-                use rustc_codegen_ssa::common::{AtomicRmwBinOp, SynchronizationScope};\n-\n-                let split: Vec<&str> = name_str.split('_').collect();\n-\n-                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n-                let (order, failorder) = match split.len() {\n-                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n-                    3 => match split[2] {\n-                        \"unordered\" => (Unordered, Unordered),\n-                        \"relaxed\" => (Monotonic, Monotonic),\n-                        \"acq\" => (Acquire, Acquire),\n-                        \"rel\" => (Release, Monotonic),\n-                        \"acqrel\" => (AcquireRelease, Acquire),\n-                        \"failrelaxed\" if is_cxchg => (SequentiallyConsistent, Monotonic),\n-                        \"failacq\" if is_cxchg => (SequentiallyConsistent, Acquire),\n-                        _ => self.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    4 => match (split[2], split[3]) {\n-                        (\"acq\", \"failrelaxed\") if is_cxchg => (Acquire, Monotonic),\n-                        (\"acqrel\", \"failrelaxed\") if is_cxchg => (AcquireRelease, Monotonic),\n-                        _ => self.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n-                    },\n-                    _ => self.sess().fatal(\"Atomic intrinsic not in correct format\"),\n-                };\n-\n-                let invalid_monomorphization = |ty| {\n-                    span_invalid_monomorphization_error(\n-                        tcx.sess,\n-                        span,\n-                        &format!(\n-                            \"invalid monomorphization of `{}` intrinsic: \\\n-                                  expected basic integer type, found `{}`\",\n-                            name, ty\n-                        ),\n-                    );\n-                };\n-\n-                match split[1] {\n-                    \"cxchg\" | \"cxchgweak\" => {\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            let weak = split[1] == \"cxchgweak\";\n-                            let pair = self.atomic_cmpxchg(\n-                                args[0].immediate(),\n-                                args[1].immediate(),\n-                                args[2].immediate(),\n-                                order,\n-                                failorder,\n-                                weak,\n-                            );\n-                            let val = self.extract_value(pair, 0);\n-                            let success = self.extract_value(pair, 1);\n-                            let success = self.zext(success, self.type_bool());\n-\n-                            let dest = result.project_field(self, 0);\n-                            self.store(val, dest.llval, dest.align);\n-                            let dest = result.project_field(self, 1);\n-                            self.store(success, dest.llval, dest.align);\n-                            return;\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-\n-                    \"load\" => {\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            let size = self.size_of(ty);\n-                            self.atomic_load(args[0].immediate(), order, size)\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-\n-                    \"store\" => {\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            let size = self.size_of(ty);\n-                            self.atomic_store(\n-                                args[1].immediate(),\n-                                args[0].immediate(),\n-                                order,\n-                                size,\n-                            );\n-                            return;\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-\n-                    \"fence\" => {\n-                        self.atomic_fence(order, SynchronizationScope::CrossThread);\n-                        return;\n-                    }\n-\n-                    \"singlethreadfence\" => {\n-                        self.atomic_fence(order, SynchronizationScope::SingleThread);\n-                        return;\n-                    }\n-\n-                    // These are all AtomicRMW ops\n-                    op => {\n-                        let atom_op = match op {\n-                            \"xchg\" => AtomicRmwBinOp::AtomicXchg,\n-                            \"xadd\" => AtomicRmwBinOp::AtomicAdd,\n-                            \"xsub\" => AtomicRmwBinOp::AtomicSub,\n-                            \"and\" => AtomicRmwBinOp::AtomicAnd,\n-                            \"nand\" => AtomicRmwBinOp::AtomicNand,\n-                            \"or\" => AtomicRmwBinOp::AtomicOr,\n-                            \"xor\" => AtomicRmwBinOp::AtomicXor,\n-                            \"max\" => AtomicRmwBinOp::AtomicMax,\n-                            \"min\" => AtomicRmwBinOp::AtomicMin,\n-                            \"umax\" => AtomicRmwBinOp::AtomicUMax,\n-                            \"umin\" => AtomicRmwBinOp::AtomicUMin,\n-                            _ => self.sess().fatal(\"unknown atomic operation\"),\n-                        };\n-\n-                        let ty = substs.type_at(0);\n-                        if int_type_width_signed(ty, self).is_some() {\n-                            self.atomic_rmw(\n-                                atom_op,\n-                                args[0].immediate(),\n-                                args[1].immediate(),\n-                                order,\n-                            )\n-                        } else {\n-                            return invalid_monomorphization(ty);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            sym::nontemporal_store => {\n-                let dst = args[0].deref(self.cx());\n-                args[1].val.nontemporal_store(self, dst);\n-                return;\n-            }\n-\n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = args[0].immediate();\n-                let b = args[1].immediate();\n-                if name == sym::ptr_guaranteed_eq {\n-                    self.icmp(IntPredicate::IntEQ, a, b)\n-                } else {\n-                    self.icmp(IntPredicate::IntNE, a, b)\n-                }\n-            }\n-\n-            sym::ptr_offset_from => {\n-                let ty = substs.type_at(0);\n-                let pointee_size = self.size_of(ty);\n-\n-                // This is the same sequence that Clang emits for pointer subtraction.\n-                // It can be neither `nsw` nor `nuw` because the input is treated as\n-                // unsigned but then the output is treated as signed, so neither works.\n-                let a = args[0].immediate();\n-                let b = args[1].immediate();\n-                let a = self.ptrtoint(a, self.type_isize());\n-                let b = self.ptrtoint(b, self.type_isize());\n-                let d = self.sub(a, b);\n-                let pointee_size = self.const_usize(pointee_size.bytes());\n-                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n-                self.exactsdiv(d, pointee_size)\n-            }\n \n             _ => bug!(\"unknown intrinsic '{}'\", name),\n         };\n@@ -807,39 +352,6 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n }\n \n-fn copy_intrinsic(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n-    allow_overlap: bool,\n-    volatile: bool,\n-    ty: Ty<'tcx>,\n-    dst: &'ll Value,\n-    src: &'ll Value,\n-    count: &'ll Value,\n-) {\n-    let (size, align) = bx.size_and_align_of(ty);\n-    let size = bx.mul(bx.const_usize(size.bytes()), count);\n-    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n-    if allow_overlap {\n-        bx.memmove(dst, align, src, align, size, flags);\n-    } else {\n-        bx.memcpy(dst, align, src, align, size, flags);\n-    }\n-}\n-\n-fn memset_intrinsic(\n-    bx: &mut Builder<'a, 'll, 'tcx>,\n-    volatile: bool,\n-    ty: Ty<'tcx>,\n-    dst: &'ll Value,\n-    val: &'ll Value,\n-    count: &'ll Value,\n-) {\n-    let (size, align) = bx.size_and_align_of(ty);\n-    let size = bx.mul(bx.const_usize(size.bytes()), count);\n-    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n-    bx.memset(dst, val, size, align, flags);\n-}\n-\n fn try_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n     try_func: &'ll Value,\n@@ -2205,37 +1717,12 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n // stuffs.\n fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n     match ty.kind() {\n-        ty::Int(t) => Some((\n-            match t {\n-                ast::IntTy::Isize => u64::from(cx.tcx.sess.target.ptr_width),\n-                ast::IntTy::I8 => 8,\n-                ast::IntTy::I16 => 16,\n-                ast::IntTy::I32 => 32,\n-                ast::IntTy::I64 => 64,\n-                ast::IntTy::I128 => 128,\n-            },\n-            true,\n-        )),\n-        ty::Uint(t) => Some((\n-            match t {\n-                ast::UintTy::Usize => u64::from(cx.tcx.sess.target.ptr_width),\n-                ast::UintTy::U8 => 8,\n-                ast::UintTy::U16 => 16,\n-                ast::UintTy::U32 => 32,\n-                ast::UintTy::U64 => 64,\n-                ast::UintTy::U128 => 128,\n-            },\n-            false,\n-        )),\n-        _ => None,\n-    }\n-}\n-\n-// Returns the width of a float Ty\n-// Returns None if the type is not a float\n-fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n-    match ty.kind() {\n-        ty::Float(t) => Some(t.bit_width()),\n+        ty::Int(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), true))\n+        }\n+        ty::Uint(t) => {\n+            Some((t.bit_width().unwrap_or(u64::from(cx.tcx.sess.target.ptr_width)), false))\n+        }\n         _ => None,\n     }\n }"}, {"sha": "a87ce1446ba140f5a094478fa714df12a2d310e8", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -8,8 +8,6 @@\n #![feature(or_patterns)]\n #![feature(trusted_len)]\n #![feature(associated_type_bounds)]\n-#![feature(const_fn)] // for rustc_index::newtype_index\n-#![feature(const_panic)] // for rustc_index::newtype_index\n #![recursion_limit = \"256\"]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others)."}, {"sha": "703a17b200a345abc2fc5758c6899dfa29b14d3c", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -687,7 +687,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 })\n                 .collect();\n \n-            bx.codegen_intrinsic_call(\n+            Self::codegen_intrinsic_call(\n+                &mut bx,\n                 *instance.as_ref().unwrap(),\n                 &fn_abi,\n                 &args,"}, {"sha": "14f1ed59a67c5f1704e9f5d7a0100df80c0e80b7", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -0,0 +1,596 @@\n+use super::operand::{OperandRef, OperandValue};\n+use super::place::PlaceRef;\n+use super::FunctionCx;\n+use crate::common::{span_invalid_monomorphization_error, IntPredicate};\n+use crate::glue;\n+use crate::traits::*;\n+use crate::MemFlags;\n+\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::{sym, Span};\n+use rustc_target::abi::call::{FnAbi, PassMode};\n+\n+fn copy_intrinsic<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    allow_overlap: bool,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: Bx::Value,\n+    src: Bx::Value,\n+    count: Bx::Value,\n+) {\n+    let layout = bx.layout_of(ty);\n+    let size = layout.size;\n+    let align = layout.align.abi;\n+    let size = bx.mul(bx.const_usize(size.bytes()), count);\n+    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n+    if allow_overlap {\n+        bx.memmove(dst, align, src, align, size, flags);\n+    } else {\n+        bx.memcpy(dst, align, src, align, size, flags);\n+    }\n+}\n+\n+fn memset_intrinsic<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    volatile: bool,\n+    ty: Ty<'tcx>,\n+    dst: Bx::Value,\n+    val: Bx::Value,\n+    count: Bx::Value,\n+) {\n+    let layout = bx.layout_of(ty);\n+    let size = layout.size;\n+    let align = layout.align.abi;\n+    let size = bx.mul(bx.const_usize(size.bytes()), count);\n+    let flags = if volatile { MemFlags::VOLATILE } else { MemFlags::empty() };\n+    bx.memset(dst, val, size, align, flags);\n+}\n+\n+impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n+    pub fn codegen_intrinsic_call(\n+        bx: &mut Bx,\n+        instance: ty::Instance<'tcx>,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        args: &[OperandRef<'tcx, Bx::Value>],\n+        llresult: Bx::Value,\n+        span: Span,\n+    ) {\n+        let callee_ty = instance.ty(bx.tcx(), ty::ParamEnv::reveal_all());\n+\n+        let (def_id, substs) = match *callee_ty.kind() {\n+            ty::FnDef(def_id, substs) => (def_id, substs),\n+            _ => bug!(\"expected fn item type, found {}\", callee_ty),\n+        };\n+\n+        let sig = callee_ty.fn_sig(bx.tcx());\n+        let sig = bx.tcx().normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n+        let arg_tys = sig.inputs();\n+        let ret_ty = sig.output();\n+        let name = bx.tcx().item_name(def_id);\n+        let name_str = &*name.as_str();\n+\n+        let llret_ty = bx.backend_type(bx.layout_of(ret_ty));\n+        let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n+\n+        let llval = match name {\n+            sym::assume => {\n+                bx.assume(args[0].immediate());\n+                return;\n+            }\n+            sym::abort => {\n+                bx.abort();\n+                return;\n+            }\n+\n+            sym::unreachable => {\n+                return;\n+            }\n+            sym::va_start => bx.va_start(args[0].immediate()),\n+            sym::va_end => bx.va_end(args[0].immediate()),\n+            sym::size_of_val => {\n+                let tp_ty = substs.type_at(0);\n+                if let OperandValue::Pair(_, meta) = args[0].val {\n+                    let (llsize, _) = glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n+                    llsize\n+                } else {\n+                    bx.const_usize(bx.layout_of(tp_ty).size.bytes())\n+                }\n+            }\n+            sym::min_align_of_val => {\n+                let tp_ty = substs.type_at(0);\n+                if let OperandValue::Pair(_, meta) = args[0].val {\n+                    let (_, llalign) = glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n+                    llalign\n+                } else {\n+                    bx.const_usize(bx.layout_of(tp_ty).align.abi.bytes())\n+                }\n+            }\n+            sym::size_of\n+            | sym::pref_align_of\n+            | sym::min_align_of\n+            | sym::needs_drop\n+            | sym::type_id\n+            | sym::type_name\n+            | sym::variant_count => {\n+                let value = bx\n+                    .tcx()\n+                    .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n+                    .unwrap();\n+                OperandRef::from_const(bx, value, ret_ty).immediate_or_packed_pair(bx)\n+            }\n+            // Effectively no-op\n+            sym::forget => {\n+                return;\n+            }\n+            sym::offset => {\n+                let ptr = args[0].immediate();\n+                let offset = args[1].immediate();\n+                bx.inbounds_gep(ptr, &[offset])\n+            }\n+            sym::arith_offset => {\n+                let ptr = args[0].immediate();\n+                let offset = args[1].immediate();\n+                bx.gep(ptr, &[offset])\n+            }\n+\n+            sym::copy_nonoverlapping => {\n+                copy_intrinsic(\n+                    bx,\n+                    false,\n+                    false,\n+                    substs.type_at(0),\n+                    args[1].immediate(),\n+                    args[0].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::copy => {\n+                copy_intrinsic(\n+                    bx,\n+                    true,\n+                    false,\n+                    substs.type_at(0),\n+                    args[1].immediate(),\n+                    args[0].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::write_bytes => {\n+                memset_intrinsic(\n+                    bx,\n+                    false,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+\n+            sym::volatile_copy_nonoverlapping_memory => {\n+                copy_intrinsic(\n+                    bx,\n+                    false,\n+                    true,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::volatile_copy_memory => {\n+                copy_intrinsic(\n+                    bx,\n+                    true,\n+                    true,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::volatile_set_memory => {\n+                memset_intrinsic(\n+                    bx,\n+                    true,\n+                    substs.type_at(0),\n+                    args[0].immediate(),\n+                    args[1].immediate(),\n+                    args[2].immediate(),\n+                );\n+                return;\n+            }\n+            sym::volatile_store => {\n+                let dst = args[0].deref(bx.cx());\n+                args[1].val.volatile_store(bx, dst);\n+                return;\n+            }\n+            sym::unaligned_volatile_store => {\n+                let dst = args[0].deref(bx.cx());\n+                args[1].val.unaligned_volatile_store(bx, dst);\n+                return;\n+            }\n+            sym::add_with_overflow\n+            | sym::sub_with_overflow\n+            | sym::mul_with_overflow\n+            | sym::wrapping_add\n+            | sym::wrapping_sub\n+            | sym::wrapping_mul\n+            | sym::unchecked_div\n+            | sym::unchecked_rem\n+            | sym::unchecked_shl\n+            | sym::unchecked_shr\n+            | sym::unchecked_add\n+            | sym::unchecked_sub\n+            | sym::unchecked_mul\n+            | sym::exact_div => {\n+                let ty = arg_tys[0];\n+                match int_type_width_signed(ty, bx.tcx()) {\n+                    Some((_width, signed)) => match name {\n+                        sym::add_with_overflow\n+                        | sym::sub_with_overflow\n+                        | sym::mul_with_overflow => {\n+                            let op = match name {\n+                                sym::add_with_overflow => OverflowOp::Add,\n+                                sym::sub_with_overflow => OverflowOp::Sub,\n+                                sym::mul_with_overflow => OverflowOp::Mul,\n+                                _ => bug!(),\n+                            };\n+                            let (val, overflow) =\n+                                bx.checked_binop(op, ty, args[0].immediate(), args[1].immediate());\n+                            // Convert `i1` to a `bool`, and write it to the out parameter\n+                            let val = bx.from_immediate(val);\n+                            let overflow = bx.from_immediate(overflow);\n+\n+                            let dest = result.project_field(bx, 0);\n+                            bx.store(val, dest.llval, dest.align);\n+                            let dest = result.project_field(bx, 1);\n+                            bx.store(overflow, dest.llval, dest.align);\n+\n+                            return;\n+                        }\n+                        sym::wrapping_add => bx.add(args[0].immediate(), args[1].immediate()),\n+                        sym::wrapping_sub => bx.sub(args[0].immediate(), args[1].immediate()),\n+                        sym::wrapping_mul => bx.mul(args[0].immediate(), args[1].immediate()),\n+                        sym::exact_div => {\n+                            if signed {\n+                                bx.exactsdiv(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.exactudiv(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_div => {\n+                            if signed {\n+                                bx.sdiv(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.udiv(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_rem => {\n+                            if signed {\n+                                bx.srem(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.urem(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_shl => bx.shl(args[0].immediate(), args[1].immediate()),\n+                        sym::unchecked_shr => {\n+                            if signed {\n+                                bx.ashr(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.lshr(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_add => {\n+                            if signed {\n+                                bx.unchecked_sadd(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.unchecked_uadd(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_sub => {\n+                            if signed {\n+                                bx.unchecked_ssub(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.unchecked_usub(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        sym::unchecked_mul => {\n+                            if signed {\n+                                bx.unchecked_smul(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.unchecked_umul(args[0].immediate(), args[1].immediate())\n+                            }\n+                        }\n+                        _ => bug!(),\n+                    },\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            bx.tcx().sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic integer type, found `{}`\",\n+                                name, ty\n+                            ),\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n+                match float_type_width(arg_tys[0]) {\n+                    Some(_width) => match name {\n+                        sym::fadd_fast => bx.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fsub_fast => bx.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fmul_fast => bx.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fdiv_fast => bx.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::frem_fast => bx.frem_fast(args[0].immediate(), args[1].immediate()),\n+                        _ => bug!(),\n+                    },\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            bx.tcx().sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `{}` intrinsic: \\\n+                                      expected basic float type, found `{}`\",\n+                                name, arg_tys[0]\n+                            ),\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            sym::float_to_int_unchecked => {\n+                if float_type_width(arg_tys[0]).is_none() {\n+                    span_invalid_monomorphization_error(\n+                        bx.tcx().sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `float_to_int_unchecked` \\\n+                                  intrinsic: expected basic float type, \\\n+                                  found `{}`\",\n+                            arg_tys[0]\n+                        ),\n+                    );\n+                    return;\n+                }\n+                let (_width, signed) = match int_type_width_signed(ret_ty, bx.tcx()) {\n+                    Some(pair) => pair,\n+                    None => {\n+                        span_invalid_monomorphization_error(\n+                            bx.tcx().sess,\n+                            span,\n+                            &format!(\n+                                \"invalid monomorphization of `float_to_int_unchecked` \\\n+                                      intrinsic:  expected basic integer type, \\\n+                                      found `{}`\",\n+                                ret_ty\n+                            ),\n+                        );\n+                        return;\n+                    }\n+                };\n+                if signed {\n+                    bx.fptosi(args[0].immediate(), llret_ty)\n+                } else {\n+                    bx.fptoui(args[0].immediate(), llret_ty)\n+                }\n+            }\n+\n+            sym::discriminant_value => {\n+                if ret_ty.is_integral() {\n+                    args[0].deref(bx.cx()).codegen_get_discr(bx, ret_ty)\n+                } else {\n+                    span_bug!(span, \"Invalid discriminant type for `{:?}`\", arg_tys[0])\n+                }\n+            }\n+\n+            // This requires that atomic intrinsics follow a specific naming pattern:\n+            // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n+            name if name_str.starts_with(\"atomic_\") => {\n+                use crate::common::AtomicOrdering::*;\n+                use crate::common::{AtomicRmwBinOp, SynchronizationScope};\n+\n+                let split: Vec<&str> = name_str.split('_').collect();\n+\n+                let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n+                let (order, failorder) = match split.len() {\n+                    2 => (SequentiallyConsistent, SequentiallyConsistent),\n+                    3 => match split[2] {\n+                        \"unordered\" => (Unordered, Unordered),\n+                        \"relaxed\" => (Monotonic, Monotonic),\n+                        \"acq\" => (Acquire, Acquire),\n+                        \"rel\" => (Release, Monotonic),\n+                        \"acqrel\" => (AcquireRelease, Acquire),\n+                        \"failrelaxed\" if is_cxchg => (SequentiallyConsistent, Monotonic),\n+                        \"failacq\" if is_cxchg => (SequentiallyConsistent, Acquire),\n+                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    },\n+                    4 => match (split[2], split[3]) {\n+                        (\"acq\", \"failrelaxed\") if is_cxchg => (Acquire, Monotonic),\n+                        (\"acqrel\", \"failrelaxed\") if is_cxchg => (AcquireRelease, Monotonic),\n+                        _ => bx.sess().fatal(\"unknown ordering in atomic intrinsic\"),\n+                    },\n+                    _ => bx.sess().fatal(\"Atomic intrinsic not in correct format\"),\n+                };\n+\n+                let invalid_monomorphization = |ty| {\n+                    span_invalid_monomorphization_error(\n+                        bx.tcx().sess,\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `{}` intrinsic: \\\n+                                  expected basic integer type, found `{}`\",\n+                            name, ty\n+                        ),\n+                    );\n+                };\n+\n+                match split[1] {\n+                    \"cxchg\" | \"cxchgweak\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            let weak = split[1] == \"cxchgweak\";\n+                            let pair = bx.atomic_cmpxchg(\n+                                args[0].immediate(),\n+                                args[1].immediate(),\n+                                args[2].immediate(),\n+                                order,\n+                                failorder,\n+                                weak,\n+                            );\n+                            let val = bx.extract_value(pair, 0);\n+                            let success = bx.extract_value(pair, 1);\n+                            let val = bx.from_immediate(val);\n+                            let success = bx.from_immediate(success);\n+\n+                            let dest = result.project_field(bx, 0);\n+                            bx.store(val, dest.llval, dest.align);\n+                            let dest = result.project_field(bx, 1);\n+                            bx.store(success, dest.llval, dest.align);\n+                            return;\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+\n+                    \"load\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            let size = bx.layout_of(ty).size;\n+                            bx.atomic_load(args[0].immediate(), order, size)\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+\n+                    \"store\" => {\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            let size = bx.layout_of(ty).size;\n+                            bx.atomic_store(args[1].immediate(), args[0].immediate(), order, size);\n+                            return;\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+\n+                    \"fence\" => {\n+                        bx.atomic_fence(order, SynchronizationScope::CrossThread);\n+                        return;\n+                    }\n+\n+                    \"singlethreadfence\" => {\n+                        bx.atomic_fence(order, SynchronizationScope::SingleThread);\n+                        return;\n+                    }\n+\n+                    // These are all AtomicRMW ops\n+                    op => {\n+                        let atom_op = match op {\n+                            \"xchg\" => AtomicRmwBinOp::AtomicXchg,\n+                            \"xadd\" => AtomicRmwBinOp::AtomicAdd,\n+                            \"xsub\" => AtomicRmwBinOp::AtomicSub,\n+                            \"and\" => AtomicRmwBinOp::AtomicAnd,\n+                            \"nand\" => AtomicRmwBinOp::AtomicNand,\n+                            \"or\" => AtomicRmwBinOp::AtomicOr,\n+                            \"xor\" => AtomicRmwBinOp::AtomicXor,\n+                            \"max\" => AtomicRmwBinOp::AtomicMax,\n+                            \"min\" => AtomicRmwBinOp::AtomicMin,\n+                            \"umax\" => AtomicRmwBinOp::AtomicUMax,\n+                            \"umin\" => AtomicRmwBinOp::AtomicUMin,\n+                            _ => bx.sess().fatal(\"unknown atomic operation\"),\n+                        };\n+\n+                        let ty = substs.type_at(0);\n+                        if int_type_width_signed(ty, bx.tcx()).is_some() {\n+                            bx.atomic_rmw(atom_op, args[0].immediate(), args[1].immediate(), order)\n+                        } else {\n+                            return invalid_monomorphization(ty);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            sym::nontemporal_store => {\n+                let dst = args[0].deref(bx.cx());\n+                args[1].val.nontemporal_store(bx, dst);\n+                return;\n+            }\n+\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                if name == sym::ptr_guaranteed_eq {\n+                    bx.icmp(IntPredicate::IntEQ, a, b)\n+                } else {\n+                    bx.icmp(IntPredicate::IntNE, a, b)\n+                }\n+            }\n+\n+            sym::ptr_offset_from => {\n+                let ty = substs.type_at(0);\n+                let pointee_size = bx.layout_of(ty).size;\n+\n+                // This is the same sequence that Clang emits for pointer subtraction.\n+                // It can be neither `nsw` nor `nuw` because the input is treated as\n+                // unsigned but then the output is treated as signed, so neither works.\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                let a = bx.ptrtoint(a, bx.type_isize());\n+                let b = bx.ptrtoint(b, bx.type_isize());\n+                let d = bx.sub(a, b);\n+                let pointee_size = bx.const_usize(pointee_size.bytes());\n+                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n+                bx.exactsdiv(d, pointee_size)\n+            }\n+\n+            _ => {\n+                // Need to use backend-specific things in the implementation.\n+                bx.codegen_intrinsic_call(instance, fn_abi, args, llresult, span);\n+                return;\n+            }\n+        };\n+\n+        if !fn_abi.ret.is_ignore() {\n+            if let PassMode::Cast(ty) = fn_abi.ret.mode {\n+                let ptr_llty = bx.type_ptr_to(bx.cast_backend_type(&ty));\n+                let ptr = bx.pointercast(result.llval, ptr_llty);\n+                bx.store(llval, ptr, result.align);\n+            } else {\n+                OperandRef::from_immediate_or_packed_pair(bx, llval, result.layout)\n+                    .val\n+                    .store(bx, result);\n+            }\n+        }\n+    }\n+}\n+\n+// Returns the width of an int Ty, and if it's signed or not\n+// Returns None if the type is not an integer\n+// FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n+// stuffs.\n+fn int_type_width_signed(ty: Ty<'_>, tcx: TyCtxt<'_>) -> Option<(u64, bool)> {\n+    match ty.kind() {\n+        ty::Int(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), true)),\n+        ty::Uint(t) => Some((t.bit_width().unwrap_or(u64::from(tcx.sess.target.ptr_width)), false)),\n+        _ => None,\n+    }\n+}\n+\n+// Returns the width of a float Ty\n+// Returns None if the type is not a float\n+fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n+    match ty.kind() {\n+        ty::Float(t) => Some(t.bit_width()),\n+        _ => None,\n+    }\n+}"}, {"sha": "64d456fb7aa67b8dd6afb816e61d215eb31873a2", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -486,6 +486,7 @@ mod block;\n pub mod constant;\n pub mod coverageinfo;\n pub mod debuginfo;\n+mod intrinsic;\n pub mod operand;\n pub mod place;\n mod rvalue;"}, {"sha": "8dafcdf3bc6b7cc956d4762f577d68a49600096d", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -8,10 +8,10 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![allow(incomplete_features)]\n+#![feature(array_windows)]\n #![feature(control_flow_enum)]\n #![feature(in_band_lifetimes)]\n #![feature(unboxed_closures)]\n-#![feature(generators)]\n #![feature(generator_trait)]\n #![feature(fn_traits)]\n #![feature(int_bits_const)]\n@@ -27,7 +27,7 @@\n #![feature(thread_id_value)]\n #![feature(extend_one)]\n #![feature(const_panic)]\n-#![feature(const_generics)]\n+#![feature(min_const_generics)]\n #![feature(once_cell)]\n #![allow(rustc::default_hash_types)]\n "}, {"sha": "4807380595db7267446061203cf4f7c26dbaee6e", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -34,7 +34,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n     /// and that there are no duplicates.\n     #[inline]\n     pub fn from_presorted_elements(elements: Vec<(K, V)>) -> SortedMap<K, V> {\n-        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+        debug_assert!(elements.array_windows().all(|[fst, snd]| fst.0 < snd.0));\n \n         SortedMap { data: elements }\n     }\n@@ -159,7 +159,7 @@ impl<K: Ord, V> SortedMap<K, V> {\n             return;\n         }\n \n-        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+        debug_assert!(elements.array_windows().all(|[fst, snd]| fst.0 < snd.0));\n \n         let start_index = self.lookup_index_for(&elements[0].0);\n "}, {"sha": "4f2febf04b135acf54afa8009bd74a46d42a1705", "filename": "compiler/rustc_driver/src/args.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_driver%2Fsrc%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fargs.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -4,8 +4,7 @@ use std::fs;\n use std::io;\n \n pub fn arg_expand(arg: String) -> Result<Vec<String>, Error> {\n-    if arg.starts_with('@') {\n-        let path = &arg[1..];\n+    if let Some(path) = arg.strip_prefix('@') {\n         let file = match fs::read_to_string(path) {\n             Ok(file) => file,\n             Err(ref err) if err.kind() == io::ErrorKind::InvalidData => {"}, {"sha": "47247294f5dc69ed5b90bc18d5695ad5d8f39fd1", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1,5 +1,4 @@\n #![feature(bool_to_option)]\n-#![feature(cow_is_borrowed)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(or_patterns)]"}, {"sha": "504b66bae7329c26594cdb9f428a85a7319dc9e5", "filename": "compiler/rustc_infer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_infer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -13,7 +13,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![feature(bindings_after_at)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n@@ -23,7 +22,6 @@\n #![feature(never_type)]\n #![feature(or_patterns)]\n #![feature(in_band_lifetimes)]\n-#![feature(crate_visibility_modifier)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]"}, {"sha": "b48592c103ca2d71deb6e5baba9c6cfae43b0246", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -27,6 +27,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(test, feature(test))]\n+#![feature(array_windows)]\n #![feature(bool_to_option)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "b3125f55d4d6e4b4d054cc627236d0b61557023e", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -70,9 +70,9 @@ fn is_camel_case(name: &str) -> bool {\n     // ones (some scripts don't have a concept of upper/lowercase)\n     !name.chars().next().unwrap().is_lowercase()\n         && !name.contains(\"__\")\n-        && !name.chars().collect::<Vec<_>>().windows(2).any(|pair| {\n+        && !name.chars().collect::<Vec<_>>().array_windows().any(|&[fst, snd]| {\n             // contains a capitalisable character followed by, or preceded by, an underscore\n-            char_has_case(pair[0]) && pair[1] == '_' || char_has_case(pair[1]) && pair[0] == '_'\n+            char_has_case(fst) && snd == '_' || char_has_case(snd) && fst == '_'\n         })\n }\n "}, {"sha": "74cb3c130b7f087962427b8ff25012589847765f", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -23,33 +23,29 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(array_windows)]\n #![feature(backtrace)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cmp_min_max_by)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n-#![feature(const_fn_transmute)]\n #![feature(core_intrinsics)]\n #![feature(discriminant_kind)]\n-#![feature(drain_filter)]\n #![feature(never_type)]\n-#![feature(exhaustive_patterns)]\n #![feature(extern_types)]\n #![feature(nll)]\n #![feature(once_cell)]\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n-#![feature(stmt_expr_attributes)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]\n-#![feature(hash_raw_entry)]\n #![feature(int_error_matching)]\n #![recursion_limit = \"512\"]\n "}, {"sha": "12dc1c12264491316122996631b2b1423198c2e2", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -2286,7 +2286,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n /// Constants\n ///\n /// Two constants are equal if they are the same constant. Note that\n-/// this does not necessarily mean that they are `==` in Rust -- in\n+/// this does not necessarily mean that they are `==` in Rust. In\n /// particular, one must be wary of `NaN`!\n \n #[derive(Clone, Copy, PartialEq, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "38c0441990b2573634566aa2f09cb8be9479809a", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -2419,7 +2419,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         eps: &[ExistentialPredicate<'tcx>],\n     ) -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n-        assert!(eps.windows(2).all(|w| w[0].stable_cmp(self, &w[1]) != Ordering::Greater));\n+        assert!(eps.array_windows().all(|[a, b]| a.stable_cmp(self, b) != Ordering::Greater));\n         self._intern_existential_predicates(eps)\n     }\n "}, {"sha": "629e9be9ddd45f57d9932f253d3f0fecf4902c51", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -492,8 +492,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             {\n                 if let Ok(pat_snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(pat_span)\n                 {\n-                    if pat_snippet.starts_with('&') {\n-                        let pat_snippet = pat_snippet[1..].trim_start();\n+                    if let Some(stripped) = pat_snippet.strip_prefix('&') {\n+                        let pat_snippet = stripped.trim_start();\n                         let (suggestion, to_remove) = if pat_snippet.starts_with(\"mut\")\n                             && pat_snippet[\"mut\".len()..].starts_with(rustc_lexer::is_whitespace)\n                         {"}, {"sha": "d4cdf02104ace23c088bfe61d14847c15bfaa43f", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -631,9 +631,8 @@ fn suggest_ampmut<'tcx>(\n                 let lt_name = &src[1..ws_pos];\n                 let ty = &src[ws_pos..];\n                 return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n-            } else if src.starts_with('&') {\n-                let borrowed_expr = &src[1..];\n-                return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n+            } else if let Some(stripped) = src.strip_prefix('&') {\n+                return (assignment_rhs_span, format!(\"&mut {}\", stripped));\n             }\n         }\n     }"}, {"sha": "5d4c4251961d20df3bdf7d1c71e31ef3eafae90f", "filename": "compiler/rustc_mir/src/dataflow/framework/graphviz.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1,6 +1,7 @@\n //! A helpful diagram for debugging dataflow problems.\n \n use std::borrow::Cow;\n+use std::lazy::SyncOnceCell;\n use std::{io, ops, str};\n \n use regex::Regex;\n@@ -570,6 +571,13 @@ where\n     }\n }\n \n+macro_rules! regex {\n+    ($re:literal $(,)?) => {{\n+        static RE: SyncOnceCell<regex::Regex> = SyncOnceCell::new();\n+        RE.get_or_init(|| Regex::new($re).unwrap())\n+    }};\n+}\n+\n fn diff_pretty<T, C>(new: T, old: T, ctxt: &C) -> String\n where\n     T: DebugWithContext<C>,\n@@ -578,7 +586,7 @@ where\n         return String::new();\n     }\n \n-    let re = Regex::new(\"\\t?\\u{001f}([+-])\").unwrap();\n+    let re = regex!(\"\\t?\\u{001f}([+-])\");\n \n     let raw_diff = format!(\"{:#?}\", DebugDiffWithAdapter { new, old, ctxt });\n "}, {"sha": "a356ae1709deb64a2f74cfe8aad60f11ae8516b8", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -6,6 +6,7 @@ Rust MIR: a lowered representation of Rust.\n \n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n+#![feature(array_windows)]\n #![feature(bindings_after_at)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n@@ -14,20 +15,18 @@ Rust MIR: a lowered representation of Rust.\n #![feature(const_panic)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n-#![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n-#![feature(iter_order_by)]\n #![feature(never_type)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n-#![feature(associated_type_bounds)]\n #![feature(associated_type_defaults)]\n #![feature(stmt_expr_attributes)]\n #![feature(trait_alias)]\n #![feature(option_expect_none)]\n #![feature(or_patterns)]\n+#![feature(once_cell)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "db6d3b2d912d693aa640358abe69eaf54720c1fa", "filename": "compiler/rustc_mir/src/monomorphize/partitioning/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpartitioning%2Fmod.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -277,14 +277,8 @@ where\n \n     symbols.sort_by_key(|sym| sym.1);\n \n-    for pair in symbols.windows(2) {\n-        let sym1 = &pair[0].1;\n-        let sym2 = &pair[1].1;\n-\n+    for &[(mono_item1, ref sym1), (mono_item2, ref sym2)] in symbols.array_windows() {\n         if sym1 == sym2 {\n-            let mono_item1 = pair[0].0;\n-            let mono_item2 = pair[1].0;\n-\n             let span1 = mono_item1.local_span(tcx);\n             let span2 = mono_item2.local_span(tcx);\n "}, {"sha": "714041ad4e8741df90c20ee28640030f398058ba", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1,7 +1,7 @@\n //! Construction of MIR from HIR.\n //!\n //! This crate also contains the match exhaustiveness and usefulness checking.\n-\n+#![feature(array_windows)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(const_fn)]"}, {"sha": "eddd2882406ba38cb40a586cc9873fec8f62a102", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -2299,19 +2299,19 @@ fn split_grouped_constructors<'p, 'tcx>(\n                 // interval into a constructor.\n                 split_ctors.extend(\n                     borders\n-                        .windows(2)\n-                        .filter_map(|window| match (window[0], window[1]) {\n-                            (Border::JustBefore(n), Border::JustBefore(m)) => {\n+                        .array_windows()\n+                        .filter_map(|&pair| match pair {\n+                            [Border::JustBefore(n), Border::JustBefore(m)] => {\n                                 if n < m {\n                                     Some(IntRange { range: n..=(m - 1), ty, span })\n                                 } else {\n                                     None\n                                 }\n                             }\n-                            (Border::JustBefore(n), Border::AfterMax) => {\n+                            [Border::JustBefore(n), Border::AfterMax] => {\n                                 Some(IntRange { range: n..=u128::MAX, ty, span })\n                             }\n-                            (Border::AfterMax, _) => None,\n+                            [Border::AfterMax, _] => None,\n                         })\n                         .map(IntRange),\n                 );"}, {"sha": "72a34b86ae20bbb0451f8e33ec97763b92b6cdd6", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -3,7 +3,6 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n-#![feature(try_blocks)]\n #![feature(or_patterns)]\n \n use rustc_ast as ast;"}, {"sha": "dde162681b77311f1f4923f13d3d04f55f6dda68", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -11,8 +11,6 @@\n )]\n #![feature(nll)]\n #![feature(or_patterns)]\n-#![feature(rustc_private)]\n-#![feature(unicode_internals)]\n #![feature(bool_to_option)]\n \n pub use Alignment::*;"}, {"sha": "c2de4cdbf0dd5c76e0d3f847178fddc0d3c16d48", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1,7 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;"}, {"sha": "ced272e474d1154f55576ad7b301316df9ef7caa", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1418,9 +1418,9 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n                             introduce_suggestion\n                                 .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n-                        } else if snippet.starts_with(\"&'_ \") {\n+                        } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n                             introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[4..])));\n+                                .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n                         }\n                     }\n                 }"}, {"sha": "83b737a73b1e84239a9d5ea1c33cb56e563aede7", "filename": "compiler/rustc_session/src/search_paths.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_session%2Fsrc%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_session%2Fsrc%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsearch_paths.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -56,16 +56,16 @@ impl PathKind {\n \n impl SearchPath {\n     pub fn from_cli_opt(path: &str, output: config::ErrorOutputType) -> Self {\n-        let (kind, path) = if path.starts_with(\"native=\") {\n-            (PathKind::Native, &path[\"native=\".len()..])\n-        } else if path.starts_with(\"crate=\") {\n-            (PathKind::Crate, &path[\"crate=\".len()..])\n-        } else if path.starts_with(\"dependency=\") {\n-            (PathKind::Dependency, &path[\"dependency=\".len()..])\n-        } else if path.starts_with(\"framework=\") {\n-            (PathKind::Framework, &path[\"framework=\".len()..])\n-        } else if path.starts_with(\"all=\") {\n-            (PathKind::All, &path[\"all=\".len()..])\n+        let (kind, path) = if let Some(stripped) = path.strip_prefix(\"native=\") {\n+            (PathKind::Native, stripped)\n+        } else if let Some(stripped) = path.strip_prefix(\"crate=\") {\n+            (PathKind::Crate, stripped)\n+        } else if let Some(stripped) = path.strip_prefix(\"dependency=\") {\n+            (PathKind::Dependency, stripped)\n+        } else if let Some(stripped) = path.strip_prefix(\"framework=\") {\n+            (PathKind::Framework, stripped)\n+        } else if let Some(stripped) = path.strip_prefix(\"all=\") {\n+            (PathKind::All, stripped)\n         } else {\n             (PathKind::All, path)\n         };"}, {"sha": "a730c30378827e328ae8f5c5106e9e5da5f3d3ab", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -5,15 +5,14 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(array_windows)]\n #![feature(crate_visibility_modifier)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(negative_impls)]\n #![feature(nll)]\n-#![feature(optin_builtin_traits)]\n #![feature(min_specialization)]\n #![feature(option_expect_none)]\n-#![feature(refcell_take)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -1158,7 +1157,12 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n                     let max_line_length = if lines.len() == 1 {\n                         0\n                     } else {\n-                        lines.windows(2).map(|w| w[1] - w[0]).map(|bp| bp.to_usize()).max().unwrap()\n+                        lines\n+                            .array_windows()\n+                            .map(|&[fst, snd]| snd - fst)\n+                            .map(|bp| bp.to_usize())\n+                            .max()\n+                            .unwrap()\n                     };\n \n                     let bytes_per_diff: u8 = match max_line_length {\n@@ -1173,7 +1177,7 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n                     // Encode the first element.\n                     lines[0].encode(s)?;\n \n-                    let diff_iter = (&lines[..]).windows(2).map(|w| (w[1] - w[0]));\n+                    let diff_iter = lines[..].array_windows().map(|&[fst, snd]| snd - fst);\n \n                     match bytes_per_diff {\n                         1 => {"}, {"sha": "d0b05beb4e63c86ee9ea23d25931a4a5c715acfc", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -4,7 +4,6 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "8dd6aa3c7fcc1da74fecf7dd8e88416f1227d66e", "filename": "compiler/rustc_ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-#![feature(bool_to_option)]\n #![feature(nll)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "c7ce5008c335405ba45d50e0c18ec5b4b53c2305", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -370,7 +370,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let s = s.as_ref();\n         let old = old.as_ref();\n-        if s.starts_with(old) { Some(new.as_ref().to_owned() + &s[old.len()..]) } else { None }\n+        if let Some(stripped) = s.strip_prefix(old) {\n+            Some(new.as_ref().to_owned() + stripped)\n+        } else {\n+            None\n+        }\n     }\n \n     /// This function is used to determine potential \"simple\" improvements or users' errors and"}, {"sha": "66975f32a1f4ad6fe873ca268c264a21cbd15782", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -589,10 +589,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 } else {\n                                     msg\n                                 },\n-                                if lstring.starts_with('&') {\n+                                if let Some(stripped) = lstring.strip_prefix('&') {\n                                     // let a = String::new();\n                                     // let _ = &a + \"bar\";\n-                                    lstring[1..].to_string()\n+                                    stripped.to_string()\n                                 } else {\n                                     format!(\"{}.to_owned()\", lstring)\n                                 },\n@@ -617,10 +617,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     is_assign,\n                 ) {\n                     (Ok(l), Ok(r), IsAssign::No) => {\n-                        let to_string = if l.starts_with('&') {\n+                        let to_string = if let Some(stripped) = l.strip_prefix('&') {\n                             // let a = String::new(); let b = String::new();\n                             // let _ = &a + b;\n-                            l[1..].to_string()\n+                            stripped.to_string()\n                         } else {\n                             format!(\"{}.to_owned()\", l)\n                         };"}, {"sha": "f5418c9e01e4928a0a6f1d86f398e4be369bfba3", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -2343,8 +2343,8 @@ fn from_target_feature(\n                         item.span(),\n                         format!(\"`{}` is not valid for this target\", feature),\n                     );\n-                    if feature.starts_with('+') {\n-                        let valid = supported_target_features.contains_key(&feature[1..]);\n+                    if let Some(stripped) = feature.strip_prefix('+') {\n+                        let valid = supported_target_features.contains_key(stripped);\n                         if valid {\n                             err.help(\"consider removing the leading `+` in the feature name\");\n                         }"}, {"sha": "016f139a501a00da5749e941e4c1d47df2fdaccb", "filename": "library/alloc/src/collections/btree/borrow.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fborrow.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -16,6 +16,9 @@ pub struct DormantMutRef<'a, T> {\n     _marker: PhantomData<&'a mut T>,\n }\n \n+unsafe impl<'a, T> Sync for DormantMutRef<'a, T> where &'a mut T: Sync {}\n+unsafe impl<'a, T> Send for DormantMutRef<'a, T> where &'a mut T: Send {}\n+\n impl<'a, T> DormantMutRef<'a, T> {\n     /// Capture a unique borrow, and immediately reborrow it. For the compiler,\n     /// the lifetime of the new reference is the same as the lifetime of the"}, {"sha": "d2cd6b8e5241ad7e2fbd7dc0ee469eb7bd7826aa", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1418,6 +1418,146 @@ fn test_variance() {\n     }\n }\n \n+#[test]\n+#[allow(dead_code)]\n+fn test_sync() {\n+    fn map<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v\n+    }\n+\n+    fn into_iter<T: Sync>(v: BTreeMap<T, T>) -> impl Sync {\n+        v.into_iter()\n+    }\n+\n+    fn into_keys<T: Sync + Ord>(v: BTreeMap<T, T>) -> impl Sync {\n+        v.into_keys()\n+    }\n+\n+    fn into_values<T: Sync + Ord>(v: BTreeMap<T, T>) -> impl Sync {\n+        v.into_values()\n+    }\n+\n+    fn drain_filter<T: Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.drain_filter(|_, _| false)\n+    }\n+\n+    fn iter<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.iter()\n+    }\n+\n+    fn iter_mut<T: Sync>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.iter_mut()\n+    }\n+\n+    fn keys<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.keys()\n+    }\n+\n+    fn values<T: Sync>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.values()\n+    }\n+\n+    fn values_mut<T: Sync>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.values_mut()\n+    }\n+\n+    fn range<T: Sync + Ord>(v: &BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.range(..)\n+    }\n+\n+    fn range_mut<T: Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.range_mut(..)\n+    }\n+\n+    fn entry<T: Sync + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        v.entry(Default::default())\n+    }\n+\n+    fn occupied_entry<T: Sync + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        match v.entry(Default::default()) {\n+            Occupied(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn vacant_entry<T: Sync + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Sync + '_ {\n+        match v.entry(Default::default()) {\n+            Vacant(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[test]\n+#[allow(dead_code)]\n+fn test_send() {\n+    fn map<T: Send>(v: BTreeMap<T, T>) -> impl Send {\n+        v\n+    }\n+\n+    fn into_iter<T: Send>(v: BTreeMap<T, T>) -> impl Send {\n+        v.into_iter()\n+    }\n+\n+    fn into_keys<T: Send + Ord>(v: BTreeMap<T, T>) -> impl Send {\n+        v.into_keys()\n+    }\n+\n+    fn into_values<T: Send + Ord>(v: BTreeMap<T, T>) -> impl Send {\n+        v.into_values()\n+    }\n+\n+    fn drain_filter<T: Send + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.drain_filter(|_, _| false)\n+    }\n+\n+    fn iter<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.iter()\n+    }\n+\n+    fn iter_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.iter_mut()\n+    }\n+\n+    fn keys<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.keys()\n+    }\n+\n+    fn values<T: Send + Sync>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.values()\n+    }\n+\n+    fn values_mut<T: Send + Sync>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.values_mut()\n+    }\n+\n+    fn range<T: Send + Sync + Ord>(v: &BTreeMap<T, T>) -> impl Send + '_ {\n+        v.range(..)\n+    }\n+\n+    fn range_mut<T: Send + Sync + Ord>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.range_mut(..)\n+    }\n+\n+    fn entry<T: Send + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        v.entry(Default::default())\n+    }\n+\n+    fn occupied_entry<T: Send + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        match v.entry(Default::default()) {\n+            Occupied(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    fn vacant_entry<T: Send + Ord + Default>(v: &mut BTreeMap<T, T>) -> impl Send + '_ {\n+        match v.entry(Default::default()) {\n+            Vacant(entry) => entry,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n #[test]\n fn test_occupied_entry_key() {\n     let mut a = BTreeMap::new();"}, {"sha": "a8a25f927163cd33a63ef4c1ba9194570febc65c", "filename": "library/core/src/ascii.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fascii.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -6,8 +6,6 @@\n //!\n //! The [`escape_default`] function provides an iterator over the bytes of an\n //! escaped version of the character given.\n-//!\n-//! [`escape_default`]: fn.escape_default.html\n \n #![stable(feature = \"core_ascii\", since = \"1.26.0\")]\n \n@@ -20,8 +18,6 @@ use crate::str::from_utf8_unchecked;\n ///\n /// This `struct` is created by the [`escape_default`] function. See its\n /// documentation for more.\n-///\n-/// [`escape_default`]: fn.escape_default.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct EscapeDefault {"}, {"sha": "ab162638a1cfe24d2fb257bd0fe8850883c7e3f2", "filename": "library/core/src/future/pending.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ffuture%2Fpending.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ffuture%2Fpending.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fpending.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -7,10 +7,8 @@ use crate::task::{Context, Poll};\n /// Creates a future which never resolves, representing a computation that never\n /// finishes.\n ///\n-/// This `struct` is created by the [`pending`] function. See its\n+/// This `struct` is created by [`pending()`]. See its\n /// documentation for more.\n-///\n-/// [`pending`]: fn.pending.html\n #[stable(feature = \"future_readiness_fns\", since = \"1.48.0\")]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n pub struct Pending<T> {"}, {"sha": "f302cda09e721166e2d6929402d46e621aa5db4c", "filename": "library/core/src/future/poll_fn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ffuture%2Fpoll_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ffuture%2Fpoll_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fpoll_fn.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -33,10 +33,8 @@ where\n \n /// A Future that wraps a function returning `Poll`.\n ///\n-/// This `struct` is created by the [`poll_fn`] function. See its\n+/// This `struct` is created by [`poll_fn()`]. See its\n /// documentation for more.\n-///\n-/// [`poll_fn`]: fn.poll_fn.html\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]\n #[unstable(feature = \"future_poll_fn\", issue = \"72302\")]\n pub struct PollFn<F> {"}, {"sha": "e98f5c570bf3cb70a5e5ce814acab0146817d917", "filename": "library/core/src/future/ready.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ffuture%2Fready.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ffuture%2Fready.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fready.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -4,10 +4,8 @@ use crate::task::{Context, Poll};\n \n /// Creates a future that is immediately ready with a value.\n ///\n-/// This `struct` is created by the [`ready`] function. See its\n+/// This `struct` is created by [`ready()`]. See its\n /// documentation for more.\n-///\n-/// [`ready`]: fn.ready.html\n #[stable(feature = \"future_readiness_fns\", since = \"1.48.0\")]\n #[derive(Debug, Clone)]\n #[must_use = \"futures do nothing unless you `.await` or poll them\"]"}, {"sha": "4eb47dd1378c56562b4de07e84f29d924fc6e99a", "filename": "library/core/src/hint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhint.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -111,7 +111,7 @@ pub fn spin_loop() {\n #[cfg_attr(not(miri), inline)]\n #[cfg_attr(miri, inline(never))]\n #[unstable(feature = \"test\", issue = \"50297\")]\n-#[allow(unreachable_code)] // this makes #[cfg] a bit easier below.\n+#[cfg_attr(miri, allow(unused_mut))]\n pub fn black_box<T>(mut dummy: T) -> T {\n     // We need to \"use\" the argument in some way LLVM can't introspect, and on\n     // targets that support it we can typically leverage inline assembly to do"}, {"sha": "7e560d63fe23b40245b66e001b6e958825600d0d", "filename": "library/core/src/option.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1502,8 +1502,6 @@ unsafe impl<A> TrustedLen for IterMut<'_, A> {}\n /// The iterator yields one value if the [`Option`] is a [`Some`], otherwise none.\n ///\n /// This `struct` is created by the [`Option::into_iter`] function.\n-///\n-/// [`Option::into_iter`]: enum.Option.html#method.into_iter\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IntoIter<A> {"}, {"sha": "ff926c517bc7cac0150cc1144ddab141ce9a6b3c", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -957,7 +957,7 @@ impl<T> [T] {\n     ///\n     /// This is the const generic equivalent of [`windows`].\n     ///\n-    /// If `N` is smaller than the size of the array, it will return no windows.\n+    /// If `N` is greater than the size of the slice, it will return no windows.\n     ///\n     /// # Panics\n     ///"}, {"sha": "6dc14f9125fefc11425b27ce09338b4f92579e66", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -4,7 +4,7 @@\n //!\n //! For more details, see the [`std::str`] module.\n //!\n-//! [`std::str`]: self\n+//! [`std::str`]: ../../std/str/index.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -84,9 +84,6 @@ pub trait FromStr: Sized {\n     /// when the string is ill-formatted return an error specific to the\n     /// inside [`Err`]. The error type is specific to implementation of the trait.\n     ///\n-    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage with [`i32`][ithirtytwo], a type that implements `FromStr`:\n@@ -269,11 +266,9 @@ impl Utf8Error {\n ///\n /// If you are sure that the byte slice is valid UTF-8, and you don't want to\n /// incur the overhead of the validity check, there is an unsafe version of\n-/// this function, [`from_utf8_unchecked`][fromutf8u], which has the same\n+/// this function, [`from_utf8_unchecked`], which has the same\n /// behavior but skips the check.\n ///\n-/// [fromutf8u]: fn.from_utf8_unchecked.html\n-///\n /// If you need a `String` instead of a `&str`, consider\n /// [`String::from_utf8`][string].\n ///\n@@ -318,11 +313,9 @@ impl Utf8Error {\n /// assert!(str::from_utf8(&sparkle_heart).is_err());\n /// ```\n ///\n-/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n+/// See the docs for [`Utf8Error`] for more details on the kinds of\n /// errors that can be returned.\n ///\n-/// [error]: struct.Utf8Error.html\n-///\n /// A \"stack allocated string\":\n ///\n /// ```\n@@ -371,10 +364,8 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n ///\n /// assert!(str::from_utf8_mut(&mut invalid).is_err());\n /// ```\n-/// See the docs for [`Utf8Error`][error] for more details on the kinds of\n+/// See the docs for [`Utf8Error`] for more details on the kinds of\n /// errors that can be returned.\n-///\n-/// [error]: struct.Utf8Error.html\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     run_utf8_validation(v)?;\n@@ -385,9 +376,7 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n /// Converts a slice of bytes to a string slice without checking\n /// that the string contains valid UTF-8.\n ///\n-/// See the safe version, [`from_utf8`][fromutf8], for more information.\n-///\n-/// [fromutf8]: fn.from_utf8.html\n+/// See the safe version, [`from_utf8`], for more information.\n ///\n /// # Safety\n ///"}, {"sha": "508c522e71aa25b7f9d60e6c90186dff41b7270c", "filename": "library/core/src/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fpattern.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -28,7 +28,7 @@\n //! assert_eq!(s.find(|c: char| c.is_ascii_punctuation()), Some(35));\n //! ```\n //!\n-//! [pattern-impls]: trait.Pattern.html#implementors\n+//! [pattern-impls]: Pattern#implementors\n \n #![unstable(\n     feature = \"pattern\","}, {"sha": "668a028a3f1ea948c0f110ea4c53a70a3a5840bf", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -8,10 +8,8 @@ use crate::marker::{PhantomData, Unpin};\n ///\n /// [vtable]: https://en.wikipedia.org/wiki/Virtual_method_table\n ///\n-/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable] that\n-/// customizes the behavior of the `RawWaker`.\n-///\n-/// [`Waker`]: struct.Waker.html\n+/// It consists of a data pointer and a [virtual function pointer table (vtable)][vtable]\n+/// that customizes the behavior of the `RawWaker`.\n #[derive(PartialEq, Debug)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct RawWaker {\n@@ -52,12 +50,10 @@ impl RawWaker {\n /// The pointer passed to all functions inside the vtable is the `data` pointer\n /// from the enclosing [`RawWaker`] object.\n ///\n-/// The functions inside this struct are only intended be called on the `data`\n+/// The functions inside this struct are only intended to be called on the `data`\n /// pointer of a properly constructed [`RawWaker`] object from inside the\n /// [`RawWaker`] implementation. Calling one of the contained functions using\n /// any other `data` pointer will cause undefined behavior.\n-///\n-/// [`RawWaker`]: struct.RawWaker.html\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RawWakerVTable {\n@@ -68,9 +64,6 @@ pub struct RawWakerVTable {\n     /// required for this additional instance of a [`RawWaker`] and associated\n     /// task. Calling `wake` on the resulting [`RawWaker`] should result in a wakeup\n     /// of the same task that would have been awoken by the original [`RawWaker`].\n-    ///\n-    /// [`Waker`]: struct.Waker.html\n-    /// [`RawWaker`]: struct.RawWaker.html\n     clone: unsafe fn(*const ()) -> RawWaker,\n \n     /// This function will be called when `wake` is called on the [`Waker`].\n@@ -79,28 +72,20 @@ pub struct RawWakerVTable {\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n-    ///\n-    /// [`Waker`]: struct.Waker.html\n-    /// [`RawWaker`]: struct.RawWaker.html\n     wake: unsafe fn(*const ()),\n \n     /// This function will be called when `wake_by_ref` is called on the [`Waker`].\n     /// It must wake up the task associated with this [`RawWaker`].\n     ///\n     /// This function is similar to `wake`, but must not consume the provided data\n     /// pointer.\n-    ///\n-    /// [`Waker`]: struct.Waker.html\n-    /// [`RawWaker`]: struct.RawWaker.html\n     wake_by_ref: unsafe fn(*const ()),\n \n     /// This function gets called when a [`RawWaker`] gets dropped.\n     ///\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n-    ///\n-    /// [`RawWaker`]: struct.RawWaker.html\n     drop: unsafe fn(*const ()),\n }\n \n@@ -142,9 +127,6 @@ impl RawWakerVTable {\n     /// The implementation of this function must make sure to release any\n     /// resources that are associated with this instance of a [`RawWaker`] and\n     /// associated task.\n-    ///\n-    /// [`Waker`]: struct.Waker.html\n-    /// [`RawWaker`]: struct.RawWaker.html\n     #[rustc_promotable]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     // `rustc_allow_const_fn_ptr` is a hack that should not be used anywhere else\n@@ -208,8 +190,6 @@ impl fmt::Debug for Context<'_> {\n /// executor-specific wakeup behavior.\n ///\n /// Implements [`Clone`], [`Send`], and [`Sync`].\n-///\n-/// [`RawWaker`]: struct.RawWaker.html\n #[repr(transparent)]\n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub struct Waker {\n@@ -275,9 +255,6 @@ impl Waker {\n     /// The behavior of the returned `Waker` is undefined if the contract defined\n     /// in [`RawWaker`]'s and [`RawWakerVTable`]'s documentation is not upheld.\n     /// Therefore this method is unsafe.\n-    ///\n-    /// [`RawWaker`]: struct.RawWaker.html\n-    /// [`RawWakerVTable`]: struct.RawWakerVTable.html\n     #[inline]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     pub unsafe fn from_raw(waker: RawWaker) -> Waker {"}, {"sha": "e5800fbceb27ac0f288d4dcaa191367519b857dc", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -47,7 +47,7 @@ pub unsafe extern \"C\" fn __rust_start_panic(_payload: usize) -> u32 {\n                 }\n                 __rust_abort();\n             }\n-        } else if #[cfg(windows)] {\n+        } else if #[cfg(all(windows, not(miri)))] {\n             // On Windows, use the processor-specific __fastfail mechanism. In Windows 8\n             // and later, this will terminate the process immediately without running any\n             // in-process exception handlers. In earlier versions of Windows, this"}, {"sha": "61d71d55d6593c3e267a6cbda4018114d2e09425", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -1298,9 +1298,7 @@ pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n /// This `enum` is constructed through the [`raw_entry_mut`] method on [`HashMap`],\n /// then calling one of the methods of that [`RawEntryBuilderMut`].\n ///\n-/// [`Entry`]: enum.Entry.html\n /// [`raw_entry_mut`]: HashMap::raw_entry_mut\n-/// [`RawEntryBuilderMut`]: struct.RawEntryBuilderMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"56167\")]\n pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n@@ -1705,8 +1703,6 @@ impl<K: Debug, V: Debug> Debug for Entry<'_, K, V> {\n \n /// A view into an occupied entry in a `HashMap`.\n /// It is part of the [`Entry`] enum.\n-///\n-/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     base: base::RustcOccupiedEntry<'a, K, V>,\n@@ -1721,8 +1717,6 @@ impl<K: Debug, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n \n /// A view into a vacant entry in a `HashMap`.\n /// It is part of the [`Entry`] enum.\n-///\n-/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     base: base::RustcVacantEntry<'a, K, V>,"}, {"sha": "842c84a3e5cd6dcd82220e36c49133be5da00db2", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/41507ed0d57eba71adc20a021a19b64322162f04/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41507ed0d57eba71adc20a021a19b64322162f04/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=41507ed0d57eba71adc20a021a19b64322162f04", "patch": "@@ -98,7 +98,6 @@ impl Default for Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n-        let mut extra_help = String::new();\n         let mut subcommand_help = String::from(\n             \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n@@ -170,16 +169,6 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n \n-        // fn usage()\n-        let usage =\n-            |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n-                println!(\"{}\", opts.usage(subcommand_help));\n-                if !extra_help.is_empty() {\n-                    println!(\"{}\", extra_help);\n-                }\n-                process::exit(exit_code);\n-            };\n-\n         // We can't use getopt to parse the options until we have completed specifying which\n         // options are valid, but under the current implementation, some options are conditional on\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n@@ -263,12 +252,38 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             _ => {}\n         };\n \n+        // fn usage()\n+        let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n+            let mut extra_help = String::new();\n+\n+            // All subcommands except `clean` can have an optional \"Available paths\" section\n+            if verbose {\n+                let config = Config::parse(&[\"build\".to_string()]);\n+                let build = Build::new(config);\n+\n+                let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n+                extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n+            } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n+                extra_help.push_str(\n+                    format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n+                        .as_str(),\n+                );\n+            }\n+\n+            println!(\"{}\", opts.usage(subcommand_help));\n+            if !extra_help.is_empty() {\n+                println!(\"{}\", extra_help);\n+            }\n+            process::exit(exit_code);\n+        };\n+\n         // Done specifying what options are possible, so do the getopts parsing\n         let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n             // Invalid argument/option format\n             println!(\"\\n{}\\n\", e);\n-            usage(1, &opts, &subcommand_help, &extra_help);\n+            usage(1, &opts, false, &subcommand_help);\n         });\n+\n         // Extra sanity check to make sure we didn't hit this crazy corner case:\n         //\n         //     ./x.py --frobulate clean build\n@@ -436,24 +451,11 @@ Arguments:\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n-\n-        // All subcommands except `clean` can have an optional \"Available paths\" section\n-        if matches.opt_present(\"verbose\") {\n-            let config = Config::parse(&[\"build\".to_string()]);\n-            let build = Build::new(config);\n-\n-            let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n-            extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n-        } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n-            extra_help.push_str(\n-                format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n-                    .as_str(),\n-            );\n-        }\n+        let verbose = matches.opt_present(\"verbose\");\n \n         // User passed in -h/--help?\n         if matches.opt_present(\"help\") {\n-            usage(0, &opts, &subcommand_help, &extra_help);\n+            usage(0, &opts, verbose, &subcommand_help);\n         }\n \n         let cmd = match subcommand.as_str() {\n@@ -483,7 +485,7 @@ Arguments:\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n-                    usage(1, &opts, &subcommand_help, &extra_help);\n+                    usage(1, &opts, verbose, &subcommand_help);\n                 }\n \n                 Subcommand::Clean { all: matches.opt_present(\"all\") }\n@@ -494,12 +496,12 @@ Arguments:\n             \"run\" | \"r\" => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n-                    usage(1, &opts, &subcommand_help, &extra_help);\n+                    usage(1, &opts, verbose, &subcommand_help);\n                 }\n                 Subcommand::Run { paths }\n             }\n             _ => {\n-                usage(1, &opts, &subcommand_help, &extra_help);\n+                usage(1, &opts, verbose, &subcommand_help);\n             }\n         };\n "}]}