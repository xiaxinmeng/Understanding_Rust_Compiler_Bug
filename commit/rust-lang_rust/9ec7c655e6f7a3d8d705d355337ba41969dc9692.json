{"sha": "9ec7c655e6f7a3d8d705d355337ba41969dc9692", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYzdjNjU1ZTZmN2EzZDhkNzA1ZDM1NTMzN2JhNDE5NjlkYzk2OTI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-20T10:34:38Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-20T10:34:38Z"}, "message": "Add missing urls in collections module", "tree": {"sha": "972dd84fc636b39efa47dc1972f0ce2454c0d6ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/972dd84fc636b39efa47dc1972f0ce2454c0d6ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ec7c655e6f7a3d8d705d355337ba41969dc9692", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ec7c655e6f7a3d8d705d355337ba41969dc9692", "html_url": "https://github.com/rust-lang/rust/commit/9ec7c655e6f7a3d8d705d355337ba41969dc9692", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ec7c655e6f7a3d8d705d355337ba41969dc9692/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb38d426c41aa8487e8cb8a9dafbfcf3528201f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb38d426c41aa8487e8cb8a9dafbfcf3528201f9", "html_url": "https://github.com/rust-lang/rust/commit/eb38d426c41aa8487e8cb8a9dafbfcf3528201f9"}], "stats": {"total": 120, "additions": 65, "deletions": 55}, "files": [{"sha": "b9e92a01b2f8e72a72102d3ec756bd3731a9110b", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 65, "deletions": 55, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/9ec7c655e6f7a3d8d705d355337ba41969dc9692/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ec7c655e6f7a3d8d705d355337ba41969dc9692/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=9ec7c655e6f7a3d8d705d355337ba41969dc9692", "patch": "@@ -15,7 +15,7 @@\n //! standard implementations, it should be possible for two libraries to\n //! communicate without significant data conversion.\n //!\n-//! To get this out of the way: you should probably just use `Vec` or `HashMap`.\n+//! To get this out of the way: you should probably just use [`Vec`] or [`HashMap`].\n //! These two collections cover most use cases for generic data storage and\n //! processing. They are exceptionally good at doing what they do. All the other\n //! collections in the standard library have specific use cases where they are\n@@ -25,10 +25,10 @@\n //!\n //! Rust's collections can be grouped into four major categories:\n //!\n-//! * Sequences: `Vec`, `VecDeque`, `LinkedList`\n-//! * Maps: `HashMap`, `BTreeMap`\n-//! * Sets: `HashSet`, `BTreeSet`\n-//! * Misc: `BinaryHeap`\n+//! * Sequences: [`Vec`], [`VecDeque`], [`LinkedList`]\n+//! * Maps: [`HashMap`], [`BTreeMap`]\n+//! * Sets: [`HashSet`], [`BTreeSet`]\n+//! * Misc: [`BinaryHeap`]\n //!\n //! # When Should You Use Which Collection?\n //!\n@@ -46,13 +46,13 @@\n //! * You want a heap-allocated array.\n //!\n //! ### Use a `VecDeque` when:\n-//! * You want a `Vec` that supports efficient insertion at both ends of the\n+//! * You want a [`Vec`] that supports efficient insertion at both ends of the\n //!   sequence.\n //! * You want a queue.\n //! * You want a double-ended queue (deque).\n //!\n //! ### Use a `LinkedList` when:\n-//! * You want a `Vec` or `VecDeque` of unknown size, and can't tolerate\n+//! * You want a [`Vec`] or [`VecDeque`] of unknown size, and can't tolerate\n //!   amortization.\n //! * You want to efficiently split and append lists.\n //! * You are *absolutely* certain you *really*, *truly*, want a doubly linked\n@@ -92,38 +92,38 @@\n //! Throughout the documentation, we will follow a few conventions. For all\n //! operations, the collection's size is denoted by n. If another collection is\n //! involved in the operation, it contains m elements. Operations which have an\n-//! *amortized* cost are suffixed with a `*`.  Operations with an *expected*\n+//! *amortized* cost are suffixed with a `*`. Operations with an *expected*\n //! cost are suffixed with a `~`.\n //!\n //! All amortized costs are for the potential need to resize when capacity is\n-//! exhausted.  If a resize occurs it will take O(n) time. Our collections never\n+//! exhausted. If a resize occurs it will take O(n) time. Our collections never\n //! automatically shrink, so removal operations aren't amortized. Over a\n //! sufficiently large series of operations, the average cost per operation will\n //! deterministically equal the given cost.\n //!\n-//! Only HashMap has expected costs, due to the probabilistic nature of hashing.\n-//! It is theoretically possible, though very unlikely, for HashMap to\n+//! Only [`HashMap`] has expected costs, due to the probabilistic nature of hashing.\n+//! It is theoretically possible, though very unlikely, for [`HashMap`] to\n //! experience worse performance.\n //!\n //! ## Sequences\n //!\n-//! |              | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n-//! |--------------|----------------|-----------------|----------------|--------|----------------|\n-//! | Vec          | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n-//! | VecDeque     | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n-//! | LinkedList   | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n+//! |                | get(i)         | insert(i)       | remove(i)      | append | split_off(i)   |\n+//! |----------------|----------------|-----------------|----------------|--------|----------------|\n+//! | [`Vec`]        | O(1)           | O(n-i)*         | O(n-i)         | O(m)*  | O(n-i)         |\n+//! | [`VecDeque`]   | O(1)           | O(min(i, n-i))* | O(min(i, n-i)) | O(m)*  | O(min(i, n-i)) |\n+//! | [`LinkedList`] | O(min(i, n-i)) | O(min(i, n-i))  | O(min(i, n-i)) | O(1)   | O(min(i, n-i)) |\n //!\n-//! Note that where ties occur, Vec is generally going to be faster than VecDeque, and VecDeque\n-//! is generally going to be faster than LinkedList.\n+//! Note that where ties occur, [`Vec`] is generally going to be faster than [`VecDeque`], and\n+//! [`VecDeque`] is generally going to be faster than [`LinkedList`].\n //!\n //! ## Maps\n //!\n //! For Sets, all operations have the cost of the equivalent Map operation.\n //!\n-//! |          | get       | insert   | remove   | predecessor | append |\n-//! |----------|-----------|----------|----------|-------------|--------|\n-//! | HashMap  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n-//! | BTreeMap | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n+//! |              | get       | insert   | remove   | predecessor | append |\n+//! |--------------|-----------|----------|----------|-------------|--------|\n+//! | [`HashMap`]  | O(1)~     | O(1)~*   | O(1)~    | N/A         | N/A    |\n+//! | [`BTreeMap`] | O(log n)  | O(log n) | O(log n) | O(log n)    | O(n+m) |\n //!\n //! # Correct and Efficient Usage of Collections\n //!\n@@ -136,7 +136,7 @@\n //! ## Capacity Management\n //!\n //! Many collections provide several constructors and methods that refer to\n-//! \"capacity\".  These collections are generally built on top of an array.\n+//! \"capacity\". These collections are generally built on top of an array.\n //! Optimally, this array would be exactly the right size to fit only the\n //! elements stored in the collection, but for the collection to do this would\n //! be very inefficient. If the backing array was exactly the right size at all\n@@ -157,29 +157,29 @@\n //! information to do this itself. Therefore, it is up to us programmers to give\n //! it hints.\n //!\n-//! Any `with_capacity` constructor will instruct the collection to allocate\n+//! Any `with_capacity()` constructor will instruct the collection to allocate\n //! enough space for the specified number of elements. Ideally this will be for\n //! exactly that many elements, but some implementation details may prevent\n-//! this. `Vec` and `VecDeque` can be relied on to allocate exactly the\n-//! requested amount, though. Use `with_capacity` when you know exactly how many\n+//! this. [`Vec`] and [`VecDeque`] can be relied on to allocate exactly the\n+//! requested amount, though. Use `with_capacity()` when you know exactly how many\n //! elements will be inserted, or at least have a reasonable upper-bound on that\n //! number.\n //!\n-//! When anticipating a large influx of elements, the `reserve` family of\n+//! When anticipating a large influx of elements, the `reserve()` family of\n //! methods can be used to hint to the collection how much room it should make\n-//! for the coming items.  As with `with_capacity`, the precise behavior of\n+//! for the coming items. As with `with_capacity()`, the precise behavior of\n //! these methods will be specific to the collection of interest.\n //!\n //! For optimal performance, collections will generally avoid shrinking\n-//! themselves.  If you believe that a collection will not soon contain any more\n-//! elements, or just really need the memory, the `shrink_to_fit` method prompts\n+//! themselves. If you believe that a collection will not soon contain any more\n+//! elements, or just really need the memory, the `shrink_to_fit()` method prompts\n //! the collection to shrink the backing array to the minimum size capable of\n //! holding its elements.\n //!\n //! Finally, if ever you're interested in what the actual capacity of the\n-//! collection is, most collections provide a `capacity` method to query this\n-//! information on demand.  This can be useful for debugging purposes, or for\n-//! use with the `reserve` methods.\n+//! collection is, most collections provide a `capacity()` method to query this\n+//! information on demand. This can be useful for debugging purposes, or for\n+//! use with the `reserve()` methods.\n //!\n //! ## Iterators\n //!\n@@ -194,15 +194,15 @@\n //!\n //! All of the standard collections provide several iterators for performing\n //! bulk manipulation of their contents. The three primary iterators almost\n-//! every collection should provide are `iter`, `iter_mut`, and `into_iter`.\n+//! every collection should provide are `iter()`, `iter_mut()`, and `into_iter()`.\n //! Some of these are not provided on collections where it would be unsound or\n //! unreasonable to provide them.\n //!\n-//! `iter` provides an iterator of immutable references to all the contents of a\n-//! collection in the most \"natural\" order. For sequence collections like `Vec`,\n+//! `iter()` provides an iterator of immutable references to all the contents of a\n+//! collection in the most \"natural\" order. For sequence collections like [`Vec`],\n //! this means the items will be yielded in increasing order of index starting\n-//! at 0. For ordered collections like `BTreeMap`, this means that the items\n-//! will be yielded in sorted order.  For unordered collections like `HashMap`,\n+//! at 0. For ordered collections like [`BTreeMap`], this means that the items\n+//! will be yielded in sorted order. For unordered collections like [`HashMap`],\n //! the items will be yielded in whatever order the internal representation made\n //! most convenient. This is great for reading through all the contents of the\n //! collection.\n@@ -214,8 +214,8 @@\n //! }\n //! ```\n //!\n-//! `iter_mut` provides an iterator of *mutable* references in the same order as\n-//! `iter`.  This is great for mutating all the contents of the collection.\n+//! `iter_mut()` provides an iterator of *mutable* references in the same order as\n+//! `iter()`. This is great for mutating all the contents of the collection.\n //!\n //! ```\n //! let mut vec = vec![1, 2, 3, 4];\n@@ -224,12 +224,12 @@\n //! }\n //! ```\n //!\n-//! `into_iter` transforms the actual collection into an iterator over its\n+//! `into_iter()` transforms the actual collection into an iterator over its\n //! contents by-value. This is great when the collection itself is no longer\n-//! needed, and the values are needed elsewhere. Using `extend` with `into_iter`\n+//! needed, and the values are needed elsewhere. Using `extend()` with `into_iter()`\n //! is the main way that contents of one collection are moved into another.\n-//! `extend` automatically calls `into_iter`, and takes any `T: IntoIterator`.\n-//! Calling `collect` on an iterator itself is also a great way to convert one\n+//! `extend()` automatically calls `into_iter()`, and takes any `T: `[`IntoIterator`].\n+//! Calling `collect()` on an iterator itself is also a great way to convert one\n //! collection into another. Both of these methods should internally use the\n //! capacity management tools discussed in the previous section to do this as\n //! efficiently as possible.\n@@ -248,9 +248,9 @@\n //! ```\n //!\n //! Iterators also provide a series of *adapter* methods for performing common\n-//! threads to sequences. Among the adapters are functional favorites like `map`,\n-//! `fold`, `skip`, and `take`. Of particular interest to collections is the\n-//! `rev` adapter, that reverses any iterator that supports this operation. Most\n+//! threads to sequences. Among the adapters are functional favorites like `map()`,\n+//! `fold()`, `skip()` and `take()`. Of particular interest to collections is the\n+//! `rev()` adapter, that reverses any iterator that supports this operation. Most\n //! collections provide reversible iterators as the way to iterate over them in\n //! reverse order.\n //!\n@@ -263,42 +263,42 @@\n //!\n //! Several other collection methods also return iterators to yield a sequence\n //! of results but avoid allocating an entire collection to store the result in.\n-//! This provides maximum flexibility as `collect` or `extend` can be called to\n+//! This provides maximum flexibility as `collect()` or `extend()` can be called to\n //! \"pipe\" the sequence into any collection if desired. Otherwise, the sequence\n //! can be looped over with a `for` loop. The iterator can also be discarded\n //! after partial use, preventing the computation of the unused items.\n //!\n //! ## Entries\n //!\n-//! The `entry` API is intended to provide an efficient mechanism for\n+//! The `entry()` API is intended to provide an efficient mechanism for\n //! manipulating the contents of a map conditionally on the presence of a key or\n //! not. The primary motivating use case for this is to provide efficient\n //! accumulator maps. For instance, if one wishes to maintain a count of the\n //! number of times each key has been seen, they will have to perform some\n //! conditional logic on whether this is the first time the key has been seen or\n-//! not. Normally, this would require a `find` followed by an `insert`,\n+//! not. Normally, this would require a `find()` followed by an `insert()`,\n //! effectively duplicating the search effort on each insertion.\n //!\n //! When a user calls `map.entry(&key)`, the map will search for the key and\n //! then yield a variant of the `Entry` enum.\n //!\n //! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case\n-//! the only valid operation is to `insert` a value into the entry. When this is\n+//! the only valid operation is to `insert()` a value into the entry. When this is\n //! done, the vacant entry is consumed and converted into a mutable reference to\n //! the value that was inserted. This allows for further manipulation of the\n //! value beyond the lifetime of the search itself. This is useful if complex\n //! logic needs to be performed on the value regardless of whether the value was\n //! just inserted.\n //!\n //! If an `Occupied(entry)` is yielded, then the key *was* found. In this case,\n-//! the user has several options: they can `get`, `insert`, or `remove` the\n+//! the user has several options: they can `get()`, `insert()` or `remove()` the\n //! value of the occupied entry. Additionally, they can convert the occupied\n //! entry into a mutable reference to its value, providing symmetry to the\n-//! vacant `insert` case.\n+//! vacant `insert()` case.\n //!\n //! ### Examples\n //!\n-//! Here are the two primary ways in which `entry` is used. First, a simple\n+//! Here are the two primary ways in which `entry()` is used. First, a simple\n //! example where the logic performed on the values is trivial.\n //!\n //! #### Counting the number of times each character in a string occurs\n@@ -322,7 +322,7 @@\n //! ```\n //!\n //! When the logic to be performed on the value is more complex, we may simply\n-//! use the `entry` API to ensure that the value is initialized, and perform the\n+//! use the `entry()` API to ensure that the value is initialized and perform the\n //! logic afterwards.\n //!\n //! #### Tracking the inebriation of customers at a bar\n@@ -406,6 +406,16 @@\n //! // ...but the key hasn't changed. b is still \"baz\", not \"xyz\".\n //! assert_eq!(map.keys().next().unwrap().b, \"baz\");\n //! ```\n+//!\n+//! [`Vec`]: ../../std/vec/struct.Vec.html\n+//! [`HashMap`]: ../../std/collections/struct.HashMap.html\n+//! [`VecDeque`]: ../../std/collections/struct.VecDeque.html\n+//! [`LinkedList`]: ../../std/collections/struct.LinkedList.html\n+//! [`BTreeMap`]: ../../std/collections/struct.BTreeMap.html\n+//! [`HashSet`]: ../../std/collections/struct.HashSet.html\n+//! [`BTreeSet`]: ../../std/collections/struct.BTreeSet.html\n+//! [`BinaryHeap`]: ../../std/collections/struct.BinaryHeap.html\n+//! [`IntoIterator`]: ../../std/iter/trait.IntoIterator.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}