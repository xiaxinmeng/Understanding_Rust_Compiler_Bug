{"sha": "8687949a29aaf8e33718a33154f9d9b65d39a6be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ODc5NDlhMjlhYWY4ZTMzNzE4YTMzMTU0ZjlkOWI2NWQzOWE2YmU=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@cs.washington.edu", "date": "2016-03-25T22:47:27Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-04-02T13:32:57Z"}, "message": "Tests passing for invalid_upcast_comparisons", "tree": {"sha": "2696293b03fca5b4ebf566662164474f893c425d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2696293b03fca5b4ebf566662164474f893c425d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8687949a29aaf8e33718a33154f9d9b65d39a6be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8687949a29aaf8e33718a33154f9d9b65d39a6be", "html_url": "https://github.com/rust-lang/rust/commit/8687949a29aaf8e33718a33154f9d9b65d39a6be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8687949a29aaf8e33718a33154f9d9b65d39a6be/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c81edfc7b904ccab94073a5726fda27c439db010", "url": "https://api.github.com/repos/rust-lang/rust/commits/c81edfc7b904ccab94073a5726fda27c439db010", "html_url": "https://github.com/rust-lang/rust/commit/c81edfc7b904ccab94073a5726fda27c439db010"}], "stats": {"total": 123, "additions": 63, "deletions": 60}, "files": [{"sha": "8fede2593ed6b5536bda67cd2b3f78ceb5164085", "filename": "src/types.rs", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8687949a29aaf8e33718a33154f9d9b65d39a6be/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8687949a29aaf8e33718a33154f9d9b65d39a6be/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=8687949a29aaf8e33718a33154f9d9b65d39a6be", "patch": "@@ -1,5 +1,4 @@\n use reexport::*;\n-use rustc_const_eval::*;\n use rustc::lint::*;\n use rustc::middle::def;\n use rustc::ty;\n@@ -657,7 +656,7 @@ fn normalize_comparison<'a>(op: BinOp_, lhs: &'a Expr, rhs: &'a Expr)\n         BiLe => Some((Rel::Le, lhs, rhs)),\n         BiGt => Some((Rel::Lt, rhs, lhs)),\n         BiGe => Some((Rel::Le, rhs, lhs)),\n-        _ => return None,\n+        _ => None,\n     }\n }\n \n@@ -669,7 +668,7 @@ fn detect_absurd_comparison<'a>(cx: &LateContext, op: BinOp_, lhs: &'a Expr, rhs\n \n     let normalized = normalize_comparison(op, lhs, rhs);\n     if normalized.is_none() { return None; } // Could be an if let, but this prevents rightward drift\n-    let (rel, normalized_lhs, normalized_rhs) = normalized.unwrap();\n+    let (rel, normalized_lhs, normalized_rhs) = normalized.expect(\"Unreachable-- is none check above\");\n \n     let lx = detect_extreme_expr(cx, normalized_lhs);\n     let rx = detect_extreme_expr(cx, normalized_rhs);\n@@ -818,15 +817,15 @@ enum FullInt {\n }\n \n use std;\n-use self::FullInt::*;\n-use std::cmp::Ordering::*;\n+use std::cmp::Ordering;\n \n impl FullInt {\n+    #[allow(cast_sign_loss)]\n     fn cmp_s_u(s: &i64, u: &u64) -> std::cmp::Ordering {\n         if *s < 0 {\n-            Less\n+            Ordering::Less\n         } else if *u > (i64::max_value() as u64) {\n-            Greater\n+            Ordering::Greater\n         } else {\n             (*s as u64).cmp(u)\n         }\n@@ -835,54 +834,51 @@ impl FullInt {\n \n impl PartialEq for FullInt {\n     fn eq(&self, other: &Self) -> bool {\n-        self.cmp(other) == Equal\n+        self.cmp(other) == Ordering::Equal\n     }\n }\n impl Eq for FullInt {}\n \n impl PartialOrd for FullInt {\n     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n         Some(match (self, other) {\n-            (&S(ref s), &S(ref o)) => s.cmp(o),\n-            (&U(ref s), &U(ref o)) => s.cmp(o),\n-            (&S(ref s), &U(ref o)) => Self::cmp_s_u(s, o),\n-            (&U(ref s), &S(ref o)) => Self::cmp_s_u(o, s).reverse(),\n+            (&FullInt::S(ref s), &FullInt::S(ref o)) => s.cmp(o),\n+            (&FullInt::U(ref s), &FullInt::U(ref o)) => s.cmp(o),\n+            (&FullInt::S(ref s), &FullInt::U(ref o)) => Self::cmp_s_u(s, o),\n+            (&FullInt::U(ref s), &FullInt::S(ref o)) => Self::cmp_s_u(o, s).reverse(),\n         })\n     }\n }\n impl Ord for FullInt {\n     fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n-        self.partial_cmp(other).unwrap()\n+        self.partial_cmp(other).expect(\"partial_cmp for FullInt can never return None\")\n     }\n }\n \n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n-    use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+    use rustc::middle::ty::TypeVariants::{TyInt, TyUint};\n+    use syntax::ast::UintTy;\n+    use syntax::ast::IntTy;\n+    use std::*;\n \n     if let ExprCast(ref cast_exp,_) = expr.node {\n-        let cv = match const_eval::eval_const_expr_partial(cx.tcx, cast_exp, ExprTypeChecked, None) {\n-            Ok(val) => val,\n-            Err(_) => return None,\n-        };\n-\n-        if let Integral(const_int) = cv {\n-            Some(match const_int {\n-                I8(_) => (S(i8::min_value() as i64), S(i8::max_value() as i64)),\n-                I16(_) => (S(i16::min_value() as i64), S(i16::max_value() as i64)),\n-                I32(_) => (S(i32::min_value() as i64), S(i32::max_value() as i64)),\n-                Isize(_) |\n-                I64(_) |\n-                InferSigned(_) => (S(i64::max_value()), S(i64::max_value())),\n-                U8(_) => (U(u8::min_value() as u64), U(u8::max_value() as u64)),\n-                U16(_) => (U(u16::min_value() as u64), U(u16::max_value() as u64)),\n-                U32(_) => (U(u32::min_value() as u64), U(u32::max_value() as u64)),\n-                Usize(_) |\n-                U64(_) |\n-                Infer(_) => (U(u64::max_value()), U(u64::max_value())),\n-            })\n-        } else {\n-            None\n+        match cx.tcx.expr_ty(cast_exp).sty {\n+            TyInt(int_ty) => Some(match int_ty {\n+                IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n+                IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n+                IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n+                IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n+                IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n+            }),\n+            TyUint(uint_ty) => Some(match uint_ty {\n+                UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n+                UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n+                UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n+                UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n+                UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n+            }),\n+            _ => None,\n         }\n     } else {\n         None\n@@ -891,35 +887,36 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n \n fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n     use rustc::middle::const_eval::EvalHint::ExprTypeChecked;\n+    use rustc_const_eval::*;\n \n     match const_eval::eval_const_expr_partial(cx.tcx, expr, ExprTypeChecked, None) {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n                 Some(match const_int {\n-                    I8(x) => S(x as i64),\n-                    I16(x) => S(x as i64),\n-                    I32(x) => S(x as i64),\n-                    Isize(x) => S(match x {\n+                    I8(x) => FullInt::S(x as i64),\n+                    I16(x) => FullInt::S(x as i64),\n+                    I32(x) => FullInt::S(x as i64),\n+                    Isize(x) => FullInt::S(match x {\n                         Is32(x_) => x_ as i64,\n                         Is64(x_) => x_\n                     }),\n-                    I64(x) => S(x),\n-                    InferSigned(x) => S(x as i64),\n-                    U8(x) => U(x as u64),\n-                    U16(x) => U(x as u64),\n-                    U32(x) => U(x as u64),\n-                    Usize(x) => U(match x {\n+                    I64(x) => FullInt::S(x),\n+                    InferSigned(x) => FullInt::S(x as i64),\n+                    U8(x) => FullInt::U(x as u64),\n+                    U16(x) => FullInt::U(x as u64),\n+                    U32(x) => FullInt::U(x as u64),\n+                    Usize(x) => FullInt::U(match x {\n                         Us32(x_) => x_ as u64,\n                         Us64(x_) => x_,\n                     }),\n-                    U64(x) => U(x),\n-                    Infer(x) => U(x as u64),\n+                    U64(x) => FullInt::U(x),\n+                    Infer(x) => FullInt::U(x as u64),\n                 })\n             } else {\n                 None\n             }\n         },\n-        Err(_) => return None,\n+        Err(_) => None,\n     }\n }\n \n@@ -928,12 +925,14 @@ impl LateLintPass for InvalidUpcastComparisons {\n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n             let normalized = normalize_comparison(cmp.node, lhs, rhs);\n             if normalized.is_none() { return; }\n-            let (rel, normalized_lhs, normalized_rhs) = normalized.unwrap();\n+            let (rel, normalized_lhs, normalized_rhs) = normalized.expect(\"Unreachable-- is none check above\");\n+\n+            let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n+            let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n \n-            let norm_lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n-            let norm_rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n+            let msg = \"Because of the numeric bounds prior to casting, this expression is always \";\n \n-            if let Some(nlb) = norm_lhs_bounds {\n+            if let Some(nlb) = lhs_bounds {\n                 if let Some(norm_rhs_val) = node_as_const_fullint(cx, normalized_rhs) {\n                     if match rel {\n                         Rel::Lt => nlb.1 < norm_rhs_val,\n@@ -942,18 +941,18 @@ impl LateLintPass for InvalidUpcastComparisons {\n                         // Expression is always true\n                         cx.span_lint(INVALID_UPCAST_COMPARISONS,\n                                      expr.span,\n-                                     &format!(\"\"));\n+                                     &format!(\"{}{}.\", msg, \"true\"));\n                     } else if match rel {\n                         Rel::Lt => nlb.0 >= norm_rhs_val,\n                         Rel::Le => nlb.0 > norm_rhs_val,\n                     } {\n                         // Expression is always false\n                         cx.span_lint(INVALID_UPCAST_COMPARISONS,\n                                      expr.span,\n-                                     &format!(\"\"));\n+                                     &format!(\"{}{}.\", msg, \"false\"));\n                     }\n                 }\n-            } else if let Some(nrb) = norm_rhs_bounds {\n+            } else if let Some(nrb) = rhs_bounds {\n                 if let Some(norm_lhs_val) = node_as_const_fullint(cx, normalized_lhs) {\n                     if match rel {\n                         Rel::Lt => norm_lhs_val < nrb.0,\n@@ -962,15 +961,15 @@ impl LateLintPass for InvalidUpcastComparisons {\n                         // Expression is always true\n                         cx.span_lint(INVALID_UPCAST_COMPARISONS,\n                                      expr.span,\n-                                     &format!(\"\"));\n+                                     &format!(\"{}{}.\", msg, \"true\"));\n                     } else if match rel {\n                         Rel::Lt => norm_lhs_val >= nrb.1,\n                         Rel::Le => norm_lhs_val > nrb.1,\n                     } {\n                         // Expression is always false\n                         cx.span_lint(INVALID_UPCAST_COMPARISONS,\n                                      expr.span,\n-                                     &format!(\"\"));\n+                                     &format!(\"{}{}.\", msg, \"false\"));\n                     }\n                 }\n             }"}, {"sha": "d5849420e387c29d6becc0da1417bac7d6ad9bc9", "filename": "tests/compile-fail/invalid_upcast_comparisons.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8687949a29aaf8e33718a33154f9d9b65d39a6be/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8687949a29aaf8e33718a33154f9d9b65d39a6be/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_upcast_comparisons.rs?ref=8687949a29aaf8e33718a33154f9d9b65d39a6be", "patch": "@@ -7,9 +7,13 @@ fn main() {\n     let zero: u32 = 0;\n     let u8_max: u8 = 255;\n \n-    (u8_max as u32) > 300; //~ERROR\n+    (u8_max as u32) > 300; //~ERROR Because of the numeric bounds prior to casting, this expression is always false.\n     (u8_max as u32) > 20;\n \n-    (zero as i32) < -5; //~ERROR\n+    (zero as i32) < -5; //~ERROR Because of the numeric bounds prior to casting, this expression is always false.\n     (zero as i32) < 10;\n+\n+    -5 < (zero as i32); //~ERROR Because of the numeric bounds prior to casting, this expression is always true.\n+    0 <= (zero as i32); //~ERROR Because of the numeric bounds prior to casting, this expression is always true.\n+    0 < (zero as i32);\n }"}]}