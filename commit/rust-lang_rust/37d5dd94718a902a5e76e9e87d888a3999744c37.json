{"sha": "37d5dd94718a902a5e76e9e87d888a3999744c37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZDVkZDk0NzE4YTkwMmE1ZTc2ZTllODdkODg4YTM5OTk3NDRjMzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T18:53:26Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-18T18:54:12Z"}, "message": "rustc: Group the variable binding machinery into a separate data structure during unification", "tree": {"sha": "ad0fdd725dcd8f67ff38c48ba0c87c3b7aeb84ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad0fdd725dcd8f67ff38c48ba0c87c3b7aeb84ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37d5dd94718a902a5e76e9e87d888a3999744c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37d5dd94718a902a5e76e9e87d888a3999744c37", "html_url": "https://github.com/rust-lang/rust/commit/37d5dd94718a902a5e76e9e87d888a3999744c37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37d5dd94718a902a5e76e9e87d888a3999744c37/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a795d0e5b24a8a74cf2529bfc738af275b5a3e78", "url": "https://api.github.com/repos/rust-lang/rust/commits/a795d0e5b24a8a74cf2529bfc738af275b5a3e78", "html_url": "https://github.com/rust-lang/rust/commit/a795d0e5b24a8a74cf2529bfc738af275b5a3e78"}], "stats": {"total": 62, "additions": 33, "deletions": 29}, "files": [{"sha": "b7ff61ffd2bdd68a2ee2dafa570164de84959e04", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/37d5dd94718a902a5e76e9e87d888a3999744c37/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d5dd94718a902a5e76e9e87d888a3999744c37/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=37d5dd94718a902a5e76e9e87d888a3999744c37", "patch": "@@ -1865,9 +1865,18 @@ mod unify {\n         ures_err(type_err, t, t);\n     }\n \n-    type ctxt = rec(ufind::ufind sets,\n-                    hashmap[int,uint] var_ids,\n-                    mutable vec[mutable vec[t]] types,\n+    type var_bindings = rec(ufind::ufind sets,\n+                            hashmap[int,uint] var_ids,\n+                            mutable vec[mutable vec[t]] types);\n+\n+    fn mk_var_bindings() -> var_bindings {\n+        let vec[mutable vec[t]] types = [mutable];\n+        ret rec(sets=ufind::make(),\n+                var_ids=common::new_int_hash[uint](),\n+                mutable types=types);\n+    }\n+\n+    type ctxt = rec(var_bindings var_bindings,\n                     unify_handler handler,\n                     ty_ctxt tcx);\n \n@@ -2070,12 +2079,12 @@ mod unify {\n \n     fn get_or_create_set(&@ctxt cx, int id) -> uint {\n         auto set_num;\n-        alt (cx.var_ids.find(id)) {\n-        case (none[uint]) {\n-            set_num = ufind::make_set(cx.sets);\n-            cx.var_ids.insert(id, set_num);\n-        }\n-        case (some[uint](?n)) { set_num = n; }\n+        alt (cx.var_bindings.var_ids.find(id)) {\n+            case (none[uint]) {\n+                set_num = ufind::make_set(cx.var_bindings.sets);\n+                cx.var_bindings.var_ids.insert(id, set_num);\n+            }\n+            case (some[uint](?n)) { set_num = n; }\n         }\n         ret set_num;\n     }\n@@ -2098,17 +2107,18 @@ mod unify {\n                 alt (struct(cx.tcx, expected)) {\n                     case (ty::ty_var(?expected_id)) {\n                         auto expected_n = get_or_create_set(cx, expected_id);\n-                        ufind::union(cx.sets, expected_n, actual_n);\n+                        ufind::union(cx.var_bindings.sets, expected_n,\n+                                     actual_n);\n                     }\n \n                     case (_) {\n                         // Just bind the type variable to the expected type.\n-                        auto vlen = vec::len[vec[t]](cx.types);\n+                        auto vlen = vec::len[vec[t]](cx.var_bindings.types);\n                         if (actual_n < vlen) {\n-                            cx.types.(actual_n) += [expected];\n+                            cx.var_bindings.types.(actual_n) += [expected];\n                         } else {\n                             assert (actual_n == vlen);\n-                            cx.types += [mutable [expected]];\n+                            cx.var_bindings.types += [mutable [expected]];\n                         }\n                     }\n                 }\n@@ -2472,12 +2482,12 @@ mod unify {\n             case (ty::ty_var(?expected_id)) {\n                 // Add a binding.\n                 auto expected_n = get_or_create_set(cx, expected_id);\n-                auto vlen = vec::len[vec[t]](cx.types);\n+                auto vlen = vec::len[vec[t]](cx.var_bindings.types);\n                 if (expected_n < vlen) {\n-                    cx.types.(expected_n) += [actual];\n+                    cx.var_bindings.types.(expected_n) += [actual];\n                 } else {\n                     assert (expected_n == vlen);\n-                    cx.types += [mutable [actual]];\n+                    cx.var_bindings.types += [mutable [actual]];\n                 }\n                 ret ures_ok(expected);\n             }\n@@ -2517,9 +2527,9 @@ mod unify {\n         fn substituter(@ctxt cx, vec[t] types, t typ) -> t {\n             alt (struct(cx.tcx, typ)) {\n                 case (ty_var(?id)) {\n-                    alt (cx.var_ids.find(id)) {\n+                    alt (cx.var_bindings.var_ids.find(id)) {\n                         case (some[uint](?n)) {\n-                            auto root = ufind::find(cx.sets, n);\n+                            auto root = ufind::find(cx.var_bindings.sets, n);\n                             ret types.(root);\n                         }\n                         case (none[uint]) { ret typ; }\n@@ -2538,15 +2548,15 @@ mod unify {\n         let vec[mutable vec[t]] set_types = [mutable throwaway];\n         vec::pop[vec[t]](set_types);   // FIXME: botch\n \n-        for (ufind::node node in cx.sets.nodes) {\n+        for (ufind::node node in cx.var_bindings.sets.nodes) {\n             let vec[t] v = [];\n             set_types += [mutable v];\n         }\n \n         auto i = 0u;\n         while (i < vec::len[vec[t]](set_types)) {\n-            auto root = ufind::find(cx.sets, i);\n-            set_types.(root) += cx.types.(i);\n+            auto root = ufind::find(cx.var_bindings.sets, i);\n+            set_types.(root) += cx.var_bindings.types.(i);\n             i += 1u;\n         }\n \n@@ -2567,13 +2577,7 @@ mod unify {\n              &t actual,\n              &unify_handler handler,\n              &ty_ctxt tcx) -> result {\n-        let vec[t] throwaway = [];\n-        let vec[mutable vec[t]] types = [mutable throwaway];\n-        vec::pop[vec[t]](types);   // FIXME: botch\n-\n-        auto cx = @rec(sets=ufind::make(),\n-                       var_ids=common::new_int_hash[uint](),\n-                       mutable types=types,\n+        auto cx = @rec(var_bindings=mk_var_bindings(),\n                        handler=handler,\n                        tcx=tcx);\n \n@@ -2582,7 +2586,7 @@ mod unify {\n         case (ures_ok(?typ)) {\n             // Fast path: if there are no local variables, don't perform\n             // substitutions.\n-            if (vec::len(cx.sets.nodes) == 0u) {\n+            if (vec::len(cx.var_bindings.sets.nodes) == 0u) {\n                 ret ures_ok(typ);\n             }\n "}]}