{"sha": "d08f3a1c702c337c494bbc03d8bed9664ac1dddf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwOGYzYTFjNzAyYzMzN2M0OTRiYmMwM2Q4YmVkOTY2NGFjMWRkZGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-01T01:49:26Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-01T01:49:26Z"}, "message": "More complete sketch of structural compare. Still not quite working.", "tree": {"sha": "24a0e22330b4d0ac314432599a79e33f0024a704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24a0e22330b4d0ac314432599a79e33f0024a704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d08f3a1c702c337c494bbc03d8bed9664ac1dddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d08f3a1c702c337c494bbc03d8bed9664ac1dddf", "html_url": "https://github.com/rust-lang/rust/commit/d08f3a1c702c337c494bbc03d8bed9664ac1dddf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d08f3a1c702c337c494bbc03d8bed9664ac1dddf/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1291cc2df90c36eee8642048e1bf1b69a690781f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1291cc2df90c36eee8642048e1bf1b69a690781f", "html_url": "https://github.com/rust-lang/rust/commit/1291cc2df90c36eee8642048e1bf1b69a690781f"}], "stats": {"total": 153, "additions": 115, "deletions": 38}, "files": [{"sha": "8dc4efb74c2d059916716b639a30a2b38f0d5238", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 115, "deletions": 38, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/d08f3a1c702c337c494bbc03d8bed9664ac1dddf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d08f3a1c702c337c494bbc03d8bed9664ac1dddf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d08f3a1c702c337c494bbc03d8bed9664ac1dddf", "patch": "@@ -1493,27 +1493,50 @@ fn mk_plain_tag(ast.def_id tid) -> @ty.t {\n \n type val_and_ty_fn = fn(@block_ctxt cx, ValueRef v, @ty.t t) -> result;\n \n+type val_pair_and_ty_fn =\n+    fn(@block_ctxt cx, ValueRef av, ValueRef bv, @ty.t t) -> result;\n+\n // Iterates through the elements of a structural type.\n fn iter_structural_ty(@block_ctxt cx,\n                       ValueRef v,\n                       @ty.t t,\n                       val_and_ty_fn f)\n     -> result {\n+    fn adaptor_fn(val_and_ty_fn f,\n+                  @block_ctxt cx,\n+                  ValueRef av,\n+                  ValueRef bv,\n+                  @ty.t t) -> result {\n+        ret f(cx, av, t);\n+    }\n+    be iter_structural_ty_full(cx, v, v, t,\n+                               bind adaptor_fn(f, _, _, _, _));\n+}\n+\n+\n+fn iter_structural_ty_full(@block_ctxt cx,\n+                           ValueRef av,\n+                           ValueRef bv,\n+                           @ty.t t,\n+                           val_pair_and_ty_fn f)\n+    -> result {\n     let result r = res(cx, C_nil());\n \n     fn iter_boxpp(@block_ctxt cx,\n-                  ValueRef box_cell,\n-                  val_and_ty_fn f) -> result {\n-        auto box_ptr = cx.build.Load(box_cell);\n+                  ValueRef box_a_cell,\n+                  ValueRef box_b_cell,\n+                  val_pair_and_ty_fn f) -> result {\n+        auto box_a_ptr = cx.build.Load(box_a_cell);\n+        auto box_b_ptr = cx.build.Load(box_b_cell);\n         auto tnil = plain_ty(ty.ty_nil);\n         auto tbox = plain_ty(ty.ty_box(tnil));\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n-        auto null_test = cx.build.IsNull(box_ptr);\n+        auto null_test = cx.build.IsNull(box_a_ptr);\n         cx.build.CondBr(null_test, next_cx.llbb, inner_cx.llbb);\n \n-        auto r = f(inner_cx, box_ptr, tbox);\n+        auto r = f(inner_cx, box_a_ptr, box_b_ptr, tbox);\n         r.bcx.build.Br(next_cx.llbb);\n         ret res(next_cx, r.val);\n     }\n@@ -1522,19 +1545,23 @@ fn iter_structural_ty(@block_ctxt cx,\n         case (ty.ty_tup(?args)) {\n             let int i = 0;\n             for (@ty.t arg in args) {\n-                auto elt = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n+                auto elt_a = r.bcx.build.GEP(av, vec(C_int(0), C_int(i)));\n+                auto elt_b = r.bcx.build.GEP(bv, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, elt, arg),\n+                      load_scalar_or_boxed(r.bcx, elt_a, arg),\n+                      load_scalar_or_boxed(r.bcx, elt_b, arg),\n                       arg);\n                 i += 1;\n             }\n         }\n         case (ty.ty_rec(?fields)) {\n             let int i = 0;\n             for (ty.field fld in fields) {\n-                auto llfld = r.bcx.build.GEP(v, vec(C_int(0), C_int(i)));\n+                auto llfld_a = r.bcx.build.GEP(av, vec(C_int(0), C_int(i)));\n+                auto llfld_b = r.bcx.build.GEP(bv, vec(C_int(0), C_int(i)));\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, llfld, fld.ty),\n+                      load_scalar_or_boxed(r.bcx, llfld_a, fld.ty),\n+                      load_scalar_or_boxed(r.bcx, llfld_b, fld.ty),\n                       fld.ty);\n                 i += 1;\n             }\n@@ -1545,53 +1572,69 @@ fn iter_structural_ty(@block_ctxt cx,\n             auto variants = tag_variants(cx.fcx.ccx, tid);\n             auto n_variants = _vec.len[ast.variant](variants);\n \n-            auto lldiscrim_ptr = cx.build.GEP(v, vec(C_int(0), C_int(0)));\n-            auto llunion_ptr = cx.build.GEP(v, vec(C_int(0), C_int(1)));\n-            auto lldiscrim = cx.build.Load(lldiscrim_ptr);\n+            auto lldiscrim_a_ptr = cx.build.GEP(av, vec(C_int(0), C_int(0)));\n+            auto llunion_a_ptr = cx.build.GEP(av, vec(C_int(0), C_int(1)));\n+            auto lldiscrim_a = cx.build.Load(lldiscrim_a_ptr);\n+\n+            auto lldiscrim_b_ptr = cx.build.GEP(bv, vec(C_int(0), C_int(0)));\n+            auto llunion_b_ptr = cx.build.GEP(bv, vec(C_int(0), C_int(1)));\n+            auto lldiscrim_b = cx.build.Load(lldiscrim_b_ptr);\n \n             auto unr_cx = new_sub_block_ctxt(cx, \"tag-iter-unr\");\n             unr_cx.build.Unreachable();\n \n-            auto llswitch = cx.build.Switch(lldiscrim, unr_cx.llbb,\n-                                            n_variants);\n+            auto llswitch = cx.build.Switch(lldiscrim_a, unr_cx.llbb,\n+                                             n_variants);\n \n             auto next_cx = new_sub_block_ctxt(cx, \"tag-iter-next\");\n \n             auto i = 0u;\n             for (ast.variant variant in variants) {\n-                auto variant_cx = new_sub_block_ctxt(cx, \"tag-iter-variant-\" +\n+                auto variant_cx = new_sub_block_ctxt(cx,\n+                                                     \"tag-iter-variant-\" +\n                                                      _uint.to_str(i, 10u));\n                 llvm.LLVMAddCase(llswitch, C_int(i as int), variant_cx.llbb);\n \n                 if (_vec.len[ast.variant_arg](variant.args) > 0u) {\n                     // N-ary variant.\n-                    let vec[ValueRef] vals = vec(C_int(0), C_int(1),\n-                                                 C_int(i as int));\n-                    auto llvar = variant_cx.build.GEP(v, vals);\n                     auto llvarty = type_of_variant(cx.fcx.ccx, variants.(i));\n \n                     auto fn_ty = ty.ann_to_type(variants.(i).ann);\n                     alt (fn_ty.struct) {\n                         case (ty.ty_fn(_, ?args, _)) {\n-                            auto llvarp = variant_cx.build.\n-                                TruncOrBitCast(llunion_ptr, T_ptr(llvarty));\n+                            auto llvarp_a = variant_cx.build.\n+                                TruncOrBitCast(llunion_a_ptr, T_ptr(llvarty));\n+\n+                            auto llvarp_b = variant_cx.build.\n+                                TruncOrBitCast(llunion_b_ptr, T_ptr(llvarty));\n \n                             auto ty_params = tag_ty_params(cx.fcx.ccx, tid);\n \n                             auto j = 0u;\n                             for (ty.arg a in args) {\n                                 auto v = vec(C_int(0), C_int(j as int));\n-                                auto llfldp = variant_cx.build.GEP(llvarp, v);\n+\n+                                auto llfldp_a =\n+                                    variant_cx.build.GEP(llvarp_a, v);\n+\n+                                auto llfldp_b =\n+                                    variant_cx.build.GEP(llvarp_b, v);\n \n                                 auto ty_subst = ty.substitute_ty_params(\n                                     ty_params, tps, a.ty);\n \n-                                auto llfld =\n+                                auto llfld_a =\n                                     load_scalar_or_boxed(variant_cx,\n-                                                         llfldp,\n+                                                         llfldp_a,\n                                                          ty_subst);\n \n-                                auto res = f(variant_cx, llfld, ty_subst);\n+                                auto llfld_b =\n+                                    load_scalar_or_boxed(variant_cx,\n+                                                         llfldp_b,\n+                                                         ty_subst);\n+\n+                                auto res = f(variant_cx,\n+                                             llfld_a, llfld_b, ty_subst);\n                                 variant_cx = res.bcx;\n                                 j += 1u;\n                             }\n@@ -1611,21 +1654,29 @@ fn iter_structural_ty(@block_ctxt cx,\n             ret res(next_cx, C_nil());\n         }\n         case (ty.ty_fn(_,_,_)) {\n-            auto box_cell =\n-                cx.build.GEP(v,\n+            auto box_cell_a =\n+                cx.build.GEP(av,\n+                             vec(C_int(0),\n+                                 C_int(abi.fn_field_box)));\n+            auto box_cell_b =\n+                cx.build.GEP(bv,\n                              vec(C_int(0),\n                                  C_int(abi.fn_field_box)));\n-            ret iter_boxpp(cx, box_cell, f);\n+            ret iter_boxpp(cx, box_cell_a, box_cell_b, f);\n         }\n         case (ty.ty_obj(_)) {\n-            auto box_cell =\n-                cx.build.GEP(v,\n+            auto box_cell_a =\n+                cx.build.GEP(av,\n+                             vec(C_int(0),\n+                                 C_int(abi.obj_field_box)));\n+            auto box_cell_b =\n+                cx.build.GEP(bv,\n                              vec(C_int(0),\n                                  C_int(abi.obj_field_box)));\n-            ret iter_boxpp(cx, box_cell, f);\n+            ret iter_boxpp(cx, box_cell_a, box_cell_b, f);\n         }\n         case (_) {\n-            cx.fcx.ccx.sess.unimpl(\"type in iter_structural_ty\");\n+            cx.fcx.ccx.sess.unimpl(\"type in iter_structural_ty_full\");\n         }\n     }\n     ret r;\n@@ -1965,21 +2016,47 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n         ret res(cx, trans_scalar_compare(cx, op, t, lhs, rhs));\n \n     } else if (ty.type_is_structural(t)) {\n-        auto scx = new_sub_block_ctxt(cx, \"structural compare body\");\n-        auto next = new_sub_block_ctxt(cx, \"structural compare completion\");\n+        auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n+        auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n         cx.build.Br(scx.llbb);\n \n         // Start with the assumptioin that our predicate holds.\n         auto flag = scx.build.Alloca(T_i1());\n         scx.build.Store(C_integral(1, T_i1()), flag);\n \n-        // Attempt to prove otherwise by inverting the sense of the comparison\n-        // on each inner element and bailing if any succeed.\n+        // Attempt to prove otherwise by assuming true, comparing each element\n+        // and writing 0 + early-exiting if any comparisons fail.\n+\n+        fn inner(@block_ctxt next_cx,\n+                 ValueRef flag,\n+                 ast.binop op,\n+                 @block_ctxt cx,\n+                 ValueRef av,\n+                 ValueRef bv,\n+                 @ty.t t) -> result {\n+            // Compare av op bv\n+            auto cnt_cx = new_sub_block_ctxt(cx, \"continue comparison\");\n+            auto stop_cx = new_sub_block_ctxt(cx, \"stop comparison\");\n+\n+            auto r = trans_compare(cx, op, t, av, bv);\n+\n+            // if true, then carry on, else write 0 to flag, branch to 'next'.\n+            r.bcx.build.CondBr(r.val, cnt_cx.llbb, stop_cx.llbb);\n+            stop_cx.build.Store(C_integral(0, T_i1()), flag);\n+            stop_cx.build.Br(next_cx.llbb);\n+\n+            ret res(cnt_cx, C_nil());\n+        }\n+\n+        // FIXME: this is wrong for tag types; need to confirm discriminants\n+        // are equal before blindly walking over elements.\n \n-        // FIXME: finish this.\n+        auto r = iter_structural_ty_full(scx, lhs, rhs, t,\n+                                         bind inner(next, flag, op,\n+                                                    _, _, _, _));\n \n-        auto v = scx.build.Load(flag);\n-        scx.build.Br(next.llbb);\n+        r.bcx.build.Br(next.llbb);\n+        auto v = next.build.Load(flag);\n         ret res(next, v);\n \n     } else {"}]}