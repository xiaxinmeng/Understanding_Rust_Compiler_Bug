{"sha": "80ef7243ea6e49b24a26185d198839b686419714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwZWY3MjQzZWE2ZTQ5YjI0YTI2MTg1ZDE5ODgzOWI2ODY0MTk3MTQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-13T03:17:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-14T22:59:32Z"}, "message": "Remove spawn_listener, spawn_conversation\n\nThese are not needed in a pipe-based Rustiverse", "tree": {"sha": "7a911655768b644cafd5112e6d11ab83bf9de20d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a911655768b644cafd5112e6d11ab83bf9de20d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80ef7243ea6e49b24a26185d198839b686419714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80ef7243ea6e49b24a26185d198839b686419714", "html_url": "https://github.com/rust-lang/rust/commit/80ef7243ea6e49b24a26185d198839b686419714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80ef7243ea6e49b24a26185d198839b686419714/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dff2853e4de3a7d2e69c6acfbf8c952026fe99aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/dff2853e4de3a7d2e69c6acfbf8c952026fe99aa", "html_url": "https://github.com/rust-lang/rust/commit/dff2853e4de3a7d2e69c6acfbf8c952026fe99aa"}], "stats": {"total": 149, "additions": 40, "deletions": 109}, "files": [{"sha": "d29eb8a98fd2a886573e34c9411e5b858d025723", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ef7243ea6e49b24a26185d198839b686419714/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/80ef7243ea6e49b24a26185d198839b686419714/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=80ef7243ea6e49b24a26185d198839b686419714", "patch": "@@ -461,7 +461,7 @@ and child both need to exchange messages with each other. The\n function `std::comm::DuplexStream()` supports this pattern.  We'll\n look briefly at how to use it.\n \n-To see how `spawn_conversation()` works, we will create a child task\n+To see how `DuplexStream()` works, we will create a child task\n that repeatedly receives a `uint` message, converts it to a string, and sends\n the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:"}, {"sha": "c024781c43018c99d8c178b33b11cb1d5ee99734", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=80ef7243ea6e49b24a26185d198839b686419714", "patch": "@@ -433,43 +433,6 @@ impl TaskBuilder {\n         }\n     }\n \n-    /**\n-     * Runs a new task while providing a channel from the parent to the child\n-     *\n-     * Sets up a communication channel from the current task to the new\n-     * child task, passes the port to child's body, and returns a channel\n-     * linked to the port to the parent.\n-     *\n-     * This encapsulates some boilerplate handshaking logic that would\n-     * otherwise be required to establish communication from the parent\n-     * to the child.\n-     */\n-    fn spawn_listener<A: Owned>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n-        let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(&setup_po);\n-        do self.spawn |move f| {\n-            let po = comm::Port();\n-            let ch = comm::Chan(&po);\n-            comm::send(setup_ch, ch);\n-            f(move po);\n-        }\n-        comm::recv(setup_po)\n-    }\n-\n-    /**\n-     * Runs a new task, setting up communication in both directions\n-     */\n-    fn spawn_conversation<A: Owned, B: Owned>\n-        (f: fn~(comm::Port<A>, comm::Chan<B>))\n-        -> (comm::Port<B>, comm::Chan<A>) {\n-        let from_child = comm::Port();\n-        let to_parent = comm::Chan(&from_child);\n-        let to_child = do self.spawn_listener |move f, from_parent| {\n-            f(from_parent, to_parent)\n-        };\n-        (from_child, to_child)\n-    }\n-\n     /**\n      * Execute a function in another task and return either the return value\n      * of the function or result::err.\n@@ -567,28 +530,6 @@ pub fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n     task().spawn_with(move arg, move f)\n }\n \n-pub fn spawn_listener<A:Owned>(f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n-    /*!\n-     * Runs a new task while providing a channel from the parent to the child\n-     *\n-     * This function is equivalent to `task().spawn_listener(f)`.\n-     */\n-\n-    task().spawn_listener(move f)\n-}\n-\n-pub fn spawn_conversation<A: Owned, B: Owned>\n-    (f: fn~(comm::Port<A>, comm::Chan<B>))\n-    -> (comm::Port<B>, comm::Chan<A>) {\n-    /*!\n-     * Runs a new task, setting up communication in both directions\n-     *\n-     * This function is equivalent to `task().spawn_conversation(f)`.\n-     */\n-\n-    task().spawn_conversation(move f)\n-}\n-\n pub fn spawn_sched(mode: SchedMode, f: fn~()) {\n     /*!\n      * Creates a new scheduler and executes a task on it\n@@ -926,34 +867,6 @@ fn test_back_to_the_future_result() {\n     let _ = task().future_result(util::ignore).future_result(util::ignore);\n }\n \n-#[test]\n-fn test_spawn_listiner_bidi() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    let ch = do spawn_listener |po| {\n-        // Now the child has a port called 'po' to read from and\n-        // an environment-captured channel called 'ch'.\n-        let res: ~str = comm::recv(po);\n-        assert res == ~\"ping\";\n-        comm::send(ch, ~\"pong\");\n-    };\n-    // Likewise, the parent has both a 'po' and 'ch'\n-    comm::send(ch, ~\"ping\");\n-    let res: ~str = comm::recv(po);\n-    assert res == ~\"pong\";\n-}\n-\n-#[test]\n-fn test_spawn_conversation() {\n-    let (recv_str, send_int) = do spawn_conversation |recv_int, send_str| {\n-        let input = comm::recv(recv_int);\n-        let output = int::str(input);\n-        comm::send(send_str, move output);\n-    };\n-    comm::send(send_int, 1);\n-    assert comm::recv(recv_str) == ~\"1\";\n-}\n-\n #[test]\n fn test_try_success() {\n     match do try {\n@@ -1115,15 +1028,6 @@ fn test_avoid_copying_the_body_spawn() {\n     avoid_copying_the_body(spawn);\n }\n \n-#[test]\n-fn test_avoid_copying_the_body_spawn_listener() {\n-    do avoid_copying_the_body |f| {\n-        spawn_listener(fn~(move f, _po: comm::Port<int>) {\n-            f();\n-        });\n-    }\n-}\n-\n #[test]\n fn test_avoid_copying_the_body_task_spawn() {\n     do avoid_copying_the_body |f| {\n@@ -1133,15 +1037,6 @@ fn test_avoid_copying_the_body_task_spawn() {\n     }\n }\n \n-#[test]\n-fn test_avoid_copying_the_body_spawn_listener_1() {\n-    do avoid_copying_the_body |f| {\n-        task().spawn_listener(fn~(move f, _po: comm::Port<int>) {\n-            f();\n-        });\n-    }\n-}\n-\n #[test]\n fn test_avoid_copying_the_body_try() {\n     do avoid_copying_the_body |f| {"}, {"sha": "827db4211c495273851b3c43f74f08702588e2f6", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=80ef7243ea6e49b24a26185d198839b686419714", "patch": "@@ -64,7 +64,7 @@ pub fn from_file<T>(file: ~str, owner: SrvOwner<T>) -> T {\n fn run<T>(owner: SrvOwner<T>, source: ~str, +parse: Parser) -> T {\n \n     let srv_ = Srv({\n-        ch: do task::spawn_listener |move parse, po| {\n+        ch: do util::spawn_listener |move parse, po| {\n             act(po, source, parse);\n         }\n     });"}, {"sha": "4bcb7c64ad0cf7ee297a7719cc972e1b353feda2", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=80ef7243ea6e49b24a26185d198839b686419714", "patch": "@@ -39,7 +39,7 @@ fn run(\n         return doc;\n     }\n \n-    let (result_port, page_chan) = do task::spawn_conversation\n+    let (result_port, page_chan) = do util::spawn_conversation\n         |page_port, result_chan| {\n         comm::send(result_chan, make_doc_from_pages(page_port));\n     };"}, {"sha": "e1c810b19a4465318eb62e1fde216efdc37af58b", "filename": "src/librustdoc/util.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibrustdoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ef7243ea6e49b24a26185d198839b686419714/src%2Flibrustdoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Futil.rs?ref=80ef7243ea6e49b24a26185d198839b686419714", "patch": "@@ -17,3 +17,26 @@ impl<T: Copy> NominalOp<T>: Clone {\n     fn clone(&self) -> NominalOp<T> { copy *self }\n }\n \n+pub fn spawn_listener<A: Owned>(\n+    +f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+    let setup_po = comm::Port();\n+    let setup_ch = comm::Chan(&setup_po);\n+    do task::spawn |move f| {\n+        let po = comm::Port();\n+        let ch = comm::Chan(&po);\n+        comm::send(setup_ch, ch);\n+        f(move po);\n+    }\n+    comm::recv(setup_po)\n+}\n+\n+pub fn spawn_conversation<A: Owned, B: Owned>\n+    (+f: fn~(comm::Port<A>, comm::Chan<B>))\n+    -> (comm::Port<B>, comm::Chan<A>) {\n+    let from_child = comm::Port();\n+    let to_parent = comm::Chan(&from_child);\n+    let to_child = do spawn_listener |move f, from_parent| {\n+        f(from_parent, to_parent)\n+    };\n+    (from_child, to_child)\n+}"}, {"sha": "d36e8daf376a6534d1ff6ca1933716d43c581a6d", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80ef7243ea6e49b24a26185d198839b686419714/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80ef7243ea6e49b24a26185d198839b686419714/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=80ef7243ea6e49b24a26185d198839b686419714", "patch": "@@ -131,6 +131,19 @@ fn creature(\n }\n \n fn rendezvous(nn: uint, set: ~[color]) {\n+\n+    pub fn spawn_listener<A: Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n+        let setup_po = comm::Port();\n+        let setup_ch = comm::Chan(&setup_po);\n+        do task::spawn |move f| {\n+            let po = comm::Port();\n+            let ch = comm::Chan(&po);\n+            comm::send(setup_ch, ch);\n+            f(move po);\n+        }\n+        comm::recv(setup_po)\n+    }\n+\n     // these ports will allow us to hear from the creatures\n     let from_creatures:     comm::Port<creature_info> = comm::Port();\n     let from_creatures_log: comm::Port<~str> = comm::Port();\n@@ -146,7 +159,7 @@ fn rendezvous(nn: uint, set: ~[color]) {\n             // give us a channel to talk to each\n             let ii = ii;\n             let col = *col;\n-            do task::spawn_listener |from_rendezvous, move ii, move col| {\n+            do spawn_listener |from_rendezvous, move ii, move col| {\n                 creature(ii, col, from_rendezvous, to_rendezvous,\n                          to_rendezvous_log);\n             }"}]}