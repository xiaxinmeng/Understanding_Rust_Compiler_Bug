{"sha": "653ce3e52575ef716390b93a180d3db0728a67a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1M2NlM2U1MjU3NWVmNzE2MzkwYjkzYTE4MGQzZGIwNzI4YTY3YTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-30T15:05:46Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-30T15:05:46Z"}, "message": "Rollup merge of #33867 - oli-obk:rustdoc_variant_types, r=GuillaumeGomez\n\nprint enum variant fields in docs\n\nRight now we are repeating enum variants at the top, because the fields aren't shown with the actual docs. It's very annoying to have to scroll up and down to have both docs and field info. For struct variants we already list the fields.\n\nenum docs look like this after this PR:\n\n![screenshot from 2016-05-25 14-02-42](https://cloud.githubusercontent.com/assets/332036/15539231/84b018cc-2281-11e6-9666-1063655931f4.png)\n\nThere are degenerate cases for enum tuple variants with lots of fields:\n\n![screenshot from 2016-05-25 14-01-00](https://cloud.githubusercontent.com/assets/332036/15539260/91e537ca-2281-11e6-8bf1-a3d6b2e78f65.png)\n\nI was thinking that we could move the docs below the variant (slightly indented) or list the variant fields vertically instead of horizontally\n\nr? @steveklabnik", "tree": {"sha": "90fff5b0c616293f1d430a642b8af4ca96e00899", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90fff5b0c616293f1d430a642b8af4ca96e00899"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/653ce3e52575ef716390b93a180d3db0728a67a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/653ce3e52575ef716390b93a180d3db0728a67a0", "html_url": "https://github.com/rust-lang/rust/commit/653ce3e52575ef716390b93a180d3db0728a67a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/653ce3e52575ef716390b93a180d3db0728a67a0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5da602bda3f30a8943dd4d10383bae6d8a77575c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5da602bda3f30a8943dd4d10383bae6d8a77575c", "html_url": "https://github.com/rust-lang/rust/commit/5da602bda3f30a8943dd4d10383bae6d8a77575c"}, {"sha": "b0c703304204f21ab6964d4b37776e7e5015cf7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c703304204f21ab6964d4b37776e7e5015cf7b", "html_url": "https://github.com/rust-lang/rust/commit/b0c703304204f21ab6964d4b37776e7e5015cf7b"}], "stats": {"total": 105, "additions": 65, "deletions": 40}, "files": [{"sha": "a5449b748dd5e98c2434bb2d86774f21bd9a62d4", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=653ce3e52575ef716390b93a180d3db0728a67a0", "patch": "@@ -117,6 +117,7 @@\n from htmlentitydefs import entitydefs\n entitydefs['larrb'] = u'\\u21e4'\n entitydefs['rarrb'] = u'\\u21e5'\n+entitydefs['nbsp'] = ' '\n \n # \"void elements\" (no closing tag) from the HTML Standard section 12.1.2\n VOID_ELEMENTS = set(['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',"}, {"sha": "92401a5c55ffd058c06c963648d2d9d1589b9f7d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=653ce3e52575ef716390b93a180d3db0728a67a0", "patch": "@@ -111,27 +111,27 @@ impl fmt::Display for clean::Generics {\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n             if i > 0 {\n-                f.write_str(\", \")?;\n+                f.write_str(\",&nbsp;\")?;\n             }\n             write!(f, \"{}\", *life)?;\n         }\n \n         if !self.type_params.is_empty() {\n             if !self.lifetimes.is_empty() {\n-                f.write_str(\", \")?;\n+                f.write_str(\",&nbsp;\")?;\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n                 if i > 0 {\n-                    f.write_str(\", \")?\n+                    f.write_str(\",&nbsp;\")?\n                 }\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {\n-                    write!(f, \": {}\", TyParamBounds(&tp.bounds))?;\n+                    write!(f, \":&nbsp;{}\", TyParamBounds(&tp.bounds))?;\n                 }\n \n                 match tp.default {\n-                    Some(ref ty) => { write!(f, \" = {}\", ty)?; },\n+                    Some(ref ty) => { write!(f, \"&nbsp;=&nbsp;{}\", ty)?; },\n                     None => {}\n                 };\n             }\n@@ -229,21 +229,21 @@ impl fmt::Display for clean::PathParameters {\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n                         if comma {\n-                            f.write_str(\", \")?;\n+                            f.write_str(\",&nbsp;\")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *lifetime)?;\n                     }\n                     for ty in types {\n                         if comma {\n-                            f.write_str(\", \")?;\n+                            f.write_str(\",&nbsp;\")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *ty)?;\n                     }\n                     for binding in bindings {\n                         if comma {\n-                            f.write_str(\", \")?;\n+                            f.write_str(\",&nbsp;\")?;\n                         }\n                         comma = true;\n                         write!(f, \"{}\", *binding)?;"}, {"sha": "396f71173f83451a24d43b3c071f06299dafe30f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=653ce3e52575ef716390b93a180d3db0728a67a0", "patch": "@@ -2243,26 +2243,24 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"</pre>\")?;\n \n     document(w, cx, it)?;\n-    let mut fields = s.fields.iter().filter(|f| {\n+    let mut fields = s.fields.iter().filter_map(|f| {\n         match f.inner {\n-            clean::StructFieldItem(..) => true,\n-            _ => false,\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n         }\n     }).peekable();\n     if let doctree::Plain = s.struct_type {\n         if fields.peek().is_some() {\n-            write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\")?;\n-            for field in fields {\n-                write!(w, \"<tr class='stab {stab}'>\n-                             <td id='{shortty}.{name}'>\\\n-                               <code>{name}</code></td><td>\",\n+            write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+            for (field, ty) in fields {\n+                write!(w, \"<span id='{shortty}.{name}'><code>{name}: {ty}</code></span>\n+                           <span class='stab {stab}'></span>\",\n                        shortty = ItemType::StructField,\n                        stab = field.stability_class(),\n-                       name = field.name.as_ref().unwrap())?;\n+                       name = field.name.as_ref().unwrap(),\n+                       ty = ty)?;\n                 document(w, cx, field)?;\n-                write!(w, \"</td></tr>\")?;\n             }\n-            write!(w, \"</table>\")?;\n         }\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n@@ -2292,7 +2290,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                             write!(w, \"{}(\", name)?;\n                             for (i, ty) in tys.iter().enumerate() {\n                                 if i > 0 {\n-                                    write!(w, \", \")?\n+                                    write!(w, \",&nbsp;\")?\n                                 }\n                                 write!(w, \"{}\", *ty)?;\n                             }\n@@ -2324,40 +2322,47 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     document(w, cx, it)?;\n     if !e.variants.is_empty() {\n-        write!(w, \"<h2 class='variants'>Variants</h2>\\n<table class='variants_table'>\")?;\n+        write!(w, \"<h2 class='variants'>Variants</h2>\\n\")?;\n         for variant in &e.variants {\n-            write!(w, \"<tr><td id='{shortty}.{name}'><code>{name}</code></td><td>\",\n+            write!(w, \"<span id='{shortty}.{name}' class='variant'><code>{name}\",\n                    shortty = ItemType::Variant,\n                    name = variant.name.as_ref().unwrap())?;\n+            if let clean::VariantItem(ref var) = variant.inner {\n+                if let clean::TupleVariant(ref tys) = var.kind {\n+                    write!(w, \"(\")?;\n+                    for (i, ty) in tys.iter().enumerate() {\n+                        if i > 0 {\n+                            write!(w, \",&nbsp;\")?;\n+                        }\n+                        write!(w, \"{}\", *ty)?;\n+                    }\n+                    write!(w, \")\")?;\n+                }\n+            }\n+            write!(w, \"</code></span>\")?;\n             document(w, cx, variant)?;\n \n             use clean::{Variant, StructVariant};\n             if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n-                let fields = s.fields.iter().filter(|f| {\n-                    match f.inner {\n-                        clean::StructFieldItem(..) => true,\n-                        _ => false,\n-                    }\n-                });\n                 write!(w, \"<h3 class='fields'>Fields</h3>\\n\n                            <table>\")?;\n-                for field in fields {\n-                    write!(w, \"<tr><td \\\n-                               id='{shortty}.{v}.field.{f}'>\\\n-                               <code>{f}</code></td><td>\",\n-                           shortty = ItemType::Variant,\n-                           v = variant.name.as_ref().unwrap(),\n-                           f = field.name.as_ref().unwrap())?;\n-                    document(w, cx, field)?;\n-                    write!(w, \"</td></tr>\")?;\n+                for field in &s.fields {\n+                    use clean::StructFieldItem;\n+                    if let StructFieldItem(ref ty) = field.inner {\n+                        write!(w, \"<tr><td \\\n+                                   id='variant.{v}.field.{f}'>\\\n+                                   <code>{f}:&nbsp;{t}</code></td><td>\",\n+                               v = variant.name.as_ref().unwrap(),\n+                               f = field.name.as_ref().unwrap(),\n+                               t = *ty)?;\n+                        document(w, cx, field)?;\n+                        write!(w, \"</td></tr>\")?;\n+                    }\n                 }\n                 write!(w, \"</table>\")?;\n             }\n-            write!(w, \"</td><td>\")?;\n             render_stability_since(w, variant, it)?;\n-            write!(w, \"</td></tr>\")?;\n         }\n-        write!(w, \"</table>\")?;\n     }\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)?;\n     Ok(())"}, {"sha": "bfe3f7b8dd69d9bc55440b8cea402d11a34ce51f", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/653ce3e52575ef716390b93a180d3db0728a67a0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=653ce3e52575ef716390b93a180d3db0728a67a0", "patch": "@@ -265,6 +265,10 @@ nav.sub {\n .docblock h2 { font-size: 1.15em; }\n .docblock h3, .docblock h4, .docblock h5 { font-size: 1em; }\n \n+.docblock {\n+    margin-left: 24px;\n+}\n+\n .content .out-of-band {\n     font-size: 23px;\n     margin: 0px;\n@@ -640,6 +644,21 @@ span.since {\n     margin-right: 5px;\n }\n \n+.enum > .toggle-wrapper > .collapse-toggle, .struct > .toggle-wrapper > .collapse-toggle {\n+    left: 0;\n+    margin-top: 5px;\n+}\n+\n+.enum > .toggle-wrapper + .docblock, .struct > .toggle-wrapper + .docblock {\n+    margin-left: 30px;\n+    margin-bottom: 20px;\n+    margin-top: 5px;\n+}\n+\n+.enum > .collapsed, .struct > .collapsed {\n+    margin-bottom: 25px;\n+}\n+\n :target > code {\n    background: #FDFFD3;\n }"}]}