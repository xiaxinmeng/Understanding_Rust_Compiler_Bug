{"sha": "4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb", "node_id": "C_kwDOAAsO6NoAKDRmNzYwNWI2ZmRiODFjMWY1YmU2MjQ0NmY1NmIyNWE3Y2JhYThlZWI", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2021-11-30T23:04:49Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2021-12-01T01:25:30Z"}, "message": "Add `RemoveUninitDrops` MIR pass", "tree": {"sha": "44bc72ada37296bedc9e058084de96f5b0cde46e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44bc72ada37296bedc9e058084de96f5b0cde46e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb", "html_url": "https://github.com/rust-lang/rust/commit/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7077073648041ec505629b2f1df9ab800c422e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7077073648041ec505629b2f1df9ab800c422e2", "html_url": "https://github.com/rust-lang/rust/commit/d7077073648041ec505629b2f1df9ab800c422e2"}], "stats": {"total": 172, "additions": 172, "deletions": 0}, "files": [{"sha": "b9d670e651cd47331712e2fe6d10ee6d07be29a7", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb", "patch": "@@ -63,6 +63,7 @@ mod nrvo;\n mod remove_false_edges;\n mod remove_noop_landing_pads;\n mod remove_storage_markers;\n+mod remove_uninit_drops;\n mod remove_unneeded_drops;\n mod remove_zsts;\n mod required_consts;"}, {"sha": "c219f2673244144721a172cd4486de71716457a4", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=4f7605b6fdb81c1f5be62446f56b25a7cbaa8eeb", "patch": "@@ -0,0 +1,171 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::{Body, Field, Rvalue, Statement, StatementKind, TerminatorKind};\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, VariantDef};\n+use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n+use rustc_mir_dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n+use rustc_mir_dataflow::{self, move_path_children_matching, Analysis, MoveDataParamEnv};\n+\n+use crate::MirPass;\n+\n+/// Removes `Drop` and `DropAndReplace` terminators whose target is known to be uninitialized at\n+/// that point.\n+///\n+/// This is redundant with drop elaboration, but we need to do it prior to const-checking, and\n+/// running const-checking after drop elaboration makes it opimization dependent, causing issues\n+/// like [#90770].\n+///\n+/// [#90770]: https://github.com/rust-lang/rust/issues/90770\n+pub struct RemoveUninitDrops;\n+\n+impl<'tcx> MirPass<'tcx> for RemoveUninitDrops {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let param_env = tcx.param_env(body.source.def_id());\n+        let Ok(move_data) = MoveData::gather_moves(body, tcx, param_env) else {\n+            // We could continue if there are move errors, but there's not much point since our\n+            // init data isn't complete.\n+            return;\n+        };\n+\n+        let mdpe = MoveDataParamEnv { move_data, param_env };\n+        let mut maybe_inits = MaybeInitializedPlaces::new(tcx, body, &mdpe)\n+            .into_engine(tcx, body)\n+            .pass_name(\"remove_uninit_drops\")\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(body);\n+\n+        let mut to_remove = vec![];\n+        for (bb, block) in body.basic_blocks().iter_enumerated() {\n+            let terminator = block.terminator();\n+            let (TerminatorKind::Drop { place, .. } | TerminatorKind::DropAndReplace { place, .. })\n+                = &terminator.kind\n+            else { continue };\n+\n+            maybe_inits.seek_before_primary_effect(body.terminator_loc(bb));\n+\n+            // If there's no move path for the dropped place, it's probably a `Deref`. Let it alone.\n+            let LookupResult::Exact(mpi) = mdpe.move_data.rev_lookup.find(place.as_ref()) else {\n+                continue;\n+            };\n+\n+            let should_keep = is_needs_drop_and_init(\n+                tcx,\n+                param_env,\n+                maybe_inits.get(),\n+                &mdpe.move_data,\n+                place.ty(body, tcx).ty,\n+                mpi,\n+            );\n+            if !should_keep {\n+                to_remove.push(bb)\n+            }\n+        }\n+\n+        for bb in to_remove {\n+            let block = &mut body.basic_blocks_mut()[bb];\n+\n+            let (TerminatorKind::Drop { target, .. } | TerminatorKind::DropAndReplace { target, .. })\n+                = &block.terminator().kind\n+            else { unreachable!() };\n+\n+            // Replace block terminator with `Goto`.\n+            let target = *target;\n+            let old_terminator_kind = std::mem::replace(\n+                &mut block.terminator_mut().kind,\n+                TerminatorKind::Goto { target },\n+            );\n+\n+            // If this is a `DropAndReplace`, we need to emulate the assignment to the return place.\n+            if let TerminatorKind::DropAndReplace { place, value, .. } = old_terminator_kind {\n+                block.statements.push(Statement {\n+                    source_info: block.terminator().source_info,\n+                    kind: StatementKind::Assign(Box::new((place, Rvalue::Use(value)))),\n+                });\n+            }\n+        }\n+    }\n+}\n+\n+fn is_needs_drop_and_init(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    maybe_inits: &BitSet<MovePathIndex>,\n+    move_data: &MoveData<'tcx>,\n+    ty: Ty<'tcx>,\n+    mpi: MovePathIndex,\n+) -> bool {\n+    // No need to look deeper if the root is definitely uninit or if it has no `Drop` impl.\n+    if !maybe_inits.contains(mpi) || !ty.needs_drop(tcx, param_env) {\n+        return false;\n+    }\n+\n+    let field_needs_drop_and_init = |(f, f_ty, mpi)| {\n+        let child = move_path_children_matching(move_data, mpi, |x| x.is_field_to(f));\n+        let Some(mpi) = child else {\n+            return f_ty.needs_drop(tcx, param_env);\n+        };\n+\n+        is_needs_drop_and_init(tcx, param_env, maybe_inits, move_data, f_ty, mpi)\n+    };\n+\n+    // This pass is only needed for const-checking, so it doesn't handle as many cases as\n+    // `DropCtxt::open_drop`, since they aren't relevant in a const-context.\n+    match ty.kind() {\n+        ty::Adt(adt, substs) => {\n+            let dont_elaborate = adt.is_union() || adt.is_manually_drop() || adt.has_dtor(tcx);\n+            if dont_elaborate {\n+                return true;\n+            }\n+\n+            // Look at all our fields, or if we are an enum all our variants and their fields.\n+            //\n+            // If a field's projection *is not* present in `MoveData`, it has the same\n+            // initializedness as its parent (maybe init).\n+            //\n+            // If its projection *is* present in `MoveData`, then the field may have been moved\n+            // from separate from its parent. Recurse.\n+            adt.variants.iter_enumerated().any(|(vid, variant)| {\n+                // Enums have multiple variants, which are discriminated with a `Downcast` projection.\n+                // Structs have a single variant, and don't use a `Downcast` projection.\n+                let mpi = if adt.is_enum() {\n+                    let downcast =\n+                        move_path_children_matching(move_data, mpi, |x| x.is_downcast_to(vid));\n+                    let Some(dc_mpi) = downcast else {\n+                        return variant_needs_drop(tcx, param_env, substs, variant);\n+                    };\n+\n+                    dc_mpi\n+                } else {\n+                    mpi\n+                };\n+\n+                variant\n+                    .fields\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(f, field)| (Field::from_usize(f), field.ty(tcx, substs), mpi))\n+                    .any(field_needs_drop_and_init)\n+            })\n+        }\n+\n+        ty::Tuple(_) => ty\n+            .tuple_fields()\n+            .enumerate()\n+            .map(|(f, f_ty)| (Field::from_usize(f), f_ty, mpi))\n+            .any(field_needs_drop_and_init),\n+\n+        _ => true,\n+    }\n+}\n+\n+fn variant_needs_drop(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    substs: SubstsRef<'tcx>,\n+    variant: &VariantDef,\n+) -> bool {\n+    variant.fields.iter().any(|field| {\n+        let f_ty = field.ty(tcx, substs);\n+        f_ty.needs_drop(tcx, param_env)\n+    })\n+}"}]}