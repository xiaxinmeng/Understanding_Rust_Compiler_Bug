{"sha": "a10d8e458118b3feac96fe5e56c25e70cee99b88", "node_id": "C_kwDOAAsO6NoAKGExMGQ4ZTQ1ODExOGIzZmVhYzk2ZmU1ZTU2YzI1ZTcwY2VlOTliODg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-17T15:40:34Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-20T21:09:22Z"}, "message": "rename get_global_alloc to try_get_global_alloc", "tree": {"sha": "be9b0977aa7211e91e41fdad6da4d1e65e989213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be9b0977aa7211e91e41fdad6da4d1e65e989213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a10d8e458118b3feac96fe5e56c25e70cee99b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a10d8e458118b3feac96fe5e56c25e70cee99b88", "html_url": "https://github.com/rust-lang/rust/commit/a10d8e458118b3feac96fe5e56c25e70cee99b88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a10d8e458118b3feac96fe5e56c25e70cee99b88/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da5e4d73f192b5c0faa357992e6b6c61707ae592", "url": "https://api.github.com/repos/rust-lang/rust/commits/da5e4d73f192b5c0faa357992e6b6c61707ae592", "html_url": "https://github.com/rust-lang/rust/commit/da5e4d73f192b5c0faa357992e6b6c61707ae592"}], "stats": {"total": 54, "additions": 32, "deletions": 22}, "files": [{"sha": "a1508d7c72b424985efb78ad47ac7d072069e93b", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -362,7 +362,7 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n         let (data_id, alloc, section_name) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n                 //println!(\"alloc_id {}\", alloc_id);\n-                let alloc = match tcx.get_global_alloc(alloc_id).unwrap() {\n+                let alloc = match tcx.global_alloc(alloc_id) {\n                     GlobalAlloc::Memory(alloc) => alloc,\n                     GlobalAlloc::Function(_) | GlobalAlloc::Static(_) | GlobalAlloc::Vtable(..) => {\n                         unreachable!()"}, {"sha": "fc2e6652a3d72267811bf589cec5aa9fd18df404", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -369,7 +369,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 // we don't deallocate it.\n                 let (alloc_id, _, _) = ecx.ptr_get_alloc_id(ptr)?;\n                 let is_allocated_in_another_const = matches!(\n-                    ecx.tcx.get_global_alloc(alloc_id),\n+                    ecx.tcx.try_get_global_alloc(alloc_id),\n                     Some(interpret::GlobalAlloc::Memory(_))\n                 );\n "}, {"sha": "948c33494982612b87deff77f037e21879caabdd", "filename": "compiler/rustc_const_eval/src/const_eval/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmod.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -138,7 +138,7 @@ pub(crate) fn deref_mir_constant<'tcx>(\n     let mplace = ecx.deref_operand(&op).unwrap();\n     if let Some(alloc_id) = mplace.ptr.provenance {\n         assert_eq!(\n-            tcx.get_global_alloc(alloc_id).unwrap().unwrap_memory().0.0.mutability,\n+            tcx.global_alloc(alloc_id).unwrap_memory().0.0.mutability,\n             Mutability::Not,\n             \"deref_mir_constant cannot be used with mutable allocations as \\\n             that could allow pattern matching to observe mutable statics\","}, {"sha": "23526edcc343aa92bf2138743066f45225a84aa2", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -94,7 +94,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n         // to validation to error -- it has the much better error messages, pointing out where\n         // in the value the dangling reference lies.\n         // The `delay_span_bug` ensures that we don't forget such a check in validation.\n-        if tcx.get_global_alloc(alloc_id).is_none() {\n+        if tcx.try_get_global_alloc(alloc_id).is_none() {\n             tcx.sess.delay_span_bug(ecx.tcx.span, \"tried to intern dangling pointer\");\n         }\n         // treat dangling pointers like other statics\n@@ -454,7 +454,7 @@ pub fn intern_const_alloc_recursive<\n                 .sess\n                 .span_err(ecx.tcx.span, \"encountered dangling pointer in final constant\");\n             return Err(reported);\n-        } else if ecx.tcx.get_global_alloc(alloc_id).is_none() {\n+        } else if ecx.tcx.try_get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n             // marked as dangling by local memory.  That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);"}, {"sha": "0287c180e94b603d3622cbd5c3e69f44d6c8e3cd", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -161,7 +161,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc_id = ptr.provenance;\n         // We need to handle `extern static`.\n-        match self.tcx.get_global_alloc(alloc_id) {\n+        match self.tcx.try_get_global_alloc(alloc_id) {\n             Some(GlobalAlloc::Static(def_id)) if self.tcx.is_thread_local_static(def_id) => {\n                 bug!(\"global memory cannot point to thread-local static\")\n             }\n@@ -289,7 +289,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let Some((alloc_kind, mut alloc)) = self.memory.alloc_map.remove(&alloc_id) else {\n             // Deallocating global memory -- always an error\n-            return Err(match self.tcx.get_global_alloc(alloc_id) {\n+            return Err(match self.tcx.try_get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n                     err_ub_format!(\"deallocating {alloc_id:?}, which is a function\")\n                 }\n@@ -478,7 +478,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         id: AllocId,\n         is_write: bool,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::Provenance, M::AllocExtra>>> {\n-        let (alloc, def_id) = match self.tcx.get_global_alloc(id) {\n+        let (alloc, def_id) = match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Memory(mem)) => {\n                 // Memory of a constant or promoted or anonymous memory referenced by a static.\n                 (mem, None)\n@@ -669,7 +669,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // # Statics\n         // Can't do this in the match argument, we may get cycle errors since the lock would\n         // be held throughout the match.\n-        match self.tcx.get_global_alloc(id) {\n+        match self.tcx.try_get_global_alloc(id) {\n             Some(GlobalAlloc::Static(did)) => {\n                 assert!(!self.tcx.is_thread_local_static(did));\n                 // Use size and align of the type.\n@@ -715,7 +715,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         if let Some(extra) = self.memory.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n-            match self.tcx.get_global_alloc(id) {\n+            match self.tcx.try_get_global_alloc(id) {\n                 Some(GlobalAlloc::Function(instance)) => Some(FnVal::Instance(instance)),\n                 _ => None,\n             }\n@@ -839,7 +839,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                 }\n                 None => {\n                     // global alloc\n-                    match self.ecx.tcx.get_global_alloc(id) {\n+                    match self.ecx.tcx.try_get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             write!(fmt, \" (unchanged global, \")?;\n                             write_allocation_track_relocs("}, {"sha": "569af01c4853ad2413dc655e17e5d4c80ad2239e", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -447,7 +447,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // `!` is a ZST and we want to validate it.\n             if let Ok((alloc_id, _offset, _prov)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n-                let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n+                let alloc_kind = self.ecx.tcx.try_get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n                     assert!(!self.ecx.tcx.is_thread_local_static(did));\n                     assert!(self.ecx.tcx.is_static(did));"}, {"sha": "9b0fe593cfc88d497ac16bceb2569e2647861c1b", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -312,7 +312,9 @@ impl<'s> AllocDecodingSession<'s> {\n                                 State::InProgress(TinyList::new_single(self.session_id), alloc_id);\n                             Some(alloc_id)\n                         }\n-                        AllocDiscriminant::Fn | AllocDiscriminant::Static | AllocDiscriminant::Vtable => {\n+                        AllocDiscriminant::Fn\n+                        | AllocDiscriminant::Static\n+                        | AllocDiscriminant::Vtable => {\n                             // Fns and statics cannot be cyclic, and their `AllocId`\n                             // is determined later by interning.\n                             *entry =\n@@ -366,7 +368,8 @@ impl<'s> AllocDecodingSession<'s> {\n                     assert!(alloc_id.is_none());\n                     trace!(\"creating static alloc ID\");\n                     let ty = <Ty<'_> as Decodable<D>>::decode(decoder);\n-                    let poly_trait_ref = <Option<ty::PolyExistentialTraitRef<'_>> as Decodable<D>>::decode(decoder);\n+                    let poly_trait_ref =\n+                        <Option<ty::PolyExistentialTraitRef<'_>> as Decodable<D>>::decode(decoder);\n                     trace!(\"decoded vtable alloc instance: {ty:?}, {poly_trait_ref:?}\");\n                     let alloc_id = decoder.interner().create_vtable_alloc(ty, poly_trait_ref);\n                     alloc_id\n@@ -533,7 +536,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Generates an `AllocId` for a (symbolic, not-reified) vtable.  Will get deduplicated.\n-    pub fn create_vtable_alloc(self, ty: Ty<'tcx>, poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>) -> AllocId {\n+    pub fn create_vtable_alloc(\n+        self,\n+        ty: Ty<'tcx>,\n+        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    ) -> AllocId {\n         self.reserve_and_set_dedup(GlobalAlloc::Vtable(ty, poly_trait_ref))\n     }\n \n@@ -554,7 +561,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get_global_alloc(self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+    pub fn try_get_global_alloc(self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n         self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n@@ -565,7 +572,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// ids), this function is frequently used throughout rustc, but should not be used within\n     /// the miri engine.\n     pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n-        match self.get_global_alloc(id) {\n+        match self.try_get_global_alloc(id) {\n             Some(alloc) => alloc,\n             None => bug!(\"could not find allocation for {id:?}\"),\n         }"}, {"sha": "013b67ea2b9693473e83e79632d7ae87bcd6eab4", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -720,12 +720,14 @@ pub fn write_allocations<'tcx>(\n                 write!(w, \"{}\", display_allocation(tcx, alloc.inner()))\n             };\n         write!(w, \"\\n{id:?}\")?;\n-        match tcx.get_global_alloc(id) {\n+        match tcx.try_get_global_alloc(id) {\n             // This can't really happen unless there are bugs, but it doesn't cost us anything to\n             // gracefully handle it and allow buggy rustc to be debugged via allocation printing.\n             None => write!(w, \" (deallocated)\")?,\n             Some(GlobalAlloc::Function(inst)) => write!(w, \" (fn: {inst})\")?,\n-            Some(GlobalAlloc::Vtable(ty, Some(trait_ref))) => write!(w, \" (vtable: impl {trait_ref} for {ty})\")?,\n+            Some(GlobalAlloc::Vtable(ty, Some(trait_ref))) => {\n+                write!(w, \" (vtable: impl {trait_ref} for {ty})\")?\n+            }\n             Some(GlobalAlloc::Vtable(ty, None)) => write!(w, \" (vtable: impl ? for {ty})\")?,\n             Some(GlobalAlloc::Static(did)) if !tcx.is_foreign_item(did) => {\n                 match tcx.eval_static_initializer(did) {"}, {"sha": "263d64a57776affd1575c165a450ee65a88d188a", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -147,7 +147,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            tcx.get_global_alloc(*self).hash_stable(hcx, hasher);\n+            tcx.try_get_global_alloc(*self).hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "43abed847e00024115aa0e2540ad5a9593553b9e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a10d8e458118b3feac96fe5e56c25e70cee99b88/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=a10d8e458118b3feac96fe5e56c25e70cee99b88", "patch": "@@ -1269,7 +1269,7 @@ pub trait PrettyPrinter<'tcx>:\n                 if let ty::Array(elem, len) = inner.kind() {\n                     if let ty::Uint(ty::UintTy::U8) = elem.kind() {\n                         if let ty::ConstKind::Value(ty::ValTree::Leaf(int)) = len.kind() {\n-                            match self.tcx().get_global_alloc(alloc_id) {\n+                            match self.tcx().try_get_global_alloc(alloc_id) {\n                                 Some(GlobalAlloc::Memory(alloc)) => {\n                                     let len = int.assert_bits(self.tcx().data_layout.pointer_size);\n                                     let range =\n@@ -1298,7 +1298,8 @@ pub trait PrettyPrinter<'tcx>:\n             ty::FnPtr(_) => {\n                 // FIXME: We should probably have a helper method to share code with the \"Byte strings\"\n                 // printing above (which also has to handle pointers to all sorts of things).\n-                if let Some(GlobalAlloc::Function(instance)) = self.tcx().get_global_alloc(alloc_id)\n+                if let Some(GlobalAlloc::Function(instance)) =\n+                    self.tcx().try_get_global_alloc(alloc_id)\n                 {\n                     self = self.typed_value(\n                         |this| this.print_value_path(instance.def_id(), instance.substs),"}]}