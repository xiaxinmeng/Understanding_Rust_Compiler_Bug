{"sha": "2f575dab3030467525acae204e47f7a9a8311530", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNTc1ZGFiMzAzMDQ2NzUyNWFjYWUyMDRlNDdmN2E5YTgzMTE1MzA=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-29T12:32:37Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-01-30T12:58:33Z"}, "message": "Add missing links for cmp traits", "tree": {"sha": "356c9572b9c18e93f76bb031180bfb00d458a828", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/356c9572b9c18e93f76bb031180bfb00d458a828"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f575dab3030467525acae204e47f7a9a8311530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f575dab3030467525acae204e47f7a9a8311530", "html_url": "https://github.com/rust-lang/rust/commit/2f575dab3030467525acae204e47f7a9a8311530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f575dab3030467525acae204e47f7a9a8311530/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "320ada6479b3e29c7d9a66bc56ac44c2d2b57566", "url": "https://api.github.com/repos/rust-lang/rust/commits/320ada6479b3e29c7d9a66bc56ac44c2d2b57566", "html_url": "https://github.com/rust-lang/rust/commit/320ada6479b3e29c7d9a66bc56ac44c2d2b57566"}], "stats": {"total": 51, "additions": 31, "deletions": 20}, "files": [{"sha": "e41a7afd3e223a4f840c8a5b5dd14d9d690df050", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f575dab3030467525acae204e47f7a9a8311530/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f575dab3030467525acae204e47f7a9a8311530/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=2f575dab3030467525acae204e47f7a9a8311530", "patch": "@@ -35,7 +35,7 @@ use self::Ordering::*;\n ///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n-/// so floating point types implement `PartialEq` but not `Eq`.\n+/// so floating point types implement `PartialEq` but not [`Eq`].\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n@@ -55,12 +55,12 @@ use self::Ordering::*;\n ///\n /// ## How can I implement `PartialEq`?\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n-/// in terms of it by default. Any manual implementation of `ne` *must* respect\n-/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// `PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\n+/// in terms of it by default. Any manual implementation of [`ne`] *must* respect\n+/// the rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n+/// Implementations of `PartialEq`, [`PartialOrd`], and [`Ord`] *must* agree with\n /// each other. It's easy to accidentally make them disagree by deriving some\n /// of the traits and manually implementing others.\n ///\n@@ -190,6 +190,9 @@ use self::Ordering::*;\n /// assert_eq!(x == y, false);\n /// assert_eq!(x.eq(&y), false);\n /// ```\n+///\n+/// [`eq`]: PartialEq::eq\n+/// [`ne`]: PartialEq::ne\n #[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"==\")]\n@@ -233,7 +236,7 @@ pub macro PartialEq($item:item) {\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n /// This property cannot be checked by the compiler, and therefore `Eq` implies\n-/// `PartialEq`, and has no extra methods.\n+/// [`PartialEq`], and has no extra methods.\n ///\n /// ## Derivable\n ///\n@@ -370,6 +373,7 @@ impl Ordering {\n     /// Chains two orderings.\n     ///\n     /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -442,10 +446,12 @@ impl Ordering {\n \n /// A helper struct for reverse ordering.\n ///\n-/// This struct is a helper to be used with functions like `Vec::sort_by_key` and\n+/// This struct is a helper to be used with functions like [`Vec::sort_by_key`] and\n /// can be used to reverse order a part of a key.\n ///\n-/// Example usage:\n+/// [`Vec::sort_by_key`]: ../../std/vec/struct.Vec.html#method.sort_by_key\n+///\n+/// # Examples\n ///\n /// ```\n /// use std::cmp::Reverse;\n@@ -506,12 +512,12 @@ impl<T: Ord> Ord for Reverse<T> {\n ///\n /// ## How can I implement `Ord`?\n ///\n-/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n+/// `Ord` requires that the type also be [`PartialOrd`] and [`Eq`] (which requires [`PartialEq`]).\n ///\n-/// Then you must define an implementation for `cmp()`. You may find it useful to use\n-/// `cmp()` on your type's fields.\n+/// Then you must define an implementation for [`cmp`]. You may find it useful to use\n+/// [`cmp`] on your type's fields.\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must*\n+/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must*\n /// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n /// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n /// all `a` and `b`. It's easy to accidentally make them disagree by\n@@ -548,13 +554,15 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n+///\n+/// [`cmp`]: Ord::cmp\n #[doc(alias = \"<\")]\n #[doc(alias = \">\")]\n #[doc(alias = \"<=\")]\n #[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n-    /// This method returns an `Ordering` between `self` and `other`.\n+    /// This method returns an [`Ordering`] between `self` and `other`.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n     /// `self <operator> other` if true.\n@@ -689,20 +697,20 @@ impl PartialOrd for Ordering {\n ///\n /// ## How can I implement `PartialOrd`?\n ///\n-/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n+/// `PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others\n /// generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n-/// `PartialOrd` requires your type to be `PartialEq`.\n+/// `PartialOrd` requires your type to be [`PartialEq`].\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// Implementations of [`PartialEq`], `PartialOrd`, and [`Ord`] *must* agree with each other. It's\n /// easy to accidentally make them disagree by deriving some of the traits and manually\n /// implementing others.\n ///\n-/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n+/// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n ///\n /// ```\n /// use std::cmp::Ordering;\n@@ -733,7 +741,7 @@ impl PartialOrd for Ordering {\n /// }\n /// ```\n ///\n-/// You may also find it useful to use `partial_cmp()` on your type's fields. Here\n+/// You may also find it useful to use [`partial_cmp`] on your type's fields. Here\n /// is an example of `Person` types who have a floating-point `height` field that\n /// is the only field to be used for sorting:\n ///\n@@ -768,6 +776,9 @@ impl PartialOrd for Ordering {\n /// assert_eq!(x < y, true);\n /// assert_eq!(x.lt(&y), true);\n /// ```\n+///\n+/// [`partial_cmp`]: PartialOrd::partial_cmp\n+/// [`cmp`]: Ord::cmp\n #[lang = \"partial_ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \">\")]\n@@ -893,7 +904,7 @@ pub macro PartialOrd($item:item) {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n ///\n-/// Internally uses an alias to `Ord::min`.\n+/// Internally uses an alias to [`Ord::min`].\n ///\n /// # Examples\n ///\n@@ -956,7 +967,7 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n ///\n-/// Internally uses an alias to `Ord::max`.\n+/// Internally uses an alias to [`Ord::max`].\n ///\n /// # Examples\n ///"}]}