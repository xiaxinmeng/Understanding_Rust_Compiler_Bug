{"sha": "268cbfeb88b4c13425d47910d3424c85b4c96462", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2OGNiZmViODhiNGMxMzQyNWQ0NzkxMGQzNDI0Yzg1YjRjOTY0NjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T09:13:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-16T09:13:14Z"}, "message": "Auto merge of #79682 - jyn514:no-blanket-impls, r=Manishearth,GuillaumeGomez\n\nDon't look for blanket impls in intra-doc links\n\nThis never worked and has been causing severe performance problems.\nHopefully it will be re-landed at some point in the future when it\nactually works, but in the meantime it makes no sense to have the code\naround when it does nothing and actively makes rustdoc harder to use.\n\nCloses https://github.com/rust-lang/rust/issues/78761. Does *not* affect https://github.com/rust-lang/rust/issues/78800.\n\nr? `@Manishearth`\ncc `@seeplusplus`", "tree": {"sha": "05a01c59ac185e6da0bd7c0b5818d7c7d4b27b1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a01c59ac185e6da0bd7c0b5818d7c7d4b27b1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/268cbfeb88b4c13425d47910d3424c85b4c96462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/268cbfeb88b4c13425d47910d3424c85b4c96462", "html_url": "https://github.com/rust-lang/rust/commit/268cbfeb88b4c13425d47910d3424c85b4c96462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/268cbfeb88b4c13425d47910d3424c85b4c96462/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ddbc6176de780987025c2cf22eb63922bc0c6253", "url": "https://api.github.com/repos/rust-lang/rust/commits/ddbc6176de780987025c2cf22eb63922bc0c6253", "html_url": "https://github.com/rust-lang/rust/commit/ddbc6176de780987025c2cf22eb63922bc0c6253"}, {"sha": "6580f11a5239296d55c717fbe54fa2f71b861469", "url": "https://api.github.com/repos/rust-lang/rust/commits/6580f11a5239296d55c717fbe54fa2f71b861469", "html_url": "https://github.com/rust-lang/rust/commit/6580f11a5239296d55c717fbe54fa2f71b861469"}], "stats": {"total": 94, "additions": 15, "deletions": 79}, "files": [{"sha": "dbdcd68810b593da0f63ae7794165d952b2fb363", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/268cbfeb88b4c13425d47910d3424c85b4c96462/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268cbfeb88b4c13425d47910d3424c85b4c96462/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=268cbfeb88b4c13425d47910d3424c85b4c96462", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::ty::{AssocKind, TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n@@ -375,15 +375,6 @@ impl ItemKind {\n             _ => false,\n         }\n     }\n-\n-    crate fn as_assoc_kind(&self) -> Option<AssocKind> {\n-        match *self {\n-            ItemKind::AssocConstItem(..) => Some(AssocKind::Const),\n-            ItemKind::AssocTypeItem(..) => Some(AssocKind::Type),\n-            ItemKind::TyMethodItem(..) | ItemKind::MethodItem(..) => Some(AssocKind::Fn),\n-            _ => None,\n-        }\n-    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "f9d81fb863538bebef46f99ae14ba4f7ca1eefd5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 14, "deletions": 69, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/268cbfeb88b4c13425d47910d3424c85b4c96462/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268cbfeb88b4c13425d47910d3424c85b4c96462/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=268cbfeb88b4c13425d47910d3424c85b4c96462", "patch": "@@ -31,7 +31,7 @@ use std::cell::Cell;\n use std::mem;\n use std::ops::Range;\n \n-use crate::clean::{self, Crate, GetDefId, Item, ItemLink, PrimitiveType};\n+use crate::clean::{self, Crate, Item, ItemLink, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::markdown_links;\n@@ -685,78 +685,23 @@ fn resolve_associated_trait_item(\n     ns: Namespace,\n     cx: &DocContext<'_>,\n ) -> Option<(ty::AssocKind, DefId)> {\n-    let ty = cx.tcx.type_of(did);\n-    // First consider blanket impls: `impl From<T> for T`\n-    let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n-    let mut candidates: Vec<_> = implicit_impls\n-        .flat_map(|impl_outer| {\n-            match impl_outer.kind {\n-                clean::ImplItem(impl_) => {\n-                    debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n-                    // Give precedence to methods that were overridden\n-                    if !impl_.provided_trait_methods.contains(&*item_name.as_str()) {\n-                        let mut items = impl_.items.into_iter().filter_map(|assoc| {\n-                            if assoc.name != Some(item_name) {\n-                                return None;\n-                            }\n-                            let kind = assoc\n-                                .kind\n-                                .as_assoc_kind()\n-                                .expect(\"inner items for a trait should be associated items\");\n-                            if kind.namespace() != ns {\n-                                return None;\n-                            }\n-\n-                            trace!(\"considering associated item {:?}\", assoc.kind);\n-                            // We have a slight issue: normal methods come from `clean` types,\n-                            // but provided methods come directly from `tcx`.\n-                            // Fortunately, we don't need the whole method, we just need to know\n-                            // what kind of associated item it is.\n-                            Some((kind, assoc.def_id))\n-                        });\n-                        let assoc = items.next();\n-                        debug_assert_eq!(items.count(), 0);\n-                        assoc\n-                    } else {\n-                        // These are provided methods or default types:\n-                        // ```\n-                        // trait T {\n-                        //   type A = usize;\n-                        //   fn has_default() -> A { 0 }\n-                        // }\n-                        // ```\n-                        let trait_ = impl_.trait_.unwrap().def_id().unwrap();\n-                        cx.tcx\n-                            .associated_items(trait_)\n-                            .find_by_name_and_namespace(\n-                                cx.tcx,\n-                                Ident::with_dummy_span(item_name),\n-                                ns,\n-                                trait_,\n-                            )\n-                            .map(|assoc| (assoc.kind, assoc.def_id))\n-                    }\n-                }\n-                _ => panic!(\"get_impls returned something that wasn't an impl\"),\n-            }\n-        })\n-        .collect();\n+    // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n+    // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n+    // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n-    if candidates.is_empty() {\n-        let traits = traits_implemented_by(cx, did, module);\n-        debug!(\"considering traits {:?}\", traits);\n-        candidates.extend(traits.iter().filter_map(|&trait_| {\n-            cx.tcx\n-                .associated_items(trait_)\n-                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n-                .map(|assoc| (assoc.kind, assoc.def_id))\n-        }));\n-    }\n+    let traits = traits_implemented_by(cx, did, module);\n+    debug!(\"considering traits {:?}\", traits);\n+    let mut candidates = traits.iter().filter_map(|&trait_| {\n+        cx.tcx\n+            .associated_items(trait_)\n+            .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n+            .map(|assoc| (assoc.kind, assoc.def_id))\n+    });\n     // FIXME(#74563): warn about ambiguity\n-    debug!(\"the candidates were {:?}\", candidates);\n-    candidates.pop()\n+    debug!(\"the candidates were {:?}\", candidates.clone().collect::<Vec<_>>());\n+    candidates.next()\n }\n \n /// Given a type, return all traits in scope in `module` implemented by that type."}]}