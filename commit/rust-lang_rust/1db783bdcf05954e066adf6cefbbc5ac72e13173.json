{"sha": "1db783bdcf05954e066adf6cefbbc5ac72e13173", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkYjc4M2JkY2YwNTk1NGUwNjZhZGY2Y2VmYmJjNWFjNzJlMTMxNzM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-16T03:37:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:21:56Z"}, "message": "Finish implementing io::net::addrinfo\n\nThis fills in the `hints` structure and exposes libuv's full functionality for\ndoing dns lookups.", "tree": {"sha": "3452ba6c392a17b576c8a4c91807e1fb12a68ce7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3452ba6c392a17b576c8a4c91807e1fb12a68ce7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1db783bdcf05954e066adf6cefbbc5ac72e13173", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1db783bdcf05954e066adf6cefbbc5ac72e13173", "html_url": "https://github.com/rust-lang/rust/commit/1db783bdcf05954e066adf6cefbbc5ac72e13173", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1db783bdcf05954e066adf6cefbbc5ac72e13173/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bac96818580a97c049532e50702c2a8204e11754", "url": "https://api.github.com/repos/rust-lang/rust/commits/bac96818580a97c049532e50702c2a8204e11754", "html_url": "https://github.com/rust-lang/rust/commit/bac96818580a97c049532e50702c2a8204e11754"}], "stats": {"total": 354, "additions": 262, "deletions": 92}, "files": [{"sha": "ae0d542acbe47eaba4f946fe77aea5a451b5c477", "filename": "src/libstd/rt/io/net/addrinfo.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Faddrinfo.rs?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Synchronous DNS Resolution\n+\n+Contains the functionality to perform DNS resolution in a style related to\n+getaddrinfo()\n+\n+*/\n+\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n+use rt::io::io_error;\n+use rt::io::net::ip::{SocketAddr, IpAddr};\n+use rt::rtio::{IoFactory, IoFactoryObject};\n+use rt::local::Local;\n+\n+/// Hints to the types of sockets that are desired when looking up hosts\n+pub enum SocketType {\n+    Stream, Datagram, Raw\n+}\n+\n+/// Flags which can be or'd into the `flags` field of a `Hint`. These are used\n+/// to manipulate how a query is performed.\n+///\n+/// The meaning of each of these flags can be found with `man -s 3 getaddrinfo`\n+pub enum Flag {\n+    AddrConfig,\n+    All,\n+    CanonName,\n+    NumericHost,\n+    NumericServ,\n+    Passive,\n+    V4Mapped,\n+}\n+\n+/// A transport protocol associated with either a hint or a return value of\n+/// `lookup`\n+pub enum Protocol {\n+    TCP, UDP\n+}\n+\n+/// This structure is used to provide hints when fetching addresses for a\n+/// remote host to control how the lookup is performed.\n+///\n+/// For details on these fields, see their corresponding definitions via\n+/// `man -s 3 getaddrinfo`\n+pub struct Hint {\n+    family: uint,\n+    socktype: Option<SocketType>,\n+    protocol: Option<Protocol>,\n+    flags: uint,\n+}\n+\n+pub struct Info {\n+    address: SocketAddr,\n+    family: uint,\n+    socktype: Option<SocketType>,\n+    protocol: Option<Protocol>,\n+    flags: uint,\n+}\n+\n+/// Easy name resolution. Given a hostname, returns the list of IP addresses for\n+/// that hostname.\n+///\n+/// # Failure\n+///\n+/// On failure, this will raise on the `io_error` condition.\n+pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n+    lookup(Some(host), None, None).map(|a| a.map(|i| i.address.ip))\n+}\n+\n+/// Full-fleged resolution. This function will perform a synchronous call to\n+/// getaddrinfo, controlled by the parameters\n+///\n+/// # Arguments\n+///\n+/// * hostname - an optional hostname to lookup against\n+/// * servname - an optional service name, listed in the system services\n+/// * hint - see the hint structure, and \"man -s 3 getaddrinfo\", for how this\n+///          controls lookup\n+///\n+/// # Failure\n+///\n+/// On failure, this will raise on the `io_error` condition.\n+pub fn lookup(hostname: Option<&str>, servname: Option<&str>,\n+              hint: Option<Hint>) -> Option<~[Info]> {\n+    let ipaddrs = unsafe {\n+        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n+        (*io).get_host_addresses(hostname, servname, hint)\n+    };\n+\n+    match ipaddrs {\n+        Ok(i) => Some(i),\n+        Err(ioerr) => {\n+            io_error::cond.raise(ioerr);\n+            None\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use option::Some;\n+    use rt::io::net::ip::Ipv4Addr;\n+    use super::*;\n+\n+    #[test]\n+    fn dns_smoke_test() {\n+        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n+        let mut found_local = false;\n+        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n+        for addr in ipaddrs.iter() {\n+            found_local = found_local || addr == local_addr;\n+        }\n+        assert!(found_local);\n+    }\n+}"}, {"sha": "cf109167089d40ca6581ce6bdade64927d65dfc0", "filename": "src/libstd/rt/io/net/mod.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fmod.rs?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -8,55 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option, Some, None};\n-use result::{Ok, Err};\n-use rt::io::io_error;\n-use rt::io::net::ip::IpAddr;\n-use rt::rtio::{IoFactory, IoFactoryObject};\n-use rt::local::Local;\n+pub use self::addrinfo::get_host_addresses;\n \n+pub mod addrinfo;\n pub mod tcp;\n pub mod udp;\n pub mod ip;\n #[cfg(unix)]\n pub mod unix;\n-\n-/// Simplistic name resolution\n-pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n-    /*!\n-     * Get the IP addresses for a given host name.\n-     *\n-     * Raises io_error on failure.\n-     */\n-\n-    let ipaddrs = unsafe {\n-        let io: *mut IoFactoryObject = Local::unsafe_borrow();\n-        (*io).get_host_addresses(host)\n-    };\n-\n-    match ipaddrs {\n-        Ok(i) => Some(i),\n-        Err(ioerr) => {\n-            io_error::cond.raise(ioerr);\n-            None\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use option::Some;\n-    use rt::io::net::ip::Ipv4Addr;\n-    use super::*;\n-\n-    #[test]\n-    fn dns_smoke_test() {\n-        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n-        let mut found_local = false;\n-        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n-        for addr in ipaddrs.iter() {\n-            found_local = found_local || addr == local_addr;\n-        }\n-        assert!(found_local);\n-    }\n-}"}, {"sha": "4a290ca46e50e196efdf7638cbb8055f373ec146", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -13,6 +13,7 @@ use option::*;\n use result::*;\n use libc::c_int;\n \n+use ai = rt::io::net::addrinfo;\n use rt::io::IoError;\n use super::io::process::ProcessConfig;\n use super::io::net::ip::{IpAddr, SocketAddr};\n@@ -80,7 +81,8 @@ pub trait IoFactory {\n     fn fs_open<P: PathLike>(&mut self, path: &P, fm: FileMode, fa: FileAccess)\n         -> Result<~RtioFileStream, IoError>;\n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n-    fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError>;\n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError>;\n     fn fs_stat<P: PathLike>(&mut self, path: &P) -> Result<FileStat, IoError>;\n     fn fs_mkdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n     fn fs_rmdir<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;"}, {"sha": "7556d7db665efca313d2808b77e6b18014ce6641", "filename": "src/libstd/rt/uv/addrinfo.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Faddrinfo.rs?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -18,9 +18,10 @@ use rt::uv::uvll;\n use rt::uv::uvll::UV_GETADDRINFO;\n use rt::uv::{Loop, UvError, NativeHandle};\n use rt::uv::status_to_maybe_uv_error;\n-use rt::uv::net::UvAddrInfo;\n+use rt::uv::net;\n+use ai = rt::io::net::addrinfo;\n \n-type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &UvAddrInfo, Option<UvError>);\n+type GetAddrInfoCallback = ~fn(GetAddrInfoRequest, &net::UvAddrInfo, Option<UvError>);\n \n pub struct GetAddrInfoRequest(*uvll::uv_getaddrinfo_t);\n \n@@ -38,7 +39,7 @@ impl GetAddrInfoRequest {\n     }\n \n     pub fn getaddrinfo(&mut self, loop_: &Loop, node: Option<&str>,\n-                       service: Option<&str>, hints: Option<UvAddrInfo>,\n+                       service: Option<&str>, hints: Option<ai::Hint>,\n                        cb: GetAddrInfoCallback) {\n \n         assert!(node.is_some() || service.is_some());\n@@ -72,8 +73,37 @@ impl GetAddrInfoRequest {\n             cb(req, addrinfo, err)\n         };\n \n-        // XXX: Implement hints\n-        assert!(hints.is_none());\n+        let hint = hints.map(|hint| unsafe {\n+            let mut flags = 0;\n+            do each_ai_flag |cval, aival| {\n+                if hint.flags & (aival as uint) != 0 {\n+                    flags |= cval as i32;\n+                }\n+            }\n+            let socktype = match hint.socktype {\n+                Some(ai::Stream) => uvll::rust_SOCK_STREAM(),\n+                Some(ai::Datagram) => uvll::rust_SOCK_DGRAM(),\n+                Some(ai::Raw) => uvll::rust_SOCK_RAW(),\n+                None => 0,\n+            };\n+            let protocol = match hint.protocol {\n+                Some(ai::UDP) => uvll::rust_IPPROTO_UDP(),\n+                Some(ai::TCP) => uvll::rust_IPPROTO_TCP(),\n+                _ => 0,\n+            };\n+\n+            uvll::addrinfo {\n+                ai_flags: flags,\n+                ai_family: hint.family as c_int,\n+                ai_socktype: socktype,\n+                ai_protocol: protocol,\n+                ai_addrlen: 0,\n+                ai_canonname: null(),\n+                ai_addr: null(),\n+                ai_next: null(),\n+            }\n+        });\n+        let hint_ptr = hint.as_ref().map_default(null(), |x| x as *uvll::addrinfo);\n \n         self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n \n@@ -83,15 +113,15 @@ impl GetAddrInfoRequest {\n                                            getaddrinfo_cb,\n                                            c_node_ptr,\n                                            c_service_ptr,\n-                                           null()));\n+                                           hint_ptr));\n         }\n \n         extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n                                      status: c_int,\n                                      res: *uvll::addrinfo) {\n             let mut req: GetAddrInfoRequest = NativeHandle::from_native_handle(req);\n             let err = status_to_maybe_uv_error(status);\n-            let addrinfo = UvAddrInfo(res);\n+            let addrinfo = net::UvAddrInfo(res);\n             let data = req.get_req_data();\n             (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n             unsafe {\n@@ -137,6 +167,66 @@ impl GetAddrInfoRequest {\n     }\n }\n \n+fn each_ai_flag(f: &fn(c_int, ai::Flag)) {\n+    unsafe {\n+        f(uvll::rust_AI_ADDRCONFIG(), ai::AddrConfig);\n+        f(uvll::rust_AI_ALL(), ai::All);\n+        f(uvll::rust_AI_CANONNAME(), ai::CanonName);\n+        f(uvll::rust_AI_NUMERICHOST(), ai::NumericHost);\n+        f(uvll::rust_AI_NUMERICSERV(), ai::NumericServ);\n+        f(uvll::rust_AI_PASSIVE(), ai::Passive);\n+        f(uvll::rust_AI_V4MAPPED(), ai::V4Mapped);\n+    }\n+}\n+\n+// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n+pub fn accum_addrinfo(addr: &net::UvAddrInfo) -> ~[ai::Info] {\n+    unsafe {\n+        let &net::UvAddrInfo(addr) = addr;\n+        let mut addr = addr;\n+\n+        let mut addrs = ~[];\n+        loop {\n+            let uvaddr = net::sockaddr_to_UvSocketAddr((*addr).ai_addr);\n+            let rustaddr = net::uv_socket_addr_to_socket_addr(uvaddr);\n+\n+            let mut flags = 0;\n+            do each_ai_flag |cval, aival| {\n+                if (*addr).ai_flags & cval != 0 {\n+                    flags |= aival as uint;\n+                }\n+            }\n+\n+            let protocol = match (*addr).ai_protocol {\n+                p if p == uvll::rust_IPPROTO_UDP() => Some(ai::UDP),\n+                p if p == uvll::rust_IPPROTO_TCP() => Some(ai::TCP),\n+                _ => None,\n+            };\n+            let socktype = match (*addr).ai_socktype {\n+                p if p == uvll::rust_SOCK_STREAM() => Some(ai::Stream),\n+                p if p == uvll::rust_SOCK_DGRAM() => Some(ai::Datagram),\n+                p if p == uvll::rust_SOCK_RAW() => Some(ai::Raw),\n+                _ => None,\n+            };\n+\n+            addrs.push(ai::Info {\n+                address: rustaddr,\n+                family: (*addr).ai_family as uint,\n+                socktype: socktype,\n+                protocol: protocol,\n+                flags: flags,\n+            });\n+            if (*addr).ai_next.is_not_null() {\n+                addr = (*addr).ai_next;\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        return addrs;\n+    }\n+}\n+\n impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n     fn from_native_handle(handle: *uvll::uv_getaddrinfo_t) -> GetAddrInfoRequest {\n         GetAddrInfoRequest(handle)\n@@ -150,7 +240,6 @@ impl NativeHandle<*uvll::uv_getaddrinfo_t> for GetAddrInfoRequest {\n mod test {\n     use option::{Some, None};\n     use rt::uv::Loop;\n-    use rt::uv::net::accum_sockaddrs;\n     use rt::io::net::ip::{SocketAddr, Ipv4Addr};\n     use super::*;\n \n@@ -159,14 +248,14 @@ mod test {\n         let mut loop_ = Loop::new();\n         let mut req = GetAddrInfoRequest::new();\n         do req.getaddrinfo(&loop_, Some(\"localhost\"), None, None) |_, addrinfo, _| {\n-            let sockaddrs = accum_sockaddrs(addrinfo);\n+            let sockaddrs = accum_addrinfo(addrinfo);\n             let mut found_local = false;\n             let local_addr = &SocketAddr {\n                 ip: Ipv4Addr(127, 0, 0, 1),\n                 port: 0\n             };\n             for addr in sockaddrs.iter() {\n-                found_local = found_local || addr == local_addr;\n+                found_local = found_local || addr.address == *local_addr;\n             }\n             assert!(found_local);\n         }"}, {"sha": "e2f2510c48781cb7a64a3dd6b32b57206cd69688", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -27,7 +27,7 @@ pub enum UvSocketAddr {\n     UvIpv6SocketAddr(*sockaddr_in6),\n }\n \n-fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n+pub fn sockaddr_to_UvSocketAddr(addr: *uvll::sockaddr) -> UvSocketAddr {\n     unsafe {\n         assert!((is_ip4_addr(addr) || is_ip6_addr(addr)));\n         assert!(!(is_ip4_addr(addr) && is_ip6_addr(addr)));\n@@ -96,28 +96,6 @@ pub fn uv_socket_addr_to_socket_addr(addr: UvSocketAddr) -> SocketAddr {\n     uv_socket_addr_as_socket_addr(addr, util::id)\n }\n \n-// Traverse the addrinfo linked list, producing a vector of Rust socket addresses\n-pub fn accum_sockaddrs(addr: &UvAddrInfo) -> ~[SocketAddr] {\n-    unsafe {\n-        let &UvAddrInfo(addr) = addr;\n-        let mut addr = addr;\n-\n-        let mut addrs = ~[];\n-        loop {\n-            let uvaddr = sockaddr_to_UvSocketAddr((*addr).ai_addr);\n-            let rustaddr = uv_socket_addr_to_socket_addr(uvaddr);\n-            addrs.push(rustaddr);\n-            if (*addr).ai_next.is_not_null() {\n-                addr = (*addr).ai_next;\n-            } else {\n-                break;\n-            }\n-        }\n-\n-        return addrs;\n-    }\n-}\n-\n #[cfg(test)]\n #[test]\n fn test_ip4_conversion() {\n@@ -232,13 +210,13 @@ impl StreamWatcher {\n             data.connect_cb = Some(cb);\n         }\n \n-        unsafe {\n+        return unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n             match uvll::listen(self.native_handle(), BACKLOG, connection_cb) {\n                 0 => Ok(()),\n                 n => Err(UvError(n))\n             }\n-        }\n+        };\n \n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n@@ -466,12 +444,12 @@ impl NativeHandle<*uvll::uv_udp_t> for UdpWatcher {\n }\n \n // uv_connect_t is a subclass of uv_req_t\n-struct ConnectRequest(*uvll::uv_connect_t);\n+pub struct ConnectRequest(*uvll::uv_connect_t);\n impl Request for ConnectRequest { }\n \n impl ConnectRequest {\n \n-    fn new() -> ConnectRequest {\n+    pub fn new() -> ConnectRequest {\n         let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n         assert!(connect_handle.is_not_null());\n         ConnectRequest(connect_handle as *uvll::uv_connect_t)"}, {"sha": "bc9be40cde5630e44ab14e85fd575c548c20c601", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -32,8 +32,8 @@ use rt::tube::Tube;\n use rt::task::SchedHome;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n-use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr, accum_sockaddrs};\n-use rt::uv::addrinfo::GetAddrInfoRequest;\n+use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n+use rt::uv::addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n use unstable::sync::Exclusive;\n use path::{GenericPath, Path};\n use super::super::io::support::PathLike;\n@@ -43,6 +43,7 @@ use rt::io::{FileMode, FileAccess, OpenOrCreate, Open, Create,\n              CreateOrTruncate, Append, Truncate, Read, Write, ReadWrite,\n              FileStat};\n use task;\n+use ai = rt::io::net::addrinfo;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -658,23 +659,27 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn get_host_addresses(&mut self, host: &str) -> Result<~[IpAddr], IoError> {\n+    fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n+                          hint: Option<ai::Hint>) -> Result<~[ai::Info], IoError> {\n         let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~[IpAddr], IoError>> = &result_cell;\n-        let host_ptr: *&str = &host;\n+        let result_cell_ptr: *Cell<Result<~[ai::Info], IoError>> = &result_cell;\n+        let host_ptr: *Option<&str> = &host;\n+        let servname_ptr: *Option<&str> = &servname;\n+        let hint_ptr: *Option<ai::Hint> = &hint;\n         let addrinfo_req = GetAddrInfoRequest::new();\n         let addrinfo_req_cell = Cell::new(addrinfo_req);\n+\n         do task::unkillable { // FIXME(#8674)\n             let scheduler: ~Scheduler = Local::take();\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let task_cell = Cell::new(task);\n                 let mut addrinfo_req = addrinfo_req_cell.take();\n                 unsafe {\n                     do addrinfo_req.getaddrinfo(self.uv_loop(),\n-                                                Some(*host_ptr),\n-                                                None, None) |_, addrinfo, err| {\n+                                                *host_ptr, *servname_ptr,\n+                                                *hint_ptr) |_, addrinfo, err| {\n                         let res = match err {\n-                            None => Ok(accum_sockaddrs(addrinfo).map(|addr| addr.ip.clone())),\n+                            None => Ok(accum_addrinfo(addrinfo)),\n                             Some(err) => Err(uv_error_to_io_error(err))\n                         };\n                         (*result_cell_ptr).put_back(res);"}, {"sha": "29d0800237b6bc14e6ed6052346ec8aa75ba4fb2", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/1db783bdcf05954e066adf6cefbbc5ac72e13173/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=1db783bdcf05954e066adf6cefbbc5ac72e13173", "patch": "@@ -637,3 +637,16 @@ extern \"C\" int\n rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n   return uv_pipe_init(loop, p, ipc);\n }\n+\n+extern \"C\" int rust_SOCK_STREAM()  { return SOCK_STREAM; }\n+extern \"C\" int rust_SOCK_DGRAM()  { return SOCK_DGRAM; }\n+extern \"C\" int rust_SOCK_RAW()  { return SOCK_RAW; }\n+extern \"C\" int rust_IPPROTO_UDP()  { return IPPROTO_UDP; }\n+extern \"C\" int rust_IPPROTO_TCP()  { return IPPROTO_TCP; }\n+extern \"C\" int rust_AI_ADDRCONFIG()  { return AI_ADDRCONFIG; }\n+extern \"C\" int rust_AI_ALL()  { return AI_ALL; }\n+extern \"C\" int rust_AI_CANONNAME()  { return AI_CANONNAME; }\n+extern \"C\" int rust_AI_NUMERICHOST()  { return AI_NUMERICHOST; }\n+extern \"C\" int rust_AI_NUMERICSERV()  { return AI_NUMERICSERV; }\n+extern \"C\" int rust_AI_PASSIVE()  { return AI_PASSIVE; }\n+extern \"C\" int rust_AI_V4MAPPED()  { return AI_V4MAPPED; }"}]}