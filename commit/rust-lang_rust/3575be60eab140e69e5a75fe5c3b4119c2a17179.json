{"sha": "3575be60eab140e69e5a75fe5c3b4119c2a17179", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NzViZTYwZWFiMTQwZTY5ZTVhNzVmZTVjM2I0MTE5YzJhMTcxNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-03T03:13:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-03T03:13:43Z"}, "message": "Auto merge of #51319 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #51143 (Specify that packed types must derive, not implement, Copy)\n - #51226 (Make Layout's align a NonZeroUsize)\n - #51297 (Fix run button style)\n - #51306 (impl Default for &mut str)\n - #51312 (Clarify the difference between get_mut and into_mut for OccupiedEntry)\n - #51313 (use type name in E0599 enum variant suggestion)\n\nFailed merges:", "tree": {"sha": "d34f9307f8f807c7dfad8d81bac4e5fc5fffabb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d34f9307f8f807c7dfad8d81bac4e5fc5fffabb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3575be60eab140e69e5a75fe5c3b4119c2a17179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3575be60eab140e69e5a75fe5c3b4119c2a17179", "html_url": "https://github.com/rust-lang/rust/commit/3575be60eab140e69e5a75fe5c3b4119c2a17179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3575be60eab140e69e5a75fe5c3b4119c2a17179/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "251ec62a134824c1b8c01671a2d05aa793839232", "url": "https://api.github.com/repos/rust-lang/rust/commits/251ec62a134824c1b8c01671a2d05aa793839232", "html_url": "https://github.com/rust-lang/rust/commit/251ec62a134824c1b8c01671a2d05aa793839232"}, {"sha": "c09cad1f28135d019231c171d631e608c7b39f0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c09cad1f28135d019231c171d631e608c7b39f0e", "html_url": "https://github.com/rust-lang/rust/commit/c09cad1f28135d019231c171d631e608c7b39f0e"}], "stats": {"total": 156, "additions": 99, "deletions": 57}, "files": [{"sha": "9b6f91c039feaa471360c47a83fa452d2cd95694", "filename": "src/liballoc/btree/map.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Fliballoc%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Fliballoc%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fmap.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -2369,6 +2369,11 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n+    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// destruction of the `Entry` value, see [`into_mut`].\n+    ///\n+    /// [`into_mut`]: #method.into_mut\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2380,9 +2385,13 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], 12);\n     /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///      *o.get_mut() += 10;\n+    ///     *o.get_mut() += 10;\n+    ///     assert_eq!(*o.get(), 22);\n+    ///\n+    ///     // We can use the same Entry multiple times.\n+    ///     *o.get_mut() += 2;\n     /// }\n-    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// assert_eq!(map[\"poneyland\"], 24);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n@@ -2391,6 +2400,10 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n     /// Converts the entry into a mutable reference to its value.\n     ///\n+    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: #method.get_mut\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "75306ac82dfd5df1e0131ec2315580af534265e0", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -1326,6 +1326,7 @@ fn test_str_default() {\n \n     t::<&str>();\n     t::<String>();\n+    t::<&mut str>();\n }\n \n #[test]"}, {"sha": "229758803c87071e1d4497b6a69c0f50113e496f", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 43, "deletions": 37, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -20,6 +20,7 @@ use fmt;\n use mem;\n use usize;\n use ptr::{self, NonNull};\n+use num::NonZeroUsize;\n \n extern {\n     /// An opaque, unsized type. Used for pointers to allocated memory.\n@@ -66,7 +67,7 @@ fn size_align<T>() -> (usize, usize) {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Layout {\n     // size of the requested block of memory, measured in bytes.\n-    size: usize,\n+    size_: usize,\n \n     // alignment of the requested block of memory, measured in bytes.\n     // we ensure that this is always a power-of-two, because API's\n@@ -75,17 +76,12 @@ pub struct Layout {\n     //\n     // (However, we do not analogously require `align >= sizeof(void*)`,\n     //  even though that is *also* a requirement of `posix_memalign`.)\n-    align: usize,\n+    align_: NonZeroUsize,\n }\n \n-\n-// FIXME: audit default implementations for overflow errors,\n-// (potentially switching to overflowing_add and\n-//  overflowing_mul as necessary).\n-\n impl Layout {\n     /// Constructs a `Layout` from a given `size` and `align`,\n-    /// or returns `None` if either of the following conditions\n+    /// or returns `LayoutErr` if either of the following conditions\n     /// are not met:\n     ///\n     /// * `align` must be a power of two,\n@@ -126,23 +122,23 @@ impl Layout {\n     ///\n     /// # Safety\n     ///\n-    /// This function is unsafe as it does not verify that `align` is\n-    /// a power-of-two nor `size` aligned to `align` fits within the\n-    /// address space (i.e. the `Layout::from_size_align` preconditions).\n+    /// This function is unsafe as it does not verify the preconditions from\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n-        Layout { size: size, align: align }\n+        Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n     #[inline]\n-    pub fn size(&self) -> usize { self.size }\n+    pub fn size(&self) -> usize { self.size_ }\n \n     /// The minimum byte alignment for a memory block of this layout.\n     #[inline]\n-    pub fn align(&self) -> usize { self.align }\n+    pub fn align(&self) -> usize { self.align_.get() }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[inline]\n     pub fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n         // Note that the align is guaranteed by rustc to be a power of two and\n@@ -158,6 +154,7 @@ impl Layout {\n     /// Produces layout describing a record that could be used to\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n+    #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n         // See rationale in `new` for why this us using an unsafe variant below\n@@ -181,18 +178,19 @@ impl Layout {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the combination of `self.size` and the given `align`\n-    /// violates the conditions listed in `from_size_align`.\n+    /// Panics if the combination of `self.size()` and the given `align`\n+    /// violates the conditions listed in\n+    /// [`Layout::from_size_align`](#method.from_size_align).\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Self {\n-        Layout::from_size_align(self.size, cmp::max(self.align, align)).unwrap()\n+        Layout::from_size_align(self.size(), cmp::max(self.align(), align)).unwrap()\n     }\n \n     /// Returns the amount of padding we must insert after `self`\n     /// to ensure that the following address will satisfy `align`\n     /// (measured in bytes).\n     ///\n-    /// E.g. if `self.size` is 9, then `self.padding_needed_for(4)`\n+    /// E.g. if `self.size()` is 9, then `self.padding_needed_for(4)`\n     /// returns 3, because that is the minimum number of bytes of\n     /// padding required to get a 4-aligned address (assuming that the\n     /// corresponding memory block starts at a 4-aligned address).\n@@ -203,7 +201,7 @@ impl Layout {\n     /// Note that the utility of the returned value requires `align`\n     /// to be less than or equal to the alignment of the starting\n     /// address for the whole allocated block of memory. One way to\n-    /// satisfy this constraint is to ensure `align <= self.align`.\n+    /// satisfy this constraint is to ensure `align <= self.align()`.\n     #[inline]\n     pub fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n@@ -227,7 +225,8 @@ impl Layout {\n         // size and padding overflow in the above manner should cause\n         // the allocator to yield an error anyway.)\n \n-        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1)\n+            & !align.wrapping_sub(1);\n         return len_rounded_up.wrapping_sub(len);\n     }\n \n@@ -238,14 +237,19 @@ impl Layout {\n     /// layout of the array and `offs` is the distance between the start\n     /// of each element in the array.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n-        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))\n+        let padded_size = self.size().checked_add(self.padding_needed_for(self.align()))\n             .ok_or(LayoutErr { private: () })?;\n         let alloc_size = padded_size.checked_mul(n)\n             .ok_or(LayoutErr { private: () })?;\n-        Ok((Layout::from_size_align(alloc_size, self.align)?, padded_size))\n+\n+        unsafe {\n+            // self.align is already known to be valid and alloc_size has been\n+            // padded already.\n+            Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size))\n+        }\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -258,16 +262,15 @@ impl Layout {\n     /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n-        let new_align = cmp::max(self.align, next.align);\n-        let realigned = Layout::from_size_align(self.size, new_align)?;\n-\n-        let pad = realigned.padding_needed_for(next.align);\n+        let new_align = cmp::max(self.align(), next.align());\n+        let pad = self.padding_needed_for(next.align());\n \n-        let offset = self.size.checked_add(pad)\n+        let offset = self.size().checked_add(pad)\n             .ok_or(LayoutErr { private: () })?;\n-        let new_size = offset.checked_add(next.size)\n+        let new_size = offset.checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n \n         let layout = Layout::from_size_align(new_size, new_align)?;\n@@ -285,10 +288,11 @@ impl Layout {\n     /// guaranteed that all elements in the array will be properly\n     /// aligned.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n         let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n-        Layout::from_size_align(size, self.align)\n+        Layout::from_size_align(size, self.align())\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -305,17 +309,19 @@ impl Layout {\n     ///  signature out of convenience in matching the signature of\n     ///  `extend`.)\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn extend_packed(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_size = self.size().checked_add(next.size())\n             .ok_or(LayoutErr { private: () })?;\n-        let layout = Layout::from_size_align(new_size, self.align)?;\n+        let layout = Layout::from_size_align(new_size, self.align())?;\n         Ok((layout, self.size()))\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n-    /// On arithmetic overflow, returns `None`.\n+    /// On arithmetic overflow, returns `LayoutErr`.\n+    #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n         Layout::new::<T>()\n             .repeat(n)\n@@ -842,7 +848,7 @@ pub unsafe trait Alloc {\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size >= layout.size);\n+        debug_assert!(new_size >= layout.size());\n         let (_l, u) = self.usable_size(&layout);\n         // _l <= layout.size()                       [guaranteed by usable_size()]\n         //       layout.size() <= new_layout.size()  [required by this method]\n@@ -897,7 +903,7 @@ pub unsafe trait Alloc {\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_size <= layout.size);\n+        debug_assert!(new_size <= layout.size());\n         let (l, _u) = self.usable_size(&layout);\n         //                      layout.size() <= _u  [guaranteed by usable_size()]\n         // new_layout.size() <= layout.size()        [required by this method]"}, {"sha": "5e1a9c25a2190729b0696c65d43e50d2caba4fed", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -3875,6 +3875,12 @@ impl<'a> Default for &'a str {\n     fn default() -> &'a str { \"\" }\n }\n \n+#[stable(feature = \"default_mut_str\", since = \"1.28.0\")]\n+impl<'a> Default for &'a mut str {\n+    /// Creates an empty mutable str\n+    fn default() -> &'a mut str { unsafe { from_utf8_unchecked_mut(&mut []) } }\n+}\n+\n /// An iterator over the non-whitespace substrings of a string,\n /// separated by any amount of whitespace.\n ///"}, {"sha": "4c282f037a5cc9c663168c78bdab4ff1333b70c5", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -362,8 +362,8 @@ fn unsafe_derive_on_repr_packed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: D\n         format!(\"#[derive] can't be used on a #[repr(packed)] struct with \\\n                  type parameters (error E0133)\")\n     } else {\n-        format!(\"#[derive] can't be used on a non-Copy #[repr(packed)] struct \\\n-                 (error E0133)\")\n+        format!(\"#[derive] can't be used on a #[repr(packed)] struct that \\\n+                 does not derive Copy (error E0133)\")\n     };\n     tcx.lint_node(SAFE_PACKED_BORROWS,\n                   lint_node_id,"}, {"sha": "86cd8d0fb2c5207c0cdd5846ad235bb29e4583a7", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let ty_string = self.ty_to_string(actual);\n                 let is_method = mode == Mode::MethodCall;\n                 let mut suggestion = None;\n-                let type_str = if is_method {\n+                let item_kind = if is_method {\n                     \"method\"\n                 } else if actual.is_enum() {\n                     if let TyAdt(ref adt_def, _) = actual.sty {\n@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             span,\n                             E0689,\n                             \"can't call {} `{}` on ambiguous numeric type `{}`\",\n-                            type_str,\n+                            item_kind,\n                             item_name,\n                             ty_string\n                         );\n@@ -284,12 +284,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             span,\n                             E0599,\n                             \"no {} named `{}` found for type `{}` in the current scope\",\n-                            type_str,\n+                            item_kind,\n                             item_name,\n                             ty_string\n                         );\n                         if let Some(suggestion) = suggestion {\n-                            err.note(&format!(\"did you mean `{}::{}`?\", type_str, suggestion));\n+                            err.note(&format!(\"did you mean `{}::{}`?\", ty_string, suggestion));\n                         }\n                         err\n                     }\n@@ -301,7 +301,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(full_sp) = tcx.hir.span_if_local(def.did) {\n                         let def_sp = tcx.sess.codemap().def_span(full_sp);\n                         err.span_label(def_sp, format!(\"{} `{}` not found {}\",\n-                                                       type_str,\n+                                                       item_kind,\n                                                        item_name,\n                                                        if def.is_enum() && !is_method {\n                                                            \"here\"\n@@ -355,7 +355,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 } else {\n-                    err.span_label(span, format!(\"{} not found in `{}`\", type_str, ty_string));\n+                    err.span_label(span, format!(\"{} not found in `{}`\", item_kind, ty_string));\n                 }\n \n                 if self.is_fn_ty(&rcvr_ty, span) {"}, {"sha": "773b8174e56bc98b20c07298e3c96249d940493b", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -561,7 +561,8 @@ a {\n \tcontent: '\\2002\\00a7\\2002';\n }\n \n-.docblock a:not(.srclink):hover, .docblock-short a:not(.srclink):hover, .stability a {\n+.docblock a:not(.srclink):not(.test-arrow):hover,\n+.docblock-short a:not(.srclink):not(.test-arrow):hover, .stability a {\n \ttext-decoration: underline;\n }\n "}, {"sha": "f96dcd9ec1c888bbfe6a8f5991a214b64ab7c5f2", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -163,7 +163,8 @@ a {\n \tcolor: #ddd;\n }\n \n-.docblock a:not(.srclink), .docblock-short a:not(.srclink), .stability a {\n+.docblock a:not(.srclink):not(.test-arrow), .docblock-short a:not(.srclink):not(.test-arrow),\n+.stability a {\n \tcolor: #D2991D;\n }\n "}, {"sha": "54cf50cfffd1e030467aa6bcc705aebab2c819ef", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -163,7 +163,8 @@ a {\n \tcolor: #000;\n }\n \n-.docblock a:not(.srclink), .docblock-short a:not(.srclink), .stability a {\n+.docblock a:not(.srclink):not(.test-arrow), .docblock-short a:not(.srclink):not(.test-arrow),\n+.stability a {\n \tcolor: #3873AD;\n }\n "}, {"sha": "5cbd8891364dd0f0d15c73d2a7df085fceed21c5", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -2250,6 +2250,11 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n \n     /// Gets a mutable reference to the value in the entry.\n     ///\n+    /// If you need a reference to the `OccupiedEntry` which may outlive the\n+    /// destruction of the `Entry` value, see [`into_mut`].\n+    ///\n+    /// [`into_mut`]: #method.into_mut\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2261,10 +2266,14 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     ///\n     /// assert_eq!(map[\"poneyland\"], 12);\n     /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///      *o.get_mut() += 10;\n+    ///     *o.get_mut() += 10;\n+    ///     assert_eq!(*o.get(), 22);\n+    ///\n+    ///     // We can use the same Entry multiple times.\n+    ///     *o.get_mut() += 2;\n     /// }\n     ///\n-    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// assert_eq!(map[\"poneyland\"], 24);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n@@ -2274,6 +2283,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n     /// with a lifetime bound to the map itself.\n     ///\n+    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: #method.get_mut\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "43375098cb5b4e6e515e85dfb7611062de483064", "filename": "src/test/ui/deriving-with-repr-packed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fderiving-with-repr-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fderiving-with-repr-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving-with-repr-packed.rs?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -33,7 +33,7 @@ pub struct Bar(u32, u32, u32);\n struct Y(usize);\n \n #[derive(PartialEq)]\n-//~^ ERROR #[derive] can't be used on a non-Copy #[repr(packed)]\n+//~^ ERROR #[derive] can't be used\n //~| hard error\n #[repr(packed)]\n struct X(Y);"}, {"sha": "a7599c1e7db34d6e10a604d24e4f0610dfd5ab21", "filename": "src/test/ui/deriving-with-repr-packed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fderiving-with-repr-packed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fderiving-with-repr-packed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving-with-repr-packed.stderr?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -21,7 +21,7 @@ LL | #[derive(Copy, Clone, PartialEq, Eq)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n \n-error: #[derive] can't be used on a non-Copy #[repr(packed)] struct (error E0133)\n+error: #[derive] can't be used on a #[repr(packed)] struct that does not derive Copy (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:26:10\n    |\n LL | #[derive(PartialEq, Eq)]\n@@ -30,7 +30,7 @@ LL | #[derive(PartialEq, Eq)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n \n-error: #[derive] can't be used on a non-Copy #[repr(packed)] struct (error E0133)\n+error: #[derive] can't be used on a #[repr(packed)] struct that does not derive Copy (error E0133)\n   --> $DIR/deriving-with-repr-packed.rs:35:10\n    |\n LL | #[derive(PartialEq)]"}, {"sha": "d87f239bca6906e865613569637a5ece0d89c80c", "filename": "src/test/ui/issue-23217.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fissue-23217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fissue-23217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-23217.stderr?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -6,7 +6,7 @@ LL | pub enum SomeEnum {\n LL |     B = SomeEnum::A,\n    |         ^^^^^^^^^^^ variant not found in `SomeEnum`\n    |\n-   = note: did you mean `variant::B`?\n+   = note: did you mean `SomeEnum::B`?\n \n error: aborting due to previous error\n "}, {"sha": "c04e21f7c58572d7e6e63bd10dfc3ed01317e62b", "filename": "src/test/ui/issue-28971.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fissue-28971.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3575be60eab140e69e5a75fe5c3b4119c2a17179/src%2Ftest%2Fui%2Fissue-28971.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-28971.stderr?ref=3575be60eab140e69e5a75fe5c3b4119c2a17179", "patch": "@@ -7,7 +7,7 @@ LL | enum Foo {\n LL |             Foo::Baz(..) => (),\n    |             ^^^^^^^^^^^^ variant not found in `Foo`\n    |\n-   = note: did you mean `variant::Bar`?\n+   = note: did you mean `Foo::Bar`?\n \n error: aborting due to previous error\n "}]}