{"sha": "b289892b5d4acd52237fb88ab12f825e7602280c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyODk4OTJiNWQ0YWNkNTIyMzdmYjg4YWIxMmY4MjVlNzYwMjI4MGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-19T23:57:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-19T23:57:07Z"}, "message": "Auto merge of #29894 - alexcrichton:stdtime, r=brson\n\nThis commit is an implementation of [RFC 1288][rfc] which adds two new unstable\ntypes to the `std::time` module. The `Instant` type is used to represent\nmeasurements of a monotonically increasing clock suitable for measuring time\nwithing a process for operations such as benchmarks or just the elapsed time to\ndo something. An `Instant` favors panicking when bugs are found as the bugs are\nprogrammer errors rather than typical errors that can be encountered.\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/1288\n\nThe `SystemTime` type is used to represent a system timestamp and is not\nmonotonic. Very few guarantees are provided about this measurement of the system\nclock, but a fixed point in time (`UNIX_EPOCH`) is provided to learn about the\nrelative distance from this point for any particular time stamp.\n\nThis PR takes the same implementation strategy as the `time` crate on crates.io,\nnamely:\n\n|  Platform  |  Instant                 |  SystemTime              |\n|------------|--------------------------|--------------------------|\n| Windows    | QueryPerformanceCounter  | GetSystemTimeAsFileTime  |\n| OSX        | mach_absolute_time       | gettimeofday             |\n| Unix       | CLOCK_MONOTONIC          | CLOCK_REALTIME           |\n\nThese implementations can perhaps be refined over time, but they currently\nsatisfy the requirements of the `Instant` and `SystemTime` types while also\nbeing portable across implementations and revisions of each platform.\n\ncc #29866", "tree": {"sha": "82332c0640871d8d6d3df3c9e58d11c904fa2cd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82332c0640871d8d6d3df3c9e58d11c904fa2cd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b289892b5d4acd52237fb88ab12f825e7602280c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b289892b5d4acd52237fb88ab12f825e7602280c", "html_url": "https://github.com/rust-lang/rust/commit/b289892b5d4acd52237fb88ab12f825e7602280c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b289892b5d4acd52237fb88ab12f825e7602280c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6861c51453963317849b4488ddc6a110e4f3470a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6861c51453963317849b4488ddc6a110e4f3470a", "html_url": "https://github.com/rust-lang/rust/commit/6861c51453963317849b4488ddc6a110e4f3470a"}, {"sha": "c6eb8527e09bed702f30ffdc8d6e54acf9b867ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6eb8527e09bed702f30ffdc8d6e54acf9b867ca", "html_url": "https://github.com/rust-lang/rust/commit/c6eb8527e09bed702f30ffdc8d6e54acf9b867ca"}], "stats": {"total": 918, "additions": 816, "deletions": 102}, "files": [{"sha": "389c9c4a0661da5aed2fc0fc90273f28a12e51f3", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -12,11 +12,10 @@ use prelude::v1::*;\n \n use sync::atomic::{AtomicUsize, Ordering};\n use sync::{mutex, MutexGuard, PoisonError};\n-use sys::time::SteadyTime;\n use sys_common::condvar as sys;\n use sys_common::mutex as sys_mutex;\n use sys_common::poison::{self, LockResult};\n-use time::Duration;\n+use time::{Instant, Duration};\n \n /// A type indicating whether a timed wait on a condition variable returned\n /// due to a time out or not.\n@@ -345,14 +344,13 @@ impl StaticCondvar {\n             where F: FnMut(LockResult<&mut T>) -> bool {\n         // This could be made more efficient by pushing the implementation into\n         // sys::condvar\n-        let start = SteadyTime::now();\n+        let start = Instant::now();\n         let mut guard_result: LockResult<MutexGuard<'a, T>> = Ok(guard);\n         while !f(guard_result\n                     .as_mut()\n                     .map(|g| &mut **g)\n                     .map_err(|e| PoisonError::new(&mut **e.get_mut()))) {\n-            let now = SteadyTime::now();\n-            let consumed = &now - &start;\n+            let consumed = start.elapsed();\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n             let (new_guard_result, timed_out) = if consumed > dur {\n                 (Ok(guard), WaitTimeoutResult(true))"}, {"sha": "5062be8cd631cc3a45afad4449766ab81fa4e60b", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -98,3 +98,22 @@ pub fn cleanup() {\n         at_exit_imp::cleanup();\n     });\n }\n+\n+// Computes (value*numer)/denom without overflow, as long as both\n+// (numer*denom) and the overall result fit into i64 (which is the case\n+// for our time conversions).\n+#[allow(dead_code)] // not used on all platforms\n+pub fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n+    let q = value / denom;\n+    let r = value % denom;\n+    // Decompose value as (value/denom*denom + value%denom),\n+    // substitute into (value*numer)/denom and simplify.\n+    // r < denom, so (denom*numer) is the upper bound of (r*numer)\n+    q * numer + r * numer / denom\n+}\n+\n+#[test]\n+fn test_muldiv() {\n+    assert_eq!(mul_div_u64( 1_000_000_000_001, 1_000_000_000, 1_000_000),\n+               1_000_000_000_001_000);\n+}"}, {"sha": "2e1c1900b46b3147aa565321a14bce1068676465", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -12,8 +12,7 @@ use cell::UnsafeCell;\n use libc;\n use ptr;\n use sys::mutex::{self, Mutex};\n-use sys::time;\n-use time::Duration;\n+use time::{Instant, Duration};\n \n pub struct Condvar { inner: UnsafeCell<libc::pthread_cond_t> }\n \n@@ -53,7 +52,7 @@ impl Condvar {\n         // stable time.  pthread_cond_timedwait uses system time, but we want to\n         // report timeout based on stable time.\n         let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n-        let stable_now = time::SteadyTime::now();\n+        let stable_now = Instant::now();\n         let r = libc::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n@@ -81,7 +80,7 @@ impl Condvar {\n \n         // ETIMEDOUT is not a totally reliable method of determining timeout due\n         // to clock shifts, so do the check ourselves\n-        &time::SteadyTime::now() - &stable_now < dur\n+        stable_now.elapsed() < dur\n     }\n \n     #[inline]"}, {"sha": "75319ce962cc3acc5cdee7a4336557344717c3dd", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 326, "deletions": 55, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -8,30 +8,183 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::inner::SteadyTime;\n+pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n \n const NSEC_PER_SEC: u64 = 1_000_000_000;\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n+    use cmp::Ordering;\n+    use fmt;\n     use libc;\n-    use time::Duration;\n-    use ops::Sub;\n-    use sync::Once;\n     use super::NSEC_PER_SEC;\n+    use sync::Once;\n+    use sys::cvt;\n+    use sys_common::mul_div_u64;\n+    use time::Duration;\n \n-    pub struct SteadyTime {\n+    const USEC_PER_SEC: u64 = NSEC_PER_SEC / 1000;\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+    pub struct Instant {\n         t: u64\n     }\n \n-    impl SteadyTime {\n-        pub fn now() -> SteadyTime {\n-            SteadyTime {\n-                t: unsafe { libc::mach_absolute_time() },\n+    #[derive(Copy, Clone)]\n+    pub struct SystemTime {\n+        t: libc::timeval,\n+    }\n+\n+    pub const UNIX_EPOCH: SystemTime = SystemTime {\n+        t: libc::timeval {\n+            tv_sec: 0,\n+            tv_usec: 0,\n+        },\n+    };\n+\n+    impl Instant {\n+        pub fn now() -> Instant {\n+            Instant { t: unsafe { libc::mach_absolute_time() } }\n+        }\n+\n+        pub fn sub_instant(&self, other: &Instant) -> Duration {\n+            let info = info();\n+            let diff = self.t.checked_sub(other.t)\n+                           .expect(\"second instant is later than self\");\n+            let nanos = mul_div_u64(diff, info.numer as u64, info.denom as u64);\n+            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> Instant {\n+            Instant {\n+                t: self.t.checked_add(dur2intervals(other))\n+                       .expect(\"overflow when adding duration to instant\"),\n+            }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> Instant {\n+            Instant {\n+                t: self.t.checked_sub(dur2intervals(other))\n+                       .expect(\"overflow when adding duration to instant\"),\n+            }\n+        }\n+    }\n+\n+    impl SystemTime {\n+        pub fn now() -> SystemTime {\n+            let mut s = SystemTime {\n+                t: libc::timeval {\n+                    tv_sec: 0,\n+                    tv_usec: 0,\n+                },\n+            };\n+            cvt(unsafe {\n+                libc::gettimeofday(&mut s.t, 0 as *mut _)\n+            }).unwrap();\n+            return s\n+        }\n+\n+        pub fn sub_time(&self, other: &SystemTime)\n+                        -> Result<Duration, Duration> {\n+            if self >= other {\n+                Ok(if self.t.tv_usec >= other.t.tv_usec {\n+                    Duration::new(self.t.tv_sec as u64 - other.t.tv_sec as u64,\n+                                  (self.t.tv_usec as u32 -\n+                                   other.t.tv_usec as u32) * 1000)\n+                } else {\n+                    Duration::new(self.t.tv_sec as u64 - 1 - other.t.tv_sec as u64,\n+                                  (self.t.tv_usec as u32 + (USEC_PER_SEC as u32) -\n+                                   other.t.tv_usec as u32) * 1000)\n+                })\n+            } else {\n+                match other.sub_time(self) {\n+                    Ok(d) => Err(d),\n+                    Err(d) => Ok(d),\n+                }\n+            }\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+            let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n+            let mut secs = secs.expect(\"overflow when adding duration to time\");\n+\n+            // Nano calculations can't overflow because nanos are <1B which fit\n+            // in a u32.\n+            let mut usec = (other.subsec_nanos() / 1000) + self.t.tv_usec as u32;\n+            if usec > USEC_PER_SEC as u32 {\n+                usec -= USEC_PER_SEC as u32;\n+                secs = secs.checked_add(1).expect(\"overflow when adding \\\n+                                                   duration to time\");\n+            }\n+            SystemTime {\n+                t: libc::timeval {\n+                    tv_sec: secs as libc::time_t,\n+                    tv_usec: usec as libc::suseconds_t,\n+                },\n+            }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+            let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n+            let mut secs = secs.expect(\"overflow when subtracting duration \\\n+                                        from time\");\n+\n+            // Similar to above, nanos can't overflow.\n+            let mut usec = self.t.tv_usec as i32 -\n+                           (other.subsec_nanos() / 1000) as i32;\n+            if usec < 0 {\n+                usec += USEC_PER_SEC as i32;\n+                secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n+                                                   duration from time\");\n+            }\n+            SystemTime {\n+                t: libc::timeval {\n+                    tv_sec: secs as libc::time_t,\n+                    tv_usec: usec as libc::suseconds_t,\n+                },\n             }\n         }\n     }\n \n+    impl PartialEq for SystemTime {\n+        fn eq(&self, other: &SystemTime) -> bool {\n+            self.t.tv_sec == other.t.tv_sec && self.t.tv_usec == other.t.tv_usec\n+        }\n+    }\n+\n+    impl Eq for SystemTime {}\n+\n+    impl PartialOrd for SystemTime {\n+        fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl Ord for SystemTime {\n+        fn cmp(&self, other: &SystemTime) -> Ordering {\n+            let me = (self.t.tv_sec, self.t.tv_usec);\n+            let other = (other.t.tv_sec, other.t.tv_usec);\n+            me.cmp(&other)\n+        }\n+    }\n+\n+    impl fmt::Debug for SystemTime {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.debug_struct(\"SystemTime\")\n+             .field(\"tv_sec\", &self.t.tv_sec)\n+             .field(\"tv_usec\", &self.t.tv_usec)\n+             .finish()\n+        }\n+    }\n+\n+    fn dur2intervals(dur: &Duration) -> u64 {\n+        let info = info();\n+        let nanos = dur.as_secs().checked_mul(NSEC_PER_SEC).and_then(|nanos| {\n+            nanos.checked_add(dur.subsec_nanos() as u64)\n+        }).expect(\"overflow converting duration to nanoseconds\");\n+        mul_div_u64(nanos, info.denom as u64, info.numer as u64)\n+    }\n+\n     fn info() -> &'static libc::mach_timebase_info {\n         static mut INFO: libc::mach_timebase_info = libc::mach_timebase_info {\n             numer: 0,\n@@ -46,72 +199,190 @@ mod inner {\n             &INFO\n         }\n     }\n-\n-    #[unstable(feature = \"libstd_sys_internals\", issue = \"0\")]\n-    impl<'a> Sub for &'a SteadyTime {\n-        type Output = Duration;\n-\n-        fn sub(self, other: &SteadyTime) -> Duration {\n-            let info = info();\n-            let diff = self.t as u64 - other.t as u64;\n-            let nanos = diff * info.numer as u64 / info.denom as u64;\n-            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n-        }\n-    }\n }\n \n #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n mod inner {\n+    use cmp::Ordering;\n+    use fmt;\n     use libc;\n-    use time::Duration;\n-    use ops::Sub;\n     use super::NSEC_PER_SEC;\n+    use sys::cvt;\n+    use time::Duration;\n \n-    pub struct SteadyTime {\n+    #[derive(Copy, Clone)]\n+    struct Timespec {\n         t: libc::timespec,\n     }\n \n-    // Apparently android provides this in some other library?\n-    // Bitrig's RT extensions are in the C library, not a separate librt\n-    // OpenBSD and NaCl provide it via libc\n-    #[cfg(not(any(target_os = \"android\",\n-                  target_os = \"bitrig\",\n-                  target_os = \"netbsd\",\n-                  target_os = \"openbsd\",\n-                  target_env = \"musl\",\n-                  target_os = \"nacl\")))]\n-    #[link(name = \"rt\")]\n-    extern {}\n-\n-    impl SteadyTime {\n-        pub fn now() -> SteadyTime {\n-            let mut t = SteadyTime {\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct Instant {\n+        t: Timespec,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    pub struct SystemTime {\n+        t: Timespec,\n+    }\n+\n+    pub const UNIX_EPOCH: SystemTime = SystemTime {\n+        t: Timespec {\n+            t: libc::timespec {\n+                tv_sec: 0,\n+                tv_nsec: 0,\n+            },\n+        },\n+    };\n+\n+    impl Instant {\n+        pub fn now() -> Instant {\n+            Instant { t: Timespec::now(libc::CLOCK_MONOTONIC) }\n+        }\n+\n+        pub fn sub_instant(&self, other: &Instant) -> Duration {\n+            self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n+                panic!(\"other was less than the current instant\")\n+            })\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> Instant {\n+            Instant { t: self.t.add_duration(other) }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> Instant {\n+            Instant { t: self.t.sub_duration(other) }\n+        }\n+    }\n+\n+    impl fmt::Debug for Instant {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.debug_struct(\"Instant\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    impl SystemTime {\n+        pub fn now() -> SystemTime {\n+            SystemTime { t: Timespec::now(libc::CLOCK_REALTIME) }\n+        }\n+\n+        pub fn sub_time(&self, other: &SystemTime)\n+                        -> Result<Duration, Duration> {\n+            self.t.sub_timespec(&other.t)\n+        }\n+\n+        pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+            SystemTime { t: self.t.add_duration(other) }\n+        }\n+\n+        pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+            SystemTime { t: self.t.sub_duration(other) }\n+        }\n+    }\n+\n+    impl fmt::Debug for SystemTime {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            f.debug_struct(\"SystemTime\")\n+             .field(\"tv_sec\", &self.t.t.tv_sec)\n+             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+             .finish()\n+        }\n+    }\n+\n+    impl Timespec {\n+        pub fn now(clock: libc::c_int) -> Timespec {\n+            let mut t = Timespec {\n                 t: libc::timespec {\n                     tv_sec: 0,\n                     tv_nsec: 0,\n                 }\n             };\n-            unsafe {\n-                assert_eq!(0, libc::clock_gettime(libc::CLOCK_MONOTONIC,\n-                                                  &mut t.t));\n-            }\n+            cvt(unsafe {\n+                libc::clock_gettime(clock, &mut t.t)\n+            }).unwrap();\n             t\n         }\n-    }\n \n-    #[unstable(feature = \"libstd_sys_internals\", issue = \"0\")]\n-    impl<'a> Sub for &'a SteadyTime {\n-        type Output = Duration;\n-\n-        fn sub(self, other: &SteadyTime) -> Duration {\n-            if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new(self.t.tv_sec as u64 - other.t.tv_sec as u64,\n-                              self.t.tv_nsec as u32 - other.t.tv_nsec as u32)\n+        fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n+            if self >= other {\n+                Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n+                    Duration::new((self.t.tv_sec - other.t.tv_sec) as u64,\n+                                  (self.t.tv_nsec - other.t.tv_nsec) as u32)\n+                } else {\n+                    Duration::new((self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n+                                  self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                                  other.t.tv_nsec as u32)\n+                })\n             } else {\n-                Duration::new(self.t.tv_sec as u64 - 1 - other.t.tv_sec as u64,\n-                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n-                                          other.t.tv_nsec as u32)\n+                match other.sub_timespec(self) {\n+                    Ok(d) => Err(d),\n+                    Err(d) => Ok(d),\n+                }\n+            }\n+        }\n+\n+        fn add_duration(&self, other: &Duration) -> Timespec {\n+            let secs = (self.t.tv_sec as i64).checked_add(other.as_secs() as i64);\n+            let mut secs = secs.expect(\"overflow when adding duration to time\");\n+\n+            // Nano calculations can't overflow because nanos are <1B which fit\n+            // in a u32.\n+            let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n+            if nsec > NSEC_PER_SEC as u32 {\n+                nsec -= NSEC_PER_SEC as u32;\n+                secs = secs.checked_add(1).expect(\"overflow when adding \\\n+                                                   duration to time\");\n+            }\n+            Timespec {\n+                t: libc::timespec {\n+                    tv_sec: secs as libc::time_t,\n+                    tv_nsec: nsec as libc::c_long,\n+                },\n+            }\n+        }\n+\n+        fn sub_duration(&self, other: &Duration) -> Timespec {\n+            let secs = (self.t.tv_sec as i64).checked_sub(other.as_secs() as i64);\n+            let mut secs = secs.expect(\"overflow when subtracting duration \\\n+                                        from time\");\n+\n+            // Similar to above, nanos can't overflow.\n+            let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n+            if nsec < 0 {\n+                nsec += NSEC_PER_SEC as i32;\n+                secs = secs.checked_sub(1).expect(\"overflow when subtracting \\\n+                                                   duration from time\");\n+            }\n+            Timespec {\n+                t: libc::timespec {\n+                    tv_sec: secs as libc::time_t,\n+                    tv_nsec: nsec as libc::c_long,\n+                },\n             }\n         }\n     }\n+\n+    impl PartialEq for Timespec {\n+        fn eq(&self, other: &Timespec) -> bool {\n+            self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n+        }\n+    }\n+\n+    impl Eq for Timespec {}\n+\n+    impl PartialOrd for Timespec {\n+        fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n+            Some(self.cmp(other))\n+        }\n+    }\n+\n+    impl Ord for Timespec {\n+        fn cmp(&self, other: &Timespec) -> Ordering {\n+            let me = (self.t.tv_sec, self.t.tv_nsec);\n+            let other = (other.t.tv_sec, other.t.tv_nsec);\n+            me.cmp(&other)\n+        }\n+    }\n }"}, {"sha": "7ef504fba81e0d019fe893c2044a892cf0dcab19", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -65,6 +65,7 @@ pub type LPWSANETWORKEVENTS = *mut WSANETWORKEVENTS;\n pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n pub type LPWSTR = *mut WCHAR;\n+pub type LPFILETIME = *mut FILETIME;\n \n pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n pub type PLARGE_INTEGER = *mut c_longlong;\n@@ -1231,6 +1232,7 @@ extern \"system\" {\n                        ReturnValue: LPVOID,\n                        OriginalContext: *const CONTEXT,\n                        HistoryTable: *const UNWIND_HISTORY_TABLE);\n+    pub fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);\n }\n \n // Functions that aren't available on Windows XP, but we still use them and just"}, {"sha": "058587b11dc19eb72c09b2bf2afb7c4d7d397ca4", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 156, "deletions": 35, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -8,62 +8,183 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ops::Sub;\n+use cmp::Ordering;\n+use fmt;\n+use mem;\n use sync::Once;\n use sys::c;\n+use sys::cvt;\n+use sys_common::mul_div_u64;\n use time::Duration;\n \n const NANOS_PER_SEC: u64 = 1_000_000_000;\n+const INTERVALS_PER_SEC: u64 = NANOS_PER_SEC / 100;\n \n-pub struct SteadyTime {\n+#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n+pub struct Instant {\n     t: c::LARGE_INTEGER,\n }\n \n-impl SteadyTime {\n-    pub fn now() -> SteadyTime {\n-        let mut t = SteadyTime { t: 0 };\n-        unsafe { c::QueryPerformanceCounter(&mut t.t); }\n+#[derive(Copy, Clone)]\n+pub struct SystemTime {\n+    t: c::FILETIME,\n+}\n+\n+const INTERVALS_TO_UNIX_EPOCH: u64 = 11_644_473_600 * INTERVALS_PER_SEC;\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime {\n+    t: c::FILETIME {\n+        dwLowDateTime: INTERVALS_TO_UNIX_EPOCH as u32,\n+        dwHighDateTime: (INTERVALS_TO_UNIX_EPOCH >> 32) as u32,\n+    },\n+};\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        let mut t = Instant { t: 0 };\n+        cvt(unsafe {\n+            c::QueryPerformanceCounter(&mut t.t)\n+        }).unwrap();\n         t\n     }\n+\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        // Values which are +- 1 need to be considered as basically the same\n+        // units in time due to various measurement oddities, according to\n+        // Windows [1]\n+        //\n+        // [1]:\n+        // https://msdn.microsoft.com/en-us/library/windows/desktop\n+        //                           /dn553408%28v=vs.85%29.aspx#guidance\n+        if other.t > self.t && other.t - self.t == 1 {\n+            return Duration::new(0, 0)\n+        }\n+        let diff = (self.t as u64).checked_sub(other.t as u64)\n+                                  .expect(\"specified instant was later than \\\n+                                           self\");\n+        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n+        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        let freq = frequency() as u64;\n+        let t = other.as_secs().checked_mul(freq).and_then(|i| {\n+            (self.t as u64).checked_add(i)\n+        }).and_then(|i| {\n+            i.checked_add(mul_div_u64(other.subsec_nanos() as u64, freq,\n+                                      NANOS_PER_SEC))\n+        }).expect(\"overflow when adding duration to time\");\n+        Instant {\n+            t: t as c::LARGE_INTEGER,\n+        }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        let freq = frequency() as u64;\n+        let t = other.as_secs().checked_mul(freq).and_then(|i| {\n+            (self.t as u64).checked_sub(i)\n+        }).and_then(|i| {\n+            i.checked_sub(mul_div_u64(other.subsec_nanos() as u64, freq,\n+                                      NANOS_PER_SEC))\n+        }).expect(\"overflow when subtracting duration from time\");\n+        Instant {\n+            t: t as c::LARGE_INTEGER,\n+        }\n+    }\n }\n \n-fn frequency() -> c::LARGE_INTEGER {\n-    static mut FREQUENCY: c::LARGE_INTEGER = 0;\n-    static ONCE: Once = Once::new();\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        unsafe {\n+            let mut t: SystemTime = mem::zeroed();\n+            c::GetSystemTimeAsFileTime(&mut t.t);\n+            return t\n+        }\n+    }\n \n-    unsafe {\n-        ONCE.call_once(|| {\n-            c::QueryPerformanceFrequency(&mut FREQUENCY);\n-        });\n-        FREQUENCY\n+    fn from_intervals(intervals: i64) -> SystemTime {\n+        SystemTime {\n+            t: c::FILETIME {\n+                dwLowDateTime: intervals as c::DWORD,\n+                dwHighDateTime: (intervals >> 32) as c::DWORD,\n+            }\n+        }\n+    }\n+\n+    fn intervals(&self) -> i64 {\n+        (self.t.dwLowDateTime as i64) | ((self.t.dwHighDateTime as i64) << 32)\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        let me = self.intervals();\n+        let other = other.intervals();\n+        if me >= other {\n+            Ok(intervals2dur((me - other) as u64))\n+        } else {\n+            Err(intervals2dur((other - me) as u64))\n+        }\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        let intervals = self.intervals().checked_add(dur2intervals(other))\n+                            .expect(\"overflow when adding duration to time\");\n+        SystemTime::from_intervals(intervals)\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        let intervals = self.intervals().checked_sub(dur2intervals(other))\n+                            .expect(\"overflow when subtracting from time\");\n+        SystemTime::from_intervals(intervals)\n     }\n }\n \n-#[unstable(feature = \"libstd_sys_internals\", issue = \"0\")]\n-impl<'a> Sub for &'a SteadyTime {\n-    type Output = Duration;\n+impl PartialEq for SystemTime {\n+    fn eq(&self, other: &SystemTime) -> bool {\n+        self.intervals() == other.intervals()\n+    }\n+}\n \n-    fn sub(self, other: &SteadyTime) -> Duration {\n-        let diff = self.t as u64 - other.t as u64;\n-        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n-        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n+impl Eq for SystemTime {}\n+\n+impl PartialOrd for SystemTime {\n+    fn partial_cmp(&self, other: &SystemTime) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for SystemTime {\n+    fn cmp(&self, other: &SystemTime) -> Ordering {\n+        self.intervals().cmp(&other.intervals())\n     }\n }\n \n-// Computes (value*numer)/denom without overflow, as long as both\n-// (numer*denom) and the overall result fit into i64 (which is the case\n-// for our time conversions).\n-fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n-    let q = value / denom;\n-    let r = value % denom;\n-    // Decompose value as (value/denom*denom + value%denom),\n-    // substitute into (value*numer)/denom and simplify.\n-    // r < denom, so (denom*numer) is the upper bound of (r*numer)\n-    q * numer + r * numer / denom\n+impl fmt::Debug for SystemTime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SystemTime\")\n+         .field(\"intervals\", &self.intervals())\n+         .finish()\n+    }\n }\n \n-#[test]\n-fn test_muldiv() {\n-    assert_eq!(mul_div_u64( 1_000_000_000_001, 1_000_000_000, 1_000_000),\n-               1_000_000_000_001_000);\n+fn dur2intervals(d: &Duration) -> i64 {\n+    d.as_secs().checked_mul(INTERVALS_PER_SEC).and_then(|i| {\n+        i.checked_add(d.subsec_nanos() as u64 / 100)\n+    }).expect(\"overflow when converting duration to intervals\") as i64\n+}\n+\n+fn intervals2dur(intervals: u64) -> Duration {\n+    Duration::new(intervals / INTERVALS_PER_SEC,\n+                  ((intervals % INTERVALS_PER_SEC) * 100) as u32)\n+}\n+\n+fn frequency() -> c::LARGE_INTEGER {\n+    static mut FREQUENCY: c::LARGE_INTEGER = 0;\n+    static ONCE: Once = Once::new();\n+\n+    unsafe {\n+        ONCE.call_once(|| {\n+            cvt(c::QueryPerformanceFrequency(&mut FREQUENCY)).unwrap();\n+        });\n+        FREQUENCY\n+    }\n }"}, {"sha": "63d517606a0319923380157fa4958f58a78961e6", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ops::{Add, Sub, Mul, Div};\n-use sys::time::SteadyTime;\n+use time::Instant;\n \n const NANOS_PER_SEC: u32 = 1_000_000_000;\n const NANOS_PER_MILLI: u32 = 1_000_000;\n@@ -67,9 +67,9 @@ impl Duration {\n                          abstraction\",\n                issue = \"27799\")]\n     pub fn span<F>(f: F) -> Duration where F: FnOnce() {\n-        let start = SteadyTime::now();\n+        let start = Instant::now();\n         f();\n-        &SteadyTime::now() - &start\n+        start.elapsed()\n     }\n \n     /// Creates a new `Duration` from the specified number of seconds."}, {"sha": "95f68712be2b4888fd9b723a605b5c4c876bfe9f", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b289892b5d4acd52237fb88ab12f825e7602280c/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=b289892b5d4acd52237fb88ab12f825e7602280c", "patch": "@@ -12,7 +12,311 @@\n \n #![stable(feature = \"time\", since = \"1.3.0\")]\n \n+use error::Error;\n+use fmt;\n+use ops::{Add, Sub};\n+use sys::time;\n+\n #[stable(feature = \"time\", since = \"1.3.0\")]\n pub use self::duration::Duration;\n \n mod duration;\n+\n+/// A measurement of a monotonically increasing clock which is suitable for\n+/// measuring the amount of time that an operation takes.\n+///\n+/// Instants are guaranteed always be greater than any previously measured\n+/// instant when created, and are often useful for tasks such as measuring\n+/// benchmarks or timing how long an operation takes.\n+///\n+/// Note, however, that instants are not guaranteed to be **steady**.  In other\n+/// words each tick of the underlying clock may not be the same length (e.g.\n+/// some seconds may be longer than others). An instant may jump forwards or\n+/// experience time dilation (slow down or speed up), but it will never go\n+/// backwards.\n+///\n+/// Instants are opaque types that can only be compared to one another. There is\n+/// no method to get \"the number of seconds\" from an instant but instead it only\n+/// allow learning the duration between two instants (or comparing two\n+/// instants).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+pub struct Instant(time::Instant);\n+\n+/// A measurement of the system clock appropriate for timestamps such as those\n+/// on files on the filesystem.\n+///\n+/// Distinct from the `Instant` type, this time measurement **is not\n+/// monotonic**. This means that you can save a file to the file system, then\n+/// save another file to the file system, **and the second file has a\n+/// `SystemTime` measurement earlier than the second**. In other words, an\n+/// operation that happens after another operation in real time may have an\n+/// earlier `SystemTime`!\n+///\n+/// Consequently, comparing two `SystemTime` instances to learn about the\n+/// duration between them returns a `Result` instead of an infallible `Duration`\n+/// to indicate that this sort of time drift may happen and needs to be handled.\n+///\n+/// Although a `SystemTime` cannot be directly inspected, the `UNIX_EPOCH`\n+/// constant is provided in this module as an anchor in time to learn\n+/// information about a `SystemTime`. By calculating the duration from this\n+/// fixed point in time a `SystemTime` can be converted to a human-readable time\n+/// or perhaps some other string representation.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+pub struct SystemTime(time::SystemTime);\n+\n+/// An error returned from the `duration_from_earlier` method on `SystemTime`,\n+/// used to learn about why how far in the opposite direction a timestamp lies.\n+#[derive(Clone, Debug)]\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+pub struct SystemTimeError(Duration);\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl Instant {\n+    /// Returns an instant corresponding to \"now\".\n+    pub fn now() -> Instant {\n+        Instant(time::Instant::now())\n+    }\n+\n+    /// Returns the amount of time elapsed from another instant to this one.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if `earlier` is later than `self`, which should\n+    /// only be possible if `earlier` was created after `self`. Because\n+    /// `Instant` is monotonic, the only time that this should happen should be\n+    /// a bug.\n+    pub fn duration_from_earlier(&self, earlier: Instant) -> Duration {\n+        self.0.sub_instant(&earlier.0)\n+    }\n+\n+    /// Returns the amount of time elapsed since this instant was created.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function may panic if the current time is earlier than this instant\n+    /// which can happen if an `Instant` is produced synthetically.\n+    pub fn elapsed(&self) -> Duration {\n+        Instant::now().duration_from_earlier(*self)\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl Add<Duration> for Instant {\n+    type Output = Instant;\n+\n+    fn add(self, other: Duration) -> Instant {\n+        Instant(self.0.add_duration(&other))\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl Sub<Duration> for Instant {\n+    type Output = Instant;\n+\n+    fn sub(self, other: Duration) -> Instant {\n+        Instant(self.0.sub_duration(&other))\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl fmt::Debug for Instant {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl SystemTime {\n+    /// Returns the system time corresponding to \"now\".\n+    pub fn now() -> SystemTime {\n+        SystemTime(time::SystemTime::now())\n+    }\n+\n+    /// Returns the amount of time elapsed from an earlier point in time.\n+    ///\n+    /// This function may fail because measurements taken earlier are not\n+    /// guaranteed to always be before later measurements (due to anomalies such\n+    /// as the system clock being adjusted either forwards or backwards).\n+    ///\n+    /// If successful, `Ok(duration)` is returned where the duration represents\n+    /// the amount of time elapsed from the specified measurement to this one.\n+    ///\n+    /// Returns an `Err` if `earlier` is later than `self`, and the error\n+    /// contains how far from `self` the time is.\n+    pub fn duration_from_earlier(&self, earlier: SystemTime)\n+                                 -> Result<Duration, SystemTimeError> {\n+        self.0.sub_time(&earlier.0).map_err(SystemTimeError)\n+    }\n+\n+    /// Returns the amount of time elapsed since this system time was created.\n+    ///\n+    /// This function may fail as the underlying system clock is susceptible to\n+    /// drift and updates (e.g. the system clock could go backwards), so this\n+    /// function may not always succeed. If successful, `Ok(duration)` is\n+    /// returned where the duration represents the amount of time elapsed from\n+    /// this time measurement to the current time.\n+    ///\n+    /// Returns an `Err` if `self` is later than the current system time, and\n+    /// the error contains how far from the current system time `self` is.\n+    pub fn elapsed(&self) -> Result<Duration, SystemTimeError> {\n+        SystemTime::now().duration_from_earlier(*self)\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl Add<Duration> for SystemTime {\n+    type Output = SystemTime;\n+\n+    fn add(self, dur: Duration) -> SystemTime {\n+        SystemTime(self.0.add_duration(&dur))\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl Sub<Duration> for SystemTime {\n+    type Output = SystemTime;\n+\n+    fn sub(self, dur: Duration) -> SystemTime {\n+        SystemTime(self.0.sub_duration(&dur))\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl fmt::Debug for SystemTime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+/// An anchor in time which can be used to create new `SystemTime` instances or\n+/// learn about where in time a `SystemTime` lies.\n+///\n+/// This constant is defined to be \"1970-01-01 00:00:00 UTC\" on all systems with\n+/// respect to the system clock. Using `duration_from_earlier` on an existing\n+/// `SystemTime` instance can tell how far away from this point in time a\n+/// measurement lies, and using `UNIX_EPOCH + duration` can be used to create a\n+/// `SystemTime` instance to represent another fixed point in time.\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+pub const UNIX_EPOCH: SystemTime = SystemTime(time::UNIX_EPOCH);\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl SystemTimeError {\n+    /// Returns the positive duration which represents how far forward the\n+    /// second system time was from the first.\n+    ///\n+    /// A `SystemTimeError` is returned from the `duration_from_earlier`\n+    /// operation whenever the second duration, `earlier`, actually represents a\n+    /// point later in time than the `self` of the method call. This function\n+    /// will extract and return the amount of time later `earlier` actually is.\n+    pub fn duration(&self) -> Duration {\n+        self.0\n+    }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl Error for SystemTimeError {\n+    fn description(&self) -> &str { \"other time was not earlier than self\" }\n+}\n+\n+#[unstable(feature = \"time2\", reason = \"recently added\", issue = \"29866\")]\n+impl fmt::Display for SystemTimeError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"second time provided was later than self\")\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Instant, SystemTime, Duration, UNIX_EPOCH};\n+\n+    #[test]\n+    fn instant_monotonic() {\n+        let a = Instant::now();\n+        let b = Instant::now();\n+        assert!(b >= a);\n+    }\n+\n+    #[test]\n+    fn instant_elapsed() {\n+        let a = Instant::now();\n+        a.elapsed();\n+    }\n+\n+    #[test]\n+    fn instant_math() {\n+        let a = Instant::now();\n+        let b = Instant::now();\n+        let dur = b.duration_from_earlier(a);\n+        assert_eq!(b - dur, a);\n+        assert_eq!(a + dur, b);\n+\n+        let second = Duration::new(1, 0);\n+        assert_eq!(a - second + second, a);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn instant_duration_panic() {\n+        let a = Instant::now();\n+        (a - Duration::new(1, 0)).duration_from_earlier(a);\n+    }\n+\n+    #[test]\n+    fn system_time_math() {\n+        let a = SystemTime::now();\n+        let b = SystemTime::now();\n+        match b.duration_from_earlier(a) {\n+            Ok(dur) if dur == Duration::new(0, 0) => {\n+                assert_eq!(a, b);\n+            }\n+            Ok(dur) => {\n+                assert!(b > a);\n+                assert_eq!(b - dur, a);\n+                assert_eq!(a + dur, b);\n+            }\n+            Err(dur) => {\n+                let dur = dur.duration();\n+                assert!(a > b);\n+                assert_eq!(b + dur, a);\n+                assert_eq!(b - dur, a);\n+            }\n+        }\n+\n+        let second = Duration::new(1, 0);\n+        assert_eq!(a.duration_from_earlier(a - second).unwrap(), second);\n+        assert_eq!(a.duration_from_earlier(a + second).unwrap_err().duration(),\n+                   second);\n+\n+        assert_eq!(a - second + second, a);\n+\n+        let eighty_years = second * 60 * 60 * 24 * 365 * 80;\n+        assert_eq!(a - eighty_years + eighty_years, a);\n+        assert_eq!(a - (eighty_years * 10) + (eighty_years * 10), a);\n+    }\n+\n+    #[test]\n+    fn system_time_elapsed() {\n+        let a = SystemTime::now();\n+        drop(a.elapsed());\n+    }\n+\n+    #[test]\n+    fn since_epoch() {\n+        let ts = SystemTime::now();\n+        let a = ts.duration_from_earlier(UNIX_EPOCH).unwrap();\n+        let b = ts.duration_from_earlier(UNIX_EPOCH - Duration::new(1, 0)).unwrap();\n+        assert!(b > a);\n+        assert_eq!(b - a, Duration::new(1, 0));\n+\n+        // let's assume that we're all running computers later than 2000\n+        let thirty_years = Duration::new(1, 0) * 60 * 60 * 24 * 365 * 30;\n+        assert!(a > thirty_years);\n+\n+        // let's assume that we're all running computers earlier than 2090.\n+        // Should give us ~70 years to fix this!\n+        let hundred_twenty_years = thirty_years * 4;\n+        assert!(a < hundred_twenty_years);\n+    }\n+}"}]}