{"sha": "949a38509e0f2444361e28e322fda2f74c297c80", "node_id": "C_kwDOAAsO6NoAKDk0OWEzODUwOWUwZjI0NDQzNjFlMjhlMzIyZmRhMmY3NGMyOTdjODA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-04T08:41:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-04T08:41:27Z"}, "message": "Auto merge of #2830 - oli-obk:rustup, r=oli-obk\n\nRustup", "tree": {"sha": "ea0df96e44b8efb29e37a017893205af9649543f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea0df96e44b8efb29e37a017893205af9649543f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/949a38509e0f2444361e28e322fda2f74c297c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/949a38509e0f2444361e28e322fda2f74c297c80", "html_url": "https://github.com/rust-lang/rust/commit/949a38509e0f2444361e28e322fda2f74c297c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/949a38509e0f2444361e28e322fda2f74c297c80/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7315b6da628e0e6759c2eab5e83253edc1f1f9a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7315b6da628e0e6759c2eab5e83253edc1f1f9a7", "html_url": "https://github.com/rust-lang/rust/commit/7315b6da628e0e6759c2eab5e83253edc1f1f9a7"}, {"sha": "663664bec65de66e80dccaf0805a35c77c43d5fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/663664bec65de66e80dccaf0805a35c77c43d5fc", "html_url": "https://github.com/rust-lang/rust/commit/663664bec65de66e80dccaf0805a35c77c43d5fc"}], "stats": {"total": 25415, "additions": 16406, "deletions": 9009}, "files": [{"sha": "a917d9a7d55dda05a05257e8ebd66e210368258d", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -34,7 +34,7 @@ jobs:\n   pr:\n     permissions:\n       actions: write\n-    name: PR\n+    name: \"PR - ${{ matrix.name }}\"\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n       CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n@@ -159,7 +159,7 @@ jobs:\n   auto:\n     permissions:\n       actions: write\n-    name: auto\n+    name: \"auto - ${{ matrix.name }}\"\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n       CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse\n@@ -578,7 +578,7 @@ jobs:\n   try:\n     permissions:\n       actions: write\n-    name: try\n+    name: \"try - ${{ matrix.name }}\"\n     env:\n       CI_JOB_NAME: \"${{ matrix.name }}\"\n       CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse"}, {"sha": "0bbccb57130225dda1105ac59dcb250094dc97a3", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -25,7 +25,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/15.0-2022-12-07\n+\tbranch = rustc/16.0-2023-03-06\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "92be31747501e83187c06706d3d5be1909f331a2", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -102,6 +102,7 @@ Carol Willing <carolcode@willingconsulting.com>\n Chandler Deng <chandde@microsoft.com>\n Charles Lew <crlf0710@gmail.com> CrLF0710 <crlf0710@gmail.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n+Chris Denton <chris@chrisdenton.dev> Chris Denton <ChrisDenton@users.noreply.github.com>\n Chris Gregory <czipperz@gmail.com>\n Chris Pardy <chrispardy36@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n@@ -415,6 +416,7 @@ Nick Platt <platt.nicholas@gmail.com>\n Niclas Schwarzlose <15schnic@gmail.com>\n Nicolas Abram <abramlujan@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n+Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> nils <48135649+Nilstrieb@users.noreply.github.com>\n Nif Ward <nif.ward@gmail.com>\n Nika Layzell <nika@thelayzells.com> <michael@thelayzells.com>\n NODA Kai <nodakai@gmail.com>"}, {"sha": "dfaa70bb9db005a2d79c5064f57d95640e2af079", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -33,7 +33,6 @@ find a mentor! You can learn more about asking questions and getting help in the\n Did a compiler error message tell you to come here? If you want to create an ICE report,\n refer to [this section][contributing-bug-reports] and [open an issue][issue template].\n \n-[Contributing to Rust]: https://rustc-dev-guide.rust-lang.org/contributing.html#contributing-to-rust\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n [std-dev-guide]: https://std-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports"}, {"sha": "c7bd689b2d864d336dbecff1b0891356875e4e46", "filename": "Cargo.lock", "status": "modified", "additions": 150, "deletions": 79, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -98,6 +98,46 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"anstream\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"342258dd14006105c2b75ab1bd7543a03bdf0cfc94383303ac212a04939dff6f\"\n+dependencies = [\n+ \"anstyle\",\n+ \"anstyle-parse\",\n+ \"anstyle-wincon\",\n+ \"concolor-override\",\n+ \"concolor-query 0.3.3\",\n+ \"is-terminal\",\n+ \"utf8parse\",\n+]\n+\n+[[package]]\n+name = \"anstyle\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"23ea9e81bd02e310c216d080f6223c179012256e5151c41db88d12c88a1684d2\"\n+\n+[[package]]\n+name = \"anstyle-parse\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7d1bb534e9efed14f3e5f44e7dd1a4f709384023a4165199a4241e18dff0116\"\n+dependencies = [\n+ \"utf8parse\",\n+]\n+\n+[[package]]\n+name = \"anstyle-wincon\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c3127af6145b149f3287bb9a0d10ad9c5692dba8c53ad48285e5bec4063834fa\"\n+dependencies = [\n+ \"anstyle\",\n+ \"windows-sys 0.45.0\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.65\"\n@@ -106,11 +146,11 @@ checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"ar_archive_writer\"\n-version = \"0.1.1\"\n+version = \"0.1.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"276881980556fdadeb88aa1ffc667e4d2e8fe72531dfabcb7a82bb3c9ea9ba31\"\n+checksum = \"b0639441fd17a3197d1cbca8dc8768cc172a63b64b4bb6c372e8f41ed0acc9bb\"\n dependencies = [\n- \"object 0.29.0\",\n+ \"object 0.30.1\",\n ]\n \n [[package]]\n@@ -149,9 +189,9 @@ dependencies = [\n \n [[package]]\n name = \"askama_derive\"\n-version = \"0.12.0\"\n+version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e80b5ad1afe82872b7aa3e9de9b206ecb85584aa324f0f60fa4c903ce935936b\"\n+checksum = \"c22fbe0413545c098358e56966ff22cdd039e10215ae213cfbd65032b119fc94\"\n dependencies = [\n  \"basic-toml\",\n  \"mime\",\n@@ -160,7 +200,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"serde\",\n- \"syn\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]\n@@ -362,7 +402,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -398,6 +438,7 @@ dependencies = [\n  \"pasetors\",\n  \"pathdiff\",\n  \"pretty_env_logger\",\n+ \"rand\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n  \"same-file\",\n@@ -590,7 +631,7 @@ checksum = \"d552b2fa341f5fc35c6b917b1d289d3c3a34d0b74e579390ea6192d6152a8cdb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"synstructure\",\n ]\n \n@@ -669,17 +710,27 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"4.1.4\"\n+version = \"4.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f13b9c79b5d1dd500d20ef541215a6423c75829ef43117e1b4d17fd8af0b5d76\"\n+checksum = \"046ae530c528f252094e4a77886ee1374437744b2bff1497aa898bbddbbb29b3\"\n dependencies = [\n+ \"clap_builder\",\n+ \"clap_derive 4.2.0\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"clap_builder\"\n+version = \"4.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"223163f58c9a40c3b0a43e1c4b50a9ce09f007ea2cb1ec258a687945b4b7929f\"\n+dependencies = [\n+ \"anstream\",\n+ \"anstyle\",\n  \"bitflags\",\n- \"clap_derive 4.1.0\",\n- \"clap_lex 0.3.0\",\n- \"is-terminal\",\n+ \"clap_lex 0.4.1\",\n  \"once_cell\",\n  \"strsim\",\n- \"termcolor\",\n  \"terminal_size\",\n ]\n \n@@ -689,7 +740,7 @@ version = \"4.0.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"10861370d2ba66b0f5989f83ebf35db6421713fd92351790e7fdd6c36774c56b\"\n dependencies = [\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n ]\n \n [[package]]\n@@ -702,20 +753,19 @@ dependencies = [\n  \"proc-macro-error\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n name = \"clap_derive\"\n-version = \"4.1.0\"\n+version = \"4.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"684a277d672e91966334af371f1a7b5833f9aa00b07c84e92fbce95e00208ce8\"\n+checksum = \"3f9644cd56d6b87dbe899ef8b053e331c0637664e9e21a33dfcdc36093f5c5c4\"\n dependencies = [\n  \"heck\",\n- \"proc-macro-error\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 2.0.8\",\n ]\n \n [[package]]\n@@ -729,18 +779,15 @@ dependencies = [\n \n [[package]]\n name = \"clap_lex\"\n-version = \"0.3.0\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0d4198f73e42b4936b35b5bb248d81d2b595ecb170da0bac7655c54eedfa8da8\"\n-dependencies = [\n- \"os_str_bytes\",\n-]\n+checksum = \"8a2dd5a6fe8c6e3502f568a6353e5273bbb15193ad9a89e457b9970798efbea1\"\n \n [[package]]\n name = \"clippy\"\n version = \"0.1.70\"\n dependencies = [\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n  \"clippy_lints\",\n  \"clippy_utils\",\n  \"compiletest_rs\",\n@@ -757,7 +804,7 @@ dependencies = [\n  \"rustc_tools_util\",\n  \"semver\",\n  \"serde\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"tempfile\",\n  \"termize\",\n  \"tester\",\n@@ -771,7 +818,7 @@ name = \"clippy_dev\"\n version = \"0.0.1\"\n dependencies = [\n  \"aho-corasick\",\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n  \"indoc\",\n  \"itertools\",\n  \"opener\",\n@@ -868,9 +915,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.87\"\n+version = \"0.1.91\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f867ce54c09855ccd135ad4a50c777182a0c7af5ff20a8f537617bd648b10d50\"\n+checksum = \"571298a3cce7e2afbd3d61abb91a18667d5ab25993ec577a88ee8ac45f00cc3a\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -932,15 +979,30 @@ checksum = \"b90f9dcd9490a97db91a85ccd79e38a87e14323f0bb824659ee3274e9143ba37\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n- \"concolor-query\",\n+ \"concolor-query 0.1.0\",\n ]\n \n+[[package]]\n+name = \"concolor-override\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a855d4a1978dc52fb0536a04d384c2c0c1aa273597f08b77c8c4d3b2eec6037f\"\n+\n [[package]]\n name = \"concolor-query\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"82a90734b3d5dcf656e7624cca6bce9c3a90ee11f900e80141a7427ccfb3d317\"\n \n+[[package]]\n+name = \"concolor-query\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"88d11d52c3d7ca2e6d0040212be9e4dbbcd78b6447f535b6b561f449427944cf\"\n+dependencies = [\n+ \"windows-sys 0.45.0\",\n+]\n+\n [[package]]\n name = \"const-oid\"\n version = \"0.9.1\"\n@@ -1108,7 +1170,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6d2301688392eb071b0bf1a37be05c469d3cc4dbbd95df672fe28ab021e6a096\"\n dependencies = [\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -1154,7 +1216,7 @@ version = \"0.1.70\"\n dependencies = [\n  \"itertools\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -1176,7 +1238,7 @@ checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -1189,7 +1251,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"rustc_version\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -1267,7 +1329,7 @@ checksum = \"3bf95dc3f046b9da4f2d51833c0d3547d8564ef6910f5c1ed130306a75b92886\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -1683,7 +1745,7 @@ checksum = \"6dbd947adfffb0efc70599b3ddcf7b5597bb5fa9e245eb99f62b3a5f7bb8bd3c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -2530,7 +2592,7 @@ dependencies = [\n  \"markup5ever\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -2619,7 +2681,7 @@ checksum = \"9ddb07844c2ffc4c28840e799e9e54ff054393cf090740decf25624e9d94b93a\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -2689,9 +2751,9 @@ checksum = \"ce23b50ad8242c51a442f3ff322d56b02f08852c77e4c0b4d3fd684abc89c683\"\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.2\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n+checksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown 0.12.3\",\n@@ -2844,7 +2906,7 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n  \"fs-err\",\n  \"rustc-hash\",\n  \"rustdoc-json-types\",\n@@ -2879,28 +2941,28 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.139\"\n+version = \"0.2.140\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"201de327520df007757c1f0adce6e827fe8562fbc28bfd9c15571c66ca1f5f79\"\n+checksum = \"99227334921fae1a979cf0bfdfcc6b3e5ce376ef57e16fb6fb3ea2ed6095f80c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n name = \"libffi\"\n-version = \"3.0.1\"\n+version = \"3.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1e454b3efb16fba3b17810ae5e41df02b649e564ab3c5a34b3b93ed07ad287e6\"\n+checksum = \"ce826c243048e3d5cec441799724de52e2d42f820468431fc3fceee2341871e2\"\n dependencies = [\n  \"libc\",\n  \"libffi-sys\",\n ]\n \n [[package]]\n name = \"libffi-sys\"\n-version = \"2.0.0\"\n+version = \"2.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ab4106b7f09d7b87d021334d5618fac1dfcfb824d4c5fe111ff0074dfd242e15\"\n+checksum = \"dc65067b78c0fc069771e8b9a9e02df71e08858bec92c1f101377c67b9dca7c7\"\n dependencies = [\n  \"cc\",\n ]\n@@ -3089,7 +3151,7 @@ checksum = \"0f1b8c13cb1f814b634a96b2c725449fe7ed464a7b8781de8688be5ffbd3f305\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -3110,7 +3172,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.10.0\",\n@@ -3679,7 +3741,7 @@ dependencies = [\n  \"pest_meta\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -3823,7 +3885,7 @@ dependencies = [\n  \"proc-macro-error-attr\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"version_check\",\n ]\n \n@@ -3846,9 +3908,9 @@ checksum = \"dbf0c48bc1d91375ae5c3cd81e3722dff1abcf81a30960240640d223f59fe0e5\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.46\"\n+version = \"1.0.53\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94e2ef8dbfc347b10c094890f778ee2e36ca9bb4262e86dc99cd217e35f3470b\"\n+checksum = \"ba466839c78239c09faf015484e5cc04860f88242cff4d03eb038f04b4699b73\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -3925,9 +3987,9 @@ checksum = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.21\"\n+version = \"1.0.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bbe448f377a7d6961e30f5955f9b8d106c3f5e449d493ee1b125c1d43c2b5179\"\n+checksum = \"4424af4bf778aae2051a77b60283332f386554255d722233d09fbfc7e30da2fc\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -4115,7 +4177,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap 4.1.4\",\n+ \"clap 4.2.1\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -4160,21 +4222,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-rayon\"\n-version = \"0.4.0\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1a79f0b0b2609e2eacf9758013f50e7176cb4b29fd6436a747b14a5362c8727a\"\n+checksum = \"eb81aadc8837ca6ecebe0fe1353f15df83b3b3cc2cf7a8afd571bc22aa121710\"\n dependencies = [\n- \"autocfg\",\n- \"crossbeam-deque\",\n  \"either\",\n  \"rustc-rayon-core\",\n ]\n \n [[package]]\n name = \"rustc-rayon-core\"\n-version = \"0.4.1\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"02269144a0db9bb55cf5d4a41a5a0e95b334b0b78b08269018ca9b0250718c30\"\n+checksum = \"67668daaf00e359c126f6dcb40d652d89b458a008c8afa727a42a2d20fca0b7f\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"crossbeam-deque\",\n@@ -4224,7 +4284,7 @@ dependencies = [\n  \"regex\",\n  \"serde_json\",\n  \"smallvec\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"url\",\n  \"winapi\",\n ]\n@@ -4934,7 +4994,7 @@ dependencies = [\n  \"fluent-syntax\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"synstructure\",\n  \"unic-langid\",\n ]\n@@ -5514,7 +5574,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"serde\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -5684,7 +5744,7 @@ checksum = \"4f1d362ca8fc9c3e3a7484440752472d68a6caa98f1ab81d99b5dfe517cec852\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -6028,7 +6088,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"rustversion\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -6048,6 +6108,17 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"syn\"\n+version = \"2.0.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bcc02725fd69ab9f26eab07fad303e2497fad6fb9eba4f96c4d1687bdf704ad9\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n [[package]]\n name = \"synstructure\"\n version = \"0.12.6\"\n@@ -6056,7 +6127,7 @@ checksum = \"f36bdaa60a83aca3921b5259d5400cbf5e90fc51931376a9bd4a0eb79aa7210f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"unicode-xid\",\n ]\n \n@@ -6190,7 +6261,7 @@ checksum = \"1fb327af4685e4d03fa8cbcf1716380da910eeb2bb8be417e7f9fd3fb164f36f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -6387,7 +6458,7 @@ checksum = \"11c75893af559bc8e10716548bdef5cb2b983f8e637db9d0e15126b61b484ee2\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -6586,7 +6657,7 @@ checksum = \"1f5cdec05b907f4e2f6843f4354f4ce6a5bebe1a56df320a49134944477ce4d8\"\n dependencies = [\n  \"proc-macro-hack\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"unic-langid-impl\",\n ]\n \n@@ -6739,9 +6810,9 @@ checksum = \"05e42f7c18b8f902290b009cde6d651262f956c98bc51bca4cd1d511c9cd85c7\"\n \n [[package]]\n name = \"utf8parse\"\n-version = \"0.2.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"936e4b492acfd135421d8dca4b1aa80a7bfc26e702ef3af710e0752684df5372\"\n+checksum = \"711b9620af191e0cdc7468a8d14e709c3dcdb115b36f838e601583af800a370a\"\n \n [[package]]\n name = \"uuid\"\n@@ -6834,7 +6905,7 @@ dependencies = [\n  \"once_cell\",\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"wasm-bindgen-shared\",\n ]\n \n@@ -6856,7 +6927,7 @@ checksum = \"07bc0c051dc5f23e307b13285f9d75df86bfdf816c5721e573dec1f9b8aa193c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"wasm-bindgen-backend\",\n  \"wasm-bindgen-shared\",\n ]\n@@ -7082,7 +7153,7 @@ checksum = \"ca800d73d6b7a7ee54f2608205c98b549fca71c9500c1abcb3abdc7708b4a8cb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"synstructure\",\n ]\n \n@@ -7103,7 +7174,7 @@ checksum = \"2e8aa86add9ddbd2409c1ed01e033cd457d79b1b1229b64922c25095c595e829\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"synstructure\",\n ]\n \n@@ -7132,6 +7203,6 @@ checksum = \"2154cb6e2a748163354165e22c6a555effb09ca2d16334767bf66bb404f2206e\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n  \"synstructure\",\n ]"}, {"sha": "b923f87abfd4721d066108753aa2bbd5c82ea4f2", "filename": "RELEASES.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,3 +1,26 @@\n+Version 1.68.2 (2023-03-28)\n+===========================\n+\n+- [Update the GitHub RSA host key bundled within Cargo](https://github.com/rust-lang/cargo/pull/11883).\n+  The key was [rotated by GitHub](https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/)\n+  on 2023-03-24 after the old one leaked.\n+- [Mark the old GitHub RSA host key as revoked](https://github.com/rust-lang/cargo/pull/11889).\n+  This will prevent Cargo from accepting the leaked key even when trusted by\n+  the system.\n+- [Add support for `@revoked` and a better error message for `@cert-authority` in Cargo's SSH host key verification](https://github.com/rust-lang/cargo/pull/11635)\n+\n+Version 1.68.1 (2023-03-23)\n+===========================\n+\n+- [Fix miscompilation in produced Windows MSVC artifacts](https://github.com/rust-lang/rust/pull/109094)\n+  This was introduced by enabling ThinLTO for the distributed rustc which led\n+  to miscompilations in the resulting binary. Currently this is believed to be\n+  limited to the -Zdylib-lto flag used for rustc compilation, rather than a\n+  general bug in ThinLTO, so only rustc artifacts should be affected.\n+- [Fix --enable-local-rust builds](https://github.com/rust-lang/rust/pull/109111/)\n+- [Treat `$prefix-clang` as `clang` in linker detection code](https://github.com/rust-lang/rust/pull/109156)\n+- [Fix panic in compiler code](https://github.com/rust-lang/rust/pull/108162)\n+\n Version 1.68.0 (2023-03-09)\n ==========================\n \n@@ -71,6 +94,7 @@ Misc\n Compatibility Notes\n -------------------\n \n+- [Only support Android NDK 25 or newer](https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html)\n - [Add `SEMICOLON_IN_EXPRESSIONS_FROM_MACROS` to future-incompat report](https://github.com/rust-lang/rust/pull/103418/)\n - [Only specify `--target` by default for `-Zgcc-ld=lld` on wasm](https://github.com/rust-lang/rust/pull/101792/)\n - [Bump `IMPLIED_BOUNDS_ENTAILMENT` to Deny + ReportNow](https://github.com/rust-lang/rust/pull/106465/)"}, {"sha": "aea59ee6aea3e5a348f32fbee7d9ebef7ea70a3f", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -43,7 +43,7 @@ pub trait LayoutCalculator {\n             .max_by_key(|niche| niche.available(dl));\n \n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Arbitrary {\n                 offsets: vec![Size::ZERO, b_offset],\n                 memory_index: vec![0, 1],\n@@ -264,7 +264,7 @@ pub trait LayoutCalculator {\n             abi = Abi::Uninhabited;\n         }\n         Some(LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Arbitrary { offsets, memory_index },\n             abi,\n             largest_niche,\n@@ -277,7 +277,7 @@ pub trait LayoutCalculator {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Uninhabited,\n             largest_niche: None,\n@@ -289,7 +289,7 @@ pub trait LayoutCalculator {\n     fn layout_of_struct_or_enum(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexVec<VariantIdx, Vec<Layout<'_>>>,\n+        variants: &IndexSlice<VariantIdx, Vec<Layout<'_>>>,\n         is_enum: bool,\n         is_unsafe_cell: bool,\n         scalar_valid_range: (Bound<u128>, Bound<u128>),\n@@ -331,7 +331,7 @@ pub trait LayoutCalculator {\n             }\n             // If it's a struct, still compute a layout so that we can still compute the\n             // field offsets.\n-            None => VariantIdx::new(0),\n+            None => FIRST_VARIANT,\n         };\n \n         let is_struct = !is_enum ||\n@@ -467,7 +467,7 @@ pub trait LayoutCalculator {\n                 .max_by_key(|(_i, layout)| layout.size.bytes())\n                 .map(|(i, _layout)| i)?;\n \n-            let all_indices = (0..=variants.len() - 1).map(VariantIdx::new);\n+            let all_indices = variants.indices();\n             let needs_disc =\n                 |index: VariantIdx| index != largest_variant_index && !absent(&variants[index]);\n             let niche_variants = all_indices.clone().find(|v| needs_disc(*v)).unwrap().index()\n@@ -883,7 +883,7 @@ pub trait LayoutCalculator {\n     fn layout_of_union(\n         &self,\n         repr: &ReprOptions,\n-        variants: &IndexVec<VariantIdx, Vec<Layout<'_>>>,\n+        variants: &IndexSlice<VariantIdx, Vec<Layout<'_>>>,\n     ) -> Option<LayoutS> {\n         let dl = self.current_data_layout();\n         let dl = dl.borrow();\n@@ -896,8 +896,8 @@ pub trait LayoutCalculator {\n         let optimize = !repr.inhibit_union_abi_opt();\n         let mut size = Size::ZERO;\n         let mut abi = Abi::Aggregate { sized: true };\n-        let index = VariantIdx::new(0);\n-        for field in &variants[index] {\n+        let only_variant = &variants[FIRST_VARIANT];\n+        for field in only_variant {\n             assert!(field.0.is_sized());\n             align = align.max(field.align());\n \n@@ -930,8 +930,8 @@ pub trait LayoutCalculator {\n         }\n \n         Some(LayoutS {\n-            variants: Variants::Single { index },\n-            fields: FieldsShape::Union(NonZeroUsize::new(variants[index].len())?),\n+            variants: Variants::Single { index: FIRST_VARIANT },\n+            fields: FieldsShape::Union(NonZeroUsize::new(only_variant.len())?),\n             abi,\n             largest_niche: None,\n             align,"}, {"sha": "7b5732b488b41658debbecb38013368adda19dc4", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -11,7 +11,7 @@ use bitflags::bitflags;\n use rustc_data_structures::intern::Interned;\n #[cfg(feature = \"nightly\")]\n use rustc_data_structures::stable_hasher::StableOrd;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n #[cfg(feature = \"nightly\")]\n use rustc_macros::HashStable_Generic;\n #[cfg(feature = \"nightly\")]\n@@ -1057,6 +1057,32 @@ impl Scalar {\n     }\n }\n \n+rustc_index::newtype_index! {\n+    /// The *source-order* index of a field in a variant.\n+    ///\n+    /// This is how most code after type checking refers to fields, rather than\n+    /// using names (as names have hygiene complications and more complex lookup).\n+    ///\n+    /// Particularly for `repr(Rust)` types, this may not be the same as *layout* order.\n+    /// (It is for `repr(C)` `struct`s, however.)\n+    ///\n+    /// For example, in the following types,\n+    /// ```rust\n+    /// # enum Never {}\n+    /// # #[repr(u16)]\n+    /// enum Demo1 {\n+    ///    Variant0 { a: Never, b: i32 } = 100,\n+    ///    Variant1 { c: u8, d: u64 } = 10,\n+    /// }\n+    /// struct Demo2 { e: u8, f: u16, g: u8 }\n+    /// ```\n+    /// `b` is `FieldIdx(1)` in `VariantIdx(0)`,\n+    /// `d` is `FieldIdx(1)` in `VariantIdx(1)`, and\n+    /// `f` is `FieldIdx(1)` in `VariantIdx(0)`.\n+    #[derive(HashStable_Generic)]\n+    pub struct FieldIdx {}\n+}\n+\n /// Describes how the fields of a type are located in memory.\n #[derive(PartialEq, Eq, Hash, Clone, Debug)]\n #[cfg_attr(feature = \"nightly\", derive(HashStable_Generic))]\n@@ -1380,8 +1406,21 @@ impl Niche {\n }\n \n rustc_index::newtype_index! {\n+    /// The *source-order* index of a variant in a type.\n+    ///\n+    /// For enums, these are always `0..variant_count`, regardless of any\n+    /// custom discriminants that may have been defined, and including any\n+    /// variants that may end up uninhabited due to field types.  (Some of the\n+    /// variants may not be present in a monomorphized ABI [`Variants`], but\n+    /// those skipped variants are always counted when determining the *index*.)\n+    ///\n+    /// `struct`s, `tuples`, and `unions`s are considered to have a single variant\n+    /// with variant index zero, aka [`FIRST_VARIANT`].\n     #[derive(HashStable_Generic)]\n-    pub struct VariantIdx {}\n+    pub struct VariantIdx {\n+        /// Equivalent to `VariantIdx(0)`.\n+        const FIRST_VARIANT = 0;\n+    }\n }\n \n #[derive(PartialEq, Eq, Hash, Clone)]\n@@ -1422,7 +1461,7 @@ impl LayoutS {\n         let size = scalar.size(cx);\n         let align = scalar.align(cx);\n         LayoutS {\n-            variants: Variants::Single { index: VariantIdx::new(0) },\n+            variants: Variants::Single { index: FIRST_VARIANT },\n             fields: FieldsShape::Primitive,\n             abi: Abi::Scalar(scalar),\n             largest_niche,"}, {"sha": "9b6bfaadef05a1ccd551fc5f8ff841de3aa292f0", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -167,6 +167,9 @@ pub enum GenericArgs {\n     AngleBracketed(AngleBracketedArgs),\n     /// The `(A, B)` and `C` in `Foo(A, B) -> C`.\n     Parenthesized(ParenthesizedArgs),\n+    /// Associated return type bounds, like `T: Trait<method(..): Send>`\n+    /// which applies the `Send` bound to the return-type of `method`.\n+    ReturnTypeNotation(Span),\n }\n \n impl GenericArgs {\n@@ -178,6 +181,7 @@ impl GenericArgs {\n         match self {\n             AngleBracketed(data) => data.span,\n             Parenthesized(data) => data.span,\n+            ReturnTypeNotation(span) => *span,\n         }\n     }\n }\n@@ -231,15 +235,15 @@ impl AngleBracketedArg {\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n-    fn into(self) -> Option<P<GenericArgs>> {\n-        Some(P(GenericArgs::AngleBracketed(self)))\n+impl Into<P<GenericArgs>> for AngleBracketedArgs {\n+    fn into(self) -> P<GenericArgs> {\n+        P(GenericArgs::AngleBracketed(self))\n     }\n }\n \n-impl Into<Option<P<GenericArgs>>> for ParenthesizedArgs {\n-    fn into(self) -> Option<P<GenericArgs>> {\n-        Some(P(GenericArgs::Parenthesized(self)))\n+impl Into<P<GenericArgs>> for ParenthesizedArgs {\n+    fn into(self) -> P<GenericArgs> {\n+        P(GenericArgs::Parenthesized(self))\n     }\n }\n \n@@ -2570,7 +2574,7 @@ pub enum AttrStyle {\n \n rustc_index::newtype_index! {\n     #[custom_encodable]\n-    #[debug_format = \"AttrId({})]\"]\n+    #[debug_format = \"AttrId({})\"]\n     pub struct AttrId {}\n }\n "}, {"sha": "514978f5569a76fe48d3234c44fa384a5bc382de", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -561,6 +561,7 @@ pub fn noop_visit_generic_args<T: MutVisitor>(generic_args: &mut GenericArgs, vi\n     match generic_args {\n         GenericArgs::AngleBracketed(data) => vis.visit_angle_bracketed_parameter_data(data),\n         GenericArgs::Parenthesized(data) => vis.visit_parenthesized_parameter_data(data),\n+        GenericArgs::ReturnTypeNotation(_span) => {}\n     }\n }\n "}, {"sha": "e5a0ad1f1e48186e5aaf553aece374d60ee18767", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -481,6 +481,7 @@ where\n             walk_list!(visitor, visit_ty, &data.inputs);\n             walk_fn_ret_ty(visitor, &data.output);\n         }\n+        GenericArgs::ReturnTypeNotation(_span) => {}\n     }\n }\n "}, {"sha": "21b2a3c22fa10eb7eb53b8c2c59c073eff23bc88", "filename": "compiler/rustc_ast_lowering/messages.ftl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -139,3 +139,15 @@ ast_lowering_trait_fn_async =\n     .label = `async` because of this\n     .note = `async` trait functions are not currently supported\n     .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n+\n+ast_lowering_bad_return_type_notation_inputs =\n+    argument types not allowed with return type notation\n+    .suggestion = remove the input types\n+\n+ast_lowering_bad_return_type_notation_needs_dots =\n+    return type notation arguments must be elided with `..`\n+    .suggestion = add `..`\n+\n+ast_lowering_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type"}, {"sha": "f4e55619ebb189e1f38062091dbd46ba8b0af406", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -347,3 +347,25 @@ pub struct TraitFnAsync {\n     #[label]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+pub enum BadReturnTypeNotation {\n+    #[diag(ast_lowering_bad_return_type_notation_inputs)]\n+    Inputs {\n+        #[primary_span]\n+        #[suggestion(code = \"(..)\", applicability = \"maybe-incorrect\")]\n+        span: Span,\n+    },\n+    #[diag(ast_lowering_bad_return_type_notation_needs_dots)]\n+    NeedsDots {\n+        #[primary_span]\n+        #[suggestion(code = \"(..)\", applicability = \"maybe-incorrect\")]\n+        span: Span,\n+    },\n+    #[diag(ast_lowering_bad_return_type_notation_output)]\n+    Output {\n+        #[primary_span]\n+        #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+        span: Span,\n+    },\n+}"}, {"sha": "c41bdc440935c9969508db9a95a378e44574205a", "filename": "compiler/rustc_ast_lowering/src/format.rs", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fformat.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,7 +2,7 @@ use super::LoweringContext;\n use rustc_ast as ast;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::*;\n-use rustc_data_structures::fx::FxIndexSet;\n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_span::{\n     sym,\n@@ -238,7 +238,7 @@ fn make_count<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     sp: Span,\n     count: &Option<FormatCount>,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n ) -> hir::Expr<'hir> {\n     match count {\n         Some(FormatCount::Literal(n)) => {\n@@ -252,7 +252,7 @@ fn make_count<'hir>(\n         }\n         Some(FormatCount::Argument(arg)) => {\n             if let Ok(arg_index) = arg.index {\n-                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize), arg.span);\n                 let count_param = ctx.arena.alloc(ctx.expr_lang_item_type_relative(\n                     sp,\n                     hir::LangItem::FormatCount,\n@@ -291,12 +291,14 @@ fn make_format_spec<'hir>(\n     ctx: &mut LoweringContext<'_, 'hir>,\n     sp: Span,\n     placeholder: &FormatPlaceholder,\n-    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+    argmap: &mut FxIndexMap<(usize, ArgumentType), Option<Span>>,\n ) -> hir::Expr<'hir> {\n     let position = match placeholder.argument.index {\n         Ok(arg_index) => {\n-            let (i, _) =\n-                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            let (i, _) = argmap.insert_full(\n+                (arg_index, ArgumentType::Format(placeholder.format_trait)),\n+                placeholder.span,\n+            );\n             ctx.expr_usize(sp, i)\n         }\n         Err(_) => ctx.expr(\n@@ -386,15 +388,18 @@ fn expand_format_args<'hir>(\n \n     // Create a list of all _unique_ (argument, format trait) combinations.\n     // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n-    let mut argmap = FxIndexSet::default();\n+    let mut argmap = FxIndexMap::default();\n     for piece in &fmt.template {\n         let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n         if placeholder.format_options != Default::default() {\n             // Can't use basic form if there's any formatting options.\n             use_format_options = true;\n         }\n         if let Ok(index) = placeholder.argument.index {\n-            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+            if argmap\n+                .insert((index, ArgumentType::Format(placeholder.format_trait)), placeholder.span)\n+                .is_some()\n+            {\n                 // Duplicate (argument, format trait) combination,\n                 // which we'll only put once in the args array.\n                 use_format_options = true;\n@@ -438,7 +443,7 @@ fn expand_format_args<'hir>(\n     // This is an optimization, speeding up compilation about 1-2% in some cases.\n     // See https://github.com/rust-lang/rust/pull/106770#issuecomment-1380790609\n     let use_simple_array = argmap.len() == arguments.len()\n-        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && argmap.iter().enumerate().all(|(i, (&(j, _), _))| i == j)\n         && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n \n     let args = if use_simple_array {\n@@ -452,14 +457,19 @@ fn expand_format_args<'hir>(\n         let elements: Vec<_> = arguments\n             .iter()\n             .zip(argmap)\n-            .map(|(arg, (_, ty))| {\n-                let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+            .map(|(arg, ((_, ty), placeholder_span))| {\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n                 let arg = ctx.lower_expr(&arg.expr);\n                 let ref_arg = ctx.arena.alloc(ctx.expr(\n-                    sp,\n+                    arg_span,\n                     hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, arg),\n                 ));\n-                make_argument(ctx, sp, ref_arg, ty)\n+                make_argument(ctx, placeholder_span, ref_arg, ty)\n             })\n             .collect();\n         ctx.expr_array_ref(macsp, ctx.arena.alloc_from_iter(elements))\n@@ -475,16 +485,26 @@ fn expand_format_args<'hir>(\n         //     }\n         let args_ident = Ident::new(sym::args, macsp);\n         let (args_pat, args_hir_id) = ctx.pat_ident(macsp, args_ident);\n-        let args = ctx.arena.alloc_from_iter(argmap.iter().map(|&(arg_index, ty)| {\n-            let arg = &arguments[arg_index];\n-            let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n-            let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n-            let arg = ctx.arena.alloc(ctx.expr(\n-                sp,\n-                hir::ExprKind::Field(args_ident_expr, Ident::new(sym::integer(arg_index), macsp)),\n-            ));\n-            make_argument(ctx, sp, arg, ty)\n-        }));\n+        let args = ctx.arena.alloc_from_iter(argmap.iter().map(\n+            |(&(arg_index, ty), &placeholder_span)| {\n+                let arg = &arguments[arg_index];\n+                let placeholder_span =\n+                    placeholder_span.unwrap_or(arg.expr.span).with_ctxt(macsp.ctxt());\n+                let arg_span = match arg.kind {\n+                    FormatArgumentKind::Captured(_) => placeholder_span,\n+                    _ => arg.expr.span.with_ctxt(macsp.ctxt()),\n+                };\n+                let args_ident_expr = ctx.expr_ident(macsp, args_ident, args_hir_id);\n+                let arg = ctx.arena.alloc(ctx.expr(\n+                    arg_span,\n+                    hir::ExprKind::Field(\n+                        args_ident_expr,\n+                        Ident::new(sym::integer(arg_index), macsp),\n+                    ),\n+                ));\n+                make_argument(ctx, placeholder_span, arg, ty)\n+            },\n+        ));\n         let elements: Vec<_> = arguments\n             .iter()\n             .map(|arg| {"}, {"sha": "2efffbb6dc5e37814a275b63b3270d1590b22f9a", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -12,7 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n@@ -25,7 +25,7 @@ use thin_vec::ThinVec;\n pub(super) struct ItemLowerer<'a, 'hir> {\n     pub(super) tcx: TyCtxt<'hir>,\n     pub(super) resolver: &'a mut ResolverAstLowering,\n-    pub(super) ast_index: &'a IndexVec<LocalDefId, AstOwner<'a>>,\n+    pub(super) ast_index: &'a IndexSlice<LocalDefId, AstOwner<'a>>,\n     pub(super) owners: &'a mut IndexVec<LocalDefId, hir::MaybeOwner<&'hir hir::OwnerInfo<'hir>>>,\n }\n "}, {"sha": "ca659db4dbea2cfb29083e031991c4efe8e6ab94", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 58, "deletions": 14, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -60,13 +60,13 @@ use rustc_hir::def::{DefKind, LifetimeRes, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use rustc_macros::fluent_messages;\n use rustc_middle::{\n     span_bug,\n     ty::{ResolverAstLowering, TyCtxt},\n };\n-use rustc_session::parse::feature_err;\n+use rustc_session::parse::{add_feature_diagnostics, feature_err};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -414,7 +414,7 @@ fn index_crate<'a>(\n /// This hash will then be part of the crate_hash which is stored in the metadata.\n fn compute_hir_hash(\n     tcx: TyCtxt<'_>,\n-    owners: &IndexVec<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n+    owners: &IndexSlice<LocalDefId, hir::MaybeOwner<&hir::OwnerInfo<'_>>>,\n ) -> Fingerprint {\n     let mut hir_body_nodes: Vec<_> = owners\n         .iter_enumerated()\n@@ -482,7 +482,7 @@ enum ParamMode {\n }\n \n enum ParenthesizedGenericArgs {\n-    Ok,\n+    ParenSugar,\n     Err,\n }\n \n@@ -987,14 +987,56 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n+                &GenericArgs::ReturnTypeNotation(span) => GenericArgsCtor {\n+                    args: Default::default(),\n+                    bindings: &[],\n+                    parenthesized: hir::GenericArgsParentheses::ReturnTypeNotation,\n+                    span,\n+                },\n                 GenericArgs::Parenthesized(data) => {\n-                    self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n-                    self.lower_angle_bracketed_parameter_data(\n-                        &data.as_angle_bracketed_args(),\n-                        ParamMode::Explicit,\n-                        itctx,\n-                    )\n-                    .0\n+                    if let Some(start_char) = constraint.ident.as_str().chars().next()\n+                        && start_char.is_ascii_lowercase()\n+                    {\n+                        let mut err = if !data.inputs.is_empty() {\n+                            self.tcx.sess.create_err(errors::BadReturnTypeNotation::Inputs {\n+                                span: data.inputs_span,\n+                            })\n+                        } else if let FnRetTy::Ty(ty) = &data.output {\n+                            self.tcx.sess.create_err(errors::BadReturnTypeNotation::Output {\n+                                span: data.inputs_span.shrink_to_hi().to(ty.span),\n+                            })\n+                        } else {\n+                            self.tcx.sess.create_err(errors::BadReturnTypeNotation::NeedsDots {\n+                                span: data.inputs_span,\n+                            })\n+                        };\n+                        if !self.tcx.features().return_type_notation\n+                            && self.tcx.sess.is_nightly_build()\n+                        {\n+                            add_feature_diagnostics(\n+                                &mut err,\n+                                &self.tcx.sess.parse_sess,\n+                                sym::return_type_notation,\n+                            );\n+                        }\n+                        err.emit();\n+                        GenericArgsCtor {\n+                            args: Default::default(),\n+                            bindings: &[],\n+                            parenthesized: hir::GenericArgsParentheses::ReturnTypeNotation,\n+                            span: data.span,\n+                        }\n+                    } else {\n+                        self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n+                        // FIXME(return_type_notation): we could issue a feature error\n+                        // if the parens are empty and there's no return type.\n+                        self.lower_angle_bracketed_parameter_data(\n+                            &data.as_angle_bracketed_args(),\n+                            ParamMode::Explicit,\n+                            itctx,\n+                        )\n+                        .0\n+                    }\n                 }\n             };\n             gen_args_ctor.into_generic_args(self)\n@@ -2075,7 +2117,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let future_args = self.arena.alloc(hir::GenericArgs {\n             args: &[],\n             bindings: arena_vec![self; self.output_ty_binding(span, output_ty)],\n-            parenthesized: false,\n+            parenthesized: hir::GenericArgsParentheses::No,\n             span_ext: DUMMY_SP,\n         });\n \n@@ -2595,13 +2637,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n struct GenericArgsCtor<'hir> {\n     args: SmallVec<[hir::GenericArg<'hir>; 4]>,\n     bindings: &'hir [hir::TypeBinding<'hir>],\n-    parenthesized: bool,\n+    parenthesized: hir::GenericArgsParentheses,\n     span: Span,\n }\n \n impl<'hir> GenericArgsCtor<'hir> {\n     fn is_empty(&self) -> bool {\n-        self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n+        self.args.is_empty()\n+            && self.bindings.is_empty()\n+            && self.parenthesized == hir::GenericArgsParentheses::No\n     }\n \n     fn into_generic_args(self, this: &LoweringContext<'_, 'hir>) -> &'hir hir::GenericArgs<'hir> {"}, {"sha": "1c47a969696d76695fbd45da7991db252339e8dc", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -13,6 +13,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::{smallvec, SmallVec};\n+use thin_vec::ThinVec;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     #[instrument(level = \"trace\", skip(self))]\n@@ -51,18 +52,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let parenthesized_generic_args = match base_res {\n                         // `a::b::Trait(Args)`\n                         Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n-                            ParenthesizedGenericArgs::Ok\n+                            ParenthesizedGenericArgs::ParenSugar\n                         }\n                         // `a::b::Trait(Args)::TraitItem`\n                         Res::Def(DefKind::AssocFn, _)\n                         | Res::Def(DefKind::AssocConst, _)\n                         | Res::Def(DefKind::AssocTy, _)\n                             if i + 2 == proj_start =>\n                         {\n-                            ParenthesizedGenericArgs::Ok\n+                            ParenthesizedGenericArgs::ParenSugar\n                         }\n                         // Avoid duplicated errors.\n-                        Res::Err => ParenthesizedGenericArgs::Ok,\n+                        Res::Err => ParenthesizedGenericArgs::ParenSugar,\n                         // An error\n                         _ => ParenthesizedGenericArgs::Err,\n                     };\n@@ -180,7 +181,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => {\n+                    ParenthesizedGenericArgs::ParenSugar => {\n                         self.lower_parenthesized_parameter_data(data, itctx)\n                     }\n                     ParenthesizedGenericArgs::Err => {\n@@ -218,13 +219,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         )\n                     }\n                 },\n+                &GenericArgs::ReturnTypeNotation(span) => {\n+                    self.tcx.sess.emit_err(GenericTypeWithParentheses { span, sub: None });\n+                    (\n+                        self.lower_angle_bracketed_parameter_data(\n+                            &AngleBracketedArgs { span, args: ThinVec::default() },\n+                            param_mode,\n+                            itctx,\n+                        )\n+                        .0,\n+                        false,\n+                    )\n+                }\n             }\n         } else {\n             (\n                 GenericArgsCtor {\n                     args: Default::default(),\n                     bindings: &[],\n-                    parenthesized: false,\n+                    parenthesized: hir::GenericArgsParentheses::No,\n                     span: path_span.shrink_to_hi(),\n                 },\n                 param_mode == ParamMode::Optional,\n@@ -233,7 +246,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let has_lifetimes =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n-        if !generic_args.parenthesized && !has_lifetimes {\n+\n+        // FIXME(return_type_notation): Is this correct? I think so.\n+        if generic_args.parenthesized != hir::GenericArgsParentheses::ParenSugar && !has_lifetimes {\n             self.maybe_insert_elided_lifetimes_in_path(\n                 path_span,\n                 segment.id,\n@@ -328,7 +343,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AngleBracketedArg::Constraint(c) => Some(self.lower_assoc_ty_constraint(c, itctx)),\n             AngleBracketedArg::Arg(_) => None,\n         }));\n-        let ctor = GenericArgsCtor { args, bindings, parenthesized: false, span: data.span };\n+        let ctor = GenericArgsCtor {\n+            args,\n+            bindings,\n+            parenthesized: hir::GenericArgsParentheses::No,\n+            span: data.span,\n+        };\n         (ctor, !has_non_lt_args && param_mode == ParamMode::Optional)\n     }\n \n@@ -376,7 +396,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             GenericArgsCtor {\n                 args,\n                 bindings: arena_vec![self; binding],\n-                parenthesized: true,\n+                parenthesized: hir::GenericArgsParentheses::ParenSugar,\n                 span: data.inputs_span,\n             },\n             false,\n@@ -396,7 +416,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let gen_args = self.arena.alloc(hir::GenericArgs {\n             args,\n             bindings,\n-            parenthesized: false,\n+            parenthesized: hir::GenericArgsParentheses::No,\n             span_ext: DUMMY_SP,\n         });\n         hir::TypeBinding {"}, {"sha": "44b6c77fc4195b18e9f028a28722d94114e41430", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1075,6 +1075,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.with_impl_trait(None, |this| this.visit_ty(ty));\n                 }\n             }\n+            GenericArgs::ReturnTypeNotation(_span) => {}\n         }\n     }\n \n@@ -1387,16 +1388,19 @@ fn deny_equality_constraints(\n                                     match &mut assoc_path.segments[len].args {\n                                         Some(args) => match args.deref_mut() {\n                                             GenericArgs::Parenthesized(_) => continue,\n+                                            GenericArgs::ReturnTypeNotation(_span) => continue,\n                                             GenericArgs::AngleBracketed(args) => {\n                                                 args.args.push(arg);\n                                             }\n                                         },\n                                         empty_args => {\n-                                            *empty_args = AngleBracketedArgs {\n-                                                span: ident.span,\n-                                                args: thin_vec![arg],\n-                                            }\n-                                            .into();\n+                                            *empty_args = Some(\n+                                                AngleBracketedArgs {\n+                                                    span: ident.span,\n+                                                    args: thin_vec![arg],\n+                                                }\n+                                                .into(),\n+                                            );\n                                         }\n                                     }\n                                     err.assoc = Some(errors::AssociatedSuggestion {"}, {"sha": "de94c1bc47794e06f13c2537fcebb6376f8a1a77", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -482,12 +482,28 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n     fn visit_assoc_constraint(&mut self, constraint: &'a AssocConstraint) {\n         if let AssocConstraintKind::Bound { .. } = constraint.kind {\n-            gate_feature_post!(\n-                &self,\n-                associated_type_bounds,\n-                constraint.span,\n-                \"associated type bounds are unstable\"\n-            )\n+            if let Some(args) = constraint.gen_args.as_ref()\n+                && matches!(\n+                    args,\n+                    ast::GenericArgs::ReturnTypeNotation(..) | ast::GenericArgs::Parenthesized(..)\n+                )\n+            {\n+                // RTN is gated elsewhere, and parenthesized args will turn into\n+                // another error.\n+                if matches!(args, ast::GenericArgs::Parenthesized(..)) {\n+                    self.sess.delay_span_bug(\n+                        constraint.span,\n+                        \"should have emitted a parenthesized generics error\",\n+                    );\n+                }\n+            } else {\n+                gate_feature_post!(\n+                    &self,\n+                    associated_type_bounds,\n+                    constraint.span,\n+                    \"associated type bounds are unstable\"\n+                )\n+            }\n         }\n         visit::walk_assoc_constraint(self, constraint)\n     }\n@@ -577,6 +593,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(yeet_expr, \"`do yeet` expression is experimental\");\n     gate_all!(dyn_star, \"`dyn*` trait objects are experimental\");\n     gate_all!(const_closures, \"const closures are experimental\");\n+    gate_all!(return_type_notation, \"return type notation is experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "80c451d675355564d4b42c3c95739a85d58e50d5", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -936,6 +936,10 @@ impl<'a> PrintState<'a> for State<'a> {\n                 self.word(\")\");\n                 self.print_fn_ret_ty(&data.output);\n             }\n+\n+            ast::GenericArgs::ReturnTypeNotation(_span) => {\n+                self.word(\"(..)\");\n+            }\n         }\n     }\n }"}, {"sha": "cb217be66547663af86c1a27f5421d08b3390392", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 297, "deletions": 294, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -226,307 +226,95 @@ impl UnstableReason {\n     }\n }\n \n-/// Collects stability info from all stability attributes in `attrs`.\n-/// Returns `None` if no stability attributes are found.\n+/// Collects stability info from `stable`/`unstable`/`rustc_allowed_through_unstable_modules`\n+/// attributes in `attrs`. Returns `None` if no stability attributes are found.\n pub fn find_stability(\n     sess: &Session,\n     attrs: &[Attribute],\n     item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-{\n-    find_stability_generic(sess, attrs.iter(), item_sp)\n-}\n-\n-fn find_stability_generic<'a, I>(\n-    sess: &Session,\n-    attrs_iter: I,\n-    item_sp: Span,\n-) -> (Option<(Stability, Span)>, Option<(ConstStability, Span)>, Option<(DefaultBodyStability, Span)>)\n-where\n-    I: Iterator<Item = &'a Attribute>,\n-{\n-    use StabilityLevel::*;\n-\n+) -> Option<(Stability, Span)> {\n     let mut stab: Option<(Stability, Span)> = None;\n-    let mut const_stab: Option<(ConstStability, Span)> = None;\n-    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n-    let mut promotable = false;\n     let mut allowed_through_unstable_modules = false;\n \n-    'outer: for attr in attrs_iter {\n-        if ![\n-            sym::rustc_const_unstable,\n-            sym::rustc_const_stable,\n-            sym::unstable,\n-            sym::stable,\n-            sym::rustc_promotable,\n-            sym::rustc_allowed_through_unstable_modules,\n-            sym::rustc_default_body_unstable,\n-        ]\n-        .iter()\n-        .any(|&s| attr.has_name(s))\n-        {\n-            continue; // not a stability level\n-        }\n-\n-        let meta = attr.meta();\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_allowed_through_unstable_modules => allowed_through_unstable_modules = true,\n+            sym::unstable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n \n-        if attr.has_name(sym::rustc_promotable) {\n-            promotable = true;\n-        } else if attr.has_name(sym::rustc_allowed_through_unstable_modules) {\n-            allowed_through_unstable_modules = true;\n-        }\n-        // attributes with data\n-        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n-            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n-                if item.is_some() {\n-                    handle_errors(\n-                        &sess.parse_sess,\n-                        meta.span,\n-                        AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n-                    );\n-                    return false;\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n                 }\n-                if let Some(v) = meta.value_str() {\n-                    *item = Some(v);\n-                    true\n-                } else {\n-                    sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n-                    false\n+            }\n+            sym::stable => {\n+                if stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-            };\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    stab = Some((Stability { level, feature }, attr.span));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n \n-            let meta_name = meta.name_or_empty();\n-            match meta_name {\n-                sym::rustc_const_unstable | sym::rustc_default_body_unstable | sym::unstable => {\n-                    if meta_name == sym::unstable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_unstable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_default_body_unstable && body_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n+    if allowed_through_unstable_modules {\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n+        }\n+    }\n \n-                    let mut feature = None;\n-                    let mut reason = None;\n-                    let mut issue = None;\n-                    let mut issue_num = None;\n-                    let mut is_soft = false;\n-                    let mut implied_by = None;\n-                    for meta in metas {\n-                        let Some(mi) = meta.meta_item() else {\n-                            handle_errors(\n-                                &sess.parse_sess,\n-                                meta.span(),\n-                                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n-                            );\n-                            continue 'outer;\n-                        };\n-                        match mi.name_or_empty() {\n-                            sym::feature => {\n-                                if !get(mi, &mut feature) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::reason => {\n-                                if !get(mi, &mut reason) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            sym::issue => {\n-                                if !get(mi, &mut issue) {\n-                                    continue 'outer;\n-                                }\n+    stab\n+}\n \n-                                // These unwraps are safe because `get` ensures the meta item\n-                                // is a name/value pair string literal.\n-                                issue_num = match issue.unwrap().as_str() {\n-                                    \"none\" => None,\n-                                    issue => match issue.parse::<NonZeroU32>() {\n-                                        Ok(num) => Some(num),\n-                                        Err(err) => {\n-                                            sess.emit_err(\n-                                                session_diagnostics::InvalidIssueString {\n-                                                    span: mi.span,\n-                                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n-                                                        mi.name_value_literal_span().unwrap(),\n-                                                        err.kind(),\n-                                                    ),\n-                                                },\n-                                            );\n-                                            continue 'outer;\n-                                        }\n-                                    },\n-                                };\n-                            }\n-                            sym::soft => {\n-                                if !mi.is_word() {\n-                                    sess.emit_err(session_diagnostics::SoftNoArgs {\n-                                        span: mi.span,\n-                                    });\n-                                }\n-                                is_soft = true;\n-                            }\n-                            sym::implied_by => {\n-                                if !get(mi, &mut implied_by) {\n-                                    continue 'outer;\n-                                }\n-                            }\n-                            _ => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    meta.span(),\n-                                    AttrError::UnknownMetaItem(\n-                                        pprust::path_to_string(&mi.path),\n-                                        &[\"feature\", \"reason\", \"issue\", \"soft\"],\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n+/// Collects stability info from `rustc_const_stable`/`rustc_const_unstable`/`rustc_promotable`\n+/// attributes in `attrs`. Returns `None` if no stability attributes are found.\n+pub fn find_const_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+    item_sp: Span,\n+) -> Option<(ConstStability, Span)> {\n+    let mut const_stab: Option<(ConstStability, Span)> = None;\n+    let mut promotable = false;\n \n-                    match (feature, reason, issue) {\n-                        (Some(feature), reason, Some(_)) => {\n-                            if !rustc_lexer::is_ident(feature.as_str()) {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    attr.span,\n-                                    AttrError::NonIdentFeature,\n-                                );\n-                                continue;\n-                            }\n-                            let level = Unstable {\n-                                reason: UnstableReason::from_opt_reason(reason),\n-                                issue: issue_num,\n-                                is_soft,\n-                                implied_by,\n-                            };\n-                            if sym::unstable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else if sym::rustc_const_unstable == meta_name {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            } else if sym::rustc_default_body_unstable == meta_name {\n-                                body_stab =\n-                                    Some((DefaultBodyStability { level, feature }, attr.span));\n-                            } else {\n-                                unreachable!(\"Unknown stability attribute {meta_name}\");\n-                            }\n-                        }\n-                        (None, _, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n-                            continue;\n-                        }\n-                    }\n+    for attr in attrs {\n+        match attr.name_or_empty() {\n+            sym::rustc_promotable => promotable = true,\n+            sym::rustc_const_unstable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n                 }\n-                sym::rustc_const_stable | sym::stable => {\n-                    if meta_name == sym::stable && stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    } else if meta_name == sym::rustc_const_stable && const_stab.is_some() {\n-                        handle_errors(\n-                            &sess.parse_sess,\n-                            attr.span,\n-                            AttrError::MultipleStabilityLevels,\n-                        );\n-                        break;\n-                    }\n-\n-                    let mut feature = None;\n-                    let mut since = None;\n-                    for meta in metas {\n-                        match meta {\n-                            NestedMetaItem::MetaItem(mi) => match mi.name_or_empty() {\n-                                sym::feature => {\n-                                    if !get(mi, &mut feature) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                sym::since => {\n-                                    if !get(mi, &mut since) {\n-                                        continue 'outer;\n-                                    }\n-                                }\n-                                _ => {\n-                                    handle_errors(\n-                                        &sess.parse_sess,\n-                                        meta.span(),\n-                                        AttrError::UnknownMetaItem(\n-                                            pprust::path_to_string(&mi.path),\n-                                            &[\"feature\", \"since\"],\n-                                        ),\n-                                    );\n-                                    continue 'outer;\n-                                }\n-                            },\n-                            NestedMetaItem::Lit(lit) => {\n-                                handle_errors(\n-                                    &sess.parse_sess,\n-                                    lit.span,\n-                                    AttrError::UnsupportedLiteral(\n-                                        UnsupportedLiteralReason::Generic,\n-                                        false,\n-                                    ),\n-                                );\n-                                continue 'outer;\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n-                        since = Some(rust_version_symbol());\n-                    }\n \n-                    match (feature, since) {\n-                        (Some(feature), Some(since)) => {\n-                            let level = Stable { since, allowed_through_unstable_modules: false };\n-                            if sym::stable == meta_name {\n-                                stab = Some((Stability { level, feature }, attr.span));\n-                            } else {\n-                                const_stab = Some((\n-                                    ConstStability { level, feature, promotable: false },\n-                                    attr.span,\n-                                ));\n-                            }\n-                        }\n-                        (None, _) => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n-                            continue;\n-                        }\n-                        _ => {\n-                            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n-                            continue;\n-                        }\n-                    }\n+                if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n+                }\n+            }\n+            sym::rustc_const_stable => {\n+                if const_stab.is_some() {\n+                    handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                    break;\n+                }\n+                if let Some((feature, level)) = parse_stability(sess, attr) {\n+                    const_stab =\n+                        Some((ConstStability { level, feature, promotable: false }, attr.span));\n                 }\n-                _ => unreachable!(),\n             }\n+            _ => {}\n         }\n     }\n \n@@ -538,22 +326,237 @@ where\n         }\n     }\n \n-    if allowed_through_unstable_modules {\n-        match &mut stab {\n-            Some((\n-                Stability {\n-                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n-                    ..\n-                },\n-                _,\n-            )) => *allowed_through_unstable_modules = true,\n+    const_stab\n+}\n+\n+/// Collects stability info from `rustc_default_body_unstable` attributes in `attrs`.\n+/// Returns `None` if no stability attributes are found.\n+pub fn find_body_stability(\n+    sess: &Session,\n+    attrs: &[Attribute],\n+) -> Option<(DefaultBodyStability, Span)> {\n+    let mut body_stab: Option<(DefaultBodyStability, Span)> = None;\n+\n+    for attr in attrs {\n+        if attr.has_name(sym::rustc_default_body_unstable) {\n+            if body_stab.is_some() {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::MultipleStabilityLevels);\n+                break;\n+            }\n+\n+            if let Some((feature, level)) = parse_unstability(sess, attr) {\n+                body_stab = Some((DefaultBodyStability { level, feature }, attr.span));\n+            }\n+        }\n+    }\n+\n+    body_stab\n+}\n+\n+/// Read the content of a `stable`/`rustc_const_stable` attribute, and return the feature name and\n+/// its stability information.\n+fn parse_stability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut since = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::since => {\n+                if !insert_or_error(mi, &mut since) {\n+                    return None;\n+                }\n+            }\n             _ => {\n-                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"since\"],\n+                    ),\n+                );\n+                return None;\n             }\n         }\n     }\n \n-    (stab, const_stab, body_stab)\n+    if let Some(s) = since && s.as_str() == VERSION_PLACEHOLDER {\n+        since = Some(rust_version_symbol());\n+    }\n+\n+    match (feature, since) {\n+        (Some(feature), Some(since)) => {\n+            let level = StabilityLevel::Stable { since, allowed_through_unstable_modules: false };\n+            Some((feature, level))\n+        }\n+        (None, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            None\n+        }\n+        _ => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingSince);\n+            None\n+        }\n+    }\n+}\n+\n+/// Read the content of a `unstable`/`rustc_const_unstable`/`rustc_default_body_unstable`\n+/// attribute, and return the feature name and its stability information.\n+fn parse_unstability(sess: &Session, attr: &Attribute) -> Option<(Symbol, StabilityLevel)> {\n+    let meta = attr.meta()?;\n+    let MetaItem { kind: MetaItemKind::List(ref metas), .. } = meta else { return None };\n+    let insert_or_error = |meta: &MetaItem, item: &mut Option<Symbol>| {\n+        if item.is_some() {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span,\n+                AttrError::MultipleItem(pprust::path_to_string(&meta.path)),\n+            );\n+            return false;\n+        }\n+        if let Some(v) = meta.value_str() {\n+            *item = Some(v);\n+            true\n+        } else {\n+            sess.emit_err(session_diagnostics::IncorrectMetaItem { span: meta.span });\n+            false\n+        }\n+    };\n+\n+    let mut feature = None;\n+    let mut reason = None;\n+    let mut issue = None;\n+    let mut issue_num = None;\n+    let mut is_soft = false;\n+    let mut implied_by = None;\n+    for meta in metas {\n+        let Some(mi) = meta.meta_item() else {\n+            handle_errors(\n+                &sess.parse_sess,\n+                meta.span(),\n+                AttrError::UnsupportedLiteral(UnsupportedLiteralReason::Generic, false),\n+            );\n+            return None;\n+        };\n+\n+        match mi.name_or_empty() {\n+            sym::feature => {\n+                if !insert_or_error(mi, &mut feature) {\n+                    return None;\n+                }\n+            }\n+            sym::reason => {\n+                if !insert_or_error(mi, &mut reason) {\n+                    return None;\n+                }\n+            }\n+            sym::issue => {\n+                if !insert_or_error(mi, &mut issue) {\n+                    return None;\n+                }\n+\n+                // These unwraps are safe because `insert_or_error` ensures the meta item\n+                // is a name/value pair string literal.\n+                issue_num = match issue.unwrap().as_str() {\n+                    \"none\" => None,\n+                    issue => match issue.parse::<NonZeroU32>() {\n+                        Ok(num) => Some(num),\n+                        Err(err) => {\n+                            sess.emit_err(\n+                                session_diagnostics::InvalidIssueString {\n+                                    span: mi.span,\n+                                    cause: session_diagnostics::InvalidIssueStringCause::from_int_error_kind(\n+                                        mi.name_value_literal_span().unwrap(),\n+                                        err.kind(),\n+                                    ),\n+                                },\n+                            );\n+                            return None;\n+                        }\n+                    },\n+                };\n+            }\n+            sym::soft => {\n+                if !mi.is_word() {\n+                    sess.emit_err(session_diagnostics::SoftNoArgs { span: mi.span });\n+                }\n+                is_soft = true;\n+            }\n+            sym::implied_by => {\n+                if !insert_or_error(mi, &mut implied_by) {\n+                    return None;\n+                }\n+            }\n+            _ => {\n+                handle_errors(\n+                    &sess.parse_sess,\n+                    meta.span(),\n+                    AttrError::UnknownMetaItem(\n+                        pprust::path_to_string(&mi.path),\n+                        &[\"feature\", \"reason\", \"issue\", \"soft\", \"implied_by\"],\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+    }\n+\n+    match (feature, reason, issue) {\n+        (Some(feature), reason, Some(_)) => {\n+            if !rustc_lexer::is_ident(feature.as_str()) {\n+                handle_errors(&sess.parse_sess, attr.span, AttrError::NonIdentFeature);\n+                return None;\n+            }\n+            let level = StabilityLevel::Unstable {\n+                reason: UnstableReason::from_opt_reason(reason),\n+                issue: issue_num,\n+                is_soft,\n+                implied_by,\n+            };\n+            Some((feature, level))\n+        }\n+        (None, _, _) => {\n+            handle_errors(&sess.parse_sess, attr.span, AttrError::MissingFeature);\n+            return None;\n+        }\n+        _ => {\n+            sess.emit_err(session_diagnostics::MissingIssue { span: attr.span });\n+            return None;\n+        }\n+    }\n }\n \n pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {"}, {"sha": "d2d9779dbea47570e4bb9aaffd29269791f7c6bc", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n \n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::{RegionVid, VarianceDiagInfo};\n use rustc_span::Span;\n@@ -60,7 +60,9 @@ impl<'tcx> OutlivesConstraintSet<'tcx> {\n         Sccs::new(region_graph)\n     }\n \n-    pub(crate) fn outlives(&self) -> &IndexVec<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n+    pub(crate) fn outlives(\n+        &self,\n+    ) -> &IndexSlice<OutlivesConstraintIndex, OutlivesConstraint<'tcx>> {\n         &self.outlives\n     }\n }"}, {"sha": "cb1a65222237096efe7c715c369d2aedd4cad3eb", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_middle::mir::Body;\n use rustc_middle::ty::{self, TyCtxt};\n@@ -35,6 +35,6 @@ pub fn get_body_with_borrowck_facts(\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n-    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    let promoted: &IndexSlice<_, _> = &promoted.borrow();\n     *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n }"}, {"sha": "8860395e71c80cb7e3387346066160901abe84ba", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::intravisit::Visitor;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, LocalInfo, Location, Operand, Place,\n@@ -60,7 +60,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n+        local_names: &IndexSlice<Local, Option<Symbol>>,\n         err: &mut Diagnostic,\n         borrow_desc: &str,\n         borrow_span: Option<Span>,"}, {"sha": "7bd4331c5ed92b79130535a45e05b7b6a665b565", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,18 +6,19 @@ use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, Namespace};\n use rustc_hir::GeneratorKind;\n+use rustc_index::vec::IndexSlice;\n use rustc_infer::infer::{LateBoundRegionConversionTime, TyCtxtInferExt};\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n-    AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n-    Place, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n+    AggregateKind, Constant, FakeReadCause, Local, LocalInfo, LocalKind, Location, Operand, Place,\n+    PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     type_known_to_meet_bound_modulo_regions, Obligation, ObligationCause,\n@@ -302,7 +303,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn describe_field(\n         &self,\n         place: PlaceRef<'tcx>,\n-        field: Field,\n+        field: FieldIdx,\n         including_tuple_field: IncludingTupleField,\n     ) -> Option<String> {\n         let place_ty = match place {\n@@ -331,7 +332,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn describe_field_from_ty(\n         &self,\n         ty: Ty<'_>,\n-        field: Field,\n+        field: FieldIdx,\n         variant_index: Option<VariantIdx>,\n         including_tuple_field: IncludingTupleField,\n     ) -> Option<String> {\n@@ -350,7 +351,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if !including_tuple_field.0 && variant.ctor_kind() == Some(CtorKind::Fn) {\n                         return None;\n                     }\n-                    Some(variant.fields[field.index()].name.to_string())\n+                    Some(variant.fields[field].name.to_string())\n                 }\n                 ty::Tuple(_) => Some(field.index().to_string()),\n                 ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n@@ -825,7 +826,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     debug!(\"move_spans: def_id={:?} place={:?}\", closure_def_id, place);\n                     let places = &[Operand::Move(place)];\n                     if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                        self.closure_span(closure_def_id, moved_place, places)\n+                        self.closure_span(closure_def_id, moved_place, IndexSlice::from_raw(places))\n                     {\n                         return ClosureUse {\n                             generator_kind,\n@@ -975,7 +976,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         def_id: LocalDefId,\n         target_place: PlaceRef<'tcx>,\n-        places: &[Operand<'tcx>],\n+        places: &IndexSlice<FieldIdx, Operand<'tcx>>,\n     ) -> Option<(Span, Option<GeneratorKind>, Span, Span)> {\n         debug!(\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\","}, {"sha": "9d90400965040efecda0a07f5914f72c50002d15", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::{\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, BytePos, Span};\n+use rustc_target::abi::FieldIdx;\n \n use crate::diagnostics::BorrowedContentSource;\n use crate::MirBorrowckCtxt;\n@@ -1275,7 +1276,7 @@ fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n fn get_mut_span_in_struct_field<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    field: mir::Field,\n+    field: FieldIdx,\n ) -> Option<Span> {\n     // Expect our local to be a reference to a struct of some kind.\n     if let ty::Ref(_, ty, _) = ty.kind()"}, {"sha": "80b2787ce0c42fde3119d497704f0377c8e9e036", "filename": "compiler/rustc_borrowck/src/diagnostics/var_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fvar_name.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@\n \n use crate::Upvar;\n use crate::{nll::ToRegionVid, region_infer::RegionInferenceContext};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice};\n use rustc_middle::mir::{Body, Local};\n use rustc_middle::ty::{RegionVid, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -14,7 +14,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n+        local_names: &IndexSlice<Local, Option<Symbol>>,\n         upvars: &[Upvar<'tcx>],\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n@@ -113,7 +113,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn get_argument_name_and_span_for_region(\n         &self,\n         body: &Body<'tcx>,\n-        local_names: &IndexVec<Local, Option<Symbol>>,\n+        local_names: &IndexSlice<Local, Option<Symbol>>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n         let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();"}, {"sha": "1d4d1406239d9ba20f44c00f1f3a383bc012e777", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(rustc_attrs)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n@@ -23,7 +23,7 @@ use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticMessage, Subdiagnost\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_infer::infer::{\n     DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n };\n@@ -33,12 +33,13 @@ use rustc_middle::mir::{\n     Place, PlaceElem, PlaceRef, VarDebugInfoContents,\n };\n use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc_middle::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n+use rustc_middle::mir::{ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, CapturedPlace, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::UNUSED_MUT;\n use rustc_span::{Span, Symbol};\n+use rustc_target::abi::FieldIdx;\n \n use either::Either;\n use smallvec::SmallVec;\n@@ -153,7 +154,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n     let infcx =\n         tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n-    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    let promoted: &IndexSlice<_, _> = &promoted.borrow();\n     let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, false).0;\n     debug!(\"mir_borrowck done\");\n \n@@ -169,7 +170,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> &Bor\n fn do_mir_borrowck<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n-    input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    input_promoted: &IndexSlice<Promoted, Body<'tcx>>,\n     return_body_with_facts: bool,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.with_opt_param().as_local().unwrap();\n@@ -222,7 +223,7 @@ fn do_mir_borrowck<'tcx>(\n     // be modified (in place) to contain non-lexical lifetimes. It\n     // will have a lifetime tied to the inference context.\n     let mut body_owned = input_body.clone();\n-    let mut promoted = input_promoted.clone();\n+    let mut promoted = input_promoted.to_owned();\n     let free_regions =\n         nll::replace_regions_in_mir(&infcx, param_env, &mut body_owned, &mut promoted);\n     let body = &body_owned; // no further changes\n@@ -597,7 +598,7 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     used_mut: FxIndexSet<Local>,\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n-    used_mut_upvars: SmallVec<[Field; 8]>,\n+    used_mut_upvars: SmallVec<[FieldIdx; 8]>,\n     /// Region inference context. This contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n     regioncx: Rc<RegionInferenceContext<'tcx>>,\n@@ -1342,7 +1343,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n-                            self.propagate_closure_used_mut_upvar(&operands[field.index()]);\n+                            self.propagate_closure_used_mut_upvar(&operands[*field]);\n                         }\n                     }\n                     AggregateKind::Adt(..)\n@@ -2277,7 +2278,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// then returns the index of the field being projected. Note that this closure will always\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n-    fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n+    fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<FieldIdx> {\n         path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())\n     }\n "}, {"sha": "f637e6a95ac686cfb55b7def21c27b6081c83578", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,7 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxIndexMap;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::infer::MemberConstraint;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n@@ -215,7 +215,7 @@ where\n /// target_list: A -> B -> C -> D -> E -> F -> (None)\n /// ```\n fn append_list(\n-    constraints: &mut IndexVec<NllMemberConstraintIndex, NllMemberConstraint<'_>>,\n+    constraints: &mut IndexSlice<NllMemberConstraintIndex, NllMemberConstraint<'_>>,\n     target_list: NllMemberConstraintIndex,\n     source_list: NllMemberConstraintIndex,\n ) {"}, {"sha": "06ecbdb1707c58e987c4e92d7c03bf3aba4edf43", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,7 +4,7 @@\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n@@ -59,7 +59,7 @@ pub(crate) fn replace_regions_in_mir<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n-    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+    promoted: &mut IndexSlice<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     let def = body.source.with_opt_param().as_local().unwrap();\n \n@@ -158,7 +158,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n-    promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    promoted: &IndexSlice<Promoted, Body<'tcx>>,\n     location_table: &LocationTable,\n     param_env: ty::ParamEnv<'tcx>,\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,"}, {"sha": "ea9f8683ca7bbb24e50c5916a913c0335890b5f9", "filename": "compiler/rustc_borrowck/src/path_utils.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fpath_utils.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -7,8 +7,9 @@ use crate::BorrowIndex;\n use crate::Upvar;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::BorrowKind;\n-use rustc_middle::mir::{BasicBlock, Body, Field, Location, Place, PlaceRef, ProjectionElem};\n+use rustc_middle::mir::{BasicBlock, Body, Location, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::TyCtxt;\n+use rustc_target::abi::FieldIdx;\n \n /// Returns `true` if the borrow represented by `kind` is\n /// allowed to be split into separate Reservation and\n@@ -148,7 +149,7 @@ pub(crate) fn is_upvar_field_projection<'tcx>(\n     upvars: &[Upvar<'tcx>],\n     place_ref: PlaceRef<'tcx>,\n     body: &Body<'tcx>,\n-) -> Option<Field> {\n+) -> Option<FieldIdx> {\n     let mut place_ref = place_ref;\n     let mut by_ref = false;\n "}, {"sha": "f67af4584a4a561abdaabaa84de0d7787cbda5b7", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n@@ -399,7 +399,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// the minimum, or narrowest, universe.\n     fn compute_scc_universes(\n         constraint_sccs: &Sccs<RegionVid, ConstraintSccIndex>,\n-        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+        definitions: &IndexSlice<RegionVid, RegionDefinition<'tcx>>,\n     ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n         let num_sccs = constraint_sccs.num_sccs();\n         let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n@@ -486,7 +486,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// more details.\n     fn compute_scc_representatives(\n         constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n-        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+        definitions: &IndexSlice<RegionVid, RegionDefinition<'tcx>>,\n     ) -> IndexVec<ConstraintSccIndex, ty::RegionVid> {\n         let num_sccs = constraints_scc.num_sccs();\n         let next_region_vid = definitions.next_index();"}, {"sha": "0fbf01dbe4455c4e0164c30ed4431618eaed4152", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,7 +1,7 @@\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n use crate::BorrowckInferCtxt;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::Constant;\n@@ -16,7 +16,7 @@ use rustc_span::{Span, Symbol};\n pub fn renumber_mir<'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &mut Body<'tcx>,\n-    promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n+    promoted: &mut IndexSlice<Promoted, Body<'tcx>>,\n ) {\n     debug!(?body.arg_count);\n "}, {"sha": "2fc4e32ecb24e311243cd0e12ee5c9473c55fa6f", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -14,7 +14,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n@@ -36,7 +36,7 @@ use rustc_middle::ty::{\n };\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -125,7 +125,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n-    promoted: &IndexVec<Promoted, Body<'tcx>>,\n+    promoted: &IndexSlice<Promoted, Body<'tcx>>,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n     location_table: &LocationTable,\n     borrow_set: &BorrowSet<'tcx>,\n@@ -292,7 +292,7 @@ enum FieldAccessError {\n /// is a problem.\n struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n-    promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n+    promoted: &'b IndexSlice<Promoted, Body<'tcx>>,\n     last_span: Span,\n     errors_reported: bool,\n }\n@@ -493,7 +493,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     fn new(\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n-        promoted: &'b IndexVec<Promoted, Body<'tcx>>,\n+        promoted: &'b IndexSlice<Promoted, Body<'tcx>>,\n     ) -> Self {\n         TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n     }\n@@ -786,7 +786,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         &mut self,\n         parent: &dyn fmt::Debug,\n         base_ty: PlaceTy<'tcx>,\n-        field: Field,\n+        field: FieldIdx,\n         location: Location,\n     ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n@@ -812,7 +812,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             },\n             PlaceTy { ty, variant_index: None } => match *ty.kind() {\n                 ty::Adt(adt_def, substs) if !adt_def.is_enum() => {\n-                    (adt_def.variant(VariantIdx::new(0)), substs)\n+                    (adt_def.variant(FIRST_VARIANT), substs)\n                 }\n                 ty::Closure(_, substs) => {\n                     return match substs\n@@ -854,7 +854,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             },\n         };\n \n-        if let Some(field) = variant.fields.get(field.index()) {\n+        if let Some(field) = variant.fields.get(field) {\n             Ok(self.cx.normalize(field.ty(tcx, substs), location))\n         } else {\n             Err(FieldAccessError::OutOfRange { field_count: variant.fields.len() })\n@@ -1716,7 +1716,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn aggregate_field_ty(\n         &mut self,\n         ak: &AggregateKind<'tcx>,\n-        field_index: usize,\n+        field_index: FieldIdx,\n         location: Location,\n     ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n@@ -1733,7 +1733,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n             }\n             AggregateKind::Closure(_, substs) => {\n-                match substs.as_closure().upvar_tys().nth(field_index) {\n+                match substs.as_closure().upvar_tys().nth(field_index.as_usize()) {\n                     Some(ty) => Ok(ty),\n                     None => Err(FieldAccessError::OutOfRange {\n                         field_count: substs.as_closure().upvar_tys().count(),\n@@ -1744,7 +1744,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // It doesn't make sense to look at a field beyond the prefix;\n                 // these require a variant index, and are not initialized in\n                 // aggregate rvalues.\n-                match substs.as_generator().prefix_tys().nth(field_index) {\n+                match substs.as_generator().prefix_tys().nth(field_index.as_usize()) {\n                     Some(ty) => Ok(ty),\n                     None => Err(FieldAccessError::OutOfRange {\n                         field_count: substs.as_generator().prefix_tys().count(),\n@@ -2349,7 +2349,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         body: &Body<'tcx>,\n         rvalue: &Rvalue<'tcx>,\n         aggregate_kind: &AggregateKind<'tcx>,\n-        operands: &[Operand<'tcx>],\n+        operands: &IndexSlice<FieldIdx, Operand<'tcx>>,\n         location: Location,\n     ) {\n         let tcx = self.tcx();\n@@ -2361,16 +2361,16 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             return;\n         }\n \n-        for (i, operand) in operands.iter().enumerate() {\n+        for (i, operand) in operands.iter_enumerated() {\n             let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n                 Ok(field_ty) => field_ty,\n                 Err(FieldAccessError::OutOfRange { field_count }) => {\n                     span_mirbug!(\n                         self,\n                         rvalue,\n                         \"accessed field #{} but variant only has {}\",\n-                        i,\n-                        field_count\n+                        i.as_u32(),\n+                        field_count,\n                     );\n                     continue;\n                 }"}, {"sha": "87e4ac2660579dd20595bd721021326b7a601101", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -235,9 +235,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.9.2\"\n+version = \"1.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1885e79c1fc4b10f0e172c475f458b7f7b93061064d98c3293e98c5ba0c8b399\"\n+checksum = \"bd070e393353796e801d209ad339e89596eb4c8d430d18ede6a1cced8fafbd99\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\","}, {"sha": "5dadcaaec42ce718a278a967cf4290b320d278fb", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -25,7 +25,7 @@ target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n-indexmap = \"1.9.1\"\n+indexmap = \"1.9.3\"\n libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\"\n smallvec = \"1.8.1\""}, {"sha": "91c085d3d698684b0d2b4cbd13c84ba9d063256b", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -327,7 +327,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n             ArgKind::Spread(params) => {\n                 for (i, param) in params.into_iter().enumerate() {\n                     if let Some(param) = param {\n-                        place.place_field(fx, mir::Field::new(i)).write_cvalue(fx, param);\n+                        place.place_field(fx, FieldIdx::new(i)).write_cvalue(fx, param);\n                     }\n                 }\n             }\n@@ -460,7 +460,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         args.push(self_arg);\n         for i in 0..tupled_arguments.len() {\n             args.push(CallArgument {\n-                value: pack_arg.value.value_field(fx, mir::Field::new(i)),\n+                value: pack_arg.value.value_field(fx, FieldIdx::new(i)),\n                 is_owned: pack_arg.is_owned,\n             });\n         }"}, {"sha": "2630f02e6eb317102d6d5b70c873c6ca1d9811f6", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -379,6 +379,18 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                             source_info.span,\n                         );\n                     }\n+                    AssertKind::MisalignedPointerDereference { ref required, ref found } => {\n+                        let required = codegen_operand(fx, required).load_scalar(fx);\n+                        let found = codegen_operand(fx, found).load_scalar(fx);\n+                        let location = fx.get_caller_location(source_info).load_scalar(fx);\n+\n+                        codegen_panic_inner(\n+                            fx,\n+                            rustc_hir::LangItem::PanicBoundsCheck,\n+                            &[required, found, location],\n+                            source_info.span,\n+                        );\n+                    }\n                     _ => {\n                         let msg_str = msg.description();\n                         codegen_panic(fx, msg_str, source_info);\n@@ -785,19 +797,20 @@ fn codegen_stmt<'tcx>(\n                             let variant_dest = lval.downcast_variant(fx, variant_index);\n                             (variant_index, variant_dest, active_field_index)\n                         }\n-                        _ => (VariantIdx::from_u32(0), lval, None),\n+                        _ => (FIRST_VARIANT, lval, None),\n                     };\n                     if active_field_index.is_some() {\n                         assert_eq!(operands.len(), 1);\n                     }\n-                    for (i, operand) in operands.iter().enumerate() {\n+                    for (i, operand) in operands.iter_enumerated() {\n                         let operand = codegen_operand(fx, operand);\n                         let field_index = active_field_index.unwrap_or(i);\n                         let to = if let mir::AggregateKind::Array(_) = **kind {\n-                            let index = fx.bcx.ins().iconst(fx.pointer_type, field_index as i64);\n+                            let array_index = i64::from(field_index.as_u32());\n+                            let index = fx.bcx.ins().iconst(fx.pointer_type, array_index);\n                             variant_dest.place_index(fx, index)\n                         } else {\n-                            variant_dest.place_field(fx, mir::Field::new(field_index))\n+                            variant_dest.place_field(fx, field_index)\n                         };\n                         to.write_cvalue(fx, operand);\n                     }"}, {"sha": "ebb4de33f990a2e118c5dea57f4ad760ed279f63", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -54,12 +54,22 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n     def_id: DefId,\n     layout: TyAndLayout<'tcx>,\n ) -> CValue<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    if fx.clif_comments.enabled() {\n-        fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n-    }\n-    let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n+    let tls_ptr = if !def_id.is_local() && fx.tcx.needs_thread_local_shim(def_id) {\n+        let instance = ty::Instance {\n+            def: ty::InstanceDef::ThreadLocalShim(def_id),\n+            substs: ty::InternalSubsts::empty(),\n+        };\n+        let func_ref = fx.get_function_ref(instance);\n+        let call = fx.bcx.ins().call(func_ref, &[]);\n+        fx.bcx.func.dfg.first_result(call)\n+    } else {\n+        let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n+        let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n+        if fx.clif_comments.enabled() {\n+            fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+        }\n+        fx.bcx.ins().tls_value(fx.pointer_type, local_data_id)\n+    };\n     CValue::by_val(tls_ptr, layout)\n }\n "}, {"sha": "f740945a03c31578b8b025a062288d44d9ea6a16", "filename": "compiler/rustc_codegen_cranelift/src/discriminant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdiscriminant.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             tag_encoding: TagEncoding::Direct,\n             variants: _,\n         } => {\n-            let ptr = place.place_field(fx, mir::Field::new(tag_field));\n+            let ptr = place.place_field(fx, FieldIdx::new(tag_field));\n             let to = layout.ty.discriminant_for_variant(fx.tcx, variant_index).unwrap().val;\n             let to = if ptr.layout().abi.is_signed() {\n                 ty::ScalarInt::try_from_int(\n@@ -47,7 +47,7 @@ pub(crate) fn codegen_set_discriminant<'tcx>(\n             variants: _,\n         } => {\n             if variant_index != untagged_variant {\n-                let niche = place.place_field(fx, mir::Field::new(tag_field));\n+                let niche = place.place_field(fx, FieldIdx::new(tag_field));\n                 let niche_type = fx.clif_type(niche.layout().ty).unwrap();\n                 let niche_value = variant_index.as_u32() - niche_variants.start().as_u32();\n                 let niche_value = (niche_value as u128).wrapping_add(niche_start);\n@@ -107,7 +107,7 @@ pub(crate) fn codegen_get_discriminant<'tcx>(\n     let cast_to = fx.clif_type(dest_layout.ty).unwrap();\n \n     // Read the tag/niche-encoded discriminant from memory.\n-    let tag = value.value_field(fx, mir::Field::new(tag_field));\n+    let tag = value.value_field(fx, FieldIdx::new(tag_field));\n     let tag = tag.load_scalar(fx);\n \n     // Decode the discriminant (specifically if it's niche-encoded)."}, {"sha": "0f32d1a25ffade75762b0c7b39f5cbbfcb411089", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm_x86.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -179,8 +179,8 @@ fn llvm_add_sub<'tcx>(\n \n     // c + carry -> c + first intermediate carry or borrow respectively\n     let int0 = crate::num::codegen_checked_int_binop(fx, bin_op, a, b);\n-    let c = int0.value_field(fx, mir::Field::new(0));\n-    let cb0 = int0.value_field(fx, mir::Field::new(1)).load_scalar(fx);\n+    let c = int0.value_field(fx, FieldIdx::new(0));\n+    let cb0 = int0.value_field(fx, FieldIdx::new(1)).load_scalar(fx);\n \n     // c + carry -> c + second intermediate carry or borrow respectively\n     let cb_in_as_u64 = fx.bcx.ins().uextend(types::I64, cb_in);"}, {"sha": "6f54a8d49c8674d8b320d72b0ae84fa0a5387505", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -253,7 +253,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n \n             ret.write_cvalue(fx, base);\n-            let ret_lane = ret.place_field(fx, mir::Field::new(idx.try_into().unwrap()));\n+            let ret_lane = ret.place_field(fx, FieldIdx::new(idx.try_into().unwrap()));\n             ret_lane.write_cvalue(fx, val);\n         }\n "}, {"sha": "8cc7f6c34b021ac8d7c9c06e166693228633f425", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -86,7 +86,7 @@ mod prelude {\n         self, FloatTy, Instance, InstanceDef, IntTy, ParamEnv, Ty, TyCtxt, TypeAndMut,\n         TypeFoldable, TypeVisitableExt, UintTy,\n     };\n-    pub(crate) use rustc_target::abi::{Abi, Scalar, Size, VariantIdx};\n+    pub(crate) use rustc_target::abi::{Abi, FieldIdx, Scalar, Size, VariantIdx, FIRST_VARIANT};\n \n     pub(crate) use rustc_data_structures::fx::FxHashMap;\n "}, {"sha": "ff0e12410e7031498d13b61e02bc1e3525401055", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -146,9 +146,9 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variant(VariantIdx::new(0)).fields.len() {\n-                let src_f = src.value_field(fx, mir::Field::new(i));\n-                let dst_f = dst.place_field(fx, mir::Field::new(i));\n+            for i in 0..def_a.variant(FIRST_VARIANT).fields.len() {\n+                let src_f = src.value_field(fx, FieldIdx::new(i));\n+                let dst_f = dst.place_field(fx, FieldIdx::new(i));\n \n                 if dst_f.layout().is_zst() {\n                     continue;"}, {"sha": "1b69862ce2ca1642c81eb71a7b04f6d64733ecf1", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,7 +10,7 @@ fn codegen_field<'tcx>(\n     base: Pointer,\n     extra: Option<Value>,\n     layout: TyAndLayout<'tcx>,\n-    field: mir::Field,\n+    field: FieldIdx,\n ) -> (Pointer, TyAndLayout<'tcx>) {\n     let field_offset = layout.fields.offset(field.index());\n     let field_layout = layout.field(&*fx, field.index());\n@@ -210,7 +210,7 @@ impl<'tcx> CValue<'tcx> {\n     pub(crate) fn value_field(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n-        field: mir::Field,\n+        field: FieldIdx,\n     ) -> CValue<'tcx> {\n         let layout = self.1;\n         match self.0 {\n@@ -687,7 +687,7 @@ impl<'tcx> CPlace<'tcx> {\n     pub(crate) fn place_field(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n-        field: mir::Field,\n+        field: FieldIdx,\n     ) -> CPlace<'tcx> {\n         let layout = self.layout();\n \n@@ -701,7 +701,8 @@ impl<'tcx> CPlace<'tcx> {\n                     };\n                 }\n                 ty::Adt(adt_def, substs) if layout.ty.is_simd() => {\n-                    let f0_ty = adt_def.non_enum_variant().fields[0].ty(fx.tcx, substs);\n+                    let f0 = &adt_def.non_enum_variant().fields[FieldIdx::from_u32(0)];\n+                    let f0_ty = f0.ty(fx.tcx, substs);\n \n                     match f0_ty.kind() {\n                         ty::Array(_, _) => {"}, {"sha": "b309695c190f8b4b6489a251870fa04116c39957", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -50,7 +50,7 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n         if let Abi::Scalar(_) = arg.layout().abi {\n             'descend_newtypes: while !arg.layout().ty.is_unsafe_ptr() && !arg.layout().ty.is_ref() {\n                 for i in 0..arg.layout().fields.count() {\n-                    let field = arg.value_field(fx, mir::Field::new(i));\n+                    let field = arg.value_field(fx, FieldIdx::new(i));\n                     if !field.layout().is_zst() {\n                         // we found the one non-zero-sized field that is allowed\n                         // now find *its* non-zero-sized field, or stop if it's a\n@@ -68,9 +68,9 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n             if ty.is_dyn_star() {\n                 let inner_layout = fx.layout_of(arg.layout().ty.builtin_deref(true).unwrap().ty);\n                 let dyn_star = CPlace::for_ptr(Pointer::new(arg.load_scalar(fx)), inner_layout);\n-                let ptr = dyn_star.place_field(fx, mir::Field::new(0)).to_ptr();\n+                let ptr = dyn_star.place_field(fx, FieldIdx::new(0)).to_ptr();\n                 let vtable =\n-                    dyn_star.place_field(fx, mir::Field::new(1)).to_cvalue(fx).load_scalar(fx);\n+                    dyn_star.place_field(fx, FieldIdx::new(1)).to_cvalue(fx).load_scalar(fx);\n                 break 'block (ptr, vtable);\n             }\n         }"}, {"sha": "0f2e152f8ce5641b8a1f35836eff167822010106", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -35,17 +35,17 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#fe242b7eb26980e6c78859d51c8d4cc1e43381a3\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#fe242b7eb26980e6c78859d51c8d4cc1e43381a3\"\n dependencies = [\n- \"libc 0.1.12\",\n+ \"libc\",\n ]\n \n [[package]]\n@@ -64,7 +64,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.112\",\n+ \"libc\",\n  \"wasi\",\n ]\n \n@@ -74,7 +74,7 @@ version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"libc 0.2.112\",\n+ \"libc\",\n ]\n \n [[package]]\n@@ -85,20 +85,14 @@ checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n dependencies = [\n  \"fm\",\n  \"getopts\",\n- \"libc 0.2.112\",\n+ \"libc\",\n  \"num_cpus\",\n  \"termcolor\",\n  \"threadpool\",\n  \"wait-timeout\",\n  \"walkdir\",\n ]\n \n-[[package]]\n-name = \"libc\"\n-version = \"0.1.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n-\n [[package]]\n name = \"libc\"\n version = \"0.2.112\"\n@@ -118,7 +112,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n- \"libc 0.2.112\",\n+ \"libc\",\n ]\n \n [[package]]\n@@ -133,7 +127,7 @@ version = \"0.8.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n dependencies = [\n- \"libc 0.2.112\",\n+ \"libc\",\n  \"rand_chacha\",\n  \"rand_core\",\n  \"rand_hc\",\n@@ -234,7 +228,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.112\",\n+ \"libc\",\n  \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n@@ -271,7 +265,7 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n dependencies = [\n- \"libc 0.2.112\",\n+ \"libc\",\n ]\n \n [[package]]"}, {"sha": "ac04b61a30672cf152dfb5736830899b2e5a6c11", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -73,6 +73,11 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         }\n     }\n \n+    fn const_poison(&self, typ: Type<'gcc>) -> RValue<'gcc> {\n+        // No distinction between undef and poison.\n+        self.const_undef(typ)\n+    }\n+\n     fn const_int(&self, typ: Type<'gcc>, int: i64) -> RValue<'gcc> {\n         self.gcc_int(typ, int)\n     }"}, {"sha": "b6d7484bccefd7eb8cc0bb8fe35cdcc646f0d663", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -27,7 +27,8 @@ codegen_llvm_error_calling_dlltool =\n     Error calling dlltool: {$error}\n \n codegen_llvm_dlltool_fail_import_library =\n-    Dlltool could not create import library: {$stdout}\\n{$stderr}\n+    Dlltool could not create import library: {$stdout}\n+    {$stderr}\n \n codegen_llvm_target_feature_disable_or_enable =\n     the target features {$features} must all be either enabled or disabled together"}, {"sha": "12da21dc47772bef572cc1e0f2ff4c60372dc897", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -110,7 +110,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n     fn new_archive_builder<'a>(&self, sess: &'a Session) -> Box<dyn ArchiveBuilder<'a> + 'a> {\n         // FIXME use ArArchiveBuilder on most targets again once reading thin archives is\n         // implemented\n-        if true || sess.target.arch == \"wasm32\" || sess.target.arch == \"wasm64\" {\n+        if true {\n             Box::new(LlvmArchiveBuilder { sess, additions: Vec::new() })\n         } else {\n             Box::new(ArArchiveBuilder::new(sess, get_llvm_object_symbols))"}, {"sha": "fb563f70ed090e2fc546ae09edfbf2353b9a52f6", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -214,6 +214,8 @@ pub fn target_machine_factory(\n \n     let path_mapping = sess.source_map().path_mapping().clone();\n \n+    let force_emulated_tls = sess.target.force_emulated_tls;\n+\n     Arc::new(move |config: TargetMachineFactoryConfig| {\n         let split_dwarf_file =\n             path_mapping.map_prefix(config.split_dwarf_file.unwrap_or_default()).0;\n@@ -239,6 +241,7 @@ pub fn target_machine_factory(\n                 relax_elf_relocations,\n                 use_init_array,\n                 split_dwarf_file.as_ptr(),\n+                force_emulated_tls,\n             )\n         };\n "}, {"sha": "63e8a67db53edc6183615f2243570f3f8c1c2a7f", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -990,7 +990,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn resume(&mut self, exn0: &'ll Value, exn1: &'ll Value) {\n         let ty = self.type_struct(&[self.type_i8p(), self.type_i32()], false);\n-        let mut exn = self.const_undef(ty);\n+        let mut exn = self.const_poison(ty);\n         exn = self.insert_value(exn, exn0, 0);\n         exn = self.insert_value(exn, exn1, 1);\n         unsafe {\n@@ -1190,8 +1190,8 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // Set KCFI operand bundle\n         let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n         let kcfi_bundle =\n-            if self.tcx.sess.is_sanitizer_kcfi_enabled() && fn_abi.is_some() && is_indirect_call {\n-                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap());\n+            if let Some(fn_abi) = fn_abi && self.tcx.sess.is_sanitizer_kcfi_enabled() && is_indirect_call {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n                 Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n             } else {\n                 None"}, {"sha": "4f8b5abd9010c424077d3d73077128afb5a984b3", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -130,6 +130,10 @@ impl<'ll, 'tcx> ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         unsafe { llvm::LLVMGetUndef(t) }\n     }\n \n+    fn const_poison(&self, t: &'ll Type) -> &'ll Value {\n+        unsafe { llvm::LLVMGetPoison(t) }\n+    }\n+\n     fn const_int(&self, t: &'ll Type, i: i64) -> &'ll Value {\n         unsafe { llvm::LLVMConstInt(t, i as u64, True) }\n     }\n@@ -374,8 +378,7 @@ pub(crate) fn get_dllimport<'tcx>(\n     name: &str,\n ) -> Option<&'tcx DllImport> {\n     tcx.native_library(id)\n-        .map(|lib| lib.dll_imports.iter().find(|di| di.name.as_str() == name))\n-        .flatten()\n+        .and_then(|lib| lib.dll_imports.iter().find(|di| di.name.as_str() == name))\n }\n \n pub(crate) fn is_mingw_gnu_toolchain(target: &Target) -> bool {"}, {"sha": "55a217f59f91e0267814797b4bea3479118cc0dd", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,18 +3,20 @@ use rustc_codegen_ssa::debuginfo::{\n     wants_c_like_enum_debuginfo,\n };\n use rustc_hir::def::CtorKind;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::{\n     bug,\n-    mir::{Field, GeneratorLayout, GeneratorSavedLocal},\n+    mir::{GeneratorLayout, GeneratorSavedLocal},\n     ty::{\n         self,\n         layout::{IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout},\n         AdtDef, GeneratorSubsts, Ty, VariantDef,\n     },\n };\n use rustc_span::Symbol;\n-use rustc_target::abi::{HasDataLayout, Integer, Primitive, TagEncoding, VariantIdx, Variants};\n+use rustc_target::abi::{\n+    FieldIdx, HasDataLayout, Integer, Primitive, TagEncoding, VariantIdx, Variants,\n+};\n use std::borrow::Cow;\n \n use crate::{\n@@ -272,7 +274,8 @@ fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n                 .map(|field_index| {\n                     let field_name = if variant_def.ctor_kind() != Some(CtorKind::Fn) {\n                         // Fields have names\n-                        Cow::from(variant_def.fields[field_index].name.as_str())\n+                        let field = &variant_def.fields[FieldIdx::from_usize(field_index)];\n+                        Cow::from(field.name.as_str())\n                     } else {\n                         // Tuple-like\n                         super::tuple_field_name(field_index)\n@@ -320,7 +323,7 @@ pub fn build_generator_variant_struct_type_di_node<'ll, 'tcx>(\n     generator_type_and_layout: TyAndLayout<'tcx>,\n     generator_type_di_node: &'ll DIType,\n     generator_layout: &GeneratorLayout<'tcx>,\n-    state_specific_upvar_names: &IndexVec<GeneratorSavedLocal, Option<Symbol>>,\n+    state_specific_upvar_names: &IndexSlice<GeneratorSavedLocal, Option<Symbol>>,\n     common_upvar_names: &[String],\n ) -> &'ll DIType {\n     let variant_name = GeneratorSubsts::variant_name(variant_index);\n@@ -353,7 +356,7 @@ pub fn build_generator_variant_struct_type_di_node<'ll, 'tcx>(\n             let state_specific_fields: SmallVec<_> = (0..variant_layout.fields.count())\n                 .map(|field_index| {\n                     let generator_saved_local = generator_layout.variant_fields[variant_index]\n-                        [Field::from_usize(field_index)];\n+                        [FieldIdx::from_usize(field_index)];\n                     let field_name_maybe = state_specific_upvar_names[generator_saved_local];\n                     let field_name = field_name_maybe\n                         .as_ref()"}, {"sha": "3f77ea77effe31a35e283ca90350bc7361a68f2b", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,7 +10,6 @@\n #![feature(iter_intersperse)]\n #![feature(let_chains)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "0d63e634ad888bafdd0dd95dec36b9a32683e792", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1069,6 +1069,7 @@ extern \"C\" {\n     // Operations on constants of any type\n     pub fn LLVMConstNull(Ty: &Type) -> &Value;\n     pub fn LLVMGetUndef(Ty: &Type) -> &Value;\n+    pub fn LLVMGetPoison(Ty: &Type) -> &Value;\n \n     // Operations on metadata\n     pub fn LLVMMDStringInContext(C: &Context, Str: *const c_char, SLen: c_uint) -> &Value;\n@@ -2256,6 +2257,7 @@ extern \"C\" {\n         RelaxELFRelocations: bool,\n         UseInitArray: bool,\n         SplitDwarfFile: *const c_char,\n+        ForceEmulatedTls: bool,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n     pub fn LLVMRustAddLibraryInfo<'a>("}, {"sha": "69bb00f804d3cda155b50ba84fa908a47a86d604", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1621,7 +1621,7 @@ impl<'a> Linker for AixLinker<'a> {\n         let path = tmpdir.join(\"list.exp\");\n         let res: io::Result<()> = try {\n             let mut f = BufWriter::new(File::create(&path)?);\n-            // TODO: use llvm-nm to generate export list.\n+            // FIXME: use llvm-nm to generate export list.\n             for symbol in symbols {\n                 debug!(\"  _{}\", symbol);\n                 writeln!(f, \"  {}\", symbol)?;"}, {"sha": "d0fd3cd7666744a3eb9f9a679ad25a34820758da", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -177,14 +177,29 @@ fn exported_symbols_provider_local(\n \n     // FIXME: Sorting this is unnecessary since we are sorting later anyway.\n     //        Can we skip the later sorting?\n-    let mut symbols: Vec<_> = tcx.with_stable_hashing_context(|hcx| {\n-        tcx.reachable_non_generics(LOCAL_CRATE)\n-            .to_sorted(&hcx, true)\n-            .into_iter()\n-            .map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info))\n-            .collect()\n+    let sorted = tcx.with_stable_hashing_context(|hcx| {\n+        tcx.reachable_non_generics(LOCAL_CRATE).to_sorted(&hcx, true)\n     });\n \n+    let mut symbols: Vec<_> =\n+        sorted.iter().map(|(&def_id, &info)| (ExportedSymbol::NonGeneric(def_id), info)).collect();\n+\n+    // Export TLS shims\n+    if !tcx.sess.target.dll_tls_export {\n+        symbols.extend(sorted.iter().filter_map(|(&def_id, &info)| {\n+            tcx.needs_thread_local_shim(def_id).then(|| {\n+                (\n+                    ExportedSymbol::ThreadLocalShim(def_id),\n+                    SymbolExportInfo {\n+                        level: info.level,\n+                        kind: SymbolExportKind::Text,\n+                        used: info.used,\n+                    },\n+                )\n+            })\n+        }))\n+    }\n+\n     if tcx.entry_fn(()).is_some() {\n         let exported_symbol =\n             ExportedSymbol::NoDefId(SymbolName::new(tcx, tcx.sess.target.entry_name.as_ref()));\n@@ -380,7 +395,9 @@ fn upstream_monomorphizations_provider(\n                         continue;\n                     }\n                 }\n-                ExportedSymbol::NonGeneric(..) | ExportedSymbol::NoDefId(..) => {\n+                ExportedSymbol::NonGeneric(..)\n+                | ExportedSymbol::ThreadLocalShim(..)\n+                | ExportedSymbol::NoDefId(..) => {\n                     // These are no monomorphizations\n                     continue;\n                 }\n@@ -500,6 +517,16 @@ pub fn symbol_name_for_instance_in_crate<'tcx>(\n                 instantiating_crate,\n             )\n         }\n+        ExportedSymbol::ThreadLocalShim(def_id) => {\n+            rustc_symbol_mangling::symbol_name_for_instance_in_crate(\n+                tcx,\n+                ty::Instance {\n+                    def: ty::InstanceDef::ThreadLocalShim(def_id),\n+                    substs: ty::InternalSubsts::empty(),\n+                },\n+                instantiating_crate,\n+            )\n+        }\n         ExportedSymbol::DropGlue(ty) => rustc_symbol_mangling::symbol_name_for_instance_in_crate(\n             tcx,\n             Instance::resolve_drop_in_place(tcx, ty),\n@@ -548,6 +575,8 @@ pub fn linking_symbol_name_for_instance_in_crate<'tcx>(\n         ExportedSymbol::DropGlue(..) => None,\n         // NoDefId always follow the target's default symbol decoration scheme.\n         ExportedSymbol::NoDefId(..) => None,\n+        // ThreadLocalShim always follow the target's default symbol decoration scheme.\n+        ExportedSymbol::ThreadLocalShim(..) => None,\n     };\n \n     let (conv, args) = instance"}, {"sha": "2dda4cd169410e878690c3d94c3ced52599f66d3", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1452,8 +1452,8 @@ fn start_executing_work<B: ExtraBackendMethods>(\n                         Err(e) => {\n                             let msg = &format!(\"failed to acquire jobserver token: {}\", e);\n                             shared_emitter.fatal(msg);\n-                            // Exit the coordinator thread\n-                            panic!(\"{}\", msg)\n+                            codegen_done = true;\n+                            codegen_aborted = true;\n                         }\n                     }\n                 }"}, {"sha": "c5ca7936a2b458cbb9aa5af2d5f71c94c7d7c934", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -24,7 +24,6 @@ use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n-use rustc_index::vec::Idx;\n use rustc_metadata::EncodedMetadata;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols;\n@@ -40,7 +39,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::{Align, FIRST_VARIANT};\n \n use std::collections::BTreeSet;\n use std::time::{Duration, Instant};\n@@ -307,9 +306,9 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n             assert_eq!(def_a, def_b);\n \n-            for i in 0..def_a.variant(VariantIdx::new(0)).fields.len() {\n-                let src_f = src.project_field(bx, i);\n-                let dst_f = dst.project_field(bx, i);\n+            for i in def_a.variant(FIRST_VARIANT).fields.indices() {\n+                let src_f = src.project_field(bx, i.as_usize());\n+                let dst_f = dst.project_field(bx, i.as_usize());\n \n                 if dst_f.layout.is_zst() {\n                     continue;"}, {"sha": "8542bab689d6d04a7286384b75dfd00c4dbf1a60", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 300, "deletions": 290, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,6 +10,7 @@ use rustc_middle::mir::mono::Linkage;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self as ty, TyCtxt};\n use rustc_session::{lint, parse::feature_err};\n+use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};\n \n@@ -83,336 +84,345 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n             }\n         };\n \n-        if attr.has_name(sym::cold) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD;\n-        } else if attr.has_name(sym::rustc_allocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR;\n-        } else if attr.has_name(sym::ffi_returns_twice) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE;\n-        } else if attr.has_name(sym::ffi_pure) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE;\n-        } else if attr.has_name(sym::ffi_const) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST;\n-        } else if attr.has_name(sym::rustc_nounwind) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND;\n-        } else if attr.has_name(sym::rustc_reallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR;\n-        } else if attr.has_name(sym::rustc_deallocator) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR;\n-        } else if attr.has_name(sym::rustc_allocator_zeroed) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED;\n-        } else if attr.has_name(sym::naked) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED;\n-        } else if attr.has_name(sym::no_mangle) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE;\n-        } else if attr.has_name(sym::no_coverage) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE;\n-        } else if attr.has_name(sym::rustc_std_internal_symbol) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n-        } else if attr.has_name(sym::used) {\n-            let inner = attr.meta_item_list();\n-            match inner.as_deref() {\n-                Some([item]) if item.has_name(sym::linker) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n-                            attr.span,\n-                            \"`#[used(linker)]` is currently unstable\",\n-                        )\n-                        .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n-                }\n-                Some([item]) if item.has_name(sym::compiler) => {\n-                    if !tcx.features().used_with_arg {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::used_with_arg,\n+        let Some(Ident { name, .. }) = attr.ident() else {\n+            continue;\n+        };\n+\n+        match name {\n+            sym::cold => codegen_fn_attrs.flags |= CodegenFnAttrFlags::COLD,\n+            sym::rustc_allocator => codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR,\n+            sym::ffi_returns_twice => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_RETURNS_TWICE\n+            }\n+            sym::ffi_pure => codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_PURE,\n+            sym::ffi_const => codegen_fn_attrs.flags |= CodegenFnAttrFlags::FFI_CONST,\n+            sym::rustc_nounwind => codegen_fn_attrs.flags |= CodegenFnAttrFlags::NEVER_UNWIND,\n+            sym::rustc_reallocator => codegen_fn_attrs.flags |= CodegenFnAttrFlags::REALLOCATOR,\n+            sym::rustc_deallocator => codegen_fn_attrs.flags |= CodegenFnAttrFlags::DEALLOCATOR,\n+            sym::rustc_allocator_zeroed => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::ALLOCATOR_ZEROED\n+            }\n+            sym::naked => codegen_fn_attrs.flags |= CodegenFnAttrFlags::NAKED,\n+            sym::no_mangle => {\n+                if tcx.opt_item_name(did.to_def_id()).is_some() {\n+                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_MANGLE\n+                } else {\n+                    tcx.sess\n+                        .struct_span_err(\n                             attr.span,\n-                            \"`#[used(compiler)]` is currently unstable\",\n+                            format!(\n+                                \"`#[no_mangle]` cannot be used on {} {} as it has no name\",\n+                                tcx.def_descr_article(did.to_def_id()),\n+                                tcx.def_descr(did.to_def_id()),\n+                            ),\n                         )\n                         .emit();\n-                    }\n-                    codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n-                }\n-                Some(_) => {\n-                    tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n                 }\n-                None => {\n-                    // Unfortunately, unconditionally using `llvm.used` causes\n-                    // issues in handling `.init_array` with the gold linker,\n-                    // but using `llvm.compiler.used` caused a nontrival amount\n-                    // of unintentional ecosystem breakage -- particularly on\n-                    // Mach-O targets.\n-                    //\n-                    // As a result, we emit `llvm.compiler.used` only on ELF\n-                    // targets. This is somewhat ad-hoc, but actually follows\n-                    // our pre-LLVM 13 behavior (prior to the ecosystem\n-                    // breakage), and seems to match `clang`'s behavior as well\n-                    // (both before and after LLVM 13), possibly because they\n-                    // have similar compatibility concerns to us. See\n-                    // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n-                    // and following comments for some discussion of this, as\n-                    // well as the comments in `rustc_codegen_llvm` where these\n-                    // flags are handled.\n-                    //\n-                    // Anyway, to be clear: this is still up in the air\n-                    // somewhat, and is subject to change in the future (which\n-                    // is a good thing, because this would ideally be a bit\n-                    // more firmed up).\n-                    let is_like_elf = !(tcx.sess.target.is_like_osx\n-                        || tcx.sess.target.is_like_windows\n-                        || tcx.sess.target.is_like_wasm);\n-                    codegen_fn_attrs.flags |= if is_like_elf {\n-                        CodegenFnAttrFlags::USED\n-                    } else {\n-                        CodegenFnAttrFlags::USED_LINKER\n-                    };\n-                }\n-            }\n-        } else if attr.has_name(sym::cmse_nonsecure_entry) {\n-            if let Some(fn_sig) = fn_sig()\n-                && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n-            {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    attr.span,\n-                    E0776,\n-                    \"`#[cmse_nonsecure_entry]` requires C ABI\"\n-                )\n-                .emit();\n-            }\n-            if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n-                struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n-                    .emit();\n             }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY;\n-        } else if attr.has_name(sym::thread_local) {\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL;\n-        } else if attr.has_name(sym::track_caller) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && let Some(fn_sig) = fn_sig()\n-                && fn_sig.skip_binder().abi() != abi::Abi::Rust\n-            {\n-                struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n-                    .emit();\n+            sym::no_coverage => codegen_fn_attrs.flags |= CodegenFnAttrFlags::NO_COVERAGE,\n+            sym::rustc_std_internal_symbol => {\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL\n             }\n-            if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n-                feature_err(\n-                    &tcx.sess.parse_sess,\n-                    sym::closure_track_caller,\n-                    attr.span,\n-                    \"`#[track_caller]` on closures is currently unstable\",\n-                )\n-                .emit();\n+            sym::used => {\n+                let inner = attr.meta_item_list();\n+                match inner.as_deref() {\n+                    Some([item]) if item.has_name(sym::linker) => {\n+                        if !tcx.features().used_with_arg {\n+                            feature_err(\n+                                &tcx.sess.parse_sess,\n+                                sym::used_with_arg,\n+                                attr.span,\n+                                \"`#[used(linker)]` is currently unstable\",\n+                            )\n+                            .emit();\n+                        }\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED_LINKER;\n+                    }\n+                    Some([item]) if item.has_name(sym::compiler) => {\n+                        if !tcx.features().used_with_arg {\n+                            feature_err(\n+                                &tcx.sess.parse_sess,\n+                                sym::used_with_arg,\n+                                attr.span,\n+                                \"`#[used(compiler)]` is currently unstable\",\n+                            )\n+                            .emit();\n+                        }\n+                        codegen_fn_attrs.flags |= CodegenFnAttrFlags::USED;\n+                    }\n+                    Some(_) => {\n+                        tcx.sess.emit_err(ExpectedUsedSymbol { span: attr.span });\n+                    }\n+                    None => {\n+                        // Unfortunately, unconditionally using `llvm.used` causes\n+                        // issues in handling `.init_array` with the gold linker,\n+                        // but using `llvm.compiler.used` caused a nontrival amount\n+                        // of unintentional ecosystem breakage -- particularly on\n+                        // Mach-O targets.\n+                        //\n+                        // As a result, we emit `llvm.compiler.used` only on ELF\n+                        // targets. This is somewhat ad-hoc, but actually follows\n+                        // our pre-LLVM 13 behavior (prior to the ecosystem\n+                        // breakage), and seems to match `clang`'s behavior as well\n+                        // (both before and after LLVM 13), possibly because they\n+                        // have similar compatibility concerns to us. See\n+                        // https://github.com/rust-lang/rust/issues/47384#issuecomment-1019080146\n+                        // and following comments for some discussion of this, as\n+                        // well as the comments in `rustc_codegen_llvm` where these\n+                        // flags are handled.\n+                        //\n+                        // Anyway, to be clear: this is still up in the air\n+                        // somewhat, and is subject to change in the future (which\n+                        // is a good thing, because this would ideally be a bit\n+                        // more firmed up).\n+                        let is_like_elf = !(tcx.sess.target.is_like_osx\n+                            || tcx.sess.target.is_like_windows\n+                            || tcx.sess.target.is_like_wasm);\n+                        codegen_fn_attrs.flags |= if is_like_elf {\n+                            CodegenFnAttrFlags::USED\n+                        } else {\n+                            CodegenFnAttrFlags::USED_LINKER\n+                        };\n+                    }\n+                }\n             }\n-            codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER;\n-        } else if attr.has_name(sym::export_name) {\n-            if let Some(s) = attr.value_str() {\n-                if s.as_str().contains('\\0') {\n-                    // `#[export_name = ...]` will be converted to a null-terminated string,\n-                    // so it may not contain any null characters.\n+            sym::cmse_nonsecure_entry => {\n+                if let Some(fn_sig) = fn_sig()\n+                    && !matches!(fn_sig.skip_binder().abi(), abi::Abi::C { .. })\n+                {\n                     struct_span_err!(\n                         tcx.sess,\n                         attr.span,\n-                        E0648,\n-                        \"`export_name` may not contain null characters\"\n+                        E0776,\n+                        \"`#[cmse_nonsecure_entry]` requires C ABI\"\n                     )\n                     .emit();\n                 }\n-                codegen_fn_attrs.export_name = Some(s);\n+                if !tcx.sess.target.llvm_target.contains(\"thumbv8m\") {\n+                    struct_span_err!(tcx.sess, attr.span, E0775, \"`#[cmse_nonsecure_entry]` is only valid for targets with the TrustZone-M extension\")\n+                    .emit();\n+                }\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::CMSE_NONSECURE_ENTRY\n             }\n-        } else if attr.has_name(sym::target_feature) {\n-            if !tcx.is_closure(did.to_def_id())\n-                && let Some(fn_sig) = fn_sig()\n-                && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n-            {\n-                if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n-                    // The `#[target_feature]` attribute is allowed on\n-                    // WebAssembly targets on all functions, including safe\n-                    // ones. Other targets require that `#[target_feature]` is\n-                    // only applied to unsafe functions (pending the\n-                    // `target_feature_11` feature) because on most targets\n-                    // execution of instructions that are not supported is\n-                    // considered undefined behavior. For WebAssembly which is a\n-                    // 100% safe target at execution time it's not possible to\n-                    // execute undefined instructions, and even if a future\n-                    // feature was added in some form for this it would be a\n-                    // deterministic trap. There is no undefined behavior when\n-                    // executing WebAssembly so `#[target_feature]` is allowed\n-                    // on safe functions (but again, only for WebAssembly)\n-                    //\n-                    // Note that this is also allowed if `actually_rustdoc` so\n-                    // if a target is documenting some wasm-specific code then\n-                    // it's not spuriously denied.\n-                    //\n-                    // This exception needs to be kept in sync with allowing\n-                    // `#[target_feature]` on `main` and `start`.\n-                } else if !tcx.features().target_feature_11 {\n-                    let mut err = feature_err(\n+            sym::thread_local => codegen_fn_attrs.flags |= CodegenFnAttrFlags::THREAD_LOCAL,\n+            sym::track_caller => {\n+                if !tcx.is_closure(did.to_def_id())\n+                    && let Some(fn_sig) = fn_sig()\n+                    && fn_sig.skip_binder().abi() != abi::Abi::Rust\n+                {\n+                    struct_span_err!(tcx.sess, attr.span, E0737, \"`#[track_caller]` requires Rust ABI\")\n+                        .emit();\n+                }\n+                if tcx.is_closure(did.to_def_id()) && !tcx.features().closure_track_caller {\n+                    feature_err(\n                         &tcx.sess.parse_sess,\n-                        sym::target_feature_11,\n+                        sym::closure_track_caller,\n                         attr.span,\n-                        \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n-                    );\n-                    err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n-                    err.emit();\n-                } else {\n-                    check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                        \"`#[track_caller]` on closures is currently unstable\",\n+                    )\n+                    .emit();\n                 }\n+                codegen_fn_attrs.flags |= CodegenFnAttrFlags::TRACK_CALLER\n             }\n-            from_target_feature(\n-                tcx,\n-                attr,\n-                supported_target_features,\n-                &mut codegen_fn_attrs.target_features,\n-            );\n-        } else if attr.has_name(sym::linkage) {\n-            if let Some(val) = attr.value_str() {\n-                let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n-                if tcx.is_foreign_item(did) {\n-                    codegen_fn_attrs.import_linkage = linkage;\n-                } else {\n-                    codegen_fn_attrs.linkage = linkage;\n+            sym::export_name => {\n+                if let Some(s) = attr.value_str() {\n+                    if s.as_str().contains('\\0') {\n+                        // `#[export_name = ...]` will be converted to a null-terminated string,\n+                        // so it may not contain any null characters.\n+                        struct_span_err!(\n+                            tcx.sess,\n+                            attr.span,\n+                            E0648,\n+                            \"`export_name` may not contain null characters\"\n+                        )\n+                        .emit();\n+                    }\n+                    codegen_fn_attrs.export_name = Some(s);\n                 }\n             }\n-        } else if attr.has_name(sym::link_section) {\n-            if let Some(val) = attr.value_str() {\n-                if val.as_str().bytes().any(|b| b == 0) {\n-                    let msg = format!(\n-                        \"illegal null byte in link_section \\\n-                         value: `{}`\",\n-                        &val\n-                    );\n-                    tcx.sess.span_err(attr.span, &msg);\n-                } else {\n-                    codegen_fn_attrs.link_section = Some(val);\n+            sym::target_feature => {\n+                if !tcx.is_closure(did.to_def_id())\n+                    && let Some(fn_sig) = fn_sig()\n+                    && fn_sig.skip_binder().unsafety() == hir::Unsafety::Normal\n+                {\n+                    if tcx.sess.target.is_like_wasm || tcx.sess.opts.actually_rustdoc {\n+                        // The `#[target_feature]` attribute is allowed on\n+                        // WebAssembly targets on all functions, including safe\n+                        // ones. Other targets require that `#[target_feature]` is\n+                        // only applied to unsafe functions (pending the\n+                        // `target_feature_11` feature) because on most targets\n+                        // execution of instructions that are not supported is\n+                        // considered undefined behavior. For WebAssembly which is a\n+                        // 100% safe target at execution time it's not possible to\n+                        // execute undefined instructions, and even if a future\n+                        // feature was added in some form for this it would be a\n+                        // deterministic trap. There is no undefined behavior when\n+                        // executing WebAssembly so `#[target_feature]` is allowed\n+                        // on safe functions (but again, only for WebAssembly)\n+                        //\n+                        // Note that this is also allowed if `actually_rustdoc` so\n+                        // if a target is documenting some wasm-specific code then\n+                        // it's not spuriously denied.\n+                        //\n+                        // This exception needs to be kept in sync with allowing\n+                        // `#[target_feature]` on `main` and `start`.\n+                    } else if !tcx.features().target_feature_11 {\n+                        let mut err = feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::target_feature_11,\n+                            attr.span,\n+                            \"`#[target_feature(..)]` can only be applied to `unsafe` functions\",\n+                        );\n+                        err.span_label(tcx.def_span(did), \"not an `unsafe` function\");\n+                        err.emit();\n+                    } else {\n+                        check_target_feature_trait_unsafe(tcx, did, attr.span);\n+                    }\n                 }\n+                from_target_feature(\n+                    tcx,\n+                    attr,\n+                    supported_target_features,\n+                    &mut codegen_fn_attrs.target_features,\n+                );\n             }\n-        } else if attr.has_name(sym::link_name) {\n-            codegen_fn_attrs.link_name = attr.value_str();\n-        } else if attr.has_name(sym::link_ordinal) {\n-            link_ordinal_span = Some(attr.span);\n-            if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n-                codegen_fn_attrs.link_ordinal = ordinal;\n+            sym::linkage => {\n+                if let Some(val) = attr.value_str() {\n+                    let linkage = Some(linkage_by_name(tcx, did, val.as_str()));\n+                    if tcx.is_foreign_item(did) {\n+                        codegen_fn_attrs.import_linkage = linkage;\n+                    } else {\n+                        codegen_fn_attrs.linkage = linkage;\n+                    }\n+                }\n             }\n-        } else if attr.has_name(sym::no_sanitize) {\n-            no_sanitize_span = Some(attr.span);\n-            if let Some(list) = attr.meta_item_list() {\n-                for item in list.iter() {\n-                    if item.has_name(sym::address) {\n-                        codegen_fn_attrs.no_sanitize |=\n-                            SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS;\n-                    } else if item.has_name(sym::cfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI;\n-                    } else if item.has_name(sym::kcfi) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI;\n-                    } else if item.has_name(sym::memory) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY;\n-                    } else if item.has_name(sym::memtag) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG;\n-                    } else if item.has_name(sym::shadow_call_stack) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK;\n-                    } else if item.has_name(sym::thread) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD;\n-                    } else if item.has_name(sym::hwaddress) {\n-                        codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS;\n+            sym::link_section => {\n+                if let Some(val) = attr.value_str() {\n+                    if val.as_str().bytes().any(|b| b == 0) {\n+                        let msg = format!(\"illegal null byte in link_section value: `{}`\", &val);\n+                        tcx.sess.span_err(attr.span, &msg);\n                     } else {\n-                        tcx.sess\n-                            .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                            .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                            .emit();\n+                        codegen_fn_attrs.link_section = Some(val);\n                     }\n                 }\n             }\n-        } else if attr.has_name(sym::instruction_set) {\n-            codegen_fn_attrs.instruction_set = attr.meta_item_list().and_then(|l| match &l[..] {\n-                [NestedMetaItem::MetaItem(set)] => {\n-                    let segments =\n-                        set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n-                    match segments.as_slice() {\n-                        [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n-                            if !tcx.sess.target.has_thumb_interworking {\n-                                struct_span_err!(\n-                                    tcx.sess.diagnostic(),\n-                                    attr.span,\n-                                    E0779,\n-                                    \"target does not support `#[instruction_set]`\"\n-                                )\n-                                .emit();\n-                                None\n-                            } else if segments[1] == sym::a32 {\n-                                Some(InstructionSetAttr::ArmA32)\n-                            } else if segments[1] == sym::t32 {\n-                                Some(InstructionSetAttr::ArmT32)\n-                            } else {\n-                                unreachable!()\n+            sym::link_name => codegen_fn_attrs.link_name = attr.value_str(),\n+            sym::link_ordinal => {\n+                link_ordinal_span = Some(attr.span);\n+                if let ordinal @ Some(_) = check_link_ordinal(tcx, attr) {\n+                    codegen_fn_attrs.link_ordinal = ordinal;\n+                }\n+            }\n+            sym::no_sanitize => {\n+                no_sanitize_span = Some(attr.span);\n+                if let Some(list) = attr.meta_item_list() {\n+                    for item in list.iter() {\n+                        match item.name_or_empty() {\n+                            sym::address => {\n+                                codegen_fn_attrs.no_sanitize |=\n+                                    SanitizerSet::ADDRESS | SanitizerSet::KERNELADDRESS\n+                            }\n+                            sym::cfi => codegen_fn_attrs.no_sanitize |= SanitizerSet::CFI,\n+                            sym::kcfi => codegen_fn_attrs.no_sanitize |= SanitizerSet::KCFI,\n+                            sym::memory => codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMORY,\n+                            sym::memtag => codegen_fn_attrs.no_sanitize |= SanitizerSet::MEMTAG,\n+                            sym::shadow_call_stack => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::SHADOWCALLSTACK\n+                            }\n+                            sym::thread => codegen_fn_attrs.no_sanitize |= SanitizerSet::THREAD,\n+                            sym::hwaddress => {\n+                                codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS\n+                            }\n+                            _ => {\n+                                tcx.sess\n+                                    .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n+                                    .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n+                                    .emit();\n                             }\n-                        }\n-                        _ => {\n-                            struct_span_err!(\n-                                tcx.sess.diagnostic(),\n-                                attr.span,\n-                                E0779,\n-                                \"invalid instruction set specified\",\n-                            )\n-                            .emit();\n-                            None\n                         }\n                     }\n                 }\n-                [] => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0778,\n-                        \"`#[instruction_set]` requires an argument\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-                _ => {\n-                    struct_span_err!(\n-                        tcx.sess.diagnostic(),\n-                        attr.span,\n-                        E0779,\n-                        \"cannot specify more than one instruction set\"\n-                    )\n-                    .emit();\n-                    None\n-                }\n-            })\n-        } else if attr.has_name(sym::repr) {\n-            codegen_fn_attrs.alignment = match attr.meta_item_list() {\n-                Some(items) => match items.as_slice() {\n-                    [item] => match item.name_value_literal() {\n-                        Some((sym::align, literal)) => {\n-                            let alignment = rustc_attr::parse_alignment(&literal.kind);\n-\n-                            match alignment {\n-                                Ok(align) => Some(align),\n-                                Err(msg) => {\n+            }\n+            sym::instruction_set => {\n+                codegen_fn_attrs.instruction_set =\n+                    attr.meta_item_list().and_then(|l| match &l[..] {\n+                        [NestedMetaItem::MetaItem(set)] => {\n+                            let segments =\n+                                set.path.segments.iter().map(|x| x.ident.name).collect::<Vec<_>>();\n+                            match segments.as_slice() {\n+                                [sym::arm, sym::a32] | [sym::arm, sym::t32] => {\n+                                    if !tcx.sess.target.has_thumb_interworking {\n+                                        struct_span_err!(\n+                                            tcx.sess.diagnostic(),\n+                                            attr.span,\n+                                            E0779,\n+                                            \"target does not support `#[instruction_set]`\"\n+                                        )\n+                                        .emit();\n+                                        None\n+                                    } else if segments[1] == sym::a32 {\n+                                        Some(InstructionSetAttr::ArmA32)\n+                                    } else if segments[1] == sym::t32 {\n+                                        Some(InstructionSetAttr::ArmT32)\n+                                    } else {\n+                                        unreachable!()\n+                                    }\n+                                }\n+                                _ => {\n                                     struct_span_err!(\n                                         tcx.sess.diagnostic(),\n                                         attr.span,\n-                                        E0589,\n-                                        \"invalid `repr(align)` attribute: {}\",\n-                                        msg\n+                                        E0779,\n+                                        \"invalid instruction set specified\",\n                                     )\n                                     .emit();\n-\n                                     None\n                                 }\n                             }\n                         }\n-                        _ => None,\n-                    },\n-                    [] => None,\n-                    _ => None,\n-                },\n-                None => None,\n-            };\n+                        [] => {\n+                            struct_span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0778,\n+                                \"`#[instruction_set]` requires an argument\"\n+                            )\n+                            .emit();\n+                            None\n+                        }\n+                        _ => {\n+                            struct_span_err!(\n+                                tcx.sess.diagnostic(),\n+                                attr.span,\n+                                E0779,\n+                                \"cannot specify more than one instruction set\"\n+                            )\n+                            .emit();\n+                            None\n+                        }\n+                    })\n+            }\n+            sym::repr => {\n+                codegen_fn_attrs.alignment = if let Some(items) = attr.meta_item_list()\n+                    && let [item] = items.as_slice()\n+                    && let Some((sym::align, literal)) = item.name_value_literal()\n+                {\n+                    rustc_attr::parse_alignment(&literal.kind).map_err(|msg| {\n+                        struct_span_err!(\n+                            tcx.sess.diagnostic(),\n+                            attr.span,\n+                            E0589,\n+                            \"invalid `repr(align)` attribute: {}\",\n+                            msg\n+                        )\n+                        .emit();\n+                    })\n+                    .ok()\n+                } else {\n+                    None\n+                };\n+            }\n+            _ => {}\n         }\n     }\n "}, {"sha": "1ea13040072e7b4a3b62e586e1f0fb107b60e1ab", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fmap.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,6 +1,6 @@\n pub use super::ffi::*;\n \n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::{\n     CodeRegion, CounterValueReference, ExpressionOperandId, InjectedExpressionId,\n     InjectedExpressionIndex, MappedExpressionIndex, Op,\n@@ -205,7 +205,7 @@ impl<'tcx> FunctionCoverage<'tcx> {\n         // `expression_index`s lower than the referencing `Expression`. Therefore, it is\n         // reasonable to look up the new index of an expression operand while the `new_indexes`\n         // vector is only complete up to the current `ExpressionIndex`.\n-        let id_to_counter = |new_indexes: &IndexVec<\n+        let id_to_counter = |new_indexes: &IndexSlice<\n             InjectedExpressionIndex,\n             Option<MappedExpressionIndex>,\n         >,"}, {"sha": "0ab12314b3c88c97526efe3316c77618f3157375", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,6 @@\n #![feature(int_roundings)]\n #![feature(let_chains)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n #![feature(strict_provenance)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]"}, {"sha": "dcf533dc39c3bce23c1749aaf836cb667ed60553", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,7 @@ use super::FunctionCx;\n use crate::traits::*;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::traversal;\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{self, Location, TerminatorKind};\n@@ -277,7 +277,7 @@ impl CleanupKind {\n /// Recover that structure in an analyze pass.\n pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKind> {\n     fn discover_masters<'tcx>(\n-        result: &mut IndexVec<mir::BasicBlock, CleanupKind>,\n+        result: &mut IndexSlice<mir::BasicBlock, CleanupKind>,\n         mir: &mir::Body<'tcx>,\n     ) {\n         for (bb, data) in mir.basic_blocks.iter_enumerated() {\n@@ -308,7 +308,10 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n         }\n     }\n \n-    fn propagate<'tcx>(result: &mut IndexVec<mir::BasicBlock, CleanupKind>, mir: &mir::Body<'tcx>) {\n+    fn propagate<'tcx>(\n+        result: &mut IndexSlice<mir::BasicBlock, CleanupKind>,\n+        mir: &mir::Body<'tcx>,\n+    ) {\n         let mut funclet_succs = IndexVec::from_elem(None, &mir.basic_blocks);\n \n         let mut set_successor = |funclet: mir::BasicBlock, succ| match funclet_succs[funclet] {"}, {"sha": "c086d1b7f5a38d5a3e3363ce77a17c47800dd757", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -397,8 +397,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Cast(cast_ty, _) => {\n                 let op = match self.locals[mir::RETURN_PLACE] {\n-                    LocalRef::Operand(Some(op)) => op,\n-                    LocalRef::Operand(None) => bug!(\"use of return before def\"),\n+                    LocalRef::Operand(op) => op,\n+                    LocalRef::PendingOperand => bug!(\"use of return before def\"),\n                     LocalRef::Place(cg_place) => OperandRef {\n                         val: Ref(cg_place.llval, None, cg_place.align),\n                         layout: cg_place.layout,\n@@ -600,6 +600,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // and `#[track_caller]` adds an implicit third argument.\n                 (LangItem::PanicBoundsCheck, vec![index, len, location])\n             }\n+            AssertKind::MisalignedPointerDereference { ref required, ref found } => {\n+                let required = self.codegen_operand(bx, required).immediate();\n+                let found = self.codegen_operand(bx, found).immediate();\n+                // It's `fn panic_bounds_check(index: usize, len: usize)`,\n+                // and `#[track_caller]` adds an implicit third argument.\n+                (LangItem::PanicMisalignedPointerDereference, vec![required, found, location])\n+            }\n             _ => {\n                 let msg = bx.const_str(msg.description());\n                 // It's `pub fn panic(expr: &str)`, with the wide reference being passed\n@@ -1673,7 +1680,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n-                LocalRef::Operand(None) => {\n+                LocalRef::PendingOperand => {\n                     // Handle temporary places, specifically `Operand` ones, as\n                     // they don't have `alloca`s.\n                     return if fn_ret.is_indirect() {\n@@ -1694,7 +1701,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         ReturnDest::DirectOperand(index)\n                     };\n                 }\n-                LocalRef::Operand(Some(_)) => {\n+                LocalRef::Operand(_) => {\n                     bug!(\"place local already assigned to\");\n                 }\n             }\n@@ -1737,7 +1744,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             IndirectOperand(tmp, index) => {\n                 let op = bx.load_operand(tmp);\n                 tmp.storage_dead(bx);\n-                self.locals[index] = LocalRef::Operand(Some(op));\n+                self.locals[index] = LocalRef::Operand(op);\n                 self.debug_introduce_local(bx, index);\n             }\n             DirectOperand(index) => {\n@@ -1752,7 +1759,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 } else {\n                     OperandRef::from_immediate_or_packed_pair(bx, llval, ret_abi.layout)\n                 };\n-                self.locals[index] = LocalRef::Operand(Some(op));\n+                self.locals[index] = LocalRef::Operand(op);\n                 self.debug_introduce_local(bx, index);\n             }\n         }"}, {"sha": "ff25d1e38236d11f93c09fbce832f524d3555dfa", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_session::config::DebugInfo;\n use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::{Abi, Size, VariantIdx};\n+use rustc_target::abi::{Abi, FieldIdx, Size, VariantIdx};\n \n use super::operand::{OperandRef, OperandValue};\n use super::place::PlaceRef;\n@@ -79,7 +79,7 @@ impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n trait DebugInfoOffsetLocation<'tcx, Bx> {\n     fn deref(&self, bx: &mut Bx) -> Self;\n     fn layout(&self) -> TyAndLayout<'tcx>;\n-    fn project_field(&self, bx: &mut Bx, field: mir::Field) -> Self;\n+    fn project_field(&self, bx: &mut Bx, field: FieldIdx) -> Self;\n     fn downcast(&self, bx: &mut Bx, variant: VariantIdx) -> Self;\n }\n \n@@ -94,7 +94,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> DebugInfoOffsetLocation<'tcx, Bx>\n         self.layout\n     }\n \n-    fn project_field(&self, bx: &mut Bx, field: mir::Field) -> Self {\n+    fn project_field(&self, bx: &mut Bx, field: FieldIdx) -> Self {\n         PlaceRef::project_field(*self, bx, field.index())\n     }\n \n@@ -116,7 +116,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> DebugInfoOffsetLocation<'tcx, Bx>\n         *self\n     }\n \n-    fn project_field(&self, bx: &mut Bx, field: mir::Field) -> Self {\n+    fn project_field(&self, bx: &mut Bx, field: FieldIdx) -> Self {\n         self.field(bx.cx(), field.index())\n     }\n \n@@ -312,7 +312,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::Place(place) | LocalRef::UnsizedPlace(place) => {\n                     bx.set_var_name(place.llval, name);\n                 }\n-                LocalRef::Operand(Some(operand)) => match operand.val {\n+                LocalRef::Operand(operand) => match operand.val {\n                     OperandValue::Ref(x, ..) | OperandValue::Immediate(x) => {\n                         bx.set_var_name(x, name);\n                     }\n@@ -323,7 +323,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         bx.set_var_name(b, &(name.clone() + \".1\"));\n                     }\n                 },\n-                LocalRef::Operand(None) => {}\n+                LocalRef::PendingOperand => {}\n             }\n         }\n \n@@ -332,9 +332,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         let base = match local_ref {\n-            LocalRef::Operand(None) => return,\n+            LocalRef::PendingOperand => return,\n \n-            LocalRef::Operand(Some(operand)) => {\n+            LocalRef::Operand(operand) => {\n                 // Don't spill operands onto the stack in naked functions.\n                 // See: https://github.com/rust-lang/rust/issues/42779\n                 let attrs = bx.tcx().codegen_fn_attrs(self.instance.def_id());"}, {"sha": "189549953d946a85a67b2cd65c8fe5e635dc7224", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -123,7 +123,10 @@ enum LocalRef<'tcx, V> {\n     /// Every time it is initialized, we have to reallocate the place\n     /// and update the fat pointer. That's the reason why it is indirect.\n     UnsizedPlace(PlaceRef<'tcx, V>),\n-    Operand(Option<OperandRef<'tcx, V>>),\n+    /// The backend [`OperandValue`] has already been generated.\n+    Operand(OperandRef<'tcx, V>),\n+    /// Will be a `Self::Operand` once we get to its definition.\n+    PendingOperand,\n }\n \n impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n@@ -135,9 +138,9 @@ impl<'a, 'tcx, V: CodegenObject> LocalRef<'tcx, V> {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            LocalRef::Operand(Some(OperandRef::new_zst(bx, layout)))\n+            LocalRef::Operand(OperandRef::new_zst(bx, layout))\n         } else {\n-            LocalRef::Operand(None)\n+            LocalRef::PendingOperand\n         }\n     }\n }\n@@ -337,7 +340,7 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 // We don't have to cast or keep the argument in the alloca.\n                 // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n                 // of putting everything in allocas just so we can use llvm.dbg.declare.\n-                let local = |op| LocalRef::Operand(Some(op));\n+                let local = |op| LocalRef::Operand(op);\n                 match arg.mode {\n                     PassMode::Ignore => {\n                         return local(OperandRef::new_zst(bx, arg.layout));"}, {"sha": "b45e7c834e7212070cb7dc0732fe3c011e614df9", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n     ) -> OperandRef<'tcx, V> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(bx.const_undef(bx.immediate_backend_type(layout))),\n+            val: OperandValue::Immediate(bx.const_poison(bx.immediate_backend_type(layout))),\n             layout,\n         }\n     }\n@@ -145,7 +145,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n             let llty = bx.cx().backend_type(self.layout);\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\", self, llty);\n             // Reconstruct the immediate aggregate.\n-            let mut llpair = bx.cx().const_undef(llty);\n+            let mut llpair = bx.cx().const_poison(llty);\n             let imm_a = bx.from_immediate(a);\n             let imm_b = bx.from_immediate(b);\n             llpair = bx.insert_value(llpair, imm_a, 0);\n@@ -370,7 +370,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n         match self.locals[place_ref.local] {\n-            LocalRef::Operand(Some(mut o)) => {\n+            LocalRef::Operand(mut o) => {\n                 // Moves out of scalar and scalar pair fields are trivial.\n                 for elem in place_ref.projection.iter() {\n                     match elem {\n@@ -395,7 +395,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n                 Some(o)\n             }\n-            LocalRef::Operand(None) => {\n+            LocalRef::PendingOperand => {\n                 bug!(\"use of {:?} before def\", place_ref);\n             }\n             LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {"}, {"sha": "1633cfef19d2bab2c4b94a4ea53cbda95fe7f644", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         let cast_to_size = cast_to_layout.layout.size();\n         let cast_to = bx.cx().immediate_backend_type(cast_to_layout);\n         if self.layout.abi.is_uninhabited() {\n-            return bx.cx().const_undef(cast_to);\n+            return bx.cx().const_poison(cast_to);\n         }\n         let (tag_scalar, tag_encoding, tag_field) = match self.layout.variants {\n             Variants::Single { index } => {\n@@ -558,6 +558,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bug!(\"using operand local {:?} as place\", place_ref);\n                 }\n             }\n+            LocalRef::PendingOperand => {\n+                bug!(\"using still-pending operand local {:?} as place\", place_ref);\n+            }\n         };\n         for elem in place_ref.projection[base..].iter() {\n             cg_base = match *elem {"}, {"sha": "d49d23afe513487b0ef431894de0a42a7f37d7ca", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n-use rustc_target::abi::{self, VariantIdx};\n+use rustc_target::abi::{self, FIRST_VARIANT};\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     #[instrument(level = \"trace\", skip(self, bx))]\n@@ -118,21 +118,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         let variant_dest = dest.project_downcast(bx, variant_index);\n                         (variant_index, variant_dest, active_field_index)\n                     }\n-                    _ => (VariantIdx::from_u32(0), dest, None),\n+                    _ => (FIRST_VARIANT, dest, None),\n                 };\n                 if active_field_index.is_some() {\n                     assert_eq!(operands.len(), 1);\n                 }\n-                for (i, operand) in operands.iter().enumerate() {\n+                for (i, operand) in operands.iter_enumerated() {\n                     let op = self.codegen_operand(bx, operand);\n                     // Do not generate stores and GEPis for zero-sized fields.\n                     if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n                         let field = if let mir::AggregateKind::Array(_) = **kind {\n-                            let llindex = bx.cx().const_usize(field_index as u64);\n+                            let llindex = bx.cx().const_usize(field_index.as_u32().into());\n                             variant_dest.project_index(bx, llindex)\n                         } else {\n-                            variant_dest.project_field(bx, field_index)\n+                            variant_dest.project_field(bx, field_index.as_usize())\n                         };\n                         op.val.store(bx, field);\n                     }\n@@ -346,7 +346,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         assert!(bx.cx().is_backend_immediate(cast));\n                         let ll_t_out = bx.cx().immediate_backend_type(cast);\n                         if operand.layout.abi.is_uninhabited() {\n-                            let val = OperandValue::Immediate(bx.cx().const_undef(ll_t_out));\n+                            let val = OperandValue::Immediate(bx.cx().const_poison(ll_t_out));\n                             return OperandRef { val, layout: cast };\n                         }\n                         let r_t_in =\n@@ -516,8 +516,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             mir::Rvalue::ThreadLocalRef(def_id) => {\n                 assert!(bx.cx().tcx().is_static(def_id));\n-                let static_ = bx.get_static(def_id);\n                 let layout = bx.layout_of(bx.cx().tcx().static_ptr_ty(def_id));\n+                let static_ = if !def_id.is_local() && bx.cx().tcx().needs_thread_local_shim(def_id)\n+                {\n+                    let instance = ty::Instance {\n+                        def: ty::InstanceDef::ThreadLocalShim(def_id),\n+                        substs: ty::InternalSubsts::empty(),\n+                    };\n+                    let fn_ptr = bx.get_fn_addr(instance);\n+                    let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n+                    let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n+                    bx.call(fn_ty, Some(fn_abi), fn_ptr, &[], None)\n+                } else {\n+                    bx.get_static(def_id)\n+                };\n                 OperandRef { val: OperandValue::Immediate(static_), layout }\n             }\n             mir::Rvalue::Use(ref operand) => self.codegen_operand(bx, operand),\n@@ -545,7 +557,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n         if let Some(index) = place.as_local() {\n-            if let LocalRef::Operand(Some(op)) = self.locals[index] {\n+            if let LocalRef::Operand(op) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.kind() {\n                     let n = n.eval_target_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n                     return bx.cx().const_usize(n);"}, {"sha": "3fd7397ad38651c21ce8f6d93ac6c1ba7abe6955", "filename": "compiler/rustc_codegen_ssa/src/mir/statement.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fstatement.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -18,12 +18,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         LocalRef::UnsizedPlace(cg_indirect_dest) => {\n                             self.codegen_rvalue_unsized(bx, cg_indirect_dest, rvalue)\n                         }\n-                        LocalRef::Operand(None) => {\n+                        LocalRef::PendingOperand => {\n                             let operand = self.codegen_rvalue_operand(bx, rvalue);\n-                            self.locals[index] = LocalRef::Operand(Some(operand));\n+                            self.locals[index] = LocalRef::Operand(operand);\n                             self.debug_introduce_local(bx, index);\n                         }\n-                        LocalRef::Operand(Some(op)) => {\n+                        LocalRef::Operand(op) => {\n                             if !op.layout.is_zst() {\n                                 span_bug!(\n                                     statement.source_info.span,"}, {"sha": "61906302779e95dbdc864d31dd49ee0519c3d6c5", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,6 +8,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     // Constant constructors\n     fn const_null(&self, t: Self::Type) -> Self::Value;\n     fn const_undef(&self, t: Self::Type) -> Self::Value;\n+    fn const_poison(&self, t: Self::Type) -> Self::Value;\n     fn const_int(&self, t: Self::Type, i: i64) -> Self::Value;\n     fn const_uint(&self, t: Self::Type, i: u64) -> Self::Value;\n     fn const_uint_big(&self, t: Self::Type, u: u128) -> Self::Value;"}, {"sha": "f6751df443f7ae57eefcafdbde66eee6f34f8f08", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -39,17 +39,25 @@ const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n const_eval_unallowed_mutable_refs =\n     mutable references are not allowed in the final value of {$kind}s\n     .teach_note =\n-        References in statics and constants may only refer to immutable values.\\n\\n\n+        References in statics and constants may only refer to immutable values.\n+\n+\n         Statics are shared everywhere, and if they refer to mutable data one might violate memory\n-        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        safety since holding multiple mutable references to shared data is not allowed.\n+\n+\n         If you really want global mutable state, try using static mut or a global UnsafeCell.\n \n const_eval_unallowed_mutable_refs_raw =\n     raw mutable references are not allowed in the final value of {$kind}s\n     .teach_note =\n-        References in statics and constants may only refer to immutable values.\\n\\n\n+        References in statics and constants may only refer to immutable values.\n+\n+\n         Statics are shared everywhere, and if they refer to mutable data one might violate memory\n-        safety since holding multiple mutable references to shared data is not allowed.\\n\\n\n+        safety since holding multiple mutable references to shared data is not allowed.\n+\n+\n         If you really want global mutable state, try using static mut or a global UnsafeCell.\n \n const_eval_non_const_fmt_macro_call ="}, {"sha": "c87ea18af4f427fda5c6255da9118332e6a5529c", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -544,6 +544,12 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             RemainderByZero(op) => RemainderByZero(eval_to_int(op)?),\n             ResumedAfterReturn(generator_kind) => ResumedAfterReturn(*generator_kind),\n             ResumedAfterPanic(generator_kind) => ResumedAfterPanic(*generator_kind),\n+            MisalignedPointerDereference { ref required, ref found } => {\n+                MisalignedPointerDereference {\n+                    required: eval_to_int(required)?,\n+                    found: eval_to_int(found)?,\n+                }\n+            }\n         };\n         Err(ConstEvalErrKind::AssertFailure(err).into())\n     }"}, {"sha": "4d54c01830bc0f27d63263348b4a689b699aa6f9", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,7 +8,7 @@ use crate::interpret::{\n use crate::interpret::{MPlaceTy, Value};\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::{Align, FieldIdx, VariantIdx, FIRST_VARIANT};\n \n #[instrument(skip(ecx), level = \"debug\")]\n fn branches<'tcx>(\n@@ -412,7 +412,8 @@ fn valtree_into_mplace<'tcx>(\n \n                         let inner_ty = match ty.kind() {\n                             ty::Adt(def, substs) => {\n-                                def.variant(VariantIdx::from_u32(0)).fields[i].ty(tcx, substs)\n+                                let i = FieldIdx::from_usize(i);\n+                                def.variant(FIRST_VARIANT).fields[i].ty(tcx, substs)\n                             }\n                             ty::Tuple(inner_tys) => inner_tys[i],\n                             _ => bug!(\"unexpected unsized type {:?}\", ty),"}, {"sha": "03b09cf830b71dd7c2f172125e8d5fd203b7d19e", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,10 +5,11 @@\n use either::{Either, Left, Right};\n \n use rustc_ast::Mutability;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n-use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, VariantIdx};\n+use rustc_target::abi::{self, Abi, Align, FieldIdx, HasDataLayout, Size, FIRST_VARIANT};\n \n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n@@ -787,7 +788,7 @@ where\n     pub fn write_aggregate(\n         &mut self,\n         kind: &mir::AggregateKind<'tcx>,\n-        operands: &[mir::Operand<'tcx>],\n+        operands: &IndexSlice<FieldIdx, mir::Operand<'tcx>>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         self.write_uninit(&dest)?;\n@@ -796,14 +797,14 @@ where\n                 let variant_dest = self.place_downcast(&dest, variant_index)?;\n                 (variant_index, variant_dest, active_field_index)\n             }\n-            _ => (VariantIdx::from_u32(0), dest.clone(), None),\n+            _ => (FIRST_VARIANT, dest.clone(), None),\n         };\n         if active_field_index.is_some() {\n             assert_eq!(operands.len(), 1);\n         }\n-        for (field_index, operand) in operands.iter().enumerate() {\n+        for (field_index, operand) in operands.iter_enumerated() {\n             let field_index = active_field_index.unwrap_or(field_index);\n-            let field_dest = self.place_field(&variant_dest, field_index)?;\n+            let field_dest = self.place_field(&variant_dest, field_index.as_usize())?;\n             let op = self.eval_operand(operand, Some(field_dest.layout))?;\n             self.copy_op(&op, &field_dest, /*allow_transmute*/ false)?;\n         }"}, {"sha": "2d9fee9852cc68198e1d0406984eb400f7f1decf", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -382,6 +382,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | ty::InstanceDef::FnPtrShim(..)\n             | ty::InstanceDef::DropGlue(..)\n             | ty::InstanceDef::CloneShim(..)\n+            | ty::InstanceDef::FnPtrAddrShim(..)\n+            | ty::InstanceDef::ThreadLocalShim(..)\n             | ty::InstanceDef::Item(_) => {\n                 // We need MIR for this fn\n                 let Some((body, instance)) =\n@@ -539,7 +541,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let mut receiver = args[0].clone();\n                 let receiver_place = loop {\n                     match receiver.layout.ty.kind() {\n-                        ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,\n+                        ty::Ref(..) | ty::RawPtr(..) => {\n+                            // We do *not* use `deref_operand` here: we don't want to conceptually\n+                            // create a place that must be dereferenceable, since the receiver might\n+                            // be a raw pointer and (for `*const dyn Trait`) we don't need to\n+                            // actually access memory to resolve this method.\n+                            // Also see <https://github.com/rust-lang/miri/issues/2786>.\n+                            let val = self.read_immediate(&receiver)?;\n+                            break self.ref_to_mplace(&val)?;\n+                        }\n                         ty::Dynamic(.., ty::Dyn) => break receiver.assert_mem_place(), // no immediate unsized values\n                         ty::Dynamic(.., ty::DynStar) => {\n                             // Not clear how to handle this, so far we assume the receiver is always a pointer."}, {"sha": "93b5273e1b1462bc528d715f1a5fc3c92f427b9f", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -16,7 +16,9 @@ use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange};\n+use rustc_target::abi::{\n+    Abi, FieldIdx, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange,\n+};\n \n use std::hash::Hash;\n \n@@ -269,14 +271,16 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 match layout.variants {\n                     Variants::Single { index } => {\n                         // Inside a variant\n-                        PathElem::Field(def.variant(index).fields[field].name)\n+                        PathElem::Field(def.variant(index).fields[FieldIdx::from_usize(field)].name)\n                     }\n                     Variants::Multiple { .. } => bug!(\"we handled variants above\"),\n                 }\n             }\n \n             // other ADTs\n-            ty::Adt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].name),\n+            ty::Adt(def, _) => {\n+                PathElem::Field(def.non_enum_variant().fields[FieldIdx::from_usize(field)].name)\n+            }\n \n             // arrays/slices\n             ty::Array(..) | ty::Slice(..) => PathElem::ArrayElem(field),"}, {"sha": "d6110a050f2dc58fdd19a792d6d7731845b26a84", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -722,6 +722,32 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     }\n                 };\n \n+                // Check that all trait bounds that are marked as `~const` can be satisfied.\n+                //\n+                // Typeck only does a \"non-const\" check since it operates on HIR and cannot distinguish\n+                // which path expressions are getting called on and which path expressions are only used\n+                // as function pointers. This is required for correctness.\n+                let infcx = tcx.infer_ctxt().build();\n+                let ocx = ObligationCtxt::new(&infcx);\n+\n+                let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n+                let cause = ObligationCause::new(\n+                    terminator.source_info.span,\n+                    self.body.source.def_id().expect_local(),\n+                    ObligationCauseCode::ItemObligation(callee),\n+                );\n+                let normalized_predicates = ocx.normalize(&cause, param_env, predicates);\n+                ocx.register_obligations(traits::predicates_for_generics(\n+                    |_, _| cause.clone(),\n+                    self.param_env,\n+                    normalized_predicates,\n+                ));\n+\n+                let errors = ocx.select_all_or_error();\n+                if !errors.is_empty() {\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors);\n+                }\n+\n                 // Attempting to call a trait method?\n                 if let Some(trait_id) = tcx.trait_of_item(callee) {\n                     trace!(\"attempting to call a trait method\");\n@@ -749,31 +775,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         selcx.select(&obligation)\n                     };\n \n-                    // do a well-formedness check on the trait method being called. This is because typeck only does a\n-                    // \"non-const\" check. This is required for correctness here.\n-                    {\n-                        let infcx = tcx.infer_ctxt().build();\n-                        let ocx = ObligationCtxt::new(&infcx);\n-\n-                        let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n-                        let cause = ObligationCause::new(\n-                            terminator.source_info.span,\n-                            self.body.source.def_id().expect_local(),\n-                            ObligationCauseCode::ItemObligation(callee),\n-                        );\n-                        let normalized_predicates = ocx.normalize(&cause, param_env, predicates);\n-                        ocx.register_obligations(traits::predicates_for_generics(\n-                            |_, _| cause.clone(),\n-                            self.param_env,\n-                            normalized_predicates,\n-                        ));\n-\n-                        let errors = ocx.select_all_or_error();\n-                        if !errors.is_empty() {\n-                            infcx.err_ctxt().report_fulfillment_errors(&errors);\n-                        }\n-                    }\n-\n                     match implsrc {\n                         Ok(Some(ImplSource::Param(_, ty::BoundConstness::ConstIfConst))) => {\n                             debug!("}, {"sha": "6774e5a5837640b4c54bc303796b27ec6e7aab29", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -21,7 +21,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, List, TyCtxt, TypeVisitableExt};\n use rustc_span::Span;\n \n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n \n use std::cell::Cell;\n use std::{cmp, iter, mem};\n@@ -184,7 +184,7 @@ pub fn collect_temps_and_candidates<'tcx>(\n /// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n-    temps: &'a mut IndexVec<Local, TempState>,\n+    temps: &'a mut IndexSlice<Local, TempState>,\n }\n \n impl<'a, 'tcx> std::ops::Deref for Validator<'a, 'tcx> {\n@@ -669,7 +669,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     ccx: &ConstCx<'_, '_>,\n-    temps: &mut IndexVec<Local, TempState>,\n+    temps: &mut IndexSlice<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n     let mut validator = Validator { ccx, temps };\n@@ -707,7 +707,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn assign(&mut self, dest: Local, rvalue: Rvalue<'tcx>, span: Span) {\n-        let last = self.promoted.basic_blocks.last().unwrap();\n+        let last = self.promoted.basic_blocks.last_index().unwrap();\n         let data = &mut self.promoted[last];\n         data.statements.push(Statement {\n             source_info: SourceInfo::outermost(span),\n@@ -800,7 +800,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         self.visit_operand(arg, loc);\n                     }\n \n-                    let last = self.promoted.basic_blocks.last().unwrap();\n+                    let last = self.promoted.basic_blocks.last_index().unwrap();\n                     let new_target = self.new_block();\n \n                     *self.promoted[last].terminator_mut() = Terminator {"}, {"sha": "558253f727bcc7ff3d67dc3af01cca876f2ac6fc", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::{self, InstanceDef, ParamEnv, Ty, TyCtxt, TypeVisitableExt\n use rustc_mir_dataflow::impls::MaybeStorageLive;\n use rustc_mir_dataflow::storage::always_storage_live_locals;\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n-use rustc_target::abi::{Size, VariantIdx};\n+use rustc_target::abi::{Size, FIRST_VARIANT};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum EdgeKind {\n@@ -359,8 +359,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         check_equal(self, location, *f_ty);\n                     }\n                     ty::Adt(adt_def, substs) => {\n-                        let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n-                        let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n+                        let var = parent_ty.variant_index.unwrap_or(FIRST_VARIANT);\n+                        let Some(field) = adt_def.variant(var).fields.get(f) else {\n                             fail_out_of_bounds(self, location);\n                             return;\n                         };\n@@ -677,8 +677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     );\n                 }\n                 if let Rvalue::CopyForDeref(place) = rvalue {\n-                    if !place.ty(&self.body.local_decls, self.tcx).ty.builtin_deref(true).is_some()\n-                    {\n+                    if place.ty(&self.body.local_decls, self.tcx).ty.builtin_deref(true).is_none() {\n                         self.fail(\n                             location,\n                             \"`CopyForDeref` should only be used for dereferenceable types\","}, {"sha": "0b2b03da2080a72173290a19ea5e4cbb5d96e117", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,12 +10,12 @@ arrayvec = { version = \"0.7\", default-features = false }\n bitflags = \"1.2.1\"\n cfg-if = \"1.0\"\n ena = \"0.14.2\"\n-indexmap = { version = \"1.9.1\" }\n+indexmap = { version = \"1.9.3\" }\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n libc = \"0.2\"\n measureme = \"10.0.0\"\n-rayon-core = { version = \"0.4.0\", package = \"rustc-rayon-core\", optional = true }\n-rayon = { version = \"0.4.0\", package = \"rustc-rayon\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n+rustc-rayon = { version = \"0.5.0\", optional = true }\n rustc_graphviz = { path = \"../rustc_graphviz\" }\n rustc-hash = \"1.1.0\"\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n@@ -51,4 +51,4 @@ features = [\n memmap2 = \"0.2.1\"\n \n [features]\n-rustc_use_parallel_compiler = [\"indexmap/rustc-rayon\", \"rayon\", \"rayon-core\"]\n+rustc_use_parallel_compiler = [\"indexmap/rustc-rayon\", \"rustc-rayon\", \"rustc-rayon-core\"]"}, {"sha": "0df9dc112ee6133a1cc91a74a460c03c61811160", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,7 +10,7 @@\n //! <https://www.cs.princeton.edu/courses/archive/spr03/cs423/download/dominators.pdf>\n \n use super::ControlFlowGraph;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use std::cmp::Ordering;\n \n #[cfg(test)]\n@@ -256,10 +256,10 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n /// where `+>` is a proper ancestor and `*>` is just an ancestor.\n #[inline]\n fn eval(\n-    ancestor: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    ancestor: &mut IndexSlice<PreorderIndex, PreorderIndex>,\n     lastlinked: Option<PreorderIndex>,\n-    semi: &IndexVec<PreorderIndex, PreorderIndex>,\n-    label: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    semi: &IndexSlice<PreorderIndex, PreorderIndex>,\n+    label: &mut IndexSlice<PreorderIndex, PreorderIndex>,\n     node: PreorderIndex,\n ) -> PreorderIndex {\n     if is_processed(node, lastlinked) {\n@@ -277,10 +277,10 @@ fn is_processed(v: PreorderIndex, lastlinked: Option<PreorderIndex>) -> bool {\n \n #[inline]\n fn compress(\n-    ancestor: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    ancestor: &mut IndexSlice<PreorderIndex, PreorderIndex>,\n     lastlinked: Option<PreorderIndex>,\n-    semi: &IndexVec<PreorderIndex, PreorderIndex>,\n-    label: &mut IndexVec<PreorderIndex, PreorderIndex>,\n+    semi: &IndexSlice<PreorderIndex, PreorderIndex>,\n+    label: &mut IndexSlice<PreorderIndex, PreorderIndex>,\n     v: PreorderIndex,\n ) {\n     assert!(is_processed(v, lastlinked));"}, {"sha": "01a83b40a75a5c9b535b868abc6a58b906bfb692", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,6 +1,6 @@\n use super::{DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use std::ops::ControlFlow;\n \n #[cfg(test)]\n@@ -31,7 +31,7 @@ fn post_order_walk<G: DirectedGraph + WithSuccessors + WithNumNodes>(\n     graph: &G,\n     node: G::Node,\n     result: &mut Vec<G::Node>,\n-    visited: &mut IndexVec<G::Node, bool>,\n+    visited: &mut IndexSlice<G::Node, bool>,\n ) {\n     struct PostOrderFrame<Node, Iter> {\n         node: Node,"}, {"sha": "28c357e54dd61e595305a39be99d9a6a291eb295", "filename": "compiler/rustc_data_structures/src/graph/scc/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,7 +8,7 @@\n use crate::fx::FxHashSet;\n use crate::graph::vec_graph::VecGraph;\n use crate::graph::{DirectedGraph, GraphSuccessors, WithNumEdges, WithNumNodes, WithSuccessors};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use std::ops::Range;\n \n #[cfg(test)]\n@@ -43,7 +43,7 @@ impl<N: Idx, S: Idx + Ord> Sccs<N, S> {\n         SccsConstruction::construct(graph)\n     }\n \n-    pub fn scc_indices(&self) -> &IndexVec<N, S> {\n+    pub fn scc_indices(&self) -> &IndexSlice<N, S> {\n         &self.scc_indices\n     }\n \n@@ -123,7 +123,7 @@ impl<S: Idx> SccData<S> {\n         self.ranges.len()\n     }\n \n-    pub fn ranges(&self) -> &IndexVec<S, Range<usize>> {\n+    pub fn ranges(&self) -> &IndexSlice<S, Range<usize>> {\n         &self.ranges\n     }\n "}, {"sha": "9b52638e61249cbdd5076a23dadf27b26eec2e35", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -20,7 +20,7 @@\n #![feature(never_type)]\n #![feature(type_alias_impl_trait)]\n #![feature(new_uninit)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(rustc_attrs)]\n #![feature(negative_impls)]\n #![feature(test)]"}, {"sha": "f88c055a9b56972558c25a6799cd58069fbd910c", "filename": "compiler/rustc_data_structures/src/sharded.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsharded.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,7 @@ use std::collections::hash_map::RawEntryMut;\n use std::hash::{Hash, Hasher};\n use std::mem;\n \n-#[derive(Clone, Default)]\n+#[derive(Default)]\n #[cfg_attr(parallel_compiler, repr(align(64)))]\n struct CacheAligned<T>(T);\n \n@@ -21,7 +21,6 @@ const SHARD_BITS: usize = 0;\n pub const SHARDS: usize = 1 << SHARD_BITS;\n \n /// An array of cache-line aligned inner locked structures with convenience methods.\n-#[derive(Clone)]\n pub struct Sharded<T> {\n     shards: [CacheAligned<Lock<T>>; SHARDS],\n }"}, {"sha": "4e2126fff7be9e730b073ddd4e95a50ab21252e6", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,21 +1,46 @@\n-//! This module defines types which are thread safe if cfg!(parallel_compiler) is true.\n+//! This module defines various operations and types that are implemented in\n+//! one way for the serial compiler, and another way the parallel compiler.\n //!\n-//! `Lrc` is an alias of `Arc` if cfg!(parallel_compiler) is true, `Rc` otherwise.\n+//! Operations\n+//! ----------\n+//! The parallel versions of operations use Rayon to execute code in parallel,\n+//! while the serial versions degenerate straightforwardly to serial execution.\n+//! The operations include `join`, `parallel`, `par_iter`, and `par_for_each`.\n //!\n-//! `Lock` is a mutex.\n-//! It internally uses `parking_lot::Mutex` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! `rustc_erase_owner!` erases an `OwningRef` owner into `Erased` for the\n+//! serial version and `Erased + Send + Sync` for the parallel version.\n //!\n-//! `RwLock` is a read-write lock.\n-//! It internally uses `parking_lot::RwLock` if cfg!(parallel_compiler) is true,\n-//! `RefCell` otherwise.\n+//! Types\n+//! -----\n+//! The parallel versions of types provide various kinds of synchronization,\n+//! while the serial compiler versions do not.\n //!\n-//! `MTLock` is a mutex which disappears if cfg!(parallel_compiler) is false.\n+//! The following table shows how the types are implemented internally. Except\n+//! where noted otherwise, the type in column one is defined as a\n+//! newtype around the type from column two or three.\n //!\n-//! `MTRef` is an immutable reference if cfg!(parallel_compiler), and a mutable reference otherwise.\n+//! | Type                    | Serial version      | Parallel version                |\n+//! | ----------------------- | ------------------- | ------------------------------- |\n+//! | `Lrc<T>`                | `rc::Rc<T>`         | `sync::Arc<T>`                  |\n+//! |` Weak<T>`               | `rc::Weak<T>`       | `sync::Weak<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `AtomicBool`            | `Cell<bool>`        | `atomic::AtomicBool`            |\n+//! | `AtomicU32`             | `Cell<u32>`         | `atomic::AtomicU32`             |\n+//! | `AtomicU64`             | `Cell<u64>`         | `atomic::AtomicU64`             |\n+//! | `AtomicUsize`           | `Cell<usize>`       | `atomic::AtomicUsize`           |\n+//! |                         |                     |                                 |\n+//! | `Lock<T>`               | `RefCell<T>`        | `parking_lot::Mutex<T>`         |\n+//! | `RwLock<T>`             | `RefCell<T>`        | `parking_lot::RwLock<T>`        |\n+//! | `MTLock<T>`        [^1] | `T`                 | `Lock<T>`                       |\n+//! | `MTLockRef<'a, T>` [^2] | `&'a mut MTLock<T>` | `&'a MTLock<T>`                 |\n+//! |                         |                     |                                 |\n+//! | `ParallelIterator`      | `Iterator`          | `rayon::iter::ParallelIterator` |\n //!\n-//! `rustc_erase_owner!` erases an OwningRef owner into Erased or Erased + Send + Sync\n-//! depending on the value of cfg!(parallel_compiler).\n+//! [^1] `MTLock` is similar to `Lock`, but the serial version avoids the cost\n+//! of a `RefCell`. This is appropriate when interior mutability is not\n+//! required.\n+//!\n+//! [^2] `MTLockRef` is a typedef.\n \n use crate::owning_ref::{Erased, OwningRef};\n use std::collections::HashMap;\n@@ -209,7 +234,7 @@ cfg_if! {\n             }\n         }\n \n-        pub type MTRef<'a, T> = &'a mut T;\n+        pub type MTLockRef<'a, T> = &'a mut MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(T);\n@@ -267,7 +292,7 @@ cfg_if! {\n         pub use std::sync::Arc as Lrc;\n         pub use std::sync::Weak as Weak;\n \n-        pub type MTRef<'a, T> = &'a T;\n+        pub type MTLockRef<'a, T> = &'a MTLock<T>;\n \n         #[derive(Debug, Default)]\n         pub struct MTLock<T>(Lock<T>);\n@@ -553,18 +578,6 @@ impl<T> RwLock<T> {\n         self.write()\n     }\n \n-    #[cfg(not(parallel_compiler))]\n-    #[inline(always)]\n-    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n-        ReadGuard::clone(rg)\n-    }\n-\n-    #[cfg(parallel_compiler)]\n-    #[inline(always)]\n-    pub fn clone_guard<'a>(rg: &ReadGuard<'a, T>) -> ReadGuard<'a, T> {\n-        ReadGuard::rwlock(&rg).read()\n-    }\n-\n     #[cfg(not(parallel_compiler))]\n     #[inline(always)]\n     pub fn leak(&self) -> &T {"}, {"sha": "b96b356f55177ddeb5d48caa62be22ba5f26ab09", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,7 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(is_terminal)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(decl_macro)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]"}, {"sha": "c05324a5a2ccbc5c472634cfceb8a4567821c9ce", "filename": "compiler/rustc_error_codes/src/error_codes/E0080.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0080.md?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -16,7 +16,8 @@ or causing an integer overflow are two ways to induce this error.\n Ensure that the expressions given can be evaluated as the desired integer type.\n \n See the [Discriminants] section of the Reference for more information about\n-setting custom integer types on enums using the [`repr` attribute][repr-attribute].\n+setting custom integer types on enums using the\n+[`repr` attribute][repr-attribute].\n \n [discriminants]: https://doc.rust-lang.org/reference/items/enumerations.html#discriminants\n [repr-attribute]: https://doc.rust-lang.org/reference/type-layout.html#representations"}, {"sha": "ba5f00528218d155859d827152bcebf66942018d", "filename": "compiler/rustc_error_codes/src/error_codes/E0223.md", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0223.md", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0223.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0223.md?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,31 +3,33 @@ An attempt was made to retrieve an associated type, but the type was ambiguous.\n Erroneous code example:\n \n ```compile_fail,E0223\n-trait MyTrait {type X; }\n+trait Trait { type X; }\n \n fn main() {\n-    let foo: MyTrait::X;\n+    let foo: Trait::X;\n }\n ```\n \n-The problem here is that we're attempting to take the type of X from MyTrait.\n-Unfortunately, the type of X is not defined, because it's only made concrete in\n-implementations of the trait. A working version of this code might look like:\n+The problem here is that we're attempting to take the associated type of `X`\n+from `Trait`. Unfortunately, the type of `X` is not defined, because it's only\n+made concrete in implementations of the trait. A working version of this code\n+might look like:\n \n ```\n-trait MyTrait {type X; }\n-struct MyStruct;\n+trait Trait { type X; }\n \n-impl MyTrait for MyStruct {\n+struct Struct;\n+impl Trait for Struct {\n     type X = u32;\n }\n \n fn main() {\n-    let foo: <MyStruct as MyTrait>::X;\n+    let foo: <Struct as Trait>::X;\n }\n ```\n \n-This syntax specifies that we want the X type from MyTrait, as made concrete in\n-MyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\n-might implement two different traits with identically-named associated types.\n-This syntax allows disambiguation between the two.\n+This syntax specifies that we want the associated type `X` from `Struct`'s\n+implementation of `Trait`.\n+\n+Due to internal limitations of the current compiler implementation we cannot\n+simply use `Struct::X`."}, {"sha": "c8f73de95a214c74ba609cd1e6ce427bd6be5efe", "filename": "compiler/rustc_error_codes/src/error_codes/E0794.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0794.md?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -59,6 +59,6 @@ In the definition of `bar`, the lifetime parameter `'a` is late-bound, while\n where `'a` is universally quantified and `'b` is substituted by a specific\n lifetime. It is not allowed to explicitly specify early-bound lifetime\n arguments when late-bound lifetime parameters are present (as for `bar_fn2`,\n-see [issue #42868](https://github.com/rust-lang/rust/issues/42868)), although the\n-types that are constrained by early-bound parameters can be specified (as for\n-`bar_fn3`).\n+see [issue #42868](https://github.com/rust-lang/rust/issues/42868)), although\n+the types that are constrained by early-bound parameters can be specified (as\n+for `bar_fn3`)."}, {"sha": "6f319b96f2faf56d26b12a9d679dd82102c35ea9", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,5 +1,5 @@\n #![feature(let_chains)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(rustc_attrs)]\n #![feature(type_alias_impl_trait)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "9872b3bda1e065f4361f03cd722a70876c6e3778", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -202,7 +202,10 @@ impl AnnotateSnippetEmitterWriter {\n                             annotations: annotations\n                                 .iter()\n                                 .map(|annotation| SourceAnnotation {\n-                                    range: (annotation.start_col, annotation.end_col),\n+                                    range: (\n+                                        annotation.start_col.display,\n+                                        annotation.end_col.display,\n+                                    ),\n                                     label: annotation.label.as_deref().unwrap_or_default(),\n                                     annotation_type: annotation_type_for_level(*level),\n                                 })"}, {"sha": "4b1ff0e1df941e974695238b8b789013112235ff", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -12,7 +12,9 @@ use Destination::*;\n use rustc_span::source_map::SourceMap;\n use rustc_span::{FileLines, SourceFile, Span};\n \n-use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n+use crate::snippet::{\n+    Annotation, AnnotationColumn, AnnotationType, Line, MultilineAnnotation, Style, StyledString,\n+};\n use crate::styled_buffer::StyledBuffer;\n use crate::translation::{to_fluent_args, Translate};\n use crate::{\n@@ -858,7 +860,7 @@ impl EmitterWriter {\n         let mut short_start = true;\n         for ann in &line.annotations {\n             if let AnnotationType::MultilineStart(depth) = ann.annotation_type {\n-                if source_string.chars().take(ann.start_col).all(|c| c.is_whitespace()) {\n+                if source_string.chars().take(ann.start_col.display).all(|c| c.is_whitespace()) {\n                     let style = if ann.is_primary {\n                         Style::UnderlinePrimary\n                     } else {\n@@ -1093,15 +1095,15 @@ impl EmitterWriter {\n                         '_',\n                         line_offset + pos,\n                         width_offset + depth,\n-                        (code_offset + annotation.start_col).saturating_sub(left),\n+                        (code_offset + annotation.start_col.display).saturating_sub(left),\n                         style,\n                     );\n                 }\n                 _ if self.teach => {\n                     buffer.set_style_range(\n                         line_offset,\n-                        (code_offset + annotation.start_col).saturating_sub(left),\n-                        (code_offset + annotation.end_col).saturating_sub(left),\n+                        (code_offset + annotation.start_col.display).saturating_sub(left),\n+                        (code_offset + annotation.end_col.display).saturating_sub(left),\n                         style,\n                         annotation.is_primary,\n                     );\n@@ -1133,7 +1135,7 @@ impl EmitterWriter {\n                 for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(\n                         p,\n-                        (code_offset + annotation.start_col).saturating_sub(left),\n+                        (code_offset + annotation.start_col.display).saturating_sub(left),\n                         '|',\n                         style,\n                     );\n@@ -1169,9 +1171,9 @@ impl EmitterWriter {\n             let style =\n                 if annotation.is_primary { Style::LabelPrimary } else { Style::LabelSecondary };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, (annotation.end_col + 1).saturating_sub(left))\n+                (pos + 1, (annotation.end_col.display + 1).saturating_sub(left))\n             } else {\n-                (pos + 2, annotation.start_col.saturating_sub(left))\n+                (pos + 2, annotation.start_col.display.saturating_sub(left))\n             };\n             if let Some(ref label) = annotation.label {\n                 buffer.puts(line_offset + pos, code_offset + col, label, style);\n@@ -1208,7 +1210,7 @@ impl EmitterWriter {\n             } else {\n                 ('-', Style::UnderlineSecondary)\n             };\n-            for p in annotation.start_col..annotation.end_col {\n+            for p in annotation.start_col.display..annotation.end_col.display {\n                 buffer.putc(\n                     line_offset + 1,\n                     (code_offset + p).saturating_sub(left),\n@@ -1459,7 +1461,7 @@ impl EmitterWriter {\n                                         &annotated_file.file.name,\n                                         line.line_index\n                                     ),\n-                                    annotations[0].start_col + 1,\n+                                    annotations[0].start_col.file + 1,\n                                 ),\n                                 Style::LineAndColumn,\n                             );\n@@ -1546,7 +1548,7 @@ impl EmitterWriter {\n                 buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n                 let loc = if let Some(first_line) = annotated_file.lines.first() {\n                     let col = if let Some(first_annotation) = first_line.annotations.first() {\n-                        format!(\":{}\", first_annotation.start_col + 1)\n+                        format!(\":{}\", first_annotation.start_col.file + 1)\n                     } else {\n                         String::new()\n                     };\n@@ -1607,8 +1609,8 @@ impl EmitterWriter {\n                 let mut span_left_margin = usize::MAX;\n                 for line in &annotated_file.lines {\n                     for ann in &line.annotations {\n-                        span_left_margin = min(span_left_margin, ann.start_col);\n-                        span_left_margin = min(span_left_margin, ann.end_col);\n+                        span_left_margin = min(span_left_margin, ann.start_col.display);\n+                        span_left_margin = min(span_left_margin, ann.end_col.display);\n                     }\n                 }\n                 if span_left_margin == usize::MAX {\n@@ -1625,11 +1627,12 @@ impl EmitterWriter {\n                         annotated_file.file.get_line(line.line_index - 1).map_or(0, |s| s.len()),\n                     );\n                     for ann in &line.annotations {\n-                        span_right_margin = max(span_right_margin, ann.start_col);\n-                        span_right_margin = max(span_right_margin, ann.end_col);\n+                        span_right_margin = max(span_right_margin, ann.start_col.display);\n+                        span_right_margin = max(span_right_margin, ann.end_col.display);\n                         // FIXME: account for labels not in the same line\n                         let label_right = ann.label.as_ref().map_or(0, |l| l.len() + 1);\n-                        label_right_margin = max(label_right_margin, ann.end_col + label_right);\n+                        label_right_margin =\n+                            max(label_right_margin, ann.end_col.display + label_right);\n                     }\n                 }\n \n@@ -2232,7 +2235,7 @@ impl EmitterWriter {\n             }\n         } else if is_multiline {\n             buffer.puts(*row_num, 0, &self.maybe_anonymized(line_num), Style::LineNumber);\n-            match &highlight_parts[..] {\n+            match &highlight_parts {\n                 [SubstitutionHighlight { start: 0, end }] if *end == line_to_add.len() => {\n                     buffer.puts(*row_num, max_line_num_len + 1, \"+ \", Style::Addition);\n                 }\n@@ -2352,17 +2355,17 @@ impl FileWithAnnotatedLines {\n                         depth: 1,\n                         line_start: lo.line,\n                         line_end: hi.line,\n-                        start_col: lo.col_display,\n-                        end_col: hi.col_display,\n+                        start_col: AnnotationColumn::from_loc(&lo),\n+                        end_col: AnnotationColumn::from_loc(&hi),\n                         is_primary,\n                         label,\n                         overlaps_exactly: false,\n                     };\n                     multiline_annotations.push((lo.file, ml));\n                 } else {\n                     let ann = Annotation {\n-                        start_col: lo.col_display,\n-                        end_col: hi.col_display,\n+                        start_col: AnnotationColumn::from_loc(&lo),\n+                        end_col: AnnotationColumn::from_loc(&hi),\n                         is_primary,\n                         label,\n                         annotation_type: AnnotationType::Singleline,\n@@ -2551,7 +2554,13 @@ fn num_overlap(\n     (b_start..b_end + extra).contains(&a_start) || (a_start..a_end + extra).contains(&b_start)\n }\n fn overlaps(a1: &Annotation, a2: &Annotation, padding: usize) -> bool {\n-    num_overlap(a1.start_col, a1.end_col + padding, a2.start_col, a2.end_col, false)\n+    num_overlap(\n+        a1.start_col.display,\n+        a1.end_col.display + padding,\n+        a2.start_col.display,\n+        a2.end_col.display,\n+        false,\n+    )\n }\n \n fn emit_to_destination("}, {"sha": "98eb70b5fceeeaf70a5af67bc85b3fba5ee91a91", "filename": "compiler/rustc_errors/src/snippet.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fsnippet.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,20 +1,46 @@\n // Code for annotating snippets.\n \n-use crate::Level;\n+use crate::{Level, Loc};\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Line {\n     pub line_index: usize,\n     pub annotations: Vec<Annotation>,\n }\n \n+#[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Default)]\n+pub struct AnnotationColumn {\n+    /// the (0-indexed) column for *display* purposes, counted in characters, not utf-8 bytes\n+    pub display: usize,\n+    /// the (0-indexed) column in the file, counted in characters, not utf-8 bytes.\n+    ///\n+    /// this may be different from `self.display`,\n+    /// e.g. if the file contains hard tabs, because we convert tabs to spaces for error messages.\n+    ///\n+    /// for example:\n+    /// ```text\n+    /// (hard tab)hello\n+    ///           ^ this is display column 4, but file column 1\n+    /// ```\n+    ///\n+    /// we want to keep around the correct file offset so that column numbers in error messages\n+    /// are correct. (motivated by <https://github.com/rust-lang/rust/issues/109537>)\n+    pub file: usize,\n+}\n+\n+impl AnnotationColumn {\n+    pub fn from_loc(loc: &Loc) -> AnnotationColumn {\n+        AnnotationColumn { display: loc.col_display, file: loc.col.0 }\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub struct MultilineAnnotation {\n     pub depth: usize,\n     pub line_start: usize,\n     pub line_end: usize,\n-    pub start_col: usize,\n-    pub end_col: usize,\n+    pub start_col: AnnotationColumn,\n+    pub end_col: AnnotationColumn,\n     pub is_primary: bool,\n     pub label: Option<String>,\n     pub overlaps_exactly: bool,\n@@ -36,7 +62,12 @@ impl MultilineAnnotation {\n     pub fn as_start(&self) -> Annotation {\n         Annotation {\n             start_col: self.start_col,\n-            end_col: self.start_col + 1,\n+            end_col: AnnotationColumn {\n+                // these might not correspond to the same place anymore,\n+                // but that's okay for our purposes\n+                display: self.start_col.display + 1,\n+                file: self.start_col.file + 1,\n+            },\n             is_primary: self.is_primary,\n             label: None,\n             annotation_type: AnnotationType::MultilineStart(self.depth),\n@@ -45,7 +76,12 @@ impl MultilineAnnotation {\n \n     pub fn as_end(&self) -> Annotation {\n         Annotation {\n-            start_col: self.end_col.saturating_sub(1),\n+            start_col: AnnotationColumn {\n+                // these might not correspond to the same place anymore,\n+                // but that's okay for our purposes\n+                display: self.end_col.display.saturating_sub(1),\n+                file: self.end_col.file.saturating_sub(1),\n+            },\n             end_col: self.end_col,\n             is_primary: self.is_primary,\n             label: self.label.clone(),\n@@ -55,8 +91,8 @@ impl MultilineAnnotation {\n \n     pub fn as_line(&self) -> Annotation {\n         Annotation {\n-            start_col: 0,\n-            end_col: 0,\n+            start_col: Default::default(),\n+            end_col: Default::default(),\n             is_primary: self.is_primary,\n             label: None,\n             annotation_type: AnnotationType::MultilineLine(self.depth),\n@@ -92,14 +128,14 @@ pub enum AnnotationType {\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Annotation {\n-    /// Start column, 0-based indexing -- counting *characters*, not\n-    /// utf-8 bytes. Note that it is important that this field goes\n+    /// Start column.\n+    /// Note that it is important that this field goes\n     /// first, so that when we sort, we sort orderings by start\n     /// column.\n-    pub start_col: usize,\n+    pub start_col: AnnotationColumn,\n \n     /// End column within the line (exclusive)\n-    pub end_col: usize,\n+    pub end_col: AnnotationColumn,\n \n     /// Is this annotation derived from primary span\n     pub is_primary: bool,\n@@ -118,12 +154,13 @@ impl Annotation {\n         matches!(self.annotation_type, AnnotationType::MultilineLine(_))\n     }\n \n+    /// Length of this annotation as displayed in the stderr output\n     pub fn len(&self) -> usize {\n         // Account for usize underflows\n-        if self.end_col > self.start_col {\n-            self.end_col - self.start_col\n+        if self.end_col.display > self.start_col.display {\n+            self.end_col.display - self.start_col.display\n         } else {\n-            self.start_col - self.end_col\n+            self.start_col.display - self.end_col.display\n         }\n     }\n "}, {"sha": "caa2a201c758dbfae4dd1a6398ea05e264670b14", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -793,7 +793,9 @@ impl SyntaxExtension {\n                 )\n             })\n             .unwrap_or_else(|| (None, helper_attrs));\n-        let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n+        let stability = attr::find_stability(&sess, attrs, span);\n+        let const_stability = attr::find_const_stability(&sess, attrs, span);\n+        let body_stability = attr::find_body_stability(&sess, attrs);\n         if let Some((_, sp)) = const_stability {\n             sess.emit_err(errors::MacroConstStability {\n                 span: sp,"}, {"sha": "8a16143311b8f7a0497dede556f616254cf53ba3", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -36,7 +36,7 @@ impl<'a> ExtCtxt<'a> {\n         );\n         let args = if !args.is_empty() {\n             let args = args.into_iter().map(ast::AngleBracketedArg::Arg).collect();\n-            ast::AngleBracketedArgs { args, span }.into()\n+            Some(ast::AngleBracketedArgs { args, span }.into())\n         } else {\n             None\n         };"}, {"sha": "26bc216f678cfb5be2f18d5e2facfef20c668037", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -54,7 +54,7 @@ impl base::BangProcMacro for BangProcMacro {\n     ) -> Result<TokenStream, ErrorGuaranteed> {\n         let _timer =\n             ecx.sess.prof.generic_activity_with_arg_recorder(\"expand_proc_macro\", |recorder| {\n-                recorder.record_arg_with_span(ecx.expansion_descr(), span);\n+                recorder.record_arg_with_span(ecx.sess.source_map(), ecx.expansion_descr(), span);\n             });\n \n         let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n@@ -85,7 +85,7 @@ impl base::AttrProcMacro for AttrProcMacro {\n     ) -> Result<TokenStream, ErrorGuaranteed> {\n         let _timer =\n             ecx.sess.prof.generic_activity_with_arg_recorder(\"expand_proc_macro\", |recorder| {\n-                recorder.record_arg_with_span(ecx.expansion_descr(), span);\n+                recorder.record_arg_with_span(ecx.sess.source_map(), ecx.expansion_descr(), span);\n             });\n \n         let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n@@ -134,7 +134,11 @@ impl MultiItemModifier for DeriveProcMacro {\n         let stream = {\n             let _timer =\n                 ecx.sess.prof.generic_activity_with_arg_recorder(\"expand_proc_macro\", |recorder| {\n-                    recorder.record_arg_with_span(ecx.expansion_descr(), span);\n+                    recorder.record_arg_with_span(\n+                        ecx.sess.source_map(),\n+                        ecx.expansion_descr(),\n+                        span,\n+                    );\n                 });\n             let proc_macro_backtrace = ecx.ecfg.proc_macro_backtrace;\n             let strategy = exec_strategy(ecx);"}, {"sha": "84114b27f415ca06201d179e5b95344671f6e903", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -225,7 +225,7 @@ declare_features! (\n     (active, rustc_allow_const_fn_unstable, \"1.49.0\", Some(69399), None),\n     /// Allows using compiler's own crates.\n     (active, rustc_private, \"1.0.0\", Some(27812), None),\n-    /// Allows using internal rustdoc features like `doc(primitive)` or `doc(keyword)`.\n+    /// Allows using internal rustdoc features like `doc(keyword)`.\n     (active, rustdoc_internals, \"1.58.0\", Some(90418), None),\n     /// Allows using the `rustdoc::missing_doc_code_examples` lint\n     (active, rustdoc_missing_doc_code_examples, \"1.31.0\", Some(101730), None),\n@@ -495,6 +495,8 @@ declare_features! (\n     (active, repr_simd, \"1.4.0\", Some(27731), None),\n     /// Allows return-position `impl Trait` in traits.\n     (incomplete, return_position_impl_trait_in_trait, \"1.65.0\", Some(91611), None),\n+    /// Allows bounding the return type of AFIT/RPITIT.\n+    (incomplete, return_type_notation, \"CURRENT_RUSTC_VERSION\", Some(109417), None),\n     /// Allows `extern \"rust-cold\"`.\n     (active, rust_cold_cc, \"1.63.0\", Some(97544), None),\n     /// Allows the use of SIMD types in functions declared in `extern` blocks."}, {"sha": "c77292fdd1647d630407cafafe14482f17760764", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -778,6 +778,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         definition of a trait, it's currently in experimental form and should be changed before \\\n         being exposed outside of the std\"\n     ),\n+    rustc_attr!(\n+        rustc_doc_primitive, Normal, template!(NameValueStr: \"primitive name\"), ErrorFollowing,\n+        r#\"`rustc_doc_primitive` is a rustc internal attribute\"#,\n+    ),\n \n     // ==========================================================================\n     // Internal attributes, Testing:"}, {"sha": "3ce16e1566769d163a95b6fcfef68d0077ce2159", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -11,7 +11,7 @@\n //! even if it is stabilized or removed, *do not remove it*. Instead, move the\n //! symbol to the `accepted` or `removed` modules respectively.\n \n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n "}, {"sha": "8ceb176491b6f95d37934f00f2cba89dd721f99f", "filename": "compiler/rustc_hir/src/definitions.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdefinitions.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -404,12 +404,8 @@ impl DefPathData {\n         match *self {\n             TypeNs(name) | ValueNs(name) | MacroNs(name) | LifetimeNs(name) => Some(name),\n \n-            // We use this name when collecting `ModChild`s.\n-            // FIXME this could probably be removed with some refactoring to the name resolver.\n-            ImplTraitAssocTy => Some(kw::Empty),\n-\n             Impl | ForeignMod | CrateRoot | Use | GlobalAsm | ClosureExpr | Ctor | AnonConst\n-            | ImplTrait => None,\n+            | ImplTrait | ImplTraitAssocTy => None,\n         }\n     }\n "}, {"sha": "35a72f868fbcc31df0f616b1094a3d2c9ca23335", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -328,7 +328,7 @@ pub struct GenericArgs<'hir> {\n     /// Were arguments written in parenthesized form `Fn(T) -> U`?\n     /// This is required mostly for pretty-printing and diagnostics,\n     /// but also for changing lifetime elision rules to be \"function-like\".\n-    pub parenthesized: bool,\n+    pub parenthesized: GenericArgsParentheses,\n     /// The span encompassing arguments and the surrounding brackets `<>` or `()`\n     ///       Foo<A, B, AssocTy = D>           Fn(T, U, V) -> W\n     ///          ^^^^^^^^^^^^^^^^^^^             ^^^^^^^^^\n@@ -340,11 +340,16 @@ pub struct GenericArgs<'hir> {\n \n impl<'hir> GenericArgs<'hir> {\n     pub const fn none() -> Self {\n-        Self { args: &[], bindings: &[], parenthesized: false, span_ext: DUMMY_SP }\n+        Self {\n+            args: &[],\n+            bindings: &[],\n+            parenthesized: GenericArgsParentheses::No,\n+            span_ext: DUMMY_SP,\n+        }\n     }\n \n     pub fn inputs(&self) -> &[Ty<'hir>] {\n-        if self.parenthesized {\n+        if self.parenthesized == GenericArgsParentheses::ParenSugar {\n             for arg in self.args {\n                 match arg {\n                     GenericArg::Lifetime(_) => {}\n@@ -417,6 +422,17 @@ impl<'hir> GenericArgs<'hir> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]\n+#[derive(HashStable_Generic)]\n+pub enum GenericArgsParentheses {\n+    No,\n+    /// Bounds for `feature(return_type_notation)`, like `T: Trait<method(..): Send>`,\n+    /// where the args are explicitly elided with `..`\n+    ReturnTypeNotation,\n+    /// parenthesized function-family traits, like `T: Fn(u32) -> i32`\n+    ParenSugar,\n+}\n+\n /// A modifier on a bound, currently this is only used for `?Sized`, where the\n /// modifier is `Maybe`. Negative bounds should also be handled here.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Hash, Debug)]"}, {"sha": "eac8fd29429319c4fe82ec1e446395b7422fa0db", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -166,6 +166,9 @@ language_item_table! {\n \n     Freeze,                  sym::freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n \n+    FnPtrTrait,              sym::fn_ptr_trait,        fn_ptr_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    FnPtrAddr,               sym::fn_ptr_addr,         fn_ptr_addr,                Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n     Drop,                    sym::drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n     Destruct,                sym::destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n \n@@ -237,6 +240,7 @@ language_item_table! {\n     PanicDisplay,            sym::panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n     ConstPanicFmt,           sym::const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n     PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n+    PanicMisalignedPointerDereference,        sym::panic_misaligned_pointer_dereference,  panic_misaligned_pointer_dereference_fn,      Target::Fn,             GenericRequirement::Exact(0);\n     PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n     PanicLocation,           sym::panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n     PanicImpl,               sym::panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;"}, {"sha": "a57f3987849161a64a6475c5eac35a906e779c03", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -178,3 +178,14 @@ hir_analysis_invalid_union_field =\n \n hir_analysis_invalid_union_field_sugg =\n     wrap the field type in `ManuallyDrop<...>`\n+\n+hir_analysis_return_type_notation_on_non_rpitit =\n+    return type notation used on function that is not `async` and does not return `impl Trait`\n+    .note = function returns `{$ty}`, which is not compatible with associated type return bounds\n+    .label = this function must be `async` or return `impl Trait`\n+\n+hir_analysis_return_type_notation_equality_bound =\n+    return type notation is not allowed to use type equality\n+\n+hir_analysis_return_type_notation_missing_method =\n+    cannot find associated function `{$assoc_name}` in trait `{$trait_name}`"}, {"sha": "113c3f08ab9ae986c3dfc8155157976522c40b9f", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -55,7 +55,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let trait_def = self.tcx().trait_def(trait_def_id);\n         if !trait_def.paren_sugar {\n-            if trait_segment.args().parenthesized {\n+            if trait_segment.args().parenthesized == hir::GenericArgsParentheses::ParenSugar {\n                 // For now, require that parenthetical notation be used only with `Fn()` etc.\n                 let mut err = feature_err(\n                     &self.tcx().sess.parse_sess,\n@@ -71,7 +71,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let sess = self.tcx().sess;\n \n-        if !trait_segment.args().parenthesized {\n+        if trait_segment.args().parenthesized != hir::GenericArgsParentheses::ParenSugar {\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let mut err = feature_err(\n                 &sess.parse_sess,\n@@ -483,8 +483,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 [segment] if segment.args.is_none() => {\n                     trait_bound_spans = vec![segment.ident.span];\n                     associated_types = associated_types\n-                        .into_iter()\n-                        .map(|(_, items)| (segment.ident.span, items))\n+                        .into_values()\n+                        .map(|items| (segment.ident.span, items))\n                         .collect();\n                 }\n                 _ => {}\n@@ -607,11 +607,19 @@ pub fn prohibit_assoc_ty_binding(\n     span: Span,\n     segment: Option<(&hir::PathSegment<'_>, Span)>,\n ) {\n-    tcx.sess.emit_err(AssocTypeBindingNotAllowed { span, fn_trait_expansion: if let Some((segment, span)) = segment && segment.args().parenthesized {\n-        Some(ParenthesizedFnTraitExpansion { span, expanded_type: fn_trait_to_string(tcx, segment, false) })\n-    } else {\n-        None\n-    }});\n+    tcx.sess.emit_err(AssocTypeBindingNotAllowed {\n+        span,\n+        fn_trait_expansion: if let Some((segment, span)) = segment\n+            && segment.args().parenthesized == hir::GenericArgsParentheses::ParenSugar\n+        {\n+            Some(ParenthesizedFnTraitExpansion {\n+                span,\n+                expanded_type: fn_trait_to_string(tcx, segment, false),\n+            })\n+        } else {\n+            None\n+        },\n+    });\n }\n \n pub(crate) fn fn_trait_to_string("}, {"sha": "e25b07d93922ebbf5b532c53d53dfe88e6d52fe6", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 156, "deletions": 57, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -854,16 +854,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n-    fn trait_defines_associated_type_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n-        self.tcx()\n-            .associated_items(trait_def_id)\n-            .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n-            .is_some()\n-    }\n-    fn trait_defines_associated_const_named(&self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+    fn trait_defines_associated_item_named(\n+        &self,\n+        trait_def_id: DefId,\n+        assoc_kind: ty::AssocKind,\n+        assoc_name: Ident,\n+    ) -> bool {\n         self.tcx()\n             .associated_items(trait_def_id)\n-            .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Const, trait_def_id)\n+            .find_by_name_and_kind(self.tcx(), assoc_name, assoc_kind, trait_def_id)\n             .is_some()\n     }\n \n@@ -1087,24 +1086,44 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let tcx = self.tcx();\n \n-        let candidate =\n-            if self.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n-                // Simple case: X is defined in the current trait.\n+        let return_type_notation =\n+            binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation;\n+\n+        let candidate = if return_type_notation {\n+            if self.trait_defines_associated_item_named(\n+                trait_ref.def_id(),\n+                ty::AssocKind::Fn,\n+                binding.item_name,\n+            ) {\n                 trait_ref\n             } else {\n-                // Otherwise, we have to walk through the supertraits to find\n-                // those that do.\n-                self.one_bound_for_assoc_type(\n-                    || traits::supertraits(tcx, trait_ref),\n-                    trait_ref.print_only_trait_path(),\n-                    binding.item_name,\n-                    path_span,\n-                    match binding.kind {\n-                        ConvertedBindingKind::Equality(term) => Some(term),\n-                        _ => None,\n-                    },\n-                )?\n-            };\n+                return Err(tcx.sess.emit_err(crate::errors::ReturnTypeNotationMissingMethod {\n+                    span: binding.span,\n+                    trait_name: tcx.item_name(trait_ref.def_id()),\n+                    assoc_name: binding.item_name.name,\n+                }));\n+            }\n+        } else if self.trait_defines_associated_item_named(\n+            trait_ref.def_id(),\n+            ty::AssocKind::Type,\n+            binding.item_name,\n+        ) {\n+            // Simple case: X is defined in the current trait.\n+            trait_ref\n+        } else {\n+            // Otherwise, we have to walk through the supertraits to find\n+            // those that do.\n+            self.one_bound_for_assoc_type(\n+                || traits::supertraits(tcx, trait_ref),\n+                trait_ref.print_only_trait_path(),\n+                binding.item_name,\n+                path_span,\n+                match binding.kind {\n+                    ConvertedBindingKind::Equality(term) => Some(term),\n+                    _ => None,\n+                },\n+            )?\n+        };\n \n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n@@ -1116,9 +1135,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .filter_by_name_unhygienic(assoc_ident.name)\n                 .find(|i| i.kind == kind && i.ident(tcx).normalize_to_macros_2_0() == assoc_ident)\n         };\n-        let assoc_item = find_item_of_kind(ty::AssocKind::Type)\n-            .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n-            .expect(\"missing associated type\");\n+        let assoc_item = if return_type_notation {\n+            find_item_of_kind(ty::AssocKind::Fn)\n+        } else {\n+            find_item_of_kind(ty::AssocKind::Type)\n+                .or_else(|| find_item_of_kind(ty::AssocKind::Const))\n+        }\n+        .expect(\"missing associated type\");\n \n         if !assoc_item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n             tcx.sess\n@@ -1135,7 +1158,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             dup_bindings\n                 .entry(assoc_item.def_id)\n                 .and_modify(|prev_span| {\n-                    self.tcx().sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n+                    tcx.sess.emit_err(ValueOfAssociatedStructAlreadySpecified {\n                         span: binding.span,\n                         prev_span: *prev_span,\n                         item_name: binding.item_name,\n@@ -1145,28 +1168,100 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 .or_insert(binding.span);\n         }\n \n-        // Include substitutions for generic parameters of associated types\n-        let projection_ty = candidate.map_bound(|trait_ref| {\n-            let ident = Ident::new(assoc_item.name, binding.item_name.span);\n-            let item_segment = hir::PathSegment {\n-                ident,\n-                hir_id: binding.hir_id,\n-                res: Res::Err,\n-                args: Some(binding.gen_args),\n-                infer_args: false,\n+        let projection_ty = if return_type_notation {\n+            // If we have an method return type bound, then we need to substitute\n+            // the method's early bound params with suitable late-bound params.\n+            let mut num_bound_vars = candidate.bound_vars().len();\n+            let substs =\n+                candidate.skip_binder().substs.extend_to(tcx, assoc_item.def_id, |param, _| {\n+                    let subst = match param.kind {\n+                        GenericParamDefKind::Lifetime => tcx\n+                            .mk_re_late_bound(\n+                                ty::INNERMOST,\n+                                ty::BoundRegion {\n+                                    var: ty::BoundVar::from_usize(num_bound_vars),\n+                                    kind: ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                                },\n+                            )\n+                            .into(),\n+                        GenericParamDefKind::Type { .. } => tcx\n+                            .mk_bound(\n+                                ty::INNERMOST,\n+                                ty::BoundTy {\n+                                    var: ty::BoundVar::from_usize(num_bound_vars),\n+                                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n+                                },\n+                            )\n+                            .into(),\n+                        GenericParamDefKind::Const { .. } => {\n+                            let ty = tcx\n+                                .type_of(param.def_id)\n+                                .no_bound_vars()\n+                                .expect(\"ct params cannot have early bound vars\");\n+                            tcx.mk_const(\n+                                ty::ConstKind::Bound(\n+                                    ty::INNERMOST,\n+                                    ty::BoundVar::from_usize(num_bound_vars),\n+                                ),\n+                                ty,\n+                            )\n+                            .into()\n+                        }\n+                    };\n+                    num_bound_vars += 1;\n+                    subst\n+                });\n+\n+            // Next, we need to check that the return-type notation is being used on\n+            // an RPITIT (return-position impl trait in trait) or AFIT (async fn in trait).\n+            let output = tcx.fn_sig(assoc_item.def_id).skip_binder().output();\n+            let output = if let ty::Alias(ty::Projection, alias_ty) = *output.skip_binder().kind()\n+                && tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n+            {\n+                alias_ty\n+            } else {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationOnNonRpitit {\n+                        span: binding.span,\n+                        ty: tcx.liberate_late_bound_regions(assoc_item.def_id, output),\n+                        fn_span: tcx.hir().span_if_local(assoc_item.def_id),\n+                        note: (),\n+                    },\n+                ));\n             };\n \n-            let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n-                path_span,\n-                assoc_item.def_id,\n-                &item_segment,\n-                trait_ref.substs,\n-            );\n+            // Finally, move the fn return type's bound vars over to account for the early bound\n+            // params (and trait ref's late bound params). This logic is very similar to\n+            // `Predicate::subst_supertrait`, and it's no coincidence why.\n+            let shifted_output = tcx.shift_bound_var_indices(num_bound_vars, output);\n+            let subst_output = ty::EarlyBinder(shifted_output).subst(tcx, substs);\n+\n+            let bound_vars = tcx.late_bound_vars(binding.hir_id);\n+            ty::Binder::bind_with_vars(subst_output, bound_vars)\n+        } else {\n+            // Include substitutions for generic parameters of associated types\n+            candidate.map_bound(|trait_ref| {\n+                let ident = Ident::new(assoc_item.name, binding.item_name.span);\n+                let item_segment = hir::PathSegment {\n+                    ident,\n+                    hir_id: binding.hir_id,\n+                    res: Res::Err,\n+                    args: Some(binding.gen_args),\n+                    infer_args: false,\n+                };\n \n-            debug!(?substs_trait_ref_and_assoc_item);\n+                let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n+                    path_span,\n+                    assoc_item.def_id,\n+                    &item_segment,\n+                    trait_ref.substs,\n+                );\n \n-            self.tcx().mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n-        });\n+                debug!(?substs_trait_ref_and_assoc_item);\n+\n+                tcx.mk_alias_ty(assoc_item.def_id, substs_trait_ref_and_assoc_item)\n+            })\n+        };\n \n         if !speculative {\n             // Find any late-bound regions declared in `ty` that are not\n@@ -1206,6 +1301,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         match binding.kind {\n+            ConvertedBindingKind::Equality(..) if return_type_notation => {\n+                return Err(self.tcx().sess.emit_err(\n+                    crate::errors::ReturnTypeNotationEqualityBound { span: binding.span },\n+                ));\n+            }\n             ConvertedBindingKind::Equality(mut term) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n@@ -1267,7 +1367,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_alias(ty::Projection, projection_ty.skip_binder());\n-                self.add_bounds(param_ty, ast_bounds.iter(), bounds, candidate.bound_vars());\n+                self.add_bounds(param_ty, ast_bounds.iter(), bounds, projection_ty.bound_vars());\n             }\n         }\n         Ok(())\n@@ -1427,13 +1527,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for (base_trait_ref, span, constness) in regular_traits_refs_spans {\n             assert_eq!(constness, ty::BoundConstness::NotConst);\n \n-            for obligation in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n-                debug!(\n-                    \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n-                    obligation.predicate\n-                );\n+            for pred in traits::elaborate_trait_ref(tcx, base_trait_ref) {\n+                debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", pred);\n \n-                let bound_predicate = obligation.predicate.kind();\n+                let bound_predicate = pred.kind();\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => {\n                         let pred = bound_predicate.rebind(pred);\n@@ -1811,10 +1908,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n     {\n-        let mut matching_candidates = all_candidates()\n-            .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n-        let mut const_candidates = all_candidates()\n-            .filter(|r| self.trait_defines_associated_const_named(r.def_id(), assoc_name));\n+        let mut matching_candidates = all_candidates().filter(|r| {\n+            self.trait_defines_associated_item_named(r.def_id(), ty::AssocKind::Type, assoc_name)\n+        });\n+        let mut const_candidates = all_candidates().filter(|r| {\n+            self.trait_defines_associated_item_named(r.def_id(), ty::AssocKind::Const, assoc_name)\n+        });\n \n         let (bound, next_cand) = match (matching_candidates.next(), const_candidates.next()) {\n             (Some(bound), _) => (bound, matching_candidates.next()),"}, {"sha": "8617bca082589ad76a3c98c2d02337d33ba4c7d7", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -27,6 +27,7 @@ use rustc_middle::ty::{\n use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVENTIONS};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n+use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -474,7 +475,7 @@ fn is_enum_of_nonnullable_ptr<'tcx>(\n     let [var_one, var_two] = &adt_def.variants().raw[..] else {\n         return false;\n     };\n-    let (([], [field]) | ([field], [])) = (&var_one.fields[..], &var_two.fields[..]) else {\n+    let (([], [field]) | ([field], [])) = (&var_one.fields.raw[..], &var_two.fields.raw[..]) else {\n         return false;\n     };\n     matches!(field.ty(tcx, substs).kind(), ty::FnPtr(..) | ty::Ref(..))\n@@ -893,7 +894,7 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n             struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n             return;\n         }\n-        let e = fields[0].ty(tcx, substs);\n+        let e = fields[FieldIdx::from_u32(0)].ty(tcx, substs);\n         if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n             struct_span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\")\n                 .span_label(sp, \"SIMD elements must have the same type\")"}, {"sha": "2d509a114ad2e2272108700e5d8bf4aa81d2a0a5", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 51, "deletions": 57, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -330,7 +330,6 @@ fn compare_method_predicate_entailment<'tcx>(\n     // lifetime parameters.\n     let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n@@ -727,7 +726,6 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n     // lifetime parameters.\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(infcx),\n         infcx.implied_bounds_tys(param_env, impl_m_def_id, wf_tys),\n     );\n     infcx\n@@ -1876,14 +1874,17 @@ pub(super) fn check_type_bounds<'tcx>(\n     impl_ty: ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n+    let param_env = tcx.param_env(impl_ty.def_id);\n+    let container_id = impl_ty.container_id(tcx);\n     // Given\n     //\n     // impl<A, B> Foo<u32> for (A, B) {\n-    //     type Bar<C> =...\n+    //     type Bar<C> = Wrapper<A, B, C>\n     // }\n     //\n     // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>`\n-    // - `impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n+    // - `normalize_impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n+    // - `normalize_impl_ty` would be `Wrapper<A, B, ^0.0>`\n     // - `rebased_substs` would be `[(A, B), u32, ^0.0]`, combining the substs from\n     //    the *trait* with the generic associated type parameters (as bound vars).\n     //\n@@ -1912,56 +1913,46 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Member<C: Eq> = .... That type would fail a well-formedness check that we ought to be doing\n     // elsewhere, which would check that any <T as Family>::Member<X> meets the bounds declared in\n     // the trait (notably, that X: Eq and T: Family).\n-    let defs: &ty::Generics = tcx.generics_of(impl_ty.def_id);\n-    let mut substs = smallvec::SmallVec::with_capacity(defs.count());\n-    if let Some(def_id) = defs.parent {\n-        let parent_defs = tcx.generics_of(def_id);\n-        InternalSubsts::fill_item(&mut substs, tcx, parent_defs, &mut |param, _| {\n-            tcx.mk_param_from_def(param)\n-        });\n-    }\n     let mut bound_vars: smallvec::SmallVec<[ty::BoundVariableKind; 8]> =\n-        smallvec::SmallVec::with_capacity(defs.count());\n-    InternalSubsts::fill_single(&mut substs, defs, &mut |param, _| match param.kind {\n-        GenericParamDefKind::Type { .. } => {\n-            let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n-            let bound_var = ty::BoundVariableKind::Ty(kind);\n-            bound_vars.push(bound_var);\n-            tcx.mk_bound(\n-                ty::INNERMOST,\n-                ty::BoundTy { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            )\n-            .into()\n-        }\n-        GenericParamDefKind::Lifetime => {\n-            let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n-            let bound_var = ty::BoundVariableKind::Region(kind);\n-            bound_vars.push(bound_var);\n-            tcx.mk_re_late_bound(\n-                ty::INNERMOST,\n-                ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n-            )\n-            .into()\n-        }\n-        GenericParamDefKind::Const { .. } => {\n-            let bound_var = ty::BoundVariableKind::Const;\n-            bound_vars.push(bound_var);\n-            tcx.mk_const(\n-                ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_usize(bound_vars.len() - 1)),\n-                tcx.type_of(param.def_id).subst_identity(),\n-            )\n-            .into()\n-        }\n-    });\n-    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n-    let impl_ty_substs = tcx.mk_substs(&substs);\n-    let container_id = impl_ty.container_id(tcx);\n-\n-    let rebased_substs = impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n-    let impl_ty_value = tcx.type_of(impl_ty.def_id).subst_identity();\n-\n-    let param_env = tcx.param_env(impl_ty.def_id);\n-\n+        smallvec::SmallVec::with_capacity(tcx.generics_of(impl_ty.def_id).params.len());\n+    // Extend the impl's identity substs with late-bound GAT vars\n+    let normalize_impl_ty_substs = ty::InternalSubsts::identity_for_item(tcx, container_id)\n+        .extend_to(tcx, impl_ty.def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Type { .. } => {\n+                let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n+                let bound_var = ty::BoundVariableKind::Ty(kind);\n+                bound_vars.push(bound_var);\n+                tcx.mk_bound(\n+                    ty::INNERMOST,\n+                    ty::BoundTy { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n+                )\n+                .into()\n+            }\n+            GenericParamDefKind::Lifetime => {\n+                let kind = ty::BoundRegionKind::BrNamed(param.def_id, param.name);\n+                let bound_var = ty::BoundVariableKind::Region(kind);\n+                bound_vars.push(bound_var);\n+                tcx.mk_re_late_bound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind },\n+                )\n+                .into()\n+            }\n+            GenericParamDefKind::Const { .. } => {\n+                let bound_var = ty::BoundVariableKind::Const;\n+                bound_vars.push(bound_var);\n+                tcx.mk_const(\n+                    ty::ConstKind::Bound(\n+                        ty::INNERMOST,\n+                        ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    ),\n+                    tcx.type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n+                )\n+                .into()\n+            }\n+        });\n     // When checking something like\n     //\n     // trait X { type Y: PartialEq<<Self as X>::Y> }\n@@ -1971,9 +1962,13 @@ pub(super) fn check_type_bounds<'tcx>(\n     // we want <T as X>::Y to normalize to S. This is valid because we are\n     // checking the default value specifically here. Add this equality to the\n     // ParamEnv for normalization specifically.\n+    let normalize_impl_ty = tcx.type_of(impl_ty.def_id).subst(tcx, normalize_impl_ty_substs);\n+    let rebased_substs =\n+        normalize_impl_ty_substs.rebase_onto(tcx, container_id, impl_trait_ref.substs);\n+    let bound_vars = tcx.mk_bound_variable_kinds(&bound_vars);\n     let normalize_param_env = {\n         let mut predicates = param_env.caller_bounds().iter().collect::<Vec<_>>();\n-        match impl_ty_value.kind() {\n+        match normalize_impl_ty.kind() {\n             ty::Alias(ty::Projection, proj)\n                 if proj.def_id == trait_ty.def_id && proj.substs == rebased_substs =>\n             {\n@@ -1987,7 +1982,7 @@ pub(super) fn check_type_bounds<'tcx>(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {\n                         projection_ty: tcx.mk_alias_ty(trait_ty.def_id, rebased_substs),\n-                        term: impl_ty_value.into(),\n+                        term: normalize_impl_ty.into(),\n                     },\n                     bound_vars,\n                 )\n@@ -2068,8 +2063,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     // Finally, resolve all regions. This catches wily misuses of\n     // lifetime parameters.\n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl_ty_def_id, assumed_wf_types);\n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(&infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     infcx.err_ctxt().check_region_obligations_and_report_errors(\n         impl_ty.def_id.expect_local(),"}, {"sha": "0d482b53afef8806d4b702ed2188326d0297f65c", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitableE\n use rustc_session::lint;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{Symbol, DUMMY_SP};\n+use rustc_target::abi::FieldIdx;\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n \n pub struct InlineAsmCtxt<'a, 'tcx> {\n@@ -82,7 +83,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n             }\n             ty::Adt(adt, substs) if adt.repr().simd() => {\n                 let fields = &adt.non_enum_variant().fields;\n-                let elem_ty = fields[0].ty(self.tcx, substs);\n+                let elem_ty = fields[FieldIdx::from_u32(0)].ty(self.tcx, substs);\n                 match elem_ty.kind() {\n                     ty::Never | ty::Error(_) => return None,\n                     ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {"}, {"sha": "24cc58ee3449cab723ad5d74c859e234e5691843", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -114,8 +114,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n         return;\n     }\n \n-    let outlives_environment =\n-        OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_environment = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n \n     let _ = infcx\n         .err_ctxt()\n@@ -675,7 +674,6 @@ fn resolve_regions_with_wf_tys<'tcx>(\n     let infcx = tcx.infer_ctxt().build();\n     let outlives_environment = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n         infcx.implied_bounds_tys(param_env, id, wf_tys.clone()),\n     );\n     let region_bound_pairs = outlives_environment.region_bound_pairs();\n@@ -1032,7 +1030,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             // intermediate types must be sized.\n             let needs_drop_copy = || {\n                 packed && {\n-                    let ty = tcx.type_of(variant.fields.last().unwrap().did).subst_identity();\n+                    let ty = tcx.type_of(variant.fields.raw.last().unwrap().did).subst_identity();\n                     let ty = tcx.erase_regions(ty);\n                     if ty.needs_infer() {\n                         tcx.sess\n@@ -1048,7 +1046,7 @@ fn check_type_defn<'tcx>(tcx: TyCtxt<'tcx>, item: &hir::Item<'tcx>, all_sized: b\n             let all_sized = all_sized || variant.fields.is_empty() || needs_drop_copy();\n             let unsized_len = if all_sized { 0 } else { 1 };\n             for (idx, field) in\n-                variant.fields[..variant.fields.len() - unsized_len].iter().enumerate()\n+                variant.fields.raw[..variant.fields.len() - unsized_len].iter().enumerate()\n             {\n                 let last = idx == variant.fields.len() - 1;\n                 let field_id = field.did.expect_local();\n@@ -1544,42 +1542,81 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     span: Span,\n ) {\n     let tcx = wfcx.tcx();\n-    if let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id())\n-        && assoc_item.container == ty::AssocItemContainer::TraitContainer\n-    {\n-        // FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): Even with the new lowering\n-        // strategy, we can't just call `check_associated_item` on the new RPITITs,\n-        // because tests like `tests/ui/async-await/in-trait/implied-bounds.rs` will fail.\n-        // That's because we need to check that the bounds of the RPITIT hold using\n-        // the special substs that we create during opaque type lowering, otherwise we're\n-        // getting a bunch of early bound and free regions mixed up... Haven't looked too\n-        // deep into this, though.\n-        for arg in fn_output.walk() {\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                // RPITITs are always eagerly normalized into opaques, so always look for an\n-                // opaque here.\n-                && let ty::Alias(ty::Opaque, opaque_ty) = ty.kind()\n-                && let Some(opaque_def_id) = opaque_ty.def_id.as_local()\n-                && let opaque = tcx.hir().expect_item(opaque_def_id).expect_opaque_ty()\n-                && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n-                && source == fn_def_id\n+    let Some(assoc_item) = tcx.opt_associated_item(fn_def_id.to_def_id()) else {\n+        return;\n+    };\n+    if assoc_item.container != ty::AssocItemContainer::TraitContainer {\n+        return;\n+    }\n+    fn_output.visit_with(&mut ImplTraitInTraitFinder {\n+        wfcx,\n+        fn_def_id,\n+        depth: ty::INNERMOST,\n+        seen: FxHashSet::default(),\n+    });\n+}\n+\n+// FIXME(-Zlower-impl-trait-in-trait-to-assoc-ty): Even with the new lowering\n+// strategy, we can't just call `check_associated_item` on the new RPITITs,\n+// because tests like `tests/ui/async-await/in-trait/implied-bounds.rs` will fail.\n+// That's because we need to check that the bounds of the RPITIT hold using\n+// the special substs that we create during opaque type lowering, otherwise we're\n+// getting a bunch of early bound and free regions mixed up... Haven't looked too\n+// deep into this, though.\n+struct ImplTraitInTraitFinder<'a, 'tcx> {\n+    wfcx: &'a WfCheckingCtxt<'a, 'tcx>,\n+    fn_def_id: LocalDefId,\n+    depth: ty::DebruijnIndex,\n+    seen: FxHashSet<DefId>,\n+}\n+impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n+    type BreakTy = !;\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<!> {\n+        let tcx = self.wfcx.tcx();\n+        if let ty::Alias(ty::Opaque, unshifted_opaque_ty) = *ty.kind()\n+            && self.seen.insert(unshifted_opaque_ty.def_id)\n+            && let Some(opaque_def_id) = unshifted_opaque_ty.def_id.as_local()\n+            && let opaque = tcx.hir().expect_item(opaque_def_id).expect_opaque_ty()\n+            && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n+            && source == self.fn_def_id\n+        {\n+            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, depth| {\n+                if let ty::ReLateBound(index, bv) = re.kind() {\n+                    if depth != ty::INNERMOST {\n+                        return tcx.mk_re_error_with_message(\n+                            DUMMY_SP,\n+                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n+                        );\n+                    }\n+                    tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n+                } else {\n+                    re\n+                }\n+            });\n+            for (bound, bound_span) in tcx\n+                .bound_explicit_item_bounds(opaque_ty.def_id)\n+                .subst_iter_copied(tcx, opaque_ty.substs)\n             {\n-                let span = tcx.def_span(opaque_ty.def_id);\n-                let bounds = wfcx.tcx().explicit_item_bounds(opaque_ty.def_id);\n-                let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-                    let bound = ty::EarlyBinder(bound).subst(tcx, opaque_ty.substs);\n-                    let normalized_bound = wfcx.normalize(span, None, bound);\n-                    traits::wf::predicate_obligations(\n-                        wfcx.infcx,\n-                        wfcx.param_env,\n-                        wfcx.body_def_id,\n-                        normalized_bound,\n-                        bound_span,\n-                    )\n-                });\n-                wfcx.register_obligations(wf_obligations);\n+                let bound = self.wfcx.normalize(bound_span, None, bound);\n+                self.wfcx.register_obligations(traits::wf::predicate_obligations(\n+                    self.wfcx.infcx,\n+                    self.wfcx.param_env,\n+                    self.wfcx.body_def_id,\n+                    bound,\n+                    bound_span,\n+                ));\n+                // Set the debruijn index back to innermost here, since we already eagerly\n+                // shifted the substs that we use to generate these bounds. This is unfortunately\n+                // subtly different behavior than the `ImplTraitInTraitFinder` we use in `param_env`,\n+                // but that function doesn't actually need to normalize the bound it's visiting\n+                // (whereas we have to do so here)...\n+                let old_depth = std::mem::replace(&mut self.depth, ty::INNERMOST);\n+                bound.visit_with(self);\n+                self.depth = old_depth;\n             }\n         }\n+        ty.super_visit_with(self)\n     }\n }\n \n@@ -1873,14 +1910,13 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n         // Check elaborated bounds.\n         let implied_obligations = traits::elaborate_predicates_with_span(tcx, predicates_with_span);\n \n-        for obligation in implied_obligations {\n+        for (pred, obligation_span) in implied_obligations {\n             // We lower empty bounds like `Vec<dyn Copy>:` as\n             // `WellFormed(Vec<dyn Copy>)`, which will later get checked by\n             // regular WF checking\n-            if let ty::PredicateKind::WellFormed(..) = obligation.predicate.kind().skip_binder() {\n+            if let ty::PredicateKind::WellFormed(..) = pred.kind().skip_binder() {\n                 continue;\n             }\n-            let pred = obligation.predicate;\n             // Match the existing behavior.\n             if pred.is_global() && !pred.has_late_bound_vars() {\n                 let pred = self.normalize(span, None, pred);\n@@ -1891,8 +1927,6 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n                 if let Some(hir::Generics { predicates, .. }) =\n                     hir_node.and_then(|node| node.generics())\n                 {\n-                    let obligation_span = obligation.cause.span();\n-\n                     span = predicates\n                         .iter()\n                         // There seems to be no better way to find out which predicate we are in"}, {"sha": "ac7c68d9c4b3034b17e71423b5e8b3083c551fe6", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -486,8 +486,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: LocalDefId) -> Coe\n             // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n             let fields = &def_a.non_enum_variant().fields;\n             let diff_fields = fields\n-                .iter()\n-                .enumerate()\n+                .iter_enumerated()\n                 .filter_map(|(i, f)| {\n                     let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n "}, {"sha": "d2e45c28658bd5f1a9a84d78ff69cb7fd055c255", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -130,12 +130,9 @@ pub(super) fn item_bounds(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n ) -> ty::EarlyBinder<&'_ ty::List<ty::Predicate<'_>>> {\n-    let bounds = tcx.mk_predicates_from_iter(\n-        util::elaborate_predicates(\n-            tcx,\n-            tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n-        )\n-        .map(|obligation| obligation.predicate),\n-    );\n+    let bounds = tcx.mk_predicates_from_iter(util::elaborate_predicates(\n+        tcx,\n+        tcx.explicit_item_bounds(def_id).iter().map(|&(bound, _span)| bound),\n+    ));\n     ty::EarlyBinder(bounds)\n }"}, {"sha": "5e4f377a1e7eae72908d505fdd844d8aea6fb9ab", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1461,7 +1461,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         depth: usize,\n         generic_args: &'tcx hir::GenericArgs<'tcx>,\n     ) {\n-        if generic_args.parenthesized {\n+        if generic_args.parenthesized == hir::GenericArgsParentheses::ParenSugar {\n             self.visit_fn_like_elision(\n                 generic_args.inputs(),\n                 Some(generic_args.bindings[0].ty()),\n@@ -1640,7 +1640,59 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 },\n                 s: self.scope,\n             };\n-            if let Some(type_def_id) = type_def_id {\n+            // If the binding is parenthesized, then this must be `feature(return_type_notation)`.\n+            // In that case, introduce a binder over all of the function's early and late bound vars.\n+            //\n+            // For example, given\n+            // ```\n+            // trait Foo {\n+            //     async fn x<'r, T>();\n+            // }\n+            // ```\n+            // and a bound that looks like:\n+            //    `for<'a> T::Trait<'a, x(): for<'b> Other<'b>>`\n+            // this is going to expand to something like:\n+            //    `for<'a> for<'r, T> <T as Trait<'a>>::x::<'r, T>::{opaque#0}: for<'b> Other<'b>`.\n+            if binding.gen_args.parenthesized == hir::GenericArgsParentheses::ReturnTypeNotation {\n+                let bound_vars = if let Some(type_def_id) = type_def_id\n+                    && self.tcx.def_kind(type_def_id) == DefKind::Trait\n+                    // FIXME(return_type_notation): We could bound supertrait methods.\n+                    && let Some(assoc_fn) = self\n+                        .tcx\n+                        .associated_items(type_def_id)\n+                        .find_by_name_and_kind(self.tcx, binding.ident, ty::AssocKind::Fn, type_def_id)\n+                {\n+                    self.tcx\n+                        .generics_of(assoc_fn.def_id)\n+                        .params\n+                        .iter()\n+                        .map(|param| match param.kind {\n+                            ty::GenericParamDefKind::Lifetime => ty::BoundVariableKind::Region(\n+                                ty::BoundRegionKind::BrNamed(param.def_id, param.name),\n+                            ),\n+                            ty::GenericParamDefKind::Type { .. } => ty::BoundVariableKind::Ty(\n+                                ty::BoundTyKind::Param(param.def_id, param.name),\n+                            ),\n+                            ty::GenericParamDefKind::Const { .. } => ty::BoundVariableKind::Const,\n+                        })\n+                        .chain(self.tcx.fn_sig(assoc_fn.def_id).subst_identity().bound_vars())\n+                        .collect()\n+                } else {\n+                    self.tcx.sess.delay_span_bug(\n+                        binding.ident.span,\n+                        \"bad return type notation here\",\n+                    );\n+                    vec![]\n+                };\n+                self.with(scope, |this| {\n+                    let scope = Scope::Supertrait { bound_vars, s: this.scope };\n+                    this.with(scope, |this| {\n+                        let (bound_vars, _) = this.poly_trait_ref_binder_info();\n+                        this.record_late_bound_vars(binding.hir_id, bound_vars);\n+                        this.visit_assoc_type_binding(binding)\n+                    });\n+                });\n+            } else if let Some(type_def_id) = type_def_id {\n                 let bound_vars =\n                     BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n                 self.with(scope, |this| {"}, {"sha": "c71ce9a0bc7cd388b4cd4b9d5bc179804cb75997", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -471,6 +471,18 @@ pub(crate) struct InvalidUnionField {\n     pub note: (),\n }\n \n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_return_type_notation_on_non_rpitit)]\n+pub(crate) struct ReturnTypeNotationOnNonRpitit<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    #[label]\n+    pub fn_span: Option<Span>,\n+    #[note]\n+    pub note: (),\n+}\n+\n #[derive(Subdiagnostic)]\n #[multipart_suggestion(hir_analysis_invalid_union_field_sugg, applicability = \"machine-applicable\")]\n pub(crate) struct InvalidUnionFieldSuggestion {\n@@ -479,3 +491,19 @@ pub(crate) struct InvalidUnionFieldSuggestion {\n     #[suggestion_part(code = \">\")]\n     pub hi: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_return_type_notation_equality_bound)]\n+pub(crate) struct ReturnTypeNotationEqualityBound {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_return_type_notation_missing_method)]\n+pub(crate) struct ReturnTypeNotationMissingMethod {\n+    #[primary_span]\n+    pub span: Span,\n+    pub trait_name: Symbol,\n+    pub assoc_name: Symbol,\n+}"}, {"sha": "b5bae5788f6b2d825b5b00cb4b746a1e09654924", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -179,7 +179,7 @@ fn get_impl_substs(\n     }\n \n     let implied_bounds = infcx.implied_bounds_tys(param_env, impl1_def_id, assumed_wf_types);\n-    let outlives_env = OutlivesEnvironment::with_bounds(param_env, Some(infcx), implied_bounds);\n+    let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n     let _ =\n         infcx.err_ctxt().check_region_obligations_and_report_errors(impl1_def_id, &outlives_env);\n     let Ok(impl2_substs) = infcx.fully_resolve(impl2_substs) else {\n@@ -318,16 +318,8 @@ fn check_predicates<'tcx>(\n     span: Span,\n ) {\n     let instantiated = tcx.predicates_of(impl1_def_id).instantiate(tcx, impl1_substs);\n-    let impl1_predicates: Vec<_> = traits::elaborate_predicates_with_span(\n-        tcx,\n-        std::iter::zip(\n-            instantiated.predicates,\n-            // Don't drop predicates (unsound!) because `spans` is too short\n-            instantiated.spans.into_iter().chain(std::iter::repeat(span)),\n-        ),\n-    )\n-    .map(|obligation| (obligation.predicate, obligation.cause.span))\n-    .collect();\n+    let impl1_predicates: Vec<_> =\n+        traits::elaborate_predicates_with_span(tcx, instantiated.into_iter()).collect();\n \n     let mut impl2_predicates = if impl2_node.is_from_trait() {\n         // Always applicable traits have to be always applicable without any\n@@ -341,7 +333,6 @@ fn check_predicates<'tcx>(\n                 .predicates\n                 .into_iter(),\n         )\n-        .map(|obligation| obligation.predicate)\n         .collect()\n     };\n     debug!(?impl1_predicates, ?impl2_predicates);\n@@ -361,12 +352,16 @@ fn check_predicates<'tcx>(\n     // which is sound because we forbid impls like the following\n     //\n     // impl<D: Debug> AlwaysApplicable for D { }\n-    let always_applicable_traits = impl1_predicates.iter().copied().filter(|&(predicate, _)| {\n-        matches!(\n-            trait_predicate_kind(tcx, predicate),\n-            Some(TraitSpecializationKind::AlwaysApplicable)\n-        )\n-    });\n+    let always_applicable_traits = impl1_predicates\n+        .iter()\n+        .copied()\n+        .filter(|&(predicate, _)| {\n+            matches!(\n+                trait_predicate_kind(tcx, predicate),\n+                Some(TraitSpecializationKind::AlwaysApplicable)\n+            )\n+        })\n+        .map(|(pred, _span)| pred);\n \n     // Include the well-formed predicates of the type parameters of the impl.\n     for arg in tcx.impl_trait_ref(impl1_def_id).unwrap().subst_identity().substs {\n@@ -380,10 +375,7 @@ fn check_predicates<'tcx>(\n             traits::elaborate_obligations(tcx, obligations).map(|obligation| obligation.predicate),\n         )\n     }\n-    impl2_predicates.extend(\n-        traits::elaborate_predicates_with_span(tcx, always_applicable_traits)\n-            .map(|obligation| obligation.predicate),\n-    );\n+    impl2_predicates.extend(traits::elaborate_predicates(tcx, always_applicable_traits));\n \n     for (predicate, span) in impl1_predicates {\n         if !impl2_predicates.iter().any(|pred2| trait_predicates_eq(tcx, predicate, *pred2, span)) {"}, {"sha": "2a9025d60aba7a47e87dc82a855f440a7ed47727", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -67,7 +67,7 @@ This API is completely unstable and subject to change.\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(slice_partition_dedup)]\n #![feature(try_blocks)]\n #![feature(is_some_and)]"}, {"sha": "8f4d81ec3a935a13128d70597081a5938be46b15", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -565,7 +565,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     /// type Map = HashMap<String>;\n     /// ```\n     fn suggest_adding_args(&self, err: &mut Diagnostic) {\n-        if self.gen_args.parenthesized {\n+        if self.gen_args.parenthesized != hir::GenericArgsParentheses::No {\n             return;\n         }\n \n@@ -962,7 +962,11 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n \n             let msg = format!(\n                 \"remove these {}generics\",\n-                if self.gen_args.parenthesized { \"parenthetical \" } else { \"\" },\n+                if self.gen_args.parenthesized == hir::GenericArgsParentheses::ParenSugar {\n+                    \"parenthetical \"\n+                } else {\n+                    \"\"\n+                },\n             );\n \n             err.span_suggestion(span, &msg, \"\", Applicability::MaybeIncorrect);"}, {"sha": "4f27c01fad2c9d2d3794f18bc2126fbf9c4529e7", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1652,61 +1652,65 @@ impl<'a> State<'a> {\n         generic_args: &hir::GenericArgs<'_>,\n         colons_before_params: bool,\n     ) {\n-        if generic_args.parenthesized {\n-            self.word(\"(\");\n-            self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(ty));\n-            self.word(\")\");\n+        match generic_args.parenthesized {\n+            hir::GenericArgsParentheses::No => {\n+                let start = if colons_before_params { \"::<\" } else { \"<\" };\n+                let empty = Cell::new(true);\n+                let start_or_comma = |this: &mut Self| {\n+                    if empty.get() {\n+                        empty.set(false);\n+                        this.word(start)\n+                    } else {\n+                        this.word_space(\",\")\n+                    }\n+                };\n+\n+                let mut nonelided_generic_args: bool = false;\n+                let elide_lifetimes = generic_args.args.iter().all(|arg| match arg {\n+                    GenericArg::Lifetime(lt) if lt.is_elided() => true,\n+                    GenericArg::Lifetime(_) => {\n+                        nonelided_generic_args = true;\n+                        false\n+                    }\n+                    _ => {\n+                        nonelided_generic_args = true;\n+                        true\n+                    }\n+                });\n \n-            self.space_if_not_bol();\n-            self.word_space(\"->\");\n-            self.print_type(generic_args.bindings[0].ty());\n-        } else {\n-            let start = if colons_before_params { \"::<\" } else { \"<\" };\n-            let empty = Cell::new(true);\n-            let start_or_comma = |this: &mut Self| {\n-                if empty.get() {\n-                    empty.set(false);\n-                    this.word(start)\n-                } else {\n-                    this.word_space(\",\")\n+                if nonelided_generic_args {\n+                    start_or_comma(self);\n+                    self.commasep(Inconsistent, generic_args.args, |s, generic_arg| {\n+                        match generic_arg {\n+                            GenericArg::Lifetime(lt) if !elide_lifetimes => s.print_lifetime(lt),\n+                            GenericArg::Lifetime(_) => {}\n+                            GenericArg::Type(ty) => s.print_type(ty),\n+                            GenericArg::Const(ct) => s.print_anon_const(&ct.value),\n+                            GenericArg::Infer(_inf) => s.word(\"_\"),\n+                        }\n+                    });\n                 }\n-            };\n \n-            let mut nonelided_generic_args: bool = false;\n-            let elide_lifetimes = generic_args.args.iter().all(|arg| match arg {\n-                GenericArg::Lifetime(lt) if lt.is_elided() => true,\n-                GenericArg::Lifetime(_) => {\n-                    nonelided_generic_args = true;\n-                    false\n+                for binding in generic_args.bindings {\n+                    start_or_comma(self);\n+                    self.print_type_binding(binding);\n                 }\n-                _ => {\n-                    nonelided_generic_args = true;\n-                    true\n-                }\n-            });\n-\n-            if nonelided_generic_args {\n-                start_or_comma(self);\n-                self.commasep(\n-                    Inconsistent,\n-                    generic_args.args,\n-                    |s, generic_arg| match generic_arg {\n-                        GenericArg::Lifetime(lt) if !elide_lifetimes => s.print_lifetime(lt),\n-                        GenericArg::Lifetime(_) => {}\n-                        GenericArg::Type(ty) => s.print_type(ty),\n-                        GenericArg::Const(ct) => s.print_anon_const(&ct.value),\n-                        GenericArg::Infer(_inf) => s.word(\"_\"),\n-                    },\n-                );\n-            }\n \n-            for binding in generic_args.bindings {\n-                start_or_comma(self);\n-                self.print_type_binding(binding);\n+                if !empty.get() {\n+                    self.word(\">\")\n+                }\n             }\n+            hir::GenericArgsParentheses::ParenSugar => {\n+                self.word(\"(\");\n+                self.commasep(Inconsistent, generic_args.inputs(), |s, ty| s.print_type(ty));\n+                self.word(\")\");\n \n-            if !empty.get() {\n-                self.word(\">\")\n+                self.space_if_not_bol();\n+                self.word_space(\"->\");\n+                self.print_type(generic_args.bindings[0].ty());\n+            }\n+            hir::GenericArgsParentheses::ReturnTypeNotation => {\n+                self.word(\"(..)\");\n             }\n         }\n     }"}, {"sha": "1481c038cfebb6a2713bef6f16e680b6c7e5c81d", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -103,13 +103,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Ok(match *t.kind() {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n             ty::Dynamic(ref tty, _, ty::Dyn) => Some(PointerKind::VTable(tty.principal_def_id())),\n-            ty::Adt(def, substs) if def.is_struct() => match def.non_enum_variant().fields.last() {\n-                None => Some(PointerKind::Thin),\n-                Some(f) => {\n-                    let field_ty = self.field_ty(span, f, substs);\n-                    self.pointer_kind(field_ty, span)?\n+            ty::Adt(def, substs) if def.is_struct() => {\n+                match def.non_enum_variant().fields.raw.last() {\n+                    None => Some(PointerKind::Thin),\n+                    Some(f) => {\n+                        let field_ty = self.field_ty(span, f, substs);\n+                        self.pointer_kind(field_ty, span)?\n+                    }\n                 }\n-            },\n+            }\n             ty::Tuple(fields) => match fields.last() {\n                 None => Some(PointerKind::Thin),\n                 Some(&f) => self.pointer_kind(f, span)?,"}, {"sha": "47a8b0801664fec04f254dee2816e65a6146b67f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -204,25 +204,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_sig = None;\n         let mut expected_kind = None;\n \n-        for obligation in traits::elaborate_predicates_with_span(\n+        for (pred, span) in traits::elaborate_predicates_with_span(\n             self.tcx,\n             // Reverse the obligations here, since `elaborate_*` uses a stack,\n             // and we want to keep inference generally in the same order of\n             // the registered obligations.\n             predicates.rev(),\n         ) {\n-            debug!(?obligation.predicate);\n-            let bound_predicate = obligation.predicate.kind();\n+            debug!(?pred);\n+            let bound_predicate = pred.kind();\n \n             // Given a Projection predicate, we can potentially infer\n             // the complete signature.\n             if expected_sig.is_none()\n                 && let ty::PredicateKind::Clause(ty::Clause::Projection(proj_predicate)) = bound_predicate.skip_binder()\n             {\n                 let inferred_sig = self.normalize(\n-                    obligation.cause.span,\n+                    span,\n                     self.deduce_sig_from_projection(\n-                    Some(obligation.cause.span),\n+                    Some(span),\n                         bound_predicate.rebind(proj_predicate),\n                     ),\n                 );"}, {"sha": "30d307948a6ca8c835798acc9aea52a0e42eda1b", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut, TypeVisitableExt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n+use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n@@ -850,7 +851,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     variant.fields.len() == 1\n                 })\n                 .filter_map(|variant| {\n-                    let sole_field = &variant.fields[0];\n+                    let sole_field = &variant.fields[FieldIdx::from_u32(0)];\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible ="}, {"sha": "c17aae22ba54059859ae7833b9c449e4097cba88", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -50,6 +50,7 @@ use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n@@ -1561,8 +1562,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut remaining_fields = variant\n             .fields\n-            .iter()\n-            .enumerate()\n+            .iter_enumerated()\n             .map(|(i, field)| (field.ident(tcx).normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n@@ -1815,7 +1815,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         adt_ty: Ty<'tcx>,\n         span: Span,\n-        remaining_fields: FxHashMap<Ident, (usize, &ty::FieldDef)>,\n+        remaining_fields: FxHashMap<Ident, (FieldIdx, &ty::FieldDef)>,\n         variant: &'tcx ty::VariantDef,\n         ast_fields: &'tcx [hir::ExprField<'tcx>],\n         substs: SubstsRef<'tcx>,\n@@ -2209,11 +2209,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did(), body_hir_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields\n-                        .iter()\n-                        .position(|f| f.ident(self.tcx).normalize_to_macros_2_0() == ident)\n+                    if let Some((index, field)) = fields\n+                        .iter_enumerated()\n+                        .find(|(_, f)| f.ident(self.tcx).normalize_to_macros_2_0() == ident)\n                     {\n-                        let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case\n                         // of error recovery.\n@@ -2230,15 +2229,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 ty::Tuple(tys) => {\n-                    let fstr = field.as_str();\n-                    if let Ok(index) = fstr.parse::<usize>() {\n-                        if fstr == index.to_string() {\n+                    if let Ok(index) = field.as_str().parse::<usize>() {\n+                        if field.name == sym::integer(index) {\n                             if let Some(&field_ty) = tys.get(index) {\n                                 let adjustments = self.adjust_steps(&autoderef);\n                                 self.apply_adjustments(base, adjustments);\n                                 self.register_predicates(autoderef.into_obligations());\n \n-                                self.write_field_index(expr.hir_id, index);\n+                                self.write_field_index(expr.hir_id, FieldIdx::from_usize(index));\n                                 return field_ty;\n                             }\n                         }"}, {"sha": "ee1c6fbfd650fdee648f196a5b38c51fd8083894", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -14,12 +14,11 @@ use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n-use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, adjustment, AdtKind, Ty, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::FIRST_VARIANT;\n use ty::BorrowKind::ImmBorrow;\n \n use crate::mem_categorization as mc;\n@@ -540,7 +539,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         match with_place.place.ty().kind() {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n-                for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n+                for (f_index, with_field) in adt.non_enum_variant().fields.iter_enumerated() {\n                     let is_mentioned = fields\n                         .iter()\n                         .any(|f| self.mc.typeck_results.opt_field_index(f.hir_id) == Some(f_index));\n@@ -549,7 +548,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             &*with_expr,\n                             with_place.clone(),\n                             with_field.ty(self.tcx(), substs),\n-                            ProjectionKind::Field(f_index as u32, VariantIdx::new(0)),\n+                            ProjectionKind::Field(f_index, FIRST_VARIANT),\n                         );\n                         self.delegate_consume(&field_place, field_place.hir_id);\n                     }\n@@ -560,7 +559,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // struct; however, when EUV is run during typeck, it\n                 // may not. This will generate an error earlier in typeck,\n                 // so we can just ignore it.\n-                if !self.tcx().sess.has_errors().is_some() {\n+                if self.tcx().sess.has_errors().is_none() {\n                     span_bug!(with_expr.span, \"with expression doesn't evaluate to a struct\");\n                 }\n             }"}, {"sha": "fdf178c3ea79ec69ea46a24f6fc567dcf48b8015", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -33,6 +33,7 @@ use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n+use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, NormalizeExt, ObligationCauseCode, ObligationCtxt};\n \n@@ -147,7 +148,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_field_index(&self, hir_id: hir::HirId, index: usize) {\n+    pub fn write_field_index(&self, hir_id: hir::HirId, index: FieldIdx) {\n         self.typeck_results.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n@@ -1416,41 +1417,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) {\n         let param_env = self.param_env;\n \n-        let remap = match self.tcx.def_kind(def_id) {\n-            // Associated consts have `Self: ~const Trait` bounds that should be satisfiable when\n-            // `Self: Trait` is satisfied because it does not matter whether the impl is `const`.\n-            // Therefore we have to remap the param env here to be non-const.\n-            hir::def::DefKind::AssocConst => true,\n-            hir::def::DefKind::AssocFn\n-                if self.tcx.def_kind(self.tcx.parent(def_id)) == hir::def::DefKind::Trait =>\n-            {\n-                // N.B.: All callsites to this function involve checking a path expression.\n-                //\n-                // When instantiating a trait method as a function item, it does not actually matter whether\n-                // the trait is `const` or not, or whether `where T: ~const Tr` needs to be satisfied as\n-                // `const`. If we were to introduce instantiating trait methods as `const fn`s, we would\n-                // check that after this, either via a bound `where F: ~const FnOnce` or when coercing to a\n-                // `const fn` pointer.\n-                //\n-                // FIXME(fee1-dead) FIXME(const_trait_impl): update this doc when trait methods can satisfy\n-                // `~const FnOnce` or can be coerced to `const fn` pointer.\n-                true\n-            }\n-            _ => false,\n-        };\n         let bounds = self.instantiate_bounds(span, def_id, &substs);\n \n-        for mut obligation in traits::predicates_for_generics(\n+        for obligation in traits::predicates_for_generics(\n             |idx, predicate_span| {\n                 traits::ObligationCause::new(span, self.body_id, code(idx, predicate_span))\n             },\n             param_env,\n             bounds,\n         ) {\n-            if remap {\n-                obligation = obligation.without_const(self.tcx);\n-            }\n-            self.register_predicate(obligation);\n+            // N.B. We are remapping all predicates to non-const since we don't know if we just\n+            // want them as function pointers or we are calling them from a const-context. The\n+            // actual checking will occur in `rustc_const_eval::transform::check_consts`.\n+            self.register_predicate(obligation.without_const(self.tcx));\n         }\n     }\n "}, {"sha": "7534e432f1198aa411cd581da42afe9813a64eba", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -310,7 +310,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+                find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -356,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .filter(|(_, ty)| find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n@@ -579,8 +579,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Find out which of `in_ty_elements` refer to `param`.\n             // FIXME: It may be better to take the first if there are multiple,\n             // just so that the error points to a smaller expression.\n-            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n-                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            let Some((drill_expr, drill_ty)) = is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                find_param_in_ty((*in_ty_elem).into(), param)\n             })) else {\n                 // The param is not mentioned, or it is mentioned in multiple indexes.\n                 return Err(expr);\n@@ -628,10 +628,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -751,10 +751,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // We need to know which of the generic parameters mentions our target param.\n             // We expect that at least one of them does, since it is expected to be mentioned.\n             let Some((drill_generic_index, generic_argument_type)) =\n-                Self::is_iterator_singleton(\n+                is_iterator_singleton(\n                     in_ty_adt_generic_args.iter().enumerate().filter(\n                         |(_index, in_ty_generic)| {\n-                            Self::find_param_in_ty(*in_ty_generic, param)\n+                            find_param_in_ty(*in_ty_generic, param)\n                         },\n                     ),\n                 ) else {\n@@ -793,14 +793,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //     outer contextual information.\n \n             // (1) Find the (unique) field index which mentions the type in our constraint:\n-            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+            let Some((field_index, field_type)) = is_iterator_singleton(\n                 in_ty_adt\n                     .variant_with_id(variant_def_id)\n                     .fields\n                     .iter()\n                     .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n                     .enumerate()\n-                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+                    .filter(|(_index, field_type)| find_param_in_ty((*field_type).into(), param))\n             ) else {\n                 return Err(expr);\n             };\n@@ -833,20 +833,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         Err(expr)\n     }\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n-    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n-    pub fn find_param_in_ty(\n-        ty: ty::GenericArg<'tcx>,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-    ) -> bool {\n-        let mut walk = ty.walk();\n-        while let Some(arg) = walk.next() {\n-            if arg == param_to_point_at {\n-                return true;\n-            }\n-            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+/// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+/// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+fn find_param_in_ty<'tcx>(\n+    ty: ty::GenericArg<'tcx>,\n+    param_to_point_at: ty::GenericArg<'tcx>,\n+) -> bool {\n+    let mut walk = ty.walk();\n+    while let Some(arg) = walk.next() {\n+        if arg == param_to_point_at {\n+            return true;\n+        }\n+        if let ty::GenericArgKind::Type(ty) = arg.unpack()\n                 && let ty::Alias(ty::Projection, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n@@ -857,16 +857,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // in some UI tests.\n                 walk.skip_current_subtree();\n             }\n-        }\n-        false\n     }\n+    false\n+}\n \n-    // FIXME: This can be made into a private, non-impl function later.\n-    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n-    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n-        match (iterator.next(), iterator.next()) {\n-            (_, Some(_)) => None,\n-            (first, _) => first,\n-        }\n+/// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+    match (iterator.next(), iterator.next()) {\n+        (_, Some(_)) => None,\n+        (first, _) => first,\n     }\n }"}, {"sha": "5fda4e191c2a003f447f0016f6659295de62a002", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -983,13 +983,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n                 .must_apply_modulo_regions()\n           {\n-              diag.span_suggestion_verbose(\n-                  expr.span.shrink_to_hi(),\n-                  \"consider using clone here\",\n-                  \".clone()\",\n-                  Applicability::MachineApplicable,\n-              );\n-              return true;\n+            let suggestion = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                Some(ident) => format!(\": {}.clone()\", ident),\n+                None => \".clone()\".to_string()\n+            };\n+\n+            diag.span_suggestion_verbose(\n+                expr.span.shrink_to_hi(),\n+                \"consider using clone here\",\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n           }\n         false\n     }\n@@ -1150,13 +1155,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return false;\n         }\n \n-        diag.span_suggestion(\n+        let suggestion = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+            Some(ident) => format!(\": {}.is_some()\", ident),\n+            None => \".is_some()\".to_string(),\n+        };\n+\n+        diag.span_suggestion_verbose(\n             expr.span.shrink_to_hi(),\n             \"use `Option::is_some` to test if the `Option` has a value\",\n-            \".is_some()\",\n+            suggestion,\n             Applicability::MachineApplicable,\n         );\n-\n         true\n     }\n "}, {"sha": "901acffe1c8c5b14b14aff970a346aa8e7403a72", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,7 +4,7 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_target::abi::{Pointer, VariantIdx};\n+use rustc_target::abi::{FieldIdx, Pointer, VariantIdx};\n \n use super::FnCtxt;\n \n@@ -28,7 +28,7 @@ fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         }\n \n         if def.variant(data_idx).fields.len() == 1 {\n-            return def.variant(data_idx).fields[0].ty(tcx, substs);\n+            return def.variant(data_idx).fields[FieldIdx::from_u32(0)].ty(tcx, substs);\n         }\n     }\n "}, {"sha": "6c861b5930a1ebe48f4605a14592d64e96df22aa", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -59,10 +59,9 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::PatKind;\n-use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n pub(crate) trait HirNode {\n@@ -331,7 +330,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     expr,\n                     base,\n                     expr_ty,\n-                    ProjectionKind::Field(field_idx as u32, VariantIdx::new(0)),\n+                    ProjectionKind::Field(field_idx, FIRST_VARIANT),\n                 ))\n             }\n \n@@ -561,7 +560,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | Res::SelfTyParam { .. }\n             | Res::SelfTyAlias { .. } => {\n                 // Structs and Unions have only have one variant.\n-                Ok(VariantIdx::new(0))\n+                Ok(FIRST_VARIANT)\n             }\n             _ => bug!(\"expected ADT path, found={:?}\", res),\n         }\n@@ -675,7 +674,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(total_fields, dots_pos) {\n                     let subpat_ty = self.pat_ty_adjusted(subpat)?;\n-                    let projection_kind = ProjectionKind::Field(i as u32, VariantIdx::new(0));\n+                    let projection_kind =\n+                        ProjectionKind::Field(FieldIdx::from_usize(i), FIRST_VARIANT);\n                     let sub_place =\n                         self.cat_projection(pat, place_with_id.clone(), subpat_ty, projection_kind);\n                     self.cat_pattern_(sub_place, subpat, op)?;\n@@ -690,7 +690,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(total_fields, dots_pos) {\n                     let subpat_ty = self.pat_ty_adjusted(subpat)?;\n-                    let projection_kind = ProjectionKind::Field(i as u32, variant_index);\n+                    let projection_kind =\n+                        ProjectionKind::Field(FieldIdx::from_usize(i), variant_index);\n                     let sub_place =\n                         self.cat_projection(pat, place_with_id.clone(), subpat_ty, projection_kind);\n                     self.cat_pattern_(sub_place, subpat, op)?;\n@@ -715,7 +716,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                         pat,\n                         place_with_id.clone(),\n                         field_ty,\n-                        ProjectionKind::Field(field_index as u32, variant_index),\n+                        ProjectionKind::Field(field_index, variant_index),\n                     );\n                     self.cat_pattern_(field_place, fp.pat, op)?;\n                 }"}, {"sha": "2762e778591eeca204e7aeed74f7ce048b0f00da", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -576,17 +576,13 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n-            .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n+            .filter_map(|pred| match pred.kind().skip_binder() {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred))\n                     if trait_pred.def_id() == sized_def_id =>\n                 {\n                     let span = predicates\n                         .iter()\n-                        .find_map(\n-                            |(p, span)| {\n-                                if p == obligation.predicate { Some(span) } else { None }\n-                            },\n-                        )\n+                        .find_map(|(p, span)| if p == pred { Some(span) } else { None })\n                         .unwrap_or(rustc_span::DUMMY_SP);\n                     Some((trait_pred, span))\n                 }"}, {"sha": "5c50619f4c3c407686e91e64ab1fd505908805d2", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -245,6 +245,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    fn suggest_missing_writer(\n+        &self,\n+        rcvr_ty: Ty<'tcx>,\n+        args: (&'tcx hir::Expr<'tcx>, &'tcx [hir::Expr<'tcx>]),\n+    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let (ty_str, _ty_file) = self.tcx.short_ty_string(rcvr_ty);\n+        let mut err =\n+            struct_span_err!(self.tcx.sess, args.0.span, E0599, \"cannot write into `{}`\", ty_str);\n+        err.span_note(\n+            args.0.span,\n+            \"must implement `io::Write`, `fmt::Write`, or have a `write_fmt` method\",\n+        );\n+        if let ExprKind::Lit(_) = args.0.kind {\n+            err.span_help(\n+                args.0.span.shrink_to_lo(),\n+                \"a writer is needed before this format string\",\n+            );\n+        };\n+\n+        err\n+    }\n+\n     pub fn report_no_match_method_error(\n         &self,\n         mut span: Span,\n@@ -323,16 +345,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0599,\n-            \"no {} named `{}` found for {} `{}` in the current scope\",\n-            item_kind,\n-            item_name,\n-            rcvr_ty.prefix_string(self.tcx),\n-            ty_str_reported,\n-        );\n+        let is_write = sugg_span.ctxt().outer_expn_data().macro_def_id.map_or(false, |def_id| {\n+            tcx.is_diagnostic_item(sym::write_macro, def_id)\n+                || tcx.is_diagnostic_item(sym::writeln_macro, def_id)\n+        }) && item_name.name == Symbol::intern(\"write_fmt\");\n+        let mut err = if is_write\n+            && let Some(args) = args\n+        {\n+            self.suggest_missing_writer(rcvr_ty, args)\n+        } else {\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0599,\n+                \"no {} named `{}` found for {} `{}` in the current scope\",\n+                item_kind,\n+                item_name,\n+                rcvr_ty.prefix_string(self.tcx),\n+                ty_str_reported,\n+            )\n+        };\n         if tcx.sess.source_map().is_multiline(sugg_span) {\n             err.span_label(sugg_span.with_hi(span.lo()), \"\");\n         }\n@@ -1783,7 +1815,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .variants()\n                     .iter()\n                     .flat_map(|variant| {\n-                        let [field] = &variant.fields[..] else { return None; };\n+                        let [field] = &variant.fields.raw[..] else { return None; };\n                         let field_ty = field.ty(tcx, substs);\n \n                         // Skip `_`, since that'll just lead to ambiguity."}, {"sha": "241535b29c5f8eb85dce1905b756f24bbc88c31a", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -19,6 +19,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, DUMMY_SP};\n+use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::traits::{ObligationCause, Pattern};\n use ty::VariantDef;\n \n@@ -238,15 +239,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Note that there are two tests to check that this remains true\n         // (`regions-reassign-{match,let}-bound-pointer.rs`).\n         //\n-        // 2. Things go horribly wrong if we use subtype. The reason for\n-        // THIS is a fairly subtle case involving bound regions. See the\n-        // `givens` field in `region_constraints`, as well as the test\n+        // 2. An outdated issue related to the old HIR borrowck. See the test\n         // `regions-relate-bound-regions-on-closures-to-inference-variables.rs`,\n-        // for details. Short version is that we must sometimes detect\n-        // relationships between specific region variables and regions\n-        // bound in a closure signature, and that detection gets thrown\n-        // off when we substitute fresh region variables here to enable\n-        // subtyping.\n     }\n \n     /// Compute the new expected type and default binding mode from the old ones\n@@ -1098,19 +1092,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 bug!(\"unexpected pattern type {:?}\", pat_ty);\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n-                let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n+                let field = &variant.fields[FieldIdx::from_usize(i)];\n+                let field_ty = self.field_ty(subpat.span, field, substs);\n                 self.check_pat(subpat, field_ty, def_bm, ti);\n \n                 self.tcx.check_stability(\n-                    variant.fields[i].did,\n+                    variant.fields[FieldIdx::from_usize(i)].did,\n                     Some(pat.hir_id),\n                     subpat.span,\n                     None,\n                 );\n             }\n         } else {\n             // Pattern has wrong number of fields.\n-            let e = self.e0023(pat.span, res, qpath, subpats, &variant.fields, expected, had_err);\n+            let e =\n+                self.e0023(pat.span, res, qpath, subpats, &variant.fields.raw, expected, had_err);\n             on_error(e);\n             return tcx.ty_error(e);\n         }\n@@ -1340,8 +1336,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Index the struct fields' types.\n         let field_map = variant\n             .fields\n-            .iter()\n-            .enumerate()\n+            .iter_enumerated()\n             .map(|(i, field)| (field.ident(self.tcx).normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n "}, {"sha": "41a6ad80b65a3ed857fc6120211f97b3ff370ba8", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -49,8 +49,7 @@ use rustc_span::{BytePos, Pos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_index::vec::Idx;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::FIRST_VARIANT;\n \n use std::iter;\n \n@@ -712,10 +711,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                unreachable!(\n-                    \"we captured two identical projections: capture1 = {:?}, capture2 = {:?}\",\n-                    capture1, capture2\n+                self.tcx.sess.delay_span_bug(\n+                    closure_span,\n+                    &format!(\n+                        \"two identical projections: ({:?}, {:?})\",\n+                        capture1.place.projections, capture2.place.projections\n+                    ),\n                 );\n+                std::cmp::Ordering::Equal\n             });\n         }\n \n@@ -1402,15 +1405,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ProjectionKind::Field(..)\n                     ))\n                 );\n-                def.variants().get(VariantIdx::new(0)).unwrap().fields.iter().enumerate().any(\n+                def.variants().get(FIRST_VARIANT).unwrap().fields.iter_enumerated().any(\n                     |(i, field)| {\n                         let paths_using_field = captured_by_move_projs\n                             .iter()\n                             .filter_map(|projs| {\n                                 if let ProjectionKind::Field(field_idx, _) =\n                                     projs.first().unwrap().kind\n                                 {\n-                                    if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                                    if field_idx == i { Some(&projs[1..]) } else { None }\n                                 } else {\n                                     unreachable!();\n                                 }\n@@ -1443,7 +1446,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .filter_map(|projs| {\n                             if let ProjectionKind::Field(field_idx, _) = projs.first().unwrap().kind\n                             {\n-                                if (field_idx as usize) == i { Some(&projs[1..]) } else { None }\n+                                if field_idx.index() == i { Some(&projs[1..]) } else { None }\n                             } else {\n                                 unreachable!();\n                             }\n@@ -1890,14 +1893,13 @@ fn restrict_capture_precision(\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         match proj.kind {\n-            ProjectionKind::Index => {\n-                // Arrays are completely captured, so we drop Index projections\n+            ProjectionKind::Index | ProjectionKind::Subslice => {\n+                // Arrays are completely captured, so we drop Index and Subslice projections\n                 truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, i);\n                 return (place, curr_mode);\n             }\n             ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n-            ProjectionKind::Subslice => {}  // We never capture this\n         }\n     }\n "}, {"sha": "b760620e3d48b0bba6d547f043ac774ecc81f5f1", "filename": "compiler/rustc_incremental/messages.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_incremental%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_incremental%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -24,7 +24,7 @@ incremental_field_associated_value_expected = associated value expected for `{$n\n incremental_no_field = no field `{$name}`\n \n incremental_assertion_auto =\n-    `except` specified DepNodes that can not be affected for \\\"{$name}\\\": \\\"{$e}\\\"\n+    `except` specified DepNodes that can not be affected for \"{$name}\": \"{$e}\"\n \n incremental_undefined_clean_dirty_assertions_item =\n     clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}"}, {"sha": "eba5b3ed882a1073db91a67782f4cf1aafbd3e9f", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,5 +1,6 @@\n use crate::vec::{Idx, IndexVec};\n use arrayvec::ArrayVec;\n+use smallvec::{smallvec, SmallVec};\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n@@ -111,7 +112,7 @@ macro_rules! bit_relations_inherent_impls {\n #[derive(Eq, PartialEq, Hash, Decodable, Encodable)]\n pub struct BitSet<T> {\n     domain_size: usize,\n-    words: Vec<Word>,\n+    words: SmallVec<[Word; 2]>,\n     marker: PhantomData<T>,\n }\n \n@@ -127,14 +128,15 @@ impl<T: Idx> BitSet<T> {\n     #[inline]\n     pub fn new_empty(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n-        BitSet { domain_size, words: vec![0; num_words], marker: PhantomData }\n+        BitSet { domain_size, words: smallvec![0; num_words], marker: PhantomData }\n     }\n \n     /// Creates a new, filled bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_filled(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n-        let mut result = BitSet { domain_size, words: vec![!0; num_words], marker: PhantomData };\n+        let mut result =\n+            BitSet { domain_size, words: smallvec![!0; num_words], marker: PhantomData };\n         result.clear_excess_bits();\n         result\n     }\n@@ -1571,7 +1573,7 @@ impl<T: Idx> From<BitSet<T>> for GrowableBitSet<T> {\n pub struct BitMatrix<R: Idx, C: Idx> {\n     num_rows: usize,\n     num_columns: usize,\n-    words: Vec<Word>,\n+    words: SmallVec<[Word; 2]>,\n     marker: PhantomData<(R, C)>,\n }\n \n@@ -1584,7 +1586,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         BitMatrix {\n             num_rows,\n             num_columns,\n-            words: vec![0; num_rows * words_per_row],\n+            words: smallvec![0; num_rows * words_per_row],\n             marker: PhantomData,\n         }\n     }"}, {"sha": "5945de2302a564e49a06e5e6c609b975913cea4d", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 207, "deletions": 73, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,11 +1,12 @@\n #[cfg(feature = \"rustc_serialize\")]\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n \n+use std::borrow::{Borrow, BorrowMut};\n use std::fmt;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n-use std::ops::{Index, IndexMut, RangeBounds};\n+use std::ops::{Deref, DerefMut, Index, IndexMut, RangeBounds};\n use std::slice;\n use std::vec;\n \n@@ -51,16 +52,41 @@ impl Idx for u32 {\n     }\n }\n \n+/// An owned contiguous collection of `T`s, indexed by `I` rather than by `usize`.\n+///\n+/// While it's possible to use `u32` or `usize` directly for `I`,\n+/// you almost certainly want to use a [`newtype_index!`]-generated type instead.\n+///\n+/// [`newtype_index!`]: ../macro.newtype_index.html\n #[derive(Clone, PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,\n     _marker: PhantomData<fn(&I)>,\n }\n \n+/// A view into contiguous `T`s, indexed by `I` rather than by `usize`.\n+///\n+/// One common pattern you'll see is code that uses [`IndexVec::from_elem`]\n+/// to create the storage needed for a particular \"universe\" (aka the set of all\n+/// the possible keys that need an associated value) then passes that working\n+/// area as `&mut IndexSlice<I, T>` to clarify that nothing will be added nor\n+/// removed during processing (and, as a bonus, to chase fewer pointers).\n+#[derive(PartialEq, Eq, Hash)]\n+#[repr(transparent)]\n+pub struct IndexSlice<I: Idx, T> {\n+    _marker: PhantomData<fn(&I)>,\n+    pub raw: [T],\n+}\n+\n // Whether `IndexVec` is `Send` depends only on the data,\n // not the phantom data.\n unsafe impl<I: Idx, T> Send for IndexVec<I, T> where T: Send {}\n \n+// Whether `IndexSlice` is `Send` depends only on the data,\n+// not the phantom data.\n+unsafe impl<I: Idx, T> Send for IndexSlice<I, T> where T: Send {}\n+\n #[cfg(feature = \"rustc_serialize\")]\n impl<S: Encoder, I: Idx, T: Encodable<S>> Encodable<S> for IndexVec<I, T> {\n     fn encode(&self, s: &mut S) {\n@@ -81,6 +107,12 @@ impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T: fmt::Debug> fmt::Debug for IndexSlice<I, T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.raw, fmt)\n+    }\n+}\n+\n impl<I: Idx, T> IndexVec<I, T> {\n     #[inline]\n     pub fn new() -> Self {\n@@ -98,7 +130,7 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn from_elem<S>(elem: T, universe: &IndexVec<I, S>) -> Self\n+    pub fn from_elem<S>(elem: T, universe: &IndexSlice<I, S>) -> Self\n     where\n         T: Clone,\n     {\n@@ -122,6 +154,16 @@ impl<I: Idx, T> IndexVec<I, T> {\n         Self::from_raw(indices.map(func).collect())\n     }\n \n+    #[inline]\n+    pub fn as_slice(&self) -> &IndexSlice<I, T> {\n+        IndexSlice::from_raw(&self.raw)\n+    }\n+\n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut IndexSlice<I, T> {\n+        IndexSlice::from_raw_mut(&mut self.raw)\n+    }\n+\n     #[inline]\n     pub fn push(&mut self, d: T) -> I {\n         let idx = I::new(self.len());\n@@ -135,32 +177,143 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn len(&self) -> usize {\n-        self.raw.len()\n+    pub fn into_iter(self) -> vec::IntoIter<T> {\n+        self.raw.into_iter()\n     }\n \n-    /// Gives the next index that will be assigned when `push` is\n-    /// called.\n     #[inline]\n-    pub fn next_index(&self) -> I {\n-        I::new(self.len())\n+    pub fn into_iter_enumerated(\n+        self,\n+    ) -> impl DoubleEndedIterator<Item = (I, T)> + ExactSizeIterator {\n+        self.raw.into_iter().enumerate().map(|(n, t)| (I::new(n), t))\n     }\n \n     #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.raw.is_empty()\n+    pub fn drain<'a, R: RangeBounds<usize>>(\n+        &'a mut self,\n+        range: R,\n+    ) -> impl Iterator<Item = T> + 'a {\n+        self.raw.drain(range)\n     }\n \n     #[inline]\n-    pub fn into_iter(self) -> vec::IntoIter<T> {\n-        self.raw.into_iter()\n+    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n+        &'a mut self,\n+        range: R,\n+    ) -> impl Iterator<Item = (I, T)> + 'a {\n+        let begin = match range.start_bound() {\n+            std::ops::Bound::Included(i) => *i,\n+            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n+            std::ops::Bound::Unbounded => 0,\n+        };\n+        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n     }\n \n     #[inline]\n-    pub fn into_iter_enumerated(\n-        self,\n-    ) -> impl DoubleEndedIterator<Item = (I, T)> + ExactSizeIterator {\n-        self.raw.into_iter().enumerate().map(|(n, t)| (I::new(n), t))\n+    pub fn shrink_to_fit(&mut self) {\n+        self.raw.shrink_to_fit()\n+    }\n+\n+    #[inline]\n+    pub fn truncate(&mut self, a: usize) {\n+        self.raw.truncate(a)\n+    }\n+\n+    pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n+        IndexVec { raw: self.raw, _marker: PhantomData }\n+    }\n+\n+    /// Grows the index vector so that it contains an entry for\n+    /// `elem`; if that is already true, then has no\n+    /// effect. Otherwise, inserts new values as needed by invoking\n+    /// `fill_value`.\n+    #[inline]\n+    pub fn ensure_contains_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n+        let min_new_len = elem.index() + 1;\n+        if self.len() < min_new_len {\n+            self.raw.resize_with(min_new_len, fill_value);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n+        let min_new_len = elem.index() + 1;\n+        self.raw.resize_with(min_new_len, fill_value);\n+    }\n+}\n+\n+impl<I: Idx, T> Deref for IndexVec<I, T> {\n+    type Target = IndexSlice<I, T>;\n+\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        self.as_slice()\n+    }\n+}\n+\n+impl<I: Idx, T> DerefMut for IndexVec<I, T> {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.as_mut_slice()\n+    }\n+}\n+\n+impl<I: Idx, T> Borrow<IndexSlice<I, T>> for IndexVec<I, T> {\n+    fn borrow(&self) -> &IndexSlice<I, T> {\n+        self\n+    }\n+}\n+\n+impl<I: Idx, T> BorrowMut<IndexSlice<I, T>> for IndexVec<I, T> {\n+    fn borrow_mut(&mut self) -> &mut IndexSlice<I, T> {\n+        self\n+    }\n+}\n+\n+impl<I: Idx, T: Clone> ToOwned for IndexSlice<I, T> {\n+    type Owned = IndexVec<I, T>;\n+\n+    fn to_owned(&self) -> IndexVec<I, T> {\n+        IndexVec::from_raw(self.raw.to_owned())\n+    }\n+\n+    fn clone_into(&self, target: &mut IndexVec<I, T>) {\n+        self.raw.clone_into(&mut target.raw)\n+    }\n+}\n+\n+impl<I: Idx, T> IndexSlice<I, T> {\n+    #[inline]\n+    pub fn from_raw(raw: &[T]) -> &Self {\n+        let ptr: *const [T] = raw;\n+        // SAFETY: `IndexSlice` is `repr(transparent)` over a normal slice\n+        unsafe { &*(ptr as *const Self) }\n+    }\n+\n+    #[inline]\n+    pub fn from_raw_mut(raw: &mut [T]) -> &mut Self {\n+        let ptr: *mut [T] = raw;\n+        // SAFETY: `IndexSlice` is `repr(transparent)` over a normal slice\n+        unsafe { &mut *(ptr as *mut Self) }\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.raw.len()\n+    }\n+\n+    /// Gives the next index that will be assigned when `push` is called.\n+    ///\n+    /// Manual bounds checks can be done using `idx < slice.next_index()`\n+    /// (as opposed to `idx.index() < slice.len()`).\n+    #[inline]\n+    pub fn next_index(&self) -> I {\n+        I::new(self.len())\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.raw.is_empty()\n     }\n \n     #[inline]\n@@ -195,46 +348,15 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn drain<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n-        range: R,\n-    ) -> impl Iterator<Item = T> + 'a {\n-        self.raw.drain(range)\n-    }\n-\n-    #[inline]\n-    pub fn drain_enumerated<'a, R: RangeBounds<usize>>(\n-        &'a mut self,\n-        range: R,\n-    ) -> impl Iterator<Item = (I, T)> + 'a {\n-        let begin = match range.start_bound() {\n-            std::ops::Bound::Included(i) => *i,\n-            std::ops::Bound::Excluded(i) => i.checked_add(1).unwrap(),\n-            std::ops::Bound::Unbounded => 0,\n-        };\n-        self.raw.drain(range).enumerate().map(move |(n, t)| (I::new(begin + n), t))\n-    }\n-\n-    #[inline]\n-    pub fn last(&self) -> Option<I> {\n+    pub fn last_index(&self) -> Option<I> {\n         self.len().checked_sub(1).map(I::new)\n     }\n \n-    #[inline]\n-    pub fn shrink_to_fit(&mut self) {\n-        self.raw.shrink_to_fit()\n-    }\n-\n     #[inline]\n     pub fn swap(&mut self, a: I, b: I) {\n         self.raw.swap(a.index(), b.index())\n     }\n \n-    #[inline]\n-    pub fn truncate(&mut self, a: usize) {\n-        self.raw.truncate(a)\n-    }\n-\n     #[inline]\n     pub fn get(&self, index: I) -> Option<&T> {\n         self.raw.get(index.index())\n@@ -274,28 +396,6 @@ impl<I: Idx, T> IndexVec<I, T> {\n         let ptr = self.raw.as_mut_ptr();\n         unsafe { (&mut *ptr.add(ai), &mut *ptr.add(bi), &mut *ptr.add(ci)) }\n     }\n-\n-    pub fn convert_index_type<Ix: Idx>(self) -> IndexVec<Ix, T> {\n-        IndexVec { raw: self.raw, _marker: PhantomData }\n-    }\n-\n-    /// Grows the index vector so that it contains an entry for\n-    /// `elem`; if that is already true, then has no\n-    /// effect. Otherwise, inserts new values as needed by invoking\n-    /// `fill_value`.\n-    #[inline]\n-    pub fn ensure_contains_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n-        let min_new_len = elem.index() + 1;\n-        if self.len() < min_new_len {\n-            self.raw.resize_with(min_new_len, fill_value);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn resize_to_elem(&mut self, elem: I, fill_value: impl FnMut() -> T) {\n-        let min_new_len = elem.index() + 1;\n-        self.raw.resize_with(min_new_len, fill_value);\n-    }\n }\n \n /// `IndexVec` is often used as a map, so it provides some map-like APIs.\n@@ -326,7 +426,7 @@ impl<I: Idx, T: Clone> IndexVec<I, T> {\n     }\n }\n \n-impl<I: Idx, T: Ord> IndexVec<I, T> {\n+impl<I: Idx, T: Ord> IndexSlice<I, T> {\n     #[inline]\n     pub fn binary_search(&self, value: &T) -> Result<I, I> {\n         match self.raw.binary_search(value) {\n@@ -336,7 +436,7 @@ impl<I: Idx, T: Ord> IndexVec<I, T> {\n     }\n }\n \n-impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n+impl<I: Idx, T> Index<I> for IndexSlice<I, T> {\n     type Output = T;\n \n     #[inline]\n@@ -345,7 +445,7 @@ impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     }\n }\n \n-impl<I: Idx, T> IndexMut<I> for IndexVec<I, T> {\n+impl<I: Idx, T> IndexMut<I> for IndexSlice<I, T> {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut T {\n         &mut self.raw[index.index()]\n@@ -359,6 +459,20 @@ impl<I: Idx, T> Default for IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T> Default for &IndexSlice<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        IndexSlice::from_raw(Default::default())\n+    }\n+}\n+\n+impl<I: Idx, T> Default for &mut IndexSlice<I, T> {\n+    #[inline]\n+    fn default() -> Self {\n+        IndexSlice::from_raw_mut(Default::default())\n+    }\n+}\n+\n impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     #[inline]\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n@@ -418,5 +532,25 @@ impl<'a, I: Idx, T> IntoIterator for &'a mut IndexVec<I, T> {\n     }\n }\n \n+impl<'a, I: Idx, T> IntoIterator for &'a IndexSlice<I, T> {\n+    type Item = &'a T;\n+    type IntoIter = slice::Iter<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::Iter<'a, T> {\n+        self.raw.iter()\n+    }\n+}\n+\n+impl<'a, I: Idx, T> IntoIterator for &'a mut IndexSlice<I, T> {\n+    type Item = &'a mut T;\n+    type IntoIter = slice::IterMut<'a, T>;\n+\n+    #[inline]\n+    fn into_iter(self) -> slice::IterMut<'a, T> {\n+        self.raw.iter_mut()\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "3bbd01f82736381331b6efd1ef87032b3de62f38", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -230,9 +230,9 @@ impl CanonicalizeMode for CanonicalizeUserTypeAnnotation {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic => r,\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReErased | ty::ReStatic | ty::ReError(_) => r,\n             ty::ReVar(_) => canonicalizer.canonical_var_for_region_in_root_universe(r),\n-            _ => {\n+            ty::RePlaceholder(..) | ty::ReLateBound(..) => {\n                 // We only expect region names that the user can type.\n                 bug!(\"unexpected region in query response: `{:?}`\", r)\n             }"}, {"sha": "e98f68ae5a851b05ace2f947404f37e35dc6b97f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -640,11 +640,9 @@ pub fn make_query_region_constraints<'tcx>(\n     outlives_obligations: impl Iterator<Item = (Ty<'tcx>, ty::Region<'tcx>, ConstraintCategory<'tcx>)>,\n     region_constraints: &RegionConstraintData<'tcx>,\n ) -> QueryRegionConstraints<'tcx> {\n-    let RegionConstraintData { constraints, verifys, givens, member_constraints } =\n-        region_constraints;\n+    let RegionConstraintData { constraints, verifys, member_constraints } = region_constraints;\n \n     assert!(verifys.is_empty());\n-    assert!(givens.is_empty());\n \n     debug!(?constraints);\n "}, {"sha": "d53e64830ff38d0219da32fd26ae92744961ee72", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -978,7 +978,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             let (_, sig, reg) = ty::print::FmtPrinter::new(self.tcx, Namespace::TypeNS)\n                 .name_all_regions(sig)\n                 .unwrap();\n-            let lts: Vec<String> = reg.into_iter().map(|(_, kind)| kind.to_string()).collect();\n+            let lts: Vec<String> = reg.into_values().map(|kind| kind.to_string()).collect();\n             (if lts.is_empty() { String::new() } else { format!(\"for<{}> \", lts.join(\", \")) }, sig)\n         };\n \n@@ -1942,7 +1942,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     escaped\n                 }\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n-                if let Some((expected, found)) = trace.values.ty() {\n+                let values = self.resolve_vars_if_possible(trace.values);\n+                if let Some((expected, found)) = values.ty() {\n                     match (expected.kind(), found.kind()) {\n                         (ty::Tuple(_), ty::Tuple(_)) => {}\n                         // If a tuple of length one was expected and the found expression has\n@@ -2398,10 +2399,8 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 let suggestion =\n                     if has_lifetimes { format!(\" + {}\", sub) } else { format!(\": {}\", sub) };\n                 let mut suggestions = vec![(sp, suggestion)];\n-                for add_lt_sugg in add_lt_suggs {\n-                    if let Some(add_lt_sugg) = add_lt_sugg {\n-                        suggestions.push(add_lt_sugg);\n-                    }\n+                for add_lt_sugg in add_lt_suggs.into_iter().flatten() {\n+                    suggestions.push(add_lt_sugg);\n                 }\n                 err.multipart_suggestion_verbose(\n                     format!(\"{msg}...\"),\n@@ -2425,11 +2424,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     };\n                     let mut sugg =\n                         vec![(sp, suggestion), (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n-                    for add_lt_sugg in add_lt_suggs.clone() {\n-                        if let Some(lt) = add_lt_sugg {\n-                            sugg.push(lt);\n-                            sugg.rotate_right(1);\n-                        }\n+                    for lt in add_lt_suggs.clone().into_iter().flatten() {\n+                        sugg.push(lt);\n+                        sugg.rotate_right(1);\n                     }\n                     // `MaybeIncorrect` due to issue #41966.\n                     err.multipart_suggestion(msg, sugg, Applicability::MaybeIncorrect);"}, {"sha": "8ad143247e8138daf79d7a03d79e673dc4fdaffa", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,6 +10,7 @@ use rustc_middle::traits::{\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitableExt};\n use rustc_span::{sym, BytePos, Span};\n+use rustc_target::abi::FieldIdx;\n \n use crate::errors::{\n     ConsiderAddingAwait, SuggAddLetForLetChains, SuggestRemoveSemiOrReturnBinding,\n@@ -109,7 +110,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         variant.fields.len() == 1 && variant.ctor_kind() == Some(CtorKind::Fn)\n                     })\n                     .filter_map(|variant| {\n-                        let sole_field = &variant.fields[0];\n+                        let sole_field = &variant.fields[FieldIdx::from_u32(0)];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n                             let variant_path ="}, {"sha": "d89f63e5c53e9641b6e2a3452a915d98723dc4b2", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -43,18 +43,16 @@ pub struct TypeFreshener<'a, 'tcx> {\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n     const_freshen_map: FxHashMap<ty::InferConst<'tcx>, ty::Const<'tcx>>,\n-    keep_static: bool,\n }\n \n impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'tcx>, keep_static: bool) -> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'tcx>) -> TypeFreshener<'a, 'tcx> {\n         TypeFreshener {\n             infcx,\n             ty_freshen_count: 0,\n             const_freshen_count: 0,\n             ty_freshen_map: Default::default(),\n             const_freshen_map: Default::default(),\n-            keep_static,\n         }\n     }\n \n@@ -121,18 +119,9 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for TypeFreshener<'a, 'tcx> {\n             | ty::ReFree(_)\n             | ty::ReVar(_)\n             | ty::RePlaceholder(..)\n+            | ty::ReStatic\n             | ty::ReError(_)\n-            | ty::ReErased => {\n-                // replace all free regions with 'erased\n-                self.interner().lifetimes.re_erased\n-            }\n-            ty::ReStatic => {\n-                if self.keep_static {\n-                    r\n-                } else {\n-                    self.interner().lifetimes.re_erased\n-                }\n-            }\n+            | ty::ReErased => self.interner().lifetimes.re_erased,\n         }\n     }\n "}, {"sha": "9e2bdb7f510b3a22ea6afdac10957b8146890740", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 48, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -13,7 +13,7 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_data_structures::intern::Interned;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::PlaceholderRegion;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -132,7 +132,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         let graph = self.construct_graph();\n-        self.expand_givens(&graph);\n         self.expansion(&mut var_data);\n         self.collect_errors(&mut var_data, errors);\n         self.collect_var_errors(&var_data, &graph, errors);\n@@ -164,38 +163,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n-    fn expand_givens(&mut self, graph: &RegionGraph<'_>) {\n-        // Givens are a kind of horrible hack to account for\n-        // constraints like 'c <= '0 that are known to hold due to\n-        // closure signatures (see the comment above on the `givens`\n-        // field). They should go away. But until they do, the role\n-        // of this fn is to account for the transitive nature:\n-        //\n-        //     Given 'c <= '0\n-        //     and   '0 <= '1\n-        //     then  'c <= '1\n-\n-        let seeds: Vec<_> = self.data.givens.iter().cloned().collect();\n-        for (r, vid) in seeds {\n-            // While all things transitively reachable in the graph\n-            // from the variable (`'0` in the example above).\n-            let seed_index = NodeIndex(vid.index() as usize);\n-            for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n-                let succ_index = succ_index.0;\n-\n-                // The first N nodes correspond to the region\n-                // variables. Other nodes correspond to constant\n-                // regions.\n-                if succ_index < self.num_vars() {\n-                    let succ_vid = RegionVid::new(succ_index);\n-\n-                    // Add `'c <= '1`.\n-                    self.data.givens.insert((r, succ_vid));\n-                }\n-            }\n-        }\n-    }\n-\n     /// Gets the LUb of a given region and the empty region\n     fn lub_empty(&self, a_region: Region<'tcx>) -> Result<Region<'tcx>, PlaceholderRegion> {\n         match *a_region {\n@@ -362,18 +329,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\", a_region, b_vid, b_data);\n \n-        match *a_region {\n-            // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n-                if self.data.givens.contains(&(a_region, b_vid)) {\n-                    debug!(\"given\");\n-                    return false;\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n         match *b_data {\n             VarValue::Empty(empty_ui) => {\n                 let lub = match self.lub_empty(a_region) {\n@@ -768,7 +723,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn collect_error_for_expanding_node(\n         &self,\n         graph: &RegionGraph<'tcx>,\n-        dup_vec: &mut IndexVec<RegionVid, Option<RegionVid>>,\n+        dup_vec: &mut IndexSlice<RegionVid, Option<RegionVid>>,\n         node_idx: RegionVid,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n@@ -891,7 +846,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         graph: &RegionGraph<'tcx>,\n         orig_node_idx: RegionVid,\n         dir: Direction,\n-        mut dup_vec: Option<&mut IndexVec<RegionVid, Option<RegionVid>>>,\n+        mut dup_vec: Option<&mut IndexSlice<RegionVid, Option<RegionVid>>>,\n     ) -> (Vec<RegionAndOrigin<'tcx>>, FxHashSet<RegionVid>, bool) {\n         struct WalkState<'tcx> {\n             set: FxHashSet<RegionVid>,"}, {"sha": "9903ffa90bae1588bc724071c04c03791c3791d3", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -713,12 +713,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self, false)\n-    }\n-\n-    /// Like `freshener`, but does not replace `'static` regions.\n-    pub fn freshener_keep_static<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self, true)\n+        freshen::TypeFreshener::new(self)\n     }\n \n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n@@ -874,10 +869,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.inner.borrow().undo_log.opaque_types_in_snapshot(&snapshot.undo_snapshot)\n     }\n \n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n-    }\n-\n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> bool\n     where\n         T: at::ToTrace<'tcx>,"}, {"sha": "47e3dd762b08b2d6f07ce8dd0aa457bfc228ac52", "filename": "compiler/rustc_infer/src/infer/outlives/env.rs", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fenv.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::free_regions::FreeRegionMap;\n-use crate::infer::{GenericKind, InferCtxt};\n+use crate::infer::GenericKind;\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_data_structures::transitive_relation::TransitiveRelationBuilder;\n-use rustc_middle::ty::{self, ReEarlyBound, ReFree, ReVar, Region};\n+use rustc_middle::ty::{self, Region};\n \n use super::explicit_outlives_bounds;\n \n@@ -75,7 +75,7 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs: Default::default(),\n         };\n \n-        builder.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n+        builder.add_outlives_bounds(explicit_outlives_bounds(param_env));\n \n         builder\n     }\n@@ -89,11 +89,10 @@ impl<'tcx> OutlivesEnvironment<'tcx> {\n     /// Create a new `OutlivesEnvironment` with extra outlives bounds.\n     pub fn with_bounds(\n         param_env: ty::ParamEnv<'tcx>,\n-        infcx: Option<&InferCtxt<'tcx>>,\n         extra_bounds: impl IntoIterator<Item = OutlivesBound<'tcx>>,\n     ) -> Self {\n         let mut builder = Self::builder(param_env);\n-        builder.add_outlives_bounds(infcx, extra_bounds);\n+        builder.add_outlives_bounds(extra_bounds);\n         builder.build()\n     }\n \n@@ -120,12 +119,7 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n     }\n \n     /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n-    ///\n-    /// The `infcx` parameter is optional; if the implied bounds may\n-    /// contain inference variables, it must be supplied, in which\n-    /// case we will register \"givens\" on the inference context. (See\n-    /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'tcx>>, outlives_bounds: I)\n+    fn add_outlives_bounds<I>(&mut self, outlives_bounds: I)\n     where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n@@ -142,27 +136,17 @@ impl<'tcx> OutlivesEnvironmentBuilder<'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Alias(alias_b), r_a));\n                 }\n-                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n-                    if let (ReEarlyBound(_) | ReFree(_), ReVar(vid_b)) = (r_a.kind(), r_b.kind()) {\n-                        infcx\n-                            .expect(\"no infcx provided but region vars found\")\n-                            .add_given(r_a, vid_b);\n-                    } else {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        if r_a.is_free_or_static() && r_b.is_free() {\n-                            self.region_relation.add(r_a, r_b)\n-                        }\n-                    }\n-                }\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => match (*r_a, *r_b) {\n+                    (\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                        ty::ReStatic | ty::ReEarlyBound(_) | ty::ReFree(_),\n+                    ) => self.region_relation.add(r_a, r_b),\n+                    (ty::ReError(_), _) | (_, ty::ReError(_)) => {}\n+                    // FIXME(#109628): We shouldn't have existential variables in implied bounds.\n+                    // Panic here once the linked issue is resolved!\n+                    (ty::ReVar(_), _) | (_, ty::ReVar(_)) => {}\n+                    _ => bug!(\"add_outlives_bounds: unexpected regions: ({r_a:?}, {r_b:?})\"),\n+                },\n             }\n         }\n     }"}, {"sha": "89ada23c6673aefeaa4ccac65e25ff748ee14a13", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -424,9 +424,6 @@ impl<'tcx> MiniGraph<'tcx> {\n                 &AddConstraint(Constraint::RegSubReg(a, b)) => {\n                     each_edge(a, b);\n                 }\n-                &AddGiven(a, b) => {\n-                    each_edge(a, tcx.mk_re_var(b));\n-                }\n                 &AddVerify(i) => span_bug!(\n                     verifys[i].origin.span(),\n                     \"we never add verifications while doing higher-ranked things\","}, {"sha": "7b272dfd2a4547f3dcba6ab063b12ca39eb816af", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 41, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -7,7 +7,7 @@ use super::{\n     InferCtxtUndoLogs, MiscVariable, RegionVariableOrigin, Rollback, Snapshot, SubregionOrigin,\n };\n \n-use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::UndoLogs;\n@@ -104,26 +104,6 @@ pub struct RegionConstraintData<'tcx> {\n     /// An example is a `A <= B` where neither `A` nor `B` are\n     /// inference variables.\n     pub verifys: Vec<Verify<'tcx>>,\n-\n-    /// A \"given\" is a relationship that is known to hold. In\n-    /// particular, we often know from closure fn signatures that a\n-    /// particular free region must be a subregion of a region\n-    /// variable:\n-    ///\n-    ///    foo.iter().filter(<'a> |x: &'a &'b T| ...)\n-    ///\n-    /// In situations like this, `'b` is in fact a region variable\n-    /// introduced by the call to `iter()`, and `'a` is a bound region\n-    /// on the closure (as indicated by the `<'a>` prefix). If we are\n-    /// naive, we wind up inferring that `'b` must be `'static`,\n-    /// because we require that it be greater than `'a` and we do not\n-    /// know what `'a` is precisely.\n-    ///\n-    /// This hashmap is used to avoid that naive scenario. Basically\n-    /// we record the fact that `'a <= 'b` is implied by the fn\n-    /// signature, and then ignore the constraint when solving\n-    /// equations. This is a bit of a hack but seems to work.\n-    pub givens: FxIndexSet<(Region<'tcx>, ty::RegionVid)>,\n }\n \n /// Represents a constraint that influences the inference process.\n@@ -297,9 +277,6 @@ pub(crate) enum UndoLog<'tcx> {\n     /// We added the given `verify`.\n     AddVerify(usize),\n \n-    /// We added the given `given`.\n-    AddGiven(Region<'tcx>, ty::RegionVid),\n-\n     /// We added a GLB/LUB \"combination variable\".\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n }\n@@ -348,9 +325,6 @@ impl<'tcx> RegionConstraintStorage<'tcx> {\n                 self.data.verifys.pop();\n                 assert_eq!(self.data.verifys.len(), index);\n             }\n-            AddGiven(sub, sup) => {\n-                self.data.givens.remove(&(sub, sup));\n-            }\n             AddCombination(Glb, ref regions) => {\n                 self.glbs.remove(regions);\n             }\n@@ -492,15 +466,6 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         self.undo_log.push(AddVerify(index));\n     }\n \n-    pub(super) fn add_given(&mut self, sub: Region<'tcx>, sup: ty::RegionVid) {\n-        // cannot add givens once regions are resolved\n-        if self.data.givens.insert((sub, sup)) {\n-            debug!(\"add_given({:?} <= {:?})\", sub, sup);\n-\n-            self.undo_log.push(AddGiven(sub, sup));\n-        }\n-    }\n-\n     pub(super) fn make_eqregion(\n         &mut self,\n         origin: SubregionOrigin<'tcx>,\n@@ -804,11 +769,8 @@ impl<'tcx> RegionConstraintData<'tcx> {\n     /// Returns `true` if this region constraint data contains no constraints, and `false`\n     /// otherwise.\n     pub fn is_empty(&self) -> bool {\n-        let RegionConstraintData { constraints, member_constraints, verifys, givens } = self;\n-        constraints.is_empty()\n-            && member_constraints.is_empty()\n-            && verifys.is_empty()\n-            && givens.is_empty()\n+        let RegionConstraintData { constraints, member_constraints, verifys } = self;\n+        constraints.is_empty() && member_constraints.is_empty() && verifys.is_empty()\n     }\n }\n "}, {"sha": "f3797499866acbe12c10e60f249ee4911a9d257b", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -74,44 +74,58 @@ pub struct Elaborator<'tcx> {\n pub fn elaborate_trait_ref<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'tcx> {\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n     elaborate_predicates(tcx, std::iter::once(trait_ref.without_const().to_predicate(tcx)))\n }\n \n pub fn elaborate_trait_refs<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate(tcx));\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n+    let predicates = trait_refs.map(move |trait_ref| trait_ref.without_const().to_predicate(tcx));\n     elaborate_predicates(tcx, predicates)\n }\n \n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = ty::Predicate<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let obligations = predicates\n-        .map(|predicate| {\n-            predicate_obligation(predicate, ty::ParamEnv::empty(), ObligationCause::dummy())\n-        })\n-        .collect();\n-    elaborate_obligations(tcx, obligations)\n+) -> impl Iterator<Item = ty::Predicate<'tcx>> {\n+    elaborate_obligations(\n+        tcx,\n+        predicates\n+            .map(|predicate| {\n+                Obligation::new(\n+                    tcx,\n+                    // We'll dump the cause/param-env later\n+                    ObligationCause::dummy(),\n+                    ty::ParamEnv::empty(),\n+                    predicate,\n+                )\n+            })\n+            .collect(),\n+    )\n+    .map(|obl| obl.predicate)\n }\n \n pub fn elaborate_predicates_with_span<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: impl Iterator<Item = (ty::Predicate<'tcx>, Span)>,\n-) -> Elaborator<'tcx> {\n-    let obligations = predicates\n-        .map(|(predicate, span)| {\n-            predicate_obligation(\n-                predicate,\n-                ty::ParamEnv::empty(),\n-                ObligationCause::dummy_with_span(span),\n-            )\n-        })\n-        .collect();\n-    elaborate_obligations(tcx, obligations)\n+) -> impl Iterator<Item = (ty::Predicate<'tcx>, Span)> {\n+    elaborate_obligations(\n+        tcx,\n+        predicates\n+            .map(|(predicate, span)| {\n+                Obligation::new(\n+                    tcx,\n+                    // We'll dump the cause/param-env later\n+                    ObligationCause::dummy_with_span(span),\n+                    ty::ParamEnv::empty(),\n+                    predicate,\n+                )\n+            })\n+            .collect(),\n+    )\n+    .map(|obl| (obl.predicate, obl.cause.span))\n }\n \n pub fn elaborate_obligations<'tcx>(\n@@ -141,10 +155,6 @@ impl<'tcx> Elaborator<'tcx> {\n         self.stack.extend(obligations.into_iter().filter(|o| self.visited.insert(o.predicate)));\n     }\n \n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n-    }\n-\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n@@ -325,20 +335,18 @@ impl<'tcx> Iterator for Elaborator<'tcx> {\n // Supertrait iterator\n ///////////////////////////////////////////////////////////////////////////\n \n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n-\n pub fn supertraits<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    FilterToTraits::new(elaborate_trait_ref(tcx, trait_ref))\n }\n \n pub fn transitive_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    FilterToTraits::new(elaborate_trait_refs(tcx, trait_refs))\n }\n \n /// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n@@ -393,12 +401,12 @@ impl<I> FilterToTraits<I> {\n     }\n }\n \n-impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToTraits<I> {\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     type Item = ty::PolyTraitRef<'tcx>;\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        while let Some(obligation) = self.base_iterator.next() {\n-            if let Some(data) = obligation.predicate.to_opt_poly_trait_pred() {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let Some(data) = pred.to_opt_poly_trait_pred() {\n                 return Some(data.map_bound(|t| t.trait_ref));\n             }\n         }"}, {"sha": "98d3ab87f9cbd4a60fc4d35ff8ccf7e61da31e0a", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n libloading = \"0.7.1\"\n tracing = \"0.1\"\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n-rayon = { version = \"0.4.0\", package = \"rustc-rayon\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n+rustc-rayon = { version = \"0.5.0\", optional = true }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n@@ -52,4 +52,4 @@ rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n \n [features]\n llvm = ['rustc_codegen_llvm']\n-rustc_use_parallel_compiler = ['rayon', 'rustc-rayon-core', 'rustc_query_impl/rustc_use_parallel_compiler', 'rustc_errors/rustc_use_parallel_compiler']\n+rustc_use_parallel_compiler = ['rustc-rayon', 'rustc-rayon-core', 'rustc_query_impl/rustc_use_parallel_compiler', 'rustc_errors/rustc_use_parallel_compiler']"}, {"sha": "be7fa9378ca66262fb20559c24836813b7b0e6f2", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -292,7 +292,7 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n                 override_queries: config.override_queries,\n             };\n \n-            rustc_span::with_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n+            rustc_span::set_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n                 let r = {\n                     let _sess_abort_error = OnDrop(|| {\n                         compiler.sess.finish_diagnostics(registry);"}, {"sha": "9664ba8bd8ac671e643a7265765fc4102eea0be6", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,7 +2,7 @@\n #![feature(decl_macro)]\n #![feature(internal_output_capture)]\n #![feature(thread_spawn_unchecked)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]"}, {"sha": "612903810d21191102ff746cdc5c53c319121595", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -34,7 +34,7 @@ pub type MakeBackendFn = fn() -> Box<dyn CodegenBackend>;\n /// specific features (SSE, NEON etc.).\n ///\n /// This is performed by checking whether a set of permitted features\n-/// is available on the target machine, by querying LLVM.\n+/// is available on the target machine, by querying the codegen backend.\n pub fn add_configuration(\n     cfg: &mut CrateConfig,\n     sess: &mut Session,\n@@ -183,7 +183,7 @@ pub(crate) fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n                     .try_collect_active_jobs()\n                     .expect(\"active jobs shouldn't be locked in deadlock handler\")\n             });\n-            let registry = rustc_rayon_core::Registry::current();\n+            let registry = rayon_core::Registry::current();\n             thread::spawn(move || deadlock(query_map, &registry));\n         });\n     if let Some(size) = get_stack_size() {"}, {"sha": "d9c8142226d2b2730246d80a0bdca84b00e91e0f", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -91,7 +91,7 @@ lint_ty_qualified = usage of qualified `ty::{$ty}`\n lint_lintpass_by_hand = implementing `LintPass` by hand\n     .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n-lint_non_existant_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \\\"...\\\")]`\n+lint_non_existant_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n     .help = only existing keywords are allowed in core/std\n \n lint_diag_out_of_impl =\n@@ -197,7 +197,9 @@ lint_drop_glue =\n     types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n \n lint_range_endpoint_out_of_range = range endpoint is out of range for `{$ty}`\n-    .suggestion = use an inclusive range instead\n+\n+lint_range_use_inclusive_range = use an inclusive range instead\n+\n \n lint_overflowing_bin_hex = literal out of range for `{$ty}`\n     .negative_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`"}, {"sha": "c1b247e3d615a559b9140588f5d21266941b91a5", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -58,7 +58,6 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId, LocalDefIdSet, CRATE_DEF_ID};\n use rustc_hir::intravisit::FnKind as HirFnKind;\n use rustc_hir::{Body, FnDecl, ForeignItemKind, GenericParamKind, Node, PatKind, PredicateOrigin};\n-use rustc_index::vec::Idx;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -69,7 +68,7 @@ use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n-use rustc_target::abi::{Abi, VariantIdx};\n+use rustc_target::abi::{Abi, FIRST_VARIANT};\n use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n use rustc_trait_selection::traits::{self, misc::type_allowed_to_implement_copy};\n \n@@ -2788,7 +2787,7 @@ impl ClashingExternDeclarations {\n                         );\n                         if is_transparent && !is_non_null {\n                             debug_assert_eq!(def.variants().len(), 1);\n-                            let v = &def.variant(VariantIdx::new(0));\n+                            let v = &def.variant(FIRST_VARIANT);\n                             // continue with `ty`'s non-ZST field,\n                             // otherwise `ty` is a ZST and we can return\n                             if let Some(field) = transparent_newtype_field(tcx, v) {"}, {"sha": "8ec4c2b3d463ab6b51cd9df703a7392bf504426f", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1210,11 +1210,33 @@ impl<'a> DecorateLint<'a, ()> for DropGlue<'_> {\n #[diag(lint_range_endpoint_out_of_range)]\n pub struct RangeEndpointOutOfRange<'a> {\n     pub ty: &'a str,\n-    #[suggestion(code = \"{start}..={literal}{suffix}\", applicability = \"machine-applicable\")]\n-    pub suggestion: Span,\n-    pub start: String,\n-    pub literal: u128,\n-    pub suffix: &'a str,\n+    #[subdiagnostic]\n+    pub sub: UseInclusiveRange<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum UseInclusiveRange<'a> {\n+    #[suggestion(\n+        lint_range_use_inclusive_range,\n+        code = \"{start}..={literal}{suffix}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    WithoutParen {\n+        #[primary_span]\n+        sugg: Span,\n+        start: String,\n+        literal: u128,\n+        suffix: &'a str,\n+    },\n+    #[multipart_suggestion(lint_range_use_inclusive_range, applicability = \"machine-applicable\")]\n+    WithParen {\n+        #[suggestion_part(code = \"=\")]\n+        eq_sugg: Span,\n+        #[suggestion_part(code = \"{literal}{suffix}\")]\n+        lit_sugg: Span,\n+        literal: u128,\n+        suffix: &'a str,\n+    },\n }\n \n #[derive(LintDiagnostic)]"}, {"sha": "a6ba742201a3b2bcb67581cc8a5a68eabb8c2aca", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,7 +4,8 @@ use crate::{\n         AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, ImproperCTypes,\n         InvalidAtomicOrderingDiag, OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign,\n         OverflowingBinHexSub, OverflowingInt, OverflowingIntHelp, OverflowingLiteral,\n-        OverflowingUInt, RangeEndpointOutOfRange, UnusedComparisons, VariantSizeDifferencesDiag,\n+        OverflowingUInt, RangeEndpointOutOfRange, UnusedComparisons, UseInclusiveRange,\n+        VariantSizeDifferencesDiag,\n     },\n };\n use crate::{LateContext, LateLintPass, LintContext};\n@@ -136,6 +137,14 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     expr: &'tcx hir::Expr<'tcx>,\n     ty: &str,\n ) -> bool {\n+    // Look past casts to support cases like `0..256 as u8`\n+    let (expr, lit_span) = if let Node::Expr(par_expr) = cx.tcx.hir().get(cx.tcx.hir().parent_id(expr.hir_id))\n+      && let ExprKind::Cast(_, _) = par_expr.kind {\n+        (par_expr, expr.span)\n+    } else {\n+        (expr, expr.span)\n+    };\n+\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n     let par_id = cx.tcx.hir().parent_id(expr.hir_id);\n@@ -155,7 +164,6 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     if !(eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max) {\n         return false;\n     };\n-    let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n     use rustc_ast::{LitIntType, LitKind};\n     let suffix = match lit.node {\n@@ -164,16 +172,28 @@ fn lint_overflowing_range_endpoint<'tcx>(\n         LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n         _ => bug!(),\n     };\n-    cx.emit_spanned_lint(\n-        OVERFLOWING_LITERALS,\n-        struct_expr.span,\n-        RangeEndpointOutOfRange {\n-            ty,\n-            suggestion: struct_expr.span,\n+\n+    let sub_sugg = if expr.span.lo() == lit_span.lo() {\n+        let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n+        UseInclusiveRange::WithoutParen {\n+            sugg: struct_expr.span.shrink_to_lo().to(lit_span.shrink_to_hi()),\n             start,\n             literal: lit_val - 1,\n             suffix,\n-        },\n+        }\n+    } else {\n+        UseInclusiveRange::WithParen {\n+            eq_sugg: expr.span.shrink_to_lo(),\n+            lit_sugg: lit_span,\n+            literal: lit_val - 1,\n+            suffix,\n+        }\n+    };\n+\n+    cx.emit_spanned_lint(\n+        OVERFLOWING_LITERALS,\n+        struct_expr.span,\n+        RangeEndpointOutOfRange { ty, sub: sub_sugg },\n     );\n \n     // We've just emitted a lint, special cased for `(...)..MAX+1` ranges,\n@@ -750,7 +770,7 @@ pub(crate) fn repr_nullable_ptr<'tcx>(\n     debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n     if let ty::Adt(ty_def, substs) = ty.kind() {\n         let field_ty = match &ty_def.variants().raw[..] {\n-            [var_one, var_two] => match (&var_one.fields[..], &var_two.fields[..]) {\n+            [var_one, var_two] => match (&var_one.fields.raw[..], &var_two.fields.raw[..]) {\n                 ([], [field]) | ([field], []) => field.ty(cx.tcx, substs),\n                 _ => return None,\n             },"}, {"sha": "42e59f92840e08d11ef08e7f8761606bae231148", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -258,11 +258,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .find_map(|obligation| {\n+                    .find_map(|(pred, _span)| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n-                        )) = obligation.predicate.kind().skip_binder()\n+                        )) = pred.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n "}, {"sha": "f8e9ec535e4568769b39c5fe0679f44c70e063bd", "filename": "compiler/rustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fbuild.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -333,6 +333,7 @@ fn main() {\n     } else if target.contains(\"darwin\")\n         || target.contains(\"freebsd\")\n         || target.contains(\"windows-gnullvm\")\n+        || target.contains(\"aix\")\n     {\n         \"c++\"\n     } else if target.contains(\"netbsd\") && llvm_static_stdcpp.is_some() {"}, {"sha": "736766e35bcc3f996b2ab3fb7a9cf39ac0a2df53", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -368,7 +368,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n     bool EmitStackSizeSection,\n     bool RelaxELFRelocations,\n     bool UseInitArray,\n-    const char *SplitDwarfFile) {\n+    const char *SplitDwarfFile,\n+    bool ForceEmulatedTls) {\n \n   auto OptLevel = fromRust(RustOptLevel);\n   auto RM = fromRust(RustReloc);\n@@ -400,6 +401,10 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   }\n   Options.RelaxELFRelocations = RelaxELFRelocations;\n   Options.UseInitArray = UseInitArray;\n+  if (ForceEmulatedTls) {\n+    Options.ExplicitEmulatedTLS = true;\n+    Options.EmulatedTLS = true;\n+  }\n \n   if (TrapUnreachable) {\n     // Tell LLVM to codegen `unreachable` into an explicit trap instruction.\n@@ -1158,13 +1163,6 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n   // Otherwise, we sometimes lose `static` values -- see #60184.\n   computeDeadSymbolsWithConstProp(Ret->Index, Ret->GUIDPreservedSymbols,\n                                   deadIsPrevailing, /* ImportEnabled = */ false);\n-  ComputeCrossModuleImport(\n-    Ret->Index,\n-    Ret->ModuleToDefinedGVSummaries,\n-    Ret->ImportLists,\n-    Ret->ExportLists\n-  );\n-\n   // Resolve LinkOnce/Weak symbols, this has to be computed early be cause it\n   // impacts the caching.\n   //\n@@ -1181,6 +1179,16 @@ LLVMRustCreateThinLTOData(LLVMRustThinLTOModule *modules,\n       return true;\n     return Prevailing->second == S;\n   };\n+  ComputeCrossModuleImport(\n+    Ret->Index,\n+    Ret->ModuleToDefinedGVSummaries,\n+#if LLVM_VERSION_GE(17, 0)\n+    isPrevailing,\n+#endif\n+    Ret->ImportLists,\n+    Ret->ExportLists\n+  );\n+\n   auto recordNewLinkage = [&](StringRef ModuleIdentifier,\n                               GlobalValue::GUID GUID,\n                               GlobalValue::LinkageTypes NewLinkage) {"}, {"sha": "9f96a04148792f4d4ae494edc47df4c38821e07f", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -15,8 +15,7 @@ use proc_macro2::TokenStream;\n use quote::quote;\n use std::{\n     collections::{HashMap, HashSet},\n-    fs::File,\n-    io::Read,\n+    fs::read_to_string,\n     path::{Path, PathBuf},\n };\n use syn::{parse_macro_input, Ident, LitStr};\n@@ -95,20 +94,28 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n     // As this macro also outputs an `include_str!` for this file, the macro will always be\n     // re-executed when the file changes.\n-    let mut resource_file = match File::open(absolute_ftl_path) {\n-        Ok(resource_file) => resource_file,\n+    let resource_contents = match read_to_string(absolute_ftl_path) {\n+        Ok(resource_contents) => resource_contents,\n         Err(e) => {\n-            Diagnostic::spanned(resource_span, Level::Error, \"could not open Fluent resource\")\n-                .note(e.to_string())\n-                .emit();\n+            Diagnostic::spanned(\n+                resource_span,\n+                Level::Error,\n+                format!(\"could not open Fluent resource: {}\", e.to_string()),\n+            )\n+            .emit();\n             return failed(&crate_name);\n         }\n     };\n-    let mut resource_contents = String::new();\n-    if let Err(e) = resource_file.read_to_string(&mut resource_contents) {\n-        Diagnostic::spanned(resource_span, Level::Error, \"could not read Fluent resource\")\n-            .note(e.to_string())\n-            .emit();\n+    let mut bad = false;\n+    for esc in [\"\\\\n\", \"\\\\\\\"\", \"\\\\'\"] {\n+        for _ in resource_contents.matches(esc) {\n+            bad = true;\n+            Diagnostic::spanned(resource_span, Level::Error, format!(\"invalid escape `{esc}` in Fluent resource\"))\n+                .note(\"Fluent does not interpret these escape sequences (<https://projectfluent.org/fluent/guide/special.html>)\")\n+                .emit();\n+        }\n+    }\n+    if bad {\n         return failed(&crate_name);\n     }\n "}, {"sha": "880da5ca5937609d324f03b4090e88846872eec6", "filename": "compiler/rustc_metadata/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_metadata%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,7 +4,6 @@\n #![feature(generators)]\n #![feature(iter_from_generator)]\n #![feature(let_chains)]\n-#![feature(once_cell)]\n #![feature(proc_macro_internals)]\n #![feature(macro_metavar_expr)]\n #![feature(min_specialization)]"}, {"sha": "43e5946f31354659c33ed1bfa7393be57418ed5b", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1021,7 +1021,9 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             } else {\n                 // Iterate over all children.\n                 for child_index in self.root.tables.children.get(self, id).unwrap().decode(self) {\n-                    yield self.get_mod_child(child_index, sess);\n+                    if self.root.tables.opt_rpitit_info.get(self, child_index).is_none() {\n+                        yield self.get_mod_child(child_index, sess);\n+                    }\n                 }\n \n                 if let Some(reexports) = self.root.tables.module_reexports.get(self, id) {\n@@ -1067,8 +1069,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_associated_item(self, id: DefIndex, sess: &'a Session) -> ty::AssocItem {\n-        let name = self.item_name(id);\n-\n+        let name = if self.root.tables.opt_rpitit_info.get(self, id).is_some() {\n+            kw::Empty\n+        } else {\n+            self.item_name(id)\n+        };\n         let (kind, has_self) = match self.def_kind(id) {\n             DefKind::AssocConst => (ty::AssocKind::Const, false),\n             DefKind::AssocFn => (ty::AssocKind::Fn, self.get_fn_has_self_parameter(id, sess)),"}, {"sha": "5b2ec9029b16e1d87a1d261b0a5fd1000f547759", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -26,8 +26,8 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n-rustc-rayon = { version = \"0.4.0\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n+rustc-rayon = { version = \"0.5.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "bd9d89deee179d8614d8519f2d4ef56fc118702a", "filename": "compiler/rustc_middle/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -16,6 +16,10 @@ middle_limit_invalid =\n     `limit` must be a non-negative integer\n     .label = {$error_str}\n \n+middle_recursion_limit_reached =\n+    reached the recursion limit finding the struct tail for `{$ty}`\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]`\n+\n middle_const_eval_non_int =\n     constant evaluation of enum discriminant resulted in non-integer\n "}, {"sha": "dc4aa18640fb3acaf91c2527dc82bf0e95074dd9", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -49,6 +49,14 @@ pub struct LimitInvalid<'a> {\n     pub error_str: &'a str,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(middle_recursion_limit_reached)]\n+#[help]\n+pub struct RecursionLimitReached<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub suggested_limit: rustc_session::Limit,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(middle_const_eval_non_int)]\n pub struct ConstEvalNonIntError {"}, {"sha": "80b4c964ce402b2b0c1e78475ae4ce7f267d1032", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,7 +2,7 @@ use crate::ty;\n use crate::ty::Ty;\n \n use rustc_hir::HirId;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, TyEncodable, TyDecodable, HashStable)]\n #[derive(TypeFoldable, TypeVisitable)]\n@@ -27,7 +27,7 @@ pub enum ProjectionKind {\n     /// the field. The field is identified by which variant\n     /// it appears in along with a field index. The variant\n     /// is used for enums.\n-    Field(u32, VariantIdx),\n+    Field(FieldIdx, VariantIdx),\n \n     /// Some index like `B[x]`, where `B` is the base\n     /// expression. We don't preserve the index `x` because"}, {"sha": "0e883424fd47c90e72b79e5e764a2440df0590f2", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -39,7 +39,6 @@\n #![feature(never_type)]\n #![feature(extern_types)]\n #![feature(new_uninit)]\n-#![feature(once_cell)]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]"}, {"sha": "c0c0fd07b6e066eee9e7b85b36d55d0c12fe7b80", "filename": "compiler/rustc_middle/src/middle/exported_symbols.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fexported_symbols.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -43,6 +43,7 @@ pub enum ExportedSymbol<'tcx> {\n     NonGeneric(DefId),\n     Generic(DefId, SubstsRef<'tcx>),\n     DropGlue(Ty<'tcx>),\n+    ThreadLocalShim(DefId),\n     NoDefId(ty::SymbolName<'tcx>),\n }\n \n@@ -58,6 +59,10 @@ impl<'tcx> ExportedSymbol<'tcx> {\n             ExportedSymbol::DropGlue(ty) => {\n                 tcx.symbol_name(ty::Instance::resolve_drop_in_place(tcx, ty))\n             }\n+            ExportedSymbol::ThreadLocalShim(def_id) => tcx.symbol_name(ty::Instance {\n+                def: ty::InstanceDef::ThreadLocalShim(def_id),\n+                substs: ty::InternalSubsts::empty(),\n+            }),\n             ExportedSymbol::NoDefId(symbol_name) => symbol_name,\n         }\n     }"}, {"sha": "9c25f3009ba81670ebccd273f6ecbc559700146b", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -19,7 +19,7 @@ pub mod lib_features {\n                 .stable\n                 .iter()\n                 .map(|(f, (s, _))| (*f, Some(*s)))\n-                .chain(self.unstable.iter().map(|(f, _)| (*f, None)))\n+                .chain(self.unstable.keys().map(|f| (*f, None)))\n                 .collect();\n             all_features.sort_unstable_by(|a, b| a.0.as_str().partial_cmp(b.0.as_str()).unwrap());\n             all_features"}, {"sha": "967fed687b6a8de21f9d27c20d5c695766314fe4", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_span::def_id::LocalDefId;\n+use rustc_span::def_id::{LocalDefId, CRATE_DEF_ID};\n use std::hash::Hash;\n \n /// Represents the levels of effective visibility an item can have.\n@@ -107,6 +107,10 @@ impl EffectiveVisibilities {\n         })\n     }\n \n+    pub fn update_root(&mut self) {\n+        self.map.insert(CRATE_DEF_ID, EffectiveVisibility::from_vis(Visibility::Public));\n+    }\n+\n     // FIXME: Share code with `fn update`.\n     pub fn update_eff_vis(\n         &mut self,"}, {"sha": "3fb468379358aefe4b772dc87229489ae6d4d573", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::graph;\n use rustc_data_structures::graph::dominators::{dominators, Dominators};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::OnceCell;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use smallvec::SmallVec;\n \n@@ -124,10 +124,10 @@ impl<'tcx> BasicBlocks<'tcx> {\n }\n \n impl<'tcx> std::ops::Deref for BasicBlocks<'tcx> {\n-    type Target = IndexVec<BasicBlock, BasicBlockData<'tcx>>;\n+    type Target = IndexSlice<BasicBlock, BasicBlockData<'tcx>>;\n \n     #[inline]\n-    fn deref(&self) -> &IndexVec<BasicBlock, BasicBlockData<'tcx>> {\n+    fn deref(&self) -> &IndexSlice<BasicBlock, BasicBlockData<'tcx>> {\n         &self.basic_blocks\n     }\n }"}, {"sha": "2f2c7b154165a2f6b937d0e804f79644ae38c0f7", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,8 +2,6 @@\n \n mod init_mask;\n mod provenance_map;\n-#[cfg(test)]\n-mod tests;\n \n use std::borrow::Cow;\n use std::fmt;"}, {"sha": "9a02bc0cc15f80114e0c28a12b85eec54c41ff31", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask.rs", "status": "modified", "additions": 250, "deletions": 80, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,3 +1,6 @@\n+#[cfg(test)]\n+mod tests;\n+\n use std::hash;\n use std::iter;\n use std::ops::Range;\n@@ -10,20 +13,185 @@ type Block = u64;\n \n /// A bitmask where each bit refers to the byte with the same index. If the bit is `true`, the byte\n /// is initialized. If it is `false` the byte is uninitialized.\n-// Note: for performance reasons when interning, some of the `InitMask` fields can be partially\n-// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n-#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n+/// The actual bits are only materialized when needed, and we try to keep this data lazy as long as\n+/// possible. Currently, if all the blocks have the same value, then the mask represents either a\n+/// fully initialized or fully uninitialized const allocation, so we can only store that single\n+/// value.\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub struct InitMask {\n-    blocks: Vec<Block>,\n+    blocks: InitMaskBlocks,\n     len: Size,\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n+enum InitMaskBlocks {\n+    Lazy {\n+        /// Whether the lazy init mask is fully initialized or uninitialized.\n+        state: bool,\n+    },\n+    Materialized(InitMaskMaterialized),\n+}\n+\n+impl InitMask {\n+    pub fn new(size: Size, state: bool) -> Self {\n+        // Blocks start lazily allocated, until we have to materialize them.\n+        let blocks = InitMaskBlocks::Lazy { state };\n+        InitMask { len: size, blocks }\n+    }\n+\n+    /// Checks whether the `range` is entirely initialized.\n+    ///\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n+    /// indexes for the first contiguous span of the uninitialized access.\n+    #[inline]\n+    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n+        let end = range.end();\n+        if end > self.len {\n+            return Err(AllocRange::from(self.len..end));\n+        }\n+\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { state } => {\n+                // Lazily allocated blocks represent the full mask, and cover the requested range by\n+                // definition.\n+                if state { Ok(()) } else { Err(range) }\n+            }\n+            InitMaskBlocks::Materialized(ref blocks) => {\n+                blocks.is_range_initialized(range.start, end)\n+            }\n+        }\n+    }\n+\n+    /// Sets a specified range to a value. If the range is out-of-bounds, the mask will grow to\n+    /// accomodate it entirely.\n+    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n+        let start = range.start;\n+        let end = range.end();\n+\n+        let is_full_overwrite = start == Size::ZERO && end >= self.len;\n+\n+        // Optimize the cases of a full init/uninit state, while handling growth if needed.\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { ref mut state } if is_full_overwrite => {\n+                // This is fully overwriting the mask, and we'll still have a single initialization\n+                // state: the blocks can stay lazy.\n+                *state = new_state;\n+                self.len = end;\n+            }\n+            InitMaskBlocks::Materialized(_) if is_full_overwrite => {\n+                // This is also fully overwriting materialized blocks with a single initialization\n+                // state: we'll have no need for these blocks anymore and can make them lazy.\n+                self.blocks = InitMaskBlocks::Lazy { state: new_state };\n+                self.len = end;\n+            }\n+            InitMaskBlocks::Lazy { state } if state == new_state => {\n+                // Here we're partially overwriting the mask but the initialization state doesn't\n+                // change: the blocks can stay lazy.\n+                if end > self.len {\n+                    self.len = end;\n+                }\n+            }\n+            _ => {\n+                // Otherwise, we have a partial overwrite that can result in a mix of initialization\n+                // states, so we'll need materialized blocks.\n+                let len = self.len;\n+                let blocks = self.materialize_blocks();\n+\n+                // There are 3 cases of interest here, if we have:\n+                //\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // 1) the range to set can be in-bounds:\n+                //\n+                //            xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // Here, we'll simply set the single `start` to `end` range.\n+                //\n+                // 2) the range to set can be partially out-of-bounds:\n+                //\n+                //                xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // We have 2 subranges to handle:\n+                // - we'll set the existing `start` to `len` range.\n+                // - we'll grow and set the `len` to `end` range.\n+                //\n+                // 3) the range to set can be fully out-of-bounds:\n+                //\n+                //                   ---xxxx = [start, end]\n+                //         [--------]\n+                //         ^        ^\n+                //         0        len\n+                //\n+                // Since we're growing the mask to a single `new_state` value, we consider the gap\n+                // from `len` to `start` to be part of the range, and have a single subrange to\n+                // handle: we'll grow and set the `len` to `end` range.\n+                //\n+                // Note that we have to materialize, set blocks, and grow the mask. We could\n+                // therefore slightly optimize things in situations where these writes overlap.\n+                // However, as of writing this, growing the mask doesn't happen in practice yet, so\n+                // we don't do this micro-optimization.\n+\n+                if end <= len {\n+                    // Handle case 1.\n+                    blocks.set_range_inbounds(start, end, new_state);\n+                } else {\n+                    if start < len {\n+                        // Handle the first subrange of case 2.\n+                        blocks.set_range_inbounds(start, len, new_state);\n+                    }\n+\n+                    // Handle the second subrange of case 2, and case 3.\n+                    blocks.grow(len, end - len, new_state); // `Size` operation\n+                    self.len = end;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Materializes this mask's blocks when the mask is lazy.\n+    #[inline]\n+    fn materialize_blocks(&mut self) -> &mut InitMaskMaterialized {\n+        if let InitMaskBlocks::Lazy { state } = self.blocks {\n+            self.blocks = InitMaskBlocks::Materialized(InitMaskMaterialized::new(self.len, state));\n+        }\n+\n+        let InitMaskBlocks::Materialized(ref mut blocks) = self.blocks else {\n+            bug!(\"initmask blocks must be materialized here\")\n+        };\n+        blocks\n+    }\n+\n+    /// Returns the initialization state at the specified in-bounds index.\n+    #[inline]\n+    pub fn get(&self, idx: Size) -> bool {\n+        match self.blocks {\n+            InitMaskBlocks::Lazy { state } => state,\n+            InitMaskBlocks::Materialized(ref blocks) => blocks.get(idx),\n+        }\n+    }\n+}\n+\n+/// The actual materialized blocks of the bitmask, when we can't keep the `InitMask` lazy.\n+// Note: for performance reasons when interning, some of the fields can be partially\n+// hashed. (see the `Hash` impl below for more details), so the impl is not derived.\n+#[derive(Clone, Debug, Eq, PartialEq, TyEncodable, TyDecodable, HashStable)]\n+struct InitMaskMaterialized {\n+    blocks: Vec<Block>,\n+}\n+\n // Const allocations are only hashed for interning. However, they can be large, making the hashing\n // expensive especially since it uses `FxHash`: it's better suited to short keys, not potentially\n // big buffers like the allocation's init mask. We can partially hash some fields when they're\n // large.\n-impl hash::Hash for InitMask {\n+impl hash::Hash for InitMaskMaterialized {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         const MAX_BLOCKS_TO_HASH: usize = super::MAX_BYTES_TO_HASH / std::mem::size_of::<Block>();\n         const MAX_BLOCKS_LEN: usize = super::MAX_HASHED_BUFFER_LEN / std::mem::size_of::<Block>();\n@@ -41,18 +209,15 @@ impl hash::Hash for InitMask {\n         } else {\n             self.blocks.hash(state);\n         }\n-\n-        // Hash the other fields as usual.\n-        self.len.hash(state);\n     }\n }\n \n-impl InitMask {\n+impl InitMaskMaterialized {\n     pub const BLOCK_SIZE: u64 = 64;\n \n-    pub fn new(size: Size, state: bool) -> Self {\n-        let mut m = InitMask { blocks: vec![], len: Size::ZERO };\n-        m.grow(size, state);\n+    fn new(size: Size, state: bool) -> Self {\n+        let mut m = InitMaskMaterialized { blocks: vec![] };\n+        m.grow(Size::ZERO, size, state);\n         m\n     }\n \n@@ -62,30 +227,25 @@ impl InitMask {\n         // Each bit in a `Block` represents the initialization state of one byte of an allocation,\n         // so we use `.bytes()` here.\n         let bits = bits.bytes();\n-        let a = bits / InitMask::BLOCK_SIZE;\n-        let b = bits % InitMask::BLOCK_SIZE;\n+        let a = bits / Self::BLOCK_SIZE;\n+        let b = bits % Self::BLOCK_SIZE;\n         (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n     }\n \n     #[inline]\n     fn size_from_bit_index(block: impl TryInto<u64>, bit: impl TryInto<u64>) -> Size {\n         let block = block.try_into().ok().unwrap();\n         let bit = bit.try_into().ok().unwrap();\n-        Size::from_bytes(block * InitMask::BLOCK_SIZE + bit)\n+        Size::from_bytes(block * Self::BLOCK_SIZE + bit)\n     }\n \n     /// Checks whether the `range` is entirely initialized.\n     ///\n     /// Returns `Ok(())` if it's initialized. Otherwise returns a range of byte\n     /// indexes for the first contiguous span of the uninitialized access.\n     #[inline]\n-    pub fn is_range_initialized(&self, range: AllocRange) -> Result<(), AllocRange> {\n-        let end = range.end();\n-        if end > self.len {\n-            return Err(AllocRange::from(self.len..end));\n-        }\n-\n-        let uninit_start = self.find_bit(range.start, end, false);\n+    fn is_range_initialized(&self, start: Size, end: Size) -> Result<(), AllocRange> {\n+        let uninit_start = self.find_bit(start, end, false);\n \n         match uninit_start {\n             Some(uninit_start) => {\n@@ -96,81 +256,80 @@ impl InitMask {\n         }\n     }\n \n-    pub fn set_range(&mut self, range: AllocRange, new_state: bool) {\n-        let end = range.end();\n-        let len = self.len;\n-        if end > len {\n-            self.grow(end - len, new_state);\n-        }\n-        self.set_range_inbounds(range.start, end, new_state);\n-    }\n-\n     fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n-        let (blocka, bita) = Self::bit_index(start);\n-        let (blockb, bitb) = Self::bit_index(end);\n-        if blocka == blockb {\n-            // First set all bits except the first `bita`,\n-            // then unset the last `64 - bitb` bits.\n-            let range = if bitb == 0 {\n-                u64::MAX << bita\n+        let (block_a, bit_a) = Self::bit_index(start);\n+        let (block_b, bit_b) = Self::bit_index(end);\n+        if block_a == block_b {\n+            // First set all bits except the first `bit_a`,\n+            // then unset the last `64 - bit_b` bits.\n+            let range = if bit_b == 0 {\n+                u64::MAX << bit_a\n             } else {\n-                (u64::MAX << bita) & (u64::MAX >> (64 - bitb))\n+                (u64::MAX << bit_a) & (u64::MAX >> (64 - bit_b))\n             };\n             if new_state {\n-                self.blocks[blocka] |= range;\n+                self.blocks[block_a] |= range;\n             } else {\n-                self.blocks[blocka] &= !range;\n+                self.blocks[block_a] &= !range;\n             }\n             return;\n         }\n         // across block boundaries\n         if new_state {\n-            // Set `bita..64` to `1`.\n-            self.blocks[blocka] |= u64::MAX << bita;\n-            // Set `0..bitb` to `1`.\n-            if bitb != 0 {\n-                self.blocks[blockb] |= u64::MAX >> (64 - bitb);\n+            // Set `bit_a..64` to `1`.\n+            self.blocks[block_a] |= u64::MAX << bit_a;\n+            // Set `0..bit_b` to `1`.\n+            if bit_b != 0 {\n+                self.blocks[block_b] |= u64::MAX >> (64 - bit_b);\n             }\n             // Fill in all the other blocks (much faster than one bit at a time).\n-            for block in (blocka + 1)..blockb {\n+            for block in (block_a + 1)..block_b {\n                 self.blocks[block] = u64::MAX;\n             }\n         } else {\n-            // Set `bita..64` to `0`.\n-            self.blocks[blocka] &= !(u64::MAX << bita);\n-            // Set `0..bitb` to `0`.\n-            if bitb != 0 {\n-                self.blocks[blockb] &= !(u64::MAX >> (64 - bitb));\n+            // Set `bit_a..64` to `0`.\n+            self.blocks[block_a] &= !(u64::MAX << bit_a);\n+            // Set `0..bit_b` to `0`.\n+            if bit_b != 0 {\n+                self.blocks[block_b] &= !(u64::MAX >> (64 - bit_b));\n             }\n             // Fill in all the other blocks (much faster than one bit at a time).\n-            for block in (blocka + 1)..blockb {\n+            for block in (block_a + 1)..block_b {\n                 self.blocks[block] = 0;\n             }\n         }\n     }\n \n     #[inline]\n-    pub fn get(&self, i: Size) -> bool {\n+    fn get(&self, i: Size) -> bool {\n         let (block, bit) = Self::bit_index(i);\n         (self.blocks[block] & (1 << bit)) != 0\n     }\n \n-    fn grow(&mut self, amount: Size, new_state: bool) {\n+    fn grow(&mut self, len: Size, amount: Size, new_state: bool) {\n         if amount.bytes() == 0 {\n             return;\n         }\n         let unused_trailing_bits =\n-            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - self.len.bytes();\n+            u64::try_from(self.blocks.len()).unwrap() * Self::BLOCK_SIZE - len.bytes();\n+\n+        // If there's not enough capacity in the currently allocated blocks, allocate some more.\n         if amount.bytes() > unused_trailing_bits {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n-            self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n-                iter::repeat(0).take(usize::try_from(additional_blocks).unwrap()),\n-            );\n+\n+            // We allocate the blocks to the correct value for the requested init state, so we won't\n+            // have to manually set them with another write.\n+            let block = if new_state { u64::MAX } else { 0 };\n+            self.blocks\n+                .extend(iter::repeat(block).take(usize::try_from(additional_blocks).unwrap()));\n+        }\n+\n+        // New blocks have already been set here, so we only need to set the unused trailing bits,\n+        // if any.\n+        if unused_trailing_bits > 0 {\n+            let in_bounds_tail = Size::from_bytes(unused_trailing_bits);\n+            self.set_range_inbounds(len, len + in_bounds_tail, new_state); // `Size` operation\n         }\n-        let start = self.len;\n-        self.len += amount;\n-        self.set_range_inbounds(start, start + amount, new_state); // `Size` operation\n     }\n \n     /// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n@@ -188,7 +347,7 @@ impl InitMask {\n         /// ```\n         /// Also, if not stated, assume that `is_init = true`, that is, we are searching for the first 1 bit.\n         fn find_bit_fast(\n-            init_mask: &InitMask,\n+            init_mask: &InitMaskMaterialized,\n             start: Size,\n             end: Size,\n             is_init: bool,\n@@ -223,7 +382,7 @@ impl InitMask {\n                     None\n                 } else {\n                     let bit = bits.trailing_zeros();\n-                    Some(InitMask::size_from_bit_index(block, bit))\n+                    Some(InitMaskMaterialized::size_from_bit_index(block, bit))\n                 }\n             }\n \n@@ -253,9 +412,9 @@ impl InitMask {\n             // This provides the desired behavior of searching blocks 0 and 1 for (a),\n             // and searching only block 0 for (b).\n             // There is no concern of overflows since we checked for `start >= end` above.\n-            let (start_block, start_bit) = InitMask::bit_index(start);\n+            let (start_block, start_bit) = InitMaskMaterialized::bit_index(start);\n             let end_inclusive = Size::from_bytes(end.bytes() - 1);\n-            let (end_block_inclusive, _) = InitMask::bit_index(end_inclusive);\n+            let (end_block_inclusive, _) = InitMaskMaterialized::bit_index(end_inclusive);\n \n             // Handle first block: need to skip `start_bit` bits.\n             //\n@@ -340,7 +499,7 @@ impl InitMask {\n \n         #[cfg_attr(not(debug_assertions), allow(dead_code))]\n         fn find_bit_slow(\n-            init_mask: &InitMask,\n+            init_mask: &InitMaskMaterialized,\n             start: Size,\n             end: Size,\n             is_init: bool,\n@@ -436,10 +595,19 @@ impl<'a> Iterator for InitChunkIter<'a> {\n             return None;\n         }\n \n-        let end_of_chunk =\n-            self.init_mask.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+        let end_of_chunk = match self.init_mask.blocks {\n+            InitMaskBlocks::Lazy { .. } => {\n+                // If we're iterating over the chunks of lazy blocks, we just emit a single\n+                // full-size chunk.\n+                self.end\n+            }\n+            InitMaskBlocks::Materialized(ref blocks) => {\n+                let end_of_chunk =\n+                    blocks.find_bit(self.start, self.end, !self.is_init).unwrap_or(self.end);\n+                end_of_chunk\n+            }\n+        };\n         let range = self.start..end_of_chunk;\n-\n         let ret =\n             Some(if self.is_init { InitChunk::Init(range) } else { InitChunk::Uninit(range) });\n \n@@ -504,25 +672,27 @@ impl InitMask {\n \n     /// Applies multiple instances of the run-length encoding to the initialization mask.\n     pub fn apply_copy(&mut self, defined: InitCopy, range: AllocRange, repeat: u64) {\n-        // An optimization where we can just overwrite an entire range of initialization\n-        // bits if they are going to be uniformly `1` or `0`.\n+        // An optimization where we can just overwrite an entire range of initialization bits if\n+        // they are going to be uniformly `1` or `0`. If this happens to be a full-range overwrite,\n+        // we won't need materialized blocks either.\n         if defined.ranges.len() <= 1 {\n-            self.set_range_inbounds(\n-                range.start,\n-                range.start + range.size * repeat, // `Size` operations\n-                defined.initial,\n-            );\n+            let start = range.start;\n+            let end = range.start + range.size * repeat; // `Size` operations\n+            self.set_range(AllocRange::from(start..end), defined.initial);\n             return;\n         }\n \n+        // We're about to do one or more partial writes, so we ensure the blocks are materialized.\n+        let blocks = self.materialize_blocks();\n+\n         for mut j in 0..repeat {\n             j *= range.size.bytes();\n             j += range.start.bytes();\n             let mut cur = defined.initial;\n             for range in &defined.ranges {\n                 let old_j = j;\n                 j += range;\n-                self.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n+                blocks.set_range_inbounds(Size::from_bytes(old_j), Size::from_bytes(j), cur);\n                 cur = !cur;\n             }\n         }"}, {"sha": "1a7934bc210dbc07a49df6aa11764bc4a6e4bddc", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/init_mask/tests.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Finit_mask%2Ftests.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -0,0 +1,195 @@\n+use super::*;\n+use crate::mir::interpret::alloc_range;\n+\n+#[test]\n+fn uninit_mask() {\n+    let mut mask = InitMask::new(Size::from_bytes(500), false);\n+    assert!(!mask.get(Size::from_bytes(499)));\n+    mask.set_range(alloc_range(Size::from_bytes(499), Size::from_bytes(1)), true);\n+    assert!(mask.get(Size::from_bytes(499)));\n+    mask.set_range((100..256).into(), true);\n+    for i in 0..100 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+    for i in 100..256 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+    for i in 256..499 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+}\n+\n+/// Returns the number of materialized blocks for this mask.\n+fn materialized_block_count(mask: &InitMask) -> usize {\n+    match mask.blocks {\n+        InitMaskBlocks::Lazy { .. } => 0,\n+        InitMaskBlocks::Materialized(ref blocks) => blocks.blocks.len(),\n+    }\n+}\n+\n+#[test]\n+fn materialize_mask_within_range() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), false);\n+    assert_eq!(materialized_block_count(&mask), 0);\n+\n+    // Forces materialization, but doesn't require growth. This is case #1 documented in the\n+    // `set_range` method.\n+    mask.set_range((8..16).into(), true);\n+    assert_eq!(materialized_block_count(&mask), 1);\n+\n+    for i in 0..8 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+    for i in 8..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+}\n+\n+#[test]\n+fn grow_within_unused_bits_with_full_overwrite() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block. Full overwrite.\n+    // This can be fully handled without materialization.\n+    let range = (0..32).into();\n+    mask.set_range(range, true);\n+\n+    for i in 0..32 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}\n+\n+// This test checks that an initmask's spare capacity is correctly used when growing within block\n+// capacity. This can be fully handled without materialization.\n+#[test]\n+fn grow_same_state_within_unused_bits() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block. The gap between the current length and the\n+    // range's beginning should be set to the same value as the range.\n+    let range = (24..32).into();\n+    mask.set_range(range, true);\n+\n+    // We want to make sure the unused bits in the first block are correct\n+    for i in 16..24 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    for i in 24..32 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..32).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}\n+\n+// This is the same test as `grow_same_state_within_unused_bits` but with both init and uninit\n+// states: this forces materialization; otherwise the mask could stay lazy even when needing to\n+// grow.\n+#[test]\n+fn grow_mixed_state_within_unused_bits() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block. The gap between the current length and the\n+    // range's beginning should be set to the same value as the range. Note: since this is fully\n+    // out-of-bounds of the current mask, this is case #3 described in the `set_range` method.\n+    let range = (24..32).into();\n+    mask.set_range(range, false);\n+\n+    // We want to make sure the unused bits in the first block are correct\n+    for i in 16..24 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+\n+    for i in 24..32 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..16).into()).count());\n+    assert_eq!(2, mask.range_as_init_chunks((0..32).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 1);\n+}\n+\n+// This is similar to `grow_mixed_state_within_unused_bits` to force materialization, but the range\n+// to set partially overlaps the mask, so this requires a different growth + write pattern in the\n+// mask.\n+#[test]\n+fn grow_within_unused_bits_with_overlap() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+\n+    // Grow without requiring an additional block, but leave no gap after the current len. Note:\n+    // since this is partially out-of-bounds of the current mask, this is case #2 described in the\n+    // `set_range` method.\n+    let range = (8..24).into();\n+    mask.set_range(range, false);\n+\n+    // We want to make sure the unused bits in the first block are correct\n+    for i in 8..24 {\n+        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n+    }\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..8).into()).count());\n+    assert_eq!(2, mask.range_as_init_chunks((0..24).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 1);\n+}\n+\n+// Force materialization before a full overwrite: the mask can now become lazy.\n+#[test]\n+fn grow_mixed_state_within_unused_bits_and_full_overwrite() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    let range = (0..16).into();\n+    assert!(mask.is_range_initialized(range).is_ok());\n+\n+    // Force materialization.\n+    let range = (8..24).into();\n+    mask.set_range(range, false);\n+    assert!(mask.is_range_initialized(range).is_err());\n+    assert_eq!(materialized_block_count(&mask), 1);\n+\n+    // Full overwrite, lazy blocks would be enough from now on.\n+    let range = (0..32).into();\n+    mask.set_range(range, true);\n+    assert!(mask.is_range_initialized(range).is_ok());\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..32).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}\n+\n+// Check that growth outside the current capacity can still be lazy: if the init state doesn't\n+// change, we don't need materialized blocks.\n+#[test]\n+fn grow_same_state_outside_capacity() {\n+    // To have spare bits, we use a mask size smaller than its block size of 64.\n+    let mut mask = InitMask::new(Size::from_bytes(16), true);\n+    for i in 0..16 {\n+        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n+    }\n+    assert_eq!(materialized_block_count(&mask), 0);\n+\n+    // Grow to 10 blocks with the same init state.\n+    let range = (24..640).into();\n+    mask.set_range(range, true);\n+\n+    assert_eq!(1, mask.range_as_init_chunks((0..640).into()).count());\n+    assert_eq!(materialized_block_count(&mask), 0);\n+}"}, {"sha": "c9c3c50c5371e92be300050e09a213dc2defca4b", "filename": "compiler/rustc_middle/src/mir/interpret/allocation/tests.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7315b6da628e0e6759c2eab5e83253edc1f1f9a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7315b6da628e0e6759c2eab5e83253edc1f1f9a7/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation%2Ftests.rs?ref=7315b6da628e0e6759c2eab5e83253edc1f1f9a7", "patch": "@@ -1,19 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn uninit_mask() {\n-    let mut mask = InitMask::new(Size::from_bytes(500), false);\n-    assert!(!mask.get(Size::from_bytes(499)));\n-    mask.set_range(alloc_range(Size::from_bytes(499), Size::from_bytes(1)), true);\n-    assert!(mask.get(Size::from_bytes(499)));\n-    mask.set_range((100..256).into(), true);\n-    for i in 0..100 {\n-        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n-    }\n-    for i in 100..256 {\n-        assert!(mask.get(Size::from_bytes(i)), \"{i} should be set\");\n-    }\n-    for i in 256..499 {\n-        assert!(!mask.get(Size::from_bytes(i)), \"{i} should not be set\");\n-    }\n-}"}, {"sha": "44fd8478be9b5a0685c264262eeed67a950cb728", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 44, "deletions": 32, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -21,13 +21,13 @@ use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::{self, GeneratorKind, ImplicitSelfKind};\n use rustc_hir::{self as hir, HirId};\n use rustc_session::Session;\n-use rustc_target::abi::{Size, VariantIdx};\n+use rustc_target::abi::{FieldIdx, Size, VariantIdx};\n \n use polonius_engine::Atom;\n pub use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::dominators::Dominators;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use rustc_serialize::{Decodable, Encodable};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n@@ -70,12 +70,19 @@ pub use self::pretty::{\n };\n \n /// Types for locals\n-pub type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n+pub type LocalDecls<'tcx> = IndexSlice<Local, LocalDecl<'tcx>>;\n \n pub trait HasLocalDecls<'tcx> {\n     fn local_decls(&self) -> &LocalDecls<'tcx>;\n }\n \n+impl<'tcx> HasLocalDecls<'tcx> for IndexVec<Local, LocalDecl<'tcx>> {\n+    #[inline]\n+    fn local_decls(&self) -> &LocalDecls<'tcx> {\n+        self\n+    }\n+}\n+\n impl<'tcx> HasLocalDecls<'tcx> for LocalDecls<'tcx> {\n     #[inline]\n     fn local_decls(&self) -> &LocalDecls<'tcx> {\n@@ -250,7 +257,7 @@ pub struct Body<'tcx> {\n     /// The first local is the return value pointer, followed by `arg_count`\n     /// locals for the function arguments, followed by any user-declared\n     /// variables and temporaries.\n-    pub local_decls: LocalDecls<'tcx>,\n+    pub local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n \n     /// User type annotations.\n     pub user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n@@ -311,7 +318,7 @@ impl<'tcx> Body<'tcx> {\n         source: MirSource<'tcx>,\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n-        local_decls: LocalDecls<'tcx>,\n+        local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n         user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n         var_debug_info: Vec<VarDebugInfo<'tcx>>,\n@@ -1277,7 +1284,7 @@ impl<O> AssertKind<O> {\n \n     /// Getting a description does not require `O` to be printable, and does not\n     /// require allocation.\n-    /// The caller is expected to handle `BoundsCheck` separately.\n+    /// The caller is expected to handle `BoundsCheck` and `MisalignedPointerDereference` separately.\n     pub fn description(&self) -> &'static str {\n         use AssertKind::*;\n         match self {\n@@ -1296,7 +1303,9 @@ impl<O> AssertKind<O> {\n             ResumedAfterReturn(GeneratorKind::Async(_)) => \"`async fn` resumed after completion\",\n             ResumedAfterPanic(GeneratorKind::Gen) => \"generator resumed after panicking\",\n             ResumedAfterPanic(GeneratorKind::Async(_)) => \"`async fn` resumed after panicking\",\n-            BoundsCheck { .. } => bug!(\"Unexpected AssertKind\"),\n+            BoundsCheck { .. } | MisalignedPointerDereference { .. } => {\n+                bug!(\"Unexpected AssertKind\")\n+            }\n         }\n     }\n \n@@ -1353,6 +1362,13 @@ impl<O> AssertKind<O> {\n             Overflow(BinOp::Shl, _, r) => {\n                 write!(f, \"\\\"attempt to shift left by `{{}}`, which would overflow\\\", {:?}\", r)\n             }\n+            MisalignedPointerDereference { required, found } => {\n+                write!(\n+                    f,\n+                    \"\\\"misaligned pointer dereference: address must be a multiple of {{}} but is {{}}\\\", {:?}, {:?}\",\n+                    required, found\n+                )\n+            }\n             _ => write!(f, \"\\\"{}\\\"\", self.description()),\n         }\n     }\n@@ -1397,6 +1413,13 @@ impl<O: fmt::Debug> fmt::Debug for AssertKind<O> {\n             Overflow(BinOp::Shl, _, r) => {\n                 write!(f, \"attempt to shift left by `{:#?}`, which would overflow\", r)\n             }\n+            MisalignedPointerDereference { required, found } => {\n+                write!(\n+                    f,\n+                    \"misaligned pointer dereference: address must be a multiple of {:?} but is {:?}\",\n+                    required, found\n+                )\n+            }\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }\n@@ -1512,7 +1535,7 @@ impl<V, T> ProjectionElem<V, T> {\n     }\n \n     /// Returns `true` if this is a `Field` projection with the given index.\n-    pub fn is_field_to(&self, f: Field) -> bool {\n+    pub fn is_field_to(&self, f: FieldIdx) -> bool {\n         matches!(*self, Self::Field(x, _) if x == f)\n     }\n }\n@@ -1521,22 +1544,6 @@ impl<V, T> ProjectionElem<V, T> {\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n pub type ProjectionKind = ProjectionElem<(), ()>;\n \n-rustc_index::newtype_index! {\n-    /// A [newtype'd][wrapper] index type in the MIR [control-flow graph][CFG]\n-    ///\n-    /// A field (e.g., `f` in `_1.f`) is one variant of [`ProjectionElem`]. Conceptually,\n-    /// rustc can identify that a field projection refers to either two different regions of memory\n-    /// or the same one between the base and the 'projection element'.\n-    /// Read more about projections in the [rustc-dev-guide][mir-datatypes]\n-    ///\n-    /// [wrapper]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html#newtype\n-    /// [CFG]: https://rustc-dev-guide.rust-lang.org/appendix/background.html#cfg\n-    /// [mir-datatypes]: https://rustc-dev-guide.rust-lang.org/mir/index.html#mir-data-types\n-    #[derive(HashStable)]\n-    #[debug_format = \"field[{}]\"]\n-    pub struct Field {}\n-}\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct PlaceRef<'tcx> {\n     pub local: Local,\n@@ -1779,7 +1786,7 @@ impl SourceScope {\n     /// from the function that was inlined instead of the function call site.\n     pub fn lint_root(\n         self,\n-        source_scopes: &IndexVec<SourceScope, SourceScopeData<'_>>,\n+        source_scopes: &IndexSlice<SourceScope, SourceScopeData<'_>>,\n     ) -> Option<HirId> {\n         let mut data = &source_scopes[self];\n         // FIXME(oli-obk): we should be able to just walk the `inlined_parent_scope`, but it\n@@ -1799,7 +1806,7 @@ impl SourceScope {\n     #[inline]\n     pub fn inlined_instance<'tcx>(\n         self,\n-        source_scopes: &IndexVec<SourceScope, SourceScopeData<'tcx>>,\n+        source_scopes: &IndexSlice<SourceScope, SourceScopeData<'tcx>>,\n     ) -> Option<ty::Instance<'tcx>> {\n         let scope_data = &source_scopes[self];\n         if let Some((inlined_instance, _)) = scope_data.inlined {\n@@ -2685,12 +2692,17 @@ impl<'tcx> UserTypeProjections {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.deref())\n     }\n \n-    pub fn leaf(self, field: Field) -> Self {\n+    pub fn leaf(self, field: FieldIdx) -> Self {\n         self.map_projections(|pat_ty_proj| pat_ty_proj.leaf(field))\n     }\n \n-    pub fn variant(self, adt_def: AdtDef<'tcx>, variant_index: VariantIdx, field: Field) -> Self {\n-        self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n+    pub fn variant(\n+        self,\n+        adt_def: AdtDef<'tcx>,\n+        variant_index: VariantIdx,\n+        field_index: FieldIdx,\n+    ) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field_index))\n     }\n }\n \n@@ -2733,7 +2745,7 @@ impl UserTypeProjection {\n         self\n     }\n \n-    pub(crate) fn leaf(mut self, field: Field) -> Self {\n+    pub(crate) fn leaf(mut self, field: FieldIdx) -> Self {\n         self.projs.push(ProjectionElem::Field(field, ()));\n         self\n     }\n@@ -2742,13 +2754,13 @@ impl UserTypeProjection {\n         mut self,\n         adt_def: AdtDef<'_>,\n         variant_index: VariantIdx,\n-        field: Field,\n+        field_index: FieldIdx,\n     ) -> Self {\n         self.projs.push(ProjectionElem::Downcast(\n             Some(adt_def.variant(variant_index).name),\n             variant_index,\n         ));\n-        self.projs.push(ProjectionElem::Field(field, ()));\n+        self.projs.push(ProjectionElem::Field(field_index, ()));\n         self\n     }\n }"}, {"sha": "f592f1515c110b18db87c6c142c2cb1650027d71", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -381,7 +381,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             | InstanceDef::Virtual(..)\n                             | InstanceDef::ClosureOnceShim { .. }\n                             | InstanceDef::DropGlue(..)\n-                            | InstanceDef::CloneShim(..) => None,\n+                            | InstanceDef::CloneShim(..)\n+                            | InstanceDef::ThreadLocalShim(..)\n+                            | InstanceDef::FnPtrAddrShim(..) => None,\n                         }\n                     }\n                     MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),"}, {"sha": "68561cf6dd775deeee6df16b38bab56356d44616", "filename": "compiler/rustc_middle/src/mir/query.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fquery.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,12 +10,12 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use smallvec::SmallVec;\n use std::cell::Cell;\n use std::fmt::{self, Debug};\n \n-use super::{Field, SourceInfo};\n+use super::SourceInfo;\n \n #[derive(Copy, Clone, PartialEq, TyEncodable, TyDecodable, HashStable, Debug)]\n pub enum UnsafetyViolationKind {\n@@ -152,7 +152,7 @@ pub struct GeneratorLayout<'tcx> {\n \n     /// Which of the above fields are in each variant. Note that one field may\n     /// be stored in multiple variants.\n-    pub variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>>,\n+    pub variant_fields: IndexVec<VariantIdx, IndexVec<FieldIdx, GeneratorSavedLocal>>,\n \n     /// The source that led to each variant being created (usually, a yield or\n     /// await).\n@@ -229,7 +229,7 @@ pub struct BorrowCheckResult<'tcx> {\n     /// unerased regions.\n     pub concrete_opaque_types: FxIndexMap<LocalDefId, OpaqueHiddenType<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n-    pub used_mut_upvars: SmallVec<[Field; 8]>,\n+    pub used_mut_upvars: SmallVec<[FieldIdx; 8]>,\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n }\n \n@@ -353,7 +353,7 @@ pub enum ConstraintCategory<'tcx> {\n     /// like `Foo { field: my_val }`)\n     Usage,\n     OpaqueType,\n-    ClosureUpvar(Field),\n+    ClosureUpvar(FieldIdx),\n \n     /// A constraint from a user-written predicate\n     /// with the provided span, written on the item\n@@ -375,7 +375,7 @@ pub enum ConstraintCategory<'tcx> {\n #[derive(TyEncodable, TyDecodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum ReturnConstraint {\n     Normal,\n-    ClosureUpvar(Field),\n+    ClosureUpvar(FieldIdx),\n }\n \n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing"}, {"sha": "cc35e6106e29402c4092e90e50a926bc7028e253", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@\n //! This is in a dedicated file so that changes to this file can be reviewed more carefully.\n //! The intention is that this file only contains datatype declarations, no code.\n \n-use super::{BasicBlock, Constant, Field, Local, SwitchTargets, UserTypeProjection};\n+use super::{BasicBlock, Constant, Local, SwitchTargets, UserTypeProjection};\n \n use crate::mir::coverage::{CodeRegion, CoverageKind};\n use crate::traits::Reveal;\n@@ -16,7 +16,8 @@ use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{self as hir};\n use rustc_hir::{self, GeneratorKind};\n-use rustc_target::abi::VariantIdx;\n+use rustc_index::vec::IndexVec;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n \n use rustc_ast::Mutability;\n use rustc_span::def_id::LocalDefId;\n@@ -760,6 +761,7 @@ pub enum AssertKind<O> {\n     RemainderByZero(O),\n     ResumedAfterReturn(GeneratorKind),\n     ResumedAfterPanic(GeneratorKind),\n+    MisalignedPointerDereference { required: O, found: O },\n }\n \n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable)]\n@@ -888,7 +890,15 @@ pub struct Place<'tcx> {\n #[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum ProjectionElem<V, T> {\n     Deref,\n-    Field(Field, T),\n+\n+    /// A field (e.g., `f` in `_1.f`) is one variant of [`ProjectionElem`]. Conceptually,\n+    /// rustc can identify that a field projection refers to either two different regions of memory\n+    /// or the same one between the base and the 'projection element'.\n+    /// Read more about projections in the [rustc-dev-guide][mir-datatypes]\n+    ///\n+    /// [mir-datatypes]: https://rustc-dev-guide.rust-lang.org/mir/index.html#mir-data-types\n+    Field(FieldIdx, T),\n+\n     /// Index into a slice/array.\n     ///\n     /// Note that this does not also dereference, and so it does not exactly correspond to slice\n@@ -1116,7 +1126,7 @@ pub enum Rvalue<'tcx> {\n     ///\n     /// Disallowed after deaggregation for all aggregate kinds except `Array` and `Generator`. After\n     /// generator lowering, `Generator` aggregate kinds are disallowed too.\n-    Aggregate(Box<AggregateKind<'tcx>>, Vec<Operand<'tcx>>),\n+    Aggregate(Box<AggregateKind<'tcx>>, IndexVec<FieldIdx, Operand<'tcx>>),\n \n     /// Transmutes a `*mut u8` into shallow-initialized `Box<T>`.\n     ///\n@@ -1177,7 +1187,7 @@ pub enum AggregateKind<'tcx> {\n     /// active field number and is present only for union expressions\n     /// -- e.g., for a union expression `SomeUnion { c: .. }`, the\n     /// active field index would identity the field `c`\n-    Adt(DefId, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<usize>),\n+    Adt(DefId, VariantIdx, SubstsRef<'tcx>, Option<UserTypeAnnotationIndex>, Option<FieldIdx>),\n \n     Closure(DefId, SubstsRef<'tcx>),\n     Generator(DefId, SubstsRef<'tcx>, hir::Movability),\n@@ -1254,7 +1264,7 @@ pub enum BinOp {\n mod size_asserts {\n     use super::*;\n     // tidy-alphabetical-start\n-    static_assert_size!(AggregateKind<'_>, 40);\n+    static_assert_size!(AggregateKind<'_>, 32);\n     static_assert_size!(Operand<'_>, 24);\n     static_assert_size!(Place<'_>, 16);\n     static_assert_size!(PlaceElem<'_>, 24);"}, {"sha": "0092401470f5680c896f864c6672ba6c7a3f9de2", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,7 +6,7 @@\n use crate::mir::*;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n \n #[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable)]\n pub struct PlaceTy<'tcx> {\n@@ -33,7 +33,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     ///\n     /// Note that the resulting type has not been normalized.\n     #[instrument(level = \"debug\", skip(tcx), ret)]\n-    pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: Field) -> Ty<'tcx> {\n+    pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: FieldIdx) -> Ty<'tcx> {\n         match self.ty.kind() {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n@@ -43,7 +43,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                         &adt_def.variant(variant_index)\n                     }\n                 };\n-                let field_def = &variant_def.fields[f.index()];\n+                let field_def = &variant_def.fields[f];\n                 field_def.ty(tcx, substs)\n             }\n             ty::Tuple(tys) => tys[f.index()],\n@@ -61,14 +61,14 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n     /// projects `place_ty` onto `elem`, returning the appropriate\n     /// `Ty` or downcast variant corresponding to that projection.\n-    /// The `handle_field` callback must map a `Field` to its `Ty`,\n+    /// The `handle_field` callback must map a `FieldIdx` to its `Ty`,\n     /// (which should be trivial when `T` = `Ty`).\n     pub fn projection_ty_core<V, T>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         elem: &ProjectionElem<V, T>,\n-        mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n+        mut handle_field: impl FnMut(&Self, FieldIdx, T) -> Ty<'tcx>,\n         mut handle_opaque_cast: impl FnMut(&Self, T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n@@ -116,7 +116,7 @@ impl<'tcx> PlaceTy<'tcx> {\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub fn ty_from<D>(\n+    pub fn ty_from<D: ?Sized>(\n         local: Local,\n         projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n@@ -132,7 +132,7 @@ impl<'tcx> Place<'tcx> {\n             })\n     }\n \n-    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n+    pub fn ty<D: ?Sized>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n@@ -141,7 +141,7 @@ impl<'tcx> Place<'tcx> {\n }\n \n impl<'tcx> PlaceRef<'tcx> {\n-    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n+    pub fn ty<D: ?Sized>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n@@ -155,7 +155,7 @@ pub enum RvalueInitializationState {\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> Ty<'tcx>\n+    pub fn ty<D: ?Sized>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> Ty<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n@@ -164,17 +164,7 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Repeat(ref operand, count) => {\n                 tcx.mk_array_with_const_len(operand.ty(local_decls, tcx), count)\n             }\n-            Rvalue::ThreadLocalRef(did) => {\n-                let static_ty = tcx.type_of(did).subst_identity();\n-                if tcx.is_mutable_static(did) {\n-                    tcx.mk_mut_ptr(static_ty)\n-                } else if tcx.is_foreign_item(did) {\n-                    tcx.mk_imm_ptr(static_ty)\n-                } else {\n-                    // FIXME: These things don't *really* have 'static lifetime.\n-                    tcx.mk_imm_ref(tcx.lifetimes.re_static, static_ty)\n-                }\n-            }\n+            Rvalue::ThreadLocalRef(did) => tcx.thread_local_ptr_ty(did),\n             Rvalue::Ref(reg, bk, ref place) => {\n                 let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg, ty::TypeAndMut { ty: place_ty, mutbl: bk.to_mutbl_lossy() })\n@@ -227,7 +217,7 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl<'tcx> Operand<'tcx> {\n-    pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> Ty<'tcx>\n+    pub fn ty<D: ?Sized>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> Ty<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {"}, {"sha": "62cdf794b1e91c1bcbc3142018442a73b24244cc", "filename": "compiler/rustc_middle/src/mir/traversal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftraversal.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -101,15 +101,15 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n ///\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx> {\n-    basic_blocks: &'a IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    basic_blocks: &'a IndexSlice<BasicBlock, BasicBlockData<'tcx>>,\n     visited: BitSet<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>,\n     root_is_start_block: bool,\n }\n \n impl<'a, 'tcx> Postorder<'a, 'tcx> {\n     pub fn new(\n-        basic_blocks: &'a IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+        basic_blocks: &'a IndexSlice<BasicBlock, BasicBlockData<'tcx>>,\n         root: BasicBlock,\n     ) -> Postorder<'a, 'tcx> {\n         let mut po = Postorder {"}, {"sha": "7aa446ae966c62ceed8c406a81e95634caa7a263", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -335,12 +335,14 @@ macro_rules! make_mir_visitor {\n                         ty::InstanceDef::VTableShim(_def_id) |\n                         ty::InstanceDef::ReifyShim(_def_id) |\n                         ty::InstanceDef::Virtual(_def_id, _) |\n+                        ty::InstanceDef::ThreadLocalShim(_def_id) |\n                         ty::InstanceDef::ClosureOnceShim { call_once: _def_id, track_caller: _ } |\n                         ty::InstanceDef::DropGlue(_def_id, None) => {}\n \n                         ty::InstanceDef::FnPtrShim(_def_id, ty) |\n                         ty::InstanceDef::DropGlue(_def_id, Some(ty)) |\n-                        ty::InstanceDef::CloneShim(_def_id, ty) => {\n+                        ty::InstanceDef::CloneShim(_def_id, ty) |\n+                        ty::InstanceDef::FnPtrAddrShim(_def_id, ty) => {\n                             // FIXME(eddyb) use a better `TyContext` here.\n                             self.visit_ty($(& $mutability)? *ty, TyContext::Location(location));\n                         }\n@@ -608,6 +610,10 @@ macro_rules! make_mir_visitor {\n                     ResumedAfterReturn(_) | ResumedAfterPanic(_) => {\n                         // Nothing to visit\n                     }\n+                    MisalignedPointerDereference { required, found } => {\n+                        self.visit_operand(required, location);\n+                        self.visit_operand(found, location);\n+                    }\n                 }\n             }\n "}, {"sha": "4a096a2c0e840ca4dedbe1079136b2f55078fa40", "filename": "compiler/rustc_middle/src/query/keys.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fkeys.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::hir_id::{HirId, OwnerId};\n use rustc_query_system::query::{DefaultCacheSelector, SingleCacheSelector, VecCacheSelector};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi::FieldIdx;\n \n /// Placeholder for `CrateNum`'s \"local\" counterpart\n #[derive(Copy, Clone, Debug)]\n@@ -332,7 +333,7 @@ impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     }\n }\n \n-impl<'tcx> Key for (ty::Const<'tcx>, mir::Field) {\n+impl<'tcx> Key for (ty::Const<'tcx>, FieldIdx) {\n     type CacheSelector = DefaultCacheSelector<Self>;\n \n     fn default_span(&self, _: TyCtxt<'_>) -> Span {"}, {"sha": "82a7cf785173439daa484a8994bf19fda4984a96", "filename": "compiler/rustc_middle/src/thir.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fthir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fthir.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -17,14 +17,14 @@ use rustc_index::newtype_index;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::region;\n use rustc_middle::mir::interpret::AllocId;\n-use rustc_middle::mir::{self, BinOp, BorrowKind, FakeReadCause, Field, Mutability, UnOp};\n+use rustc_middle::mir::{self, BinOp, BorrowKind, FakeReadCause, Mutability, UnOp};\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtDef, FnSig, Ty, UpvarSubsts};\n use rustc_middle::ty::{CanonicalUserType, CanonicalUserTypeAnnotation};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n use std::fmt;\n use std::ops::Index;\n@@ -366,7 +366,7 @@ pub enum ExprKind<'tcx> {\n         /// Variant containing the field.\n         variant_index: VariantIdx,\n         /// This can be a named (`.foo`) or unnamed (`.0`) field.\n-        name: Field,\n+        name: FieldIdx,\n     },\n     /// A *non-overloaded* indexing operation.\n     Index {\n@@ -491,7 +491,7 @@ pub enum ExprKind<'tcx> {\n /// This is used in struct constructors.\n #[derive(Clone, Debug, HashStable)]\n pub struct FieldExpr {\n-    pub name: Field,\n+    pub name: FieldIdx,\n     pub expr: ExprId,\n }\n \n@@ -570,7 +570,7 @@ pub enum BindingMode {\n \n #[derive(Clone, Debug, HashStable)]\n pub struct FieldPat<'tcx> {\n-    pub field: Field,\n+    pub field: FieldIdx,\n     pub pattern: Box<Pat<'tcx>>,\n }\n \n@@ -784,7 +784,7 @@ impl<'tcx> fmt::Display for Pat<'tcx> {\n                             if let PatKind::Wild = p.pattern.kind {\n                                 continue;\n                             }\n-                            let name = variant.fields[p.field.index()].name;\n+                            let name = variant.fields[p.field].name;\n                             write!(f, \"{}{}: {}\", start_or_comma(), name, p.pattern)?;\n                             printed += 1;\n                         }"}, {"sha": "cd0f7e8daf1d6d64ccf714fd2c5e43e0cfb54b4b", "filename": "compiler/rustc_middle/src/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadjustment.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,6 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n+use rustc_target::abi::FieldIdx;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n pub enum PointerCast {\n@@ -208,5 +209,5 @@ pub struct CoerceUnsizedInfo {\n #[derive(Clone, Copy, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum CustomCoerceUnsized {\n     /// Records the index of the field being coerced.\n-    Struct(usize),\n+    Struct(FieldIdx),\n }"}, {"sha": "3a03c0901d798b22801e0c09d89f1b9ed5b8e0d9", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,11 +10,11 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::DataTypeKind;\n use rustc_span::symbol::sym;\n-use rustc_target::abi::{ReprOptions, VariantIdx};\n+use rustc_target::abi::{ReprOptions, VariantIdx, FIRST_VARIANT};\n \n use std::cell::RefCell;\n use std::cmp::Ordering;\n@@ -168,7 +168,7 @@ impl<'tcx> AdtDef<'tcx> {\n     }\n \n     #[inline]\n-    pub fn variants(self) -> &'tcx IndexVec<VariantIdx, VariantDef> {\n+    pub fn variants(self) -> &'tcx IndexSlice<VariantIdx, VariantDef> {\n         &self.0.0.variants\n     }\n \n@@ -228,7 +228,7 @@ impl AdtDefData {\n             AdtKind::Struct => AdtFlags::IS_STRUCT,\n         };\n \n-        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor.is_some() {\n+        if kind == AdtKind::Struct && variants[FIRST_VARIANT].ctor.is_some() {\n             flags |= AdtFlags::HAS_CTOR;\n         }\n \n@@ -357,7 +357,7 @@ impl<'tcx> AdtDef<'tcx> {\n     /// Asserts this is a struct or union and returns its unique variant.\n     pub fn non_enum_variant(self) -> &'tcx VariantDef {\n         assert!(self.is_struct() || self.is_union());\n-        &self.variant(VariantIdx::new(0))\n+        &self.variant(FIRST_VARIANT)\n     }\n \n     #[inline]\n@@ -493,7 +493,7 @@ impl<'tcx> AdtDef<'tcx> {\n \n     #[inline]\n     pub fn variant_range(self) -> Range<VariantIdx> {\n-        VariantIdx::new(0)..VariantIdx::new(self.variants().len())\n+        FIRST_VARIANT..self.variants().next_index()\n     }\n \n     /// Computes the discriminant value used by a specific variant."}, {"sha": "f29bf92b0ed9df01761d61a7a578a3c1c2f03526", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -158,12 +158,12 @@ impl<'tcx> CapturedPlace<'tcx> {\n         for proj in self.place.projections.iter() {\n             match proj.kind {\n                 HirProjectionKind::Field(idx, variant) => match ty.kind() {\n-                    ty::Tuple(_) => write!(&mut symbol, \"__{}\", idx).unwrap(),\n+                    ty::Tuple(_) => write!(&mut symbol, \"__{}\", idx.index()).unwrap(),\n                     ty::Adt(def, ..) => {\n                         write!(\n                             &mut symbol,\n                             \"__{}\",\n-                            def.variant(variant).fields[idx as usize].name.as_str(),\n+                            def.variant(variant).fields[idx].name.as_str(),\n                         )\n                         .unwrap();\n                     }\n@@ -356,11 +356,11 @@ pub fn place_to_string_for_capture<'tcx>(tcx: TyCtxt<'tcx>, place: &HirPlace<'tc\n                     curr_string = format!(\n                         \"{}.{}\",\n                         curr_string,\n-                        def.variant(variant).fields[idx as usize].name.as_str()\n+                        def.variant(variant).fields[idx].name.as_str()\n                     );\n                 }\n                 ty::Tuple(_) => {\n-                    curr_string = format!(\"{}.{}\", curr_string, idx);\n+                    curr_string = format!(\"{}.{}\", curr_string, idx.index());\n                 }\n                 _ => {\n                     bug!("}, {"sha": "8b96864ddd7c93b87007613a9b551f2f6e6e5445", "filename": "compiler/rustc_middle/src/ty/consts/valtree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fvaltree.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> ValTree<'tcx> {\n     }\n \n     pub fn try_to_target_usize(self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n-        self.try_to_scalar_int().map(|s| s.try_to_target_usize(tcx).ok()).flatten()\n+        self.try_to_scalar_int().and_then(|s| s.try_to_target_usize(tcx).ok())\n     }\n \n     /// Get the values inside the ValTree as a slice of bytes. This only works for"}, {"sha": "8d0aa622244cd9e9d8b9582dae53ea9cc5c9c71a", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -12,9 +12,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n-use crate::mir::{\n-    Body, BorrowCheckResult, Field, Local, Place, PlaceElem, ProjectionKind, Promoted,\n-};\n+use crate::mir::{Body, BorrowCheckResult, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::query::LocalCrate;\n use crate::thir::Thir;\n use crate::traits;\n@@ -65,7 +63,7 @@ use rustc_span::def_id::{DefPathHash, StableCrateId};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi::{Layout, LayoutS, TargetDataLayout, VariantIdx};\n+use rustc_target::abi::{FieldIdx, Layout, LayoutS, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n use rustc_type_ir::sty::TyKind::*;\n use rustc_type_ir::WithCachedTypeInfo;\n@@ -2125,7 +2123,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n+    pub fn mk_place_field(self, place: Place<'tcx>, f: FieldIdx, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.mk_place_elem(place, PlaceElem::Field(f, ty))\n     }\n "}, {"sha": "fb0d909307e78d3d4a8ba651e8b2f930d1591988", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,6 +4,8 @@ use crate::dep_graph::TaskDepsRef;\n use crate::ty::query;\n use rustc_data_structures::sync::{self, Lock};\n use rustc_errors::Diagnostic;\n+#[cfg(not(parallel_compiler))]\n+use std::cell::Cell;\n use std::mem;\n use std::ptr;\n use thin_vec::ThinVec;\n@@ -47,52 +49,15 @@ impl<'a, 'tcx> ImplicitCtxt<'a, 'tcx> {\n     }\n }\n \n+// Import the thread-local variable from Rayon, which is preserved for Rayon jobs.\n #[cfg(parallel_compiler)]\n-mod tlv {\n-    use rustc_rayon_core as rayon_core;\n-    use std::ptr;\n-\n-    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn get_tlv() -> *const () {\n-        ptr::from_exposed_addr(rayon_core::tlv::get())\n-    }\n-\n-    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n-    /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n-        rayon_core::tlv::with(value.expose_addr(), f)\n-    }\n-}\n+use rayon_core::tlv::TLV;\n \n+// Otherwise define our own\n #[cfg(not(parallel_compiler))]\n-mod tlv {\n-    use std::cell::Cell;\n-    use std::ptr;\n-\n-    thread_local! {\n-        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n-        static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n-    }\n-\n-    /// Gets the pointer to the current `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn get_tlv() -> *const () {\n-        TLV.with(|tlv| tlv.get())\n-    }\n-\n-    /// Sets TLV to `value` during the call to `f`.\n-    /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new `ImplicitCtxt`.\n-    #[inline]\n-    pub(super) fn with_tlv<F: FnOnce() -> R, R>(value: *const (), f: F) -> R {\n-        let old = TLV.replace(value);\n-        let _reset = rustc_data_structures::OnDrop(move || TLV.set(old));\n-        f()\n-    }\n+thread_local! {\n+    /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n+    static TLV: Cell<*const ()> = const { Cell::new(ptr::null()) };\n }\n \n #[inline]\n@@ -111,7 +76,11 @@ pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) ->\n where\n     F: FnOnce() -> R,\n {\n-    tlv::with_tlv(erase(context), f)\n+    TLV.with(|tlv| {\n+        let old = tlv.replace(erase(context));\n+        let _reset = rustc_data_structures::OnDrop(move || tlv.set(old));\n+        f()\n+    })\n }\n \n /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n@@ -120,7 +89,7 @@ pub fn with_context_opt<F, R>(f: F) -> R\n where\n     F: for<'a, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'tcx>>) -> R,\n {\n-    let context = tlv::get_tlv();\n+    let context = TLV.get();\n     if context.is_null() {\n         f(None)\n     } else {"}, {"sha": "31d00b65e984315037a6fa14649c5ba5e3680b18", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,6 +1,6 @@\n use crate::mir::Mutability;\n use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n+use crate::ty::{self, SubstsRef, Ty, TyCtxt, TypeVisitableExt};\n use rustc_hir::def_id::DefId;\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -188,22 +188,24 @@ pub struct DeepRejectCtxt {\n }\n \n impl DeepRejectCtxt {\n-    pub fn generic_args_may_unify<'tcx>(\n+    pub fn substs_refs_may_unify<'tcx>(\n         self,\n-        obligation_arg: ty::GenericArg<'tcx>,\n-        impl_arg: ty::GenericArg<'tcx>,\n+        obligation_substs: SubstsRef<'tcx>,\n+        impl_substs: SubstsRef<'tcx>,\n     ) -> bool {\n-        match (obligation_arg.unpack(), impl_arg.unpack()) {\n-            // We don't fast reject based on regions for now.\n-            (GenericArgKind::Lifetime(_), GenericArgKind::Lifetime(_)) => true,\n-            (GenericArgKind::Type(obl), GenericArgKind::Type(imp)) => {\n-                self.types_may_unify(obl, imp)\n-            }\n-            (GenericArgKind::Const(obl), GenericArgKind::Const(imp)) => {\n-                self.consts_may_unify(obl, imp)\n+        iter::zip(obligation_substs, impl_substs).all(|(obl, imp)| {\n+            match (obl.unpack(), imp.unpack()) {\n+                // We don't fast reject based on regions for now.\n+                (GenericArgKind::Lifetime(_), GenericArgKind::Lifetime(_)) => true,\n+                (GenericArgKind::Type(obl), GenericArgKind::Type(imp)) => {\n+                    self.types_may_unify(obl, imp)\n+                }\n+                (GenericArgKind::Const(obl), GenericArgKind::Const(imp)) => {\n+                    self.consts_may_unify(obl, imp)\n+                }\n+                _ => bug!(\"kind mismatch: {obl} {imp}\"),\n             }\n-            _ => bug!(\"kind mismatch: {obligation_arg} {impl_arg}\"),\n-        }\n+        })\n     }\n \n     pub fn types_may_unify<'tcx>(self, obligation_ty: Ty<'tcx>, impl_ty: Ty<'tcx>) -> bool {\n@@ -258,9 +260,7 @@ impl DeepRejectCtxt {\n             },\n             ty::Adt(obl_def, obl_substs) => match k {\n                 &ty::Adt(impl_def, impl_substs) => {\n-                    obl_def == impl_def\n-                        && iter::zip(obl_substs, impl_substs)\n-                            .all(|(obl, imp)| self.generic_args_may_unify(obl, imp))\n+                    obl_def == impl_def && self.substs_refs_may_unify(obl_substs, impl_substs)\n                 }\n                 _ => false,\n             },\n@@ -312,6 +312,7 @@ impl DeepRejectCtxt {\n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,\n \n+            // Placeholder types don't unify with anything on their own\n             ty::Placeholder(..) | ty::Bound(..) => false,\n \n             // Depending on the value of `treat_obligation_params`, we either\n@@ -321,6 +322,10 @@ impl DeepRejectCtxt {\n                 TreatParams::AsCandidateKey => true,\n             },\n \n+            ty::Infer(ty::IntVar(_)) => impl_ty.is_integral(),\n+\n+            ty::Infer(ty::FloatVar(_)) => impl_ty.is_floating_point(),\n+\n             ty::Infer(_) => true,\n \n             // As we're walking the whole type, it may encounter projections\n@@ -359,6 +364,9 @@ impl DeepRejectCtxt {\n                 TreatParams::AsCandidateKey => true,\n             },\n \n+            // Placeholder consts don't unify with anything on their own\n+            ty::ConstKind::Placeholder(_) => false,\n+\n             // As we don't necessarily eagerly evaluate constants,\n             // they might unify with any value.\n             ty::ConstKind::Expr(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n@@ -371,7 +379,7 @@ impl DeepRejectCtxt {\n \n             ty::ConstKind::Infer(_) => true,\n \n-            ty::ConstKind::Bound(..) | ty::ConstKind::Placeholder(_) => {\n+            ty::ConstKind::Bound(..) => {\n                 bug!(\"unexpected obl const: {:?}\", obligation_ct)\n             }\n         }"}, {"sha": "e73225f70ccca42d17d83d434af7df65cd8b118d", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -82,6 +82,11 @@ pub enum InstanceDef<'tcx> {\n     /// The `DefId` is the ID of the `call_once` method in `FnOnce`.\n     ClosureOnceShim { call_once: DefId, track_caller: bool },\n \n+    /// Compiler-generated accessor for thread locals which returns a reference to the thread local\n+    /// the `DefId` defines. This is used to export thread locals from dylibs on platforms lacking\n+    /// native support.\n+    ThreadLocalShim(DefId),\n+\n     /// `core::ptr::drop_in_place::<T>`.\n     ///\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n@@ -96,6 +101,13 @@ pub enum InstanceDef<'tcx> {\n     ///\n     /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n     CloneShim(DefId, Ty<'tcx>),\n+\n+    /// Compiler-generated `<T as FnPtr>::addr` implementation.\n+    ///\n+    /// Automatically generated for all potentially higher-ranked `fn(I) -> R` types.\n+    ///\n+    /// The `DefId` is for `FnPtr::addr`, the `Ty` is the type `T`.\n+    FnPtrAddrShim(DefId, Ty<'tcx>),\n }\n \n impl<'tcx> Instance<'tcx> {\n@@ -149,25 +161,30 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::FnPtrShim(def_id, _)\n             | InstanceDef::Virtual(def_id, _)\n             | InstanceDef::Intrinsic(def_id)\n+            | InstanceDef::ThreadLocalShim(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n             | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _) => def_id,\n+            | InstanceDef::CloneShim(def_id, _)\n+            | InstanceDef::FnPtrAddrShim(def_id, _) => def_id,\n         }\n     }\n \n     /// Returns the `DefId` of instances which might not require codegen locally.\n     pub fn def_id_if_not_guaranteed_local_codegen(self) -> Option<DefId> {\n         match self {\n             ty::InstanceDef::Item(def) => Some(def.did),\n-            ty::InstanceDef::DropGlue(def_id, Some(_)) => Some(def_id),\n+            ty::InstanceDef::DropGlue(def_id, Some(_)) | InstanceDef::ThreadLocalShim(def_id) => {\n+                Some(def_id)\n+            }\n             InstanceDef::VTableShim(..)\n             | InstanceDef::ReifyShim(..)\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::Virtual(..)\n             | InstanceDef::Intrinsic(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => None,\n+            | InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrAddrShim(..) => None,\n         }\n     }\n \n@@ -182,7 +199,9 @@ impl<'tcx> InstanceDef<'tcx> {\n             | InstanceDef::Intrinsic(def_id)\n             | InstanceDef::ClosureOnceShim { call_once: def_id, track_caller: _ }\n             | InstanceDef::DropGlue(def_id, _)\n-            | InstanceDef::CloneShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n+            | InstanceDef::CloneShim(def_id, _)\n+            | InstanceDef::ThreadLocalShim(def_id)\n+            | InstanceDef::FnPtrAddrShim(def_id, _) => ty::WithOptConstParam::unknown(def_id),\n         }\n     }\n \n@@ -205,6 +224,7 @@ impl<'tcx> InstanceDef<'tcx> {\n         let def_id = match *self {\n             ty::InstanceDef::Item(def) => def.did,\n             ty::InstanceDef::DropGlue(_, Some(_)) => return false,\n+            ty::InstanceDef::ThreadLocalShim(_) => return false,\n             _ => return true,\n         };\n         matches!(\n@@ -245,6 +265,9 @@ impl<'tcx> InstanceDef<'tcx> {\n                 )\n             });\n         }\n+        if let ty::InstanceDef::ThreadLocalShim(..) = *self {\n+            return false;\n+        }\n         tcx.codegen_fn_attrs(self.def_id()).requests_inline()\n     }\n \n@@ -268,6 +291,8 @@ impl<'tcx> InstanceDef<'tcx> {\n     pub fn has_polymorphic_mir_body(&self) -> bool {\n         match *self {\n             InstanceDef::CloneShim(..)\n+            | InstanceDef::ThreadLocalShim(..)\n+            | InstanceDef::FnPtrAddrShim(..)\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::DropGlue(_, Some(_)) => false,\n             InstanceDef::ClosureOnceShim { .. }\n@@ -299,13 +324,15 @@ fn fmt_instance(\n         InstanceDef::Item(_) => Ok(()),\n         InstanceDef::VTableShim(_) => write!(f, \" - shim(vtable)\"),\n         InstanceDef::ReifyShim(_) => write!(f, \" - shim(reify)\"),\n+        InstanceDef::ThreadLocalShim(_) => write!(f, \" - shim(tls)\"),\n         InstanceDef::Intrinsic(_) => write!(f, \" - intrinsic\"),\n         InstanceDef::Virtual(_, num) => write!(f, \" - virtual#{}\", num),\n         InstanceDef::FnPtrShim(_, ty) => write!(f, \" - shim({})\", ty),\n         InstanceDef::ClosureOnceShim { .. } => write!(f, \" - shim\"),\n         InstanceDef::DropGlue(_, None) => write!(f, \" - shim(None)\"),\n         InstanceDef::DropGlue(_, Some(ty)) => write!(f, \" - shim(Some({}))\", ty),\n         InstanceDef::CloneShim(_, ty) => write!(f, \" - shim({})\", ty),\n+        InstanceDef::FnPtrAddrShim(_, ty) => write!(f, \" - shim({})\", ty),\n     }\n }\n "}, {"sha": "0f70b315aa6ee10db8117de47607bc8a46092d81", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,6 @@ use crate::ty::{self, ReprOptions, Ty, TyCtxt, TypeVisitableExt};\n use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::Idx;\n use rustc_session::config::OptLevel;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n@@ -335,7 +334,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n \n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i| {\n-                    let i = VariantIdx::new(i);\n+                    let i = VariantIdx::from_usize(i);\n                     let fields =\n                         def.variant(i).fields.iter().map(|field| {\n                             SizeSkeleton::compute(field.ty(tcx, substs), tcx, param_env)\n@@ -798,7 +797,8 @@ where\n                 ty::Adt(def, substs) => {\n                     match this.variants {\n                         Variants::Single { index } => {\n-                            TyMaybeWithLayout::Ty(def.variant(index).fields[i].ty(tcx, substs))\n+                            let field = &def.variant(index).fields[FieldIdx::from_usize(i)];\n+                            TyMaybeWithLayout::Ty(field.ty(tcx, substs))\n                         }\n \n                         // Discriminant field for enums (where applicable)."}, {"sha": "800a230b6544faa370b7e9c03ede2807175d7241", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -50,7 +50,7 @@ pub use rustc_session::lint::RegisteredTools;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, ExpnKind, Span};\n-use rustc_target::abi::{Align, Integer, IntegerType, VariantIdx};\n+use rustc_target::abi::{Align, FieldIdx, Integer, IntegerType, VariantIdx};\n pub use rustc_target::abi::{ReprFlags, ReprOptions};\n use rustc_type_ir::WithCachedTypeInfo;\n pub use subst::*;\n@@ -653,8 +653,8 @@ pub enum AliasRelationDirection {\n impl std::fmt::Display for AliasRelationDirection {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         match self {\n-            AliasRelationDirection::Equate => write!(f, \" == \"),\n-            AliasRelationDirection::Subtype => write!(f, \" <: \"),\n+            AliasRelationDirection::Equate => write!(f, \"==\"),\n+            AliasRelationDirection::Subtype => write!(f, \"<:\"),\n         }\n     }\n }\n@@ -1891,7 +1891,7 @@ pub struct VariantDef {\n     /// Discriminant of this variant.\n     pub discr: VariantDiscr,\n     /// Fields of this variant.\n-    pub fields: Vec<FieldDef>,\n+    pub fields: IndexVec<FieldIdx, FieldDef>,\n     /// Flags of the variant (e.g. is field list non-exhaustive)?\n     flags: VariantFlags,\n }\n@@ -1918,7 +1918,7 @@ impl VariantDef {\n         variant_did: Option<DefId>,\n         ctor: Option<(CtorKind, DefId)>,\n         discr: VariantDiscr,\n-        fields: Vec<FieldDef>,\n+        fields: IndexVec<FieldIdx, FieldDef>,\n         adt_kind: AdtKind,\n         parent_did: DefId,\n         recovered: bool,\n@@ -2270,85 +2270,64 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n-        variant\n-            .fields\n-            .iter()\n-            .position(|field| self.hygienic_eq(ident, field.ident(self), variant.def_id))\n+    pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<FieldIdx> {\n+        variant.fields.iter_enumerated().find_map(|(i, field)| {\n+            self.hygienic_eq(ident, field.ident(self), variant.def_id).then_some(i)\n+        })\n     }\n \n     /// Returns `true` if the impls are the same polarity and the trait either\n     /// has no items or is annotated `#[marker]` and prevents item overrides.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn impls_are_allowed_to_overlap(\n         self,\n         def_id1: DefId,\n         def_id2: DefId,\n     ) -> Option<ImplOverlapKind> {\n+        let impl_trait_ref1 = self.impl_trait_ref(def_id1);\n+        let impl_trait_ref2 = self.impl_trait_ref(def_id2);\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.subst_identity().references_error())\n-            || self\n-                .impl_trait_ref(def_id2)\n-                .map_or(false, |tr| tr.subst_identity().references_error())\n+        if impl_trait_ref1.map_or(false, |tr| tr.subst_identity().references_error())\n+            || impl_trait_ref2.map_or(false, |tr| tr.subst_identity().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n \n         match (self.impl_polarity(def_id1), self.impl_polarity(def_id2)) {\n             (ImplPolarity::Reservation, _) | (_, ImplPolarity::Reservation) => {\n                 // `#[rustc_reservation_impl]` impls don't overlap with anything\n-                debug!(\n-                    \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (reservations)\",\n-                    def_id1, def_id2\n-                );\n                 return Some(ImplOverlapKind::Permitted { marker: false });\n             }\n             (ImplPolarity::Positive, ImplPolarity::Negative)\n             | (ImplPolarity::Negative, ImplPolarity::Positive) => {\n                 // `impl AutoTrait for Type` + `impl !AutoTrait for Type`\n-                debug!(\n-                    \"impls_are_allowed_to_overlap({:?}, {:?}) - None (differing polarities)\",\n-                    def_id1, def_id2\n-                );\n                 return None;\n             }\n             (ImplPolarity::Positive, ImplPolarity::Positive)\n             | (ImplPolarity::Negative, ImplPolarity::Negative) => {}\n         };\n \n         let is_marker_overlap = {\n-            let is_marker_impl = |def_id: DefId| -> bool {\n-                let trait_ref = self.impl_trait_ref(def_id);\n+            let is_marker_impl = |trait_ref: Option<EarlyBinder<TraitRef<'_>>>| -> bool {\n                 trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n-            is_marker_impl(def_id1) && is_marker_impl(def_id2)\n+            is_marker_impl(impl_trait_ref1) && is_marker_impl(impl_trait_ref2)\n         };\n \n         if is_marker_overlap {\n-            debug!(\n-                \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (marker overlap)\",\n-                def_id1, def_id2\n-            );\n             Some(ImplOverlapKind::Permitted { marker: true })\n         } else {\n             if let Some(self_ty1) = self.issue33140_self_ty(def_id1) {\n                 if let Some(self_ty2) = self.issue33140_self_ty(def_id2) {\n                     if self_ty1 == self_ty2 {\n-                        debug!(\n-                            \"impls_are_allowed_to_overlap({:?}, {:?}) - issue #33140 HACK\",\n-                            def_id1, def_id2\n-                        );\n                         return Some(ImplOverlapKind::Issue33140);\n                     } else {\n-                        debug!(\n-                            \"impls_are_allowed_to_overlap({:?}, {:?}) - found {:?} != {:?}\",\n-                            def_id1, def_id2, self_ty1, self_ty2\n-                        );\n+                        debug!(\"found {self_ty1:?} != {self_ty2:?}\");\n                     }\n                 }\n             }\n \n-            debug!(\"impls_are_allowed_to_overlap({:?}, {:?}) = None\", def_id1, def_id2);\n             None\n         }\n     }\n@@ -2405,7 +2384,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             | ty::InstanceDef::Virtual(..)\n             | ty::InstanceDef::ClosureOnceShim { .. }\n             | ty::InstanceDef::DropGlue(..)\n-            | ty::InstanceDef::CloneShim(..) => self.mir_shims(instance),\n+            | ty::InstanceDef::CloneShim(..)\n+            | ty::InstanceDef::ThreadLocalShim(..)\n+            | ty::InstanceDef::FnPtrAddrShim(..) => self.mir_shims(instance),\n         }\n     }\n "}, {"sha": "d4f058440b954ba179a5d63ce331426c9995ce71", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,7 +4,7 @@\n //! to help with the tedium.\n \n use crate::mir::interpret;\n-use crate::mir::{Field, ProjectionKind};\n+use crate::mir::ProjectionKind;\n use crate::ty::fold::{FallibleTypeFolder, TypeFoldable, TypeSuperFoldable};\n use crate::ty::print::{with_no_trimmed_paths, FmtPrinter, Printer};\n use crate::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor};\n@@ -217,6 +217,7 @@ CloneLiftImpls! {\n // implementation and traversal implementations (the latter only for\n // TyCtxt<'_> interners).\n TrivialTypeTraversalAndLiftImpls! {\n+    ::rustc_target::abi::FieldIdx,\n     ::rustc_target::abi::VariantIdx,\n     crate::middle::region::Scope,\n     crate::ty::FloatTy,\n@@ -268,7 +269,6 @@ TrivialTypeTraversalAndLiftImpls! {\n     ::rustc_span::Span,\n     ::rustc_span::symbol::Ident,\n     ::rustc_errors::ErrorGuaranteed,\n-    Field,\n     interpret::Scalar,\n     rustc_target::abi::Size,\n     ty::BoundVar,"}, {"sha": "5ea77833af25522fc6553d483dc85d7e84cfc907", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -22,7 +22,7 @@ use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};\n use rustc_target::spec::abi::{self, Abi};\n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -517,8 +517,7 @@ impl<'tcx> GeneratorSubsts<'tcx> {\n     #[inline]\n     pub fn variant_range(&self, def_id: DefId, tcx: TyCtxt<'tcx>) -> Range<VariantIdx> {\n         // FIXME requires optimized MIR\n-        let num_variants = tcx.generator_layout(def_id).unwrap().variant_fields.len();\n-        VariantIdx::new(0)..VariantIdx::new(num_variants)\n+        FIRST_VARIANT..tcx.generator_layout(def_id).unwrap().variant_fields.next_index()\n     }\n \n     /// The discriminant for the given variant. Panics if the `variant_index` is\n@@ -1904,7 +1903,7 @@ impl<'tcx> Ty<'tcx> {\n             Adt(def, substs) => {\n                 assert!(def.repr().simd(), \"`simd_size_and_type` called on non-SIMD type\");\n                 let variant = def.non_enum_variant();\n-                let f0_ty = variant.fields[0].ty(tcx, substs);\n+                let f0_ty = variant.fields[FieldIdx::from_u32(0)].ty(tcx, substs);\n \n                 match f0_ty.kind() {\n                     // If the first field is an array, we assume it is the only field and its"}, {"sha": "47943b94c3b18b883029efceeb92f2669f779f9c", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -25,6 +25,7 @@ use rustc_macros::HashStable;\n use rustc_middle::mir::FakeReadCause;\n use rustc_session::Session;\n use rustc_span::Span;\n+use rustc_target::abi::FieldIdx;\n use std::{collections::hash_map::Entry, hash::Hash, iter};\n \n use super::RvalueScopes;\n@@ -42,7 +43,7 @@ pub struct TypeckResults<'tcx> {\n     /// or patterns (`S { field }`). The index is often useful by itself, but to learn more\n     /// about the field you also need definition of the variant to which the field\n     /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n-    field_indices: ItemLocalMap<usize>,\n+    field_indices: ItemLocalMap<FieldIdx>,\n \n     /// Stores the types for various nodes in the AST. Note that this table\n     /// is not guaranteed to be populated outside inference. See\n@@ -313,19 +314,19 @@ impl<'tcx> TypeckResults<'tcx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.type_dependent_defs }\n     }\n \n-    pub fn field_indices(&self) -> LocalTableInContext<'_, usize> {\n+    pub fn field_indices(&self) -> LocalTableInContext<'_, FieldIdx> {\n         LocalTableInContext { hir_owner: self.hir_owner, data: &self.field_indices }\n     }\n \n-    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, usize> {\n+    pub fn field_indices_mut(&mut self) -> LocalTableInContextMut<'_, FieldIdx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n     }\n \n-    pub fn field_index(&self, id: hir::HirId) -> usize {\n+    pub fn field_index(&self, id: hir::HirId) -> FieldIdx {\n         self.field_indices().get(id).cloned().expect(\"no index for a field\")\n     }\n \n-    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n+    pub fn opt_field_index(&self, id: hir::HirId) -> Option<FieldIdx> {\n         self.field_indices().get(id).cloned()\n     }\n "}, {"sha": "4411bcd927d7198b8f3cb098f45dace9ccb932ff", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -19,7 +19,8 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_macros::HashStable;\n-use rustc_span::{sym, DUMMY_SP};\n+use rustc_session::Limit;\n+use rustc_span::sym;\n use rustc_target::abi::{Integer, IntegerType, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n@@ -225,17 +226,20 @@ impl<'tcx> TyCtxt<'tcx> {\n         let recursion_limit = self.recursion_limit();\n         for iteration in 0.. {\n             if !recursion_limit.value_within_limit(iteration) {\n-                return self.ty_error_with_message(\n-                    DUMMY_SP,\n-                    &format!(\"reached the recursion limit finding the struct tail for {}\", ty),\n-                );\n+                let suggested_limit = match recursion_limit {\n+                    Limit(0) => Limit(2),\n+                    limit => limit * 2,\n+                };\n+                let reported =\n+                    self.sess.emit_err(crate::error::RecursionLimitReached { ty, suggested_limit });\n+                return self.ty_error(reported);\n             }\n             match *ty.kind() {\n                 ty::Adt(def, substs) => {\n                     if !def.is_struct() {\n                         break;\n                     }\n-                    match def.non_enum_variant().fields.last() {\n+                    match def.non_enum_variant().fields.raw.last() {\n                         Some(field) => {\n                             f();\n                             ty = field.ty(self, substs);\n@@ -309,7 +313,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 (&ty::Adt(a_def, a_substs), &ty::Adt(b_def, b_substs))\n                     if a_def == b_def && a_def.is_struct() =>\n                 {\n-                    if let Some(f) = a_def.non_enum_variant().fields.last() {\n+                    if let Some(f) = a_def.non_enum_variant().fields.raw.last() {\n                         a = f.ty(self, a_substs);\n                         b = f.ty(self, b_substs);\n                     } else {\n@@ -597,6 +601,28 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.static_mutability(def_id) == Some(hir::Mutability::Mut)\n     }\n \n+    /// Returns `true` if the item pointed to by `def_id` is a thread local which needs a\n+    /// thread local shim generated.\n+    #[inline]\n+    pub fn needs_thread_local_shim(self, def_id: DefId) -> bool {\n+        !self.sess.target.dll_tls_export\n+            && self.is_thread_local_static(def_id)\n+            && !self.is_foreign_item(def_id)\n+    }\n+\n+    /// Returns the type a reference to the thread local takes in MIR.\n+    pub fn thread_local_ptr_ty(self, def_id: DefId) -> Ty<'tcx> {\n+        let static_ty = self.type_of(def_id).subst_identity();\n+        if self.is_mutable_static(def_id) {\n+            self.mk_mut_ptr(static_ty)\n+        } else if self.is_foreign_item(def_id) {\n+            self.mk_imm_ptr(static_ty)\n+        } else {\n+            // FIXME: These things don't *really* have 'static lifetime.\n+            self.mk_imm_ref(self.lifetimes.re_static, static_ty)\n+        }\n+    }\n+\n     /// Get the type of the pointer to the static that we use in MIR.\n     pub fn static_ptr_ty(self, def_id: DefId) -> Ty<'tcx> {\n         // Make sure that any constants in the static's type are evaluated."}, {"sha": "fcc7cbe0715f525c31a499d5c737e74a23f3e1bb", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -331,6 +331,10 @@ mir_build_indirect_structural_match =\n mir_build_nontrivial_structural_match =\n     to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n+mir_build_type_not_structural_tip = the traits must be derived, manual `impl`s are not sufficient\n+\n+mir_build_type_not_structural_more_info = see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n+\n mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpoints\n     .range = ... with this range\n     .note = you likely meant to write mutually exclusive ranges"}, {"sha": "d385153ba94c52c9974d4f02706eaddc5205e96a", "filename": "compiler/rustc_mir_build/src/build/custom/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -21,7 +21,7 @@ use rustc_ast::Attribute;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::{\n     mir::*,\n     thir::*,\n@@ -37,7 +37,7 @@ pub(super) fn build_custom_mir<'tcx>(\n     hir_id: HirId,\n     thir: &Thir<'tcx>,\n     expr: ExprId,\n-    params: &IndexVec<ParamId, Param<'tcx>>,\n+    params: &IndexSlice<ParamId, Param<'tcx>>,\n     return_ty: Ty<'tcx>,\n     return_ty_span: Span,\n     span: Span,\n@@ -49,7 +49,7 @@ pub(super) fn build_custom_mir<'tcx>(\n         phase: MirPhase::Built,\n         source_scopes: IndexVec::new(),\n         generator: None,\n-        local_decls: LocalDecls::new(),\n+        local_decls: IndexVec::new(),\n         user_type_annotations: IndexVec::new(),\n         arg_count: params.len(),\n         spread_arg: None,"}, {"sha": "12b2f5d8077745540962c6002efbb25b545726c0", "filename": "compiler/rustc_mir_build/src/build/custom/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,4 +1,4 @@\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::{mir::*, thir::*, ty::Ty};\n use rustc_span::Span;\n \n@@ -81,7 +81,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n         }\n     }\n \n-    pub fn parse_args(&mut self, params: &IndexVec<ParamId, Param<'tcx>>) -> PResult<()> {\n+    pub fn parse_args(&mut self, params: &IndexSlice<ParamId, Param<'tcx>>) -> PResult<()> {\n         for param in params.iter() {\n             let (var, span) = {\n                 let pat = param.pat.as_ref().unwrap();"}, {"sha": "33b73928704a0e23936780a99881477d34d26688", "filename": "compiler/rustc_mir_build/src/build/custom/parse/instruction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fcustom%2Fparse%2Finstruction.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::ty::cast::mir_cast_kind;\n use rustc_middle::{mir::*, thir::*, ty};\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n \n use crate::build::custom::ParseError;\n use crate::build::expr::as_constant::as_constant_inner;\n@@ -185,7 +185,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n             },\n             ExprKind::Adt(box AdtExpr{ adt_def, variant_index, substs, fields, .. }) => {\n                 let is_union = adt_def.is_union();\n-                let active_field_index = is_union.then(|| fields[0].name.index());\n+                let active_field_index = is_union.then(|| fields[0].name);\n \n                 Ok(Rvalue::Aggregate(\n                     Box::new(AggregateKind::Adt(adt_def.did(), *variant_index, substs, None, active_field_index)),\n@@ -223,7 +223,7 @@ impl<'tcx, 'body> ParseCtxt<'tcx, 'body> {\n         let (parent, proj) = parse_by_kind!(self, expr_id, expr, \"place\",\n             @call(\"mir_field\", args) => {\n                 let (parent, ty) = self.parse_place_inner(args[0])?;\n-                let field = Field::from_u32(self.parse_integer_literal(args[1])? as u32);\n+                let field = FieldIdx::from_u32(self.parse_integer_literal(args[1])? as u32);\n                 let field_ty = ty.field_ty(self.tcx, field);\n                 let proj = PlaceElem::Field(field, field_ty);\n                 let place = parent.project_deeper(&[proj], self.tcx);"}, {"sha": "99291740ac82f39b6129320a08684bf759cbb64a", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -62,21 +62,21 @@ pub fn as_constant_inner<'tcx>(\n             Constant { span, user_ty: None, literal }\n         }\n         ExprKind::NonHirLiteral { lit, ref user_ty } => {\n-            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n+            let user_ty = user_ty.as_ref().and_then(push_cuta);\n \n             let literal = ConstantKind::Val(ConstValue::Scalar(Scalar::Int(lit)), ty);\n \n             Constant { span, user_ty, literal }\n         }\n         ExprKind::ZstLiteral { ref user_ty } => {\n-            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n+            let user_ty = user_ty.as_ref().and_then(push_cuta);\n \n             let literal = ConstantKind::Val(ConstValue::ZeroSized, ty);\n \n             Constant { span, user_ty, literal }\n         }\n         ExprKind::NamedConst { def_id, substs, ref user_ty } => {\n-            let user_ty = user_ty.as_ref().map(push_cuta).flatten();\n+            let user_ty = user_ty.as_ref().and_then(push_cuta);\n \n             let uneval = mir::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n             let literal = ConstantKind::Unevaluated(uneval, ty);"}, {"sha": "fb775766c654101198be466400f1ce35d3299f3c", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -13,9 +13,7 @@ use rustc_middle::thir::*;\n use rustc_middle::ty::AdtDef;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty, Variance};\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n-\n-use rustc_index::vec::Idx;\n+use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};\n \n use std::assert_matches::assert_matches;\n use std::iter;\n@@ -91,8 +89,8 @@ fn convert_to_hir_projections_and_truncate_for_capture(\n         let hir_projection = match mir_projection {\n             ProjectionElem::Deref => HirProjectionKind::Deref,\n             ProjectionElem::Field(field, _) => {\n-                let variant = variant.unwrap_or(VariantIdx::new(0));\n-                HirProjectionKind::Field(field.index() as u32, variant)\n+                let variant = variant.unwrap_or(FIRST_VARIANT);\n+                HirProjectionKind::Field(*field, variant)\n             }\n             ProjectionElem::Downcast(.., idx) => {\n                 // We don't expect to see multi-variant enums here, as earlier\n@@ -295,7 +293,7 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         &self.projection\n     }\n \n-    pub(crate) fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n+    pub(crate) fn field(self, f: FieldIdx, ty: Ty<'tcx>) -> Self {\n         self.project(PlaceElem::Field(f, ty))\n     }\n "}, {"sha": "baa12ec11c3217994f68f794ef8a1510153bc409", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,8 +1,8 @@\n //! See docs in `build/expr/mod.rs`.\n \n-use rustc_index::vec::Idx;\n+use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_target::abi::{Abi, Primitive};\n+use rustc_target::abi::{Abi, FieldIdx, Primitive};\n \n use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -326,7 +326,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 // first process the set of fields\n                 let el_ty = expr.ty.sequence_element_type(this.tcx);\n-                let fields: Vec<_> = fields\n+                let fields: IndexVec<FieldIdx, _> = fields\n                     .into_iter()\n                     .copied()\n                     .map(|f| {\n@@ -347,7 +347,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Tuple { ref fields } => {\n                 // see (*) above\n                 // first process the set of fields\n-                let fields: Vec<_> = fields\n+                let fields: IndexVec<FieldIdx, _> = fields\n                     .into_iter()\n                     .copied()\n                     .map(|f| {\n@@ -401,7 +401,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 }\n \n                 // see (*) above\n-                let operands: Vec<_> = upvars\n+                let operands: IndexVec<FieldIdx, _> = upvars\n                     .into_iter()\n                     .copied()\n                     .map(|upvar| {\n@@ -553,8 +553,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     result_value,\n                     Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n                 );\n-                let val_fld = Field::new(0);\n-                let of_fld = Field::new(1);\n+                let val_fld = FieldIdx::new(0);\n+                let of_fld = FieldIdx::new(1);\n \n                 let tcx = self.tcx;\n                 let val = tcx.mk_place_field(result_value, val_fld, ty);\n@@ -568,7 +568,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n                 // For an unsigned RHS, the shift is in-range for `rhs < bits`.\n                 // For a signed RHS, `IntToInt` cast to the equivalent unsigned\n-                // type and do that same comparison.  Because the type is the\n+                // type and do that same comparison. Because the type is the\n                 // same size, there's no negative shift amount that ends up\n                 // overlapping with valid ones, thus it catches negatives too.\n                 let (lhs_size, _) = ty.int_size_and_signed(self.tcx);\n@@ -709,7 +709,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             this.record_operands_moved(&[value_operand]);\n         }\n-        block.and(Rvalue::Aggregate(Box::new(AggregateKind::Array(elem_ty)), Vec::new()))\n+        block.and(Rvalue::Aggregate(Box::new(AggregateKind::Array(elem_ty)), IndexVec::new()))\n     }\n \n     fn limit_capture_mutability("}, {"sha": "8efaba1f602e0d96846de48ce95647e693be8b76", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,7 +6,6 @@ use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n-use rustc_index::vec::Idx;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n@@ -319,7 +318,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // See the notes for `ExprKind::Array` in `as_rvalue` and for\n                 // `ExprKind::Borrow` above.\n                 let is_union = adt_def.is_union();\n-                let active_field_index = is_union.then(|| fields[0].name.index());\n+                let active_field_index = is_union.then(|| fields[0].name);\n \n                 let scope = this.local_scope();\n \n@@ -343,10 +342,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     })\n                     .collect();\n \n-                let field_names: Vec<_> =\n-                    (0..adt_def.variant(variant_index).fields.len()).map(Field::new).collect();\n+                let field_names = adt_def.variant(variant_index).fields.indices();\n \n-                let fields: Vec<_> = if let Some(FruInfo { base, field_types }) = base {\n+                let fields = if let Some(FruInfo { base, field_types }) = base {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*base]));\n \n@@ -363,7 +361,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         })\n                         .collect()\n                 } else {\n-                    field_names.iter().filter_map(|n| fields_map.get(n).cloned()).collect()\n+                    field_names.filter_map(|n| fields_map.get(&n).cloned()).collect()\n                 };\n \n                 let inferred_ty = expr.ty;"}, {"sha": "ac645cce5c6aac36c7f96f21a52b8b22735928d8", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::{GeneratorKind, Node};\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::middle::region;\n@@ -25,6 +25,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_span::Symbol;\n+use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi;\n \n use super::lints;\n@@ -793,7 +794,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let mutability = captured_place.mutability;\n \n                 let mut projs = closure_env_projs.clone();\n-                projs.push(ProjectionElem::Field(Field::new(i), ty));\n+                projs.push(ProjectionElem::Field(FieldIdx::new(i), ty));\n                 match capture {\n                     ty::UpvarCapture::ByValue => {}\n                     ty::UpvarCapture::ByRef(..) => {\n@@ -820,7 +821,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn args_and_body(\n         &mut self,\n         mut block: BasicBlock,\n-        arguments: &IndexVec<ParamId, Param<'tcx>>,\n+        arguments: &IndexSlice<ParamId, Param<'tcx>>,\n         argument_scope: region::Scope,\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {"}, {"sha": "25af221bf369b9b7715305a08532eea79856d37d", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -86,7 +86,7 @@ use std::mem;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::thir::{Expr, LintLevel};\n@@ -360,7 +360,7 @@ impl DropTree {\n     fn link_blocks<'tcx>(\n         &self,\n         cfg: &mut CFG<'tcx>,\n-        blocks: &IndexVec<DropIdx, Option<BasicBlock>>,\n+        blocks: &IndexSlice<DropIdx, Option<BasicBlock>>,\n     ) {\n         for (drop_idx, drop_data) in self.drops.iter_enumerated().rev() {\n             let Some(block) = blocks[drop_idx] else { continue };"}, {"sha": "cbfca77bd25d3b1a3336f7abfd0f6f13e72c31d6", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -663,6 +663,8 @@ pub struct UnionPattern {\n \n #[derive(Diagnostic)]\n #[diag(mir_build_type_not_structural)]\n+#[note(mir_build_type_not_structural_tip)]\n+#[note(mir_build_type_not_structural_more_info)]\n pub struct TypeNotStructural<'tcx> {\n     #[primary_span]\n     pub span: Span,\n@@ -695,12 +697,16 @@ pub struct PointerPattern;\n \n #[derive(LintDiagnostic)]\n #[diag(mir_build_indirect_structural_match)]\n+#[note(mir_build_type_not_structural_tip)]\n+#[note(mir_build_type_not_structural_more_info)]\n pub struct IndirectStructuralMatch<'tcx> {\n     pub non_sm_ty: Ty<'tcx>,\n }\n \n #[derive(LintDiagnostic)]\n #[diag(mir_build_nontrivial_structural_match)]\n+#[note(mir_build_type_not_structural_tip)]\n+#[note(mir_build_type_not_structural_more_info)]\n pub struct NontrivialStructuralMatch<'tcx> {\n     pub non_sm_ty: Ty<'tcx>,\n }"}, {"sha": "3f9236c9dd94ca4826e160852e9d371d31253f66", "filename": "compiler/rustc_mir_build/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,7 +8,6 @@\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n-#![feature(once_cell)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "8e2e92e6f6a9478a1a576eeba0d16ac6ea1ba2c4", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::hir::place::PlaceBase as HirPlaceBase;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n-use rustc_middle::mir::{self, BinOp, BorrowKind, Field, UnOp};\n+use rustc_middle::mir::{self, BinOp, BorrowKind, UnOp};\n use rustc_middle::thir::*;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -20,7 +20,7 @@ use rustc_middle::ty::{\n     self, AdtKind, InlineConstSubsts, InlineConstSubstsParts, ScalarInt, Ty, UpvarSubsts, UserType,\n };\n use rustc_span::{sym, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n \n impl<'tcx> Cx<'tcx> {\n     pub(crate) fn mirror_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) -> ExprId {\n@@ -357,7 +357,7 @@ impl<'tcx> Cx<'tcx> {\n                                 Res::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) => {\n                                     Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id)))\n                                 }\n-                                Res::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n+                                Res::SelfCtor(..) => Some((adt_def, FIRST_VARIANT)),\n                                 _ => None,\n                             })\n                         } else {\n@@ -379,7 +379,7 @@ impl<'tcx> Cx<'tcx> {\n                             .iter()\n                             .enumerate()\n                             .map(|(idx, e)| FieldExpr {\n-                                name: Field::new(idx),\n+                                name: FieldIdx::new(idx),\n                                 expr: self.mirror_expr(e),\n                             })\n                             .collect();\n@@ -510,7 +510,7 @@ impl<'tcx> Cx<'tcx> {\n                         debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                         ExprKind::Adt(Box::new(AdtExpr {\n                             adt_def: *adt,\n-                            variant_index: VariantIdx::new(0),\n+                            variant_index: FIRST_VARIANT,\n                             substs,\n                             user_ty,\n                             fields: self.field_refs(fields),\n@@ -732,8 +732,8 @@ impl<'tcx> Cx<'tcx> {\n             }\n             hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n                 lhs: self.mirror_expr(source),\n-                variant_index: VariantIdx::new(0),\n-                name: Field::new(self.typeck_results.field_index(expr.hir_id)),\n+                variant_index: FIRST_VARIANT,\n+                name: self.typeck_results.field_index(expr.hir_id),\n             },\n             hir::ExprKind::Cast(ref source, ref cast_ty) => {\n                 // Check for a user-given type annotation on this `cast`\n@@ -1053,7 +1053,7 @@ impl<'tcx> Cx<'tcx> {\n                 HirProjectionKind::Field(field, variant_index) => ExprKind::Field {\n                     lhs: self.thir.exprs.push(captured_place_expr),\n                     variant_index,\n-                    name: Field::new(field as usize),\n+                    name: field,\n                 },\n                 HirProjectionKind::Index | HirProjectionKind::Subslice => {\n                     // We don't capture these projections, so we can ignore them here\n@@ -1107,7 +1107,7 @@ impl<'tcx> Cx<'tcx> {\n         fields\n             .iter()\n             .map(|field| FieldExpr {\n-                name: Field::new(self.typeck_results.field_index(field.hir_id)),\n+                name: self.typeck_results.field_index(field.hir_id),\n                 expr: self.mirror_expr(field.expr),\n             })\n             .collect()"}, {"sha": "2dbef740d1a6e290dd77ea1c8ff25478ad8e3278", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,11 +2,12 @@ use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n-use rustc_middle::mir::{self, Field};\n+use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n+use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n \n@@ -218,7 +219,7 @@ impl<'tcx> ConstToPat<'tcx> {\n     ) -> Result<Vec<FieldPat<'tcx>>, FallbackToConstRef> {\n         vals.enumerate()\n             .map(|(idx, val)| {\n-                let field = Field::new(idx);\n+                let field = FieldIdx::new(idx);\n                 Ok(FieldPat { field, pattern: self.recur(val, false)? })\n             })\n             .collect()"}, {"sha": "e619e095496bc60548a20b87cfc37abe3119cf15", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -53,14 +53,14 @@ use smallvec::{smallvec, SmallVec};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::{HirId, RangeEnd};\n use rustc_index::vec::Idx;\n-use rustc_middle::mir::{self, Field};\n+use rustc_middle::mir;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, TyCtxt, VariantDef};\n use rustc_middle::{middle::stability::EvalResult, mir::interpret::ConstValue};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_target::abi::{Integer, Size, VariantIdx};\n+use rustc_target::abi::{FieldIdx, Integer, Size, VariantIdx, FIRST_VARIANT};\n \n use self::Constructor::*;\n use self::SliceKind::*;\n@@ -706,7 +706,7 @@ impl<'tcx> Constructor<'tcx> {\n             Variant(idx) => idx,\n             Single => {\n                 assert!(!adt.is_enum());\n-                VariantIdx::new(0)\n+                FIRST_VARIANT\n             }\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n@@ -1126,7 +1126,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n /// Note that the number of fields of a constructor may not match the fields declared in the\n /// original struct/variant. This happens if a private or `non_exhaustive` field is uninhabited,\n /// because the code mustn't observe that it is uninhabited. In that case that field is not\n-/// included in `fields`. For that reason, when you have a `mir::Field` you must use\n+/// included in `fields`. For that reason, when you have a `FieldIdx` you must use\n /// `index_with_declared_idx`.\n #[derive(Debug, Clone, Copy)]\n pub(super) struct Fields<'p, 'tcx> {\n@@ -1165,7 +1165,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         cx: &'a MatchCheckCtxt<'p, 'tcx>,\n         ty: Ty<'tcx>,\n         variant: &'a VariantDef,\n-    ) -> impl Iterator<Item = (Field, Ty<'tcx>)> + Captures<'a> + Captures<'p> {\n+    ) -> impl Iterator<Item = (FieldIdx, Ty<'tcx>)> + Captures<'a> + Captures<'p> {\n         let ty::Adt(adt, substs) = ty.kind() else { bug!() };\n         // Whether we must not match the fields of this variant exhaustively.\n         let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did().is_local();\n@@ -1180,7 +1180,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             if is_uninhabited && (!is_visible || is_non_exhaustive) {\n                 None\n             } else {\n-                Some((Field::new(i), ty))\n+                Some((FieldIdx::new(i), ty))\n             }\n         })\n     }\n@@ -1438,7 +1438,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 ty::Tuple(..) => PatKind::Leaf {\n                     subpatterns: subpatterns\n                         .enumerate()\n-                        .map(|(i, pattern)| FieldPat { field: Field::new(i), pattern })\n+                        .map(|(i, pattern)| FieldPat { field: FieldIdx::new(i), pattern })\n                         .collect(),\n                 },\n                 ty::Adt(adt_def, _) if adt_def.is_box() => {"}, {"sha": "9ac92f6e0a611ec90bca4704a366f1de2bd29ec8", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -21,12 +21,13 @@ use rustc_middle::mir::interpret::{\n     ConstValue, ErrorHandled, LitToConstError, LitToConstInput, Scalar,\n };\n use rustc_middle::mir::{self, UserTypeProjection};\n-use rustc_middle::mir::{BorrowKind, Field, Mutability};\n+use rustc_middle::mir::{BorrowKind, Mutability};\n use rustc_middle::thir::{Ascription, BindingMode, FieldPat, LocalVarId, Pat, PatKind, PatRange};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n use rustc_middle::ty::{self, AdtDef, ConstKind, Region, Ty, TyCtxt, UserType};\n use rustc_span::{Span, Symbol};\n+use rustc_target::abi::FieldIdx;\n \n use std::cmp::Ordering;\n \n@@ -356,7 +357,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let subpatterns = fields\n                     .iter()\n                     .map(|field| FieldPat {\n-                        field: Field::new(self.typeck_results.field_index(field.hir_id)),\n+                        field: self.typeck_results.field_index(field.hir_id),\n                         pattern: self.lower_pattern(&field.pat),\n                     })\n                     .collect();\n@@ -379,7 +380,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         pats.iter()\n             .enumerate_and_adjust(expected_len, gap_pos)\n             .map(|(i, subpattern)| FieldPat {\n-                field: Field::new(i),\n+                field: FieldIdx::new(i),\n                 pattern: self.lower_pattern(subpattern),\n             })\n             .collect()\n@@ -723,7 +724,7 @@ macro_rules! ClonePatternFoldableImpls {\n }\n \n ClonePatternFoldableImpls! { <'tcx>\n-    Span, Field, Mutability, Symbol, LocalVarId, usize,\n+    Span, FieldIdx, Mutability, Symbol, LocalVarId, usize,\n     Region<'tcx>, Ty<'tcx>, BindingMode, AdtDef<'tcx>,\n     SubstsRef<'tcx>, &'tcx GenericArg<'tcx>, UserType<'tcx>,\n     UserTypeProjection, CanonicalUserTypeAnnotation<'tcx>"}, {"sha": "9edd7967e7a4a01e08e1b91d54a5adbaf056768e", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -300,6 +300,7 @@ use rustc_arena::TypedArena;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n+use rustc_hir::Node;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::{Span, DUMMY_SP};\n@@ -867,6 +868,8 @@ fn is_useful<'p, 'tcx>(\n                     &ctor,\n                     Constructor::Missing { nonexhaustive_enum_missing_real_variants: true }\n                 )\n+                // We don't want to lint patterns which are function arguments or locals\n+                && !matches!(cx.tcx.hir().find_parent(hir_id), Some(Node::Param(_)|Node::Local(_)))\n             {\n                 let patterns = {\n                     let mut split_wildcard = SplitWildcard::new(pcx);"}, {"sha": "7ef3d41ac48c4fa1e05493c89afed510eaef3601", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 68, "deletions": 32, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::traits::Reveal;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};\n use std::{fmt, iter};\n \n /// The value of an inserted drop flag.\n@@ -129,7 +129,7 @@ pub trait DropElaborator<'a, 'tcx>: fmt::Debug {\n     /// Returns the subpath of a field of `path` (or `None` if there is no dedicated subpath).\n     ///\n     /// If this returns `None`, `field` will not get a dedicated drop flag.\n-    fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path>;\n+    fn field_subpath(&self, path: Self::Path, field: FieldIdx) -> Option<Self::Path>;\n \n     /// Returns the subpath of a dereference of `path` (or `None` if there is no dedicated subpath).\n     ///\n@@ -269,7 +269,7 @@ where\n             .iter()\n             .enumerate()\n             .map(|(i, f)| {\n-                let field = Field::new(i);\n+                let field = FieldIdx::new(i);\n                 let subpath = self.elaborator.field_subpath(variant_path, field);\n                 let tcx = self.tcx();\n \n@@ -397,8 +397,8 @@ where\n             .enumerate()\n             .map(|(i, &ty)| {\n                 (\n-                    self.tcx().mk_place_field(self.place, Field::new(i), ty),\n-                    self.elaborator.field_subpath(self.path, Field::new(i)),\n+                    self.tcx().mk_place_field(self.place, FieldIdx::new(i), ty),\n+                    self.elaborator.field_subpath(self.path, FieldIdx::new(i)),\n                 )\n             })\n             .collect();\n@@ -411,14 +411,14 @@ where\n     fn open_drop_for_box(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n         // drop glue is sent straight to codegen\n         // box cannot be directly dereferenced\n-        let unique_ty = adt.non_enum_variant().fields[0].ty(self.tcx(), substs);\n-        let nonnull_ty =\n-            unique_ty.ty_adt_def().unwrap().non_enum_variant().fields[0].ty(self.tcx(), substs);\n+        let unique_ty = adt.non_enum_variant().fields[FieldIdx::new(0)].ty(self.tcx(), substs);\n+        let unique_variant = unique_ty.ty_adt_def().unwrap().non_enum_variant();\n+        let nonnull_ty = unique_variant.fields[FieldIdx::from_u32(0)].ty(self.tcx(), substs);\n         let ptr_ty = self.tcx().mk_imm_ptr(substs[0].expect_ty());\n \n-        let unique_place = self.tcx().mk_place_field(self.place, Field::new(0), unique_ty);\n-        let nonnull_place = self.tcx().mk_place_field(unique_place, Field::new(0), nonnull_ty);\n-        let ptr_place = self.tcx().mk_place_field(nonnull_place, Field::new(0), ptr_ty);\n+        let unique_place = self.tcx().mk_place_field(self.place, FieldIdx::new(0), unique_ty);\n+        let nonnull_place = self.tcx().mk_place_field(unique_place, FieldIdx::new(0), nonnull_ty);\n+        let ptr_place = self.tcx().mk_place_field(nonnull_place, FieldIdx::new(0), ptr_ty);\n         let interior = self.tcx().mk_place_deref(ptr_place);\n \n         let interior_path = self.elaborator.deref_subpath(self.path);\n@@ -468,7 +468,7 @@ where\n             let fields = self.move_paths_for_fields(\n                 self.place,\n                 self.path,\n-                &adt.variant(VariantIdx::new(0)),\n+                &adt.variant(FIRST_VARIANT),\n                 substs,\n             );\n             self.drop_ladder(fields, succ, unwind)\n@@ -729,23 +729,59 @@ where\n         let tcx = self.tcx();\n \n         if let Some(size) = opt_size {\n-            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size)\n-                .map(|i| {\n-                    (\n-                        tcx.mk_place_elem(\n-                            self.place,\n-                            ProjectionElem::ConstantIndex {\n-                                offset: i,\n-                                min_length: size,\n-                                from_end: false,\n-                            },\n-                        ),\n-                        self.elaborator.array_subpath(self.path, i, size),\n-                    )\n-                })\n-                .collect();\n-\n-            if fields.iter().any(|(_, path)| path.is_some()) {\n+            enum ProjectionKind<Path> {\n+                Drop(std::ops::Range<u64>),\n+                Keep(u64, Path),\n+            }\n+            // Previously, we'd make a projection for every element in the array and create a drop\n+            // ladder if any `array_subpath` was `Some`, i.e. moving out with an array pattern.\n+            // This caused huge memory usage when generating the drops for large arrays, so we instead\n+            // record the *subslices* which are dropped and the *indexes* which are kept\n+            let mut drop_ranges = vec![];\n+            let mut dropping = true;\n+            let mut start = 0;\n+            for i in 0..size {\n+                let path = self.elaborator.array_subpath(self.path, i, size);\n+                if dropping && path.is_some() {\n+                    drop_ranges.push(ProjectionKind::Drop(start..i));\n+                    dropping = false;\n+                } else if !dropping && path.is_none() {\n+                    dropping = true;\n+                    start = i;\n+                }\n+                if let Some(path) = path {\n+                    drop_ranges.push(ProjectionKind::Keep(i, path));\n+                }\n+            }\n+            if !drop_ranges.is_empty() {\n+                if dropping {\n+                    drop_ranges.push(ProjectionKind::Drop(start..size));\n+                }\n+                let fields = drop_ranges\n+                    .iter()\n+                    .rev()\n+                    .map(|p| {\n+                        let (project, path) = match p {\n+                            ProjectionKind::Drop(r) => (\n+                                ProjectionElem::Subslice {\n+                                    from: r.start,\n+                                    to: r.end,\n+                                    from_end: false,\n+                                },\n+                                None,\n+                            ),\n+                            &ProjectionKind::Keep(offset, path) => (\n+                                ProjectionElem::ConstantIndex {\n+                                    offset,\n+                                    min_length: size,\n+                                    from_end: false,\n+                                },\n+                                Some(path),\n+                            ),\n+                        };\n+                        (tcx.mk_place_elem(self.place, project), path)\n+                    })\n+                    .collect::<Vec<_>>();\n                 let (succ, unwind) = self.drop_ladder_bottom();\n                 return self.drop_ladder(fields, succ, unwind).0;\n             }\n@@ -824,7 +860,7 @@ where\n                 let size = size.try_eval_target_usize(self.tcx(), self.elaborator.param_env());\n                 self.open_drop_for_array(*ety, size)\n             }\n-            ty::Slice(ety) => self.open_drop_for_array(*ety, None),\n+            ty::Slice(ety) => self.drop_loop_pair(*ety),\n \n             _ => span_bug!(self.source_info.span, \"open drop from non-ADT `{:?}`\", ty),\n         }\n@@ -894,12 +930,12 @@ where\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n         let free_func = tcx.require_lang_item(LangItem::BoxFree, Some(self.source_info.span));\n         let args = adt\n-            .variant(VariantIdx::new(0))\n+            .variant(FIRST_VARIANT)\n             .fields\n             .iter()\n             .enumerate()\n             .map(|(i, f)| {\n-                let field = Field::new(i);\n+                let field = FieldIdx::new(i);\n                 let field_ty = f.ty(tcx, substs);\n                 Operand::Move(tcx.mk_place_field(self.place, field, field_ty))\n             })"}, {"sha": "43caa2ea973923c858b918b75f9d6dcd10c33617", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,6 @@\n #![feature(exact_size_is_empty)]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n-#![feature(once_cell)]\n #![feature(stmt_expr_attributes)]\n #![feature(trusted_step)]\n #![recursion_limit = \"256\"]"}, {"sha": "257a42cddc8d2081a472701abb6da222654cf5ef", "filename": "compiler/rustc_mir_dataflow/src/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,6 +1,6 @@\n use crate::move_paths::builder::MoveDat;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_span::Span;\n@@ -64,7 +64,7 @@ impl<'tcx> MovePath<'tcx> {\n     /// Returns an iterator over the parents of `self`.\n     pub fn parents<'a>(\n         &self,\n-        move_paths: &'a IndexVec<MovePathIndex, MovePath<'tcx>>,\n+        move_paths: &'a IndexSlice<MovePathIndex, MovePath<'tcx>>,\n     ) -> impl 'a + Iterator<Item = (MovePathIndex, &'a MovePath<'tcx>)> {\n         let first = self.parent.map(|mpi| (mpi, &move_paths[mpi]));\n         MovePathLinearIter {\n@@ -78,7 +78,7 @@ impl<'tcx> MovePath<'tcx> {\n     /// Returns an iterator over the immediate children of `self`.\n     pub fn children<'a>(\n         &self,\n-        move_paths: &'a IndexVec<MovePathIndex, MovePath<'tcx>>,\n+        move_paths: &'a IndexSlice<MovePathIndex, MovePath<'tcx>>,\n     ) -> impl 'a + Iterator<Item = (MovePathIndex, &'a MovePath<'tcx>)> {\n         let first = self.first_child.map(|mpi| (mpi, &move_paths[mpi]));\n         MovePathLinearIter {\n@@ -95,7 +95,7 @@ impl<'tcx> MovePath<'tcx> {\n     /// `f` will **not** be called on `self`.\n     pub fn find_descendant(\n         &self,\n-        move_paths: &IndexVec<MovePathIndex, MovePath<'_>>,\n+        move_paths: &IndexSlice<MovePathIndex, MovePath<'_>>,\n         f: impl Fn(MovePathIndex) -> bool,\n     ) -> Option<MovePathIndex> {\n         let mut todo = if let Some(child) = self.first_child {"}, {"sha": "33a15a8d224f8d0f3561471f13081604061f7521", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -36,11 +36,11 @@ use std::fmt::{Debug, Formatter};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n \n use crate::lattice::{HasBottom, HasTop};\n use crate::{\n@@ -919,7 +919,7 @@ impl<V: HasTop> ValueOrPlace<V> {\n /// Although only field projections are currently allowed, this could change in the future.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum TrackElem {\n-    Field(Field),\n+    Field(FieldIdx),\n     Variant(VariantIdx),\n     Discriminant,\n }\n@@ -941,7 +941,7 @@ pub fn iter_fields<'tcx>(\n     ty: Ty<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    mut f: impl FnMut(Option<VariantIdx>, Field, Ty<'tcx>),\n+    mut f: impl FnMut(Option<VariantIdx>, FieldIdx, Ty<'tcx>),\n ) {\n     match ty.kind() {\n         ty::Tuple(list) => {\n@@ -1028,8 +1028,8 @@ where\n fn debug_with_context_rec<V: Debug + Eq>(\n     place: PlaceIndex,\n     place_str: &str,\n-    new: &IndexVec<ValueIndex, V>,\n-    old: Option<&IndexVec<ValueIndex, V>>,\n+    new: &IndexSlice<ValueIndex, V>,\n+    old: Option<&IndexSlice<ValueIndex, V>>,\n     map: &Map,\n     f: &mut Formatter<'_>,\n ) -> std::fmt::Result {\n@@ -1069,8 +1069,8 @@ fn debug_with_context_rec<V: Debug + Eq>(\n }\n \n fn debug_with_context<V: Debug + Eq>(\n-    new: &IndexVec<ValueIndex, V>,\n-    old: Option<&IndexVec<ValueIndex, V>>,\n+    new: &IndexSlice<ValueIndex, V>,\n+    old: Option<&IndexSlice<ValueIndex, V>>,\n     map: &Map,\n     f: &mut Formatter<'_>,\n ) -> std::fmt::Result {"}, {"sha": "5815887e5bbb6bd40267d2c1056d45d2e593313e", "filename": "compiler/rustc_mir_transform/src/check_alignment.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_alignment.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -0,0 +1,227 @@\n+use crate::MirPass;\n+use rustc_hir::def_id::DefId;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::mir::*;\n+use rustc_middle::mir::{\n+    interpret::{ConstValue, Scalar},\n+    visit::{PlaceContext, Visitor},\n+};\n+use rustc_middle::ty::{Ty, TyCtxt, TypeAndMut};\n+use rustc_session::Session;\n+\n+pub struct CheckAlignment;\n+\n+impl<'tcx> MirPass<'tcx> for CheckAlignment {\n+    fn is_enabled(&self, sess: &Session) -> bool {\n+        sess.opts.debug_assertions\n+    }\n+\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let basic_blocks = body.basic_blocks.as_mut();\n+        let local_decls = &mut body.local_decls;\n+\n+        for block in (0..basic_blocks.len()).rev() {\n+            let block = block.into();\n+            for statement_index in (0..basic_blocks[block].statements.len()).rev() {\n+                let location = Location { block, statement_index };\n+                let statement = &basic_blocks[block].statements[statement_index];\n+                let source_info = statement.source_info;\n+\n+                let mut finder = PointerFinder {\n+                    local_decls,\n+                    tcx,\n+                    pointers: Vec::new(),\n+                    def_id: body.source.def_id(),\n+                };\n+                for (pointer, pointee_ty) in finder.find_pointers(statement) {\n+                    debug!(\"Inserting alignment check for {:?}\", pointer.ty(&*local_decls, tcx).ty);\n+\n+                    let new_block = split_block(basic_blocks, location);\n+                    insert_alignment_check(\n+                        tcx,\n+                        local_decls,\n+                        &mut basic_blocks[block],\n+                        pointer,\n+                        pointee_ty,\n+                        source_info,\n+                        new_block,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'a> PointerFinder<'tcx, 'a> {\n+    fn find_pointers(&mut self, statement: &Statement<'tcx>) -> Vec<(Place<'tcx>, Ty<'tcx>)> {\n+        self.pointers.clear();\n+        self.visit_statement(statement, Location::START);\n+        core::mem::take(&mut self.pointers)\n+    }\n+}\n+\n+struct PointerFinder<'tcx, 'a> {\n+    local_decls: &'a mut LocalDecls<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    pointers: Vec<(Place<'tcx>, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx, 'a> Visitor<'tcx> for PointerFinder<'tcx, 'a> {\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n+        if let PlaceContext::NonUse(_) = context {\n+            return;\n+        }\n+        if !place.is_indirect() {\n+            return;\n+        }\n+\n+        let pointer = Place::from(place.local);\n+        let pointer_ty = pointer.ty(&*self.local_decls, self.tcx).ty;\n+\n+        // We only want to check unsafe pointers\n+        if !pointer_ty.is_unsafe_ptr() {\n+            trace!(\"Indirect, but not an unsafe ptr, not checking {:?}\", pointer_ty);\n+            return;\n+        }\n+\n+        let Some(pointee) = pointer_ty.builtin_deref(true) else {\n+            debug!(\"Indirect but no builtin deref: {:?}\", pointer_ty);\n+            return;\n+        };\n+        let mut pointee_ty = pointee.ty;\n+        if pointee_ty.is_array() || pointee_ty.is_slice() || pointee_ty.is_str() {\n+            pointee_ty = pointee_ty.sequence_element_type(self.tcx);\n+        }\n+\n+        if !pointee_ty.is_sized(self.tcx, self.tcx.param_env_reveal_all_normalized(self.def_id)) {\n+            debug!(\"Unsafe pointer, but unsized: {:?}\", pointer_ty);\n+            return;\n+        }\n+\n+        if [self.tcx.types.bool, self.tcx.types.i8, self.tcx.types.u8, self.tcx.types.str_]\n+            .contains(&pointee_ty)\n+        {\n+            debug!(\"Trivially aligned pointee type: {:?}\", pointer_ty);\n+            return;\n+        }\n+\n+        self.pointers.push((pointer, pointee_ty))\n+    }\n+}\n+\n+fn split_block(\n+    basic_blocks: &mut IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    location: Location,\n+) -> BasicBlock {\n+    let block_data = &mut basic_blocks[location.block];\n+\n+    // Drain every statement after this one and move the current terminator to a new basic block\n+    let new_block = BasicBlockData {\n+        statements: block_data.statements.split_off(location.statement_index),\n+        terminator: block_data.terminator.take(),\n+        is_cleanup: block_data.is_cleanup,\n+    };\n+\n+    basic_blocks.push(new_block)\n+}\n+\n+fn insert_alignment_check<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    local_decls: &mut IndexVec<Local, LocalDecl<'tcx>>,\n+    block_data: &mut BasicBlockData<'tcx>,\n+    pointer: Place<'tcx>,\n+    pointee_ty: Ty<'tcx>,\n+    source_info: SourceInfo,\n+    new_block: BasicBlock,\n+) {\n+    // Cast the pointer to a *const ()\n+    let const_raw_ptr = tcx.mk_ptr(TypeAndMut { ty: tcx.types.unit, mutbl: Mutability::Not });\n+    let rvalue = Rvalue::Cast(CastKind::PtrToPtr, Operand::Copy(pointer), const_raw_ptr);\n+    let thin_ptr = local_decls.push(LocalDecl::with_source_info(const_raw_ptr, source_info)).into();\n+    block_data\n+        .statements\n+        .push(Statement { source_info, kind: StatementKind::Assign(Box::new((thin_ptr, rvalue))) });\n+\n+    // Transmute the pointer to a usize (equivalent to `ptr.addr()`)\n+    let rvalue = Rvalue::Cast(CastKind::Transmute, Operand::Copy(thin_ptr), tcx.types.usize);\n+    let addr = local_decls.push(LocalDecl::with_source_info(tcx.types.usize, source_info)).into();\n+    block_data\n+        .statements\n+        .push(Statement { source_info, kind: StatementKind::Assign(Box::new((addr, rvalue))) });\n+\n+    // Get the alignment of the pointee\n+    let alignment =\n+        local_decls.push(LocalDecl::with_source_info(tcx.types.usize, source_info)).into();\n+    let rvalue = Rvalue::NullaryOp(NullOp::AlignOf, pointee_ty);\n+    block_data.statements.push(Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((alignment, rvalue))),\n+    });\n+\n+    // Subtract 1 from the alignment to get the alignment mask\n+    let alignment_mask =\n+        local_decls.push(LocalDecl::with_source_info(tcx.types.usize, source_info)).into();\n+    let one = Operand::Constant(Box::new(Constant {\n+        span: source_info.span,\n+        user_ty: None,\n+        literal: ConstantKind::Val(\n+            ConstValue::Scalar(Scalar::from_target_usize(1, &tcx)),\n+            tcx.types.usize,\n+        ),\n+    }));\n+    block_data.statements.push(Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((\n+            alignment_mask,\n+            Rvalue::BinaryOp(BinOp::Sub, Box::new((Operand::Copy(alignment), one))),\n+        ))),\n+    });\n+\n+    // BitAnd the alignment mask with the pointer\n+    let alignment_bits =\n+        local_decls.push(LocalDecl::with_source_info(tcx.types.usize, source_info)).into();\n+    block_data.statements.push(Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((\n+            alignment_bits,\n+            Rvalue::BinaryOp(\n+                BinOp::BitAnd,\n+                Box::new((Operand::Copy(addr), Operand::Copy(alignment_mask))),\n+            ),\n+        ))),\n+    });\n+\n+    // Check if the alignment bits are all zero\n+    let is_ok = local_decls.push(LocalDecl::with_source_info(tcx.types.bool, source_info)).into();\n+    let zero = Operand::Constant(Box::new(Constant {\n+        span: source_info.span,\n+        user_ty: None,\n+        literal: ConstantKind::Val(\n+            ConstValue::Scalar(Scalar::from_target_usize(0, &tcx)),\n+            tcx.types.usize,\n+        ),\n+    }));\n+    block_data.statements.push(Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((\n+            is_ok,\n+            Rvalue::BinaryOp(BinOp::Eq, Box::new((Operand::Copy(alignment_bits), zero.clone()))),\n+        ))),\n+    });\n+\n+    // Set this block's terminator to our assert, continuing to new_block if we pass\n+    block_data.terminator = Some(Terminator {\n+        source_info,\n+        kind: TerminatorKind::Assert {\n+            cond: Operand::Copy(is_ok),\n+            expected: true,\n+            target: new_block,\n+            msg: AssertKind::MisalignedPointerDereference {\n+                required: Operand::Copy(alignment),\n+                found: Operand::Copy(addr),\n+            },\n+            cleanup: None,\n+        },\n+    });\n+}"}, {"sha": "ac55948e61b571e899209b8af8bd480330f8dd1a", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -7,7 +7,7 @@ use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n@@ -117,7 +117,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n-            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n         ) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n@@ -127,7 +127,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n \n         let dummy_body = &Body::new(\n             body.source,\n-            (*body.basic_blocks).clone(),\n+            (*body.basic_blocks).to_owned(),\n             body.source_scopes.clone(),\n             body.local_decls.clone(),\n             Default::default(),\n@@ -319,7 +319,7 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    local_decls: &'mir IndexVec<Local, LocalDecl<'tcx>>,\n+    local_decls: &'mir IndexSlice<Local, LocalDecl<'tcx>>,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {"}, {"sha": "d7696a57000615db58e0721f1f0106435c89d6a1", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -9,7 +9,7 @@ use rustc_const_eval::interpret::{\n };\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n@@ -93,7 +93,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n             .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n-            traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n         ) {\n             trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", def_id);\n             return;\n@@ -103,7 +103,7 @@ impl<'tcx> MirLint<'tcx> for ConstProp {\n \n         let dummy_body = &Body::new(\n             body.source,\n-            (*body.basic_blocks).clone(),\n+            (*body.basic_blocks).to_owned(),\n             body.source_scopes.clone(),\n             body.local_decls.clone(),\n             Default::default(),\n@@ -130,8 +130,8 @@ struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>,\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n-    source_scopes: &'mir IndexVec<SourceScope, SourceScopeData<'tcx>>,\n-    local_decls: &'mir IndexVec<Local, LocalDecl<'tcx>>,\n+    source_scopes: &'mir IndexSlice<SourceScope, SourceScopeData<'tcx>>,\n+    local_decls: &'mir IndexSlice<Local, LocalDecl<'tcx>>,\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,"}, {"sha": "c155048c98b46cc517cebf131f25b0390748757a", "filename": "compiler/rustc_mir_transform/src/copy_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcopy_prop.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,5 +1,5 @@\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n@@ -102,7 +102,7 @@ struct Replacer<'a, 'tcx> {\n     fully_moved: BitSet<Local>,\n     storage_to_remove: BitSet<Local>,\n     borrowed_locals: BitSet<Local>,\n-    copy_classes: &'a IndexVec<Local, Local>,\n+    copy_classes: &'a IndexSlice<Local, Local>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for Replacer<'_, 'tcx> {"}, {"sha": "689d6c71361dd99da60b5f5acb6dd75cda50eb18", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::dominators::{self, Dominators};\n use rustc_data_structures::graph::{self, GraphSuccessors, WithNumNodes, WithStartNode};\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n \n@@ -176,10 +176,10 @@ impl CoverageGraph {\n \n     fn add_basic_coverage_block(\n         bcbs: &mut IndexVec<BasicCoverageBlock, BasicCoverageBlockData>,\n-        bb_to_bcb: &mut IndexVec<BasicBlock, Option<BasicCoverageBlock>>,\n+        bb_to_bcb: &mut IndexSlice<BasicBlock, Option<BasicCoverageBlock>>,\n         basic_blocks: Vec<BasicBlock>,\n     ) {\n-        let bcb = BasicCoverageBlock::from_usize(bcbs.len());\n+        let bcb = bcbs.next_index();\n         for &bb in basic_blocks.iter() {\n             bb_to_bcb[bb] = Some(bcb);\n         }"}, {"sha": "59b506e7345537ed738a00b7a7f02dfa3bf3bc53", "filename": "compiler/rustc_mir_transform/src/coverage/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Ftests.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -65,7 +65,7 @@ impl<'tcx> MockBlocks<'tcx> {\n     }\n \n     fn push(&mut self, kind: TerminatorKind<'tcx>) -> BasicBlock {\n-        let next_lo = if let Some(last) = self.blocks.last() {\n+        let next_lo = if let Some(last) = self.blocks.last_index() {\n             self.blocks[last].terminator().source_info.span.hi()\n         } else {\n             BytePos(1)"}, {"sha": "15f5df41153b2502b9f0baf9532bd01e6964532a", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -13,8 +13,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, ValueOrPlace};\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n-use rustc_target::abi::Align;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{Align, FieldIdx, VariantIdx};\n \n use crate::MirPass;\n \n@@ -148,7 +147,7 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                         for (field_index, operand) in operands.iter().enumerate() {\n                             if let Some(field) = self.map().apply(\n                                 variant_target_idx,\n-                                TrackElem::Field(Field::from_usize(field_index)),\n+                                TrackElem::Field(FieldIdx::from_usize(field_index)),\n                             ) {\n                                 let result = self.handle_operand(operand, state);\n                                 state.insert_idx(field, result, self.map());"}, {"sha": "85623499439b273020f4c00e2050df6cbce44dd3", "filename": "compiler/rustc_mir_transform/src/elaborate_box_derefs.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_box_derefs.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -9,6 +9,7 @@ use rustc_middle::mir::patch::MirPatch;\n use rustc_middle::mir::visit::MutVisitor;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_target::abi::FieldIdx;\n \n /// Constructs the types used when accessing a Box's pointer\n pub fn build_ptr_tys<'tcx>(\n@@ -32,9 +33,9 @@ pub fn build_projection<'tcx>(\n     ptr_ty: Ty<'tcx>,\n ) -> [PlaceElem<'tcx>; 3] {\n     [\n-        PlaceElem::Field(Field::new(0), unique_ty),\n-        PlaceElem::Field(Field::new(0), nonnull_ty),\n-        PlaceElem::Field(Field::new(0), ptr_ty),\n+        PlaceElem::Field(FieldIdx::new(0), unique_ty),\n+        PlaceElem::Field(FieldIdx::new(0), nonnull_ty),\n+        PlaceElem::Field(FieldIdx::new(0), ptr_ty),\n     ]\n }\n \n@@ -91,13 +92,14 @@ pub struct ElaborateBoxDerefs;\n impl<'tcx> MirPass<'tcx> for ElaborateBoxDerefs {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         if let Some(def_id) = tcx.lang_items().owned_box() {\n-            let unique_did = tcx.adt_def(def_id).non_enum_variant().fields[0].did;\n+            let unique_did =\n+                tcx.adt_def(def_id).non_enum_variant().fields[FieldIdx::from_u32(0)].did;\n \n             let Some(nonnull_def) = tcx.type_of(unique_did).subst_identity().ty_adt_def() else {\n                 span_bug!(tcx.def_span(unique_did), \"expected Box to contain Unique\")\n             };\n \n-            let nonnull_did = nonnull_def.non_enum_variant().fields[0].did;\n+            let nonnull_did = nonnull_def.non_enum_variant().fields[FieldIdx::from_u32(0)].did;\n \n             let patch = MirPatch::new(body);\n "}, {"sha": "a028d6356d50e0f770fbc778cabfbaeea9f2231a", "filename": "compiler/rustc_mir_transform/src/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Felaborate_drops.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -15,7 +15,7 @@ use rustc_mir_dataflow::MoveDataParamEnv;\n use rustc_mir_dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use rustc_mir_dataflow::{Analysis, ResultsCursor};\n use rustc_span::{DesugaringKind, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use std::fmt;\n \n /// During MIR building, Drop terminators are inserted in every place where a drop may occur.\n@@ -252,7 +252,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for Elaborator<'a, '_, 'tcx> {\n         }\n     }\n \n-    fn field_subpath(&self, path: Self::Path, field: Field) -> Option<Self::Path> {\n+    fn field_subpath(&self, path: Self::Path, field: FieldIdx) -> Option<Self::Path> {\n         rustc_mir_dataflow::move_path_children_matching(self.ctxt.move_data(), path, |e| match e {\n             ProjectionElem::Field(idx, _) => idx == field,\n             _ => false,"}, {"sha": "af6422c724647551abe6c5c3a7dd2ec660e87d13", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -73,7 +73,7 @@ use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n use rustc_target::spec::PanicStrategy;\n use std::{iter, ops};\n \n@@ -162,9 +162,10 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                 place,\n                 Place {\n                     local: SELF_ARG,\n-                    projection: self\n-                        .tcx()\n-                        .mk_place_elems(&[ProjectionElem::Field(Field::new(0), self.ref_gen_ty)]),\n+                    projection: self.tcx().mk_place_elems(&[ProjectionElem::Field(\n+                        FieldIdx::new(0),\n+                        self.ref_gen_ty,\n+                    )]),\n                 },\n                 self.tcx,\n             );\n@@ -273,7 +274,7 @@ impl<'tcx> TransformVisitor<'tcx> {\n             statements.push(Statement {\n                 kind: StatementKind::Assign(Box::new((\n                     Place::return_place(),\n-                    Rvalue::Aggregate(Box::new(kind), vec![]),\n+                    Rvalue::Aggregate(Box::new(kind), IndexVec::new()),\n                 ))),\n                 source_info,\n             });\n@@ -286,7 +287,7 @@ impl<'tcx> TransformVisitor<'tcx> {\n         statements.push(Statement {\n             kind: StatementKind::Assign(Box::new((\n                 Place::return_place(),\n-                Rvalue::Aggregate(Box::new(kind), vec![val]),\n+                Rvalue::Aggregate(Box::new(kind), IndexVec::from_iter([val])),\n             ))),\n             source_info,\n         });\n@@ -297,7 +298,7 @@ impl<'tcx> TransformVisitor<'tcx> {\n         let self_place = Place::from(SELF_ARG);\n         let base = self.tcx.mk_place_downcast_unnamed(self_place, variant_index);\n         let mut projection = base.projection.to_vec();\n-        projection.push(ProjectionElem::Field(Field::new(idx), ty));\n+        projection.push(ProjectionElem::Field(FieldIdx::new(idx), ty));\n \n         Place { local: base.local, projection: self.tcx.mk_place_elems(&projection) }\n     }\n@@ -967,7 +968,7 @@ fn compute_layout<'tcx>(\n \n     // Build the generator variant field list.\n     // Create a map from local indices to generator struct indices.\n-    let mut variant_fields: IndexVec<VariantIdx, IndexVec<Field, GeneratorSavedLocal>> =\n+    let mut variant_fields: IndexVec<VariantIdx, IndexVec<FieldIdx, GeneratorSavedLocal>> =\n         iter::repeat(IndexVec::new()).take(RESERVED_VARIANTS).collect();\n     let mut remap = FxHashMap::default();\n     for (suspension_point_idx, live_locals) in live_locals_at_suspension_points.iter().enumerate() {"}, {"sha": "15b31d383944bacc8e19fb30285f443d503b312e", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -10,7 +10,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n use rustc_target::spec::abi::Abi;\n \n use crate::simplify::{remove_dead_blocks, CfgSimplifier};\n@@ -270,7 +270,9 @@ impl<'tcx> Inliner<'tcx> {\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => return Ok(()),\n+            | InstanceDef::CloneShim(..)\n+            | InstanceDef::ThreadLocalShim(..)\n+            | InstanceDef::FnPtrAddrShim(..) => return Ok(()),\n         }\n \n         if self.tcx.is_constructor(callee_def_id) {\n@@ -424,13 +426,6 @@ impl<'tcx> Inliner<'tcx> {\n         debug!(\"    final inline threshold = {}\", threshold);\n \n         // FIXME: Give a bonus to functions with only a single caller\n-        let diverges = matches!(\n-            callee_body.basic_blocks[START_BLOCK].terminator().kind,\n-            TerminatorKind::Unreachable | TerminatorKind::Call { target: None, .. }\n-        );\n-        if diverges && !matches!(callee_attrs.inline, InlineAttr::Always) {\n-            return Err(\"callee diverges unconditionally\");\n-        }\n \n         let mut checker = CostChecker {\n             tcx: self.tcx,\n@@ -706,7 +701,7 @@ impl<'tcx> Inliner<'tcx> {\n             // The `tmp0`, `tmp1`, and `tmp2` in our example above.\n             let tuple_tmp_args = tuple_tys.iter().enumerate().map(|(i, ty)| {\n                 // This is e.g., `tuple_tmp.0` in our example above.\n-                let tuple_field = Operand::Move(tcx.mk_place_field(tuple, Field::new(i), ty));\n+                let tuple_field = Operand::Move(tcx.mk_place_field(tuple, FieldIdx::new(i), ty));\n \n                 // Spill to a local to make e.g., `tmp0`.\n                 self.create_temp_if_necessary(tuple_field, callsite, caller_body)\n@@ -911,8 +906,8 @@ impl<'tcx> Visitor<'tcx> for CostChecker<'_, 'tcx> {\n                     check_equal(self, *f_ty);\n                 }\n                 ty::Adt(adt_def, substs) => {\n-                    let var = parent_ty.variant_index.unwrap_or(VariantIdx::from_u32(0));\n-                    let Some(field) = adt_def.variant(var).fields.get(f.as_usize()) else {\n+                    let var = parent_ty.variant_index.unwrap_or(FIRST_VARIANT);\n+                    let Some(field) = adt_def.variant(var).fields.get(f) else {\n                         self.validation = Err(\"malformed MIR\");\n                         return;\n                     };"}, {"sha": "8aa3c23d019179ae31b7224d29af5f6f02052f5e", "filename": "compiler/rustc_mir_transform/src/inline/cycle.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline%2Fcycle.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -83,7 +83,11 @@ pub(crate) fn mir_callgraph_reachable<'tcx>(\n                 | InstanceDef::ReifyShim(_)\n                 | InstanceDef::FnPtrShim(..)\n                 | InstanceDef::ClosureOnceShim { .. }\n+                | InstanceDef::ThreadLocalShim { .. }\n                 | InstanceDef::CloneShim(..) => {}\n+\n+                // This shim does not call any other functions, thus there can be no recursion.\n+                InstanceDef::FnPtrAddrShim(..) => continue,\n                 InstanceDef::DropGlue(..) => {\n                     // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n                     // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this"}, {"sha": "3d06a0a495f79f328027f8d96c8a2f4d63fa49b0", "filename": "compiler/rustc_mir_transform/src/instcombine.rs", "status": "modified", "additions": 64, "deletions": 4, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finstcombine.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,12 +3,14 @@\n use crate::MirPass;\n use rustc_hir::Mutability;\n use rustc_middle::mir::{\n-    BinOp, Body, Constant, ConstantKind, LocalDecls, Operand, Place, ProjectionElem, Rvalue,\n-    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UnOp,\n+    BinOp, Body, CastKind, Constant, ConstantKind, LocalDecls, Operand, Place, ProjectionElem,\n+    Rvalue, SourceInfo, Statement, StatementKind, SwitchTargets, Terminator, TerminatorKind, UnOp,\n };\n use rustc_middle::ty::layout::ValidityRequirement;\n+use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, ParamEnv, SubstsRef, Ty, TyCtxt};\n use rustc_span::symbol::Symbol;\n+use rustc_target::abi::FieldIdx;\n \n pub struct InstCombine;\n \n@@ -44,6 +46,7 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n                 &mut block.terminator.as_mut().unwrap(),\n                 &mut block.statements,\n             );\n+            ctx.combine_duplicate_switch_targets(&mut block.terminator.as_mut().unwrap());\n         }\n     }\n }\n@@ -144,9 +147,53 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n     }\n \n     fn combine_cast(&self, _source_info: &SourceInfo, rvalue: &mut Rvalue<'tcx>) {\n-        if let Rvalue::Cast(_kind, operand, ty) = rvalue {\n-            if operand.ty(self.local_decls, self.tcx) == *ty {\n+        if let Rvalue::Cast(kind, operand, cast_ty) = rvalue {\n+            let operand_ty = operand.ty(self.local_decls, self.tcx);\n+            if operand_ty == *cast_ty {\n                 *rvalue = Rvalue::Use(operand.clone());\n+            } else if *kind == CastKind::Transmute {\n+                // Transmuting an integer to another integer is just a signedness cast\n+                if let (ty::Int(int), ty::Uint(uint)) | (ty::Uint(uint), ty::Int(int)) = (operand_ty.kind(), cast_ty.kind())\n+                    && int.bit_width() == uint.bit_width()\n+                {\n+                    // The width check isn't strictly necessary, as different widths\n+                    // are UB and thus we'd be allowed to turn it into a cast anyway.\n+                    // But let's keep the UB around for codegen to exploit later.\n+                    // (If `CastKind::Transmute` ever becomes *not* UB for mismatched sizes,\n+                    // then the width check is necessary for big-endian correctness.)\n+                    *kind = CastKind::IntToInt;\n+                    return;\n+                }\n+\n+                // Transmuting a fieldless enum to its repr is a discriminant read\n+                if let ty::Adt(adt_def, ..) = operand_ty.kind()\n+                    && adt_def.is_enum()\n+                    && adt_def.is_payloadfree()\n+                    && let Some(place) = operand.place()\n+                    && let Some(repr_int) = adt_def.repr().int\n+                    && repr_int.to_ty(self.tcx) == *cast_ty\n+                {\n+                    *rvalue = Rvalue::Discriminant(place);\n+                    return;\n+                }\n+\n+                // Transmuting a transparent struct/union to a field's type is a projection\n+                if let ty::Adt(adt_def, substs) = operand_ty.kind()\n+                    && adt_def.repr().transparent()\n+                    && (adt_def.is_struct() || adt_def.is_union())\n+                    && let Some(place) = operand.place()\n+                {\n+                    let variant = adt_def.non_enum_variant();\n+                    for (i, field) in variant.fields.iter().enumerate() {\n+                        let field_ty = field.ty(self.tcx, substs);\n+                        if field_ty == *cast_ty {\n+                            let place = place.project_deeper(&[ProjectionElem::Field(FieldIdx::from_usize(i), *cast_ty)], self.tcx);\n+                            let operand = if operand.is_move() { Operand::Move(place) } else { Operand::Copy(place) };\n+                            *rvalue = Rvalue::Use(operand);\n+                            return;\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -217,6 +264,19 @@ impl<'tcx> InstCombineContext<'tcx, '_> {\n         terminator.kind = TerminatorKind::Goto { target: destination_block };\n     }\n \n+    fn combine_duplicate_switch_targets(&self, terminator: &mut Terminator<'tcx>) {\n+        let TerminatorKind::SwitchInt { targets, .. } = &mut terminator.kind\n+        else { return };\n+\n+        let otherwise = targets.otherwise();\n+        if targets.iter().any(|t| t.1 == otherwise) {\n+            *targets = SwitchTargets::new(\n+                targets.iter().filter(|t| t.1 != otherwise),\n+                targets.otherwise(),\n+            );\n+        }\n+    }\n+\n     fn combine_intrinsic_assert(\n         &self,\n         terminator: &mut Terminator<'tcx>,"}, {"sha": "b52de4b72c9e8b0a462d551440e81a2e692a2264", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,6 @@\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n #![feature(option_get_or_insert_default)]\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n@@ -91,6 +90,7 @@ mod separate_const_switch;\n mod shim;\n mod ssa;\n // This pass is public to allow external drivers to perform MIR cleanup\n+mod check_alignment;\n pub mod simplify;\n mod simplify_branches;\n mod simplify_comparison_integral;\n@@ -546,6 +546,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         tcx,\n         body,\n         &[\n+            &check_alignment::CheckAlignment,\n             &reveal_all::RevealAll, // has to be done before inlining, since inlined code is in RevealAll mode.\n             &lower_slice_len::LowerSliceLenCalls, // has to be done before inlining, otherwise actual call will be almost always inlined. Also simple, so can just do first\n             &unreachable_prop::UnreachablePropagation,"}, {"sha": "c136642dff2779a253e322ddeffb68fee318f7cb", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx};\n \n pub struct LowerIntrinsics;\n \n@@ -211,7 +211,7 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                                                     Some(sym::Some),\n                                                     VariantIdx::from_u32(1),\n                                                 ),\n-                                                PlaceElem::Field(Field::from_u32(0), *dest_ty),\n+                                                PlaceElem::Field(FieldIdx::from_u32(0), *dest_ty),\n                                             ],\n                                             tcx,\n                                         ),"}, {"sha": "101fae2f08c5cae6c94798289028fb8907fb779c", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@\n \n use crate::MirPass;\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::IndexSlice;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -42,7 +42,7 @@ struct SliceLenPatchInformation<'tcx> {\n fn lower_slice_len_call<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     block: &mut BasicBlockData<'tcx>,\n-    local_decls: &IndexVec<Local, LocalDecl<'tcx>>,\n+    local_decls: &IndexSlice<Local, LocalDecl<'tcx>>,\n     slice_len_fn_item_def_id: DefId,\n ) {\n     let mut patch_found: Option<SliceLenPatchInformation<'_>> = None;"}, {"sha": "1f9e521d315d8d1315e5542ae41e78b068f270ec", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,10 +1,11 @@\n use rustc_index::bit_set::ChunkedBitSet;\n-use rustc_middle::mir::{Body, Field, TerminatorKind};\n+use rustc_middle::mir::{Body, TerminatorKind};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, VariantDef};\n use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n use rustc_mir_dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n use rustc_mir_dataflow::{self, move_path_children_matching, Analysis, MoveDataParamEnv};\n+use rustc_target::abi::FieldIdx;\n \n use crate::MirPass;\n \n@@ -130,15 +131,15 @@ fn is_needs_drop_and_init<'tcx>(\n                     .fields\n                     .iter()\n                     .enumerate()\n-                    .map(|(f, field)| (Field::from_usize(f), field.ty(tcx, substs), mpi))\n+                    .map(|(f, field)| (FieldIdx::from_usize(f), field.ty(tcx, substs), mpi))\n                     .any(field_needs_drop_and_init)\n             })\n         }\n \n         ty::Tuple(fields) => fields\n             .iter()\n             .enumerate()\n-            .map(|(f, f_ty)| (Field::from_usize(f), f_ty, mpi))\n+            .map(|(f, f_ty)| (FieldIdx::from_usize(f), f_ty, mpi))\n             .any(field_needs_drop_and_init),\n \n         _ => true,"}, {"sha": "9e406eba0fcaaca7e9adc3d0918583edf22fc127", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, EarlyBinder, GeneratorSubsts, Ty, TyCtxt};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{FieldIdx, VariantIdx, FIRST_VARIANT};\n \n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -76,7 +76,9 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n \n             build_drop_shim(tcx, def_id, ty)\n         }\n+        ty::InstanceDef::ThreadLocalShim(..) => build_thread_local_shim(tcx, instance),\n         ty::InstanceDef::CloneShim(def_id, ty) => build_clone_shim(tcx, def_id, ty),\n+        ty::InstanceDef::FnPtrAddrShim(def_id, ty) => build_fn_ptr_addr_shim(tcx, def_id, ty),\n         ty::InstanceDef::Virtual(..) => {\n             bug!(\"InstanceDef::Virtual ({:?}) is for direct calls only\", instance)\n         }\n@@ -307,7 +309,7 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n \n     fn clear_drop_flag(&mut self, _location: Location, _path: Self::Path, _mode: DropFlagMode) {}\n \n-    fn field_subpath(&self, _path: Self::Path, _field: Field) -> Option<Self::Path> {\n+    fn field_subpath(&self, _path: Self::Path, _field: FieldIdx) -> Option<Self::Path> {\n         None\n     }\n     fn deref_subpath(&self, _path: Self::Path) -> Option<Self::Path> {\n@@ -321,6 +323,34 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     }\n }\n \n+fn build_thread_local_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'tcx> {\n+    let def_id = instance.def_id();\n+\n+    let span = tcx.def_span(def_id);\n+    let source_info = SourceInfo::outermost(span);\n+\n+    let mut blocks = IndexVec::with_capacity(1);\n+    blocks.push(BasicBlockData {\n+        statements: vec![Statement {\n+            source_info,\n+            kind: StatementKind::Assign(Box::new((\n+                Place::return_place(),\n+                Rvalue::ThreadLocalRef(def_id),\n+            ))),\n+        }],\n+        terminator: Some(Terminator { source_info, kind: TerminatorKind::Return }),\n+        is_cleanup: false,\n+    });\n+\n+    new_body(\n+        MirSource::from_instance(instance),\n+        blocks,\n+        IndexVec::from_raw(vec![LocalDecl::new(tcx.thread_local_ptr_ty(def_id), span)]),\n+        0,\n+        span,\n+    )\n+}\n+\n /// Builds a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n@@ -500,7 +530,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n             // created by block 2*i. We store this block in `unwind` so that the next clone block\n             // will unwind to it if cloning fails.\n \n-            let field = Field::new(i);\n+            let field = FieldIdx::new(i);\n             let src_field = self.tcx.mk_place_field(src, field, ity);\n \n             let dest_field = self.tcx.mk_place_field(dest, field, ity);\n@@ -723,7 +753,7 @@ fn build_call_shim<'tcx>(\n     if let Some(untuple_args) = untuple_args {\n         let tuple_arg = Local::new(1 + (sig.inputs().len() - 1));\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n-            Operand::Move(tcx.mk_place_field(Place::from(tuple_arg), Field::new(i), *ity))\n+            Operand::Move(tcx.mk_place_field(Place::from(tuple_arg), FieldIdx::new(i), *ity))\n         }));\n     }\n \n@@ -816,11 +846,8 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     let source_info = SourceInfo::outermost(span);\n \n-    let variant_index = if adt_def.is_enum() {\n-        adt_def.variant_index_with_ctor_id(ctor_id)\n-    } else {\n-        VariantIdx::new(0)\n-    };\n+    let variant_index =\n+        if adt_def.is_enum() { adt_def.variant_index_with_ctor_id(ctor_id) } else { FIRST_VARIANT };\n \n     // Generate the following MIR:\n     //\n@@ -864,3 +891,39 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     body\n }\n+\n+/// ```ignore (pseudo-impl)\n+/// impl FnPtr for fn(u32) {\n+///     fn addr(self) -> usize {\n+///         self as usize\n+///     }\n+/// }\n+/// ```\n+fn build_fn_ptr_addr_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n+    assert!(matches!(self_ty.kind(), ty::FnPtr(..)), \"expected fn ptr, found {self_ty}\");\n+    let span = tcx.def_span(def_id);\n+    let Some(sig) = tcx.fn_sig(def_id).subst(tcx, &[self_ty.into()]).no_bound_vars() else {\n+        span_bug!(span, \"FnPtr::addr with bound vars for `{self_ty}`\");\n+    };\n+    let locals = local_decls_for_sig(&sig, span);\n+\n+    let source_info = SourceInfo::outermost(span);\n+    // FIXME: use `expose_addr` once we figure out whether function pointers have meaningful provenance.\n+    let rvalue = Rvalue::Cast(\n+        CastKind::FnPtrToPtr,\n+        Operand::Move(Place::from(Local::new(1))),\n+        tcx.mk_imm_ptr(tcx.types.unit),\n+    );\n+    let stmt = Statement {\n+        source_info,\n+        kind: StatementKind::Assign(Box::new((Place::return_place(), rvalue))),\n+    };\n+    let statements = vec![stmt];\n+    let start_block = BasicBlockData {\n+        statements,\n+        terminator: Some(Terminator { source_info, kind: TerminatorKind::Return }),\n+        is_cleanup: false,\n+    };\n+    let source = MirSource::from_instance(ty::InstanceDef::FnPtrAddrShim(def_id, self_ty));\n+    new_body(source, IndexVec::from_elem_n(start_block, 1), locals, sig.inputs().len(), span)\n+}"}, {"sha": "c79e1cf08050964983e4ab4ab86c31e1488b992b", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -28,8 +28,8 @@\n //! return.\n \n use crate::MirPass;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_index::vec::{Idx, IndexVec};\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n+use rustc_index::vec::{Idx, IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -48,6 +48,7 @@ impl SimplifyCfg {\n \n pub fn simplify_cfg<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     CfgSimplifier::new(body).simplify();\n+    remove_duplicate_unreachable_blocks(tcx, body);\n     remove_dead_blocks(tcx, body);\n \n     // FIXME: Should probably be moved into some kind of pass manager\n@@ -66,7 +67,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n }\n \n pub struct CfgSimplifier<'a, 'tcx> {\n-    basic_blocks: &'a mut IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    basic_blocks: &'a mut IndexSlice<BasicBlock, BasicBlockData<'tcx>>,\n     pred_count: IndexVec<BasicBlock, u32>,\n }\n \n@@ -259,6 +260,49 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n     }\n }\n \n+pub fn remove_duplicate_unreachable_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+    struct OptApplier<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        duplicates: FxIndexSet<BasicBlock>,\n+    }\n+\n+    impl<'tcx> MutVisitor<'tcx> for OptApplier<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n+            for target in terminator.successors_mut() {\n+                // We don't have to check whether `target` is a cleanup block, because have\n+                // entirely excluded cleanup blocks in building the set of duplicates.\n+                if self.duplicates.contains(target) {\n+                    *target = self.duplicates[0];\n+                }\n+            }\n+\n+            self.super_terminator(terminator, location);\n+        }\n+    }\n+\n+    let unreachable_blocks = body\n+        .basic_blocks\n+        .iter_enumerated()\n+        .filter(|(_, bb)| {\n+            // CfgSimplifier::simplify leaves behind some unreachable basic blocks without a\n+            // terminator. Those blocks will be deleted by remove_dead_blocks, but we run just\n+            // before then so we need to handle missing terminators.\n+            // We also need to prevent confusing cleanup and non-cleanup blocks. In practice we\n+            // don't emit empty unreachable cleanup blocks, so this simple check suffices.\n+            bb.terminator.is_some() && bb.is_empty_unreachable() && !bb.is_cleanup\n+        })\n+        .map(|(block, _)| block)\n+        .collect::<FxIndexSet<_>>();\n+\n+    if unreachable_blocks.len() > 1 {\n+        OptApplier { tcx, duplicates: unreachable_blocks }.visit_body(body);\n+    }\n+}\n+\n pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let reachable = traversal::reachable_as_bitset(body);\n     let num_blocks = body.basic_blocks.len();\n@@ -325,8 +369,8 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n /// instances in a single body, so the strategy described above is applied to\n /// coverage counters from each instance individually.\n fn save_unreachable_coverage(\n-    basic_blocks: &mut IndexVec<BasicBlock, BasicBlockData<'_>>,\n-    source_scopes: &IndexVec<SourceScope, SourceScopeData<'_>>,\n+    basic_blocks: &mut IndexSlice<BasicBlock, BasicBlockData<'_>>,\n+    source_scopes: &IndexSlice<SourceScope, SourceScopeData<'_>>,\n     first_dead_block: usize,\n ) {\n     // Identify instances that still have some live coverage counters left.\n@@ -445,7 +489,7 @@ fn make_local_map<V>(\n     local_decls: &mut IndexVec<Local, V>,\n     used_locals: &UsedLocals,\n ) -> IndexVec<Local, Option<Local>> {\n-    let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*local_decls);\n+    let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, local_decls);\n     let mut used = Local::new(0);\n \n     for alive_index in local_decls.indices() {"}, {"sha": "c798bd05345e28e9dbe92612281085706e37109f", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,6 +6,7 @@ use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{excluded_locals, iter_fields};\n+use rustc_target::abi::FieldIdx;\n \n pub struct ScalarReplacementOfAggregates;\n \n@@ -115,7 +116,7 @@ fn escaping_locals(excluded: &BitSet<Local>, body: &Body<'_>) -> BitSet<Local> {\n struct ReplacementMap<'tcx> {\n     /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n     /// and deinit statement and debuginfo.\n-    fragments: IndexVec<Local, Option<IndexVec<Field, Option<(Ty<'tcx>, Local)>>>>,\n+    fragments: IndexVec<Local, Option<IndexVec<FieldIdx, Option<(Ty<'tcx>, Local)>>>>,\n }\n \n impl<'tcx> ReplacementMap<'tcx> {\n@@ -129,7 +130,7 @@ impl<'tcx> ReplacementMap<'tcx> {\n     fn place_fragments(\n         &self,\n         place: Place<'tcx>,\n-    ) -> Option<impl Iterator<Item = (Field, Ty<'tcx>, Local)> + '_> {\n+    ) -> Option<impl Iterator<Item = (FieldIdx, Ty<'tcx>, Local)> + '_> {\n         let local = place.as_local()?;\n         let fields = self.fragments[local].as_ref()?;\n         Some(fields.iter_enumerated().filter_map(|(field, &opt_ty_local)| {"}, {"sha": "be026402dd5787d48487a6835644e2b330fbafb2", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n-use rustc_index::vec::IndexVec;\n+use rustc_index::vec::{IndexSlice, IndexVec};\n use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n@@ -135,7 +135,7 @@ impl SsaLocals {\n     ///   _d => _a // transitively through _c\n     ///\n     /// Exception: we do not see through the return place, as it cannot be substituted.\n-    pub fn copy_classes(&self) -> &IndexVec<Local, Local> {\n+    pub fn copy_classes(&self) -> &IndexSlice<Local, Local> {\n         &self.copy_classes\n     }\n "}, {"sha": "f41edff8513deff61aa2dcad1841b9ec00ff637b", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -174,7 +174,7 @@\n //! regardless of whether it is actually needed or not.\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::{par_for_each_in, MTLock, MTRef};\n+use rustc_data_structures::sync::{par_for_each_in, MTLock, MTLockRef};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n@@ -190,7 +190,8 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::query::TyCtxtAt;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{\n-    self, GenericParamDefKind, Instance, Ty, TyCtxt, TypeFoldable, TypeVisitableExt, VtblEntry,\n+    self, GenericParamDefKind, Instance, InstanceDef, Ty, TyCtxt, TypeFoldable, TypeVisitableExt,\n+    VtblEntry,\n };\n use rustc_middle::{middle::codegen_fn_attrs::CodegenFnAttrFlags, mir::visit::TyContext};\n use rustc_session::config::EntryFnType;\n@@ -340,8 +341,8 @@ pub fn collect_crate_mono_items(\n     let recursion_limit = tcx.recursion_limit();\n \n     {\n-        let visited: MTRef<'_, _> = &mut visited;\n-        let inlining_map: MTRef<'_, _> = &mut inlining_map;\n+        let visited: MTLockRef<'_, _> = &mut visited;\n+        let inlining_map: MTLockRef<'_, _> = &mut inlining_map;\n \n         tcx.sess.time(\"monomorphization_collector_graph_walk\", || {\n             par_for_each_in(roots, |root| {\n@@ -406,10 +407,10 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n-    visited: MTRef<'_, MTLock<FxHashSet<MonoItem<'tcx>>>>,\n+    visited: MTLockRef<'_, FxHashSet<MonoItem<'tcx>>>,\n     recursion_depths: &mut DefIdMap<usize>,\n     recursion_limit: Limit,\n-    inlining_map: MTRef<'_, MTLock<InliningMap<'tcx>>>,\n+    inlining_map: MTLockRef<'_, InliningMap<'tcx>>,\n ) {\n     if !visited.lock_mut().insert(starting_point.node) {\n         // We've been here already, no need to search again.\n@@ -462,6 +463,16 @@ fn collect_items_rec<'tcx>(\n                     collect_miri(tcx, id, &mut neighbors);\n                 }\n             }\n+\n+            if tcx.needs_thread_local_shim(def_id) {\n+                neighbors.push(respan(\n+                    starting_point.span,\n+                    MonoItem::Fn(Instance {\n+                        def: InstanceDef::ThreadLocalShim(def_id),\n+                        substs: InternalSubsts::empty(),\n+                    }),\n+                ));\n+            }\n         }\n         MonoItem::Fn(instance) => {\n             // Sanity check whether this ended up being collected accidentally\n@@ -640,8 +651,8 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n         let (shrunk, written_to_path) = shrunk_instance_name(tcx, &instance);\n         let span = tcx.def_span(instance.def_id());\n         let mut path = PathBuf::new();\n-        let was_written = if written_to_path.is_some() {\n-            path = written_to_path.unwrap();\n+        let was_written = if let Some(path2) = written_to_path {\n+            path = path2;\n             Some(())\n         } else {\n             None\n@@ -962,6 +973,9 @@ fn visit_instance_use<'tcx>(\n                 bug!(\"{:?} being reified\", instance);\n             }\n         }\n+        ty::InstanceDef::ThreadLocalShim(..) => {\n+            bug!(\"{:?} being reified\", instance);\n+        }\n         ty::InstanceDef::DropGlue(_, None) => {\n             // Don't need to emit noop drop glue if we are calling directly.\n             if !is_direct_call {\n@@ -974,7 +988,8 @@ fn visit_instance_use<'tcx>(\n         | ty::InstanceDef::ClosureOnceShim { .. }\n         | ty::InstanceDef::Item(..)\n         | ty::InstanceDef::FnPtrShim(..)\n-        | ty::InstanceDef::CloneShim(..) => {\n+        | ty::InstanceDef::CloneShim(..)\n+        | ty::InstanceDef::FnPtrAddrShim(..) => {\n             output.push(create_fn_mono_item(tcx, instance, source));\n         }\n     }\n@@ -1104,7 +1119,8 @@ fn find_vtable_types_for_unsizing<'tcx>(\n             let target_fields = &target_adt_def.non_enum_variant().fields;\n \n             assert!(\n-                coerce_index < source_fields.len() && source_fields.len() == target_fields.len()\n+                coerce_index.index() < source_fields.len()\n+                    && source_fields.len() == target_fields.len()\n             );\n \n             find_vtable_types_for_unsizing(\n@@ -1209,11 +1225,9 @@ impl<'v> RootCollector<'_, 'v> {\n                 self.output.push(dummy_spanned(MonoItem::GlobalAsm(id)));\n             }\n             DefKind::Static(..) => {\n-                debug!(\n-                    \"RootCollector: ItemKind::Static({})\",\n-                    self.tcx.def_path_str(id.owner_id.to_def_id())\n-                );\n-                self.output.push(dummy_spanned(MonoItem::Static(id.owner_id.to_def_id())));\n+                let def_id = id.owner_id.to_def_id();\n+                debug!(\"RootCollector: ItemKind::Static({})\", self.tcx.def_path_str(def_id));\n+                self.output.push(dummy_spanned(MonoItem::Static(def_id)));\n             }\n             DefKind::Const => {\n                 // const items only generate mono items if they are\n@@ -1326,27 +1340,40 @@ fn create_mono_items_for_default_impls<'tcx>(\n         return;\n     }\n \n+    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n+        return;\n+    };\n+\n+    // Lifetimes never affect trait selection, so we are allowed to eagerly\n+    // instantiate an instance of an impl method if the impl (and method,\n+    // which we check below) is only parameterized over lifetime. In that case,\n+    // we use the ReErased, which has no lifetime information associated with\n+    // it, to validate whether or not the impl is legal to instantiate at all.\n+    let only_region_params = |param: &ty::GenericParamDef, _: &_| match param.kind {\n+        GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+        GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+            unreachable!(\n+                \"`own_requires_monomorphization` check means that \\\n+                we should have no type/const params\"\n+            )\n+        }\n+    };\n+    let impl_substs = InternalSubsts::for_item(tcx, item.owner_id.to_def_id(), only_region_params);\n+    let trait_ref = trait_ref.subst(tcx, impl_substs);\n+\n     // Unlike 'lazy' monomorphization that begins by collecting items transitively\n     // called by `main` or other global items, when eagerly monomorphizing impl\n     // items, we never actually check that the predicates of this impl are satisfied\n     // in a empty reveal-all param env (i.e. with no assumptions).\n     //\n-    // Even though this impl has no substitutions, because we don't consider higher-\n-    // ranked predicates such as `for<'a> &'a mut [u8]: Copy` to be trivially false,\n-    // we must now check that the impl has no impossible-to-satisfy predicates.\n-    if tcx.subst_and_check_impossible_predicates((\n-        item.owner_id.to_def_id(),\n-        &InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id()),\n-    )) {\n+    // Even though this impl has no type or const substitutions, because we don't\n+    // consider higher-ranked predicates such as `for<'a> &'a mut [u8]: Copy` to\n+    // be trivially false. We must now check that the impl has no impossible-to-satisfy\n+    // predicates.\n+    if tcx.subst_and_check_impossible_predicates((item.owner_id.to_def_id(), impl_substs)) {\n         return;\n     }\n \n-    let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) else {\n-        return;\n-    };\n-\n-    let trait_ref = trait_ref.subst_identity();\n-\n     let param_env = ty::ParamEnv::reveal_all();\n     let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n     let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n@@ -1359,12 +1386,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n             continue;\n         }\n \n-        let substs = InternalSubsts::for_item(tcx, method.def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                trait_ref.substs[param.index as usize]\n-            }\n-        });\n+        // As mentioned above, the method is legal to eagerly instantiate if it\n+        // only has lifetime substitutions. This is validated by\n+        let substs = trait_ref.substs.extend_to(tcx, method.def_id, only_region_params);\n         let instance = ty::Instance::expect_resolve(tcx, param_env, method.def_id, substs);\n \n         let mono_item = create_fn_mono_item(tcx, instance, DUMMY_SP);"}, {"sha": "482b78d42e37715e6123abd43ea5ecc28c6a4e7f", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -89,10 +89,7 @@ impl<'tcx> Partitioner<'tcx> for DefaultPartitioning {\n         }\n \n         PreInliningPartitioning {\n-            codegen_units: codegen_units\n-                .into_iter()\n-                .map(|(_, codegen_unit)| codegen_unit)\n-                .collect(),\n+            codegen_units: codegen_units.into_values().map(|codegen_unit| codegen_unit).collect(),\n             roots,\n             internalization_candidates,\n         }\n@@ -278,7 +275,9 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n                 | ty::InstanceDef::Intrinsic(..)\n                 | ty::InstanceDef::DropGlue(..)\n                 | ty::InstanceDef::Virtual(..)\n-                | ty::InstanceDef::CloneShim(..) => return None,\n+                | ty::InstanceDef::CloneShim(..)\n+                | ty::InstanceDef::ThreadLocalShim(..)\n+                | ty::InstanceDef::FnPtrAddrShim(..) => return None,\n             };\n \n             // If this is a method, we want to put it into the same module as\n@@ -391,6 +390,19 @@ fn mono_item_linkage_and_visibility<'tcx>(\n \n type CguNameCache = FxHashMap<(DefId, bool), Symbol>;\n \n+fn static_visibility<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    can_be_internalized: &mut bool,\n+    def_id: DefId,\n+) -> Visibility {\n+    if tcx.is_reachable_non_generic(def_id) {\n+        *can_be_internalized = false;\n+        default_visibility(tcx, def_id, false)\n+    } else {\n+        Visibility::Hidden\n+    }\n+}\n+\n fn mono_item_visibility<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mono_item: &MonoItem<'tcx>,\n@@ -402,28 +414,21 @@ fn mono_item_visibility<'tcx>(\n         MonoItem::Fn(instance) => instance,\n \n         // Misc handling for generics and such, but otherwise:\n-        MonoItem::Static(def_id) => {\n-            return if tcx.is_reachable_non_generic(*def_id) {\n-                *can_be_internalized = false;\n-                default_visibility(tcx, *def_id, false)\n-            } else {\n-                Visibility::Hidden\n-            };\n-        }\n+        MonoItem::Static(def_id) => return static_visibility(tcx, can_be_internalized, *def_id),\n         MonoItem::GlobalAsm(item_id) => {\n-            return if tcx.is_reachable_non_generic(item_id.owner_id) {\n-                *can_be_internalized = false;\n-                default_visibility(tcx, item_id.owner_id.to_def_id(), false)\n-            } else {\n-                Visibility::Hidden\n-            };\n+            return static_visibility(tcx, can_be_internalized, item_id.owner_id.to_def_id());\n         }\n     };\n \n     let def_id = match instance.def {\n         InstanceDef::Item(def) => def.did,\n         InstanceDef::DropGlue(def_id, Some(_)) => def_id,\n \n+        // We match the visiblity of statics here\n+        InstanceDef::ThreadLocalShim(def_id) => {\n+            return static_visibility(tcx, can_be_internalized, def_id);\n+        }\n+\n         // These are all compiler glue and such, never exported, always hidden.\n         InstanceDef::VTableShim(..)\n         | InstanceDef::ReifyShim(..)\n@@ -432,7 +437,8 @@ fn mono_item_visibility<'tcx>(\n         | InstanceDef::Intrinsic(..)\n         | InstanceDef::ClosureOnceShim { .. }\n         | InstanceDef::DropGlue(..)\n-        | InstanceDef::CloneShim(..) => return Visibility::Hidden,\n+        | InstanceDef::CloneShim(..)\n+        | InstanceDef::FnPtrAddrShim(..) => return Visibility::Hidden,\n     };\n \n     // The `start_fn` lang item is actually a monomorphized instance of a"}, {"sha": "e21bbd0217bd5c849a50d4a7c6f9966c0ce56594", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -734,3 +734,7 @@ parse_unknown_start_of_token = unknown start of token: {$escaped}\n \n parse_box_syntax_removed = `box_syntax` has been removed\n     .suggestion = use `Box::new()` instead\n+\n+parse_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type"}, {"sha": "aead216b61cd6c626c6adea665c7b3232dab00d8", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2316,3 +2316,11 @@ pub struct BoxSyntaxRemoved<'a> {\n     pub span: Span,\n     pub code: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bad_return_type_notation_output)]\n+pub(crate) struct BadReturnTypeNotationOutput {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+}"}, {"sha": "5210b8fe69d6e4e7510171b63201f2b22dbab687", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -989,8 +989,7 @@ impl<'a> Parser<'a> {\n                     }\n                     if self.token.kind == token::OpenDelim(Delimiter::Parenthesis) {\n                         // Recover from bad turbofish: `foo.collect::Vec<_>()`.\n-                        let args = AngleBracketedArgs { args, span }.into();\n-                        segment.args = args;\n+                        segment.args = Some(AngleBracketedArgs { args, span }.into());\n \n                         self.sess.emit_err(GenericParamsWithoutAngleBrackets {\n                             span,"}, {"sha": "f1c9f0109f82f4bafa7083ebd0ef788b2cca027c", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,6 +1,6 @@\n use super::ty::{AllowPlus, RecoverQPath, RecoverReturnSign};\n use super::{Parser, Restrictions, TokenType};\n-use crate::maybe_whole;\n+use crate::{errors, maybe_whole};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::{\n@@ -290,6 +290,25 @@ impl<'a> Parser<'a> {\n                     })?;\n                     let span = lo.to(self.prev_token.span);\n                     AngleBracketedArgs { args, span }.into()\n+                } else if self.token.kind == token::OpenDelim(Delimiter::Parenthesis)\n+                    // FIXME(return_type_notation): Could also recover `...` here.\n+                    && self.look_ahead(1, |tok| tok.kind == token::DotDot)\n+                {\n+                    let lo = self.token.span;\n+                    self.bump();\n+                    self.bump();\n+                    self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n+                    let span = lo.to(self.prev_token.span);\n+                    self.sess.gated_spans.gate(sym::return_type_notation, span);\n+\n+                    if self.eat_noexpect(&token::RArrow) {\n+                        let lo = self.prev_token.span;\n+                        let ty = self.parse_ty()?;\n+                        self.sess\n+                            .emit_err(errors::BadReturnTypeNotationOutput { span: lo.to(ty.span) });\n+                    }\n+\n+                    P(GenericArgs::ReturnTypeNotation(span))\n                 } else {\n                     // `(T, U) -> R`\n                     let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n@@ -300,7 +319,7 @@ impl<'a> Parser<'a> {\n                     ParenthesizedArgs { span, inputs, inputs_span, output }.into()\n                 };\n \n-                PathSegment { ident, args, id: ast::DUMMY_NODE_ID }\n+                PathSegment { ident, args: Some(args), id: ast::DUMMY_NODE_ID }\n             } else {\n                 // Generic arguments are not found.\n                 PathSegment::from_ident(ident)\n@@ -550,7 +569,13 @@ impl<'a> Parser<'a> {\n \n                     // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                     if let AssocConstraintKind::Bound { .. } = kind {\n-                        self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n+                        if gen_args.as_ref().map_or(false, |args| {\n+                            matches!(args, GenericArgs::ReturnTypeNotation(..))\n+                        }) {\n+                            // This is already gated in `parse_path_segment`\n+                        } else {\n+                            self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n+                        }\n                     }\n                     let constraint =\n                         AssocConstraint { id: ast::DUMMY_NODE_ID, ident, gen_args, kind, span };"}, {"sha": "400c8dbe9bc6b83d85a307cb78dc0acf655dc227", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1059,8 +1059,11 @@ impl<'a> Parser<'a> {\n             output,\n         }\n         .into();\n-        *fn_path_segment =\n-            ast::PathSegment { ident: fn_path_segment.ident, args, id: ast::DUMMY_NODE_ID };\n+        *fn_path_segment = ast::PathSegment {\n+            ident: fn_path_segment.ident,\n+            args: Some(args),\n+            id: ast::DUMMY_NODE_ID,\n+        };\n \n         // Convert parsed `<'a>` in `Fn<'a>` into `for<'a>`.\n         let mut generic_params = lifetimes"}, {"sha": "b354dca7cc44c1a80830775280a187100c216d52", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -148,9 +148,6 @@ passes_doc_test_unknown =\n passes_doc_test_takes_list =\n     `#[doc(test(...)]` takes a list of attributes\n \n-passes_doc_primitive =\n-    `doc(primitive)` should never have been stable\n-\n passes_doc_cfg_hide_takes_list =\n     `#[doc(cfg_hide(...)]` takes a list of attributes\n "}, {"sha": "80a93da2b45c4bc8327f0a7a97c163f615d2cb78", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1109,17 +1109,6 @@ impl CheckAttrVisitor<'_> {\n                             }\n                         }\n \n-                        sym::primitive => {\n-                            if !self.tcx.features().rustdoc_internals {\n-                                self.tcx.emit_spanned_lint(\n-                                    INVALID_DOC_ATTRIBUTES,\n-                                    hir_id,\n-                                    i_meta.span,\n-                                    errors::DocPrimitive,\n-                                );\n-                            }\n-                        }\n-\n                         _ => {\n                             let path = rustc_ast_pretty::pprust::path_to_string(&i_meta.path);\n                             if i_meta.has_name(sym::spotlight) {"}, {"sha": "91483fe3de77453be6fd8f07cd5d5e32cb0f005f", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_target::abi::FieldIdx;\n use std::mem;\n \n use crate::errors::{\n@@ -232,7 +233,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             if let PatKind::Wild = pat.kind {\n                 continue;\n             }\n-            self.insert_def_id(variant.fields[idx].did);\n+            self.insert_def_id(variant.fields[FieldIdx::from_usize(idx)].did);\n         }\n     }\n "}, {"sha": "8c3dff23b272d1890edb5c72424be78ba368d9fa", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -206,7 +206,7 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_>) {\n     // The file may be empty, which leads to the diagnostic machinery not emitting this\n     // note. This is a relatively simple way to detect that case and emit a span-less\n     // note instead.\n-    let file_empty = !tcx.sess.source_map().lookup_line(sp.hi()).is_ok();\n+    let file_empty = tcx.sess.source_map().lookup_line(sp.hi()).is_err();\n \n     tcx.sess.emit_err(NoMainErr {\n         sp,"}, {"sha": "139ba8c9677561267145e77e8c303b5f5596d4b4", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -288,10 +288,6 @@ pub struct DocTestTakesList;\n #[diag(passes_doc_cfg_hide_takes_list)]\n pub struct DocCfgHideTakesList;\n \n-#[derive(LintDiagnostic)]\n-#[diag(passes_doc_primitive)]\n-pub struct DocPrimitive;\n-\n #[derive(LintDiagnostic)]\n #[diag(passes_doc_test_unknown_any)]\n pub struct DocTestUnknownAny {"}, {"sha": "ce44f709f3b7c09c4b2ed87e681de0816789c371", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -666,7 +666,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_generic_args(&mut self, g: &'v ast::GenericArgs) {\n         record_variants!(\n             (self, g, g, Id::None, ast, GenericArgs, GenericArgs),\n-            [AngleBracketed, Parenthesized]\n+            [AngleBracketed, Parenthesized, ReturnTypeNotation]\n         );\n         ast_visit::walk_generic_args(self, g)\n     }"}, {"sha": "4a1ba19c92064c714bfd5c3ca00cc4a0b3bfc101", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -159,7 +159,9 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             return;\n         }\n \n-        let (stab, const_stab, body_stab) = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let stab = attr::find_stability(&self.tcx.sess, attrs, item_sp);\n+        let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item_sp);\n+        let body_stab = attr::find_body_stability(&self.tcx.sess, attrs);\n         let mut const_span = None;\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n@@ -742,8 +744,8 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 let features = self.tcx.features();\n                 if features.staged_api {\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n-                    let (stab, const_stab, _) =\n-                        attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let stab = attr::find_stability(&self.tcx.sess, attrs, item.span);\n+                    let const_stab = attr::find_const_stability(&self.tcx.sess, attrs, item.span);\n \n                     // If this impl block has an #[unstable] attribute, give an\n                     // error if all involved types and traits are stable, because"}, {"sha": "d27505d1ac84d28202e6d7d08f0124af9851f20b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1082,7 +1082,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n                 // If the expression uses FRU we need to make sure all the unmentioned fields\n                 // are checked for privacy (RFC 736). Rather than computing the set of\n                 // unmentioned fields, just check them all.\n-                for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n+                for (vf_index, variant_field) in variant.fields.iter_enumerated() {\n                     let field = fields\n                         .iter()\n                         .find(|f| self.typeck_results().field_index(f.hir_id) == vf_index);\n@@ -2149,6 +2149,7 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n \n     let mut check_visitor =\n         TestReachabilityVisitor { tcx, effective_visibilities: &visitor.effective_visibilities };\n+    check_visitor.effective_visibility_diagnostic(CRATE_DEF_ID);\n     tcx.hir().visit_all_item_likes_in_crate(&mut check_visitor);\n \n     tcx.arena.alloc(visitor.effective_visibilities)"}, {"sha": "b107a3f03fe590997589a0ae83b80f4f6ec35e1c", "filename": "compiler/rustc_query_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -16,7 +16,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_query_system = { path = \"../rustc_query_system\" }\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "021a67c9513cddc014bd9be00a12c4cb8e1b8289", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -5,7 +5,6 @@\n #![feature(const_mut_refs)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]"}, {"sha": "12b4a1143136bd9a4cbf812d2b2b5445356d3d5c", "filename": "compiler/rustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -15,7 +15,7 @@ rustc_feature = { path = \"../rustc_feature\" }\n rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_macros = { path = \"../rustc_macros\" }\n-rustc-rayon-core = { version = \"0.4.0\", optional = true }\n+rustc-rayon-core = { version = \"0.5.0\", optional = true }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "2ff7de8cb9efc8f60e1602749208f4c339b19dc9", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -535,16 +535,22 @@ impl<K: DepKind> DepGraph<K> {\n             // value to an existing node.\n             //\n             // For sanity, we still check that the loaded stable hash and the new one match.\n-            if let Some(dep_node_index) = data.dep_node_index_of_opt(&node) {\n-                let _current_fingerprint =\n-                    crate::query::incremental_verify_ich(cx, data, result, &node, hash_result);\n+            if let Some(prev_index) = data.previous.node_to_index_opt(&node) {\n+                let dep_node_index = data.current.prev_index_to_index.lock()[prev_index];\n+                if let Some(dep_node_index) = dep_node_index {\n+                    crate::query::incremental_verify_ich(cx, data, result, prev_index, hash_result);\n \n-                #[cfg(debug_assertions)]\n-                if hash_result.is_some() {\n-                    data.current.record_edge(dep_node_index, node, _current_fingerprint);\n-                }\n+                    #[cfg(debug_assertions)]\n+                    if hash_result.is_some() {\n+                        data.current.record_edge(\n+                            dep_node_index,\n+                            node,\n+                            data.prev_fingerprint_of(prev_index),\n+                        );\n+                    }\n \n-                return dep_node_index;\n+                    return dep_node_index;\n+                }\n             }\n \n             let mut edges = SmallVec::new();\n@@ -626,13 +632,19 @@ impl<K: DepKind> DepGraphData<K> {\n \n     /// Returns true if the given node has been marked as green during the\n     /// current compilation session. Used in various assertions\n-    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n-        self.node_color(dep_node).map_or(false, |c| c.is_green())\n+    #[inline]\n+    pub fn is_index_green(&self, prev_index: SerializedDepNodeIndex) -> bool {\n+        self.colors.get(prev_index).map_or(false, |c| c.is_green())\n+    }\n+\n+    #[inline]\n+    pub fn prev_fingerprint_of(&self, prev_index: SerializedDepNodeIndex) -> Fingerprint {\n+        self.previous.fingerprint_by_index(prev_index)\n     }\n \n     #[inline]\n-    pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n-        self.previous.fingerprint_of(dep_node)\n+    pub fn prev_node_of(&self, prev_index: SerializedDepNodeIndex) -> DepNode<K> {\n+        self.previous.index_to_node(prev_index)\n     }\n \n     pub fn mark_debug_loaded_from_disk(&self, dep_node: DepNode<K>) {\n@@ -643,7 +655,7 @@ impl<K: DepKind> DepGraphData<K> {\n impl<K: DepKind> DepGraph<K> {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        self.data.as_ref().and_then(|data| data.dep_node_index_of_opt(dep_node)).is_some()\n+        self.data.as_ref().map_or(false, |data| data.dep_node_exists(dep_node))\n     }\n \n     /// Checks whether a previous work product exists for `v` and, if\n@@ -1053,7 +1065,7 @@ pub(super) struct CurrentDepGraph<K: DepKind> {\n     /// This is used to verify that fingerprints do not change between the creation of a node\n     /// and its recomputation.\n     #[cfg(debug_assertions)]\n-    fingerprints: Lock<FxHashMap<DepNode<K>, Fingerprint>>,\n+    fingerprints: Lock<IndexVec<DepNodeIndex, Option<Fingerprint>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -1139,7 +1151,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             #[cfg(debug_assertions)]\n             forbidden_edge,\n             #[cfg(debug_assertions)]\n-            fingerprints: Lock::new(Default::default()),\n+            fingerprints: Lock::new(IndexVec::from_elem_n(None, new_node_count_estimate)),\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n             node_intern_event_id,\n@@ -1151,14 +1163,8 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         if let Some(forbidden_edge) = &self.forbidden_edge {\n             forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n         }\n-        match self.fingerprints.lock().entry(key) {\n-            Entry::Vacant(v) => {\n-                v.insert(fingerprint);\n-            }\n-            Entry::Occupied(o) => {\n-                assert_eq!(*o.get(), fingerprint, \"Unstable fingerprints for {:?}\", key);\n-            }\n-        }\n+        let previous = *self.fingerprints.lock().get_or_insert_with(dep_node_index, || fingerprint);\n+        assert_eq!(previous, fingerprint, \"Unstable fingerprints for {:?}\", key);\n     }\n \n     /// Writes the node to the current dep-graph and allocates a `DepNodeIndex` for it."}, {"sha": "3d19a84915aec05eb43d1ca5e886e6e418dd0dfe", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -79,11 +79,6 @@ impl<K: DepKind> SerializedDepGraph<K> {\n         self.index.get(dep_node).cloned()\n     }\n \n-    #[inline]\n-    pub fn fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n-        self.index.get(dep_node).map(|&node_index| self.fingerprints[node_index])\n-    }\n-\n     #[inline]\n     pub fn fingerprint_by_index(&self, dep_node_index: SerializedDepNodeIndex) -> Fingerprint {\n         self.fingerprints[dep_node_index]"}, {"sha": "d3efc22a194515a0a67d6e94fe3709216d1072e9", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -21,9 +21,6 @@ pub trait QueryCache: Sized {\n     type Value: Copy + Debug;\n \n     /// Checks if the query is already computed and in the cache.\n-    /// It returns the shard index and a lock guard to the shard,\n-    /// which will be used if the query is not in the cache and we need\n-    /// to compute it.\n     fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n \n     fn complete(&self, key: Self::Key, value: Self::Value, index: DepNodeIndex);"}, {"sha": "a534b54070cd0bccd155fd18bbec89c68a821926", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -18,11 +18,11 @@ use std::num::NonZeroU64;\n #[cfg(parallel_compiler)]\n use {\n     parking_lot::{Condvar, Mutex},\n+    rayon_core,\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::sync::Lock,\n     rustc_data_structures::sync::Lrc,\n     rustc_data_structures::{jobserver, OnDrop},\n-    rustc_rayon_core as rayon_core,\n     rustc_span::DUMMY_SP,\n     std::iter,\n     std::process,\n@@ -124,8 +124,6 @@ impl<D: DepKind> QueryJob<D> {\n }\n \n impl QueryJobId {\n-    #[cold]\n-    #[inline(never)]\n     #[cfg(not(parallel_compiler))]\n     pub(super) fn find_cycle_in_stack<D: DepKind>(\n         &self,"}, {"sha": "519ea5ffed18fe22839b298b20faffa5454cc182", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 170, "deletions": 195, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,20 +6,20 @@ use crate::dep_graph::{DepContext, DepKind, DepNode, DepNodeIndex, DepNodeParams\n use crate::dep_graph::{DepGraphData, HasDepContext};\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n+#[cfg(parallel_compiler)]\n+use crate::query::job::QueryLatch;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n+use crate::query::SerializedDepNodeIndex;\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n use crate::values::Value;\n use crate::HandleCycleError;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::profiling::TimingGuard;\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_data_structures::sync::{Lock, LockGuard};\n+use rustc_data_structures::sync::Lock;\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::{cold_path, sharded::Sharded};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, FatalError};\n-use rustc_session::Session;\n use rustc_span::{Span, DUMMY_SP};\n use std::cell::Cell;\n use std::collections::hash_map::Entry;\n@@ -116,7 +116,6 @@ where\n {\n     state: &'tcx QueryState<K, D>,\n     key: K,\n-    id: QueryJobId,\n }\n \n #[cold]\n@@ -166,81 +165,6 @@ impl<'tcx, K, D: DepKind> JobOwner<'tcx, K, D>\n where\n     K: Eq + Hash + Copy,\n {\n-    /// Either gets a `JobOwner` corresponding the query, allowing us to\n-    /// start executing the query, or returns with the result of the query.\n-    /// This function assumes that `try_get_cached` is already called and returned `lookup`.\n-    /// If the query is executing elsewhere, this will wait for it and return the result.\n-    /// If the query panicked, this will silently panic.\n-    ///\n-    /// This function is inlined because that results in a noticeable speed-up\n-    /// for some compile-time benchmarks.\n-    #[inline(always)]\n-    fn try_start<'b, Qcx>(\n-        qcx: &'b Qcx,\n-        state: &'b QueryState<K, Qcx::DepKind>,\n-        mut state_lock: LockGuard<'b, FxHashMap<K, QueryResult<Qcx::DepKind>>>,\n-        span: Span,\n-        key: K,\n-    ) -> TryGetJob<'b, K, D>\n-    where\n-        Qcx: QueryContext + HasDepContext<DepKind = D>,\n-    {\n-        let lock = &mut *state_lock;\n-        let current_job_id = qcx.current_query_job();\n-\n-        match lock.entry(key) {\n-            Entry::Vacant(entry) => {\n-                let id = qcx.next_job_id();\n-                let job = QueryJob::new(id, span, current_job_id);\n-\n-                let key = *entry.key();\n-                entry.insert(QueryResult::Started(job));\n-\n-                let owner = JobOwner { state, id, key };\n-                return TryGetJob::NotYetStarted(owner);\n-            }\n-            Entry::Occupied(mut entry) => {\n-                match entry.get_mut() {\n-                    #[cfg(not(parallel_compiler))]\n-                    QueryResult::Started(job) => {\n-                        let id = job.id;\n-                        drop(state_lock);\n-\n-                        // If we are single-threaded we know that we have cycle error,\n-                        // so we just return the error.\n-                        return TryGetJob::Cycle(id.find_cycle_in_stack(\n-                            qcx.try_collect_active_jobs().unwrap(),\n-                            &current_job_id,\n-                            span,\n-                        ));\n-                    }\n-                    #[cfg(parallel_compiler)]\n-                    QueryResult::Started(job) => {\n-                        // For parallel queries, we'll block and wait until the query running\n-                        // in another thread has completed. Record how long we wait in the\n-                        // self-profiler.\n-                        let query_blocked_prof_timer = qcx.dep_context().profiler().query_blocked();\n-\n-                        // Get the latch out\n-                        let latch = job.latch();\n-\n-                        drop(state_lock);\n-\n-                        // With parallel queries we might just have to wait on some other\n-                        // thread.\n-                        let result = latch.wait_on(current_job_id, span);\n-\n-                        match result {\n-                            Ok(()) => TryGetJob::JobCompleted(query_blocked_prof_timer),\n-                            Err(cycle) => TryGetJob::Cycle(cycle),\n-                        }\n-                    }\n-                    QueryResult::Poisoned => FatalError.raise(),\n-                }\n-            }\n-        }\n-    }\n-\n     /// Completes the query by updating the query cache with the `result`,\n     /// signals the waiter and forgets the JobOwner, so it won't poison the query\n     fn complete<C>(self, cache: &C, result: C::Value, dep_node_index: DepNodeIndex)\n@@ -307,25 +231,6 @@ pub(crate) struct CycleError<D: DepKind> {\n     pub cycle: Vec<QueryInfo<D>>,\n }\n \n-/// The result of `try_start`.\n-enum TryGetJob<'tcx, K, D>\n-where\n-    K: Eq + Hash + Copy,\n-    D: DepKind,\n-{\n-    /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, K, D>),\n-\n-    /// The query was already completed.\n-    /// Returns the result of the query and its dep-node index\n-    /// if it succeeded or a cycle error if it failed.\n-    #[cfg(parallel_compiler)]\n-    JobCompleted(TimingGuard<'tcx>),\n-\n-    /// Trying to execute the query resulted in a cycle.\n-    Cycle(CycleError<D>),\n-}\n-\n /// Checks if the query is already computed and in the cache.\n /// It returns the shard index and a lock guard to the shard,\n /// which will be used if the query is not in the cache and we need\n@@ -346,6 +251,65 @@ where\n     }\n }\n \n+#[cold]\n+#[inline(never)]\n+#[cfg(not(parallel_compiler))]\n+fn cycle_error<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    try_execute: QueryJobId,\n+    span: Span,\n+) -> (Q::Value, Option<DepNodeIndex>)\n+where\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n+{\n+    let error = try_execute.find_cycle_in_stack(\n+        qcx.try_collect_active_jobs().unwrap(),\n+        &qcx.current_query_job(),\n+        span,\n+    );\n+    (mk_cycle(qcx, error, query.handle_cycle_error()), None)\n+}\n+\n+#[inline(always)]\n+#[cfg(parallel_compiler)]\n+fn wait_for_query<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    span: Span,\n+    key: Q::Key,\n+    latch: QueryLatch<Qcx::DepKind>,\n+    current: Option<QueryJobId>,\n+) -> (Q::Value, Option<DepNodeIndex>)\n+where\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n+{\n+    // For parallel queries, we'll block and wait until the query running\n+    // in another thread has completed. Record how long we wait in the\n+    // self-profiler.\n+    let query_blocked_prof_timer = qcx.dep_context().profiler().query_blocked();\n+\n+    // With parallel queries we might just have to wait on some other\n+    // thread.\n+    let result = latch.wait_on(current, span);\n+\n+    match result {\n+        Ok(()) => {\n+            let Some((v, index)) = query.query_cache(qcx).lookup(&key) else {\n+                cold_path(|| panic!(\"value must be in cache after waiting\"))\n+            };\n+\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n+            query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n+\n+            (v, Some(index))\n+        }\n+        Err(cycle) => (mk_cycle(qcx, cycle, query.handle_cycle_error()), None),\n+    }\n+}\n+\n #[inline(never)]\n fn try_execute_query<Q, Qcx>(\n     query: Q,\n@@ -360,9 +324,9 @@ where\n {\n     let state = query.query_state(qcx);\n     #[cfg(parallel_compiler)]\n-    let state_lock = state.active.get_shard_by_value(&key).lock();\n+    let mut state_lock = state.active.get_shard_by_value(&key).lock();\n     #[cfg(not(parallel_compiler))]\n-    let state_lock = state.active.lock();\n+    let mut state_lock = state.active.lock();\n \n     // For the parallel compiler we need to check both the query cache and query state structures\n     // while holding the state lock to ensure that 1) the query has not yet completed and 2) the\n@@ -377,44 +341,82 @@ where\n         }\n     }\n \n-    match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n-        TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = match qcx.dep_context().dep_graph().data() {\n-                None => execute_job_non_incr(query, qcx, key, job.id),\n-                Some(data) => execute_job_incr(query, qcx, data, key, dep_node, job.id),\n-            };\n+    let current_job_id = qcx.current_query_job();\n+\n+    match state_lock.entry(key) {\n+        Entry::Vacant(entry) => {\n+            // Nothing has computed or is computing the query, so we start a new job and insert it in the\n+            // state map.\n+            let id = qcx.next_job_id();\n+            let job = QueryJob::new(id, span, current_job_id);\n+            entry.insert(QueryResult::Started(job));\n \n-            let cache = query.query_cache(qcx);\n-            if query.feedable() {\n-                // We should not compute queries that also got a value via feeding.\n-                // This can't happen, as query feeding adds the very dependencies to the fed query\n-                // as its feeding query had. So if the fed query is red, so is its feeder, which will\n-                // get evaluated first, and re-feed the query.\n-                if let Some((cached_result, _)) = cache.lookup(&key) {\n-                    panic!(\n-                        \"fed query later has its value computed. The already cached value: {cached_result:?}\"\n-                    );\n+            // Drop the lock before we start executing the query\n+            drop(state_lock);\n+\n+            execute_job(query, qcx, state, key, id, dep_node)\n+        }\n+        Entry::Occupied(mut entry) => {\n+            match entry.get_mut() {\n+                #[cfg(not(parallel_compiler))]\n+                QueryResult::Started(job) => {\n+                    let id = job.id;\n+                    drop(state_lock);\n+\n+                    // If we are single-threaded we know that we have cycle error,\n+                    // so we just return the error.\n+                    cycle_error(query, qcx, id, span)\n+                }\n+                #[cfg(parallel_compiler)]\n+                QueryResult::Started(job) => {\n+                    // Get the latch out\n+                    let latch = job.latch();\n+                    drop(state_lock);\n+\n+                    wait_for_query(query, qcx, span, key, latch, current_job_id)\n                 }\n+                QueryResult::Poisoned => FatalError.raise(),\n             }\n-            job.complete(cache, result, dep_node_index);\n-            (result, Some(dep_node_index))\n         }\n-        TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(qcx, error, query.handle_cycle_error());\n-            (result, None)\n-        }\n-        #[cfg(parallel_compiler)]\n-        TryGetJob::JobCompleted(query_blocked_prof_timer) => {\n-            let Some((v, index)) = query.query_cache(qcx).lookup(&key) else {\n-                panic!(\"value must be in cache after waiting\")\n-            };\n+    }\n+}\n \n-            qcx.dep_context().profiler().query_cache_hit(index.into());\n-            query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n+#[inline(always)]\n+fn execute_job<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    state: &QueryState<Q::Key, Qcx::DepKind>,\n+    key: Q::Key,\n+    id: QueryJobId,\n+    dep_node: Option<DepNode<Qcx::DepKind>>,\n+) -> (Q::Value, Option<DepNodeIndex>)\n+where\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n+{\n+    // Use `JobOwner` so the query will be poisoned if executing it panics.\n+    let job_owner = JobOwner { state, key };\n \n-            (v, Some(index))\n+    let (result, dep_node_index) = match qcx.dep_context().dep_graph().data() {\n+        None => execute_job_non_incr(query, qcx, key, id),\n+        Some(data) => execute_job_incr(query, qcx, data, key, dep_node, id),\n+    };\n+\n+    let cache = query.query_cache(qcx);\n+    if query.feedable() {\n+        // We should not compute queries that also got a value via feeding.\n+        // This can't happen, as query feeding adds the very dependencies to the fed query\n+        // as its feeding query had. So if the fed query is red, so is its feeder, which will\n+        // get evaluated first, and re-feed the query.\n+        if let Some((cached_result, _)) = cache.lookup(&key) {\n+            panic!(\n+                \"fed query later has its value computed. The already cached value: {cached_result:?}\"\n+            );\n         }\n     }\n+    job_owner.complete(cache, result, dep_node_index);\n+\n+    (result, Some(dep_node_index))\n }\n \n // Fast path for when incr. comp. is off.\n@@ -537,7 +539,7 @@ where\n \n     let (prev_dep_node_index, dep_node_index) = dep_graph_data.try_mark_green(qcx, &dep_node)?;\n \n-    debug_assert!(dep_graph_data.is_green(dep_node));\n+    debug_assert!(dep_graph_data.is_index_green(prev_dep_node_index));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n@@ -561,8 +563,7 @@ where\n                 dep_graph_data.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint =\n-                dep_graph_data.prev_fingerprint_of(dep_node).unwrap_or(Fingerprint::ZERO);\n+            let prev_fingerprint = dep_graph_data.prev_fingerprint_of(prev_dep_node_index);\n             // If `-Zincremental-verify-ich` is specified, re-hash results from\n             // the cache and make sure that they have the expected fingerprint.\n             //\n@@ -578,7 +579,7 @@ where\n                     *qcx.dep_context(),\n                     dep_graph_data,\n                     &result,\n-                    dep_node,\n+                    prev_dep_node_index,\n                     query.hash_result(),\n                 );\n             }\n@@ -623,7 +624,7 @@ where\n         *qcx.dep_context(),\n         dep_graph_data,\n         &result,\n-        dep_node,\n+        prev_dep_node_index,\n         query.hash_result(),\n     );\n \n@@ -636,77 +637,50 @@ pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     tcx: Tcx,\n     dep_graph_data: &DepGraphData<Tcx::DepKind>,\n     result: &V,\n-    dep_node: &DepNode<Tcx::DepKind>,\n+    prev_index: SerializedDepNodeIndex,\n     hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n-) -> Fingerprint\n-where\n+) where\n     Tcx: DepContext,\n {\n-    assert!(\n-        dep_graph_data.is_green(dep_node),\n-        \"fingerprint for green query instance not loaded from cache: {dep_node:?}\",\n-    );\n+    if !dep_graph_data.is_index_green(prev_index) {\n+        incremental_verify_ich_not_green(tcx, prev_index)\n+    }\n \n     let new_hash = hash_result.map_or(Fingerprint::ZERO, |f| {\n         tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = dep_graph_data.prev_fingerprint_of(dep_node);\n+    let old_hash = dep_graph_data.prev_fingerprint_of(prev_index);\n \n-    if Some(new_hash) != old_hash {\n-        incremental_verify_ich_failed(\n-            tcx.sess(),\n-            DebugArg::from(&dep_node),\n-            DebugArg::from(&result),\n-        );\n+    if new_hash != old_hash {\n+        incremental_verify_ich_failed(tcx, prev_index, result);\n     }\n-\n-    new_hash\n }\n \n-// This DebugArg business is largely a mirror of std::fmt::ArgumentV1, which is\n-// currently not exposed publicly.\n-//\n-// The PR which added this attempted to use `&dyn Debug` instead, but that\n-// showed statistically significant worse compiler performance. It's not\n-// actually clear what the cause there was -- the code should be cold. If this\n-// can be replaced with `&dyn Debug` with on perf impact, then it probably\n-// should be.\n-extern \"C\" {\n-    type Opaque;\n-}\n-\n-struct DebugArg<'a> {\n-    value: &'a Opaque,\n-    fmt: fn(&Opaque, &mut std::fmt::Formatter<'_>) -> std::fmt::Result,\n-}\n-\n-impl<'a, T> From<&'a T> for DebugArg<'a>\n+#[cold]\n+#[inline(never)]\n+fn incremental_verify_ich_not_green<Tcx>(tcx: Tcx, prev_index: SerializedDepNodeIndex)\n where\n-    T: std::fmt::Debug,\n+    Tcx: DepContext,\n {\n-    fn from(value: &'a T) -> DebugArg<'a> {\n-        DebugArg {\n-            value: unsafe { std::mem::transmute(value) },\n-            fmt: unsafe {\n-                std::mem::transmute(<T as std::fmt::Debug>::fmt as fn(_, _) -> std::fmt::Result)\n-            },\n-        }\n-    }\n-}\n-\n-impl std::fmt::Debug for DebugArg<'_> {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        (self.fmt)(self.value, f)\n-    }\n+    panic!(\n+        \"fingerprint for green query instance not loaded from cache: {:?}\",\n+        tcx.dep_graph().data().unwrap().prev_node_of(prev_index)\n+    )\n }\n \n-// Note that this is marked #[cold] and intentionally takes the equivalent of\n-// `dyn Debug` for its arguments, as we want to avoid generating a bunch of\n-// different implementations for LLVM to chew on (and filling up the final\n-// binary, too).\n+// Note that this is marked #[cold] and intentionally takes `dyn Debug` for `result`,\n+// as we want to avoid generating a bunch of different implementations for LLVM to\n+// chew on (and filling up the final binary, too).\n #[cold]\n-fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result: DebugArg<'_>) {\n+#[inline(never)]\n+fn incremental_verify_ich_failed<Tcx>(\n+    tcx: Tcx,\n+    prev_index: SerializedDepNodeIndex,\n+    result: &dyn Debug,\n+) where\n+    Tcx: DepContext,\n+{\n     // When we emit an error message and panic, we try to debug-print the `DepNode`\n     // and query result. Unfortunately, this can cause us to run additional queries,\n     // which may result in another fingerprint mismatch while we're in the middle\n@@ -720,15 +694,16 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n     let old_in_panic = INSIDE_VERIFY_PANIC.with(|in_panic| in_panic.replace(true));\n \n     if old_in_panic {\n-        sess.emit_err(crate::error::Reentrant);\n+        tcx.sess().emit_err(crate::error::Reentrant);\n     } else {\n-        let run_cmd = if let Some(crate_name) = &sess.opts.crate_name {\n+        let run_cmd = if let Some(crate_name) = &tcx.sess().opts.crate_name {\n             format!(\"`cargo clean -p {crate_name}` or `cargo clean`\")\n         } else {\n             \"`cargo clean`\".to_string()\n         };\n \n-        sess.emit_err(crate::error::IncrementCompilation {\n+        let dep_node = tcx.dep_graph().data().unwrap().prev_node_of(prev_index);\n+        tcx.sess().emit_err(crate::error::IncrementCompilation {\n             run_cmd,\n             dep_node: format!(\"{dep_node:?}\"),\n         });"}, {"sha": "e69a9d0aecaf4a96d8fbeee26d5102587ae038b7", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1669,8 +1669,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     ) -> Option<Symbol> {\n         let mut candidates = self\n             .extern_prelude\n-            .iter()\n-            .map(|(ident, _)| ident.name)\n+            .keys()\n+            .map(|ident| ident.name)\n             .chain(\n                 self.module_map\n                     .iter()\n@@ -2007,7 +2007,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // 1) some consistent ordering for emitted diagnostics, and\n         // 2) `std` suggestions before `core` suggestions.\n         let mut extern_crate_names =\n-            self.extern_prelude.iter().map(|(ident, _)| ident.name).collect::<Vec<_>>();\n+            self.extern_prelude.keys().map(|ident| ident.name).collect::<Vec<_>>();\n         extern_crate_names.sort_by(|a, b| b.as_str().partial_cmp(a.as_str()).unwrap());\n \n         for name in extern_crate_names.into_iter() {"}, {"sha": "3673f603d16767eae28d95f800c980cb3136fa58", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 29, "deletions": 41, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -61,7 +61,7 @@ impl Resolver<'_, '_> {\n         // For mod items `nearest_normal_mod` returns its argument, but we actually need its parent.\n         let normal_mod_id = self.nearest_normal_mod(def_id);\n         if normal_mod_id == def_id {\n-            self.tcx.opt_local_parent(def_id).map_or(Visibility::Public, Visibility::Restricted)\n+            Visibility::Restricted(self.tcx.local_parent(def_id))\n         } else {\n             Visibility::Restricted(normal_mod_id)\n         }\n@@ -80,12 +80,11 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n             r,\n             def_effective_visibilities: Default::default(),\n             import_effective_visibilities: Default::default(),\n-            current_private_vis: Visibility::Public,\n+            current_private_vis: Visibility::Restricted(CRATE_DEF_ID),\n             changed: false,\n         };\n \n-        visitor.update(CRATE_DEF_ID, CRATE_DEF_ID);\n-        visitor.current_private_vis = Visibility::Restricted(CRATE_DEF_ID);\n+        visitor.def_effective_visibilities.update_root();\n         visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n@@ -125,43 +124,32 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n \n         for (_, name_resolution) in resolutions.borrow().iter() {\n             if let Some(mut binding) = name_resolution.borrow().binding() {\n-                if !binding.is_ambiguity() {\n-                    // Set the given effective visibility level to `Level::Direct` and\n-                    // sets the rest of the `use` chain to `Level::Reexported` until\n-                    // we hit the actual exported item.\n-                    let mut parent_id = ParentId::Def(module_id);\n-                    while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind\n-                    {\n-                        let binding_id = ImportId::new_unchecked(binding);\n-                        self.update_import(binding_id, parent_id);\n-\n-                        parent_id = ParentId::Import(binding_id);\n-                        binding = nested_binding;\n-                    }\n-\n-                    if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n-                        self.update_def(def_id, binding.vis.expect_local(), parent_id);\n+                // Set the given effective visibility level to `Level::Direct` and\n+                // sets the rest of the `use` chain to `Level::Reexported` until\n+                // we hit the actual exported item.\n+                //\n+                // If the binding is ambiguous, put the root ambiguity binding and all reexports\n+                // leading to it into the table. They are used by the `ambiguous_glob_reexports`\n+                // lint. For all bindings added to the table this way `is_ambiguity` returns true.\n+                let mut parent_id = ParentId::Def(module_id);\n+                while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind {\n+                    let binding_id = ImportId::new_unchecked(binding);\n+                    self.update_import(binding_id, parent_id);\n+\n+                    if binding.ambiguity.is_some() {\n+                        // Stop at the root ambiguity, further bindings in the chain should not\n+                        // be reexported because the root ambiguity blocks any access to them.\n+                        // (Those further bindings are most likely not ambiguities themselves.)\n+                        break;\n                     }\n-                } else {\n-                    // Put the root ambiguity binding and all reexports leading to it into the\n-                    // table. They are used by the `ambiguous_glob_reexports` lint. For all\n-                    // bindings added to the table here `is_ambiguity` returns true.\n-                    let mut parent_id = ParentId::Def(module_id);\n-                    while let NameBindingKind::Import { binding: nested_binding, .. } = binding.kind\n-                    {\n-                        let binding_id = ImportId::new_unchecked(binding);\n-                        self.update_import(binding_id, parent_id);\n \n-                        if binding.ambiguity.is_some() {\n-                            // Stop at the root ambiguity, further bindings in the chain should not\n-                            // be reexported because the root ambiguity blocks any access to them.\n-                            // (Those further bindings are most likely not ambiguities themselves.)\n-                            break;\n-                        }\n+                    parent_id = ParentId::Import(binding_id);\n+                    binding = nested_binding;\n+                }\n \n-                        parent_id = ParentId::Import(binding_id);\n-                        binding = nested_binding;\n-                    }\n+                if binding.ambiguity.is_none()\n+                    && let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n+                    self.update_def(def_id, binding.vis.expect_local(), parent_id);\n                 }\n             }\n         }\n@@ -213,7 +201,7 @@ impl<'r, 'a, 'tcx> EffectiveVisibilitiesVisitor<'r, 'a, 'tcx> {\n         );\n     }\n \n-    fn update(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n+    fn update_field(&mut self, def_id: LocalDefId, parent_id: LocalDefId) {\n         self.update_def(def_id, self.r.visibilities[&def_id], ParentId::Def(parent_id));\n     }\n }\n@@ -245,14 +233,14 @@ impl<'r, 'ast, 'tcx> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r, 't\n                 for variant in variants {\n                     let variant_def_id = self.r.local_def_id(variant.id);\n                     for field in variant.data.fields() {\n-                        self.update(self.r.local_def_id(field.id), variant_def_id);\n+                        self.update_field(self.r.local_def_id(field.id), variant_def_id);\n                     }\n                 }\n             }\n \n             ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n                 for field in def.fields() {\n-                    self.update(self.r.local_def_id(field.id), def_id);\n+                    self.update_field(self.r.local_def_id(field.id), def_id);\n                 }\n             }\n "}, {"sha": "06206efb9abd52cdf5ed245959011fd581754454", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -389,7 +389,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        assert!(force || !finalize.is_some()); // `finalize` implies `force`\n+        assert!(force || finalize.is_none()); // `finalize` implies `force`\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if orig_ident.is_path_segment_keyword() {"}, {"sha": "b82b07bcf0cc898e55158789825bf01fb22e6fb4", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1110,6 +1110,7 @@ impl<'a: 'ast, 'ast, 'tcx> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast,\n                         }\n                     }\n                 }\n+                GenericArgs::ReturnTypeNotation(_span) => {}\n             }\n         }\n     }\n@@ -2420,8 +2421,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     .iter()\n                     .rfind(|r| matches!(r.kind, ItemRibKind(_)))\n                     .expect(\"associated item outside of an item\");\n-                seen_bindings\n-                    .extend(parent_rib.bindings.iter().map(|(ident, _)| (*ident, ident.span)));\n+                seen_bindings.extend(parent_rib.bindings.keys().map(|ident| (*ident, ident.span)));\n             };\n             add_bindings_for_ns(ValueNS);\n             add_bindings_for_ns(TypeNS);\n@@ -4236,7 +4236,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             {\n                 return;\n             }\n-            ResolveDocLinks::Exported if !maybe_exported.eval(self.r) => {\n+            ResolveDocLinks::Exported\n+                if !maybe_exported.eval(self.r)\n+                    && !rustdoc::has_primitive_or_keyword_docs(attrs) =>\n+            {\n                 return;\n             }\n             ResolveDocLinks::ExportedMetadata"}, {"sha": "99fad22d4a12d9d1d8c05141e1a7ae6e0b2022b8", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -312,6 +312,7 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n                     (args.span, found_lifetimes)\n                 }\n                 GenericArgs::Parenthesized(args) => (args.span, true),\n+                GenericArgs::ReturnTypeNotation(span) => (*span, false),\n             }\n         } else {\n             (DUMMY_SP, false)"}, {"sha": "9eae99be2e901a7ca4520088049b60d18b9a74fa", "filename": "compiler/rustc_resolve/src/rustdoc.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Frustdoc.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,7 +3,7 @@ use rustc_ast as ast;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::def_id::DefId;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n use std::{cmp, mem};\n \n@@ -339,6 +339,22 @@ pub fn inner_docs(attrs: &[ast::Attribute]) -> bool {\n     attrs.iter().find(|a| a.doc_str().is_some()).map_or(true, |a| a.style == ast::AttrStyle::Inner)\n }\n \n+/// Has `#[rustc_doc_primitive]` or `#[doc(keyword)]`.\n+pub fn has_primitive_or_keyword_docs(attrs: &[ast::Attribute]) -> bool {\n+    for attr in attrs {\n+        if attr.has_name(sym::rustc_doc_primitive) {\n+            return true;\n+        } else if attr.has_name(sym::doc) && let Some(items) = attr.meta_item_list() {\n+            for item in items {\n+                if item.has_name(sym::keyword) {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n /// Simplified version of the corresponding function in rustdoc.\n /// If the rustdoc version returns a successful result, this function must return the same result.\n /// Otherwise this function may return anything."}, {"sha": "e4dbb8a637cea9fbc644dc1988700d69684d429c", "filename": "compiler/rustc_serialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_serialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_serialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,7 +4,7 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-indexmap = \"1.9.1\"\n+indexmap = \"1.9.3\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n thin-vec = \"0.2.12\"\n "}, {"sha": "40879db49def9bba2c57990253a3816ab064507f", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -68,6 +68,7 @@ fn current_dll_path() -> Result<PathBuf, String> {\n     use std::ffi::{CStr, OsStr};\n     use std::os::unix::prelude::*;\n \n+    #[cfg(not(target_os = \"aix\"))]\n     unsafe {\n         let addr = current_dll_path as usize as *mut _;\n         let mut info = std::mem::zeroed();\n@@ -81,6 +82,49 @@ fn current_dll_path() -> Result<PathBuf, String> {\n         let os = OsStr::from_bytes(bytes);\n         Ok(PathBuf::from(os))\n     }\n+\n+    #[cfg(target_os = \"aix\")]\n+    unsafe {\n+        // On AIX, the symbol `current_dll_path` references a function descriptor.\n+        // A function descriptor is consisted of (See https://reviews.llvm.org/D62532)\n+        // * The address of the entry point of the function.\n+        // * The TOC base address for the function.\n+        // * The environment pointer.\n+        // The function descriptor is in the data section.\n+        let addr = current_dll_path as u64;\n+        let mut buffer = vec![std::mem::zeroed::<libc::ld_info>(); 64];\n+        loop {\n+            if libc::loadquery(\n+                libc::L_GETINFO,\n+                buffer.as_mut_ptr() as *mut i8,\n+                (std::mem::size_of::<libc::ld_info>() * buffer.len()) as u32,\n+            ) >= 0\n+            {\n+                break;\n+            } else {\n+                if std::io::Error::last_os_error().raw_os_error().unwrap() != libc::ENOMEM {\n+                    return Err(\"loadquery failed\".into());\n+                }\n+                buffer.resize(buffer.len() * 2, std::mem::zeroed::<libc::ld_info>());\n+            }\n+        }\n+        let mut current = buffer.as_mut_ptr() as *mut libc::ld_info;\n+        loop {\n+            let data_base = (*current).ldinfo_dataorg as u64;\n+            let data_end = data_base + (*current).ldinfo_datasize;\n+            if (data_base..data_end).contains(&addr) {\n+                let bytes = CStr::from_ptr(&(*current).ldinfo_filename[0]).to_bytes();\n+                let os = OsStr::from_bytes(bytes);\n+                return Ok(PathBuf::from(os));\n+            }\n+            if (*current).ldinfo_next == 0 {\n+                break;\n+            }\n+            current =\n+                (current as *mut i8).offset((*current).ldinfo_next as isize) as *mut libc::ld_info;\n+        }\n+        return Err(format!(\"current dll's address {} is not in the load map\", addr));\n+    }\n }\n \n #[cfg(windows)]"}, {"sha": "968728905e7e58d2140edcef1fe1d0241c784d89", "filename": "compiler/rustc_session/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_session%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_session%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -2,7 +2,7 @@\n #![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n-#![feature(once_cell)]\n+#![feature(lazy_cell)]\n #![feature(option_get_or_insert_default)]\n #![feature(rustc_attrs)]\n #![feature(map_many_mut)]"}, {"sha": "be5d4fca7a0093b53345b301b4357a205db28a31", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -911,7 +911,7 @@ mod parse {\n         let mut seen_instruction_threshold = false;\n         let mut seen_skip_entry = false;\n         let mut seen_skip_exit = false;\n-        for option in v.into_iter().map(|v| v.split(',')).flatten() {\n+        for option in v.into_iter().flat_map(|v| v.split(',')) {\n             match option {\n                 \"always\" if !seen_always && !seen_never => {\n                     options.always = true;"}, {"sha": "5998c8b6500456668e1e3d808f31b86e48304d4c", "filename": "compiler/rustc_smir/src/rustc_internal/mod.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -3,11 +3,28 @@\n //! For that, we define APIs that will temporarily be public to 3P that exposes rustc internal APIs\n //! until stable MIR is complete.\n \n+use std::sync::RwLock;\n+\n use crate::stable_mir;\n pub use rustc_span::def_id::{CrateNum, DefId};\n \n+static DEF_ID_MAP: RwLock<Vec<DefId>> = RwLock::new(Vec::new());\n+\n pub fn item_def_id(item: &stable_mir::CrateItem) -> DefId {\n-    item.0\n+    DEF_ID_MAP.read().unwrap()[item.0]\n+}\n+\n+pub fn crate_item(did: DefId) -> stable_mir::CrateItem {\n+    // FIXME: this becomes inefficient when we have too many ids\n+    let mut map = DEF_ID_MAP.write().unwrap();\n+    for (i, &d) in map.iter().enumerate() {\n+        if d == did {\n+            return stable_mir::CrateItem(i);\n+        }\n+    }\n+    let id = map.len();\n+    map.push(did);\n+    stable_mir::CrateItem(id)\n }\n \n pub fn crate_num(item: &stable_mir::Crate) -> CrateNum {"}, {"sha": "86e30dd0f6a2adcccd648e53cae8ce371ef3c395", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -7,7 +7,10 @@\n //!\n //! For now, we are developing everything inside `rustc`, thus, we keep this module private.\n \n-use crate::stable_mir::{self};\n+use crate::{\n+    rustc_internal::{crate_item, item_def_id},\n+    stable_mir::{self},\n+};\n use rustc_middle::ty::{tls::with, TyCtxt};\n use rustc_span::def_id::{CrateNum, LOCAL_CRATE};\n use tracing::debug;\n@@ -34,9 +37,7 @@ pub fn find_crate(name: &str) -> Option<stable_mir::Crate> {\n \n /// Retrieve all items of the local crate that have a MIR associated with them.\n pub fn all_local_items() -> stable_mir::CrateItems {\n-    with(|tcx| {\n-        tcx.mir_keys(()).iter().map(|item| stable_mir::CrateItem(item.to_def_id())).collect()\n-    })\n+    with(|tcx| tcx.mir_keys(()).iter().map(|item| crate_item(item.to_def_id())).collect())\n }\n \n /// Build a stable mir crate from a given crate number.\n@@ -46,3 +47,112 @@ fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n     debug!(?crate_name, ?crate_num, \"smir_crate\");\n     stable_mir::Crate { id: crate_num.into(), name: crate_name, is_local }\n }\n+\n+pub fn mir_body(item: &stable_mir::CrateItem) -> stable_mir::mir::Body {\n+    with(|tcx| {\n+        let def_id = item_def_id(item);\n+        let mir = tcx.optimized_mir(def_id);\n+        stable_mir::mir::Body {\n+            blocks: mir\n+                .basic_blocks\n+                .iter()\n+                .map(|block| stable_mir::mir::BasicBlock {\n+                    terminator: rustc_terminator_to_terminator(block.terminator()),\n+                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n+                })\n+                .collect(),\n+        }\n+    })\n+}\n+\n+fn rustc_statement_to_statement(\n+    s: &rustc_middle::mir::Statement<'_>,\n+) -> stable_mir::mir::Statement {\n+    use rustc_middle::mir::StatementKind::*;\n+    match &s.kind {\n+        Assign(assign) => stable_mir::mir::Statement::Assign(\n+            rustc_place_to_place(&assign.0),\n+            rustc_rvalue_to_rvalue(&assign.1),\n+        ),\n+        FakeRead(_) => todo!(),\n+        SetDiscriminant { .. } => todo!(),\n+        Deinit(_) => todo!(),\n+        StorageLive(_) => todo!(),\n+        StorageDead(_) => todo!(),\n+        Retag(_, _) => todo!(),\n+        PlaceMention(_) => todo!(),\n+        AscribeUserType(_, _) => todo!(),\n+        Coverage(_) => todo!(),\n+        Intrinsic(_) => todo!(),\n+        ConstEvalCounter => todo!(),\n+        Nop => stable_mir::mir::Statement::Nop,\n+    }\n+}\n+\n+fn rustc_rvalue_to_rvalue(rvalue: &rustc_middle::mir::Rvalue<'_>) -> stable_mir::mir::Operand {\n+    use rustc_middle::mir::Rvalue::*;\n+    match rvalue {\n+        Use(op) => rustc_op_to_op(op),\n+        Repeat(_, _) => todo!(),\n+        Ref(_, _, _) => todo!(),\n+        ThreadLocalRef(_) => todo!(),\n+        AddressOf(_, _) => todo!(),\n+        Len(_) => todo!(),\n+        Cast(_, _, _) => todo!(),\n+        BinaryOp(_, _) => todo!(),\n+        CheckedBinaryOp(_, _) => todo!(),\n+        NullaryOp(_, _) => todo!(),\n+        UnaryOp(_, _) => todo!(),\n+        Discriminant(_) => todo!(),\n+        Aggregate(_, _) => todo!(),\n+        ShallowInitBox(_, _) => todo!(),\n+        CopyForDeref(_) => todo!(),\n+    }\n+}\n+\n+fn rustc_op_to_op(op: &rustc_middle::mir::Operand<'_>) -> stable_mir::mir::Operand {\n+    use rustc_middle::mir::Operand::*;\n+    match op {\n+        Copy(place) => stable_mir::mir::Operand::Copy(rustc_place_to_place(place)),\n+        Move(place) => stable_mir::mir::Operand::Move(rustc_place_to_place(place)),\n+        Constant(c) => stable_mir::mir::Operand::Constant(c.to_string()),\n+    }\n+}\n+\n+fn rustc_place_to_place(place: &rustc_middle::mir::Place<'_>) -> stable_mir::mir::Place {\n+    assert_eq!(&place.projection[..], &[]);\n+    stable_mir::mir::Place { local: place.local.as_usize() }\n+}\n+\n+fn rustc_terminator_to_terminator(\n+    terminator: &rustc_middle::mir::Terminator<'_>,\n+) -> stable_mir::mir::Terminator {\n+    use rustc_middle::mir::TerminatorKind::*;\n+    use stable_mir::mir::Terminator;\n+    match &terminator.kind {\n+        Goto { target } => Terminator::Goto { target: target.as_usize() },\n+        SwitchInt { discr, targets } => Terminator::SwitchInt {\n+            discr: rustc_op_to_op(discr),\n+            targets: targets\n+                .iter()\n+                .map(|(value, target)| stable_mir::mir::SwitchTarget {\n+                    value,\n+                    target: target.as_usize(),\n+                })\n+                .collect(),\n+            otherwise: targets.otherwise().as_usize(),\n+        },\n+        Resume => Terminator::Resume,\n+        Abort => Terminator::Abort,\n+        Return => Terminator::Return,\n+        Unreachable => Terminator::Unreachable,\n+        Drop { .. } => todo!(),\n+        Call { .. } => todo!(),\n+        Assert { .. } => todo!(),\n+        Yield { .. } => todo!(),\n+        GeneratorDrop => todo!(),\n+        FalseEdge { .. } => todo!(),\n+        FalseUnwind { .. } => todo!(),\n+        InlineAsm { .. } => todo!(),\n+    }\n+}"}, {"sha": "a9dbc3463f80b3c5efbcf5103d5966b0b6aadc14", "filename": "compiler/rustc_smir/src/stable_mir/mir.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -0,0 +1,3 @@\n+mod body;\n+\n+pub use body::*;"}, {"sha": "c504065c993c90795f7150291464c52fcf2f3153", "filename": "compiler/rustc_smir/src/stable_mir/mir/body.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -0,0 +1,69 @@\n+#[derive(Clone, Debug)]\n+pub struct Body {\n+    pub blocks: Vec<BasicBlock>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct BasicBlock {\n+    pub statements: Vec<Statement>,\n+    pub terminator: Terminator,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum Terminator {\n+    Goto {\n+        target: usize,\n+    },\n+    SwitchInt {\n+        discr: Operand,\n+        targets: Vec<SwitchTarget>,\n+        otherwise: usize,\n+    },\n+    Resume,\n+    Abort,\n+    Return,\n+    Unreachable,\n+    Drop {\n+        place: Place,\n+        target: usize,\n+        unwind: Option<usize>,\n+    },\n+    Call {\n+        func: Operand,\n+        args: Vec<Operand>,\n+        destination: Place,\n+        target: Option<usize>,\n+        cleanup: Option<usize>,\n+    },\n+    Assert {\n+        cond: Operand,\n+        expected: bool,\n+        msg: String,\n+        target: usize,\n+        cleanup: Option<usize>,\n+    },\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum Statement {\n+    Assign(Place, Operand),\n+    Nop,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum Operand {\n+    Copy(Place),\n+    Move(Place),\n+    Constant(String),\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct Place {\n+    pub local: usize,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct SwitchTarget {\n+    pub value: u128,\n+    pub target: usize,\n+}"}, {"sha": "ba23186224a750fbc9662cbd68fa61c1fce09990", "filename": "compiler/rustc_smir/src/stable_mir/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -11,7 +11,7 @@\n //! There shouldn't be any direct references to internal compiler constructs in this module.\n //! If you need an internal construct, consider using `rustc_internal` or `rustc_smir`.\n \n-use crate::rustc_internal;\n+pub mod mir;\n \n /// Use String for now but we should replace it.\n pub type Symbol = String;\n@@ -37,7 +37,13 @@ pub struct Crate {\n /// For now, it only stores the item DefId. Use functions inside `rustc_internal` module to\n /// use this item.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct CrateItem(pub(crate) rustc_internal::DefId);\n+pub struct CrateItem(pub(crate) DefId);\n+\n+impl CrateItem {\n+    pub fn body(&self) -> mir::Body {\n+        crate::rustc_smir::mir_body(self)\n+    }\n+}\n \n /// Access to the local crate.\n pub fn local_crate() -> Crate {"}, {"sha": "a7c7575f392e6fdeab11daba9c47a4d4fa733e0b", "filename": "compiler/rustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2FCargo.toml?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -18,4 +18,4 @@ tracing = \"0.1\"\n sha1 = \"0.10.0\"\n sha2 = \"0.10.1\"\n md5 = { package = \"md-5\", version = \"0.10.0\" }\n-indexmap = { version = \"1.9.1\" }\n+indexmap = { version = \"1.9.3\" }"}, {"sha": "0bb42a3a71fde1544bc31aa7b08c355f2b3fff74", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -109,7 +109,7 @@ fn assert_default_hashing_controls<CTX: HashStableContext>(ctx: &CTX, msg: &str)\n         // This is the case for instance when building a hash for name mangling.\n         // Such configuration must not be used for metadata.\n         HashingControls { hash_spans }\n-            if hash_spans == !ctx.unstable_opts_incremental_ignore_spans() => {}\n+            if hash_spans != ctx.unstable_opts_incremental_ignore_spans() => {}\n         other => panic!(\"Attempted hashing of {msg} with non-default HashingControls: {other:?}\"),\n     }\n }"}, {"sha": "e14760aa01885207faa7a3bfd4fbc3a7fcf7ec54", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -87,6 +87,14 @@ pub struct SessionGlobals {\n     symbol_interner: symbol::Interner,\n     span_interner: Lock<span_encoding::SpanInterner>,\n     hygiene_data: Lock<hygiene::HygieneData>,\n+\n+    /// A reference to the source map in the `Session`. It's an `Option`\n+    /// because it can't be initialized until `Session` is created, which\n+    /// happens after `SessionGlobals`. `set_source_map` does the\n+    /// initialization.\n+    ///\n+    /// This field should only be used in places where the `Session` is truly\n+    /// not available, such as `<Span as Debug>::fmt`.\n     source_map: Lock<Option<Lrc<SourceMap>>>,\n }\n \n@@ -1013,16 +1021,9 @@ impl<D: Decoder> Decodable<D> for Span {\n     }\n }\n \n-/// Calls the provided closure, using the provided `SourceMap` to format\n-/// any spans that are debug-printed during the closure's execution.\n-///\n-/// Normally, the global `TyCtxt` is used to retrieve the `SourceMap`\n-/// (see `rustc_interface::callbacks::span_debug1`). However, some parts\n-/// of the compiler (e.g. `rustc_parse`) may debug-print `Span`s before\n-/// a `TyCtxt` is available. In this case, we fall back to\n-/// the `SourceMap` provided to this function. If that is not available,\n-/// we fall back to printing the raw `Span` field values.\n-pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) -> T {\n+/// Insert `source_map` into the session globals for the duration of the\n+/// closure's execution.\n+pub fn set_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) -> T {\n     with_session_globals(|session_globals| {\n         *session_globals.source_map.borrow_mut() = Some(source_map);\n     });\n@@ -1041,6 +1042,8 @@ pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) ->\n \n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // Use the global `SourceMap` to print the span. If that's not\n+        // available, fall back to printing the raw values.\n         with_session_globals(|session_globals| {\n             if let Some(source_map) = &*session_globals.source_map.borrow() {\n                 write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(*self), self.ctxt())"}, {"sha": "66e5369da3ae1a8da287a3f2f5b15f743551b7cc", "filename": "compiler/rustc_span/src/profiling.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fprofiling.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,3 +1,5 @@\n+use crate::source_map::SourceMap;\n+\n use std::borrow::Borrow;\n \n use rustc_data_structures::profiling::EventArgRecorder;\n@@ -11,25 +13,17 @@ pub trait SpannedEventArgRecorder {\n     ///\n     /// Note: when self-profiling with costly event arguments, at least one argument\n     /// needs to be recorded. A panic will be triggered if that doesn't happen.\n-    fn record_arg_with_span<A>(&mut self, event_arg: A, span: crate::Span)\n+    fn record_arg_with_span<A>(&mut self, source_map: &SourceMap, event_arg: A, span: crate::Span)\n     where\n         A: Borrow<str> + Into<String>;\n }\n \n impl SpannedEventArgRecorder for EventArgRecorder<'_> {\n-    fn record_arg_with_span<A>(&mut self, event_arg: A, span: crate::Span)\n+    fn record_arg_with_span<A>(&mut self, source_map: &SourceMap, event_arg: A, span: crate::Span)\n     where\n         A: Borrow<str> + Into<String>,\n     {\n         self.record_arg(event_arg);\n-\n-        let span_arg = crate::with_session_globals(|session_globals| {\n-            if let Some(source_map) = &*session_globals.source_map.borrow() {\n-                source_map.span_to_embeddable_string(span)\n-            } else {\n-                format!(\"{span:?}\")\n-            }\n-        });\n-        self.record_arg(span_arg);\n+        self.record_arg(source_map.span_to_embeddable_string(span));\n     }\n }"}, {"sha": "0e55e81143de46c040ab2a4cba15446ce92b1ee5", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -722,6 +722,8 @@ symbols! {\n         fn_mut,\n         fn_once,\n         fn_once_output,\n+        fn_ptr_addr,\n+        fn_ptr_trait,\n         forbid,\n         forget,\n         format,\n@@ -1067,6 +1069,7 @@ symbols! {\n         panic_implementation,\n         panic_info,\n         panic_location,\n+        panic_misaligned_pointer_dereference,\n         panic_nounwind,\n         panic_runtime,\n         panic_str,\n@@ -1193,6 +1196,7 @@ symbols! {\n         residual,\n         result,\n         return_position_impl_trait_in_trait,\n+        return_type_notation,\n         rhs,\n         rintf32,\n         rintf64,\n@@ -1243,6 +1247,7 @@ symbols! {\n         rustc_diagnostic_macros,\n         rustc_dirty,\n         rustc_do_not_const_check,\n+        rustc_doc_primitive,\n         rustc_dummy,\n         rustc_dump_env_program_clauses,\n         rustc_dump_program_clauses,"}, {"sha": "5cbca81926b9aab2dbfa806f72b2a5b927ec0fbd", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -65,6 +65,10 @@ pub(super) fn mangle<'tcx>(\n         )\n         .unwrap();\n \n+    if let ty::InstanceDef::ThreadLocalShim(..) = instance.def {\n+        let _ = printer.write_str(\"{{tls-shim}}\");\n+    }\n+\n     if let ty::InstanceDef::VTableShim(..) = instance.def {\n         let _ = printer.write_str(\"{{vtable-shim}}\");\n     }"}, {"sha": "cac7ff72267dbcc359e96e6761639fb63eaf146c", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -42,6 +42,7 @@ pub(super) fn mangle<'tcx>(\n \n     // Append `::{shim:...#0}` to shims that can coexist with a non-shim instance.\n     let shim_kind = match instance.def {\n+        ty::InstanceDef::ThreadLocalShim(_) => Some(\"tls\"),\n         ty::InstanceDef::VTableShim(_) => Some(\"vtable\"),\n         ty::InstanceDef::ReifyShim(_) => Some(\"reify\"),\n "}, {"sha": "0a5e654cf0d03d981fd699f76b4750286101fff1", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_ohos.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_ohos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_ohos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_ohos.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -0,0 +1,31 @@\n+use crate::spec::{Target, TargetOptions};\n+\n+use super::SanitizerSet;\n+\n+pub fn target() -> Target {\n+    let mut base = super::linux_musl_base::opts();\n+    base.env = \"ohos\".into();\n+    base.crt_static_default = false;\n+    base.max_atomic_width = Some(128);\n+\n+    Target {\n+        // LLVM 15 doesn't support OpenHarmony yet, use a linux target instead.\n+        llvm_target: \"aarch64-unknown-linux-musl\".into(),\n+        pointer_width: 64,\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".into(),\n+        arch: \"aarch64\".into(),\n+        options: TargetOptions {\n+            features: \"+reserve-x18\".into(),\n+            mcount: \"\\u{1}_mcount\".into(),\n+            force_emulated_tls: true,\n+            supported_sanitizers: SanitizerSet::ADDRESS\n+                | SanitizerSet::CFI\n+                | SanitizerSet::LEAK\n+                | SanitizerSet::MEMORY\n+                | SanitizerSet::MEMTAG\n+                | SanitizerSet::THREAD\n+                | SanitizerSet::HWADDRESS,\n+            ..base\n+        },\n+    }\n+}"}, {"sha": "d0f988b278ff8ef50586403b920167001df5381c", "filename": "compiler/rustc_target/src/spec/armv4t_none_eabi.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv4t_none_eabi.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,13 +4,6 @@\n //!\n //! Please ping @Lokathor if changes are needed.\n //!\n-//! This target profile assumes that you have the ARM binutils in your path\n-//! (specifically the linker, `arm-none-eabi-ld`). They can be obtained for free\n-//! for all major OSes from the ARM developer's website, and they may also be\n-//! available in your system's package manager. Unfortunately, the standard\n-//! linker that Rust uses (`lld`) only supports as far back as `ARMv5TE`, so we\n-//! must use the GNU `ld` linker.\n-//!\n //! **Important:** This target profile **does not** specify a linker script. You\n //! just get the default link script when you build a binary for this target.\n //! The default link script is very likely wrong, so you should use\n@@ -35,8 +28,8 @@ pub fn target() -> Target {\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".into(),\n         options: TargetOptions {\n             abi: \"eabi\".into(),\n-            linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::No),\n-            linker: Some(\"arm-none-eabi-ld\".into()),\n+            linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::Yes),\n+            linker: Some(\"rust-lld\".into()),\n             asm_args: cvs![\"-mthumb-interwork\", \"-march=armv4t\", \"-mlittle-endian\",],\n             // Force-enable 32-bit atomics, which allows the use of atomic load/store only.\n             // The resulting atomics are ABI incompatible with atomics backed by libatomic."}, {"sha": "a64f3a4f0493e46607c4c871553e1926a67f2a36", "filename": "compiler/rustc_target/src/spec/armv7_unknown_linux_ohos.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_ohos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_ohos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Farmv7_unknown_linux_ohos.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -0,0 +1,27 @@\n+use crate::spec::{Target, TargetOptions};\n+\n+// This target is for OpenHarmony on ARMv7 Linux with thumb-mode, but no NEON or\n+// hardfloat.\n+\n+pub fn target() -> Target {\n+    // Most of these settings are copied from the armv7_unknown_linux_musleabi\n+    // target.\n+    Target {\n+        // LLVM 15 doesn't support OpenHarmony yet, use a linux target instead.\n+        llvm_target: \"armv7-unknown-linux-gnueabi\".into(),\n+        pointer_width: 32,\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".into(),\n+        arch: \"arm\".into(),\n+\n+        options: TargetOptions {\n+            abi: \"eabi\".into(),\n+            features: \"+v7,+thumb2,+soft-float,-neon\".into(),\n+            max_atomic_width: Some(64),\n+            env: \"ohos\".into(),\n+            crt_static_default: false,\n+            mcount: \"\\u{1}mcount\".into(),\n+            force_emulated_tls: true,\n+            ..super::linux_musl_base::opts()\n+        },\n+    }\n+}"}, {"sha": "bb45fb125b240d5e1a24176130b95dc0040b7936", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1261,6 +1261,9 @@ supported_targets! {\n \n     (\"aarch64-unknown-nto-qnx710\", aarch64_unknown_nto_qnx_710),\n     (\"x86_64-pc-nto-qnx710\", x86_64_pc_nto_qnx710),\n+\n+    (\"aarch64-unknown-linux-ohos\", aarch64_unknown_linux_ohos),\n+    (\"armv7-unknown-linux-ohos\", armv7_unknown_linux_ohos),\n }\n \n /// Cow-Vec-Str: Cow<'static, [Cow<'static, str>]>\n@@ -1468,6 +1471,8 @@ pub struct TargetOptions {\n     pub features: StaticCow<str>,\n     /// Whether dynamic linking is available on this target. Defaults to false.\n     pub dynamic_linking: bool,\n+    /// Whether dynamic linking can export TLS globals. Defaults to true.\n+    pub dll_tls_export: bool,\n     /// If dynamic linking is available, whether only cdylibs are supported.\n     pub only_cdylib: bool,\n     /// Whether executables are available on this target. Defaults to true.\n@@ -1734,6 +1739,9 @@ pub struct TargetOptions {\n \n     /// Whether the target supports XRay instrumentation.\n     pub supports_xray: bool,\n+\n+    /// Forces the use of emulated TLS (__emutls_get_address)\n+    pub force_emulated_tls: bool,\n }\n \n /// Add arguments for the given flavor and also for its \"twin\" flavors\n@@ -1859,6 +1867,7 @@ impl Default for TargetOptions {\n             cpu: \"generic\".into(),\n             features: \"\".into(),\n             dynamic_linking: false,\n+            dll_tls_export: true,\n             only_cdylib: false,\n             executables: true,\n             relocation_model: RelocModel::Pic,\n@@ -1954,6 +1963,7 @@ impl Default for TargetOptions {\n             entry_name: \"main\".into(),\n             entry_abi: Conv::C,\n             supports_xray: false,\n+            force_emulated_tls: false,\n         }\n     }\n }\n@@ -2530,6 +2540,7 @@ impl Target {\n         key!(cpu);\n         key!(features);\n         key!(dynamic_linking, bool);\n+        key!(dll_tls_export, bool);\n         key!(only_cdylib, bool);\n         key!(executables, bool);\n         key!(relocation_model, RelocModel)?;\n@@ -2605,6 +2616,7 @@ impl Target {\n         key!(entry_name);\n         key!(entry_abi, Conv)?;\n         key!(supports_xray, bool);\n+        key!(force_emulated_tls, bool);\n \n         if base.is_builtin {\n             // This can cause unfortunate ICEs later down the line.\n@@ -2783,6 +2795,7 @@ impl ToJson for Target {\n         target_option_val!(cpu);\n         target_option_val!(features);\n         target_option_val!(dynamic_linking);\n+        target_option_val!(dll_tls_export);\n         target_option_val!(only_cdylib);\n         target_option_val!(executables);\n         target_option_val!(relocation_model);\n@@ -2859,6 +2872,7 @@ impl ToJson for Target {\n         target_option_val!(entry_name);\n         target_option_val!(entry_abi);\n         target_option_val!(supports_xray);\n+        target_option_val!(force_emulated_tls);\n \n         if let Some(abi) = self.default_adjusted_cabi {\n             d.insert(\"default-adjusted-cabi\".into(), Abi::name(abi).to_json());"}, {"sha": "efe949a4e9074479ddd1e0bfaa3b928d15419aae", "filename": "compiler/rustc_target/src/spec/msvc_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmsvc_base.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,6 +8,7 @@ pub fn opts() -> TargetOptions {\n \n     TargetOptions {\n         linker_flavor: LinkerFlavor::Msvc(Lld::No),\n+        dll_tls_export: false,\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args,"}, {"sha": "9c59bb9114ecb222f4e48dbddd715f4e9dd130ff", "filename": "compiler/rustc_target/src/spec/thumbv4t_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fthumbv4t_none_eabi.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -4,19 +4,12 @@\n //!\n //! Please ping @Lokathor if changes are needed.\n //!\n-//! This target profile assumes that you have the ARM binutils in your path\n-//! (specifically the linker, `arm-none-eabi-ld`). They can be obtained for free\n-//! for all major OSes from the ARM developer's website, and they may also be\n-//! available in your system's package manager. Unfortunately, the standard\n-//! linker that Rust uses (`lld`) only supports as far back as `ARMv5TE`, so we\n-//! must use the GNU `ld` linker.\n-//!\n //! **Important:** This target profile **does not** specify a linker script. You\n //! just get the default link script when you build a binary for this target.\n //! The default link script is very likely wrong, so you should use\n //! `-Clink-arg=-Tmy_script.ld` to override that with a correct linker script.\n \n-use crate::spec::{cvs, Cc, FramePointer, LinkerFlavor, Lld};\n+use crate::spec::{cvs, FramePointer};\n use crate::spec::{PanicStrategy, RelocModel, Target, TargetOptions};\n \n pub fn target() -> Target {\n@@ -36,8 +29,6 @@ pub fn target() -> Target {\n         data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".into(),\n         options: TargetOptions {\n             abi: \"eabi\".into(),\n-            linker_flavor: LinkerFlavor::Gnu(Cc::No, Lld::No),\n-            linker: Some(\"arm-none-eabi-ld\".into()),\n \n             // extra args passed to the external assembler (assuming `arm-none-eabi-as`):\n             // * activate t32/a32 interworking"}, {"sha": "341763aadbaf1729495c40a84bec0f89deb9a602", "filename": "compiler/rustc_target/src/spec/wasm_base.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwasm_base.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,3 +1,4 @@\n+use super::crt_objects::LinkSelfContainedDefault;\n use super::{cvs, Cc, LinkerFlavor, PanicStrategy, RelocModel, TargetOptions, TlsModel};\n \n pub fn options() -> TargetOptions {\n@@ -94,6 +95,13 @@ pub fn options() -> TargetOptions {\n \n         pre_link_args,\n \n+        // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n+        //\n+        // rust-lang/rust#104137: cannot blindly remove this without putting in\n+        // some other way to compensate for lack of `-nostartfiles` in linker\n+        // invocation.\n+        link_self_contained: LinkSelfContainedDefault::True,\n+\n         // This has no effect in LLVM 8 or prior, but in LLVM 9 and later when\n         // PIC code is implemented this has quite a drastic effect if it stays\n         // at the default, `pic`. In an effort to keep wasm binaries as minimal"}, {"sha": "2231983f071262889399f88cec67c2a6e21ef65c", "filename": "compiler/rustc_target/src/spec/windows_gnu_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnu_base.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -78,6 +78,7 @@ pub fn opts() -> TargetOptions {\n         function_sections: false,\n         linker: Some(\"gcc\".into()),\n         dynamic_linking: true,\n+        dll_tls_export: false,\n         dll_prefix: \"\".into(),\n         dll_suffix: \".dll\".into(),\n         exe_suffix: \".exe\".into(),"}, {"sha": "b1d8e2be5a61fa1f18e0099f7f6d008b6bbc4fd2", "filename": "compiler/rustc_target/src/spec/windows_gnullvm_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -23,6 +23,7 @@ pub fn opts() -> TargetOptions {\n         abi: \"llvm\".into(),\n         linker: Some(\"clang\".into()),\n         dynamic_linking: true,\n+        dll_tls_export: false,\n         dll_prefix: \"\".into(),\n         dll_suffix: \".dll\".into(),\n         exe_suffix: \".exe\".into(),"}, {"sha": "856b1c08b7237d610a36290b30e2448601aaa5fa", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,10 +1,12 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n+use super::search_graph::OverflowHandler;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n use crate::traits::coherence;\n use itertools::Itertools;\n+use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate_predicates;\n@@ -153,6 +155,12 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n+    // A type is a `FnPtr` if it is of `FnPtr` type.\n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n+\n     // A callable type (a closure, fn def, or fn ptr) is known to implement the `Fn<A>`\n     // family of traits where `A` is given by the signature of the type.\n     fn consider_builtin_fn_trait_candidates(\n@@ -212,6 +220,11 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    fn consider_builtin_destruct_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -268,25 +281,38 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             return\n         };\n \n-        self.probe(|ecx| {\n-            let normalized_ty = ecx.next_ty_infer();\n-            let normalizes_to_goal = goal.with(\n-                tcx,\n-                ty::Binder::dummy(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    term: normalized_ty.into(),\n-                }),\n-            );\n-            ecx.add_goal(normalizes_to_goal);\n-            if let Ok(_) = ecx.try_evaluate_added_goals() {\n-                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n-\n-                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-                // This doesn't work as long as we use `CandidateSource` in winnowing.\n-                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n-            }\n+        let normalized_self_candidates: Result<_, NoSolution> = self.probe(|ecx| {\n+            ecx.with_incremented_depth(\n+                |ecx| {\n+                    let result = ecx.evaluate_added_goals_and_make_canonical_response(\n+                        Certainty::Maybe(MaybeCause::Overflow),\n+                    )?;\n+                    Ok(vec![Candidate { source: CandidateSource::BuiltinImpl, result }])\n+                },\n+                |ecx| {\n+                    let normalized_ty = ecx.next_ty_infer();\n+                    let normalizes_to_goal = goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty,\n+                            term: normalized_ty.into(),\n+                        }),\n+                    );\n+                    ecx.add_goal(normalizes_to_goal);\n+                    let _ = ecx.try_evaluate_added_goals()?;\n+                    let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+                    // NOTE: Alternatively we could call `evaluate_goal` here and only\n+                    // have a `Normalized` candidate. This doesn't work as long as we\n+                    // use `CandidateSource` in winnowing.\n+                    let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                    Ok(ecx.assemble_and_evaluate_candidates(goal))\n+                },\n+            )\n         });\n+\n+        if let Ok(normalized_self_candidates) = normalized_self_candidates {\n+            candidates.extend(normalized_self_candidates);\n+        }\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>(\n@@ -326,6 +352,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_copy_clone_candidate(self, goal)\n         } else if lang_items.pointer_like() == Some(trait_def_id) {\n             G::consider_builtin_pointer_like_candidate(self, goal)\n+        } else if lang_items.fn_ptr_trait() == Some(trait_def_id) {\n+            G::consider_builtin_fn_ptr_trait_candidate(self, goal)\n         } else if let Some(kind) = self.tcx().fn_trait_kind_from_def_id(trait_def_id) {\n             G::consider_builtin_fn_trait_candidates(self, goal, kind)\n         } else if lang_items.tuple_trait() == Some(trait_def_id) {\n@@ -340,6 +368,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             G::consider_builtin_unsize_candidate(self, goal)\n         } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n             G::consider_builtin_discriminant_kind_candidate(self, goal)\n+        } else if lang_items.destruct_trait() == Some(trait_def_id) {\n+            G::consider_builtin_destruct_candidate(self, goal)\n         } else {\n             Err(NoSolution)\n         };\n@@ -460,10 +490,22 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         };\n \n         let tcx = self.tcx();\n-        for assumption in\n-            elaborate_predicates(tcx, bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)))\n-        {\n-            match G::consider_object_bound_candidate(self, goal, assumption.predicate) {\n+        let own_bounds: FxIndexSet<_> =\n+            bounds.iter().map(|bound| bound.with_self_ty(tcx, self_ty)).collect();\n+        for assumption in elaborate_predicates(tcx, own_bounds.iter().copied()) {\n+            // FIXME: Predicates are fully elaborated in the object type's existential bounds\n+            // list. We want to only consider these pre-elaborated projections, and not other\n+            // projection predicates that we reach by elaborating the principal trait ref,\n+            // since that'll cause ambiguity.\n+            //\n+            // We can remove this when we have implemented intersections in responses.\n+            if assumption.to_opt_poly_projection_pred().is_some()\n+                && !own_bounds.contains(&assumption)\n+            {\n+                continue;\n+            }\n+\n+            match G::consider_object_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n                 }"}, {"sha": "2e5a8b7debc511b50eda684573f07380fd8d8b68", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n                 if nt != t {\n                     return self.fold_ty(nt);\n                 } else {\n-                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Float)\n                 }\n             }\n             ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {", "previous_filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs"}, {"sha": "705e79aebd8c1ffbfa998bb664e15a481f6ae6e8", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 131, "deletions": 40, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -6,23 +6,42 @@ use rustc_infer::infer::{\n     DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n };\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n };\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n+use crate::traits::specialization_graph;\n+\n use super::search_graph::{self, OverflowHandler};\n use super::SolverMode;\n use super::{search_graph::SearchGraph, Goal};\n \n+mod canonical;\n+\n pub struct EvalCtxt<'a, 'tcx> {\n-    // FIXME: should be private.\n-    pub(super) infcx: &'a InferCtxt<'tcx>,\n+    /// The inference context that backs (mostly) inference and placeholder terms\n+    /// instantiated while solving goals.\n+    ///\n+    /// NOTE: The `InferCtxt` that backs the `EvalCtxt` is intentionally private,\n+    /// because the `InferCtxt` is much more general than `EvalCtxt`. Methods such\n+    /// as  `take_registered_region_obligations` can mess up query responses,\n+    /// using `At::normalize` is totally wrong, calling `evaluate_root_goal` can\n+    /// cause coinductive unsoundness, etc.\n+    ///\n+    /// Methods that are generally of use for trait solving are *intentionally*\n+    /// re-declared through the `EvalCtxt` below, often with cleaner signatures\n+    /// since we don't care about things like `ObligationCause`s and `Span`s here.\n+    /// If some `InferCtxt` method is missing, please first think defensively about\n+    /// the method's compatibility with this solver, or if an existing one does\n+    /// the job already.\n+    infcx: &'a InferCtxt<'tcx>,\n+\n     pub(super) var_values: CanonicalVarValues<'tcx>,\n     /// The highest universe index nameable by the caller.\n     ///\n@@ -48,7 +67,20 @@ pub(super) enum IsNormalizesToHack {\n \n #[derive(Debug, Clone)]\n pub(super) struct NestedGoals<'tcx> {\n+    /// This normalizes-to goal that is treated specially during the evaluation\n+    /// loop. In each iteration we take the RHS of the projection, replace it with\n+    /// a fresh inference variable, and only after evaluating that goal do we\n+    /// equate the fresh inference variable with the actual RHS of the predicate.\n+    ///\n+    /// This is both to improve caching, and to avoid using the RHS of the\n+    /// projection predicate to influence the normalizes-to candidate we select.\n+    ///\n+    /// This is not a 'real' nested goal. We must not forget to replace the RHS\n+    /// with a fresh inference variable when we evaluate this goal. That can result\n+    /// in a trait solver cycle. This would currently result in overflow but can be\n+    /// can be unsound with more powerful coinduction in the future.\n     pub(super) normalizes_to_hack_goal: Option<Goal<'tcx, ty::ProjectionPredicate<'tcx>>>,\n+    /// The rest of the goals which have not yet processed or remain ambiguous.\n     pub(super) goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n }\n \n@@ -163,6 +195,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             canonical_response,\n         )?;\n \n+        if !has_changed && !nested_goals.is_empty() {\n+            bug!(\"an unchanged goal shouldn't have any side-effects on instantiation\");\n+        }\n+\n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n         //\n@@ -180,9 +216,17 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n-                bug!(\"unstable result: {goal:?} {canonical_goal:?} {canonical_response:?}\");\n+                bug!(\n+                    \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n+            }\n+            if certainty != canonical_response.value.certainty {\n+                bug!(\n+                    \"unstable certainty: {certainty:#?} re-canonicalized goal={canonical_goal:#?} \\\n+                     response={canonical_response:#?}\"\n+                );\n             }\n-            assert_eq!(certainty, canonical_response.value.certainty);\n         }\n \n         Ok((has_changed, certainty, nested_goals))\n@@ -262,15 +306,44 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 let mut has_changed = Err(Certainty::Yes);\n \n                 if let Some(goal) = goals.normalizes_to_hack_goal.take() {\n-                    let (_, certainty, nested_goals) = match this.evaluate_goal(\n-                        IsNormalizesToHack::Yes,\n-                        goal.with(this.tcx(), ty::Binder::dummy(goal.predicate)),\n+                    // Replace the goal with an unconstrained infer var, so the\n+                    // RHS does not affect projection candidate assembly.\n+                    let unconstrained_rhs = this.next_term_infer_of_kind(goal.predicate.term);\n+                    let unconstrained_goal = goal.with(\n+                        this.tcx(),\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: goal.predicate.projection_ty,\n+                            term: unconstrained_rhs,\n+                        }),\n+                    );\n+\n+                    let (_, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::Yes, unconstrained_goal) {\n+                            Ok(r) => r,\n+                            Err(NoSolution) => return Some(Err(NoSolution)),\n+                        };\n+                    new_goals.goals.extend(instantiate_goals);\n+\n+                    // Finally, equate the goal's RHS with the unconstrained var.\n+                    // We put the nested goals from this into goals instead of\n+                    // next_goals to avoid needing to process the loop one extra\n+                    // time if this goal returns something -- I don't think this\n+                    // matters in practice, though.\n+                    match this.eq_and_get_goals(\n+                        goal.param_env,\n+                        goal.predicate.term,\n+                        unconstrained_rhs,\n                     ) {\n-                        Ok(r) => r,\n+                        Ok(eq_goals) => {\n+                            goals.goals.extend(eq_goals);\n+                        }\n                         Err(NoSolution) => return Some(Err(NoSolution)),\n                     };\n-                    new_goals.goals.extend(nested_goals);\n \n+                    // We only look at the `projection_ty` part here rather than\n+                    // looking at the \"has changed\" return from evaluate_goal,\n+                    // because we expect the `unconstrained_rhs` part of the predicate\n+                    // to have changed -- that means we actually normalized successfully!\n                     if goal.predicate.projection_ty\n                         != this.resolve_vars_if_possible(goal.predicate.projection_ty)\n                     {\n@@ -280,40 +353,22 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            let goal = this.resolve_vars_if_possible(goal);\n-\n-                            // The rhs of this `normalizes-to` must always be an unconstrained infer var as it is\n-                            // the hack used by `normalizes-to` to ensure that every `normalizes-to` behaves the same\n-                            // regardless of the rhs.\n-                            //\n-                            // However it is important not to unconditionally replace the rhs with a new infer var\n-                            // as otherwise we may replace the original unconstrained infer var with a new infer var\n-                            // and never propagate any constraints on the new var back to the original var.\n-                            let term = this\n-                                .term_is_fully_unconstrained(goal)\n-                                .then_some(goal.predicate.term)\n-                                .unwrap_or_else(|| {\n-                                    this.next_term_infer_of_kind(goal.predicate.term)\n-                                });\n-                            let projection_pred = ty::ProjectionPredicate {\n-                                term,\n-                                projection_ty: goal.predicate.projection_ty,\n-                            };\n+                            // We need to resolve vars here so that we correctly\n+                            // deal with `has_changed` in the next iteration.\n                             new_goals.normalizes_to_hack_goal =\n-                                Some(goal.with(this.tcx(), projection_pred));\n-\n+                                Some(this.resolve_vars_if_possible(goal));\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }\n                 }\n \n-                for nested_goal in goals.goals.drain(..) {\n-                    let (changed, certainty, nested_goals) =\n-                        match this.evaluate_goal(IsNormalizesToHack::No, nested_goal) {\n+                for goal in goals.goals.drain(..) {\n+                    let (changed, certainty, instantiate_goals) =\n+                        match this.evaluate_goal(IsNormalizesToHack::No, goal) {\n                             Ok(result) => result,\n                             Err(NoSolution) => return Some(Err(NoSolution)),\n                         };\n-                    new_goals.goals.extend(nested_goals);\n+                    new_goals.goals.extend(instantiate_goals);\n \n                     if changed {\n                         has_changed = Ok(());\n@@ -322,7 +377,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     match certainty {\n                         Certainty::Yes => {}\n                         Certainty::Maybe(_) => {\n-                            new_goals.goals.push(nested_goal);\n+                            new_goals.goals.push(goal);\n                             has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n                         }\n                     }\n@@ -393,7 +448,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n                     match self.infcx.probe_ty_var(vid) {\n                         Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == self.universe(),\n+                        Err(universe) => universe == self.infcx.universe(),\n                     }\n                 } else {\n                     false\n@@ -403,7 +458,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n                     match self.infcx.probe_const_var(vid) {\n                         Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == self.universe(),\n+                        Err(universe) => universe == self.infcx.universe(),\n                     }\n                 } else {\n                     false\n@@ -545,7 +600,43 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         self.infcx.fresh_substs_for_item(DUMMY_SP, def_id)\n     }\n \n-    pub(super) fn universe(&self) -> ty::UniverseIndex {\n-        self.infcx.universe()\n+    pub(super) fn translate_substs(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        source_impl: DefId,\n+        source_substs: ty::SubstsRef<'tcx>,\n+        target_node: specialization_graph::Node,\n+    ) -> ty::SubstsRef<'tcx> {\n+        crate::traits::translate_substs(\n+            self.infcx,\n+            param_env,\n+            source_impl,\n+            source_substs,\n+            target_node,\n+        )\n+    }\n+\n+    pub(super) fn register_ty_outlives(&self, ty: Ty<'tcx>, lt: ty::Region<'tcx>) {\n+        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n+    }\n+\n+    pub(super) fn register_region_outlives(&self, a: ty::Region<'tcx>, b: ty::Region<'tcx>) {\n+        // `b : a` ==> `a <= b`\n+        // (inlined from `InferCtxt::region_outlives_predicate`)\n+        self.infcx.sub_regions(\n+            rustc_infer::infer::SubregionOrigin::RelateRegionParamBound(DUMMY_SP),\n+            b,\n+            a,\n+        );\n+    }\n+\n+    /// Computes the list of goals required for `arg` to be well-formed\n+    pub(super) fn well_formed_goals(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        arg: ty::GenericArg<'tcx>,\n+    ) -> Option<impl Iterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>> {\n+        crate::traits::wf::unnormalized_obligations(self.infcx, param_env, arg)\n+            .map(|obligations| obligations.into_iter().map(|obligation| obligation.into()))\n     }\n }"}, {"sha": "ee90488730a645cfa941ea5ac18442a2a22b235a", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "renamed", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -8,22 +8,19 @@\n /// section of the [rustc-dev-guide][c].\n ///\n /// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n-use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n-use super::{CanonicalResponse, ExternalConstraints, QueryResult, Response};\n+use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n+use crate::solve::{CanonicalResponse, QueryResult, Response};\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n-use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::solve::ExternalConstraintsData;\n-use rustc_infer::traits::ObligationCause;\n+use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use rustc_middle::ty::{self, GenericArgKind};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n \n-mod canonicalize;\n-\n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// Canonicalizes the goal remembering the original values\n     /// for each bound variable.\n@@ -48,7 +45,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// - `external_constraints`: additional constraints which aren't expressable\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub(super) fn evaluate_added_goals_and_make_canonical_response(\n+    pub(in crate::solve) fn evaluate_added_goals_and_make_canonical_response(\n         &mut self,\n         certainty: Certainty,\n     ) -> QueryResult<'tcx> {\n@@ -219,15 +216,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {\n         for &(ty::OutlivesPredicate(lhs, rhs), _) in &region_constraints.outlives {\n             match lhs.unpack() {\n-                GenericArgKind::Lifetime(lhs) => self.infcx.region_outlives_predicate(\n-                    &ObligationCause::dummy(),\n-                    ty::Binder::dummy(ty::OutlivesPredicate(lhs, rhs)),\n-                ),\n-                GenericArgKind::Type(lhs) => self.infcx.register_region_obligation_with_cause(\n-                    lhs,\n-                    rhs,\n-                    &ObligationCause::dummy(),\n-                ),\n+                GenericArgKind::Lifetime(lhs) => self.register_region_outlives(lhs, rhs),\n+                GenericArgKind::Type(lhs) => self.register_ty_outlives(lhs, rhs),\n                 GenericArgKind::Const(_) => bug!(\"const outlives: {lhs:?}: {rhs:?}\"),\n             }\n         }", "previous_filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs"}, {"sha": "a96ec2c60f0970b85eed9a140d7ed3d1bbdbc8af", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -9,24 +9,19 @@\n //! FIXME(@lcnr): Write that section. If you read this before then ask me\n //! about it on zulip.\n \n-// FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n-\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n-    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, QueryResult, Response,\n+    CanonicalResponse, Certainty, ExternalConstraintsData, Goal, QueryResult, Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n \n-use crate::traits::ObligationCause;\n-\n mod assembly;\n-mod canonical;\n+mod canonicalize;\n mod eval_ctxt;\n mod fulfill;\n mod project_goals;\n@@ -68,7 +63,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n-        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n+        self.register_ty_outlives(ty, lt);\n         self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n@@ -77,10 +72,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.region_outlives_predicate(\n-            &ObligationCause::dummy(),\n-            ty::Binder::dummy(goal.predicate),\n-        );\n+        let ty::OutlivesPredicate(a, b) = goal.predicate;\n+        self.register_region_outlives(a, b);\n         self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n@@ -105,8 +98,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, SubtypePredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         if goal.predicate.a.is_ty_var() && goal.predicate.b.is_ty_var() {\n-            // FIXME: Do we want to register a subtype relation between these vars?\n-            // That won't actually reflect in the query response, so it seems moot.\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n             self.sub(goal.param_env, goal.predicate.a, goal.predicate.b)?;\n@@ -146,13 +137,9 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match crate::traits::wf::unnormalized_obligations(\n-            self.infcx,\n-            goal.param_env,\n-            goal.predicate,\n-        ) {\n-            Some(obligations) => {\n-                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+        match self.well_formed_goals(goal.param_env, goal.predicate) {\n+            Some(goals) => {\n+                self.add_goals(goals);\n                 self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }\n             None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),"}, {"sha": "e0a69438dec0ed802013cbe85c67cfae5b3d8741", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/949a38509e0f2444361e28e322fda2f74c297c80/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=949a38509e0f2444361e28e322fda2f74c297c80", "patch": "@@ -1,4 +1,4 @@\n-use crate::traits::{specialization_graph, translate_substs};\n+use crate::traits::specialization_graph;\n \n use super::assembly;\n use super::trait_goals::structural_traits;\n@@ -7,7 +7,6 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n@@ -17,7 +16,6 @@ use rustc_middle::ty::ProjectionPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ToPredicate, TypeVisitableExt};\n use rustc_span::{sym, DUMMY_SP};\n-use std::iter;\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     #[instrument(level = \"debug\", skip(self), ret)]\n@@ -36,16 +34,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let candidates = self.assemble_and_evaluate_candidates(goal);\n             self.merge_candidates(candidates)\n         } else {\n-            let predicate = goal.predicate;\n-            let unconstrained_rhs = self.next_term_infer_of_kind(predicate.term);\n-            let unconstrained_predicate = ProjectionPredicate {\n-                projection_ty: goal.predicate.projection_ty,\n-                term: unconstrained_rhs,\n-            };\n-\n-            self.set_normalizes_to_hack_goal(goal.with(self.tcx(), unconstrained_predicate));\n-            self.try_evaluate_added_goals()?;\n-            self.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n+            self.set_normalizes_to_hack_goal(goal);\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n@@ -144,9 +133,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n         let impl_trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::ForLookup };\n-        if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n-            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n-        {\n+        if !drcx.substs_refs_may_unify(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs) {\n             return Err(NoSolution);\n         }\n \n@@ -168,13 +155,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             // return ambiguity this would otherwise be incomplete, resulting in\n             // unsoundness during coherence (#105782).\n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                ecx.infcx,\n+                ecx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n+                return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -199,8 +186,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal_trait_ref.def_id,\n                 impl_substs,\n             );\n-            let substs = translate_substs(\n-                ecx.infcx,\n+            let substs = ecx.translate_substs(\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -261,6 +247,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         bug!(\"`PointerLike` does not have an associated type: {:?}\", goal);\n     }\n \n+    fn consider_builtin_fn_ptr_trait_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`FnPtr` does not have an associated type: {:?}\", goal);\n+    }\n+\n     fn consider_builtin_fn_trait_candidates(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n@@ -342,14 +335,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         LangItem::Sized,\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n-\n                     ecx.add_goal(goal.with(tcx, sized_predicate));\n-                    ecx.eq(goal.param_env, goal.predicate.term, tcx.types.unit.into())?;\n-                    return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes);\n+                    tcx.types.unit\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n-                    match def.non_enum_variant().fields.last() {\n+                    match def.non_enum_variant().fields.raw.last() {\n                         None => tcx.types.unit,\n                         Some(field_def) => {\n                             let self_ty = field_def.ty(tcx, substs);\n@@ -481,27 +472,74 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx> {\n-        let discriminant = goal.predicate.self_ty().discriminant_ty(ecx.tcx());\n+        let self_ty = goal.predicate.self_ty();\n+        let discriminant_ty = match *self_ty.kind() {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(..)\n+            | ty::Uint(..)\n+            | ty::Float(..)\n+            | ty::Array(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::FnDef(..)\n+            | ty::FnPtr(..)\n+            | ty::Closure(..)\n+            | ty::Infer(ty::IntVar(..) | ty::FloatVar(..))\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Never\n+            | ty::Foreign(..)\n+            | ty::Adt(_, _)\n+            | ty::Str\n+            | ty::Slice(_)\n+            | ty::Dynamic(_, _, _)\n+            | ty::Tuple(_)\n+            | ty::Error(_) => self_ty.discriminant_ty(ecx.tcx()),\n+\n+            // We do not call `Ty::discriminant_ty` on alias, param, or placeholder\n+            // types, which return `<self_ty as DiscriminantKind>::Discriminant`\n+            // (or ICE in the case of placeholders). Projecting a type to itself\n+            // is never really productive.\n+            ty::Alias(_, _) | ty::Param(_) | ty::Placeholder(..) => {\n+                return Err(NoSolution);\n+            }\n+\n+            ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_))\n+            | ty::Bound(..) => bug!(\n+                \"unexpected self ty `{:?}` when normalizing `<T as DiscriminantKind>::Discriminant`\",\n+                goal.predicate.self_ty()\n+            ),\n+        };\n+\n         ecx.probe(|ecx| {\n-            ecx.eq(goal.param_env, goal.predicate.term, discriminant.into())?;\n+            ecx.eq(goal.param_env, goal.predicate.term, discriminant_ty.into())?;\n             ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         })\n     }\n+\n+    fn consider_builtin_destruct_candidate(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> QueryResult<'tcx> {\n+        bug!(\"`Destruct` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n ///\n /// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n /// diverge.\n-#[instrument(level = \"debug\", skip(infcx, param_env), ret)]\n+#[instrument(level = \"debug\", skip(ecx, param_env), ret)]\n fn fetch_eligible_assoc_item_def<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     goal_trait_ref: ty::TraitRef<'tcx>,\n     trait_assoc_def_id: DefId,\n     impl_def_id: DefId,\n ) -> Result<Option<LeafDef>, NoSolution> {\n-    let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n+    let node_item = specialization_graph::assoc_def(ecx.tcx(), impl_def_id, trait_assoc_def_id)\n         .map_err(|ErrorGuaranteed { .. }| NoSolution)?;\n \n     let eligible = if node_item.is_final() {\n@@ -513,7 +551,7 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n         // transmute checking and polymorphic MIR optimizations could\n         // get a result which isn't correct for all monomorphizations.\n         if param_env.reveal() == Reveal::All {\n-            let poly_trait_ref = infcx.resolve_vars_if_possible(goal_trait_ref);\n+            let poly_trait_ref = ecx.resolve_vars_if_possible(goal_trait_ref);\n             !poly_trait_ref.still_further_specializable()\n         } else {\n             debug!(?node_item.item.def_id, \"not eligible due to default\");"}]}