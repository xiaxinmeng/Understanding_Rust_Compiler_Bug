{"sha": "cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "node_id": "C_kwDOAAsO6NoAKGNiYjY0OWFkZmUxNzJhOWVmNGIxYjkxNjg4YzE0YjU3YzZjM2I4Mzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T07:39:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T07:39:16Z"}, "message": "Auto merge of #2249 - dtolnay-contrib:rustfmt3, r=oli-obk\n\nFormat tests with rustfmt (151-200 of 300)\n\nExtracted from #2097.\n\nThis PR is still only doing the easy cases with no comments involved.\n\nIn the next PRs after this, I'll start grouping by common comment patterns, e.g. all the cases resembling https://github.com/rust-lang/miri/pull/2097#discussion_r862436672 together in one PR.", "tree": {"sha": "60aeeafee6a8768b68524ac5b0208d27e07d971b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60aeeafee6a8768b68524ac5b0208d27e07d971b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "html_url": "https://github.com/rust-lang/rust/commit/cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "332f2894ede0e30149d04030eefd87030569d013", "url": "https://api.github.com/repos/rust-lang/rust/commits/332f2894ede0e30149d04030eefd87030569d013", "html_url": "https://github.com/rust-lang/rust/commit/332f2894ede0e30149d04030eefd87030569d013"}, {"sha": "1c66163871fc0c88bdfa435b8c5d6aedf2a3d4c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c66163871fc0c88bdfa435b8c5d6aedf2a3d4c7", "html_url": "https://github.com/rust-lang/rust/commit/1c66163871fc0c88bdfa435b8c5d6aedf2a3d4c7"}], "stats": {"total": 664, "additions": 350, "deletions": 314}, "files": [{"sha": "82cbaed462c69416fd3fd6e421a5a0c8e335c01f", "filename": "tests/fail/intrinsics/simd-rem-by-zero.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-rem-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-rem-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-rem-by-zero.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,8 +8,10 @@ extern \"platform-intrinsic\" {\n #[allow(non_camel_case_types)]\n struct i32x2(i32, i32);\n \n-fn main() { unsafe {\n-    let x = i32x2(1, 1);\n-    let y = i32x2(1, 0);\n-    simd_rem(x, y); //~ERROR Undefined Behavior: calculating the remainder with a divisor of zero\n-} }\n+fn main() {\n+    unsafe {\n+        let x = i32x2(1, 1);\n+        let y = i32x2(1, 0);\n+        simd_rem(x, y); //~ERROR Undefined Behavior: calculating the remainder with a divisor of zero\n+    }\n+}"}, {"sha": "1adc9f8235eef0d79336e15b87045913650f8f06", "filename": "tests/fail/intrinsics/simd-rem-by-zero.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-rem-by-zero.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-rem-by-zero.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-rem-by-zero.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: calculating the remainder with a divisor of zero\n   --> $DIR/simd-rem-by-zero.rs:LL:CC\n    |\n-LL |     simd_rem(x, y);\n-   |     ^^^^^^^^^^^^^^ calculating the remainder with a divisor of zero\n+LL |         simd_rem(x, y);\n+   |         ^^^^^^^^^^^^^^ calculating the remainder with a divisor of zero\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "d7a7e344aa30c110adc7c49d0db17806fdd10823", "filename": "tests/fail/intrinsics/simd-scatter.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -2,8 +2,14 @@\n #![feature(portable_simd)]\n use std::simd::*;\n \n-fn main() { unsafe {\n-    let mut vec: Vec<i8> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    let idxs = Simd::from_array([9, 3, 0, 17]);\n-    Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(&mut vec, Mask::splat(true), idxs);\n-} }\n+fn main() {\n+    unsafe {\n+        let mut vec: Vec<i8> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+        let idxs = Simd::from_array([9, 3, 0, 17]);\n+        Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(\n+            &mut vec,\n+            Mask::splat(true),\n+            idxs,\n+        );\n+    }\n+}"}, {"sha": "bc6a06fc88e5255f2aed9d9f534a18eba391f97c", "filename": "tests/fail/intrinsics/simd-scatter.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -11,8 +11,12 @@ LL |             intrinsics::simd_scatter(self, ptrs, enable.to_int())\n note: inside `main` at $DIR/simd-scatter.rs:LL:CC\n   --> $DIR/simd-scatter.rs:LL:CC\n    |\n-LL |     Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(&mut vec, Mask::splat(true), idxs);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | /         Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(\n+LL | |             &mut vec,\n+LL | |             Mask::splat(true),\n+LL | |             idxs,\n+LL | |         );\n+   | |_________^\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "cc9170c646462b072770e07bd2c9cc59eb3b0ecc", "filename": "tests/fail/intrinsics/simd-select-bitmask-invalid.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-bitmask-invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-bitmask-invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-select-bitmask-invalid.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -9,7 +9,9 @@ extern \"platform-intrinsic\" {\n #[derive(Copy, Clone)]\n struct i32x2(i32, i32);\n \n-fn main() { unsafe {\n-    let x = i32x2(0, 1);\n-    simd_select_bitmask(0b11111111u8, x, x); //~ERROR bitmask less than 8 bits long must be filled with 0s for the remaining bits\n-} }\n+fn main() {\n+    unsafe {\n+        let x = i32x2(0, 1);\n+        simd_select_bitmask(0b11111111u8, x, x); //~ERROR bitmask less than 8 bits long must be filled with 0s for the remaining bits\n+    }\n+}"}, {"sha": "0a72ed39827b224ca2f781181db6e092336d95a5", "filename": "tests/fail/intrinsics/simd-select-bitmask-invalid.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-bitmask-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-bitmask-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-select-bitmask-invalid.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\n   --> $DIR/simd-select-bitmask-invalid.rs:LL:CC\n    |\n-LL |     simd_select_bitmask(0b11111111u8, x, x);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\n+LL |         simd_select_bitmask(0b11111111u8, x, x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a SIMD bitmask less than 8 bits long must be filled with 0s for the remaining bits\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "8ccf4c362c90b1dc20598322893ce0b77969ddae", "filename": "tests/fail/intrinsics/simd-select-invalid-bool.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-invalid-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-invalid-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-select-invalid-bool.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -9,7 +9,9 @@ extern \"platform-intrinsic\" {\n #[derive(Copy, Clone)]\n struct i32x2(i32, i32);\n \n-fn main() { unsafe {\n-    let x = i32x2(0, 1);\n-    simd_select(x, x, x); //~ERROR must be all-0-bits or all-1-bits\n-} }\n+fn main() {\n+    unsafe {\n+        let x = i32x2(0, 1);\n+        simd_select(x, x, x); //~ERROR must be all-0-bits or all-1-bits\n+    }\n+}"}, {"sha": "c0ceaac06cddf96a773da806ad97bf173da3b4a3", "filename": "tests/fail/intrinsics/simd-select-invalid-bool.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-invalid-bool.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-select-invalid-bool.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-select-invalid-bool.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: each element of a SIMD mask must be all-0-bits or all-1-bits\n   --> $DIR/simd-select-invalid-bool.rs:LL:CC\n    |\n-LL |     simd_select(x, x, x);\n-   |     ^^^^^^^^^^^^^^^^^^^^ each element of a SIMD mask must be all-0-bits or all-1-bits\n+LL |         simd_select(x, x, x);\n+   |         ^^^^^^^^^^^^^^^^^^^^ each element of a SIMD mask must be all-0-bits or all-1-bits\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "e971b042066cbd84e54b68182f4d9529e1e3f720", "filename": "tests/fail/intrinsics/simd-shl-too-far.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shl-too-far.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shl-too-far.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-shl-too-far.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,8 +8,10 @@ extern \"platform-intrinsic\" {\n #[allow(non_camel_case_types)]\n struct i32x2(i32, i32);\n \n-fn main() { unsafe {\n-    let x = i32x2(1, 1);\n-    let y = i32x2(100, 0);\n-    simd_shl(x, y); //~ERROR overflowing shift by 100 in `simd_shl` in SIMD lane 0\n-} }\n+fn main() {\n+    unsafe {\n+        let x = i32x2(1, 1);\n+        let y = i32x2(100, 0);\n+        simd_shl(x, y); //~ERROR overflowing shift by 100 in `simd_shl` in SIMD lane 0\n+    }\n+}"}, {"sha": "1d990e341e68da859ec426cfa51c30470466d9c8", "filename": "tests/fail/intrinsics/simd-shl-too-far.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shl-too-far.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shl-too-far.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-shl-too-far.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: overflowing shift by 100 in `simd_shl` in SIMD lane 0\n   --> $DIR/simd-shl-too-far.rs:LL:CC\n    |\n-LL |     simd_shl(x, y);\n-   |     ^^^^^^^^^^^^^^ overflowing shift by 100 in `simd_shl` in SIMD lane 0\n+LL |         simd_shl(x, y);\n+   |         ^^^^^^^^^^^^^^ overflowing shift by 100 in `simd_shl` in SIMD lane 0\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "ae071f0b7ea13080fd87cbcddf400f8b2529892c", "filename": "tests/fail/intrinsics/simd-shr-too-far.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shr-too-far.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shr-too-far.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-shr-too-far.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,8 +8,10 @@ extern \"platform-intrinsic\" {\n #[allow(non_camel_case_types)]\n struct i32x2(i32, i32);\n \n-fn main() { unsafe {\n-    let x = i32x2(1, 1);\n-    let y = i32x2(20, 40);\n-    simd_shr(x, y); //~ERROR overflowing shift by 40 in `simd_shr` in SIMD lane 1\n-} }\n+fn main() {\n+    unsafe {\n+        let x = i32x2(1, 1);\n+        let y = i32x2(20, 40);\n+        simd_shr(x, y); //~ERROR overflowing shift by 40 in `simd_shr` in SIMD lane 1\n+    }\n+}"}, {"sha": "58ef3737545aae67c50bf011c57cdaf3eea18294", "filename": "tests/fail/intrinsics/simd-shr-too-far.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shr-too-far.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fintrinsics%2Fsimd-shr-too-far.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fintrinsics%2Fsimd-shr-too-far.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,8 @@\n error: Undefined Behavior: overflowing shift by 40 in `simd_shr` in SIMD lane 1\n   --> $DIR/simd-shr-too-far.rs:LL:CC\n    |\n-LL |     simd_shr(x, y);\n-   |     ^^^^^^^^^^^^^^ overflowing shift by 40 in `simd_shr` in SIMD lane 1\n+LL |         simd_shr(x, y);\n+   |         ^^^^^^^^^^^^^^ overflowing shift by 40 in `simd_shr` in SIMD lane 1\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information"}, {"sha": "7ba4da9018a7196dcba52444c59ae5a48aa4dc77", "filename": "tests/fail/invalid_enum_tag.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Finvalid_enum_tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Finvalid_enum_tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Finvalid_enum_tag.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,7 +8,10 @@ use std::mem;\n \n #[repr(C)]\n pub enum Foo {\n-    A, B, C, D\n+    A,\n+    B,\n+    C,\n+    D,\n }\n \n fn main() {"}, {"sha": "caf2b28c5a86e9dff500107e129f0b491f85a1c0", "filename": "tests/fail/issue-miri-1112.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fissue-miri-1112.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fissue-miri-1112.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fissue-miri-1112.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -12,11 +12,7 @@ pub struct Meta {\n \n impl Meta {\n     pub fn new() -> Self {\n-        Meta {\n-            drop_fn: |_| {},\n-            size: 0,\n-            align: 1,\n-        }\n+        Meta { drop_fn: |_| {}, size: 0, align: 1 }\n     }\n }\n "}, {"sha": "9ea809f76299b676971aa12d3fed44c43db5a179", "filename": "tests/fail/memleak_rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fmemleak_rc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fmemleak_rc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fmemleak_rc.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -2,8 +2,8 @@\n // stderr-per-bitwidth\n // normalize-stderr-test: \".*\u2502.*\" -> \"$$stripped$$\"\n \n-use std::rc::Rc;\n use std::cell::RefCell;\n+use std::rc::Rc;\n \n struct Dummy(Rc<RefCell<Option<Dummy>>>);\n "}, {"sha": "0c884142bf1d78eb6e771554702685d03bd803ec", "filename": "tests/fail/modifying_constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fmodifying_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fmodifying_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fmodifying_constants.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -4,6 +4,6 @@\n fn main() {\n     let x = &1; // the `&1` is promoted to a constant, but it used to be that only the pointer is marked static, not the pointee\n     let y = unsafe { &mut *(x as *const i32 as *mut i32) };\n-    *y = 42;  //~ ERROR read-only\n+    *y = 42; //~ ERROR read-only\n     assert_eq!(*x, 42);\n }"}, {"sha": "7aae8a29211ed8754118b12df8300b204c969015", "filename": "tests/fail/never_say_never.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fnever_say_never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fnever_say_never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fnever_say_never.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -7,9 +7,11 @@\n fn main() {\n     let y = &5;\n     let x: ! = unsafe {\n-        *(y as *const _ as *const !)  //~ ERROR entering unreachable code\n+        *(y as *const _ as *const !) //~ ERROR entering unreachable code\n     };\n     f(x)\n }\n \n-fn f(x: !) -> ! { x }\n+fn f(x: !) -> ! {\n+    x\n+}"}, {"sha": "f5d0f914dac7b1c15f61e247ae7298fd04348f57", "filename": "tests/fail/never_transmute_void.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fnever_transmute_void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fnever_transmute_void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fnever_transmute_void.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -14,8 +14,6 @@ mod m {\n }\n \n fn main() {\n-    let v = unsafe {\n-        std::mem::transmute::<(), m::Void>(())\n-    };\n+    let v = unsafe { std::mem::transmute::<(), m::Void>(()) };\n     m::f(v); //~ inside `main`\n }"}, {"sha": "049330ef363c60d3f8db401a301629288a56904a", "filename": "tests/fail/rc_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Frc_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Frc_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Frc_as_ptr.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,8 @@\n // This should fail even without validation\n // compile-flags: -Zmiri-disable-validation\n \n-use std::rc::{Rc, Weak};\n use std::ptr;\n+use std::rc::{Rc, Weak};\n \n /// Taken from the `Weak::as_ptr` doctest.\n fn main() {"}, {"sha": "2a3b096b2f5a1f18ece3c05ab80de99b0b7c916a", "filename": "tests/fail/reading_half_a_pointer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Freading_half_a_pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Freading_half_a_pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Freading_half_a_pointer.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -13,7 +13,7 @@ struct Wrapper {\n     data: Data,\n }\n \n-static G : i32 = 0;\n+static G: i32 = 0;\n \n fn main() {\n     let mut w = Wrapper { align: 0, data: Data { pad: 0, ptr: &G } };"}, {"sha": "37557de0a5e4ba93af8d091c2393703a8bebcb84", "filename": "tests/fail/shim_arg_size.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fshim_arg_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fshim_arg_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshim_arg_size.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -4,10 +4,10 @@ fn main() {\n     extern \"C\" {\n         // Use the wrong type(ie. not the pointer width) for the `size`\n         // argument.\n-        #[cfg(target_pointer_width=\"64\")]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn malloc(size: u32) -> *mut std::ffi::c_void;\n \n-        #[cfg(target_pointer_width=\"32\")]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn malloc(size: u16) -> *mut std::ffi::c_void;\n     }\n "}, {"sha": "85c24246dbeb54f20a77ebff054f5bba5a0f3b7b", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -76,7 +76,9 @@ fn test_cpp20_rwc_syncs() {\n     // Our ui_test does not yet support overriding failure status codes.\n     if (b, c) == (0, 0) {\n         // This *should* be unreachable, but Miri will reach it.\n-        unsafe { std::hint::unreachable_unchecked(); }\n+        unsafe {\n+            std::hint::unreachable_unchecked();\n+        }\n     }\n }\n "}, {"sha": "5f0e86dc653ec67981a3f6005d2e9f0ca9b5d297", "filename": "tests/fail/should-pass/cpp20_rwc_syncs.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fshould-pass%2Fcpp20_rwc_syncs.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -11,8 +11,8 @@ LL |     unsafe { intrinsics::unreachable() }\n note: inside `test_cpp20_rwc_syncs` at $DIR/cpp20_rwc_syncs.rs:LL:CC\n   --> $DIR/cpp20_rwc_syncs.rs:LL:CC\n    |\n-LL |         unsafe { std::hint::unreachable_unchecked(); }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |             std::hint::unreachable_unchecked();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n note: inside `main` at $DIR/cpp20_rwc_syncs.rs:LL:CC\n   --> $DIR/cpp20_rwc_syncs.rs:LL:CC\n    |"}, {"sha": "15d8e45f8b8b0e7480f16963bcb8aeb559b34c88", "filename": "tests/fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,6 +1,8 @@\n // This makes a ref that was passed to us via &mut alias with things it should not alias with\n fn retarget(x: &mut &u32, target: &mut u32) {\n-    unsafe { *x = &mut *(target as *mut _); }\n+    unsafe {\n+        *x = &mut *(target as *mut _);\n+    }\n }\n \n fn main() {"}, {"sha": "eb02136478f2bd8648edaa9b80cbaa37f89a280d", "filename": "tests/fail/stacked_borrows/alias_through_mutation.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -12,8 +12,8 @@ LL |     let _val = *target_alias;\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/alias_through_mutation.rs:LL:CC\n    |\n-LL |     unsafe { *x = &mut *(target as *mut _); }\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         *x = &mut *(target as *mut _);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/alias_through_mutation.rs:LL:CC\n    |"}, {"sha": "ebee134a8acbabbf7383d8fe309976ce286cded0", "filename": "tests/fail/stacked_borrows/aliasing_mut1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,8 +8,7 @@ fn main() {\n     // We need to apply some tricky to be able to call `safe` with two mutable references\n     // with the same tag: We transmute both the fn ptr (to take raw ptrs) and the argument\n     // (to be raw, but still have the unique tag).\n-    let safe_raw: fn(x: *mut i32, y: *mut i32) = unsafe {\n-        mem::transmute::<fn(&mut i32, &mut i32), _>(safe)\n-    };\n+    let safe_raw: fn(x: *mut i32, y: *mut i32) =\n+        unsafe { mem::transmute::<fn(&mut i32, &mut i32), _>(safe) };\n     safe_raw(xraw, xraw);\n }"}, {"sha": "971dbb63a9d661d73f41ed8f1253081615e59d5f", "filename": "tests/fail/stacked_borrows/aliasing_mut2.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,8 +8,7 @@ fn main() {\n     let xraw: *mut i32 = unsafe { mem::transmute_copy(&xref) };\n     let xshr = &*xref;\n     // transmute fn ptr around so that we can avoid retagging\n-    let safe_raw: fn(x: *const i32, y: *mut i32) = unsafe {\n-        mem::transmute::<fn(&i32, &mut i32), _>(safe)\n-    };\n+    let safe_raw: fn(x: *const i32, y: *mut i32) =\n+        unsafe { mem::transmute::<fn(&i32, &mut i32), _>(safe) };\n     safe_raw(xshr, xraw);\n }"}, {"sha": "91904b0b1d14b9c4dc9e24c83604690a41a7f2c4", "filename": "tests/fail/stacked_borrows/aliasing_mut3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,8 +8,7 @@ fn main() {\n     let xraw: *mut i32 = unsafe { mem::transmute_copy(&xref) };\n     let xshr = &*xref;\n     // transmute fn ptr around so that we can avoid retagging\n-    let safe_raw: fn(x: *mut i32, y: *const i32) = unsafe {\n-        mem::transmute::<fn(&mut i32, &i32), _>(safe)\n-    };\n+    let safe_raw: fn(x: *mut i32, y: *const i32) =\n+        unsafe { mem::transmute::<fn(&mut i32, &i32), _>(safe) };\n     safe_raw(xraw, xshr);\n }"}, {"sha": "79caed5dd6b4d3a2a463707f4cf27a556fb91287", "filename": "tests/fail/stacked_borrows/aliasing_mut4.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,5 +1,5 @@\n-use std::mem;\n use std::cell::Cell;\n+use std::mem;\n \n // Make sure &mut UnsafeCell also is exclusive\n pub fn safe(_x: &i32, _y: &mut Cell<i32>) {} //~ ERROR protect\n@@ -10,8 +10,7 @@ fn main() {\n     let xraw: *mut i32 = unsafe { mem::transmute_copy(&xref) };\n     let xshr = &*xref;\n     // transmute fn ptr around so that we can avoid retagging\n-    let safe_raw: fn(x: *const i32, y: *mut Cell<i32>) = unsafe {\n-        mem::transmute::<fn(&i32, &mut Cell<i32>), _>(safe)\n-    };\n+    let safe_raw: fn(x: *const i32, y: *mut Cell<i32>) =\n+        unsafe { mem::transmute::<fn(&i32, &mut Cell<i32>), _>(safe) };\n     safe_raw(xshr, xraw as *mut _);\n }"}, {"sha": "3ca480ae7ab83ec345a39d91e5cbcd34b4a3adac", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,28 +1,32 @@\n fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n-  unknown_code_1(&*our);\n+    unknown_code_1(&*our);\n \n-  // This \"re-asserts\" uniqueness of the reference: After writing, we know\n-  // our tag is at the top of the stack.\n-  *our = 5;\n+    // This \"re-asserts\" uniqueness of the reference: After writing, we know\n+    // our tag is at the top of the stack.\n+    *our = 5;\n \n-  unknown_code_2();\n+    unknown_code_2();\n \n-  // We know this will return 5\n-  *our //~ ERROR borrow stack\n+    // We know this will return 5\n+    *our //~ ERROR borrow stack\n }\n \n // Now comes the evil context\n use std::ptr;\n \n static mut LEAK: *mut i32 = ptr::null_mut();\n \n-fn unknown_code_1(x: &i32) { unsafe {\n-    LEAK = x as *const _ as *mut _;\n-} }\n+fn unknown_code_1(x: &i32) {\n+    unsafe {\n+        LEAK = x as *const _ as *mut _;\n+    }\n+}\n \n-fn unknown_code_2() { unsafe {\n-    *LEAK = 7;\n-} }\n+fn unknown_code_2() {\n+    unsafe {\n+        *LEAK = 7;\n+    }\n+}\n \n fn main() {\n     demo_mut_advanced_unique(Box::new(0));"}, {"sha": "3c3e6bbf1bc724deedbaf6281f2a54ea73f36de3", "filename": "tests/fail/stacked_borrows/box_exclusive_violation1.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,30 +1,30 @@\n error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL |   *our\n-   |   ^^^^\n-   |   |\n-   |   attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |   this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |     *our\n+   |     ^^^^\n+   |     |\n+   |     attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |     this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n LL | / fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n-LL | |   unknown_code_1(&*our);\n+LL | |     unknown_code_1(&*our);\n LL | |\n-LL | |   // This \"re-asserts\" uniqueness of the reference: After writing, we know\n+LL | |     // This \"re-asserts\" uniqueness of the reference: After writing, we know\n ...  |\n-LL | |   *our\n+LL | |     *our\n LL | | }\n    | |_^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/box_exclusive_violation1.rs:LL:CC\n    |\n-LL |     *LEAK = 7;\n-   |     ^^^^^^^^^\n+LL |         *LEAK = 7;\n+   |         ^^^^^^^^^\n    = note: inside `demo_mut_advanced_unique` at $DIR/box_exclusive_violation1.rs:LL:CC\n note: inside `main` at $DIR/box_exclusive_violation1.rs:LL:CC\n   --> $DIR/box_exclusive_violation1.rs:LL:CC"}, {"sha": "6744e4ef44814446e4e643e0ba5c3086b119cad1", "filename": "tests/fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -2,14 +2,12 @@ mod safe {\n     use std::slice::from_raw_parts_mut;\n \n     pub fn as_mut_slice<T>(self_: &Vec<T>) -> &mut [T] {\n-        unsafe {\n-            from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len())\n-        }\n+        unsafe { from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len()) }\n     }\n }\n \n fn main() {\n-    let v = vec![0,1,2];\n+    let v = vec![0, 1, 2];\n     let v1 = safe::as_mut_slice(&v);\n     let _v2 = safe::as_mut_slice(&v);\n     v1[1] = 5;"}, {"sha": "14cede13b7a18ef263d72fc4b66ee74ad28262f0", "filename": "tests/fail/stacked_borrows/buggy_as_mut_slice.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -17,8 +17,8 @@ LL |     let v1 = safe::as_mut_slice(&v);\n help: <TAG> was later invalidated at offsets [0x0..0xc]\n   --> $DIR/buggy_as_mut_slice.rs:LL:CC\n    |\n-LL |             from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len())\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         unsafe { from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len()) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: inside `main` at $DIR/buggy_as_mut_slice.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "a2ef0fcf178db4f33a537eb0fab3a8f612218b21", "filename": "tests/fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,14 +8,16 @@ mod safe {\n         unsafe {\n             assert!(mid <= len);\n \n-            (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+            (\n+                from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n+                from_raw_parts_mut(ptr.offset(mid as isize), len - mid),\n+            )\n         }\n     }\n }\n \n fn main() {\n-    let mut array = [1,2,3,4];\n+    let mut array = [1, 2, 3, 4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n     //~^ ERROR borrow stack\n     a[1] = 5;"}, {"sha": "47ab7d6a062a78e8aaf2ca27dae5408e5f24c458", "filename": "tests/fail/stacked_borrows/buggy_split_at_mut.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -12,13 +12,13 @@ LL |     let (a, b) = safe::split_at_mut(&mut array, 0);\n help: <TAG> was created by a retag at offsets [0x0..0x10]\n   --> $DIR/buggy_split_at_mut.rs:LL:CC\n    |\n-LL |             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |                 from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x10]\n   --> $DIR/buggy_split_at_mut.rs:LL:CC\n    |\n-LL |             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid),\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: inside `main` at $DIR/buggy_split_at_mut.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "af89566f6507465873250e0961dfc31e19a69fb4", "filename": "tests/fail/stacked_borrows/illegal_read6.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,8 +1,10 @@\n // Creating a shared reference does not leak the data to raw pointers.\n-fn main() { unsafe {\n-    let x = &mut 0;\n-    let raw = x as *mut _;\n-    let x = &mut *x; // kill `raw`\n-    let _y = &*x; // this should not activate `raw` again\n-    let _val = *raw; //~ ERROR borrow stack\n-} }\n+fn main() {\n+    unsafe {\n+        let x = &mut 0;\n+        let raw = x as *mut _;\n+        let x = &mut *x; // kill `raw`\n+        let _y = &*x; // this should not activate `raw` again\n+        let _val = *raw; //~ ERROR borrow stack\n+    }\n+}"}, {"sha": "9782f1aa3a58d77f0fcf684430332602c894f9d4", "filename": "tests/fail/stacked_borrows/illegal_read6.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,24 +1,24 @@\n error: Undefined Behavior: attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n-LL |     let _val = *raw;\n-   |                ^^^^\n-   |                |\n-   |                attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |         let _val = *raw;\n+   |                    ^^^^\n+   |                    |\n+   |                    attempting a read access using <untagged> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                    this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: tag was most recently created at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n-LL |     let raw = x as *mut _;\n-   |               ^\n+LL |         let raw = x as *mut _;\n+   |                   ^\n help: tag was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_read6.rs:LL:CC\n    |\n-LL |     let x = &mut *x; // kill `raw`\n-   |             ^^^^^^^\n+LL |         let x = &mut *x; // kill `raw`\n+   |                 ^^^^^^^\n    = note: inside `main` at $DIR/illegal_read6.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "e960bd5388c03da1d8126eba5470d1295874c327", "filename": "tests/fail/stacked_borrows/illegal_read7.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -4,17 +4,19 @@\n use std::cell::Cell;\n use std::ptr;\n \n-fn main() { unsafe {\n-    let x = &mut Cell::new(0);\n-    let raw = x as *mut Cell<i32>;\n-    let x = &mut *raw;\n-    let _shr = &*x;\n-    // The state here is interesting because the top of the stack is [Unique, SharedReadWrite],\n-    // just like if we had done `x as *mut _`.\n-    // If we said that reading from a lower item is fine if the top item is `SharedReadWrite`\n-    // (one way to maybe preserve a stack discipline), then we could now read from `raw`\n-    // without invalidating `x`.  That would be bad!  It would mean that creating `shr`\n-    // leaked `x` to `raw`.\n-    let _val = ptr::read(raw);\n-    let _val = *x.get_mut(); //~ ERROR borrow stack\n-} }\n+fn main() {\n+    unsafe {\n+        let x = &mut Cell::new(0);\n+        let raw = x as *mut Cell<i32>;\n+        let x = &mut *raw;\n+        let _shr = &*x;\n+        // The state here is interesting because the top of the stack is [Unique, SharedReadWrite],\n+        // just like if we had done `x as *mut _`.\n+        // If we said that reading from a lower item is fine if the top item is `SharedReadWrite`\n+        // (one way to maybe preserve a stack discipline), then we could now read from `raw`\n+        // without invalidating `x`.  That would be bad!  It would mean that creating `shr`\n+        // leaked `x` to `raw`.\n+        let _val = ptr::read(raw);\n+        let _val = *x.get_mut(); //~ ERROR borrow stack\n+    }\n+}"}, {"sha": "3d70945fa6c635a4bf7998ec09c7617b67677897", "filename": "tests/fail/stacked_borrows/illegal_read7.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,24 +1,24 @@\n error: Undefined Behavior: trying to reborrow <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_read7.rs:LL:CC\n    |\n-LL |     let _val = *x.get_mut();\n-   |                 ^^^^^^^^^^^\n-   |                 |\n-   |                 trying to reborrow <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                 this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+LL |         let _val = *x.get_mut();\n+   |                     ^^^^^^^^^^^\n+   |                     |\n+   |                     trying to reborrow <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                     this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read7.rs:LL:CC\n    |\n-LL |     let x = &mut *raw;\n-   |             ^^^^^^^^^\n+LL |         let x = &mut *raw;\n+   |                 ^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_read7.rs:LL:CC\n    |\n-LL |     let _val = ptr::read(raw);\n-   |                ^^^^^^^^^^^^^^\n+LL |         let _val = ptr::read(raw);\n+   |                    ^^^^^^^^^^^^^^\n    = note: inside `main` at $DIR/illegal_read7.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "9fef673fe6c13b2513fe98e01d48191c51d3186b", "filename": "tests/fail/stacked_borrows/illegal_read8.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,13 +1,15 @@\n // Make sure that creating a raw ptr next to a shared ref works\n // but the shared ref still gets invalidated when the raw ptr is used for writing.\n \n-fn main() { unsafe {\n-    use std::mem;\n-    let x = &mut 0;\n-    let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n-    let y2 = x as *mut _;\n-    let _val = *y2;\n-    let _val = *y1;\n-    *y2 += 1;\n-    let _fail = *y1; //~ ERROR borrow stack\n-} }\n+fn main() {\n+    unsafe {\n+        use std::mem;\n+        let x = &mut 0;\n+        let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n+        let y2 = x as *mut _;\n+        let _val = *y2;\n+        let _val = *y1;\n+        *y2 += 1;\n+        let _fail = *y1; //~ ERROR borrow stack\n+    }\n+}"}, {"sha": "7c0cb0066b2703ae9154a255dcce998d662dcfa3", "filename": "tests/fail/stacked_borrows/illegal_read8.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,24 +1,24 @@\n error: Undefined Behavior: attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/illegal_read8.rs:LL:CC\n    |\n-LL |     let _fail = *y1;\n-   |                 ^^^\n-   |                 |\n-   |                 attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                 this error occurs as part of an access at ALLOC[0x0..0x4]\n+LL |         let _fail = *y1;\n+   |                     ^^^\n+   |                     |\n+   |                     attempting a read access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                     this error occurs as part of an access at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/illegal_read8.rs:LL:CC\n    |\n-LL |     let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n-   |                    ^^^^^^^^^^^^^^^^^^^\n+LL |         let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n+   |                        ^^^^^^^^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/illegal_read8.rs:LL:CC\n    |\n-LL |     *y2 += 1;\n-   |     ^^^^^^^^\n+LL |         *y2 += 1;\n+   |         ^^^^^^^^\n    = note: inside `main` at $DIR/illegal_read8.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "1ef78edbb7ce2367e00b47db6fcadbccf12f7bf5", "filename": "tests/fail/stacked_borrows/interior_mut1.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,15 +1,17 @@\n use std::cell::UnsafeCell;\n \n-fn main() { unsafe {\n-    let c = &UnsafeCell::new(UnsafeCell::new(0));\n-    let inner_uniq = &mut *c.get();\n-    // stack: [c: SharedReadWrite, inner_uniq: Unique]\n+fn main() {\n+    unsafe {\n+        let c = &UnsafeCell::new(UnsafeCell::new(0));\n+        let inner_uniq = &mut *c.get();\n+        // stack: [c: SharedReadWrite, inner_uniq: Unique]\n \n-    let inner_shr = &*inner_uniq; // adds a SharedReadWrite\n-    // stack: [c: SharedReadWrite, inner_uniq: Unique, inner_shr: SharedReadWrite]\n+        let inner_shr = &*inner_uniq; // adds a SharedReadWrite\n+        // stack: [c: SharedReadWrite, inner_uniq: Unique, inner_shr: SharedReadWrite]\n \n-    *c.get() = UnsafeCell::new(1); // invalidates inner_shr\n-    // stack: [c: SharedReadWrite]\n+        *c.get() = UnsafeCell::new(1); // invalidates inner_shr\n+        // stack: [c: SharedReadWrite]\n \n-    let _val = *inner_shr.get(); //~ ERROR borrow stack\n-} }\n+        let _val = *inner_shr.get(); //~ ERROR borrow stack\n+    }\n+}"}, {"sha": "2490fd3e1e9aab592eeb0954c0d8f6cf5c2e4e96", "filename": "tests/fail/stacked_borrows/interior_mut1.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,24 +1,24 @@\n error: Undefined Behavior: trying to reborrow <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n   --> $DIR/interior_mut1.rs:LL:CC\n    |\n-LL |     let _val = *inner_shr.get();\n-   |                 ^^^^^^^^^^^^^^^\n-   |                 |\n-   |                 trying to reborrow <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |                 this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n+LL |         let _val = *inner_shr.get();\n+   |                     ^^^^^^^^^^^^^^^\n+   |                     |\n+   |                     trying to reborrow <TAG> for SharedReadWrite permission at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n+   |                     this error occurs as part of a reborrow at ALLOC[0x0..0x4]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n help: <TAG> was created by a retag at offsets [0x0..0x4]\n   --> $DIR/interior_mut1.rs:LL:CC\n    |\n-LL |     let inner_shr = &*inner_uniq; // adds a SharedReadWrite\n-   |                     ^^^^^^^^^^^^\n+LL |         let inner_shr = &*inner_uniq; // adds a SharedReadWrite\n+   |                         ^^^^^^^^^^^^\n help: <TAG> was later invalidated at offsets [0x0..0x4]\n   --> $DIR/interior_mut1.rs:LL:CC\n    |\n-LL |     *c.get() = UnsafeCell::new(1); // invalidates inner_shr\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |         *c.get() = UnsafeCell::new(1); // invalidates inner_shr\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: inside `main` at $DIR/interior_mut1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "e15d7656de834eebdf279451e5ab0dc2eaed1777", "filename": "tests/panic/panic/panic1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpanic%2Fpanic%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpanic%2Fpanic%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpanic%2Fpanic%2Fpanic1.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,7 +1,6 @@\n // rustc-env: RUST_BACKTRACE=1\n // compile-flags: -Zmiri-disable-isolation\n \n-\n fn main() {\n     std::panic!(\"panicking from libstd\");\n }"}, {"sha": "0205433ad9fb95d624a8040e08e6dfd5bee77c2a", "filename": "tests/panic/transmute_fat2.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpanic%2Ftransmute_fat2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpanic%2Ftransmute_fat2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpanic%2Ftransmute_fat2.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,16 +1,10 @@\n fn main() {\n-    #[cfg(all(target_endian=\"little\", target_pointer_width=\"64\"))]\n-    let bad = unsafe {\n-        std::mem::transmute::<u128, &[u8]>(42)\n-    };\n-    #[cfg(all(target_endian=\"big\", target_pointer_width=\"64\"))]\n-    let bad = unsafe {\n-        std::mem::transmute::<u128, &[u8]>(42 << 64)\n-    };\n-    #[cfg(all(target_endian=\"little\", target_pointer_width=\"32\"))]\n-    let bad = unsafe {\n-        std::mem::transmute::<u64, &[u8]>(42)\n-    };\n+    #[cfg(all(target_endian = \"little\", target_pointer_width = \"64\"))]\n+    let bad = unsafe { std::mem::transmute::<u128, &[u8]>(42) };\n+    #[cfg(all(target_endian = \"big\", target_pointer_width = \"64\"))]\n+    let bad = unsafe { std::mem::transmute::<u128, &[u8]>(42 << 64) };\n+    #[cfg(all(target_endian = \"little\", target_pointer_width = \"32\"))]\n+    let bad = unsafe { std::mem::transmute::<u64, &[u8]>(42) };\n     // This created a slice with length 0, so the following will fail the bounds check.\n     bad[0];\n }"}, {"sha": "ecb6f48d30b07f6b4f1a224ecc85e7a66592124a", "filename": "tests/pass/stacked-borrows/refcell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Frefcell.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,4 +1,4 @@\n-use std::cell::{RefCell, Ref, RefMut};\n+use std::cell::{Ref, RefCell, RefMut};\n \n fn main() {\n     basic();\n@@ -70,8 +70,8 @@ fn ref_mut_protector() {\n \n /// Make sure we do not have bad enum layout optimizations.\n fn rust_issue_68303() {\n-    let optional=Some(RefCell::new(false));\n-    let mut handle=optional.as_ref().unwrap().borrow_mut();\n+    let optional = Some(RefCell::new(false));\n+    let mut handle = optional.as_ref().unwrap().borrow_mut();\n     assert!(optional.is_some());\n-    *handle=true;\n+    *handle = true;\n }"}, {"sha": "131783ef4fb58eeb4105e5ceda211200a27d3c46", "filename": "tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -50,7 +50,9 @@ fn mut_raw_then_mut_shr() {\n     let xraw = &mut *xref as *mut _;\n     let xshr = &*xref;\n     assert_eq!(*xshr, 2);\n-    unsafe { *xraw = 4; }\n+    unsafe {\n+        *xraw = 4;\n+    }\n     assert_eq!(x, 4);\n }\n \n@@ -60,7 +62,9 @@ fn mut_shr_then_mut_raw() {\n     let xref = &mut 2;\n     let _xshr = &*xref;\n     let xraw = xref as *mut _;\n-    unsafe { *xraw = 3; }\n+    unsafe {\n+        *xraw = 3;\n+    }\n     assert_eq!(*xref, 3);\n }\n \n@@ -75,7 +79,9 @@ fn mut_raw_mut() {\n         let xraw = xref1 as *mut _;\n         let _xref2 = unsafe { &mut *xraw };\n         let _val = *xref1;\n-        unsafe { *xraw = 4; }\n+        unsafe {\n+            *xraw = 4;\n+        }\n         // we can now use both xraw and xref1, for reading\n         assert_eq!(*xref1, 4);\n         assert_eq!(unsafe { *xraw }, 4);\n@@ -112,47 +118,48 @@ fn direct_mut_to_const_raw() {\n }\n \n // Make sure that we can create two raw pointers from a mutable reference and use them both.\n-fn two_raw() { unsafe {\n-    let x = &mut 0;\n-    let y1 = x as *mut _;\n-    let y2 = x as *mut _;\n-    *y1 += 2;\n-    *y2 += 1;\n-} }\n+fn two_raw() {\n+    unsafe {\n+        let x = &mut 0;\n+        let y1 = x as *mut _;\n+        let y2 = x as *mut _;\n+        *y1 += 2;\n+        *y2 += 1;\n+    }\n+}\n \n // Make sure that creating a *mut does not invalidate existing shared references.\n-fn shr_and_raw() { unsafe {\n-    use std::mem;\n-    let x = &mut 0;\n-    let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n-    let y2 = x as *mut _;\n-    let _val = *y1;\n-    *y2 += 1;\n-} }\n+fn shr_and_raw() {\n+    unsafe {\n+        use std::mem;\n+        let x = &mut 0;\n+        let y1: &i32 = mem::transmute(&*x); // launder lifetimes\n+        let y2 = x as *mut _;\n+        let _val = *y1;\n+        *y2 += 1;\n+    }\n+}\n \n fn disjoint_mutable_subborrows() {\n     struct Foo {\n         a: String,\n         b: Vec<u32>,\n     }\n \n-    unsafe fn borrow_field_a<'a>(this:*mut Foo) -> &'a mut String {\n+    unsafe fn borrow_field_a<'a>(this: *mut Foo) -> &'a mut String {\n         &mut (*this).a\n     }\n \n-    unsafe fn borrow_field_b<'a>(this:*mut Foo) -> &'a mut Vec<u32> {\n+    unsafe fn borrow_field_b<'a>(this: *mut Foo) -> &'a mut Vec<u32> {\n         &mut (*this).b\n     }\n \n-    let mut foo = Foo {\n-        a: \"hello\".into(),\n-        b: vec![0,1,2],\n-    };\n+    let mut foo = Foo { a: \"hello\".into(), b: vec![0, 1, 2] };\n \n     let ptr = &mut foo as *mut Foo;\n \n-    let a = unsafe{ borrow_field_a(ptr) };\n-    let b = unsafe{ borrow_field_b(ptr) };\n+    let a = unsafe { borrow_field_a(ptr) };\n+    let b = unsafe { borrow_field_b(ptr) };\n     b.push(4);\n     a.push_str(\" world\");\n     eprintln!(\"{:?} {:?}\", a, b);\n@@ -181,7 +188,9 @@ fn raw_ref_to_part() {\n fn array_casts() {\n     let mut x: [usize; 2] = [0, 0];\n     let p = &mut x as *mut usize;\n-    unsafe { *p.add(1) = 1; }\n+    unsafe {\n+        *p.add(1) = 1;\n+    }\n \n     let x: [usize; 2] = [0, 1];\n     let p = &x as *const usize;\n@@ -192,7 +201,7 @@ fn array_casts() {\n fn mut_below_shr() {\n     let x = 0;\n     let y = &x;\n-    let p = unsafe { core::mem::transmute::<&&i32,&&mut i32>(&y) };\n+    let p = unsafe { core::mem::transmute::<&&i32, &&mut i32>(&y) };\n     let r = &**p;\n     let _val = *r;\n }"}, {"sha": "84a524b1ed1635c6c2e8eb21c8b8dfccdc65dbf0", "filename": "tests/pass/static_memory_modification.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstatic_memory_modification.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,4 +1,4 @@\n-use std::sync::atomic::{Ordering, AtomicUsize};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n \n static mut X: usize = 5;\n static Y: AtomicUsize = AtomicUsize::new(5);"}, {"sha": "218b02525bd55dbf2543e40fc2b86173235307f2", "filename": "tests/pass/static_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstatic_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstatic_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstatic_mut.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,5 +1,5 @@\n static mut FOO: i32 = 42;\n-static BAR: Foo = Foo(unsafe { &FOO as *const _} );\n+static BAR: Foo = Foo(unsafe { &FOO as *const _ });\n \n #[allow(dead_code)]\n struct Foo(*const i32);"}, {"sha": "ccefc69bd180ebc14068a33af7c04799f611c0ba", "filename": "tests/pass/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fstrings.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -22,7 +22,7 @@ fn fat_pointer_on_32_bit() {\n \n fn str_indexing() {\n     let mut x = \"Hello\".to_string();\n-    let _v = &mut x[..3];  // Test IndexMut on String.\n+    let _v = &mut x[..3]; // Test IndexMut on String.\n }\n \n fn unique_aliasing() {"}, {"sha": "72211a8d3f3af3baf1e8b35ff8139dc80f751c18", "filename": "tests/pass/tag-align-dyn-u64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftag-align-dyn-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftag-align-dyn-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ftag-align-dyn-u64.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -11,17 +11,17 @@\n use std::mem;\n \n enum Tag<A> {\n-    Tag2(A)\n+    Tag2(A),\n }\n \n #[allow(dead_code)]\n struct Rec {\n     c8: u8,\n-    t: Tag<u64>\n+    t: Tag<u64>,\n }\n \n fn mk_rec() -> Rec {\n-    return Rec { c8:0, t:Tag::Tag2(0) };\n+    return Rec { c8: 0, t: Tag::Tag2(0) };\n }\n \n fn is_u64_aligned(u: &Tag<u64>) -> bool {"}, {"sha": "38e846309d72885100f790910869b2620682c961", "filename": "tests/pass/time.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ftime.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,6 +1,6 @@\n // compile-flags: -Zmiri-disable-isolation\n \n-use std::time::{SystemTime, Instant, Duration};\n+use std::time::{Duration, Instant, SystemTime};\n \n fn duration_sanity(diff: Duration) {\n     // On my laptop, I observed times around 15-40ms. Add 10x lee-way both ways.\n@@ -25,7 +25,9 @@ fn main() {\n     let year = 1970 + years_since_epoch;\n     assert!(2020 <= year && year < 2100);\n     // Do some work to make time pass.\n-    for _ in 0..10 { drop(vec![42]); }\n+    for _ in 0..10 {\n+        drop(vec![42]);\n+    }\n     let now2 = SystemTime::now();\n     assert!(now2 > now1);\n     // Sanity-check the difference we got.\n@@ -37,7 +39,9 @@ fn main() {\n     // Check `Instant`.\n     let now1 = Instant::now();\n     // Do some work to make time pass.\n-    for _ in 0..10 { drop(vec![42]); }\n+    for _ in 0..10 {\n+        drop(vec![42]);\n+    }\n     let now2 = Instant::now();\n     assert!(now2 > now1);\n     // Sanity-check the difference we got."}, {"sha": "dd1e2f809adfe4ce9364334acbb7ea02c37df3b8", "filename": "tests/pass/track-caller-attribute.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftrack-caller-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftrack-caller-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ftrack-caller-attribute.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -16,7 +16,9 @@ fn nested_tracked() -> &'static Location<'static> {\n }\n \n macro_rules! caller_location_from_macro {\n-    () => (core::panic::Location::caller());\n+    () => {\n+        core::panic::Location::caller()\n+    };\n }\n \n fn test_fn_ptr() {\n@@ -62,7 +64,6 @@ fn test_trait_obj() {\n     assert_eq!(location.file(), file!());\n     assert_eq!(location.line(), expected_line);\n     assert_eq!(location.column(), 28);\n-\n }\n \n fn main() {"}, {"sha": "1d2ec92a8038942c6ff055b4b4ad57ab9b51e5b9", "filename": "tests/pass/transmute_fat.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Ftransmute_fat.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -3,9 +3,7 @@\n \n fn main() {\n     // If we are careful, we can exploit data layout...\n-    let raw = unsafe {\n-        std::mem::transmute::<&[u8], [*const u8; 2]>(&[42])\n-    };\n+    let raw = unsafe { std::mem::transmute::<&[u8], [*const u8; 2]>(&[42]) };\n     let ptr: *const u8 = unsafe { std::mem::transmute_copy(&raw) };\n     assert_eq!(unsafe { *ptr }, 42);\n }"}, {"sha": "0ef7a514cb65350f18bfedfd4b72aa1885d87886", "filename": "tests/pass/u128.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fu128.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -8,9 +8,10 @@ fn main() {\n     let y: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFE;\n     assert_eq!(!1, y);\n     assert_eq!(x, y | 1);\n-    assert_eq!(0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFE,\n-               y &\n-               0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFF);\n+    assert_eq!(\n+        0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFE,\n+        y & 0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFF,\n+    );\n     let z: u128 = 0xABCD_EF;\n     assert_eq!(z * z, 0x734C_C2F2_A521);\n     assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n@@ -19,8 +20,10 @@ fn main() {\n     assert_eq!(k + k, 0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n     assert_eq!(0, k - k);\n     assert_eq!(0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k - z);\n-    assert_eq!(0x1000_0000_0000_0000_0000_0000_0000_000,\n-               k - 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(\n+        0x1000_0000_0000_0000_0000_0000_0000_000,\n+        k - 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210,\n+    );\n     assert_eq!(0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n     assert_eq!(0, k % 42);\n     assert_eq!(15, z % 42);\n@@ -38,18 +41,19 @@ fn main() {\n     assert_eq!((z as f32) as u128, z);\n     assert_eq!((z as f64 * 16.0) as u128, z * 16);\n     assert_eq!((z as f32 * 16.0) as u128, z * 16);\n-    let l :u128 = 432 << 100;\n+    let l: u128 = 432 << 100;\n     assert_eq!((l as f32) as u128, l);\n     assert_eq!((l as f64) as u128, l);\n     // formatting\n     let j: u128 = 1 << 67;\n     assert_eq!(\"147573952589676412928\", format!(\"{}\", j));\n     assert_eq!(\"80000000000000000\", format!(\"{:x}\", j));\n     assert_eq!(\"20000000000000000000000\", format!(\"{:o}\", j));\n-    assert_eq!(\"10000000000000000000000000000000000000000000000000000000000000000000\",\n-               format!(\"{:b}\", j));\n-    assert_eq!(\"340282366920938463463374607431768211455\",\n-        format!(\"{}\", u128::MAX));\n+    assert_eq!(\n+        \"10000000000000000000000000000000000000000000000000000000000000000000\",\n+        format!(\"{:b}\", j),\n+    );\n+    assert_eq!(\"340282366920938463463374607431768211455\", format!(\"{}\", u128::MAX));\n     assert_eq!(\"147573952589676412928\", format!(\"{:?}\", j));\n     // common traits\n     assert_eq!(x, b(x.clone()));"}, {"sha": "f98a2131028515cf02c870a9ebd085fa3e2f4c5c", "filename": "tests/pass/union.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Funion.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -45,7 +45,10 @@ fn b() {\n \n fn c() {\n     #[repr(u32)]\n-    enum Tag { I, F }\n+    enum Tag {\n+        I,\n+        F,\n+    }\n \n     #[repr(C)]\n     union U {\n@@ -68,10 +71,10 @@ fn c() {\n             }\n         }\n     }\n-    assert!(is_zero(Value { tag: Tag::I, u: U { i: 0 }}));\n-    assert!(is_zero(Value { tag: Tag::F, u: U { f: 0.0 }}));\n-    assert!(!is_zero(Value { tag: Tag::I, u: U { i: 1 }}));\n-    assert!(!is_zero(Value { tag: Tag::F, u: U { f: 42.0 }}));\n+    assert!(is_zero(Value { tag: Tag::I, u: U { i: 0 } }));\n+    assert!(is_zero(Value { tag: Tag::F, u: U { f: 0.0 } }));\n+    assert!(!is_zero(Value { tag: Tag::I, u: U { i: 1 } }));\n+    assert!(!is_zero(Value { tag: Tag::F, u: U { f: 42.0 } }));\n }\n \n fn d() {\n@@ -82,8 +85,8 @@ fn d() {\n     let u = MyUnion { f1: 10 };\n     unsafe {\n         match u {\n-            MyUnion { f1: 10 } => { }\n-            MyUnion { f2: _f2 } => { panic!(\"foo\"); }\n+            MyUnion { f1: 10 } => {}\n+            MyUnion { f2: _f2 } => panic!(\"foo\"),\n         }\n     }\n }"}, {"sha": "f23f68ccbad00dc4b4bb373d5638eeec6c69b770", "filename": "tests/pass/unops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Funops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Funops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Funops.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     assert_eq!(!true, false);\n     assert_eq!(!0xFFu16, 0xFF00);\n-    assert_eq!(-{1i16}, -1i16);\n+    assert_eq!(-{ 1i16 }, -1i16);\n }"}, {"sha": "bbab1125a0afdc38dae846dda160081d993c4540", "filename": "tests/pass/unsized-tuple-impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Funsized-tuple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Funsized-tuple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Funsized-tuple-impls.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -2,8 +2,8 @@\n use std::mem;\n \n fn main() {\n-    let x : &(i32, i32, [i32]) = &(0, 1, [2, 3]);\n-    let y : &(i32, i32, [i32]) = &(0, 1, [2, 3, 4]);\n+    let x: &(i32, i32, [i32]) = &(0, 1, [2, 3]);\n+    let y: &(i32, i32, [i32]) = &(0, 1, [2, 3, 4]);\n     let mut a = [y, x];\n     a.sort();\n     assert_eq!(a, [x, y]);"}, {"sha": "f5eef2ad6e7539117e5c00890e68c96646f7f50d", "filename": "tests/pass/validation_lifetime_resolution.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvalidation_lifetime_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvalidation_lifetime_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fvalidation_lifetime_resolution.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -7,16 +7,22 @@ trait Id {\n impl<'a> Id for &'a mut i32 {\n     type Out = &'a mut i32;\n \n-    fn id(self) -> Self { self }\n+    fn id(self) -> Self {\n+        self\n+    }\n }\n \n impl<'a> Id for &'a mut u32 {\n     type Out = &'a mut u32;\n \n-    fn id(self) -> Self { self }\n+    fn id(self) -> Self {\n+        self\n+    }\n }\n \n-fn foo<T>(mut x: T) where for<'a> &'a mut T: Id\n+fn foo<T>(mut x: T)\n+where\n+    for<'a> &'a mut T: Id,\n {\n     let x = &mut x;\n     let _y = x.id();"}, {"sha": "3a869703bf96a4cb9efea88c2653400e9653cd4a", "filename": "tests/pass/vec-matching-fold.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fvec-matching-fold.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,32 +1,30 @@\n use std::fmt::Debug;\n \n-fn foldl<T, U, F>(values: &[T],\n-                  initial: U,\n-                  mut function: F)\n-                  -> U where\n-    U: Clone+Debug, T:Debug,\n+fn foldl<T, U, F>(values: &[T], initial: U, mut function: F) -> U\n+where\n+    U: Clone + Debug,\n+    T: Debug,\n     F: FnMut(U, &T) -> U,\n-{    match values {\n-        [head, tail @ ..] =>\n-            foldl(tail, function(initial, head), function),\n+{\n+    match values {\n+        [head, tail @ ..] => foldl(tail, function(initial, head), function),\n         [] => {\n-            let res = initial.clone(); res\n+            let res = initial.clone();\n+            res\n         }\n     }\n }\n \n-fn foldr<T, U, F>(values: &[T],\n-                  initial: U,\n-                  mut function: F)\n-                  -> U where\n+fn foldr<T, U, F>(values: &[T], initial: U, mut function: F) -> U\n+where\n     U: Clone,\n     F: FnMut(&T, U) -> U,\n {\n     match values {\n-        [head @ .., tail] =>\n-            foldr(head, function(tail, initial), function),\n+        [head @ .., tail] => foldr(head, function(tail, initial), function),\n         [] => {\n-            let res = initial.clone(); res\n+            let res = initial.clone();\n+            res\n         }\n     }\n }"}, {"sha": "89c2561acd970e7b17b39fd781288a0ce8b52e57", "filename": "tests/pass/vec.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fvec.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -33,51 +33,37 @@ fn make_vec_macro_repeat_zeroed() -> Vec<u8> {\n }\n \n fn vec_into_iter() -> u8 {\n-    vec![1, 2, 3, 4]\n-        .into_iter()\n-        .map(|x| x * x)\n-        .fold(0, |x, y| x + y)\n+    vec![1, 2, 3, 4].into_iter().map(|x| x * x).fold(0, |x, y| x + y)\n }\n \n fn vec_into_iter_rev() -> u8 {\n-    vec![1, 2, 3, 4]\n-        .into_iter()\n-        .map(|x| x * x)\n-        .fold(0, |x, y| x + y)\n+    vec![1, 2, 3, 4].into_iter().map(|x| x * x).fold(0, |x, y| x + y)\n }\n \n fn vec_into_iter_zst() -> usize {\n-    vec![[0u64; 0], [0u64; 0]]\n-        .into_iter()\n-        .rev()\n-        .map(|x| x.len())\n-        .sum()\n+    vec![[0u64; 0], [0u64; 0]].into_iter().rev().map(|x| x.len()).sum()\n }\n \n fn vec_into_iter_rev_zst() -> usize {\n-    vec![[0u64; 0], [0u64; 0]]\n-        .into_iter()\n-        .rev()\n-        .map(|x| x.len())\n-        .sum()\n+    vec![[0u64; 0], [0u64; 0]].into_iter().rev().map(|x| x.len()).sum()\n }\n \n fn vec_iter_and_mut() {\n-    let mut v = vec![1,2,3,4];\n+    let mut v = vec![1, 2, 3, 4];\n     for i in v.iter_mut() {\n         *i += 1;\n     }\n-    assert_eq!(v.iter().sum::<i32>(), 2+3+4+5);\n+    assert_eq!(v.iter().sum::<i32>(), 2 + 3 + 4 + 5);\n \n     test_all_refs(&mut 13, v.iter_mut());\n }\n \n fn vec_iter_and_mut_rev() {\n-    let mut v = vec![1,2,3,4];\n+    let mut v = vec![1, 2, 3, 4];\n     for i in v.iter_mut().rev() {\n         *i += 1;\n     }\n-    assert_eq!(v.iter().sum::<i32>(), 2+3+4+5);\n+    assert_eq!(v.iter().sum::<i32>(), 2 + 3 + 4 + 5);\n }\n \n fn vec_reallocate() -> Vec<u8> {"}, {"sha": "d2295a7afb5992a148f0da28079667dbd4798a0d", "filename": "tests/pass/vecdeque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fvecdeque.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     src.push_front(Box::new(2));\n     dst.append(&mut src);\n     for a in dst.iter() {\n-      assert_eq!(**a, 2);\n+        assert_eq!(**a, 2);\n     }\n \n     // Regression test for Debug impl's"}, {"sha": "b9ceb61f0c9fcf73bdb8fa36360d70179b56df49", "filename": "tests/pass/weak_memory/weak.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fweak_memory%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fweak_memory%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fweak_memory%2Fweak.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -94,7 +94,6 @@ fn initialization_write() -> bool {\n     r2 == 11\n }\n \n-\n // Asserts that the function returns true at least once in 100 runs\n macro_rules! assert_once {\n     ($f:ident) => {"}, {"sha": "e31b00e95244ee52f819cd4e7986786eec3ceec4", "filename": "tests/pass/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fwtf8.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -1,7 +1,7 @@\n // only-windows\n \n-use std::os::windows::ffi::{OsStrExt, OsStringExt};\n use std::ffi::{OsStr, OsString};\n+use std::os::windows::ffi::{OsStrExt, OsStringExt};\n \n fn test1() {\n     let base = \"a\\t\u00e9 \\u{7f}\ud83d\udca9\\r\";"}, {"sha": "3a853e7d8a68f2185e737373d6fa493c04c367d8", "filename": "tests/pass/zst.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbb649adfe172a9ef4b1b91688c14b57c6c3b839/tests%2Fpass%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fzst.rs?ref=cbb649adfe172a9ef4b1b91688c14b57c6c3b839", "patch": "@@ -19,6 +19,10 @@ fn main() {\n     assert_eq!(use_zst(), A);\n     let x = 42 as *mut [u8; 0];\n     // Reading and writing is ok.\n-    unsafe { *x = zst_val; }\n-    unsafe { let _y = *x; }\n+    unsafe {\n+        *x = zst_val;\n+    }\n+    unsafe {\n+        let _y = *x;\n+    }\n }"}]}