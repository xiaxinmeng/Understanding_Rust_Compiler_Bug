{"sha": "88714625758808e69943b472e329b00c4aa73c97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4NzE0NjI1NzU4ODA4ZTY5OTQzYjQ3MmUzMjliMDBjNGFhNzNjOTc=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-03T17:57:33Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-03T18:07:53Z"}, "message": "Do a bunch more typechecking for iters and for each loops.\n\nCloses #771.\nCloses #772.\nCloses #796.", "tree": {"sha": "34596e714b69f52e1a221a33d81d16007fb069a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34596e714b69f52e1a221a33d81d16007fb069a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88714625758808e69943b472e329b00c4aa73c97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88714625758808e69943b472e329b00c4aa73c97", "html_url": "https://github.com/rust-lang/rust/commit/88714625758808e69943b472e329b00c4aa73c97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88714625758808e69943b472e329b00c4aa73c97/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3254fb980658b7c7313e213330b80a25c28ec77b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3254fb980658b7c7313e213330b80a25c28ec77b", "html_url": "https://github.com/rust-lang/rust/commit/3254fb980658b7c7313e213330b80a25c28ec77b"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "197419fe2f5088b6eb51a421aa949c5834f2d2d8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/88714625758808e69943b472e329b00c4aa73c97/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88714625758808e69943b472e329b00c4aa73c97/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=88714625758808e69943b472e329b00c4aa73c97", "patch": "@@ -1531,9 +1531,27 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n               _ { fty }\n             };\n \n-        // Grab the argument types and the return type.\n+        let sty = structure_of(fcx, sp, fty_stripped);\n+\n+        // Check that we aren't confusing iter calls and fn calls\n+        alt sty {\n+          ty::ty_fn(ast::proto_iter., _, _, _, _) {\n+            if call_kind != kind_for_each {\n+                fcx.ccx.tcx.sess.span_err(\n+                    sp, \"calling iter outside of for each loop\");\n+            }\n+          }\n+          _ {\n+              if call_kind == kind_for_each {\n+                fcx.ccx.tcx.sess.span_err(\n+                    sp, \"calling non-iter as sequence of for each loop\");\n+            }\n+          }\n+        }\n+\n+        // Grab the argument types\n         let arg_tys;\n-        alt structure_of(fcx, sp, fty_stripped) {\n+        alt sty {\n           ty::ty_fn(_, arg_tys_0, _, _, _) |\n           ty::ty_native_fn(_, arg_tys_0, _) { arg_tys = arg_tys_0; }\n           _ {\n@@ -1590,8 +1608,8 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         write::ty_only_fixup(fcx, id, ty::mk_nil(fcx.ccx.tcx));\n         ret bot;\n     }\n-    // A generic function for checking call expressions\n \n+    // A generic function for checking call expressions\n     fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n                   args: &(@ast::expr)[], call_kind: call_kind) -> bool {\n         let args_opt_0: (option::t[@ast::expr])[] = ~[];\n@@ -1602,8 +1620,34 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         // Call the generic checker.\n         ret check_call_or_bind(fcx, sp, f, args_opt_0, call_kind);\n     }\n-    // A generic function for checking for or for-each loops\n \n+    // A generic function for doing all of the checking for call expressions\n+    fn check_call_full(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n+                       args: &(@ast::expr)[], call_kind: call_kind,\n+                       id: ast::node_id) -> bool {\n+        /* here we're kind of hosed, as f can be any expr\n+        need to restrict it to being an explicit expr_path if we're\n+        inside a pure function, and need an environment mapping from\n+        function name onto purity-designation */\n+        require_pure_call(fcx.ccx, fcx.purity, f, sp);\n+        let bot = check_call(fcx, sp, f, args, call_kind);\n+\n+        // Pull the return type out of the type of the function.\n+        let rt_1;\n+        let fty = do_autoderef(fcx, sp, ty::expr_ty(fcx.ccx.tcx, f));\n+        alt structure_of(fcx, sp, fty) {\n+          ty::ty_fn(_, _, rt, cf, _) {\n+            bot |= cf == ast::noreturn;\n+            rt_1 = rt;\n+          }\n+          ty::ty_native_fn(_, _, rt) { rt_1 = rt; }\n+          _ { fail \"LHS of call expr didn't have a function type?!\"; }\n+        }\n+        write::ty_only_fixup(fcx, id, rt_1);\n+        ret bot;\n+    }\n+\n+    // A generic function for checking for or for-each loops\n     fn check_for_or_for_each(fcx: &@fn_ctxt, local: &@ast::local,\n                              element_ty: ty::t, body: &ast::blk,\n                              node_id: ast::node_id) -> bool {\n@@ -1952,9 +1996,16 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n       }\n       ast::expr_for_each(decl, seq, body) {\n-        bot = check_expr(fcx, seq) |\n-              check_for_or_for_each(fcx, decl, expr_ty(tcx, seq),\n-                                    body, id);\n+        alt (seq.node) {\n+          ast::expr_call(f, args) {\n+            bot = check_call_full(fcx, seq.span, f, args,\n+                                  kind_for_each, seq.id);\n+          }\n+          _ { tcx.sess.span_fatal(\n+              expr.span, \"sequence in for each loop not a call\"); }\n+        }\n+        bot |= check_for_or_for_each(fcx, decl, expr_ty(tcx, seq),\n+                                     body, id);\n       }\n       ast::expr_while(cond, body) {\n         bot = check_expr(fcx, cond);\n@@ -1973,7 +2024,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n       ast::expr_alt(expr, arms) {\n         bot = check_expr(fcx, expr);\n         // Typecheck the patterns first, so that we get types for all the\n-        // bindings.\n+       // bindings.\n \n         let pattern_ty = ty::expr_ty(tcx, expr);\n         for arm: ast::arm  in arms {\n@@ -2060,28 +2111,7 @@ fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n         write::ty_only_fixup(fcx, id, t_1);\n       }\n       ast::expr_call(f, args) {\n-        /* here we're kind of hosed, as f can be any expr\n-         need to restrict it to being an explicit expr_path if we're\n-        inside a pure function, and need an environment mapping from\n-        function name onto purity-designation */\n-\n-        require_pure_call(fcx.ccx, fcx.purity, f, expr.span);\n-        bot = check_call(fcx, expr.span, f, args, kind_call);\n-        // Pull the return type out of the type of the function.\n-\n-        let rt_1;\n-        let fty = do_autoderef(fcx, expr.span, ty::expr_ty(tcx, f));\n-        alt structure_of(fcx, expr.span, fty) {\n-          ty::ty_fn(_, _, rt, cf, _) {\n-            bot |= cf == ast::noreturn;\n-            rt_1 = rt;\n-          }\n-          ty::ty_native_fn(_, _, rt) { rt_1 = rt; }\n-          _ {\n-            fail \"LHS of call expr didn't have a function type?!\";\n-          }\n-        }\n-        write::ty_only_fixup(fcx, id, rt_1);\n+        bot = check_call_full(fcx, expr.span, f, args, kind_call, expr.id);\n       }\n       ast::expr_self_method(ident) {\n         let t = ty::mk_nil(tcx);"}, {"sha": "aed835aedec5976782c69e7ed3ec6235abd26f69", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88714625758808e69943b472e329b00c4aa73c97/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88714625758808e69943b472e329b00c4aa73c97/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=88714625758808e69943b472e329b00c4aa73c97", "patch": "@@ -150,13 +150,14 @@ fn lit_eq(l: &@ast::lit, m: &@ast::lit) -> bool {\n     }\n }\n \n-tag call_kind { kind_call; kind_spawn; kind_bind; }\n+tag call_kind { kind_call; kind_spawn; kind_bind; kind_for_each; }\n \n fn call_kind_str(c: call_kind) -> str {\n     alt c {\n       kind_call. { \"Call\" }\n       kind_spawn. { \"Spawn\" }\n       kind_bind. { \"Bind\" }\n+      kind_for_each. { \"For-Each\" }\n     }\n }\n "}, {"sha": "6b4d59fa8713f7d95edac46e30f2236b794057b7", "filename": "src/test/compile-fail/fn-as-iter.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88714625758808e69943b472e329b00c4aa73c97/src%2Ftest%2Fcompile-fail%2Ffn-as-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88714625758808e69943b472e329b00c4aa73c97/src%2Ftest%2Fcompile-fail%2Ffn-as-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-as-iter.rs?ref=88714625758808e69943b472e329b00c4aa73c97", "patch": "@@ -0,0 +1,3 @@\n+// error-pattern:calling non-iter as sequence of for each loop\n+fn f() -> int { ret 4; }\n+fn main() { for each i in f() { } }"}, {"sha": "d34c91cd2712a836916885963bfa6a12f7747d87", "filename": "src/test/compile-fail/for-each-over-bs.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88714625758808e69943b472e329b00c4aa73c97/src%2Ftest%2Fcompile-fail%2Ffor-each-over-bs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88714625758808e69943b472e329b00c4aa73c97/src%2Ftest%2Fcompile-fail%2Ffor-each-over-bs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-each-over-bs.rs?ref=88714625758808e69943b472e329b00c4aa73c97", "patch": "@@ -0,0 +1,2 @@\n+// error-pattern:sequence in for each loop not a call\n+fn main() { for each p in 1 {} }"}, {"sha": "a2cd88dc2361108b60b7514927c02901e5801fdc", "filename": "src/test/compile-fail/iter-as-fn.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88714625758808e69943b472e329b00c4aa73c97/src%2Ftest%2Fcompile-fail%2Fiter-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88714625758808e69943b472e329b00c4aa73c97/src%2Ftest%2Fcompile-fail%2Fiter-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fiter-as-fn.rs?ref=88714625758808e69943b472e329b00c4aa73c97", "patch": "@@ -0,0 +1,3 @@\n+// error-pattern:calling iter outside of for each loop\n+iter i() { }\n+fn main() { i(); }"}]}