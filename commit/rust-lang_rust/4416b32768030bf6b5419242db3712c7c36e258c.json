{"sha": "4416b32768030bf6b5419242db3712c7c36e258c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MTZiMzI3NjgwMzBiZjZiNTQxOTI0MmRiMzcxMmM3YzM2ZTI1OGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T16:16:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T16:16:42Z"}, "message": "auto merge of #14873 : pnkfelix/rust/fsk-dataflow-revisions, r=nikomatsakis\n\nFix #6298.  Fix  #13767.\r\n\r\nThis also includes some drive by fixes for some other issues, noted in the commits.\r\n\r\nI still need to integrate regression tests for some cases that I noticed were missing from our unit test suite (i.e. things that compiling rustc exposes that should have been exposed when doing `make check-stage1`).  So do not land this yet, until I get the chance to add those tests.\r\n\r\nI just wanted to get the review process started soon, since this has been long in the coming.", "tree": {"sha": "08198d7c7fb1ef83a79f114602a1ada177835579", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08198d7c7fb1ef83a79f114602a1ada177835579"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4416b32768030bf6b5419242db3712c7c36e258c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4416b32768030bf6b5419242db3712c7c36e258c", "html_url": "https://github.com/rust-lang/rust/commit/4416b32768030bf6b5419242db3712c7c36e258c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4416b32768030bf6b5419242db3712c7c36e258c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78cb2f5bc0244edeb0f7f042c81f16931c437d27", "url": "https://api.github.com/repos/rust-lang/rust/commits/78cb2f5bc0244edeb0f7f042c81f16931c437d27", "html_url": "https://github.com/rust-lang/rust/commit/78cb2f5bc0244edeb0f7f042c81f16931c437d27"}, {"sha": "4c2a8bbc097b4ba0c317c07a095238aed128899d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c2a8bbc097b4ba0c317c07a095238aed128899d", "html_url": "https://github.com/rust-lang/rust/commit/4c2a8bbc097b4ba0c317c07a095238aed128899d"}], "stats": {"total": 1630, "additions": 984, "deletions": 646}, "files": [{"sha": "df208b9cdc133f85f352a0a3a60dec63e8433968", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -242,7 +242,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         let mut loan_path = loan_path;\n         loop {\n             match *loan_path {\n-                LpVar(_) => {\n+                LpVar(_) | LpUpvar(_) => {\n                     break;\n                 }\n                 LpExtend(ref lp_base, _, _) => {\n@@ -632,7 +632,7 @@ impl<'a> CheckLoanCtxt<'a> {\n          */\n \n         match **lp {\n-            LpVar(_) => {\n+            LpVar(_) | LpUpvar(_) => {\n                 // assigning to `x` does not require that `x` is initialized\n             }\n             LpExtend(ref lp_base, _, LpInterior(_)) => {"}, {"sha": "9fc291d3971912e1eff10d0b6a1a3cc2f967311c", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -948,7 +948,7 @@ The borrow checker is also in charge of ensuring that:\n \n These are two separate dataflow analyses built on the same\n framework. Let's look at checking that memory is initialized first;\n-the checking of immutable local variabe assignments works in a very\n+the checking of immutable local variable assignments works in a very\n similar way.\n \n To track the initialization of memory, we actually track all the"}, {"sha": "454c3dcd5d3cadd211f996dda5243469ac9a46e6", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -395,7 +395,8 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! from a local variable, mark the mutability decl as necessary.\n \n         match *loan_path {\n-            LpVar(local_id) => {\n+            LpVar(local_id) |\n+            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n             LpExtend(ref base, mc::McInherited, _) => {\n@@ -445,8 +446,8 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan.\n \n+        let lexical_scope = lp.kill_scope(self.bccx.tcx);\n         let rm = &self.bccx.tcx.region_maps;\n-        let lexical_scope = rm.var_scope(lp.node_id());\n         if rm.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {"}, {"sha": "d131b6f7eda29895a49ec774d8705d7bdd9b538a", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -67,13 +67,23 @@ impl<'a> RestrictionsContext<'a> {\n             }\n \n             mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) |\n-            mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n-                // R-Variable\n+            mc::cat_arg(local_id) => {\n+                // R-Variable, locally declared\n                 let lp = Rc::new(LpVar(local_id));\n                 SafeIf(lp.clone(), vec!(lp))\n             }\n \n+            mc::cat_upvar(upvar_id, _) => {\n+                // R-Variable, captured into closure\n+                let lp = Rc::new(LpUpvar(upvar_id));\n+                SafeIf(lp.clone(), vec!(lp))\n+            }\n+\n+            mc::cat_copied_upvar(..) => {\n+                // FIXME(#2152) allow mutation of upvars\n+                Safe\n+            }\n+\n             mc::cat_downcast(cmt_base) => {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n@@ -107,7 +117,6 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpDeref(pk))\n             }\n \n-            mc::cat_copied_upvar(..) | // FIXME(#2152) allow mutation of upvars\n             mc::cat_static_item(..) => {\n                 Safe\n             }"}, {"sha": "0c77e637790747f2d37131a6875a1f365a6d691b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -12,7 +12,9 @@\n \n #![allow(non_camel_case_types)]\n \n+use middle::cfg;\n use middle::dataflow::DataFlowContext;\n+use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use middle::def;\n use euv = middle::expr_use_visitor;\n@@ -126,20 +128,28 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     let id_range = ast_util::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, decl, body);\n+    let cfg = cfg::CFG::new(this.tcx, body);\n+\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n+                             \"borrowck\",\n+                             Some(decl),\n+                             &cfg,\n                              LoanDataFlowOperator,\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n         loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n         loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n     }\n-    loan_dfcx.propagate(body);\n+    loan_dfcx.add_kills_from_flow_exits(&cfg);\n+    loan_dfcx.propagate(&cfg, body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n                                                       this.tcx,\n+                                                      &cfg,\n                                                       id_range,\n+                                                      decl,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n@@ -191,6 +201,7 @@ pub struct Loan {\n #[deriving(PartialEq, Eq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n+    LpUpvar(ty::UpvarId),             // `x` captured by-value into closure\n     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n@@ -200,11 +211,25 @@ pub enum LoanPathElem {\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n+pub fn closure_to_block(closure_id: ast::NodeId,\n+                    tcx: &ty::ctxt) -> ast::NodeId {\n+    match tcx.map.get(closure_id) {\n+        ast_map::NodeExpr(expr) => match expr.node {\n+            ast::ExprProc(_decl, block) |\n+            ast::ExprFnBlock(_decl, block) => { block.id }\n+            _ => fail!(\"encountered non-closure id: {}\", closure_id)\n+        },\n+        _ => fail!(\"encountered non-expr id: {}\", closure_id)\n+    }\n+}\n+\n impl LoanPath {\n-    pub fn node_id(&self) -> ast::NodeId {\n+    pub fn kill_scope(&self, tcx: &ty::ctxt) -> ast::NodeId {\n         match *self {\n-            LpVar(local_id) => local_id,\n-            LpExtend(ref base, _, _) => base.node_id()\n+            LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n+            LpUpvar(upvar_id) =>\n+                closure_to_block(upvar_id.closure_expr_id, tcx),\n+            LpExtend(ref base, _, _) => base.kill_scope(tcx),\n         }\n     }\n }\n@@ -224,12 +249,18 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n         }\n \n         mc::cat_local(id) |\n-        mc::cat_arg(id) |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n-        mc::cat_upvar(ty::UpvarId {var_id: id, ..}, _) => {\n+        mc::cat_arg(id) => {\n             Some(Rc::new(LpVar(id)))\n         }\n \n+        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) |\n+        mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id,\n+                                               onceness: _,\n+                                               capturing_proc: proc_id }) => {\n+            let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };\n+            Some(Rc::new(LpUpvar(upvar_id)))\n+        }\n+\n         mc::cat_deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n@@ -683,6 +714,7 @@ impl<'a> BorrowckCtxt<'a> {\n                                    loan_path: &LoanPath,\n                                    out: &mut String) {\n         match *loan_path {\n+            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n@@ -724,7 +756,7 @@ impl<'a> BorrowckCtxt<'a> {\n                 self.append_autoderefd_loan_path_to_str(&**lp_base, out)\n             }\n \n-            LpVar(..) | LpExtend(_, _, LpInterior(..)) => {\n+            LpVar(..) | LpUpvar(..) | LpExtend(_, _, LpInterior(..)) => {\n                 self.append_loan_path_to_str(loan_path, out)\n             }\n         }\n@@ -753,15 +785,17 @@ fn is_statement_scope(tcx: &ty::ctxt, region: ty::Region) -> bool {\n      }\n }\n \n-impl DataFlowOperator for LoanDataFlowOperator {\n+impl BitwiseOperator for LoanDataFlowOperator {\n     #[inline]\n-    fn initial_value(&self) -> bool {\n-        false // no loans in scope by default\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // loans from both preds are in scope\n     }\n+}\n \n+impl DataFlowOperator for LoanDataFlowOperator {\n     #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n-        succ | pred // loans from both preds are in scope\n+    fn initial_value(&self) -> bool {\n+        false // no loans in scope by default\n     }\n }\n \n@@ -784,6 +818,12 @@ impl Repr for LoanPath {\n                 (format!(\"$({})\", tcx.map.node_to_str(id))).to_string()\n             }\n \n+            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n+                let s = tcx.map.node_to_str(var_id);\n+                let s = format!(\"$({} captured by id={})\", s, closure_expr_id);\n+                s.to_string()\n+            }\n+\n             &LpExtend(ref lp, _, LpDeref(_)) => {\n                 (format!(\"{}.*\", lp.repr(tcx))).to_string()\n             }"}, {"sha": "bb92043b1ea6a42e7a99dd7725fbd4070a28a922", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -20,7 +20,9 @@ use std::rc::Rc;\n use std::uint;\n use std::collections::{HashMap, HashSet};\n use middle::borrowck::*;\n+use middle::cfg;\n use middle::dataflow::DataFlowContext;\n+use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use euv = middle::expr_use_visitor;\n use middle::ty;\n@@ -229,7 +231,7 @@ impl MoveData {\n         }\n \n         let index = match *lp {\n-            LpVar(..) => {\n+            LpVar(..) | LpUpvar(..) => {\n                 let index = MovePathIndex(self.paths.borrow().len());\n \n                 self.paths.borrow_mut().push(MovePath {\n@@ -300,7 +302,7 @@ impl MoveData {\n             }\n             None => {\n                 match **lp {\n-                    LpVar(..) => { }\n+                    LpVar(..) | LpUpvar(..) => { }\n                     LpExtend(ref b, _, _) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n@@ -416,6 +418,11 @@ impl MoveData {\n                     let path = *self.path_map.borrow().get(&path.loan_path);\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n+                    let kill_id = closure_to_block(closure_expr_id, tcx);\n+                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    self.kill_moves(path, kill_id, dfcx_moves);\n+                }\n                 LpExtend(..) => {}\n             }\n         }\n@@ -428,6 +435,10 @@ impl MoveData {\n                     let kill_id = tcx.region_maps.var_scope(id);\n                     dfcx_assign.add_kill(kill_id, assignment_index);\n                 }\n+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n+                    let kill_id = closure_to_block(closure_expr_id, tcx);\n+                    dfcx_assign.add_kill(kill_id, assignment_index);\n+                }\n                 LpExtend(..) => {\n                     tcx.sess.bug(\"var assignment for non var path\");\n                 }\n@@ -499,22 +510,33 @@ impl MoveData {\n impl<'a> FlowedMoveData<'a> {\n     pub fn new(move_data: MoveData,\n                tcx: &'a ty::ctxt,\n+               cfg: &'a cfg::CFG,\n                id_range: ast_util::IdRange,\n+               decl: &ast::FnDecl,\n                body: &ast::Block)\n                -> FlowedMoveData<'a> {\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n+                                 \"flowed_move_data_moves\",\n+                                 Some(decl),\n+                                 cfg,\n                                  MoveDataFlowOperator,\n                                  id_range,\n                                  move_data.moves.borrow().len());\n         let mut dfcx_assign =\n             DataFlowContext::new(tcx,\n+                                 \"flowed_move_data_assigns\",\n+                                 Some(decl),\n+                                 cfg,\n                                  AssignDataFlowOperator,\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n         move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n-        dfcx_moves.propagate(body);\n-        dfcx_assign.propagate(body);\n+        dfcx_moves.add_kills_from_flow_exits(cfg);\n+        dfcx_assign.add_kills_from_flow_exits(cfg);\n+        dfcx_moves.propagate(cfg, body);\n+        dfcx_assign.propagate(cfg, body);\n+\n         FlowedMoveData {\n             move_data: move_data,\n             dfcx_moves: dfcx_moves,\n@@ -659,12 +681,21 @@ impl<'a> FlowedMoveData<'a> {\n     }\n }\n \n+impl BitwiseOperator for MoveDataFlowOperator {\n+    #[inline]\n+    fn join(&self, succ: uint, pred: uint) -> uint {\n+        succ | pred // moves from both preds are in scope\n+    }\n+}\n+\n impl DataFlowOperator for MoveDataFlowOperator {\n     #[inline]\n     fn initial_value(&self) -> bool {\n         false // no loans in scope by default\n     }\n+}\n \n+impl BitwiseOperator for AssignDataFlowOperator {\n     #[inline]\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n@@ -676,9 +707,4 @@ impl DataFlowOperator for AssignDataFlowOperator {\n     fn initial_value(&self) -> bool {\n         false // no assignments in scope by default\n     }\n-\n-    #[inline]\n-    fn join(&self, succ: uint, pred: uint) -> uint {\n-        succ | pred // moves from both preds are in scope\n-    }\n }"}, {"sha": "0d8729071ef6b03a5c10c65d12ba41804da32094", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -254,6 +254,7 @@ impl<'a> CFGBuilder<'a> {\n                 });\n                 let body_exit = self.block(&**body, cond_exit);          // 4\n                 self.add_contained_edge(body_exit, loopback);            // 5\n+                self.loop_scopes.pop();\n                 expr_exit\n             }\n \n@@ -427,8 +428,22 @@ impl<'a> CFGBuilder<'a> {\n                 self.straightline(expr, pred, [e])\n             }\n \n+            ast::ExprInlineAsm(ref inline_asm) => {\n+                let inputs = inline_asm.inputs.iter();\n+                let outputs = inline_asm.outputs.iter();\n+                fn extract_expr<A>(&(_, expr): &(A, Gc<ast::Expr>)) -> Gc<ast::Expr> { expr }\n+                let post_inputs = self.exprs(inputs.map(|a| {\n+                    debug!(\"cfg::construct InlineAsm id:{} input:{:?}\", expr.id, a);\n+                    extract_expr(a)\n+                }), pred);\n+                let post_outputs = self.exprs(outputs.map(|a| {\n+                    debug!(\"cfg::construct InlineAsm id:{} output:{:?}\", expr.id, a);\n+                    extract_expr(a)\n+                }), post_inputs);\n+                self.add_node(expr.id, [post_outputs])\n+            }\n+\n             ast::ExprMac(..) |\n-            ast::ExprInlineAsm(..) |\n             ast::ExprFnBlock(..) |\n             ast::ExprProc(..) |\n             ast::ExprLit(..) |\n@@ -444,15 +459,22 @@ impl<'a> CFGBuilder<'a> {\n             func_or_rcvr: Gc<ast::Expr>,\n             args: &[Gc<ast::Expr>]) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n-        self.straightline(call_expr, func_or_rcvr_exit, args)\n+        let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n+\n+        let return_ty = ty::node_id_to_type(self.tcx, call_expr.id);\n+        let fails = ty::type_is_bot(return_ty);\n+        if fails {\n+            self.add_node(ast::DUMMY_NODE_ID, [])\n+        } else {\n+            ret\n+        }\n     }\n \n-    fn exprs(&mut self,\n-             exprs: &[Gc<ast::Expr>],\n-             pred: CFGIndex) -> CFGIndex {\n+    fn exprs<I:Iterator<Gc<ast::Expr>>>(&mut self,\n+                                        mut exprs: I,\n+                                        pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `exprs` evaluated in order\n-\n-        exprs.iter().fold(pred, |p, &e| self.expr(e, p))\n+        exprs.fold(pred, |p, e| self.expr(e, p))\n     }\n \n     fn opt_expr(&mut self,\n@@ -469,7 +491,7 @@ impl<'a> CFGBuilder<'a> {\n                     subexprs: &[Gc<ast::Expr>]) -> CFGIndex {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n-        let subexprs_exit = self.exprs(subexprs, pred);\n+        let subexprs_exit = self.exprs(subexprs.iter().map(|&e|e), pred);\n         self.add_node(expr.id, [subexprs_exit])\n     }\n "}, {"sha": "bb758ec7c38b73082254fa654dafd375419ac1f0", "filename": "src/librustc/middle/cfg/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fmod.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -15,8 +15,6 @@ Uses `Graph` as the underlying representation.\n \n */\n \n-#![allow(dead_code)] // still a WIP, #6298\n-\n use middle::graph;\n use middle::ty;\n use syntax::ast;\n@@ -48,11 +46,6 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n \n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n-pub struct CFGIndices {\n-    entry: CFGIndex,\n-    exit: CFGIndex,\n-}\n-\n impl CFG {\n     pub fn new(tcx: &ty::ctxt,\n                blk: &ast::Block) -> CFG {"}, {"sha": "7a26d2104826fe13574ff3123f18ba5190602928", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 288, "deletions": 578, "changes": 866, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -17,23 +17,24 @@\n  */\n \n \n-use middle::def;\n+use middle::cfg;\n+use middle::cfg::CFGIndex;\n use middle::ty;\n-use middle::typeck;\n use std::io;\n-use std::gc::Gc;\n use std::uint;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::ast_util::IdRange;\n+use syntax::visit;\n use syntax::print::{pp, pprust};\n-use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n #[deriving(Clone)]\n pub struct DataFlowContext<'a, O> {\n     tcx: &'a ty::ctxt,\n \n+    /// a name for the analysis using this dataflow instance\n+    analysis_name: &'static str,\n+\n     /// the data flow operator\n     oper: O,\n \n@@ -44,43 +45,108 @@ pub struct DataFlowContext<'a, O> {\n     /// equal to bits_per_id/uint::BITS rounded up.\n     words_per_id: uint,\n \n-    // mapping from node to bitset index.\n-    nodeid_to_bitset: NodeMap<uint>,\n+    // mapping from cfg node index to bitset index.\n+    index_to_bitset: Vec<Option<uint>>,\n+\n+    // mapping from node to cfg node index\n+    // FIXME (#6298): Shouldn't this go with CFG?\n+    nodeid_to_index: NodeMap<CFGIndex>,\n \n-    // Bit sets per id.  The following three fields (`gens`, `kills`,\n+    // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n     // `id_range`, there is a range of words equal to `words_per_id`.\n     // So, to access the bits for any given id, you take a slice of\n     // the full vector (see the method `compute_id_range()`).\n \n-    /// bits generated as we exit the scope `id`. Updated by `add_gen()`.\n+    /// bits generated as we exit the cfg node. Updated by `add_gen()`.\n     gens: Vec<uint>,\n \n-    /// bits killed as we exit the scope `id`. Updated by `add_kill()`.\n+    /// bits killed as we exit the cfg node. Updated by `add_kill()`.\n     kills: Vec<uint>,\n \n-    /// bits that are valid on entry to the scope `id`. Updated by\n+    /// bits that are valid on entry to the cfg node. Updated by\n     /// `propagate()`.\n     on_entry: Vec<uint>,\n }\n \n+pub trait BitwiseOperator {\n+    /// Joins two predecessor bits together, typically either `|` or `&`\n+    fn join(&self, succ: uint, pred: uint) -> uint;\n+}\n+\n /// Parameterization for the precise form of data flow that is used.\n-pub trait DataFlowOperator {\n+pub trait DataFlowOperator : BitwiseOperator {\n     /// Specifies the initial value for each bit in the `on_entry` set\n     fn initial_value(&self) -> bool;\n-\n-    /// Joins two predecessor bits together, typically either `|` or `&`\n-    fn join(&self, succ: uint, pred: uint) -> uint;\n }\n \n struct PropagationContext<'a, 'b, O> {\n     dfcx: &'a mut DataFlowContext<'b, O>,\n     changed: bool\n }\n \n-struct LoopScope<'a> {\n-    loop_id: ast::NodeId,\n-    break_bits: Vec<uint>\n+fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n+    let opt_cfgindex = index.find(&id).map(|&i|i);\n+    opt_cfgindex.unwrap_or_else(|| {\n+        fail!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n+    })\n+}\n+\n+impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n+    fn has_bitset(&self, n: ast::NodeId) -> bool {\n+        assert!(n != ast::DUMMY_NODE_ID);\n+        match self.nodeid_to_index.find(&n) {\n+            None => false,\n+            Some(&cfgidx) => {\n+                let node_id = cfgidx.node_id();\n+                node_id < self.index_to_bitset.len() &&\n+                    self.index_to_bitset.get(node_id).is_some()\n+            }\n+        }\n+    }\n+    fn get_bitset_index(&self, cfgidx: CFGIndex) -> uint {\n+        let node_id = cfgidx.node_id();\n+        self.index_to_bitset.get(node_id).unwrap()\n+    }\n+    fn get_or_create_bitset_index(&mut self, cfgidx: CFGIndex) -> uint {\n+        assert!(self.words_per_id > 0);\n+        let len = self.gens.len() / self.words_per_id;\n+        let expanded;\n+        let n;\n+        if self.index_to_bitset.len() <= cfgidx.node_id() {\n+            self.index_to_bitset.grow_set(cfgidx.node_id(), &None, Some(len));\n+            expanded = true;\n+            n = len;\n+        } else {\n+            let entry = self.index_to_bitset.get_mut(cfgidx.node_id());\n+            match *entry {\n+                None => {\n+                    *entry = Some(len);\n+                    expanded = true;\n+                    n = len;\n+                }\n+                Some(bitidx) => {\n+                    expanded = false;\n+                    n = bitidx;\n+                }\n+            }\n+        }\n+        if expanded {\n+            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n+            for _ in range(0, self.words_per_id) {\n+                self.gens.push(0);\n+                self.kills.push(0);\n+                self.on_entry.push(entry);\n+            }\n+        }\n+\n+        let start = n * self.words_per_id;\n+        let end = start + self.words_per_id;\n+        let len = self.gens.len();\n+        assert!(start < len);\n+        assert!(end <= len);\n+        n\n+    }\n }\n \n impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n@@ -94,8 +160,9 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n             pprust::NodePat(pat) => pat.id\n         };\n \n-        if self.nodeid_to_bitset.contains_key(&id) {\n-            let (start, end) = self.compute_id_range_frozen(id);\n+        if self.has_bitset(id) {\n+            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+            let (start, end) = self.compute_id_range_frozen(cfgidx);\n             let on_entry = self.on_entry.slice(start, end);\n             let entry_str = bits_to_str(on_entry);\n \n@@ -121,24 +188,74 @@ impl<'a, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, O> {\n     }\n }\n \n+fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n+                         cfg: &cfg::CFG) -> NodeMap<CFGIndex> {\n+    let mut index = NodeMap::new();\n+\n+    // FIXME (#6298): Would it be better to fold formals from decl\n+    // into cfg itself?  i.e. introduce a fn-based flow-graph in\n+    // addition to the current block-based flow-graph, rather than\n+    // have to put traversals like this here?\n+    match decl {\n+        None => {}\n+        Some(decl) => add_entries_from_fn_decl(&mut index, decl, cfg.entry)\n+    }\n+\n+    cfg.graph.each_node(|node_idx, node| {\n+        if node.data.id != ast::DUMMY_NODE_ID {\n+            index.insert(node.data.id, node_idx);\n+        }\n+        true\n+    });\n+\n+    return index;\n+\n+    fn add_entries_from_fn_decl(index: &mut NodeMap<CFGIndex>,\n+                                decl: &ast::FnDecl,\n+                                entry: CFGIndex) {\n+        //! add mappings from the ast nodes for the formal bindings to\n+        //! the entry-node in the graph.\n+        struct Formals<'a> {\n+            entry: CFGIndex,\n+            index: &'a mut NodeMap<CFGIndex>,\n+        }\n+        let mut formals = Formals { entry: entry, index: index };\n+        visit::walk_fn_decl(&mut formals, decl, ());\n+        impl<'a> visit::Visitor<()> for Formals<'a> {\n+            fn visit_pat(&mut self, p: &ast::Pat, e: ()) {\n+                self.index.insert(p.id, self.entry);\n+                visit::walk_pat(self, p, e)\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n     pub fn new(tcx: &'a ty::ctxt,\n+               analysis_name: &'static str,\n+               decl: Option<&ast::FnDecl>,\n+               cfg: &cfg::CFG,\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: uint) -> DataFlowContext<'a, O> {\n         let words_per_id = (bits_per_id + uint::BITS - 1) / uint::BITS;\n \n-        debug!(\"DataFlowContext::new(id_range={:?}, bits_per_id={:?}, words_per_id={:?})\",\n-               id_range, bits_per_id, words_per_id);\n+        debug!(\"DataFlowContext::new(analysis_name: {:s}, id_range={:?}, \\\n+                                     bits_per_id={:?}, words_per_id={:?})\",\n+               analysis_name, id_range, bits_per_id, words_per_id);\n \n         let gens = Vec::new();\n         let kills = Vec::new();\n         let on_entry = Vec::new();\n \n+        let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n+\n         DataFlowContext {\n             tcx: tcx,\n+            analysis_name: analysis_name,\n             words_per_id: words_per_id,\n-            nodeid_to_bitset: NodeMap::new(),\n+            index_to_bitset: Vec::new(),\n+            nodeid_to_index: nodeid_to_index,\n             bits_per_id: bits_per_id,\n             oper: oper,\n             gens: gens,\n@@ -149,74 +266,50 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n \n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n-\n-        debug!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n-        let (start, end) = self.compute_id_range(id);\n-        {\n-            let gens = self.gens.mut_slice(start, end);\n-            set_bit(gens, bit);\n-        }\n+        debug!(\"{:s} add_gen(id={:?}, bit={:?})\",\n+               self.analysis_name, id, bit);\n+        assert!(self.nodeid_to_index.contains_key(&id));\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range(cfgidx);\n+        let gens = self.gens.mut_slice(start, end);\n+        set_bit(gens, bit);\n     }\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n-\n-        debug!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n-        let (start, end) = self.compute_id_range(id);\n-        {\n-            let kills = self.kills.mut_slice(start, end);\n-            set_bit(kills, bit);\n-        }\n+        debug!(\"{:s} add_kill(id={:?}, bit={:?})\",\n+               self.analysis_name, id, bit);\n+        assert!(self.nodeid_to_index.contains_key(&id));\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range(cfgidx);\n+        let kills = self.kills.mut_slice(start, end);\n+        set_bit(kills, bit);\n     }\n \n-    fn apply_gen_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n+    fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {\n         //! Applies the gen and kill sets for `id` to `bits`\n-\n-        debug!(\"apply_gen_kill(id={:?}, bits={}) [before]\",\n-               id, mut_bits_to_str(bits));\n-        let (start, end) = self.compute_id_range(id);\n+        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [before]\",\n+               self.analysis_name, cfgidx, mut_bits_to_str(bits));\n+        let (start, end) = self.compute_id_range(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        bitwise(bits, gens, |a, b| a | b);\n+        bitwise(bits, gens, &Union);\n         let kills = self.kills.slice(start, end);\n-        bitwise(bits, kills, |a, b| a & !b);\n+        bitwise(bits, kills, &Subtract);\n \n-        debug!(\"apply_gen_kill(id={:?}, bits={}) [after]\",\n-               id, mut_bits_to_str(bits));\n-    }\n-\n-    fn apply_kill(&mut self, id: ast::NodeId, bits: &mut [uint]) {\n-        debug!(\"apply_kill(id={:?}, bits={}) [before]\",\n-               id, mut_bits_to_str(bits));\n-        let (start, end) = self.compute_id_range(id);\n-        let kills = self.kills.slice(start, end);\n-        bitwise(bits, kills, |a, b| a & !b);\n-        debug!(\"apply_kill(id={:?}, bits={}) [after]\",\n-               id, mut_bits_to_str(bits));\n+        debug!(\"{:s} apply_gen_kill(cfgidx={}, bits={}) [after]\",\n+               self.analysis_name, cfgidx, mut_bits_to_str(bits));\n     }\n \n-    fn compute_id_range_frozen(&self, id: ast::NodeId) -> (uint, uint) {\n-        let n = *self.nodeid_to_bitset.get(&id);\n+    fn compute_id_range_frozen(&self, cfgidx: CFGIndex) -> (uint, uint) {\n+        let n = self.get_bitset_index(cfgidx);\n         let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n         (start, end)\n     }\n \n-    fn compute_id_range(&mut self, id: ast::NodeId) -> (uint, uint) {\n-        let mut expanded = false;\n-        let len = self.nodeid_to_bitset.len();\n-        let n = self.nodeid_to_bitset.find_or_insert_with(id, |_| {\n-            expanded = true;\n-            len\n-        });\n-        if expanded {\n-            let entry = if self.oper.initial_value() { uint::MAX } else {0};\n-            for _ in range(0, self.words_per_id) {\n-                self.gens.push(0);\n-                self.kills.push(0);\n-                self.on_entry.push(entry);\n-            }\n-        }\n-        let start = *n * self.words_per_id;\n+    fn compute_id_range(&mut self, cfgidx: CFGIndex) -> (uint, uint) {\n+        let n = self.get_or_create_bitset_index(cfgidx);\n+        let start = n * self.words_per_id;\n         let end = start + self.words_per_id;\n \n         assert!(start < self.gens.len());\n@@ -234,26 +327,28 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n                                     -> bool {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.nodeid_to_bitset.contains_key(&id) {\n+        if !self.has_bitset(id) {\n             return true;\n         }\n-        let (start, end) = self.compute_id_range_frozen(id);\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let on_entry = self.on_entry.slice(start, end);\n-        debug!(\"each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n-               id, bits_to_str(on_entry));\n+        debug!(\"{:s} each_bit_on_entry_frozen(id={:?}, on_entry={})\",\n+               self.analysis_name, id, bits_to_str(on_entry));\n         self.each_bit(on_entry, f)\n     }\n \n     pub fn each_gen_bit_frozen(&self, id: ast::NodeId, f: |uint| -> bool)\n                                -> bool {\n         //! Iterates through each bit in the gen set for `id`.\n-        if !self.nodeid_to_bitset.contains_key(&id) {\n+        if !self.has_bitset(id) {\n             return true;\n         }\n-        let (start, end) = self.compute_id_range_frozen(id);\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range_frozen(cfgidx);\n         let gens = self.gens.slice(start, end);\n-        debug!(\"each_gen_bit(id={:?}, gens={})\",\n-               id, bits_to_str(gens));\n+        debug!(\"{:s} each_gen_bit(id={:?}, gens={})\",\n+               self.analysis_name, id, bits_to_str(gens));\n         self.each_bit(gens, f)\n     }\n \n@@ -287,11 +382,63 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n         }\n         return true;\n     }\n+\n+    pub fn add_kills_from_flow_exits(&mut self, cfg: &cfg::CFG) {\n+        //! Whenever you have a `break` or `continue` statement, flow\n+        //! exits through any number of enclosing scopes on its way to\n+        //! the new destination. This function infers the kill bits of\n+        //! those control operators based on the kill bits associated\n+        //! with those scopes.\n+        //!\n+        //! This is usually called (if it is called at all), after\n+        //! all add_gen and add_kill calls, but before propagate.\n+\n+        debug!(\"{:s} add_kills_from_flow_exits\", self.analysis_name);\n+        if self.bits_per_id == 0 {\n+            // Skip the surprisingly common degenerate case.  (Note\n+            // compute_id_range requires self.words_per_id > 0.)\n+            return;\n+        }\n+        cfg.graph.each_edge(|_edge_index, edge| {\n+            let flow_exit = edge.source();\n+            let (start, end) = self.compute_id_range(flow_exit);\n+            let mut orig_kills = self.kills.slice(start, end).to_owned();\n+\n+            let mut changed = false;\n+            for &node_id in edge.data.exiting_scopes.iter() {\n+                let opt_cfg_idx = self.nodeid_to_index.find(&node_id).map(|&i|i);\n+                match opt_cfg_idx {\n+                    Some(cfg_idx) => {\n+                        let (start, end) = self.compute_id_range(cfg_idx);\n+                        let kills = self.kills.slice(start, end);\n+                        if bitwise(orig_kills.as_mut_slice(), kills, &Union) {\n+                            changed = true;\n+                        }\n+                    }\n+                    None => {\n+                        debug!(\"{:s} add_kills_from_flow_exits flow_exit={} \\\n+                                no cfg_idx for exiting_scope={:?}\",\n+                               self.analysis_name, flow_exit, node_id);\n+                    }\n+                }\n+            }\n+\n+            if changed {\n+                let bits = self.kills.mut_slice(start, end);\n+                debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n+                       self.analysis_name, flow_exit, mut_bits_to_str(bits));\n+                bits.copy_from(orig_kills.as_slice());\n+                debug!(\"{:s} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n+                       self.analysis_name, flow_exit, mut_bits_to_str(bits));\n+            }\n+            true\n+        });\n+    }\n }\n \n impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n //                          ^^^^^^^^^^^^^ only needed for pretty printing\n-    pub fn propagate(&mut self, blk: &ast::Block) {\n+    pub fn propagate(&mut self, cfg: &cfg::CFG, blk: &ast::Block) {\n         //! Performs the data flow analysis.\n \n         if self.bits_per_id == 0 {\n@@ -307,16 +454,14 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n             };\n \n             let mut temp = Vec::from_elem(words_per_id, 0u);\n-            let mut loop_scopes = Vec::new();\n-\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(temp.as_mut_slice());\n-                propcx.walk_block(blk, temp.as_mut_slice(), &mut loop_scopes);\n+                propcx.walk_cfg(cfg, temp.as_mut_slice());\n             }\n         }\n \n-        debug!(\"Dataflow result:\");\n+        debug!(\"Dataflow result for {:s}:\", self.analysis_name);\n         debug!(\"{}\", {\n             self.pretty_print_to(box io::stderr(), blk).unwrap();\n             \"\"\n@@ -334,499 +479,64 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n }\n \n impl<'a, 'b, O:DataFlowOperator> PropagationContext<'a, 'b, O> {\n-    fn tcx(&self) -> &'b ty::ctxt {\n-        self.dfcx.tcx\n-    }\n-\n-    fn walk_block(&mut self,\n-                  blk: &ast::Block,\n-                  in_out: &mut [uint],\n-                  loop_scopes: &mut Vec<LoopScope> ) {\n-        debug!(\"DataFlowContext::walk_block(blk.id={}, in_out={})\",\n-               blk.id, bits_to_str(in_out));\n-\n-        self.merge_with_entry_set(blk.id, in_out);\n-\n-        for stmt in blk.stmts.iter() {\n-            self.walk_stmt(stmt.clone(), in_out, loop_scopes);\n-        }\n-\n-        self.walk_opt_expr(blk.expr, in_out, loop_scopes);\n-\n-        self.dfcx.apply_gen_kill(blk.id, in_out);\n-    }\n-\n-    fn walk_stmt(&mut self,\n-                 stmt: Gc<ast::Stmt>,\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        match stmt.node {\n-            ast::StmtDecl(ref decl, _) => {\n-                self.walk_decl(decl.clone(), in_out, loop_scopes);\n-            }\n-\n-            ast::StmtExpr(ref expr, _) | ast::StmtSemi(ref expr, _) => {\n-                self.walk_expr(&**expr, in_out, loop_scopes);\n-            }\n-\n-            ast::StmtMac(..) => {\n-                self.tcx().sess.span_bug(stmt.span, \"unexpanded macro\");\n-            }\n-        }\n-    }\n-\n-    fn walk_decl(&mut self,\n-                 decl: Gc<ast::Decl>,\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        match decl.node {\n-            ast::DeclLocal(ref local) => {\n-                self.walk_opt_expr(local.init, in_out, loop_scopes);\n-                self.walk_pat(local.pat, in_out, loop_scopes);\n-            }\n-\n-            ast::DeclItem(_) => {}\n-        }\n-    }\n-\n-    fn walk_expr(&mut self,\n-                 expr: &ast::Expr,\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n-               expr.repr(self.dfcx.tcx), bits_to_str(in_out));\n-\n-        self.merge_with_entry_set(expr.id, in_out);\n-\n-        match expr.node {\n-            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-            }\n-\n-            ast::ExprIf(cond, then, els) => {\n-                //\n-                //     (cond)\n-                //       |\n-                //       v\n-                //      ( )\n-                //     /   \\\n-                //    |     |\n-                //    v     v\n-                //  (then)(els)\n-                //    |     |\n-                //    v     v\n-                //   (  succ  )\n-                //\n-                self.walk_expr(&*cond, in_out, loop_scopes);\n-\n-                let mut then_bits = in_out.to_owned();\n-                self.walk_block(&*then, then_bits.as_mut_slice(), loop_scopes);\n-\n-                self.walk_opt_expr(els, in_out, loop_scopes);\n-                join_bits(&self.dfcx.oper, then_bits.as_slice(), in_out);\n-            }\n-\n-            ast::ExprWhile(cond, blk) => {\n-                //\n-                //     (expr) <--+\n-                //       |       |\n-                //       v       |\n-                //  +--(cond)    |\n-                //  |    |       |\n-                //  |    v       |\n-                //  v  (blk) ----+\n-                //       |\n-                //    <--+ (break)\n-                //\n-\n-                self.walk_expr(&*cond, in_out, loop_scopes);\n-\n-                let mut body_bits = in_out.to_owned();\n-                loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    break_bits: Vec::from_slice(in_out)\n-                });\n-                self.walk_block(&*blk, body_bits.as_mut_slice(), loop_scopes);\n-                self.add_to_entry_set(expr.id, body_bits.as_slice());\n-                let new_loop_scope = loop_scopes.pop().unwrap();\n-                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n-            }\n-\n-            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n-\n-            ast::ExprLoop(ref blk, _) => {\n-                //\n-                //     (expr) <--+\n-                //       |       |\n-                //       v       |\n-                //     (blk) ----+\n-                //       |\n-                //    <--+ (break)\n-                //\n-\n-                let mut body_bits = in_out.to_owned();\n-                self.reset(in_out);\n-                loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n-                    break_bits: Vec::from_slice(in_out)\n-                });\n-                self.walk_block(&**blk, body_bits.as_mut_slice(), loop_scopes);\n-                self.add_to_entry_set(expr.id, body_bits.as_slice());\n-\n-                let new_loop_scope = loop_scopes.pop().unwrap();\n-                assert_eq!(new_loop_scope.loop_id, expr.id);\n-                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n-            }\n-\n-            ast::ExprMatch(ref discr, ref arms) => {\n-                //\n-                //    (discr)\n-                //     / | \\\n-                //    |  |  |\n-                //    v  v  v\n-                //   (..arms..)\n-                //    |  |  |\n-                //    v  v  v\n-                //   (  succ  )\n-                //\n-                //\n-                self.walk_expr(&**discr, in_out, loop_scopes);\n-\n-                let mut guards = in_out.to_owned();\n-\n-                // We know that exactly one arm will be taken, so we\n-                // can start out with a blank slate and just union\n-                // together the bits from each arm:\n-                self.reset(in_out);\n-\n-                for arm in arms.iter() {\n-                    // in_out reflects the discr and all guards to date\n-                    self.walk_opt_expr(arm.guard, guards.as_mut_slice(),\n-                                       loop_scopes);\n-\n-                    // determine the bits for the body and then union\n-                    // them into `in_out`, which reflects all bodies to date\n-                    let mut body = guards.to_owned();\n-                    self.walk_pat_alternatives(arm.pats.as_slice(),\n-                                               body.as_mut_slice(),\n-                                               loop_scopes);\n-                    self.walk_expr(&*arm.body, body.as_mut_slice(), loop_scopes);\n-                    join_bits(&self.dfcx.oper, body.as_slice(), in_out);\n-                }\n-            }\n-\n-            ast::ExprRet(o_e) => {\n-                self.walk_opt_expr(o_e, in_out, loop_scopes);\n-                self.reset(in_out);\n-            }\n-\n-            ast::ExprBreak(label) => {\n-                let scope = self.find_scope(expr, label, loop_scopes);\n-                self.break_from_to(expr, scope, in_out);\n-                self.reset(in_out);\n-            }\n-\n-            ast::ExprAgain(label) => {\n-                let scope = self.find_scope(expr, label, loop_scopes);\n-                self.pop_scopes(expr, scope, in_out);\n-                self.add_to_entry_set(scope.loop_id, in_out);\n-                self.reset(in_out);\n-            }\n-\n-            ast::ExprAssign(ref l, ref r) |\n-            ast::ExprAssignOp(_, ref l, ref r) => {\n-                self.walk_expr(&**r, in_out, loop_scopes);\n-                self.walk_expr(&**l, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprVec(ref exprs) => {\n-                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes)\n-            }\n-\n-            ast::ExprRepeat(ref l, ref r) => {\n-                self.walk_expr(&**l, in_out, loop_scopes);\n-                self.walk_expr(&**r, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprStruct(_, ref fields, with_expr) => {\n-                for field in fields.iter() {\n-                    self.walk_expr(&*field.expr, in_out, loop_scopes);\n-                }\n-                self.walk_opt_expr(with_expr, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprCall(ref f, ref args) => {\n-                self.walk_expr(&**f, in_out, loop_scopes);\n-                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n-            }\n-\n-            ast::ExprMethodCall(_, _, ref args) => {\n-                self.walk_call(expr.id, args.as_slice(), in_out, loop_scopes);\n-            }\n-\n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) if self.is_method_call(expr) => {\n-                self.walk_call(expr.id, [l, r], in_out, loop_scopes);\n-            }\n-\n-            ast::ExprUnary(_, e) if self.is_method_call(expr) => {\n-                self.walk_call(expr.id, [e], in_out, loop_scopes);\n-            }\n-\n-            ast::ExprTup(ref exprs) => {\n-                self.walk_exprs(exprs.as_slice(), in_out, loop_scopes);\n-            }\n-\n-            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n-                self.walk_expr(&**l, in_out, loop_scopes);\n-                let temp = in_out.to_owned();\n-                self.walk_expr(&**r, in_out, loop_scopes);\n-                join_bits(&self.dfcx.oper, temp.as_slice(), in_out);\n-            }\n-\n-            ast::ExprIndex(l, r) |\n-            ast::ExprBinary(_, l, r) => {\n-                self.walk_exprs([l, r], in_out, loop_scopes);\n-            }\n-\n-            ast::ExprLit(..) |\n-            ast::ExprPath(..) => {}\n-\n-            ast::ExprAddrOf(_, ref e) |\n-            ast::ExprCast(ref e, _) |\n-            ast::ExprUnary(_, ref e) |\n-            ast::ExprParen(ref e) |\n-            ast::ExprVstore(ref e, _) |\n-            ast::ExprField(ref e, _, _) => {\n-                self.walk_expr(&**e, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprBox(ref s, ref e) => {\n-                self.walk_expr(&**s, in_out, loop_scopes);\n-                self.walk_expr(&**e, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprInlineAsm(ref inline_asm) => {\n-                for &(_, ref expr) in inline_asm.inputs.iter() {\n-                    self.walk_expr(&**expr, in_out, loop_scopes);\n-                }\n-                for &(_, ref expr) in inline_asm.outputs.iter() {\n-                    self.walk_expr(&**expr, in_out, loop_scopes);\n-                }\n-            }\n-\n-            ast::ExprBlock(ref blk) => {\n-                self.walk_block(&**blk, in_out, loop_scopes);\n-            }\n-\n-            ast::ExprMac(..) => {\n-                self.tcx().sess.span_bug(expr.span, \"unexpanded macro\");\n-            }\n-        }\n-\n-        self.dfcx.apply_gen_kill(expr.id, in_out);\n-    }\n-\n-    fn pop_scopes(&mut self,\n-                  from_expr: &ast::Expr,\n-                  to_scope: &mut LoopScope,\n-                  in_out: &mut [uint]) {\n-        //! Whenever you have a `break` or a `loop` statement, flow\n-        //! exits through any number of enclosing scopes on its\n-        //! way to the new destination. This function applies the kill\n-        //! sets of those enclosing scopes to `in_out` (those kill sets\n-        //! concern items that are going out of scope).\n-\n-        let tcx = self.tcx();\n-\n-        debug!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n-               from_expr.repr(tcx), to_scope.loop_id,\n-               bits_to_str(in_out));\n-\n-        let mut id = from_expr.id;\n-        while id != to_scope.loop_id {\n-            self.dfcx.apply_kill(id, in_out);\n-\n-            match tcx.region_maps.opt_encl_scope(id) {\n-                Some(i) => { id = i; }\n-                None => {\n-                    tcx.sess.span_bug(\n-                        from_expr.span,\n-                        format!(\"pop_scopes(from_expr={}, to_scope={:?}) \\\n-                                 to_scope does not enclose from_expr\",\n-                                from_expr.repr(tcx),\n-                                to_scope.loop_id).as_slice());\n-                }\n-            }\n-        }\n-    }\n-\n-    fn break_from_to(&mut self,\n-                     from_expr: &ast::Expr,\n-                     to_scope: &mut LoopScope,\n-                     in_out: &mut [uint]) {\n-        self.pop_scopes(from_expr, to_scope, in_out);\n-        self.dfcx.apply_kill(from_expr.id, in_out);\n-        join_bits(&self.dfcx.oper,\n-                  in_out,\n-                  to_scope.break_bits.as_mut_slice());\n-        debug!(\"break_from_to(from_expr={}, to_scope={}) final break_bits={}\",\n-               from_expr.repr(self.tcx()),\n-               to_scope.loop_id,\n-               bits_to_str(in_out));\n-    }\n-\n-    fn walk_exprs(&mut self,\n-                  exprs: &[Gc<ast::Expr>],\n-                  in_out: &mut [uint],\n-                  loop_scopes: &mut Vec<LoopScope> ) {\n-        for expr in exprs.iter() {\n-            self.walk_expr(&**expr, in_out, loop_scopes);\n-        }\n-    }\n-\n-    fn walk_opt_expr(&mut self,\n-                     opt_expr: Option<Gc<ast::Expr>>,\n-                     in_out: &mut [uint],\n-                     loop_scopes: &mut Vec<LoopScope> ) {\n-        for expr in opt_expr.iter() {\n-            self.walk_expr(&**expr, in_out, loop_scopes);\n-        }\n-    }\n-\n-    fn walk_call(&mut self,\n-                 call_id: ast::NodeId,\n-                 args: &[Gc<ast::Expr>],\n-                 in_out: &mut [uint],\n-                 loop_scopes: &mut Vec<LoopScope> ) {\n-        self.walk_exprs(args, in_out, loop_scopes);\n-\n-        // FIXME(#6268) nested method calls\n-        // self.merge_with_entry_set(in_out);\n-        // self.dfcx.apply_gen_kill(in_out);\n-\n-        let return_ty = ty::node_id_to_type(self.tcx(), call_id);\n-        let fails = ty::type_is_bot(return_ty);\n-        if fails {\n-            self.reset(in_out);\n-        }\n-    }\n-\n-    fn walk_pat(&mut self,\n-                pat: Gc<ast::Pat>,\n-                in_out: &mut [uint],\n-                _loop_scopes: &mut Vec<LoopScope> ) {\n-        debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n-               pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n-\n-        ast_util::walk_pat(&*pat, |p| {\n-            debug!(\"  p.id={} in_out={}\", p.id, bits_to_str(in_out));\n-            self.merge_with_entry_set(p.id, in_out);\n-            self.dfcx.apply_gen_kill(p.id, in_out);\n-            true\n+    fn walk_cfg(&mut self,\n+                cfg: &cfg::CFG,\n+                in_out: &mut [uint]) {\n+        debug!(\"DataFlowContext::walk_cfg(in_out={}) {:s}\",\n+               bits_to_str(in_out), self.dfcx.analysis_name);\n+        cfg.graph.each_node(|node_index, node| {\n+            debug!(\"DataFlowContext::walk_cfg idx={} id={} begin in_out={}\",\n+                   node_index, node.data.id, bits_to_str(in_out));\n+\n+            let (start, end) = self.dfcx.compute_id_range(node_index);\n+\n+            // Initialize local bitvector with state on-entry.\n+            in_out.copy_from(self.dfcx.on_entry.slice(start, end));\n+\n+            // Compute state on-exit by applying transfer function to\n+            // state on-entry.\n+            self.dfcx.apply_gen_kill(node_index, in_out);\n+\n+            // Propagate state on-exit from node into its successors.\n+            self.propagate_bits_into_graph_successors_of(in_out, cfg, node_index);\n+            true // continue to next node\n         });\n     }\n \n-    fn walk_pat_alternatives(&mut self,\n-                             pats: &[Gc<ast::Pat>],\n-                             in_out: &mut [uint],\n-                             loop_scopes: &mut Vec<LoopScope> ) {\n-        if pats.len() == 1 {\n-            // Common special case:\n-            return self.walk_pat(pats[0], in_out, loop_scopes);\n-        }\n-\n-        // In the general case, the patterns in `pats` are\n-        // alternatives, so we must treat this like an N-way select\n-        // statement.\n-        let initial_state = in_out.to_owned();\n-        for &pat in pats.iter() {\n-            let mut temp = initial_state.clone();\n-            self.walk_pat(pat, temp.as_mut_slice(), loop_scopes);\n-            join_bits(&self.dfcx.oper, temp.as_slice(), in_out);\n-        }\n-    }\n-\n-    fn find_scope<'a,'b>(\n-                  &self,\n-                  expr: &ast::Expr,\n-                  label: Option<ast::Ident>,\n-                  loop_scopes: &'a mut Vec<LoopScope<'b>>)\n-                  -> &'a mut LoopScope<'b> {\n-        let index = match label {\n-            None => {\n-                let len = loop_scopes.len();\n-                len - 1\n-            }\n-\n-            Some(_) => {\n-                match self.tcx().def_map.borrow().find(&expr.id) {\n-                    Some(&def::DefLabel(loop_id)) => {\n-                        match loop_scopes.iter().position(|l| l.loop_id == loop_id) {\n-                            Some(i) => i,\n-                            None => {\n-                                self.tcx().sess.span_bug(\n-                                    expr.span,\n-                                    format!(\"no loop scope for id {:?}\",\n-                                            loop_id).as_slice());\n-                            }\n-                        }\n-                    }\n-\n-                    r => {\n-                        self.tcx().sess.span_bug(\n-                            expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r).as_slice());\n-                    }\n-                }\n-            }\n-        };\n-\n-        loop_scopes.get_mut(index)\n-    }\n-\n-    fn is_method_call(&self, expr: &ast::Expr) -> bool {\n-        let method_call = typeck::MethodCall::expr(expr.id);\n-        self.dfcx.tcx.method_map.borrow().contains_key(&method_call)\n-    }\n-\n     fn reset(&mut self, bits: &mut [uint]) {\n         let e = if self.dfcx.oper.initial_value() {uint::MAX} else {0};\n         for b in bits.mut_iter() {\n             *b = e;\n         }\n     }\n \n-    fn add_to_entry_set(&mut self, id: ast::NodeId, pred_bits: &[uint]) {\n-        debug!(\"add_to_entry_set(id={:?}, pred_bits={})\",\n-               id, bits_to_str(pred_bits));\n-        let (start, end) = self.dfcx.compute_id_range(id);\n-        let changed = { // FIXME(#5074) awkward construction\n-            let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n-            join_bits(&self.dfcx.oper, pred_bits, on_entry)\n-        };\n-        if changed {\n-            debug!(\"changed entry set for {:?} to {}\",\n-                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n-            self.changed = true;\n-        }\n+    fn propagate_bits_into_graph_successors_of(&mut self,\n+                                               pred_bits: &[uint],\n+                                               cfg: &cfg::CFG,\n+                                               cfgidx: CFGIndex) {\n+        cfg.graph.each_outgoing_edge(cfgidx, |_e_idx, edge| {\n+            self.propagate_bits_into_entry_set_for(pred_bits, edge);\n+            true\n+        });\n     }\n \n-    fn merge_with_entry_set(&mut self,\n-                            id: ast::NodeId,\n-                            pred_bits: &mut [uint]) {\n-        debug!(\"merge_with_entry_set(id={:?}, pred_bits={})\",\n-               id, mut_bits_to_str(pred_bits));\n-        let (start, end) = self.dfcx.compute_id_range(id);\n-        let changed = { // FIXME(#5074) awkward construction\n+    fn propagate_bits_into_entry_set_for(&mut self,\n+                                         pred_bits: &[uint],\n+                                         edge: &cfg::CFGEdge) {\n+        let source = edge.source();\n+        let cfgidx = edge.target();\n+        debug!(\"{:s} propagate_bits_into_entry_set_for(pred_bits={}, {} to {})\",\n+               self.dfcx.analysis_name, bits_to_str(pred_bits), source, cfgidx);\n+        let (start, end) = self.dfcx.compute_id_range(cfgidx);\n+        let changed = {\n+            // (scoping mutable borrow of self.dfcx.on_entry)\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n-            let changed = join_bits(&self.dfcx.oper, pred_bits, on_entry);\n-            copy_bits(on_entry, pred_bits);\n-            changed\n+            bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n-            debug!(\"changed entry set for {:?} to {}\",\n-                   id, bits_to_str(self.dfcx.on_entry.slice(start, end)));\n+            debug!(\"{:s} changed entry set for {:?} to {}\",\n+                   self.dfcx.analysis_name, cfgidx,\n+                   bits_to_str(self.dfcx.on_entry.slice(start, end)));\n             self.changed = true;\n         }\n     }\n@@ -855,24 +565,15 @@ fn bits_to_str(words: &[uint]) -> String {\n     return result\n }\n \n-fn copy_bits(in_vec: &[uint], out_vec: &mut [uint]) -> bool {\n-    bitwise(out_vec, in_vec, |_, b| b)\n-}\n-\n-fn join_bits<O:DataFlowOperator>(oper: &O,\n-                                 in_vec: &[uint],\n-                                 out_vec: &mut [uint]) -> bool {\n-    bitwise(out_vec, in_vec, |a, b| oper.join(a, b))\n-}\n-\n #[inline]\n-fn bitwise(out_vec: &mut [uint], in_vec: &[uint], op: |uint, uint| -> uint)\n-           -> bool {\n+fn bitwise<Op:BitwiseOperator>(out_vec: &mut [uint],\n+                               in_vec: &[uint],\n+                               op: &Op) -> bool {\n     assert_eq!(out_vec.len(), in_vec.len());\n     let mut changed = false;\n     for (out_elt, in_elt) in out_vec.mut_iter().zip(in_vec.iter()) {\n         let old_val = *out_elt;\n-        let new_val = op(old_val, *in_elt);\n+        let new_val = op.join(old_val, *in_elt);\n         *out_elt = new_val;\n         changed |= old_val != new_val;\n     }\n@@ -897,3 +598,12 @@ fn bit_str(bit: uint) -> String {\n     let lobits = 1 << (bit & 0xFF);\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n+\n+struct Union;\n+impl BitwiseOperator for Union {\n+    fn join(&self, a: uint, b: uint) -> uint { a | b }\n+}\n+struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    fn join(&self, a: uint, b: uint) -> uint { a & !b }\n+}"}, {"sha": "ad058ab6b5f1d1afdf2a703619c2803c97c6be24", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -186,24 +186,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n \n         let cmt = return_if_err!(self.mc.cat_expr(expr));\n         self.delegate_consume(expr.id, expr.span, cmt);\n-\n-        match expr.node {\n-            ast::ExprParen(ref subexpr) => {\n-                // Argh but is ExprParen horrible. So, if we consume\n-                // `(x)`, that generally is also consuming `x`, UNLESS\n-                // there are adjustments on the `(x)` expression\n-                // (e.g., autoderefs and autorefs).\n-                if self.typer.adjustments().borrow().contains_key(&expr.id) {\n-                    self.walk_expr(expr);\n-                } else {\n-                    self.consume_expr(&**subexpr);\n-                }\n-            }\n-\n-            _ => {\n-                self.walk_expr(expr)\n-            }\n-        }\n+        self.walk_expr(expr);\n     }\n \n     fn mutate_expr(&mut self,"}, {"sha": "b1f9b0bff9fd280310337dbb60df83a213b9c17f", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -55,7 +55,7 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n-#[deriving(PartialEq)]\n+#[deriving(Clone, PartialEq, Show)]\n pub struct NodeIndex(pub uint);\n pub static InvalidNodeIndex: NodeIndex = NodeIndex(uint::MAX);\n "}, {"sha": "03c9c56c787016ba758f4f8176d0fc70c5acf7e4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -97,6 +97,7 @@ pub enum categorization {\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub onceness: ast::Onceness,\n+    pub capturing_proc: ast::NodeId,\n }\n \n // different kinds of pointers:\n@@ -559,7 +560,9 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n                                   upvar_id: var_id,\n-                                  onceness: closure_ty.onceness}),\n+                                  onceness: closure_ty.onceness,\n+                                  capturing_proc: fn_node_id,\n+                              }),\n                               mutbl:McImmutable,\n                               ty:expr_ty\n                           }))"}, {"sha": "393ec8b0b1b3ba9d80e8a7a44e6a2e03dbbf9a60", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -12,7 +12,7 @@ fn a() {\n     let mut v = vec!(1, 2, 3);\n     let vb: &mut [int] = v.as_mut_slice();\n     match vb {\n-        [_a, ..tail] => { //~ ERROR cannot use `vb[..]` because it was mutably borrowed\n+        [_a, ..tail] => {\n             v.push(tail[0] + tail[1]); //~ ERROR cannot borrow\n         }\n         _ => {}"}, {"sha": "09440949177dd5f48d905181a663e541d7242653", "filename": "src/test/run-make/graphviz-flowgraph/Makefile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2FMakefile?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -2,7 +2,8 @@\n \n FILES=f00.rs f01.rs f02.rs f03.rs f04.rs f05.rs f06.rs f07.rs \\\n       f08.rs f09.rs f10.rs f11.rs f12.rs f13.rs f14.rs f15.rs \\\n-      f16.rs f17.rs f18.rs f19.rs f20.rs f21.rs f22.rs\n+      f16.rs f17.rs f18.rs f19.rs f20.rs f21.rs f22.rs f23.rs \\\n+      f24.rs f25.rs\n \n \n # all: $(patsubst %.rs,$(TMPDIR)/%.dot,$(FILES)) $(patsubst %.rs,$(TMPDIR)/%.pp,$(FILES))"}, {"sha": "876957a0689d6ad50a75846086bf908cd521ba60", "filename": "src/test/run-make/graphviz-flowgraph/f23.dot-expected.dot", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.dot-expected.dot?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,93 @@\n+digraph block {\n+    N0[label=\"entry\"];\n+    N1[label=\"exit\"];\n+    N2[label=\"expr 23\"];\n+    N3[label=\"local mut x\"];\n+    N4[label=\"expr 23\"];\n+    N5[label=\"local mut y\"];\n+    N6[label=\"expr 23\"];\n+    N7[label=\"local mut z\"];\n+    N8[label=\"(dummy_node)\"];\n+    N9[label=\"expr x\"];\n+    N10[label=\"expr 0\"];\n+    N11[label=\"expr x > 0\"];\n+    N12[label=\"expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N13[label=\"expr 1\"];\n+    N14[label=\"expr x\"];\n+    N15[label=\"expr x -= 1\"];\n+    N16[label=\"(dummy_node)\"];\n+    N17[label=\"expr y\"];\n+    N18[label=\"expr 0\"];\n+    N19[label=\"expr y > 0\"];\n+    N20[label=\"expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N21[label=\"expr 1\"];\n+    N22[label=\"expr y\"];\n+    N23[label=\"expr y -= 1\"];\n+    N24[label=\"(dummy_node)\"];\n+    N25[label=\"expr z\"];\n+    N26[label=\"expr 0\"];\n+    N27[label=\"expr z > 0\"];\n+    N28[label=\"expr while z > 0 { z -= 1; }\"];\n+    N29[label=\"expr 1\"];\n+    N30[label=\"expr z\"];\n+    N31[label=\"expr z -= 1\"];\n+    N32[label=\"block { z -= 1; }\"];\n+    N33[label=\"expr x\"];\n+    N34[label=\"expr 10\"];\n+    N35[label=\"expr x > 10\"];\n+    N36[label=\"expr return\"];\n+    N37[label=\"(dummy_node)\"];\n+    N38[label=\"expr \\\"unreachable\\\"\"];\n+    N39[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N40[label=\"expr if x > 10 { return; \\\"unreachable\\\"; }\"];\n+    N41[label=\"block { y -= 1; while z > 0 { z -= 1; } if x > 10 { return; \\\"unreachable\\\"; } }\"];\n+    N42[label=\"block {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N43[label=\"block {\\l    let mut x = 23;\\l    let mut y = 23;\\l    let mut z = 23;\\l    while x > 0 {\\l        x -= 1;\\l        while y > 0 {\\l            y -= 1;\\l            while z > 0 { z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N0 -> N2;\n+    N2 -> N3;\n+    N3 -> N4;\n+    N4 -> N5;\n+    N5 -> N6;\n+    N6 -> N7;\n+    N7 -> N8;\n+    N8 -> N9;\n+    N9 -> N10;\n+    N10 -> N11;\n+    N11 -> N12;\n+    N11 -> N13;\n+    N13 -> N14;\n+    N14 -> N15;\n+    N15 -> N16;\n+    N16 -> N17;\n+    N17 -> N18;\n+    N18 -> N19;\n+    N19 -> N20;\n+    N19 -> N21;\n+    N21 -> N22;\n+    N22 -> N23;\n+    N23 -> N24;\n+    N24 -> N25;\n+    N25 -> N26;\n+    N26 -> N27;\n+    N27 -> N28;\n+    N27 -> N29;\n+    N29 -> N30;\n+    N30 -> N31;\n+    N31 -> N32;\n+    N32 -> N24;\n+    N28 -> N33;\n+    N33 -> N34;\n+    N34 -> N35;\n+    N35 -> N36;\n+    N36 -> N1[label=\"exiting scope_0 expr while y > 0 {\\l    y -= 1;\\l    while z > 0 { z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr while x > 0 {\\l    x -= 1;\\l    while y > 0 {\\l        y -= 1;\\l        while z > 0 { z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N37 -> N38;\n+    N38 -> N39;\n+    N35 -> N40;\n+    N39 -> N40;\n+    N40 -> N41;\n+    N41 -> N16;\n+    N20 -> N42;\n+    N42 -> N8;\n+    N12 -> N43;\n+    N43 -> N1;\n+}"}, {"sha": "52341a3fbd4080fde2487a85d1bc52f25ccb3f19", "filename": "src/test/run-make/graphviz-flowgraph/f23.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff23.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unreachable_code)]\n+pub fn expr_while_23() {\n+    let mut x = 23;\n+    let mut y = 23;\n+    let mut z = 23;\n+\n+    while x > 0 {\n+        x -= 1;\n+\n+        while y > 0 {\n+            y -= 1;\n+\n+            while z > 0 { z -= 1; }\n+\n+            if x > 10 {\n+                return;\n+                \"unreachable\";\n+            }\n+        }\n+    }\n+}"}, {"sha": "2558998be6e1fbff9db0d41762c2556b0511402d", "filename": "src/test/run-make/graphviz-flowgraph/f24.dot-expected.dot", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.dot-expected.dot?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,123 @@\n+digraph block {\n+    N0[label=\"entry\"];\n+    N1[label=\"exit\"];\n+    N2[label=\"expr 24\"];\n+    N3[label=\"local mut x\"];\n+    N4[label=\"expr 24\"];\n+    N5[label=\"local mut y\"];\n+    N6[label=\"expr 24\"];\n+    N7[label=\"local mut z\"];\n+    N8[label=\"(dummy_node)\"];\n+    N9[label=\"expr loop  {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N10[label=\"expr x\"];\n+    N11[label=\"expr 0\"];\n+    N12[label=\"expr x == 0\"];\n+    N13[label=\"expr break\"];\n+    N14[label=\"(dummy_node)\"];\n+    N15[label=\"expr \\\"unreachable\\\"\"];\n+    N16[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N17[label=\"expr if x == 0 { break ; \\\"unreachable\\\"; }\"];\n+    N18[label=\"expr 1\"];\n+    N19[label=\"expr x\"];\n+    N20[label=\"expr x -= 1\"];\n+    N21[label=\"(dummy_node)\"];\n+    N22[label=\"expr loop  {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N23[label=\"expr y\"];\n+    N24[label=\"expr 0\"];\n+    N25[label=\"expr y == 0\"];\n+    N26[label=\"expr break\"];\n+    N27[label=\"(dummy_node)\"];\n+    N28[label=\"expr \\\"unreachable\\\"\"];\n+    N29[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N30[label=\"expr if y == 0 { break ; \\\"unreachable\\\"; }\"];\n+    N31[label=\"expr 1\"];\n+    N32[label=\"expr y\"];\n+    N33[label=\"expr y -= 1\"];\n+    N34[label=\"(dummy_node)\"];\n+    N35[label=\"expr loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n+    N36[label=\"expr z\"];\n+    N37[label=\"expr 0\"];\n+    N38[label=\"expr z == 0\"];\n+    N39[label=\"expr break\"];\n+    N40[label=\"(dummy_node)\"];\n+    N41[label=\"expr \\\"unreachable\\\"\"];\n+    N42[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N43[label=\"expr if z == 0 { break ; \\\"unreachable\\\"; }\"];\n+    N44[label=\"expr 1\"];\n+    N45[label=\"expr z\"];\n+    N46[label=\"expr z -= 1\"];\n+    N47[label=\"block { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n+    N48[label=\"expr x\"];\n+    N49[label=\"expr 10\"];\n+    N50[label=\"expr x > 10\"];\n+    N51[label=\"expr return\"];\n+    N52[label=\"(dummy_node)\"];\n+    N53[label=\"expr \\\"unreachable\\\"\"];\n+    N54[label=\"block { return; \\\"unreachable\\\"; }\"];\n+    N55[label=\"expr if x > 10 { return; \\\"unreachable\\\"; }\"];\n+    N56[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N57[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N58[label=\"block {\\l    let mut x = 24;\\l    let mut y = 24;\\l    let mut z = 24;\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { return; \\\"unreachable\\\"; }\\l        }\\l    }\\l}\\l\"];\n+    N0 -> N2;\n+    N2 -> N3;\n+    N3 -> N4;\n+    N4 -> N5;\n+    N5 -> N6;\n+    N6 -> N7;\n+    N7 -> N8;\n+    N8 -> N10;\n+    N10 -> N11;\n+    N11 -> N12;\n+    N12 -> N13;\n+    N13 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N14 -> N15;\n+    N15 -> N16;\n+    N12 -> N17;\n+    N16 -> N17;\n+    N17 -> N18;\n+    N18 -> N19;\n+    N19 -> N20;\n+    N20 -> N21;\n+    N21 -> N23;\n+    N23 -> N24;\n+    N24 -> N25;\n+    N25 -> N26;\n+    N26 -> N22[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N27 -> N28;\n+    N28 -> N29;\n+    N25 -> N30;\n+    N29 -> N30;\n+    N30 -> N31;\n+    N31 -> N32;\n+    N32 -> N33;\n+    N33 -> N34;\n+    N34 -> N36;\n+    N36 -> N37;\n+    N37 -> N38;\n+    N38 -> N39;\n+    N39 -> N35[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n+    N40 -> N41;\n+    N41 -> N42;\n+    N38 -> N43;\n+    N42 -> N43;\n+    N43 -> N44;\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N47;\n+    N47 -> N34;\n+    N35 -> N48;\n+    N48 -> N49;\n+    N49 -> N50;\n+    N50 -> N51;\n+    N51 -> N1[label=\"exiting scope_0 expr loop  {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { return; \\\"unreachable\\\"; }\\l}\\l,\\lexiting scope_1 expr loop  {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { return; \\\"unreachable\\\"; }\\l    }\\l}\\l\"];\n+    N52 -> N53;\n+    N53 -> N54;\n+    N50 -> N55;\n+    N54 -> N55;\n+    N55 -> N56;\n+    N56 -> N21;\n+    N22 -> N57;\n+    N57 -> N8;\n+    N9 -> N58;\n+    N58 -> N1;\n+}"}, {"sha": "f796d660a185634d3cb033241752fefe39eb6e3c", "filename": "src/test/run-make/graphviz-flowgraph/f24.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff24.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unreachable_code)]\n+pub fn expr_while_24() {\n+    let mut x = 24;\n+    let mut y = 24;\n+    let mut z = 24;\n+\n+    loop {\n+        if x == 0 { break; \"unreachable\"; }\n+        x -= 1;\n+\n+        loop {\n+            if y == 0 { break; \"unreachable\"; }\n+            y -= 1;\n+\n+            loop {\n+                if z == 0 { break; \"unreachable\"; }\n+                z -= 1;\n+            }\n+\n+            if x > 10 {\n+                return;\n+                \"unreachable\";\n+            }\n+        }\n+    }\n+}"}, {"sha": "c393b63546c70eff0fcbc6db0d93a333ae240cfd", "filename": "src/test/run-make/graphviz-flowgraph/f25.dot-expected.dot", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.dot-expected.dot?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,123 @@\n+digraph block {\n+    N0[label=\"entry\"];\n+    N1[label=\"exit\"];\n+    N2[label=\"expr 25\"];\n+    N3[label=\"local mut x\"];\n+    N4[label=\"expr 25\"];\n+    N5[label=\"local mut y\"];\n+    N6[label=\"expr 25\"];\n+    N7[label=\"local mut z\"];\n+    N8[label=\"(dummy_node)\"];\n+    N9[label=\"expr \\'a:\\l    loop  {\\l        if x == 0 { break ; \\\"unreachable\\\"; }\\l        x -= 1;\\l        \\'a:\\l            loop  {\\l                if y == 0 { break ; \\\"unreachable\\\"; }\\l                y -= 1;\\l                \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l            }\\l    }\\l\"];\n+    N10[label=\"expr x\"];\n+    N11[label=\"expr 0\"];\n+    N12[label=\"expr x == 0\"];\n+    N13[label=\"expr break\"];\n+    N14[label=\"(dummy_node)\"];\n+    N15[label=\"expr \\\"unreachable\\\"\"];\n+    N16[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N17[label=\"expr if x == 0 { break ; \\\"unreachable\\\"; }\"];\n+    N18[label=\"expr 1\"];\n+    N19[label=\"expr x\"];\n+    N20[label=\"expr x -= 1\"];\n+    N21[label=\"(dummy_node)\"];\n+    N22[label=\"expr \\'a:\\l    loop  {\\l        if y == 0 { break ; \\\"unreachable\\\"; }\\l        y -= 1;\\l        \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l        if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l    }\\l\"];\n+    N23[label=\"expr y\"];\n+    N24[label=\"expr 0\"];\n+    N25[label=\"expr y == 0\"];\n+    N26[label=\"expr break\"];\n+    N27[label=\"(dummy_node)\"];\n+    N28[label=\"expr \\\"unreachable\\\"\"];\n+    N29[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N30[label=\"expr if y == 0 { break ; \\\"unreachable\\\"; }\"];\n+    N31[label=\"expr 1\"];\n+    N32[label=\"expr y\"];\n+    N33[label=\"expr y -= 1\"];\n+    N34[label=\"(dummy_node)\"];\n+    N35[label=\"expr \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n+    N36[label=\"expr z\"];\n+    N37[label=\"expr 0\"];\n+    N38[label=\"expr z == 0\"];\n+    N39[label=\"expr break\"];\n+    N40[label=\"(dummy_node)\"];\n+    N41[label=\"expr \\\"unreachable\\\"\"];\n+    N42[label=\"block { break ; \\\"unreachable\\\"; }\"];\n+    N43[label=\"expr if z == 0 { break ; \\\"unreachable\\\"; }\"];\n+    N44[label=\"expr 1\"];\n+    N45[label=\"expr z\"];\n+    N46[label=\"expr z -= 1\"];\n+    N47[label=\"block { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n+    N48[label=\"expr x\"];\n+    N49[label=\"expr 10\"];\n+    N50[label=\"expr x > 10\"];\n+    N51[label=\"expr continue \\'a\"];\n+    N52[label=\"(dummy_node)\"];\n+    N53[label=\"expr \\\"unreachable\\\"\"];\n+    N54[label=\"block { continue \\'a ; \\\"unreachable\\\"; }\"];\n+    N55[label=\"expr if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\"];\n+    N56[label=\"block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N57[label=\"block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    \\'a:\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n+    N58[label=\"block {\\l    let mut x = 25;\\l    let mut y = 25;\\l    let mut z = 25;\\l    \\'a:\\l        loop  {\\l            if x == 0 { break ; \\\"unreachable\\\"; }\\l            x -= 1;\\l            \\'a:\\l                loop  {\\l                    if y == 0 { break ; \\\"unreachable\\\"; }\\l                    y -= 1;\\l                    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l                    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l                }\\l        }\\l}\\l\"];\n+    N0 -> N2;\n+    N2 -> N3;\n+    N3 -> N4;\n+    N4 -> N5;\n+    N5 -> N6;\n+    N6 -> N7;\n+    N7 -> N8;\n+    N8 -> N10;\n+    N10 -> N11;\n+    N11 -> N12;\n+    N12 -> N13;\n+    N13 -> N9[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if x == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if x == 0 { break ; \\\"unreachable\\\"; }\\l    x -= 1;\\l    \\'a:\\l        loop  {\\l            if y == 0 { break ; \\\"unreachable\\\"; }\\l            y -= 1;\\l            \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l            if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l        }\\l}\\l\"];\n+    N14 -> N15;\n+    N15 -> N16;\n+    N12 -> N17;\n+    N16 -> N17;\n+    N17 -> N18;\n+    N18 -> N19;\n+    N19 -> N20;\n+    N20 -> N21;\n+    N21 -> N23;\n+    N23 -> N24;\n+    N24 -> N25;\n+    N25 -> N26;\n+    N26 -> N22[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if y == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if y == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N27 -> N28;\n+    N28 -> N29;\n+    N25 -> N30;\n+    N29 -> N30;\n+    N30 -> N31;\n+    N31 -> N32;\n+    N32 -> N33;\n+    N33 -> N34;\n+    N34 -> N36;\n+    N36 -> N37;\n+    N37 -> N38;\n+    N38 -> N39;\n+    N39 -> N35[label=\"exiting scope_0 expr break,\\lexiting scope_1 stmt break ;,\\lexiting scope_2 block { break ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if z == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_4 stmt if z == 0 { break ; \\\"unreachable\\\"; },\\lexiting scope_5 block { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\"];\n+    N40 -> N41;\n+    N41 -> N42;\n+    N38 -> N43;\n+    N42 -> N43;\n+    N43 -> N44;\n+    N44 -> N45;\n+    N45 -> N46;\n+    N46 -> N47;\n+    N47 -> N34;\n+    N35 -> N48;\n+    N48 -> N49;\n+    N49 -> N50;\n+    N50 -> N51;\n+    N51 -> N21[label=\"exiting scope_0 expr continue \\'a,\\lexiting scope_1 stmt continue \\'a ;,\\lexiting scope_2 block { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_3 expr if x > 10 { continue \\'a ; \\\"unreachable\\\"; },\\lexiting scope_4 block {\\l    if y == 0 { break ; \\\"unreachable\\\"; }\\l    y -= 1;\\l    \\'a: loop  { if z == 0 { break ; \\\"unreachable\\\"; } z -= 1; }\\l    if x > 10 { continue \\'a ; \\\"unreachable\\\"; }\\l}\\l\"];\n+    N52 -> N53;\n+    N53 -> N54;\n+    N50 -> N55;\n+    N54 -> N55;\n+    N55 -> N56;\n+    N56 -> N21;\n+    N22 -> N57;\n+    N57 -> N8;\n+    N9 -> N58;\n+    N58 -> N1;\n+}"}, {"sha": "2ee2e48fd10e0d2a451644cc6575623f574184e2", "filename": "src/test/run-make/graphviz-flowgraph/f25.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fgraphviz-flowgraph%2Ff25.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(unreachable_code)]\n+pub fn expr_while_25() {\n+    let mut x = 25;\n+    let mut y = 25;\n+    let mut z = 25;\n+\n+    'a: loop {\n+        if x == 0 { break; \"unreachable\"; }\n+        x -= 1;\n+\n+        'a: loop {\n+            if y == 0 { break; \"unreachable\"; }\n+            y -= 1;\n+\n+            'a: loop {\n+                if z == 0 { break; \"unreachable\"; }\n+                z -= 1;\n+            }\n+\n+            if x > 10 {\n+                continue 'a;\n+                \"unreachable\";\n+            }\n+        }\n+    }\n+}"}, {"sha": "8b77500225022172302169bca8cca70f0f2bb8da", "filename": "src/test/run-pass/loop-no-reinit-needed-post-bot.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-pass%2Floop-no-reinit-needed-post-bot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-pass%2Floop-no-reinit-needed-post-bot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Floop-no-reinit-needed-post-bot.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+// Ensure S is moved, not copied, on assignment.\n+impl Drop for S { fn drop(&mut self) { } }\n+\n+// user-defined function \"returning\" bottom (i.e. no return at all).\n+fn my_fail() -> ! { loop {} }\n+\n+pub fn step(f: bool) {\n+    let mut g = S;\n+    let mut i = 0;\n+    loop\n+    {\n+        if i > 10 { break; } else { i += 1; }\n+\n+        let _g = g;\n+\n+        if f {\n+            // re-initialize g, but only before restarting loop.\n+            g = S;\n+            continue;\n+        }\n+\n+        my_fail();\n+\n+        // we never get here, so we do not need to re-initialize g.\n+    }\n+}\n+\n+pub fn main() {\n+    step(true);\n+}"}, {"sha": "7e02d10208182a9b0338f68fd10b952263924bae", "filename": "src/test/run-pass/struct-partial-move-1.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-pass%2Fstruct-partial-move-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-pass%2Fstruct-partial-move-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-partial-move-1.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(PartialEq, Show)]\n+struct Partial<T> { x: T, y: T }\n+\n+#[deriving(PartialEq, Show)]\n+struct S { val: int }\n+impl S { fn new(v: int) -> S { S { val: v } } }\n+impl Drop for S { fn drop(&mut self) { } }\n+\n+pub fn f<T>((b1, b2): (T, T), f: |T| -> T) -> Partial<T> {\n+    let p = Partial { x: b1, y: b2 };\n+\n+    // Move of `p` is legal even though we are also moving `p.y`; the\n+    // `..p` moves all fields *except* `p.y` in this context.\n+    Partial { y: f(p.y), ..p }\n+}\n+\n+pub fn main() {\n+    let p = f((S::new(3), S::new(4)), |S { val: z }| S::new(z+1));\n+    assert_eq!(p, Partial { x: S::new(3), y: S::new(5) });\n+}"}, {"sha": "fe5e1eaaa1af578fdd31f44c52fc1a44da0737d7", "filename": "src/test/run-pass/struct-partial-move-2.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-pass%2Fstruct-partial-move-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4416b32768030bf6b5419242db3712c7c36e258c/src%2Ftest%2Frun-pass%2Fstruct-partial-move-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-partial-move-2.rs?ref=4416b32768030bf6b5419242db3712c7c36e258c", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(PartialEq, Show)]\n+struct Partial<T> { x: T, y: T }\n+\n+#[deriving(PartialEq, Show)]\n+struct S { val: int }\n+impl S { fn new(v: int) -> S { S { val: v } } }\n+impl Drop for S { fn drop(&mut self) { } }\n+\n+type Two<T> = (Partial<T>, Partial<T>);\n+\n+pub fn f<T>((b1, b2): (T, T), (b3, b4): (T, T), f: |T| -> T) -> Two<T> {\n+    let p = Partial { x: b1, y: b2 };\n+    let q = Partial { x: b3, y: b4 };\n+\n+     // Move of `q` is legal even though we have already moved `q.y`;\n+     // the `..q` moves all fields *except* `q.y` in this context.\n+     // Likewise, the move of `p.x` is legal for similar reasons.\n+    (Partial { x: f(q.y), ..p }, Partial { y: f(p.x), ..q })\n+}\n+\n+pub fn main() {\n+    let two = f((S::new(1), S::new(3)),\n+                (S::new(5), S::new(7)),\n+                |S { val: z }| S::new(z+1));\n+    assert_eq!(two, (Partial { x: S::new(8), y: S::new(3) },\n+                     Partial { x: S::new(5), y: S::new(2) }));\n+}"}]}