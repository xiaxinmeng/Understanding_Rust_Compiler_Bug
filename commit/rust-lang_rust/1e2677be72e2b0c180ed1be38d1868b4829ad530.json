{"sha": "1e2677be72e2b0c180ed1be38d1868b4829ad530", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMjY3N2JlNzJlMmIwYzE4MGVkMWJlMzhkMTg2OGI0ODI5YWQ1MzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-07-16T13:46:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-07-24T08:53:17Z"}, "message": "Introduce ClosureSubsts rather than just having random fields in the\nTyClosure variant; thread this through wherever closure substitutions\nare expected, which leads to a net simplification. Simplify trans\ntreatment of closures in particular.", "tree": {"sha": "ae6ac9a40674b97e5caf0fdad53a66ac9c39d959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae6ac9a40674b97e5caf0fdad53a66ac9c39d959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e2677be72e2b0c180ed1be38d1868b4829ad530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e2677be72e2b0c180ed1be38d1868b4829ad530", "html_url": "https://github.com/rust-lang/rust/commit/1e2677be72e2b0c180ed1be38d1868b4829ad530", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e2677be72e2b0c180ed1be38d1868b4829ad530/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69d62e04e524d4b202b7fdce791e1418a4adbb38", "url": "https://api.github.com/repos/rust-lang/rust/commits/69d62e04e524d4b202b7fdce791e1418a4adbb38", "html_url": "https://github.com/rust-lang/rust/commit/69d62e04e524d4b202b7fdce791e1418a4adbb38"}], "stats": {"total": 415, "additions": 256, "deletions": 159}, "files": [{"sha": "c77e96f1648882da676ae3c8b966b9ed1d856be2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -143,10 +143,10 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::TyClosure(def, substs, ref tys) => {\n+        ty::TyClosure(def, ref substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_substs(w, cx, substs);\n-            for ty in tys {\n+            enc_substs(w, cx, &substs.func_substs);\n+            for ty in &substs.upvar_tys {\n                 enc_ty(w, cx, ty);\n             }\n             mywrite!(w, \".\");"}, {"sha": "de7582a13716620ec4e9bd6baf141d1a473d1fdf", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -76,7 +76,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n                 Err(msg) => tcx.sess.fatal(&msg),\n             }\n         }\n-        ty::TyClosure(def_id, _, _) => {\n+        ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::TyTuple(ref tys) => {"}, {"sha": "8fba98bead479bfb59d9e18976a103f0115e8102", "filename": "src/librustc/middle/implicator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fimplicator.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -28,7 +28,7 @@ use util::nodemap::FnvHashSet;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n-    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx Substs<'tcx>),\n+    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx ty::ClosureSubsts<'tcx>),\n     Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n@@ -96,7 +96,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::TyClosure(def_id, substs, _) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // TODO remove RegionSubClosure\n                 let &(r_a, opt_ty) = self.stack.last().unwrap();\n                 self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));"}, {"sha": "e6cea4d1b6ac088ff1919125aebfa5e4701009c3", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -1374,17 +1374,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn closure_type(&self,\n-                    def_id: ast::DefId,\n-                    substs: &subst::Substs<'tcx>)\n-                    -> ty::ClosureTy<'tcx>\n+                        def_id: ast::DefId,\n+                        substs: &ty::ClosureSubsts<'tcx>)\n+                        -> ty::ClosureTy<'tcx>\n     {\n-\n         let closure_ty = self.tables\n                              .borrow()\n                              .closure_tys\n                              .get(&def_id)\n                              .unwrap()\n-                             .subst(self.tcx, substs);\n+                             .subst(self.tcx, &substs.func_substs);\n \n         if self.normalize {\n             normalize_associated_type(&self.tcx, &closure_ty)\n@@ -1395,7 +1394,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn closure_upvars(&self,\n                           def_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n+                          substs: &ty::ClosureSubsts<'tcx>)\n                           -> Option<Vec<ty::ClosureUpvar<'tcx>>>\n     {\n         let result = ty::ctxt::closure_upvars(self, def_id, substs);"}, {"sha": "7db740798bd406f989be18c519cbfca939a638f3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -1493,7 +1493,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = self.ir.tcx.node_id_to_type(id);\n         match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs, _) =>\n+            ty::TyClosure(closure_def_id, ref substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ => fn_ty.fn_ret()\n         }"}, {"sha": "bf47396bb9f656afdba931e1e18e178c52099744", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -584,7 +584,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           def::DefUpvar(var_id, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n-                  ty::TyClosure(closure_id, _, _) => {\n+                  ty::TyClosure(closure_id, _) => {\n                       match self.typer.closure_kind(closure_id) {\n                           Some(kind) => {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)"}, {"sha": "376430e87c6f005b10ee6615a33df7ef044c7a08", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -270,8 +270,7 @@ pub struct VtableImplData<'tcx, N> {\n #[derive(Clone, PartialEq, Eq)]\n pub struct VtableClosureData<'tcx, N> {\n     pub closure_def_id: ast::DefId,\n-    pub substs: subst::Substs<'tcx>,\n-    pub upvar_tys: Vec<Ty<'tcx>>,\n+    pub substs: ty::ClosureSubsts<'tcx>,\n     /// Nested obligations. This can be non-empty if the closure\n     /// signature contains associated types.\n     pub nested: Vec<N>\n@@ -550,7 +549,6 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,\n                 nested: c.nested.into_iter().map(f).collect(),\n-                upvar_tys: c.upvar_tys,\n             })\n         }\n     }"}, {"sha": "ef3a217ecdbf28d494d691def3fe700300a7ab9a", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -154,7 +154,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::TyClosure(closure_def_id, substs, _) => {\n+        ty::TyClosure(closure_def_id, ref substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) ="}, {"sha": "c2c2ceb0b033de851134e455e6c56d7c4826897e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -201,7 +201,7 @@ enum SelectionCandidate<'tcx> {\n \n     /// Implementation of a `Fn`-family trait by one of the\n     /// anonymous types generated for a `||` expression.\n-    ClosureCandidate(/* closure */ ast::DefId, &'tcx Substs<'tcx>, &'tcx Vec<Ty<'tcx>>),\n+    ClosureCandidate(/* closure */ ast::DefId, &'tcx ty::ClosureSubsts<'tcx>),\n \n     /// Implementation of a `Fn`-family trait by one of the anonymous\n     /// types generated for a fn pointer type (e.g., `fn(int)->int`)\n@@ -348,7 +348,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // lifetimes can appear inside the self-type.\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::TyClosure(id, ref substs, _) => (id, substs.clone()),\n+            ty::TyClosure(id, ref substs) => (id, substs),\n             _ => { return; }\n         };\n         assert!(!substs.has_escaping_regions());\n@@ -1142,8 +1142,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // touch bound regions, they just capture the in-scope\n         // type/region parameters\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n-        let (closure_def_id, substs, upvar_tys) = match self_ty.sty {\n-            ty::TyClosure(id, substs, ref upvar_tys) => (id, substs, upvar_tys),\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::TyClosure(id, ref substs) => (id, substs),\n             ty::TyInfer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n@@ -1161,7 +1161,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             Some(closure_kind) => {\n                 debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n                 if closure_kind.extends(kind) {\n-                    candidates.vec.push(ClosureCandidate(closure_def_id, substs, upvar_tys));\n+                    candidates.vec.push(ClosureCandidate(closure_def_id, substs));\n                 }\n             }\n             None => {\n@@ -1703,7 +1703,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::TyTuple(ref tys) => ok_if(tys.clone()),\n \n-            ty::TyClosure(def_id, substs, _) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1865,7 +1865,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Some(tys.clone())\n             }\n \n-            ty::TyClosure(def_id, substs, _) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n                 // TODO\n@@ -2015,10 +2015,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableImpl(vtable_impl))\n             }\n \n-            ClosureCandidate(closure_def_id, substs, upvar_tys) => {\n+            ClosureCandidate(closure_def_id, substs) => {\n                 let vtable_closure =\n-                    try!(self.confirm_closure_candidate(obligation, closure_def_id,\n-                                                        &substs, upvar_tys));\n+                    try!(self.confirm_closure_candidate(obligation, closure_def_id, substs));\n                 Ok(VtableClosure(vtable_closure))\n             }\n \n@@ -2367,8 +2366,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_closure_candidate(&mut self,\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: ast::DefId,\n-                                 substs: &Substs<'tcx>,\n-                                 upvar_tys: &'tcx Vec<Ty<'tcx>>)\n+                                 substs: &ty::ClosureSubsts<'tcx>)\n                                  -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n                                            SelectionError<'tcx>>\n     {\n@@ -2394,7 +2392,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(VtableClosureData {\n             closure_def_id: closure_def_id,\n             substs: substs.clone(),\n-            upvar_tys: upvar_tys.clone(),\n             nested: obligations\n         })\n     }\n@@ -2856,7 +2853,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref_unnormalized(&mut self,\n                                       obligation: &TraitObligation<'tcx>,\n                                       closure_def_id: ast::DefId,\n-                                      substs: &Substs<'tcx>)\n+                                      substs: &ty::ClosureSubsts<'tcx>)\n                                       -> ty::PolyTraitRef<'tcx>\n     {\n         let closure_type = self.infcx.closure_type(closure_def_id, substs);\n@@ -2878,7 +2875,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn closure_trait_ref(&mut self,\n                          obligation: &TraitObligation<'tcx>,\n                          closure_def_id: ast::DefId,\n-                         substs: &Substs<'tcx>)\n+                         substs: &ty::ClosureSubsts<'tcx>)\n                          -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n     {\n         let trait_ref = self.closure_trait_ref_unnormalized("}, {"sha": "5528472d793134498c837ff53a96c8b246f50b41", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 128, "deletions": 14, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -1767,7 +1767,7 @@ pub enum TypeVariants<'tcx> {\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n-    TyClosure(DefId, &'tcx Substs<'tcx>, Vec<Ty<'tcx>>),\n+    TyClosure(DefId, Box<ClosureSubsts<'tcx>>),\n \n     /// A tuple type.  For example, `(i32, bool)`.\n     TyTuple(Vec<Ty<'tcx>>),\n@@ -1787,6 +1787,93 @@ pub enum TypeVariants<'tcx> {\n     TyError,\n }\n \n+/// A closure can be modeled as a struct that looks like:\n+///\n+///     struct Closure<'l0...'li, T0...Tj, U0...Uk> {\n+///         upvar0: U0,\n+///         ...\n+///         upvark: Uk\n+///     }\n+///\n+/// where 'l0...'li and T0...Tj are the lifetime and type parameters\n+/// in scope on the function that defined the closure, and U0...Uk are\n+/// type parameters representing the types of its upvars (borrowed, if\n+/// appropriate).\n+///\n+/// So, for example, given this function:\n+///\n+///     fn foo<'a, T>(data: &'a mut T) {\n+///          do(|| data.count += 1)\n+///     }\n+///\n+/// the type of the closure would be something like:\n+///\n+///     struct Closure<'a, T, U0> {\n+///         data: U0\n+///     }\n+///\n+/// Note that the type of the upvar is not specified in the struct.\n+/// You may wonder how the impl would then be able to use the upvar,\n+/// if it doesn't know it's type? The answer is that the impl is\n+/// (conceptually) not fully generic over Closure but rather tied to\n+/// instances with the expected upvar types:\n+///\n+///     impl<'b, 'a, T> FnMut() for Closure<'a, T, &'b mut &'a mut T> {\n+///         ...\n+///     }\n+///\n+/// You can see that the *impl* fully specified the type of the upvar\n+/// and thus knows full well that `data` has type `&'b mut &'a mut T`.\n+/// (Here, I am assuming that `data` is mut-borrowed.)\n+///\n+/// Now, the last question you may ask is: Why include the upvar types\n+/// as extra type parameters? The reason for this design is that the\n+/// upvar types can reference lifetimes that are internal to the\n+/// creating function. In my example above, for example, the lifetime\n+/// `'b` represents the extent of the closure itself; this is some\n+/// subset of `foo`, probably just the extent of the call to the to\n+/// `do()`. If we just had the lifetime/type parameters from the\n+/// enclosing function, we couldn't name this lifetime `'b`. Note that\n+/// there can also be lifetimes in the types of the upvars themselves,\n+/// if one of them happens to be a reference to something that the\n+/// creating fn owns.\n+///\n+/// OK, you say, so why not create a more minimal set of parameters\n+/// that just includes the extra lifetime parameters? The answer is\n+/// primarily that it would be hard --- we don't know at the time when\n+/// we create the closure type what the full types of the upvars are,\n+/// nor do we know which are borrowed and which are not. In this\n+/// design, we can just supply a fresh type parameter and figure that\n+/// out later.\n+///\n+/// All right, you say, but why include the type parameters from the\n+/// original function then? The answer is that trans may need them\n+/// when monomorphizing, and they may not appear in the upvars.  A\n+/// closure could capture no variables but still make use of some\n+/// in-scope type parameter with a bound (e.g., if our example above\n+/// had an extra `U: Default`, and the closure called `U::default()`).\n+///\n+/// There is another reason. This design (implicitly) prohibits\n+/// closures from capturing themselves (except via a trait\n+/// object). This simplifies closure inference considerably, since it\n+/// means that when we infer the kind of a closure or its upvars, we\n+/// don't have to handles cycles where the decisions we make wind up\n+/// for closure C wind up influencing the decisions we ought to make\n+/// for closure C (which would then require fixed point iteration to\n+/// handle). Plus it fixes an ICE. :P\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ClosureSubsts<'tcx> {\n+    /// Lifetime and type parameters from the enclosing function.\n+    /// These are separated out because trans wants to pass them around\n+    /// when monomorphizing.\n+    pub func_substs: &'tcx Substs<'tcx>,\n+\n+    /// The types of the upvars. The list parallels the freevars and\n+    /// `upvar_borrows` lists. These are kept distinct so that we can\n+    /// easily index into them.\n+    pub upvar_tys: Vec<Ty<'tcx>>\n+}\n+\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitTy<'tcx> {\n     pub principal: ty::PolyTraitRef<'tcx>,\n@@ -3214,11 +3301,11 @@ impl FlagComputation {\n                 }\n             }\n \n-            &TyClosure(_, substs, ref tys) => {\n+            &TyClosure(_, ref substs) => {\n                 self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n                 self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n-                self.add_substs(substs);\n-                self.add_tys(tys);\n+                self.add_substs(&substs.func_substs);\n+                self.add_tys(&substs.upvar_tys);\n             }\n \n             &TyInfer(_) => {\n@@ -3462,10 +3549,10 @@ impl<'tcx> ctxt<'tcx> {\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n-                        substs: &subst::Substs<'tcx>)\n+                        substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, substs)\n+        self.tables.borrow().closure_tys.get(&def_id).unwrap().subst(self, &substs.func_substs)\n     }\n \n     pub fn type_parameter_def(&self,\n@@ -3665,7 +3752,17 @@ impl<'tcx> ctxt<'tcx> {\n                       substs: &'tcx Substs<'tcx>,\n                       tys: Vec<Ty<'tcx>>)\n                       -> Ty<'tcx> {\n-        self.mk_ty(TyClosure(closure_id, substs, tys))\n+        self.mk_closure_from_closure_substs(closure_id, Box::new(ClosureSubsts {\n+            func_substs: substs,\n+            upvar_tys: tys\n+        }))\n+    }\n+\n+    pub fn mk_closure_from_closure_substs(&self,\n+                                          closure_id: ast::DefId,\n+                                          closure_substs: Box<ClosureSubsts<'tcx>>)\n+                                          -> Ty<'tcx> {\n+        self.mk_ty(TyClosure(closure_id, closure_substs))\n     }\n \n     pub fn mk_var(&self, v: TyVid) -> Ty<'tcx> {\n@@ -3932,7 +4029,7 @@ impl<'tcx> TyS<'tcx> {\n             TyTrait(ref tt) => Some(tt.principal_def_id()),\n             TyStruct(id, _) |\n             TyEnum(id, _) |\n-            TyClosure(id, _, _) => Some(id),\n+            TyClosure(id, _) => Some(id),\n             _ => None\n         }\n     }\n@@ -4150,7 +4247,8 @@ impl<'tcx> TyS<'tcx> {\n                     apply_lang_items(cx, did, res)\n                 }\n \n-                TyClosure(did, substs, _) => {\n+                TyClosure(did, ref substs) => {\n+                    // TODO\n                     let param_env = cx.empty_parameter_environment();\n                     let infcx = infer::new_infer_ctxt(cx, &cx.tables, Some(param_env), false);\n                     let upvars = infcx.closure_upvars(did, substs).unwrap();\n@@ -5911,9 +6009,9 @@ impl<'tcx> ctxt<'tcx> {\n \n     // Returns a list of `ClosureUpvar`s for each upvar.\n     pub fn closure_upvars<'a>(typer: &infer::InferCtxt<'a, 'tcx>,\n-                          closure_id: ast::DefId,\n-                          substs: &Substs<'tcx>)\n-                          -> Option<Vec<ClosureUpvar<'tcx>>>\n+                              closure_id: ast::DefId,\n+                              substs: &ClosureSubsts<'tcx>)\n+                              -> Option<Vec<ClosureUpvar<'tcx>>>\n     {\n         // Presently an unboxed closure type cannot \"escape\" out of a\n         // function, so we will only encounter ones that originated in the\n@@ -5932,7 +6030,7 @@ impl<'tcx> ctxt<'tcx> {\n                                 Ok(t) => { t }\n                                 Err(()) => { return None; }\n                             };\n-                            let freevar_ty = freevar_ty.subst(tcx, substs);\n+                            let freevar_ty = freevar_ty.subst(tcx, &substs.func_substs);\n \n                             let upvar_id = ty::UpvarId {\n                                 var_id: freevar_def_id.node,\n@@ -6382,7 +6480,7 @@ impl<'tcx> ctxt<'tcx> {\n                     }\n                     TyInfer(_) => unreachable!(),\n                     TyError => byte!(21),\n-                    TyClosure(d, _, _) => {\n+                    TyClosure(d, _) => {\n                         byte!(22);\n                         did(state, d);\n                     }\n@@ -6763,6 +6861,13 @@ impl<'tcx> RegionEscape for Substs<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for ClosureSubsts<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.func_substs.has_regions_escaping_depth(depth) ||\n+            self.upvar_tys.iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n impl<T:RegionEscape> RegionEscape for Vec<T> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.iter().any(|t| t.has_regions_escaping_depth(depth))\n@@ -7106,6 +7211,15 @@ impl<'tcx> HasTypeFlags for BareFnTy<'tcx> {\n     }\n }\n \n+impl<'tcx> HasTypeFlags for ClosureSubsts<'tcx> {\n+    fn has_type_flags(&self, flags: TypeFlags) -> bool {\n+        self.func_substs.has_type_flags(flags) ||\n+            self.upvar_tys.iter().any(|t| t.has_type_flags(flags))\n+    }\n+}\n+\n+\n+\n impl<'tcx> fmt::Debug for ClosureTy<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ClosureTy({},{:?},{})\","}, {"sha": "b6bb82ad7b15b2f5bd16ddea6e4ab490ca04efe0", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -296,6 +296,16 @@ impl<'tcx> TypeFoldable<'tcx> for subst::Substs<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ClosureSubsts<'tcx> {\n+        let func_substs = self.func_substs.fold_with(folder);\n+        ty::ClosureSubsts {\n+            func_substs: folder.tcx().mk_substs(func_substs),\n+            upvar_tys: self.upvar_tys.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::ItemSubsts<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::ItemSubsts<'tcx> {\n         ty::ItemSubsts {\n@@ -450,7 +460,6 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureDa\n             closure_def_id: self.closure_def_id,\n             substs: self.substs.fold_with(folder),\n             nested: self.nested.fold_with(folder),\n-            upvar_tys: self.upvar_tys.fold_with(folder),\n         }\n     }\n }\n@@ -603,10 +612,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::TyStruct(did, this.tcx().mk_substs(substs))\n         }\n-        ty::TyClosure(did, ref substs, ref tys) => {\n+        ty::TyClosure(did, ref substs) => {\n             let s = substs.fold_with(this);\n-            let tys = tys.fold_with(this);\n-            ty::TyClosure(did, this.tcx().mk_substs(s), tys)\n+            ty::TyClosure(did, s)\n         }\n         ty::TyProjection(ref data) => {\n             ty::TyProjection(data.fold_with(this))"}, {"sha": "f8678b4d8e3bd1b47cd6481758474bc37400eb87", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -506,16 +506,15 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n             Ok(tcx.mk_struct(a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::TyClosure(a_id, a_substs, ref a_tys),\n-         &ty::TyClosure(b_id, b_substs, ref b_tys))\n+        (&ty::TyClosure(a_id, ref a_substs),\n+         &ty::TyClosure(b_id, ref b_substs))\n             if a_id == b_id =>\n         {\n             // All TyClosure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n-            let tys = try!(relation.relate_zip(a_tys, b_tys));\n-            Ok(tcx.mk_closure(a_id, tcx.mk_substs(substs), tys))\n+            let substs = try!(relation.relate(a_substs, b_substs));\n+            Ok(tcx.mk_closure_from_closure_substs(a_id, substs))\n         }\n \n         (&ty::TyBox(a_inner), &ty::TyBox(b_inner)) =>\n@@ -588,6 +587,20 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n     }\n }\n \n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ClosureSubsts<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ClosureSubsts<'tcx>,\n+                 b: &ty::ClosureSubsts<'tcx>)\n+                 -> RelateResult<'tcx, ty::ClosureSubsts<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let func_substs = try!(relate_substs(relation, None, a.func_substs, b.func_substs));\n+        let upvar_tys = try!(relation.relate_zip(&a.upvar_tys, &b.upvar_tys));\n+        Ok(ty::ClosureSubsts { func_substs: relation.tcx().mk_substs(func_substs),\n+                               upvar_tys: upvar_tys })\n+    }\n+}\n+\n impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n     fn relate<R>(relation: &mut R,\n                  a: &ty::Region,"}, {"sha": "81cad4486904b7e6e7ee946bbd2a2ebc53ca540a", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -91,9 +91,9 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         ty::TyStruct(_, ref substs) => {\n             push_reversed(stack, substs.types.as_slice());\n         }\n-        ty::TyClosure(_, ref substs, ref tys) => {\n-            push_reversed(stack, substs.types.as_slice());\n-            push_reversed(stack, tys);\n+        ty::TyClosure(_, ref substs) => {\n+            push_reversed(stack, substs.func_substs.types.as_slice());\n+            push_reversed(stack, &substs.upvar_tys);\n         }\n         ty::TyTuple(ref ts) => {\n             push_reversed(stack, ts);"}, {"sha": "d24fa5cef0349bae1d035e6d3e37311912372f29", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -662,11 +662,14 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n             TyStr => write!(f, \"str\"),\n-            TyClosure(ref did, substs, _) => ty::tls::with(|tcx| {\n+            TyClosure(ref did, ref substs) => ty::tls::with(|tcx| {\n                 try!(write!(f, \"[closure\"));\n+\n+                // TODO consider changing this to print out the upvar types instead\n+\n                 let closure_tys = &tcx.tables.borrow().closure_tys;\n                 try!(closure_tys.get(did).map(|cty| &cty.sig).and_then(|sig| {\n-                    tcx.lift(&substs).map(|substs| sig.subst(tcx, substs))\n+                    tcx.lift(&substs.func_substs).map(|substs| sig.subst(tcx, substs))\n                 }).map(|sig| {\n                     fn_sig(f, &sig.0.inputs, false, sig.0.output)\n                 }).unwrap_or_else(|| {"}, {"sha": "6289d50588104bbffa0baf63dd9379b38862e535", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -2529,7 +2529,7 @@ impl LintPass for DropWithReprExtern {\n             match dtor_self_type.sty {\n                 ty::TyEnum(self_type_did, _) |\n                 ty::TyStruct(self_type_did, _) |\n-                ty::TyClosure(self_type_did, _, _) => {\n+                ty::TyClosure(self_type_did, _) => {\n                     let hints = ctx.tcx.lookup_repr_hints(self_type_did);\n                     if hints.iter().any(|attr| *attr == attr::ReprExtern) &&\n                         ctx.tcx.ty_dtor(self_type_did).has_drop_flag() {"}, {"sha": "b51a3d4b2a081c52a927346a61157e8ce12dc725", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -221,7 +221,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor_to_init_u8(dtor))\n         }\n-        ty::TyClosure(def_id, substs, _) => {\n+        ty::TyClosure(def_id, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n             let upvars = infcx.closure_upvars(def_id, substs).unwrap(); // TODO\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n@@ -441,7 +441,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Perhaps one of the upvars of this struct is non-zero\n         // Let's recurse and find out!\n-        ty::TyClosure(def_id, substs, _) => {\n+        ty::TyClosure(def_id, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(tcx, &tcx.tables);\n             let upvars = infcx.closure_upvars(def_id, substs).unwrap(); // TODO\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();"}, {"sha": "62b03c9fb0f1fcaa858b6ed464efe9628220e4df", "filename": "src/librustc_trans/trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fattributes.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -145,7 +145,7 @@ pub fn from_fn_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_type: ty::Ty<'tcx\n     let function_type;\n     let (fn_sig, abi, env_ty) = match fn_type.sty {\n         ty::TyBareFn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::TyClosure(closure_did, substs, _) => {\n+        ty::TyClosure(closure_did, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);"}, {"sha": "e18fc6c5da2beec5e218f769ef9b62e895ee49e3", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -470,7 +470,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::TyClosure(def_id, substs, _) => { // TODO\n+      ty::TyClosure(def_id, ref substs) => { // TODO\n           let repr = adt::represent_type(cx.ccx(), t);\n           let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n           let upvars = infcx.closure_upvars(def_id, substs).unwrap();"}, {"sha": "0f75c1f8ab65a6d0befe9ec2f3b25a57db63db43", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -32,7 +32,6 @@ use trans::build::*;\n use trans::callee;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n-use trans::closure;\n use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n                     ExprOrMethodCall, FunctionContext, MethodCallKey};\n use trans::consts;\n@@ -446,12 +445,6 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         }\n     };\n \n-    // If this is a closure, redirect to it.\n-    match closure::get_or_create_declaration_if_closure(ccx, def_id, substs) {\n-        None => {}\n-        Some(llfn) => return llfn,\n-    }\n-\n     // Check whether this fn has an inlined copy and, if so, redirect\n     // def_id to the local id of the inlined copy.\n     let def_id = inline::maybe_instantiate_inline(ccx, def_id);"}, {"sha": "b05bc7e5855e8009f9d8a05c7d8d6cb8d54dfbe5", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 31, "deletions": 61, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -12,7 +12,6 @@ use arena::TypedArena;\n use back::link::{self, mangle_internal_name_by_path_and_seq};\n use llvm::{ValueRef, get_params};\n use middle::infer;\n-use middle::ty::Ty;\n use trans::adt;\n use trans::attributes;\n use trans::base::*;\n@@ -24,10 +23,9 @@ use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n use trans::debuginfo::{self, DebugLoc};\n use trans::declare;\n use trans::expr;\n-use trans::monomorphize::{self, MonoId};\n+use trans::monomorphize::{MonoId};\n use trans::type_of::*;\n use middle::ty;\n-use middle::subst::Substs;\n use session::config::FullDebugInfo;\n \n use syntax::abi::RustCall;\n@@ -127,47 +125,32 @@ impl<'a> ClosureEnv<'a> {\n \n /// Returns the LLVM function declaration for a closure, creating it if\n /// necessary. If the ID does not correspond to a closure ID, returns None.\n-pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                      closure_id: ast::DefId,\n-                                                      substs: &Substs<'tcx>)\n-                                                      -> Option<Datum<'tcx, Rvalue>> {\n-    if !ccx.tcx().tables.borrow().closure_kinds.contains_key(&closure_id) {\n-        // Not a closure.\n-        return None\n-    }\n-\n-    let function_type = ccx.tcx().node_id_to_type(closure_id.node);\n-    let function_type = monomorphize::apply_param_substs(ccx.tcx(), substs, &function_type);\n-\n+pub fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                                   closure_id: ast::DefId,\n+                                                   substs: &ty::ClosureSubsts<'tcx>)\n+                                                   -> ValueRef {\n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = erase_regions(ccx.tcx(), &function_type);\n-    let params = match function_type.sty {\n-        ty::TyClosure(_, substs, _) => &substs.types,\n-        _ => unreachable!()\n-    };\n+    let substs = erase_regions(ccx.tcx(), substs);\n     let mono_id = MonoId {\n         def: closure_id,\n-        params: params\n+        params: &substs.func_substs.types\n     };\n \n-    match ccx.closure_vals().borrow().get(&mono_id) {\n-        Some(&llfn) => {\n-            debug!(\"get_or_create_declaration_if_closure(): found closure {:?}: {:?}\",\n-                   mono_id, ccx.tn().val_to_string(llfn));\n-            return Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n-        }\n-        None => {}\n+    if let Some(&llfn) = ccx.closure_vals().borrow().get(&mono_id) {\n+        debug!(\"get_or_create_declaration_if_closure(): found closure {:?}: {:?}\",\n+               mono_id, ccx.tn().val_to_string(llfn));\n+        return llfn;\n     }\n \n     let symbol = ccx.tcx().map.with_path(closure_id.node, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n \n-    // Currently there\u2019s only a single user of\n-    // get_or_create_declaration_if_closure and it unconditionally defines the\n-    // function, therefore we use define_* here.\n-    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type);\n+    let function_type = ccx.tcx().mk_closure_from_closure_substs(closure_id, Box::new(substs));\n+    let llfn = declare::define_internal_rust_fn(ccx, &symbol[..], function_type).unwrap_or_else(||{\n+        ccx.sess().bug(&format!(\"symbol `{}` already defined\", symbol));\n+    });\n \n     // set an inline hint for all closures\n     attributes::inline(llfn, attributes::InlineAttr::Hint);\n@@ -179,7 +162,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n            ccx.tn().val_to_string(llfn));\n     ccx.closure_vals().borrow_mut().insert(mono_id, llfn);\n \n-    Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n+    llfn\n }\n \n pub enum Dest<'a, 'tcx: 'a> {\n@@ -191,9 +174,11 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n                                     decl: &ast::FnDecl,\n                                     body: &ast::Block,\n                                     id: ast::NodeId,\n-                                    param_substs: &'tcx Substs<'tcx>)\n+                                    closure_substs: &'tcx ty::ClosureSubsts<'tcx>)\n                                     -> Option<Block<'a, 'tcx>>\n {\n+    let param_substs = closure_substs.func_substs;\n+\n     let ccx = match dest {\n         Dest::SaveIn(bcx, _) => bcx.ccx(),\n         Dest::Ignore(ccx) => ccx\n@@ -204,10 +189,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     debug!(\"trans_closure_expr()\");\n \n     let closure_id = ast_util::local_def(id);\n-    let llfn = get_or_create_declaration_if_closure(\n-        ccx,\n-        closure_id,\n-        param_substs).unwrap();\n+    let llfn = get_or_create_closure_declaration(ccx, closure_id, closure_substs);\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n@@ -216,7 +198,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // of the closure expression.\n \n     let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n-    let function_type = infcx.closure_type(closure_id, param_substs);\n+    let function_type = infcx.closure_type(closure_id, closure_substs);\n \n     let freevars: Vec<ty::Freevar> =\n         tcx.with_freevars(id, |fv| fv.iter().cloned().collect());\n@@ -226,7 +208,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     trans_closure(ccx,\n                   decl,\n                   body,\n-                  llfn.val,\n+                  llfn,\n                   param_substs,\n                   id,\n                   &[],\n@@ -269,28 +251,19 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                       closure_def_id: ast::DefId,\n-                                      substs: Substs<'tcx>,\n-                                      upvar_tys: Vec<Ty<'tcx>>,\n-                                      node: ExprOrMethodCall,\n-                                      param_substs: &'tcx Substs<'tcx>,\n+                                      substs: ty::ClosureSubsts<'tcx>,\n                                       trait_closure_kind: ty::ClosureKind)\n                                       -> ValueRef\n {\n-    // The substitutions should have no type parameters remaining\n-    // after passing through fulfill_obligation\n-    let llfn = callee::trans_fn_ref_with_substs(ccx,\n-                                                closure_def_id,\n-                                                node,\n-                                                param_substs,\n-                                                substs.clone()).val;\n+    // If this is a closure, redirect to it.\n+    let llfn = get_or_create_closure_declaration(ccx, closure_def_id, &substs);\n \n     // If the closure is a Fn closure, but a FnOnce is needed (etc),\n     // then adapt the self type\n     let closure_kind = ccx.tcx().closure_kind(closure_def_id);\n     trans_closure_adapter_shim(ccx,\n                                closure_def_id,\n                                substs,\n-                               upvar_tys,\n                                closure_kind,\n                                trait_closure_kind,\n                                llfn)\n@@ -299,8 +272,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n fn trans_closure_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     closure_def_id: ast::DefId,\n-    substs: Substs<'tcx>,\n-    upvar_tys: Vec<Ty<'tcx>>,\n+    substs: ty::ClosureSubsts<'tcx>,\n     llfn_closure_kind: ty::ClosureKind,\n     trait_closure_kind: ty::ClosureKind,\n     llfn: ValueRef)\n@@ -339,7 +311,7 @@ fn trans_closure_adapter_shim<'a, 'tcx>(\n             //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n             //\n             // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, upvar_tys, llfn)\n+            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n@@ -352,8 +324,7 @@ fn trans_closure_adapter_shim<'a, 'tcx>(\n fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     closure_def_id: ast::DefId,\n-    substs: Substs<'tcx>,\n-    upvar_tys: Vec<Ty<'tcx>>,\n+    substs: ty::ClosureSubsts<'tcx>,\n     llreffn: ValueRef)\n     -> ValueRef\n {\n@@ -367,12 +338,11 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Find a version of the closure type. Substitute static for the\n     // region since it doesn't really matter.\n-    let substs = tcx.mk_substs(substs);\n-    let closure_ty = tcx.mk_closure(closure_def_id, substs, upvar_tys);\n+    let closure_ty = tcx.mk_closure_from_closure_substs(closure_def_id, Box::new(substs.clone()));\n     let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), closure_ty);\n \n     // Make a version with the type of by-ref closure.\n-    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, substs);\n+    let ty::ClosureTy { unsafety, abi, mut sig } = infcx.closure_type(closure_def_id, &substs);\n     sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n     let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n                                                                abi: abi,\n@@ -402,7 +372,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n                       ast::DUMMY_NODE_ID,\n                       false,\n                       sig.output,\n-                      substs,\n+                      substs.func_substs,\n                       None,\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);"}, {"sha": "deab11332c809cb09e97d4973ba6c0f332ec1484", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -882,11 +882,16 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         },\n         ast::ExprClosure(_, ref decl, ref body) => {\n-            closure::trans_closure_expr(closure::Dest::Ignore(cx),\n-                                        decl,\n-                                        body,\n-                                        e.id,\n-                                        param_substs);\n+            match ety.sty {\n+                ty::TyClosure(_, ref substs) => {\n+                    closure::trans_closure_expr(closure::Dest::Ignore(cx), decl,\n+                                                body, e.id, substs);\n+                }\n+                _ =>\n+                    cx.sess().span_bug(\n+                        e.span,\n+                        &format!(\"bad type for closure expr: {:?}\", ety))\n+            }\n             C_null(type_of::type_of(cx, ety))\n         },\n         _ => cx.sess().span_bug(e.span,"}, {"sha": "66772e67755db5239b18c0df597acdc14416882f", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -287,7 +287,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::TyClosure(def_id, substs, _) => {\n+            ty::TyClosure(def_id, ref substs) => {\n                 let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n                 let closure_ty = infcx.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -811,7 +811,7 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             MetadataCreationResult::new(pointer_type_metadata(cx, t, fn_metadata), false)\n \n         }\n-        ty::TyClosure(def_id, substs, _) => {\n+        ty::TyClosure(def_id, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(cx.tcx(), &cx.tcx().tables);\n             let upvars = infcx.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();"}, {"sha": "0c77e74be38aa1f831bc8a0525ff17a2582694e0", "filename": "src/librustc_trans/trans/declare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdeclare.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -116,7 +116,7 @@ pub fn declare_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, name: &str,\n         ty::TyBareFn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::TyClosure(closure_did, substs, _) => {\n+        ty::TyClosure(closure_did, ref substs) => {\n             let infcx = infer::normalizing_infer_ctxt(ccx.tcx(), &ccx.tcx().tables);\n             function_type = infcx.closure_type(closure_did, substs);\n             let self_type = base::self_type_for_closure(ccx, closure_did, fn_type);"}, {"sha": "962803932b88b03361d671be9dfd79b6dadc6c40", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -1146,8 +1146,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n                 Ignore => closure::Dest::Ignore(bcx.ccx())\n             };\n-            closure::trans_closure_expr(dest, decl, body, expr.id, bcx.fcx.param_substs)\n-                .unwrap_or(bcx)\n+            let substs = match expr_ty(bcx, expr).sty {\n+                ty::TyClosure(_, ref substs) => substs,\n+                ref t =>\n+                    bcx.tcx().sess.span_bug(\n+                        expr.span,\n+                        &format!(\"closure expr without closure type: {:?}\", t)),\n+            };\n+            closure::trans_closure_expr(dest, decl, body, expr.id, substs).unwrap_or(bcx)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {"}, {"sha": "4a549d9c24cdab5e0a31250e5430d2198eeae11e", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -341,9 +341,6 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let llfn = closure::trans_closure_method(bcx.ccx(),\n                                                      vtable_closure.closure_def_id,\n                                                      vtable_closure.substs,\n-                                                     vtable_closure.upvar_tys,\n-                                                     MethodCallKey(method_call),\n-                                                     bcx.fcx.param_substs,\n                                                      trait_closure_kind);\n             Callee {\n                 bcx: bcx,\n@@ -642,15 +639,11 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 traits::VtableClosureData {\n                     closure_def_id,\n                     substs,\n-                    upvar_tys,\n                     nested: _ }) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n                 let llfn = closure::trans_closure_method(ccx,\n                                                          closure_def_id,\n                                                          substs,\n-                                                         upvar_tys,\n-                                                         ExprId(0),\n-                                                         param_substs,\n                                                          trait_closure_kind);\n                 vec![llfn].into_iter()\n             }"}, {"sha": "4cca3b7582bfb0897a3d0ee13b380ec841bf424c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -131,7 +131,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             return Some(CallStep::Builtin);\n         }\n \n-        ty::TyClosure(def_id, substs, _) => {\n+        ty::TyClosure(def_id, ref substs) => {\n             assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we"}, {"sha": "38207354792ae783c4cb703b74e3cf0686c81798", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -41,8 +41,7 @@ pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(),\n     let dtor_predicates = tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(self_type_did, self_to_impl_substs) |\n-        ty::TyStruct(self_type_did, self_to_impl_substs) |\n-        ty::TyClosure(self_type_did, self_to_impl_substs, _) => {\n+        ty::TyStruct(self_type_did, self_to_impl_substs) => {\n             try!(ensure_drop_params_and_item_params_correspond(tcx,\n                                                                drop_impl_did,\n                                                                dtor_generics,"}, {"sha": "a960123efc6b8172045ea9fefa1c0fe7a4ed8e3e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -288,7 +288,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             ty::TyEnum(did, _) |\n             ty::TyStruct(did, _) |\n-            ty::TyClosure(did, _, _) => {\n+            ty::TyClosure(did, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::TyBox(_) => {\n@@ -711,7 +711,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let steps = self.steps.clone();\n         for step in steps.iter() {\n             let closure_def_id = match step.self_ty.sty {\n-                ty::TyClosure(a, _, _) => a,\n+                ty::TyClosure(a, _) => a,\n                 _ => continue,\n             };\n "}, {"sha": "ba89908bbe7e1689e9185159e0b3a4d9eb90f35e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -89,7 +89,6 @@ use middle::free_region::FreeRegionMap;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n-use middle::subst::Substs;\n use middle::traits;\n use middle::ty::{self, ReScope, Ty, MethodCall, HasTypeFlags};\n use middle::infer::{self, GenericKind};\n@@ -1444,7 +1443,7 @@ fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,\n                                   def_id: ast::DefId,\n-                                  substs: &'tcx Substs<'tcx>) {\n+                                  substs: &'tcx ty::ClosureSubsts<'tcx>) {\n     debug!(\"closure_must_outlive(region={:?}, def_id={:?}, substs={:?})\",\n            region, def_id, substs);\n "}, {"sha": "2b800bd9a441f738c3ecdbaf93a5d059b4eede9e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e2677be72e2b0c180ed1be38d1868b4829ad530/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=1e2677be72e2b0c180ed1be38d1868b4829ad530", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match self_type.ty.sty {\n                 ty::TyEnum(type_def_id, _) |\n                 ty::TyStruct(type_def_id, _) |\n-                ty::TyClosure(type_def_id, _, _) => {\n+                ty::TyClosure(type_def_id, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());"}]}