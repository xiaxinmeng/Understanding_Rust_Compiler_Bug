{"sha": "90ab9d9a6d93743bd282f71c867740f5a6674fe0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYWI5ZDlhNmQ5Mzc0M2JkMjgyZjcxYzg2Nzc0MGY1YTY2NzRmZTA=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-23T13:10:28Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-08-23T13:13:26Z"}, "message": "code review fixes", "tree": {"sha": "b3fbe94b7b556e53dde6cb17ea64b9499030f621", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3fbe94b7b556e53dde6cb17ea64b9499030f621"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90ab9d9a6d93743bd282f71c867740f5a6674fe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90ab9d9a6d93743bd282f71c867740f5a6674fe0", "html_url": "https://github.com/rust-lang/rust/commit/90ab9d9a6d93743bd282f71c867740f5a6674fe0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90ab9d9a6d93743bd282f71c867740f5a6674fe0/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ff1734c612094f009a1eff0c2f0bc58baa46a34", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff1734c612094f009a1eff0c2f0bc58baa46a34", "html_url": "https://github.com/rust-lang/rust/commit/2ff1734c612094f009a1eff0c2f0bc58baa46a34"}], "stats": {"total": 199, "additions": 73, "deletions": 126}, "files": [{"sha": "08be7587cb4448244a78954b7acc426572131ff4", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=90ab9d9a6d93743bd282f71c867740f5a6674fe0", "patch": "@@ -48,8 +48,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // Determine whether the sub and sup consist of both anonymous (elided) regions.\n         let (ty_sup, ty_sub, scope_def_id_sup, scope_def_id_sub, bregion_sup, bregion_sub) =\n             if let (Some(anon_reg_sup), Some(anon_reg_sub)) =\n-                (self.is_suitable_anonymous_region(sup, true),\n-                 self.is_suitable_anonymous_region(sub, true)) {\n+                (self.is_suitable_anonymous_region(sup), self.is_suitable_anonymous_region(sub)) {\n                 let (def_id_sup, br_sup, def_id_sub, br_sub) = (anon_reg_sup.def_id,\n                                                                 anon_reg_sup.boundregion,\n                                                                 anon_reg_sub.def_id,\n@@ -64,7 +63,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 return false;\n             };\n \n-        let (label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n+        let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n             (self.find_arg_with_anonymous_region(sup, sup),\n              self.find_arg_with_anonymous_region(sub, sub)) {\n \n@@ -81,7 +80,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             if anon_arg_sup == anon_arg_sub {\n-                (format!(\" with one lifetime\"), format!(\" into the other\"))\n+                (format!(\"this type was declared with multiple lifetimes...\"),\n+                 format!(\" with one lifetime\"),\n+                 format!(\" into the other\"))\n             } else {\n                 let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n                     format!(\" from `{}`\", simple_name)\n@@ -95,15 +96,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     format!(\"\")\n                 };\n \n-                (span_label_var1, span_label_var2)\n+                let span_label =\n+                    format!(\"these two types are declared with different lifetimes...\",);\n+\n+                (span_label, span_label_var1, span_label_var2)\n             }\n         } else {\n             return false;\n         };\n \n+\n         struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-            .span_label(ty_sup.span,\n-                        format!(\"these two types are declared with different lifetimes...\"))\n+            .span_label(ty_sup.span, main_label)\n             .span_label(ty_sub.span, format!(\"\"))\n             .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n             .emit();\n@@ -126,7 +130,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n     pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n-        if let Some(anon_reg) = self.is_suitable_anonymous_region(region, true) {\n+        if let Some(anon_reg) = self.is_suitable_anonymous_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let ret_ty = self.tcx.type_of(def_id);"}, {"sha": "0aae008396a00615b09cd7386ac0baec47506c90", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=90ab9d9a6d93743bd282f71c867740f5a6674fe0", "patch": "@@ -31,24 +31,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n         let (named, anon_arg_info, region_info) =\n-            if sub.is_named_region() && self.is_suitable_anonymous_region(sup, false).is_some() {\n+            if sub.is_named_region() && self.is_suitable_anonymous_region(sup).is_some() {\n                 (sub,\n                  self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n-                 self.is_suitable_anonymous_region(sup, false).unwrap())\n-            } else if sup.is_named_region() &&\n-                      self.is_suitable_anonymous_region(sub, false).is_some() {\n+                 self.is_suitable_anonymous_region(sup).unwrap())\n+            } else if sup.is_named_region() && self.is_suitable_anonymous_region(sub).is_some() {\n                 (sup,\n                  self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n-                 self.is_suitable_anonymous_region(sub, false).unwrap())\n+                 self.is_suitable_anonymous_region(sub).unwrap())\n             } else {\n                 return false; // inapplicable\n             };\n \n-        let (arg, new_ty, br, is_first, scope_def_id) = (anon_arg_info.arg,\n-                                                         anon_arg_info.arg_ty,\n-                                                         anon_arg_info.bound_region,\n-                                                         anon_arg_info.is_first,\n-                                                         region_info.def_id);\n+        let (arg, new_ty, br, is_first, scope_def_id, is_impl_item) = (anon_arg_info.arg,\n+                                                                       anon_arg_info.arg_ty,\n+                                                                       anon_arg_info.bound_region,\n+                                                                       anon_arg_info.is_first,\n+                                                                       region_info.def_id,\n+                                                                       region_info.is_impl_item);\n+        if is_impl_item {\n+            return false;\n+        }\n+\n         if self.is_return_type_anon(scope_def_id, br) || self.is_self_anon(is_first, scope_def_id) {\n             return false;\n         } else {"}, {"sha": "3d5dcf37c48c17fb38666112edb1d7089d46b3dc", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=90ab9d9a6d93743bd282f71c867740f5a6674fe0", "patch": "@@ -37,6 +37,8 @@ pub struct FreeRegionInfo {\n     pub def_id: DefId,\n     // the bound region corresponding to FreeRegion\n     pub boundregion: ty::BoundRegion,\n+    // checks if bound region is in Impl Item\n+    pub is_impl_item: bool,\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n@@ -106,48 +108,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     // This method returns whether the given Region is Anonymous\n     // and returns the DefId and the BoundRegion corresponding to the given region.\n-    // The is_anon_anon is set true when we are dealing with cases where\n-    // both the regions are anonymous i.e. E0623.\n-    pub fn is_suitable_anonymous_region(&self,\n-                                        region: Region<'tcx>,\n-                                        is_anon_anon: bool)\n-                                        -> Option<FreeRegionInfo> {\n+    pub fn is_suitable_anonymous_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         if let ty::ReFree(ref free_region) = *region {\n             if let ty::BrAnon(..) = free_region.bound_region {\n                 let anonymous_region_binding_scope = free_region.scope;\n-                let node_id = self.tcx\n-                    .hir\n-                    .as_local_node_id(anonymous_region_binding_scope)\n-                    .unwrap();\n-                match self.tcx.hir.find(node_id) {\n-                    Some(hir_map::NodeItem(..)) |\n-                    Some(hir_map::NodeTraitItem(..)) => {\n-                        // Success -- proceed to return Some below\n-                    }\n-                    Some(hir_map::NodeImplItem(..)) => {\n-                        if !is_anon_anon {\n-                            let container_id = self.tcx\n-                                .associated_item(anonymous_region_binding_scope)\n-                                .container\n-                                .id();\n-                            if self.tcx.impl_trait_ref(container_id).is_some() {\n-                                // For now, we do not try to target impls of traits. This is\n-                                // because this message is going to suggest that the user\n-                                // change the fn signature, but they may not be free to do so,\n-                                // since the signature must match the trait.\n-                                //\n-                                // FIXME(#42706) -- in some cases, we could do better here.\n-                                return None;\n-                            }\n-                        } else {\n-                        }\n-                    }\n-                    _ => return None, // inapplicable\n-                    // we target only top-level functions\n-                }\n                 return Some(FreeRegionInfo {\n                                 def_id: anonymous_region_binding_scope,\n                                 boundregion: free_region.bound_region,\n+                                is_impl_item:\n+                                self.is_bound_region_in_impl_item(anonymous_region_binding_scope),\n                             });\n             }\n         }\n@@ -177,12 +146,42 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // FIXME(#42700) - Need to format self properly to\n     // enable E0621 for it.\n     pub fn is_self_anon(&self, is_first: bool, scope_def_id: DefId) -> bool {\n-        if is_first &&\n-           self.tcx\n-               .opt_associated_item(scope_def_id)\n-               .map(|i| i.method_has_self_argument)\n-               .unwrap_or(false) {\n-            return true;\n+        is_first &&\n+        self.tcx\n+            .opt_associated_item(scope_def_id)\n+            .map(|i| i.method_has_self_argument) == Some(true)\n+    }\n+\n+    // Here we check if the bound region is in Impl Item.\n+    pub fn is_bound_region_in_impl_item(&self, anonymous_region_binding_scope: DefId) -> bool {\n+        let node_id = self.tcx\n+            .hir\n+            .as_local_node_id(anonymous_region_binding_scope)\n+            .unwrap();\n+        match self.tcx.hir.find(node_id) {\n+\n+            Some(hir_map::NodeItem(..)) |\n+            Some(hir_map::NodeTraitItem(..)) => {\n+                // Success -- proceed to return Some below\n+            }\n+            Some(hir_map::NodeImplItem(..)) => {\n+                let container_id = self.tcx\n+                    .associated_item(anonymous_region_binding_scope)\n+                    .container\n+                    .id();\n+                if self.tcx.impl_trait_ref(container_id).is_some() {\n+                    // For now, we do not try to target impls of traits. This is\n+                    // because this message is going to suggest that the user\n+                    // change the fn signature, but they may not be free to do so,\n+                    // since the signature must match the trait.\n+                    //\n+                    // FIXME(#42706) -- in some cases, we could do better here.\n+                    return true;\n+                }\n+            }\n+            _ => {\n+                return false;\n+            }\n         }\n         false\n     }"}, {"sha": "1b5ac7c7b57eef542646526fd9a4e4bf07c663d7", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.stderr?ref=90ab9d9a6d93743bd282f71c867740f5a6674fe0", "patch": "@@ -4,7 +4,7 @@ error[E0623]: lifetime mismatch\n 15 | fn foo(mut x: Ref) {\n    |               ---\n    |               |\n-   |               these two types are declared with different lifetimes...\n+   |               this type was declared with multiple lifetimes...\n 16 |     x.a = x.b;\n    |           ^^^ ...but data with one lifetime flows into the other here\n "}, {"sha": "606e611865fc772746230d09cd4104c9dfef6913", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-4.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.rs?ref=2ff1734c612094f009a1eff0c2f0bc58baa46a34", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-struct Ref<'a, 'b> {\n-    a: &'a u32,\n-    b: &'b u32,\n-}\n-\n-fn foo(mut x: Ref) {\n-    x.a = x.b;\n-}\n-\n-fn main() {}"}, {"sha": "2ef1cd507f1477c9d5e3493aa36703b4eb62a5d2", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-4.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.stderr?ref=2ff1734c612094f009a1eff0c2f0bc58baa46a34", "patch": "@@ -1,12 +0,0 @@\n-error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-both-are-structs-4.rs:16:11\n-   |\n-15 | fn foo(mut x: Ref) {\n-   |               ---\n-   |               |\n-   |               these two types are declared with different lifetimes...\n-16 |     x.a = x.b;\n-   |           ^^^ ...but data with one lifetime flows into the other here\n-\n-error: aborting due to previous error\n-"}, {"sha": "4933dbb7e7a7a2c3ec95ffb312fa34dcd9875ee4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.rs?ref=90ab9d9a6d93743bd282f71c867740f5a6674fe0", "patch": "@@ -11,7 +11,7 @@\n struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n \n fn foo(mut y: Ref, x: &u32) {\n-    x = y.b;\n+    y.b = x;\n }\n \n fn main() { }"}, {"sha": "40f026bcb1b588e67d3aebf5e1b3be560b787e54", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90ab9d9a6d93743bd282f71c867740f5a6674fe0/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.stderr?ref=90ab9d9a6d93743bd282f71c867740f5a6674fe0", "patch": "@@ -1,12 +1,10 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-one-is-struct-3.rs:14:9\n+  --> $DIR/ex3-both-anon-regions-one-is-struct-4.rs:14:11\n    |\n 13 | fn foo(mut y: Ref, x: &u32) {\n-   |               ---     ----\n-   |               |\n-   |               these two types are declared with different lifetimes...\n-14 |     x = y.b;\n-   |         ^^^ ...but data from `y` flows into `x` here\n+   |               ---     ---- these two types are declared with different lifetimes...\n+14 |     y.b = x;\n+   |           ^ ...but data from `x` flows into `y` here\n \n error: aborting due to previous error\n "}, {"sha": "4933dbb7e7a7a2c3ec95ffb312fa34dcd9875ee4", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-4.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.rs?ref=2ff1734c612094f009a1eff0c2f0bc58baa46a34", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Ref<'a, 'b> { a: &'a u32, b: &'b u32 }\n-\n-fn foo(mut y: Ref, x: &u32) {\n-    y.b = x;\n-}\n-\n-fn main() { }"}, {"sha": "40f026bcb1b588e67d3aebf5e1b3be560b787e54", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-one-is-struct-4.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ff1734c612094f009a1eff0c2f0bc58baa46a34/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.stderr?ref=2ff1734c612094f009a1eff0c2f0bc58baa46a34", "patch": "@@ -1,10 +0,0 @@\n-error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-one-is-struct-4.rs:14:11\n-   |\n-13 | fn foo(mut y: Ref, x: &u32) {\n-   |               ---     ---- these two types are declared with different lifetimes...\n-14 |     y.b = x;\n-   |           ^ ...but data from `x` flows into `y` here\n-\n-error: aborting due to previous error\n-"}]}