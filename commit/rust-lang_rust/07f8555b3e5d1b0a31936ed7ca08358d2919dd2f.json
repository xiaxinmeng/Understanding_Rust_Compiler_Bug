{"sha": "07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3Zjg1NTViM2U1ZDFiMGEzMTkzNmVkN2NhMDgzNThkMjkxOWRkMmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-22T01:29:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-23T04:06:58Z"}, "message": "std: Add some hacks to use libuv", "tree": {"sha": "0073fa41a5f61472c62e4173a4102ac97a2902a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0073fa41a5f61472c62e4173a4102ac97a2902a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "html_url": "https://github.com/rust-lang/rust/commit/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a88c0847c227db089d9b1d3c4c1134721a92d955", "url": "https://api.github.com/repos/rust-lang/rust/commits/a88c0847c227db089d9b1d3c4c1134721a92d955", "html_url": "https://github.com/rust-lang/rust/commit/a88c0847c227db089d9b1d3c4c1134721a92d955"}], "stats": {"total": 509, "additions": 508, "deletions": 1}, "files": [{"sha": "a161f298a6397467777e1cf6a0c81137ed59c3d0", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "patch": "@@ -48,6 +48,7 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n               rt/rust_uv.cpp \\\n+              rt/rust_uvtmp.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_timer.cpp \\\n               rt/circular_buffer.cpp \\"}, {"sha": "bcfe108eae52425e3f5552f3e44a96c7249963df", "filename": "src/libstd/std.rc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "patch": "@@ -7,7 +7,7 @@\n #[license = \"MIT\"];\n #[crate_type = \"lib\"];\n \n-export fs, io, net, run, uv;\n+export fs, io, net, run, uv, uvtmp;\n export c_vec, four, tri, util;\n export bitv, deque, fun_treemap, list, map, smallintmap, sort, treemap, ufind;\n export rope;\n@@ -25,6 +25,7 @@ mod net;\n #[path =  \"run_program.rs\"]\n mod run;\n mod uv;\n+mod uvtmp;\n \n \n // Utility modules"}, {"sha": "e2059890511a6e52c95a289360f8b74e32d1a521", "filename": "src/libstd/uvtmp.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "patch": "@@ -0,0 +1,149 @@\n+// Some temporary libuv hacks for servo\n+\n+#[cfg(target_os = \"linux\")];\n+#[cfg(target_os = \"macos\")];\n+#[cfg(target_os = \"freebsd\")];\n+\n+\n+#[nolink]\n+native mod rustrt {\n+    fn rust_uvtmp_create_thread() -> thread;\n+    fn rust_uvtmp_start_thread(thread: thread);\n+    fn rust_uvtmp_join_thread(thread: thread);\n+    fn rust_uvtmp_delete_thread(thread: thread);\n+    fn rust_uvtmp_connect(\n+        thread: thread,\n+        ip: str::sbuf,\n+        chan: comm::chan<iomsg>);\n+    fn rust_uvtmp_close_connection(thread: thread, cd: connect_data);\n+    fn rust_uvtmp_write(\n+        thread: thread,\n+        cd: connect_data,\n+        buf: *u8,\n+        len: ctypes::size_t,\n+        chan: comm::chan<iomsg>);\n+    fn rust_uvtmp_read_start(\n+        thread: thread,\n+        cd: connect_data,\n+        chan: comm::chan<iomsg>);\n+    fn rust_uvtmp_delete_buf(buf: *u8);\n+}\n+\n+type thread = *ctypes::void;\n+\n+type connect_data = *ctypes::void;\n+\n+enum iomsg {\n+    whatever,\n+    connected(connect_data),\n+    wrote(connect_data),\n+    read(connect_data, *u8, ctypes::ssize_t)\n+}\n+\n+fn create_thread() -> thread {\n+    rustrt::rust_uvtmp_create_thread()\n+}\n+\n+fn start_thread(thread: thread) {\n+    rustrt::rust_uvtmp_start_thread(thread)\n+}\n+\n+fn join_thread(thread: thread) {\n+    rustrt::rust_uvtmp_join_thread(thread)\n+}\n+\n+fn delete_thread(thread: thread) {\n+    rustrt::rust_uvtmp_delete_thread(thread)\n+}\n+\n+fn connect(thread: thread, ip: str, ch: comm::chan<iomsg>) {\n+    str::as_buf(ip) {|ipbuf|\n+        rustrt::rust_uvtmp_connect(thread, ipbuf, ch)\n+    }\n+}\n+\n+fn close_connection(thread: thread, cd: connect_data) {\n+    rustrt::rust_uvtmp_close_connection(thread ,cd);\n+}\n+\n+fn write(thread: thread, cd: connect_data,bytes: [u8],\n+         chan: comm::chan<iomsg>) unsafe {\n+    rustrt::rust_uvtmp_write(\n+        thread, cd, vec::to_ptr(bytes), vec::len(bytes), chan);\n+}\n+\n+fn read_start(thread: thread, cd: connect_data,\n+              chan: comm::chan<iomsg>) {\n+    rustrt::rust_uvtmp_read_start(thread, cd, chan);\n+}\n+\n+fn delete_buf(buf: *u8) {\n+    rustrt::rust_uvtmp_delete_buf(buf);\n+}\n+\n+#[test]\n+fn test_start_stop() {\n+    let thread = create_thread();\n+    start_thread(thread);\n+    join_thread(thread);\n+    delete_thread(thread);\n+}\n+\n+#[test]\n+#[ignore]\n+fn test_connect() {\n+    let thread = create_thread();\n+    start_thread(thread);\n+    let port = comm::port();\n+    let chan = comm::chan(port);\n+    connect(thread, \"74.125.224.146\", chan);\n+    alt comm::recv(port) {\n+      connected(cd) {\n+        close_connection(thread, cd);\n+      }\n+    }\n+    join_thread(thread);\n+    delete_thread(thread);\n+}\n+\n+#[test]\n+#[ignore]\n+fn test_http() {\n+    let thread = create_thread();\n+    start_thread(thread);\n+    let port = comm::port();\n+    let chan = comm::chan(port);\n+    connect(thread, \"74.125.224.146\", chan);\n+    alt comm::recv(port) {\n+      connected(cd) {\n+        write(thread, cd, str::bytes(\"GET / HTTP/1.0\\n\\n\"), chan);\n+        alt comm::recv(port) {\n+          wrote(cd) {\n+            read_start(thread, cd, chan);\n+            let keep_going = true;\n+            while keep_going {\n+                alt comm::recv(port) {\n+                  read(_, buf, -1) {\n+                    keep_going = false;\n+                    delete_buf(buf);\n+                  }\n+                  read(_, buf, len) {\n+                    unsafe {\n+                        log(error, len);\n+                        let buf = vec::unsafe::from_buf(buf, len as uint);\n+                        let str = str::unsafe_from_bytes(buf);\n+                        #error(\"read something\");\n+                        io::println(str);\n+                    }\n+                    delete_buf(buf);\n+                  }\n+                }\n+            }\n+            close_connection(thread, cd);\n+          }\n+        }\n+      }\n+    }\n+    join_thread(thread);\n+    delete_thread(thread);\n+}\n\\ No newline at end of file"}, {"sha": "9ee1b844add2c1c70b9b34c3c4e8a7d61263aaba", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "patch": "@@ -48,3 +48,4 @@ extern \"C\" CDECL size_t\n rust_uv_size_of_idle_t() {\n   return sizeof(uv_idle_t);\n }\n+"}, {"sha": "3d4cb89f71111c12917bcdd63f07cd9f15ff38c8", "filename": "src/rt/rust_uvtmp.cpp", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "patch": "@@ -0,0 +1,346 @@\n+#include <utility>\n+#include <queue>\n+#include <string>\n+#include \"rust_internal.h\"\n+#include \"uv.h\"\n+\n+class rust_uvtmp_thread;\n+\n+struct connect_data {\n+    rust_uvtmp_thread *thread;\n+    uv_connect_t connect;\n+    uv_tcp_t tcp;\n+    chan_handle chan;\n+};\n+\n+const intptr_t connected_tag = 1;\n+const intptr_t wrote_tag = 2;\n+const intptr_t read_tag = 3;\n+\n+struct iomsg {\n+    intptr_t tag;\n+    union {\n+\tconnect_data *connected_val;\n+\tconnect_data *wrote_val;\n+\tstruct {\n+\t    connect_data *cd;\n+\t    uint8_t *buf;\n+\t    ssize_t nread;\n+\t} read_val;\n+    } val;\n+};\n+\n+struct write_data {\n+    connect_data *cd;\n+    uint8_t *buf;\n+    size_t len;\n+    chan_handle chan;\n+};\n+\n+struct read_start_data {\n+    connect_data *cd;\n+    chan_handle chan;\n+};\n+\n+// FIXME: Copied from rust_builtins.cpp. Could bitrot easily\n+static void\n+send(rust_task *task, chan_handle chan, void *data) {\n+    rust_task *target_task = task->kernel->get_task_by_id(chan.task);\n+    if(target_task) {\n+        rust_port *port = target_task->get_port_by_id(chan.port);\n+        if(port) {\n+            port->send(data);\n+            scoped_lock with(target_task->lock);\n+            port->deref();\n+        }\n+        target_task->deref();\n+    }\n+}\n+\n+class rust_uvtmp_thread : public rust_thread {\n+\n+private:\n+    rust_task *task;\n+    uv_loop_t *loop;\n+    uv_idle_t idle;\n+    lock_and_signal lock;\n+    bool stop_flag;\n+    std::queue<std::pair<std::string, chan_handle> > connect_queue;\n+    std::queue<connect_data*> close_connection_queue;\n+    std::queue<write_data*> write_queue;\n+    std::queue<read_start_data*> read_start_queue;\n+\n+public:\n+\n+    rust_uvtmp_thread() {\n+\ttask = rust_scheduler::get_task();\n+\tstop_flag = false;\n+\tloop = uv_loop_new();\n+\tuv_idle_init(loop, &idle);\n+\tidle.data = this;\n+\tuv_idle_start(&idle, idle_cb);\n+    }\n+\n+    ~rust_uvtmp_thread() {\n+\tuv_loop_delete(loop);\n+    }\n+\n+    void stop() {\n+\tscoped_lock with(lock);\n+\tstop_flag = true;\n+    }\n+\n+    void connect(char *ip, chan_handle chan) {\n+\tscoped_lock with(lock);\n+\tconnect_queue.push(std::pair<std::string, chan_handle>\n+\t\t\t   (std::string(ip), chan));\n+    }\n+\n+    void\n+    close_connection(connect_data *cd) {\n+\tscoped_lock with(lock);\n+\tclose_connection_queue.push(cd);\n+    }\n+\n+    void\n+    write(connect_data *cd, uint8_t *buf, size_t len, chan_handle chan) {\n+\tscoped_lock with(lock);\n+\twrite_data *wd = new write_data();\n+\twd->cd = cd;\n+\twd->buf = new uint8_t[len];\n+\twd->len = len;\n+\twd->chan = chan;\n+\n+\tmemcpy(wd->buf, buf, len);\n+\n+\twrite_queue.push(wd);\n+    }\n+\n+    void\n+    read_start(connect_data *cd, chan_handle chan) {\n+\tscoped_lock with(lock);\n+\tread_start_data *rd = new read_start_data();\n+\trd->cd = cd;\n+\trd->chan = chan;\n+\n+\tread_start_queue.push(rd);\n+    }\n+\n+private:\n+\n+    virtual void\n+    run() {\n+\tuv_run(loop);\n+    }\n+\n+    static void\n+    idle_cb(uv_idle_t* handle, int status) {\n+\trust_uvtmp_thread *self = (rust_uvtmp_thread*) handle->data;\n+\tself->on_idle();\n+    }\n+\n+    void\n+    on_idle() {\n+\tscoped_lock with(lock);\n+\tmake_new_connections();\n+\tclose_connections();\n+\twrite_buffers();\n+\tstart_reads();\n+\tclose_idle_if_stop();\n+    }\n+\n+    void\n+    make_new_connections() {\n+\tassert(lock.lock_held_by_current_thread());\n+\twhile (!connect_queue.empty()) {\n+\t    std::pair<std::string, chan_handle> pair = connect_queue.front();\n+\t    connect_queue.pop();\n+\t    struct sockaddr_in client_addr = uv_ip4_addr(\"0.0.0.0\", 0);\n+\t    struct sockaddr_in server_addr = uv_ip4_addr(pair.first.c_str(), 80);\n+\n+\t    connect_data *cd = new connect_data();\n+\t    cd->thread = this;\n+\t    cd->chan = pair.second;\n+\t    cd->connect.data = cd;\n+\n+\t    uv_tcp_init(loop, &cd->tcp);\n+\t    uv_tcp_bind(&cd->tcp, client_addr);\n+\n+\t    uv_tcp_connect(&cd->connect, &cd->tcp, server_addr, connect_cb);\n+\t}\n+    }\n+\n+    static void\n+    connect_cb(uv_connect_t *handle, int status) {\n+\tconnect_data *cd = (connect_data*)handle->data;\n+\tcd->thread->on_connect(cd);\n+    }\n+\n+    void\n+    on_connect(connect_data *cd) {\n+\tiomsg msg;\n+\tmsg.tag = connected_tag;\n+\tmsg.val.connected_val = cd;\n+\n+\tsend(task, cd->chan, &msg);\n+    }\n+\n+    void\n+    close_connections() {\n+\tassert(lock.lock_held_by_current_thread());\n+\twhile (!close_connection_queue.empty()) {\n+\t    connect_data *cd = close_connection_queue.front();\n+\t    close_connection_queue.pop();\n+\t    \n+\t    cd->tcp.data = cd;\n+\t    \n+\t    uv_close((uv_handle_t*)&cd->tcp, tcp_close_cb);\n+\t}\n+    }\n+\n+    static void\n+    tcp_close_cb(uv_handle_t *handle) {\n+\tconnect_data *cd = (connect_data*)handle->data;\n+\tdelete cd;\n+    }\n+\n+    void\n+    write_buffers() {\n+\tassert(lock.lock_held_by_current_thread());\n+\twhile (!write_queue.empty()) {\n+\t    write_data *wd = write_queue.front();\n+\t    write_queue.pop();\n+\n+\t    uv_write_t *write = new uv_write_t();\n+\n+\t    write->data = wd;\n+\n+\t    uv_buf_t buf;\n+\t    buf.base = (char*)wd->buf;\n+\t    buf.len = wd->len;\n+\n+\t    uv_write(write, (uv_stream_t*)&wd->cd->tcp, &buf, 1, write_cb);\n+\t}\n+    }\n+\n+    static void\n+    write_cb(uv_write_t *handle, int status) {\n+\twrite_data *wd = (write_data*)handle->data;\n+\trust_uvtmp_thread *self = wd->cd->thread;\n+\tself->on_write(handle, wd);\n+    }\n+\n+    void\n+    on_write(uv_write_t *handle, write_data *wd) {\n+\tiomsg msg;\n+\tmsg.tag = wrote_tag;\n+\tmsg.val.wrote_val = wd->cd;\n+\n+\tsend(task, wd->chan, &msg);\n+\n+\tdelete [] wd->buf;\n+\tdelete wd;\n+\tdelete handle;\n+    }\n+\n+    void\n+    start_reads() {\n+\tassert (lock.lock_held_by_current_thread());\n+\twhile (!read_start_queue.empty()) {\n+\t    read_start_data *rd = read_start_queue.front();\n+\t    read_start_queue.pop();\n+\n+\t    connect_data *cd = rd->cd;\n+\t    cd->tcp.data = rd;\n+\n+\t    uv_read_start((uv_stream_t*)&cd->tcp, alloc_cb, read_cb);\n+\t}\n+    }\n+\n+    static uv_buf_t\n+    alloc_cb(uv_handle_t* handle, size_t size) {\n+\tuv_buf_t buf;\n+\tbuf.base = new char[size];\n+\tbuf.len = size;\n+\treturn buf;\n+    }\n+\n+    static void\n+    read_cb(uv_stream_t *handle, ssize_t nread, uv_buf_t buf) {\n+\tread_start_data *rd = (read_start_data*)handle->data;\n+\trust_uvtmp_thread *self = rd->cd->thread;\n+\tself->on_read(rd, nread, buf);\n+    }\n+\n+    void\n+    on_read(read_start_data *rd, ssize_t nread, uv_buf_t buf) {\n+\tiomsg msg;\n+\tmsg.tag = read_tag;\n+\tmsg.val.read_val.cd = rd->cd;\n+\tmsg.val.read_val.buf = (uint8_t*)buf.base;\n+\tmsg.val.read_val.nread = nread;\n+\n+\tsend(task, rd->chan, &msg);\n+\tif (nread == -1) {\n+\t    delete rd;\n+\t}\n+    }\n+\n+    void\n+    close_idle_if_stop() {\n+\tassert(lock.lock_held_by_current_thread());\n+\tif (stop_flag) {\n+\t    uv_close((uv_handle_t*)&idle, NULL);\n+\t}\n+    }\n+\n+};\n+\n+extern \"C\" rust_uvtmp_thread *\n+rust_uvtmp_create_thread() {\n+    rust_uvtmp_thread *thread = new rust_uvtmp_thread();\n+    return thread;\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_start_thread(rust_uvtmp_thread *thread) {\n+    thread->start();    \n+}\n+\n+extern \"C\" void\n+rust_uvtmp_join_thread(rust_uvtmp_thread *thread) {\n+    thread->stop();\n+    thread->join();\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_delete_thread(rust_uvtmp_thread *thread) {\n+    delete thread;\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_connect(rust_uvtmp_thread *thread, char *ip, chan_handle *chan) {\n+    thread->connect(ip, *chan);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_close_connection(rust_uvtmp_thread *thread, connect_data *cd) {\n+  thread->close_connection(cd);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_write(rust_uvtmp_thread *thread, connect_data *cd,\n+\t\t uint8_t *buf, size_t len, chan_handle *chan) {\n+    thread->write(cd, buf, len, *chan);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_read_start(rust_uvtmp_thread *thread, connect_data *cd,\n+\t\t      chan_handle *chan) {\n+    thread->read_start(cd, *chan);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_delete_buf(uint8_t *buf) {\n+    delete [] buf;\n+}"}, {"sha": "86f24a20f9620d78bc429043a64bcf63e1658d96", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/07f8555b3e5d1b0a31936ed7ca08358d2919dd2f/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=07f8555b3e5d1b0a31936ed7ca08358d2919dd2f", "patch": "@@ -88,3 +88,12 @@ rust_uv_unref\n rust_uv_idle_init\n rust_uv_idle_start\n rust_uv_size_of_idle_t\n+rust_uvtmp_create_thread\n+rust_uvtmp_start_thread\n+rust_uvtmp_join_thread\n+rust_uvtmp_delete_thread\n+rust_uvtmp_connect\n+rust_uvtmp_close_connection\n+rust_uvtmp_write\n+rust_uvtmp_read_start\n+rust_uvtmp_delete_buf"}]}