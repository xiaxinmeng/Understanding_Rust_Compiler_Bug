{"sha": "18de1b1fde169e76c3f4941b9c8b8c009221d618", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZGUxYjFmZGUxNjllNzZjM2Y0OTQxYjljOGI4YzAwOTIyMWQ2MTg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-01-30T15:53:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-30T15:53:15Z"}, "message": "Merge pull request #1131 from bjorn3/abi_compat\n\nFull abi compatibilty", "tree": {"sha": "41ef254535aae28e25323cf7c361953402fd4701", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41ef254535aae28e25323cf7c361953402fd4701"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18de1b1fde169e76c3f4941b9c8b8c009221d618", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgFYDrCRBK7hj4Ov3rIwAAdHIIACykBt0Zyhax7plmgzV356g/\nKKa7vB/GaspQCMIS2RxmaQQ9MU8qI5LxtSMz8kvNhEDj8F1dvLw2dIEwsz5kJ/yy\nfdgfrk+p+3WbnyRTdvSwSf+EAI8pWt0cYHrDxCl43GN/0p/ZxXlR9UiLBzzxOxyJ\nKnxktBN1s9I0oOb6EejccjWKa7uRyJTb0uyDo11ssd4bHOsgTeEKFti96PeLfRpg\na+pH2RJVtwRcsg1AQd8P2rA2rMgJC09fLfl83HZB3bh/Dzc+XhCXtAFYNozT0oPj\nSL8eqGCdC0Pw4uwz82UQ4FkK6WXampfOI0WJ287/emOSmbVgyeo1OEUOkICjBkw=\n=/fVl\n-----END PGP SIGNATURE-----\n", "payload": "tree 41ef254535aae28e25323cf7c361953402fd4701\nparent 6a739b3ae199f8c60c778b28f70ccac31d1a4a48\nparent 7fcf59f19e711b89285505785f97dd57f80cbe2e\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1612021995 +0100\ncommitter GitHub <noreply@github.com> 1612021995 +0100\n\nMerge pull request #1131 from bjorn3/abi_compat\n\nFull abi compatibilty"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18de1b1fde169e76c3f4941b9c8b8c009221d618", "html_url": "https://github.com/rust-lang/rust/commit/18de1b1fde169e76c3f4941b9c8b8c009221d618", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18de1b1fde169e76c3f4941b9c8b8c009221d618/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a739b3ae199f8c60c778b28f70ccac31d1a4a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a739b3ae199f8c60c778b28f70ccac31d1a4a48", "html_url": "https://github.com/rust-lang/rust/commit/6a739b3ae199f8c60c778b28f70ccac31d1a4a48"}, {"sha": "7fcf59f19e711b89285505785f97dd57f80cbe2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fcf59f19e711b89285505785f97dd57f80cbe2e", "html_url": "https://github.com/rust-lang/rust/commit/7fcf59f19e711b89285505785f97dd57f80cbe2e"}], "stats": {"total": 1343, "additions": 769, "deletions": 574}, "files": [{"sha": "5495cfa5eaa0dc9ca414764805b45b0d288c893e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -333,6 +333,7 @@ dependencies = [\n  \"indexmap\",\n  \"libloading\",\n  \"object\",\n+ \"smallvec\",\n  \"target-lexicon\",\n ]\n "}, {"sha": "3820fce6d1e0df69ff647f91965a2ac81741e230", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -21,6 +21,7 @@ object = { version = \"0.22.0\", default-features = false, features = [\"std\", \"rea\n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.0.2\"\n libloading = { version = \"0.6.0\", optional = true }\n+smallvec = \"1.6.1\"\n \n # Uncomment to use local checkout of cranelift\n #[patch.\"https://github.com/bytecodealliance/wasmtime/\"]"}, {"sha": "55ac079c0a9b51226de88559b0d8d4cd17a9689a", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -1 +1 @@\n-nightly-2021-01-21\n+nightly-2021-01-25"}, {"sha": "9aab45b62e2115f3cb6d4790ad333cc0a77d71a4", "filename": "src/abi/comments.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -4,10 +4,10 @@\n use std::borrow::Cow;\n \n use rustc_middle::mir;\n+use rustc_target::abi::call::PassMode;\n \n use cranelift_codegen::entity::EntityRef;\n \n-use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, impl Module>) {\n@@ -21,9 +21,9 @@ pub(super) fn add_arg_comment<'tcx>(\n     kind: &str,\n     local: Option<mir::Local>,\n     local_field: Option<usize>,\n-    params: EmptySinglePair<Value>,\n-    pass_mode: PassMode,\n-    ty: Ty<'tcx>,\n+    params: &[Value],\n+    arg_abi_mode: PassMode,\n+    arg_layout: TyAndLayout<'tcx>,\n ) {\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n@@ -37,20 +37,28 @@ pub(super) fn add_arg_comment<'tcx>(\n     };\n \n     let params = match params {\n-        Empty => Cow::Borrowed(\"-\"),\n-        Single(param) => Cow::Owned(format!(\"= {:?}\", param)),\n-        Pair(param_a, param_b) => Cow::Owned(format!(\"= {:?}, {:?}\", param_a, param_b)),\n+        [] => Cow::Borrowed(\"-\"),\n+        [param] => Cow::Owned(format!(\"= {:?}\", param)),\n+        [param_a, param_b] => Cow::Owned(format!(\"= {:?},{:?}\", param_a, param_b)),\n+        params => Cow::Owned(format!(\n+            \"= {}\",\n+            params\n+                .iter()\n+                .map(ToString::to_string)\n+                .collect::<Vec<_>>()\n+                .join(\",\")\n+        )),\n     };\n \n-    let pass_mode = format!(\"{:?}\", pass_mode);\n+    let pass_mode = format!(\"{:?}\", arg_abi_mode);\n     fx.add_global_comment(format!(\n         \"{kind:5}{local:>3}{local_field:<5} {params:10} {pass_mode:36} {ty:?}\",\n         kind = kind,\n         local = local,\n         local_field = local_field,\n         params = params,\n         pass_mode = pass_mode,\n-        ty = ty,\n+        ty = arg_layout.ty,\n     ));\n }\n "}, {"sha": "6a025f2e88ae3f8b4c022663739fca48bcc9323b", "filename": "src/abi/mod.rs", "status": "modified", "additions": 136, "deletions": 261, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -6,199 +6,50 @@ mod pass_mode;\n mod returning;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n \n-use cranelift_codegen::ir::{AbiParam, ArgumentPurpose};\n+use cranelift_codegen::ir::AbiParam;\n+use smallvec::smallvec;\n \n use self::pass_mode::*;\n use crate::prelude::*;\n \n pub(crate) use self::returning::{can_return_to_ssa_var, codegen_return};\n \n-// Copied from https://github.com/rust-lang/rust/blob/f52c72948aa1dd718cc1f168d21c91c584c0a662/src/librustc_middle/ty/layout.rs#L2301\n-#[rustfmt::skip]\n-pub(crate) fn fn_sig_for_fn_abi<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> ty::PolyFnSig<'tcx> {\n-    use rustc_middle::ty::subst::Subst;\n-\n-    // FIXME(davidtwco,eddyb): A `ParamEnv` should be passed through to this function.\n-    let ty = instance.ty(tcx, ty::ParamEnv::reveal_all());\n-    match *ty.kind() {\n-        ty::FnDef(..) => {\n-            // HACK(davidtwco,eddyb): This is a workaround for polymorphization considering\n-            // parameters unused if they show up in the signature, but not in the `mir::Body`\n-            // (i.e. due to being inside a projection that got normalized, see\n-            // `src/test/ui/polymorphization/normalized_sig_types.rs`), and codegen not keeping\n-            // track of a polymorphization `ParamEnv` to allow normalizing later.\n-            let mut sig = match *ty.kind() {\n-                ty::FnDef(def_id, substs) => tcx\n-                    .normalize_erasing_regions(tcx.param_env(def_id), tcx.fn_sig(def_id))\n-                    .subst(tcx, substs),\n-                _ => unreachable!(),\n-            };\n-\n-            if let ty::InstanceDef::VtableShim(..) = instance.def {\n-                // Modify `fn(self, ...)` to `fn(self: *mut Self, ...)`.\n-                sig = sig.map_bound(|mut sig| {\n-                    let mut inputs_and_output = sig.inputs_and_output.to_vec();\n-                    inputs_and_output[0] = tcx.mk_mut_ptr(inputs_and_output[0]);\n-                    sig.inputs_and_output = tcx.intern_type_list(&inputs_and_output);\n-                    sig\n-                });\n-            }\n-            sig\n-        }\n-        ty::Closure(def_id, substs) => {\n-            let sig = substs.as_closure().sig();\n-\n-            let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-            sig.map_bound(|sig| {\n-                tcx.mk_fn_sig(\n-                    std::iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n-                    sig.output(),\n-                    sig.c_variadic,\n-                    sig.unsafety,\n-                    sig.abi,\n-                )\n-            })\n-        }\n-        ty::Generator(_, substs, _) => {\n-            let sig = substs.as_generator().poly_sig();\n-\n-            let env_region = ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrEnv });\n-            let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n-\n-            let pin_did = tcx.require_lang_item(rustc_hir::LangItem::Pin, None);\n-            let pin_adt_ref = tcx.adt_def(pin_did);\n-            let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n-            let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n-\n-            sig.map_bound(|sig| {\n-                let state_did = tcx.require_lang_item(rustc_hir::LangItem::GeneratorState, None);\n-                let state_adt_ref = tcx.adt_def(state_did);\n-                let state_substs =\n-                    tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n-                tcx.mk_fn_sig(\n-                    [env_ty, sig.resume_ty].iter(),\n-                    &ret_ty,\n-                    false,\n-                    rustc_hir::Unsafety::Normal,\n-                    rustc_target::spec::abi::Abi::Rust,\n-                )\n-            })\n-        }\n-        _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n-    }\n-}\n-\n-fn clif_sig_from_fn_sig<'tcx>(\n+fn clif_sig_from_fn_abi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n-    sig: FnSig<'tcx>,\n-    span: Span,\n-    is_vtable_fn: bool,\n-    requires_caller_location: bool,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n ) -> Signature {\n-    let abi = match sig.abi {\n-        Abi::System => Abi::C,\n-        abi => abi,\n-    };\n-    let (call_conv, inputs, output): (CallConv, Vec<Ty<'tcx>>, Ty<'tcx>) = match abi {\n-        Abi::Rust => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::C | Abi::Unadjusted => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        Abi::SysV64 => (CallConv::SystemV, sig.inputs().to_vec(), sig.output()),\n-        Abi::RustCall => {\n-            assert_eq!(sig.inputs().len(), 2);\n-            let extra_args = match sig.inputs().last().unwrap().kind() {\n-                ty::Tuple(ref tupled_arguments) => tupled_arguments,\n-                _ => bug!(\"argument to function with \\\"rust-call\\\" ABI is not a tuple\"),\n-            };\n-            let mut inputs: Vec<Ty<'tcx>> = vec![sig.inputs()[0]];\n-            inputs.extend(extra_args.types());\n-            (CallConv::triple_default(triple), inputs, sig.output())\n+    let call_conv = match fn_abi.conv {\n+        Conv::Rust | Conv::C => CallConv::triple_default(triple),\n+        Conv::X86_64SysV => CallConv::SystemV,\n+        Conv::X86_64Win64 => CallConv::WindowsFastcall,\n+        Conv::ArmAapcs\n+        | Conv::Msp430Intr\n+        | Conv::PtxKernel\n+        | Conv::X86Fastcall\n+        | Conv::X86Intr\n+        | Conv::X86Stdcall\n+        | Conv::X86ThisCall\n+        | Conv::X86VectorCall\n+        | Conv::AmdGpuKernel\n+        | Conv::AvrInterrupt\n+        | Conv::AvrNonBlockingInterrupt => {\n+            todo!(\"{:?}\", fn_abi.conv)\n         }\n-        Abi::System => unreachable!(),\n-        Abi::RustIntrinsic => (\n-            CallConv::triple_default(triple),\n-            sig.inputs().to_vec(),\n-            sig.output(),\n-        ),\n-        _ => unimplemented!(\"unsupported abi {:?}\", sig.abi),\n     };\n-\n-    let inputs = inputs\n-        .into_iter()\n-        .enumerate()\n-        .map(|(i, ty)| {\n-            let mut layout = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap();\n-            if i == 0 && is_vtable_fn {\n-                // Virtual calls turn their self param into a thin pointer.\n-                // See https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src/librustc/ty/layout.rs#L2519-L2572 for more info\n-                layout = tcx\n-                    .layout_of(ParamEnv::reveal_all().and(tcx.mk_mut_ptr(tcx.mk_unit())))\n-                    .unwrap();\n-            }\n-            let pass_mode = get_pass_mode(tcx, layout);\n-            if abi != Abi::Rust && abi != Abi::RustCall && abi != Abi::RustIntrinsic {\n-                match pass_mode {\n-                    PassMode::NoPass | PassMode::ByVal(_) => {}\n-                    PassMode::ByRef { size: Some(size) } => {\n-                        let purpose = ArgumentPurpose::StructArgument(u32::try_from(size.bytes()).expect(\"struct too big to pass on stack\"));\n-                        return EmptySinglePair::Single(AbiParam::special(pointer_ty(tcx), purpose)).into_iter();\n-                    }\n-                    PassMode::ByValPair(_, _) | PassMode::ByRef { size: None } => {\n-                        tcx.sess.span_warn(\n-                            span,\n-                            &format!(\n-                                \"Argument of type `{:?}` with pass mode `{:?}` is not yet supported \\\n-                                for non-rust abi `{}`. Calling this function may result in a crash.\",\n-                                layout.ty,\n-                                pass_mode,\n-                                abi,\n-                            ),\n-                        );\n-                    }\n-                }\n-            }\n-            pass_mode.get_param_ty(tcx).map(AbiParam::new).into_iter()\n-        })\n+    let inputs = fn_abi\n+        .args\n+        .iter()\n+        .map(|arg_abi| arg_abi.get_abi_param(tcx).into_iter())\n         .flatten();\n \n-    let (mut params, returns): (Vec<_>, Vec<_>) = match get_pass_mode(\n-        tcx,\n-        tcx.layout_of(ParamEnv::reveal_all().and(output)).unwrap(),\n-    ) {\n-        PassMode::NoPass => (inputs.collect(), vec![]),\n-        PassMode::ByVal(ret_ty) => (inputs.collect(), vec![AbiParam::new(ret_ty)]),\n-        PassMode::ByValPair(ret_ty_a, ret_ty_b) => (\n-            inputs.collect(),\n-            vec![AbiParam::new(ret_ty_a), AbiParam::new(ret_ty_b)],\n-        ),\n-        PassMode::ByRef { size: Some(_) } => {\n-            (\n-                Some(pointer_ty(tcx)) // First param is place to put return val\n-                    .into_iter()\n-                    .map(|ty| AbiParam::special(ty, ArgumentPurpose::StructReturn))\n-                    .chain(inputs)\n-                    .collect(),\n-                vec![],\n-            )\n-        }\n-        PassMode::ByRef { size: None } => todo!(),\n-    };\n-\n-    if requires_caller_location {\n-        params.push(AbiParam::new(pointer_ty(tcx)));\n-    }\n+    let (return_ptr, returns) = fn_abi.ret.get_abi_return(tcx);\n+    // Sometimes the first param is an pointer to the place where the return value needs to be stored.\n+    let params: Vec<_> = return_ptr.into_iter().chain(inputs).collect();\n \n     Signature {\n         params,\n@@ -207,30 +58,17 @@ fn clif_sig_from_fn_sig<'tcx>(\n     }\n }\n \n-pub(crate) fn get_function_name_and_sig<'tcx>(\n+pub(crate) fn get_function_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     triple: &target_lexicon::Triple,\n     inst: Instance<'tcx>,\n-    support_vararg: bool,\n-) -> (String, Signature) {\n+) -> Signature {\n     assert!(!inst.substs.needs_infer());\n-    let fn_sig = tcx\n-        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_sig_for_fn_abi(tcx, inst));\n-    if fn_sig.c_variadic && !support_vararg {\n-        tcx.sess.span_fatal(\n-            tcx.def_span(inst.def_id()),\n-            \"Variadic function definitions are not yet supported\",\n-        );\n-    }\n-    let sig = clif_sig_from_fn_sig(\n+    clif_sig_from_fn_abi(\n         tcx,\n         triple,\n-        fn_sig,\n-        tcx.def_span(inst.def_id()),\n-        false,\n-        inst.def.requires_caller_location(tcx),\n-    );\n-    (tcx.symbol_name(inst).name.to_string(), sig)\n+        &FnAbi::of_instance(&RevealAllLayoutCx(tcx), inst, &[]),\n+    )\n }\n \n /// Instance must be monomorphized\n@@ -239,7 +77,8 @@ pub(crate) fn import_function<'tcx>(\n     module: &mut impl Module,\n     inst: Instance<'tcx>,\n ) -> FuncId {\n-    let (name, sig) = get_function_name_and_sig(tcx, module.isa().triple(), inst, true);\n+    let name = tcx.symbol_name(inst).name.to_string();\n+    let sig = get_function_sig(tcx, module.isa().triple(), inst);\n     module\n         .declare_function(&name, Linkage::Import, &sig)\n         .unwrap()\n@@ -263,13 +102,13 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n     pub(crate) fn lib_call(\n         &mut self,\n         name: &str,\n-        input_tys: Vec<types::Type>,\n-        output_tys: Vec<types::Type>,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n         args: &[Value],\n     ) -> &[Value] {\n         let sig = Signature {\n-            params: input_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output_tys.iter().cloned().map(AbiParam::new).collect(),\n+            params,\n+            returns,\n             call_conv: CallConv::triple_default(self.triple()),\n         };\n         let func_id = self\n@@ -301,16 +140,18 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n             .iter()\n             .map(|arg| {\n                 (\n-                    self.clif_type(arg.layout().ty).unwrap(),\n+                    AbiParam::new(self.clif_type(arg.layout().ty).unwrap()),\n                     arg.load_scalar(self),\n                 )\n             })\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types().map(|ty| self.clif_type(ty).unwrap()).collect()\n+            tup.types()\n+                .map(|ty| AbiParam::new(self.clif_type(ty).unwrap()))\n+                .collect()\n         } else {\n-            vec![self.clif_type(return_ty).unwrap()]\n+            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n         let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n         match *ret_vals {\n@@ -352,12 +193,25 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     start_block: Block,\n ) {\n+    fx.bcx.append_block_params_for_function_params(start_block);\n+\n+    fx.bcx.switch_to_block(start_block);\n+    fx.bcx.ins().nop();\n+\n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n     #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n-    let ret_place = self::returning::codegen_return_param(fx, &ssa_analyzed, start_block);\n+    let mut block_params_iter = fx\n+        .bcx\n+        .func\n+        .dfg\n+        .block_params(start_block)\n+        .to_vec()\n+        .into_iter();\n+    let ret_place =\n+        self::returning::codegen_return_param(fx, &ssa_analyzed, &mut block_params_iter);\n     assert_eq!(fx.local_map.push(ret_place), RETURN_PLACE);\n \n     // None means pass_mode == NoPass\n@@ -366,6 +220,9 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n         Spread(Vec<Option<CValue<'tcx>>>),\n     }\n \n+    let fn_abi = fx.fn_abi.take().unwrap();\n+    let mut arg_abis_iter = fn_abi.args.iter();\n+\n     let func_params = fx\n         .mir\n         .args_iter()\n@@ -385,14 +242,18 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n                 };\n \n                 let mut params = Vec::new();\n-                for (i, arg_ty) in tupled_arg_tys.types().enumerate() {\n-                    let param = cvalue_for_param(fx, start_block, Some(local), Some(i), arg_ty);\n+                for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n+                    let arg_abi = arg_abis_iter.next().unwrap();\n+                    let param =\n+                        cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);\n                     params.push(param);\n                 }\n \n                 (local, ArgKind::Spread(params), arg_ty)\n             } else {\n-                let param = cvalue_for_param(fx, start_block, Some(local), None, arg_ty);\n+                let arg_abi = arg_abis_iter.next().unwrap();\n+                let param =\n+                    cvalue_for_param(fx, Some(local), None, arg_abi, &mut block_params_iter);\n                 (local, ArgKind::Normal(param), arg_ty)\n             }\n         })\n@@ -401,13 +262,14 @@ pub(crate) fn codegen_fn_prelude<'tcx>(\n     assert!(fx.caller_location.is_none());\n     if fx.instance.def.requires_caller_location(fx.tcx) {\n         // Store caller location for `#[track_caller]`.\n-        fx.caller_location = Some(\n-            cvalue_for_param(fx, start_block, None, None, fx.tcx.caller_location_ty()).unwrap(),\n-        );\n+        let arg_abi = arg_abis_iter.next().unwrap();\n+        fx.caller_location =\n+            Some(cvalue_for_param(fx, None, None, arg_abi, &mut block_params_iter).unwrap());\n     }\n \n-    fx.bcx.switch_to_block(start_block);\n-    fx.bcx.ins().nop();\n+    assert!(arg_abis_iter.next().is_none(), \"ArgAbi left behind\");\n+    fx.fn_abi = Some(fn_abi);\n+    assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n     #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n@@ -533,6 +395,21 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n         None\n     };\n \n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+\n     let is_cold = instance\n         .map(|inst| {\n             fx.tcx\n@@ -570,8 +447,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     //   | indirect call target\n     //   |         | the first argument to be passed\n-    //   v         v          v virtual calls are special cased below\n-    let (func_ref, first_arg, is_virtual_call) = match instance {\n+    //   v         v\n+    let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance {\n             def: InstanceDef::Virtual(_, idx),\n@@ -582,23 +459,19 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n-                    format!(\n-                        \"virtual call; self arg pass mode: {:?}\",\n-                        get_pass_mode(fx.tcx, args[0].layout())\n-                    ),\n+                    format!(\"virtual call; self arg pass mode: {:?}\", &fn_abi.args[0],),\n                 );\n             }\n             let (ptr, method) = crate::vtable::get_ptr_and_method_ref(fx, args[0], idx);\n-            (Some(method), Single(ptr), true)\n+            (Some(method), smallvec![ptr])\n         }\n \n         // Normal call\n         Some(_) => (\n             None,\n             args.get(0)\n-                .map(|arg| adjust_arg_for_abi(fx, *arg))\n-                .unwrap_or(Empty),\n-            false,\n+                .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n+                .unwrap_or(smallvec![]),\n         ),\n \n         // Indirect call\n@@ -612,23 +485,27 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             (\n                 Some(func),\n                 args.get(0)\n-                    .map(|arg| adjust_arg_for_abi(fx, *arg))\n-                    .unwrap_or(Empty),\n-                false,\n+                    .map(|arg| adjust_arg_for_abi(fx, *arg, &fn_abi.args[0]))\n+                    .unwrap_or(smallvec![]),\n             )\n         }\n     };\n \n     let ret_place = destination.map(|(place, _)| place);\n-    let (call_inst, call_args) =\n-        self::returning::codegen_with_call_return_arg(fx, fn_sig, ret_place, |fx, return_ptr| {\n+    let (call_inst, call_args) = self::returning::codegen_with_call_return_arg(\n+        fx,\n+        &fn_abi.ret,\n+        ret_place,\n+        |fx, return_ptr| {\n+            let regular_args_count = args.len();\n             let mut call_args: Vec<Value> = return_ptr\n                 .into_iter()\n                 .chain(first_arg.into_iter())\n                 .chain(\n                     args.into_iter()\n+                        .enumerate()\n                         .skip(1)\n-                        .map(|arg| adjust_arg_for_abi(fx, arg).into_iter())\n+                        .map(|(i, arg)| adjust_arg_for_abi(fx, arg, &fn_abi.args[i]).into_iter())\n                         .flatten(),\n                 )\n                 .collect::<Vec<_>>();\n@@ -639,18 +516,17 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             {\n                 // Pass the caller location for `#[track_caller]`.\n                 let caller_location = fx.get_caller_location(span);\n-                call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                call_args.extend(\n+                    adjust_arg_for_abi(fx, caller_location, &fn_abi.args[regular_args_count])\n+                        .into_iter(),\n+                );\n+                assert_eq!(fn_abi.args.len(), regular_args_count + 1);\n+            } else {\n+                assert_eq!(fn_abi.args.len(), regular_args_count);\n             }\n \n             let call_inst = if let Some(func_ref) = func_ref {\n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    span,\n-                    is_virtual_call,\n-                    false, // calls through function pointers never pass the caller location\n-                );\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, func_ref, &call_args)\n             } else {\n@@ -660,7 +536,8 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             };\n \n             (call_inst, call_args)\n-        });\n+        },\n+    );\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n@@ -701,37 +578,33 @@ pub(crate) fn codegen_drop<'tcx>(\n     drop_place: CPlace<'tcx>,\n ) {\n     let ty = drop_place.layout().ty;\n-    let drop_fn = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n+    let drop_instance = Instance::resolve_drop_in_place(fx.tcx, ty).polymorphize(fx.tcx);\n \n-    if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+    if let ty::InstanceDef::DropGlue(_, None) = drop_instance.def {\n         // we don't actually need to drop anything\n     } else {\n-        let drop_fn_ty = drop_fn.ty(fx.tcx, ParamEnv::reveal_all());\n-        let fn_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-            ParamEnv::reveal_all(),\n-            drop_fn_ty.fn_sig(fx.tcx),\n-        );\n-        assert_eq!(fn_sig.output(), fx.tcx.mk_unit());\n-\n         match ty.kind() {\n             ty::Dynamic(..) => {\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n \n-                let sig = clif_sig_from_fn_sig(\n-                    fx.tcx,\n-                    fx.triple(),\n-                    fn_sig,\n-                    span,\n-                    true,\n-                    false, // `drop_in_place` is never `#[track_caller]`\n-                );\n+                // FIXME(eddyb) perhaps move some of this logic into\n+                // `Instance::resolve_drop_in_place`?\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n+                    substs: drop_instance.substs,\n+                };\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), virtual_drop, &[]);\n+\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.triple(), &fn_abi);\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }\n             _ => {\n-                assert!(!matches!(drop_fn.def, InstanceDef::Virtual(_, _)));\n+                assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n+\n+                let fn_abi = FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), drop_instance, &[]);\n \n                 let arg_value = drop_place.place_ref(\n                     fx,\n@@ -743,17 +616,19 @@ pub(crate) fn codegen_drop<'tcx>(\n                         },\n                     )),\n                 );\n-                let arg_value = adjust_arg_for_abi(fx, arg_value);\n+                let arg_value = adjust_arg_for_abi(fx, arg_value, &fn_abi.args[0]);\n \n                 let mut call_args: Vec<Value> = arg_value.into_iter().collect::<Vec<_>>();\n \n-                if drop_fn.def.requires_caller_location(fx.tcx) {\n+                if drop_instance.def.requires_caller_location(fx.tcx) {\n                     // Pass the caller location for `#[track_caller]`.\n                     let caller_location = fx.get_caller_location(span);\n-                    call_args.extend(adjust_arg_for_abi(fx, caller_location).into_iter());\n+                    call_args.extend(\n+                        adjust_arg_for_abi(fx, caller_location, &fn_abi.args[1]).into_iter(),\n+                    );\n                 }\n \n-                let func_ref = fx.get_function_ref(drop_fn);\n+                let func_ref = fx.get_function_ref(drop_instance);\n                 fx.bcx.ins().call(func_ref, &call_args);\n             }\n         }"}, {"sha": "2f91e83386ceb7fb15291e58abec9f20ff8afe25", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 292, "deletions": 127, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -1,140 +1,279 @@\n //! Argument passing\n \n use crate::prelude::*;\n+use crate::value_and_place::assert_assignable;\n \n-pub(super) use EmptySinglePair::*;\n+use cranelift_codegen::ir::{ArgumentExtension, ArgumentPurpose};\n+use rustc_target::abi::call::{\n+    ArgAbi, ArgAttributes, ArgExtension as RustcArgExtension, CastTarget, PassMode, Reg, RegKind,\n+};\n+use smallvec::{smallvec, SmallVec};\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum PassMode {\n-    NoPass,\n-    ByVal(Type),\n-    ByValPair(Type, Type),\n-    ByRef { size: Option<Size> },\n+pub(super) trait ArgAbiExt<'tcx> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]>;\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>);\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub(super) enum EmptySinglePair<T> {\n-    Empty,\n-    Single(T),\n-    Pair(T, T),\n+fn reg_to_abi_param(reg: Reg) -> AbiParam {\n+    let clif_ty = match (reg.kind, reg.size.bytes()) {\n+        (RegKind::Integer, 1) => types::I8,\n+        (RegKind::Integer, 2) => types::I16,\n+        (RegKind::Integer, 4) => types::I32,\n+        (RegKind::Integer, 8) => types::I64,\n+        (RegKind::Integer, 16) => types::I128,\n+        (RegKind::Float, 4) => types::F32,\n+        (RegKind::Float, 8) => types::F64,\n+        (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+        _ => unreachable!(\"{:?}\", reg),\n+    };\n+    AbiParam::new(clif_ty)\n }\n \n-impl<T> EmptySinglePair<T> {\n-    pub(super) fn into_iter(self) -> EmptySinglePairIter<T> {\n-        EmptySinglePairIter(self)\n-    }\n-\n-    pub(super) fn map<U>(self, mut f: impl FnMut(T) -> U) -> EmptySinglePair<U> {\n-        match self {\n-            Empty => Empty,\n-            Single(v) => Single(f(v)),\n-            Pair(a, b) => Pair(f(a), f(b)),\n-        }\n+fn apply_arg_attrs_to_abi_param(mut param: AbiParam, arg_attrs: ArgAttributes) -> AbiParam {\n+    match arg_attrs.arg_ext {\n+        RustcArgExtension::None => {}\n+        RustcArgExtension::Zext => param.extension = ArgumentExtension::Uext,\n+        RustcArgExtension::Sext => param.extension = ArgumentExtension::Sext,\n     }\n+    param\n }\n \n-pub(super) struct EmptySinglePairIter<T>(EmptySinglePair<T>);\n-\n-impl<T> Iterator for EmptySinglePairIter<T> {\n-    type Item = T;\n+fn cast_target_to_abi_params(cast: CastTarget) -> SmallVec<[AbiParam; 2]> {\n+    let (rest_count, rem_bytes) = if cast.rest.unit.size.bytes() == 0 {\n+        (0, 0)\n+    } else {\n+        (\n+            cast.rest.total.bytes() / cast.rest.unit.size.bytes(),\n+            cast.rest.total.bytes() % cast.rest.unit.size.bytes(),\n+        )\n+    };\n \n-    fn next(&mut self) -> Option<T> {\n-        match std::mem::replace(&mut self.0, Empty) {\n-            Empty => None,\n-            Single(v) => Some(v),\n-            Pair(a, b) => {\n-                self.0 = Single(b);\n-                Some(a)\n-            }\n+    if cast.prefix.iter().all(|x| x.is_none()) {\n+        // Simplify to a single unit when there is no prefix and size <= unit size\n+        if cast.rest.total <= cast.rest.unit.size {\n+            let clif_ty = match (cast.rest.unit.kind, cast.rest.unit.size.bytes()) {\n+                (RegKind::Integer, 1) => types::I8,\n+                (RegKind::Integer, 2) => types::I16,\n+                (RegKind::Integer, 3..=4) => types::I32,\n+                (RegKind::Integer, 5..=8) => types::I64,\n+                (RegKind::Integer, 9..=16) => types::I128,\n+                (RegKind::Float, 4) => types::F32,\n+                (RegKind::Float, 8) => types::F64,\n+                (RegKind::Vector, size) => types::I8.by(u16::try_from(size).unwrap()).unwrap(),\n+                _ => unreachable!(\"{:?}\", cast.rest.unit),\n+            };\n+            return smallvec![AbiParam::new(clif_ty)];\n         }\n     }\n-}\n \n-impl<T: std::fmt::Debug> EmptySinglePair<T> {\n-    pub(super) fn assert_single(self) -> T {\n-        match self {\n-            Single(v) => v,\n-            _ => panic!(\"Called assert_single on {:?}\", self),\n-        }\n-    }\n+    // Create list of fields in the main structure\n+    let mut args = cast\n+        .prefix\n+        .iter()\n+        .flatten()\n+        .map(|&kind| {\n+            reg_to_abi_param(Reg {\n+                kind,\n+                size: cast.prefix_chunk_size,\n+            })\n+        })\n+        .chain((0..rest_count).map(|_| reg_to_abi_param(cast.rest.unit)))\n+        .collect::<SmallVec<_>>();\n \n-    pub(super) fn assert_pair(self) -> (T, T) {\n-        match self {\n-            Pair(a, b) => (a, b),\n-            _ => panic!(\"Called assert_pair on {:?}\", self),\n-        }\n+    // Append final integer\n+    if rem_bytes != 0 {\n+        // Only integers can be really split further.\n+        assert_eq!(cast.rest.unit.kind, RegKind::Integer);\n+        args.push(reg_to_abi_param(Reg {\n+            kind: RegKind::Integer,\n+            size: Size::from_bytes(rem_bytes),\n+        }));\n     }\n-}\n \n-impl PassMode {\n-    pub(super) fn get_param_ty(self, tcx: TyCtxt<'_>) -> EmptySinglePair<Type> {\n-        match self {\n-            PassMode::NoPass => Empty,\n-            PassMode::ByVal(clif_type) => Single(clif_type),\n-            PassMode::ByValPair(a, b) => Pair(a, b),\n-            PassMode::ByRef { size: Some(_) } => Single(pointer_ty(tcx)),\n-            PassMode::ByRef { size: None } => Pair(pointer_ty(tcx), pointer_ty(tcx)),\n-        }\n-    }\n+    args\n }\n \n-pub(super) fn get_pass_mode<'tcx>(tcx: TyCtxt<'tcx>, layout: TyAndLayout<'tcx>) -> PassMode {\n-    if layout.is_zst() {\n-        // WARNING zst arguments must never be passed, as that will break CastKind::ClosureFnPointer\n-        PassMode::NoPass\n-    } else {\n-        match &layout.abi {\n-            Abi::Uninhabited => PassMode::NoPass,\n-            Abi::Scalar(scalar) => PassMode::ByVal(scalar_to_clif_type(tcx, scalar.clone())),\n-            Abi::ScalarPair(a, b) => {\n-                let a = scalar_to_clif_type(tcx, a.clone());\n-                let b = scalar_to_clif_type(tcx, b.clone());\n-                if a == types::I128 && b == types::I128 {\n-                    // Returning (i128, i128) by-val-pair would take 4 regs, while only 3 are\n-                    // available on x86_64. Cranelift gets confused when too many return params\n-                    // are used.\n-                    PassMode::ByRef {\n-                        size: Some(layout.size),\n-                    }\n-                } else {\n-                    PassMode::ByValPair(a, b)\n+impl<'tcx> ArgAbiExt<'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n+    fn get_abi_param(&self, tcx: TyCtxt<'tcx>) -> SmallVec<[AbiParam; 2]> {\n+        match self.mode {\n+            PassMode::Ignore => smallvec![],\n+            PassMode::Direct(attrs) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => {\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::new(scalar_to_clif_type(tcx, scalar.clone())),\n+                        attrs\n+                    )]\n                 }\n-            }\n-\n-            // FIXME implement Vector Abi in a cg_llvm compatible way\n-            Abi::Vector { .. } => {\n-                if let Some(vector_ty) = crate::intrinsics::clif_vector_type(tcx, layout) {\n-                    PassMode::ByVal(vector_ty)\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    smallvec![AbiParam::new(vector_ty)]\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Pair(attrs_a, attrs_b) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    smallvec![\n+                        apply_arg_attrs_to_abi_param(AbiParam::new(a), attrs_a),\n+                        apply_arg_attrs_to_abi_param(AbiParam::new(b), attrs_b),\n+                    ]\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Cast(cast) => cast_target_to_abi_params(cast),\n+            PassMode::Indirect {\n+                attrs,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                if on_stack {\n+                    let size = u32::try_from(self.layout.size.bytes()).unwrap();\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::special(pointer_ty(tcx), ArgumentPurpose::StructArgument(size),),\n+                        attrs\n+                    )]\n                 } else {\n-                    PassMode::ByRef {\n-                        size: Some(layout.size),\n-                    }\n+                    smallvec![apply_arg_attrs_to_abi_param(\n+                        AbiParam::new(pointer_ty(tcx)),\n+                        attrs\n+                    )]\n                 }\n             }\n+            PassMode::Indirect {\n+                attrs,\n+                extra_attrs: Some(extra_attrs),\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                smallvec![\n+                    apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), attrs),\n+                    apply_arg_attrs_to_abi_param(AbiParam::new(pointer_ty(tcx)), extra_attrs),\n+                ]\n+            }\n+        }\n+    }\n \n-            Abi::Aggregate { sized: true } => PassMode::ByRef {\n-                size: Some(layout.size),\n+    fn get_abi_return(&self, tcx: TyCtxt<'tcx>) -> (Option<AbiParam>, Vec<AbiParam>) {\n+        match self.mode {\n+            PassMode::Ignore => (None, vec![]),\n+            PassMode::Direct(_) => match &self.layout.abi {\n+                Abi::Scalar(scalar) => (\n+                    None,\n+                    vec![AbiParam::new(scalar_to_clif_type(tcx, scalar.clone()))],\n+                ),\n+                Abi::Vector { .. } => {\n+                    let vector_ty = crate::intrinsics::clif_vector_type(tcx, self.layout).unwrap();\n+                    (None, vec![AbiParam::new(vector_ty)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n+            },\n+            PassMode::Pair(_, _) => match &self.layout.abi {\n+                Abi::ScalarPair(a, b) => {\n+                    let a = scalar_to_clif_type(tcx, a.clone());\n+                    let b = scalar_to_clif_type(tcx, b.clone());\n+                    (None, vec![AbiParam::new(a), AbiParam::new(b)])\n+                }\n+                _ => unreachable!(\"{:?}\", self.layout.abi),\n             },\n-            Abi::Aggregate { sized: false } => PassMode::ByRef { size: None },\n+            PassMode::Cast(cast) => (None, cast_target_to_abi_params(cast).into_iter().collect()),\n+            PassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: None,\n+                on_stack,\n+            } => {\n+                assert!(!on_stack);\n+                (\n+                    Some(AbiParam::special(\n+                        pointer_ty(tcx),\n+                        ArgumentPurpose::StructReturn,\n+                    )),\n+                    vec![],\n+                )\n+            }\n+            PassMode::Indirect {\n+                attrs: _,\n+                extra_attrs: Some(_),\n+                on_stack: _,\n+            } => unreachable!(\"unsized return value\"),\n         }\n     }\n }\n \n+pub(super) fn to_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    arg: CValue<'tcx>,\n+    cast: CastTarget,\n+) -> SmallVec<[Value; 2]> {\n+    let (ptr, meta) = arg.force_stack(fx);\n+    assert!(meta.is_none());\n+    let mut offset = 0;\n+    cast_target_to_abi_params(cast)\n+        .into_iter()\n+        .map(|param| {\n+            let val = ptr\n+                .offset_i64(fx, offset)\n+                .load(fx, param.value_type, MemFlags::new());\n+            offset += i64::from(param.value_type.bytes());\n+            val\n+        })\n+        .collect()\n+}\n+\n+pub(super) fn from_casted_value<'tcx>(\n+    fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n+    block_params: &[Value],\n+    layout: TyAndLayout<'tcx>,\n+    cast: CastTarget,\n+) -> CValue<'tcx> {\n+    let abi_params = cast_target_to_abi_params(cast);\n+    let size: u32 = abi_params\n+        .iter()\n+        .map(|param| param.value_type.bytes())\n+        .sum();\n+    // Stack slot size may be bigger for for example `[u8; 3]` which is packed into an `i32`.\n+    assert!(u64::from(size) >= layout.size.bytes());\n+    let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+        kind: StackSlotKind::ExplicitSlot,\n+        // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+        // specify stack slot alignment.\n+        size: (size + 15) / 16 * 16,\n+        offset: None,\n+    });\n+    let ptr = Pointer::new(fx.bcx.ins().stack_addr(pointer_ty(fx.tcx), stack_slot, 0));\n+    let mut offset = 0;\n+    let mut block_params_iter = block_params.into_iter().copied();\n+    for param in abi_params {\n+        let val = ptr.offset_i64(fx, offset).store(\n+            fx,\n+            block_params_iter.next().unwrap(),\n+            MemFlags::new(),\n+        );\n+        offset += i64::from(param.value_type.bytes());\n+        val\n+    }\n+    assert_eq!(block_params_iter.next(), None, \"Leftover block param\");\n+    CValue::by_ref(ptr, layout)\n+}\n+\n /// Get a set of values to be passed as function arguments.\n pub(super) fn adjust_arg_for_abi<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     arg: CValue<'tcx>,\n-) -> EmptySinglePair<Value> {\n-    match get_pass_mode(fx.tcx, arg.layout()) {\n-        PassMode::NoPass => Empty,\n-        PassMode::ByVal(_) => Single(arg.load_scalar(fx)),\n-        PassMode::ByValPair(_, _) => {\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+) -> SmallVec<[Value; 2]> {\n+    assert_assignable(fx, arg.layout().ty, arg_abi.layout.ty);\n+    match arg_abi.mode {\n+        PassMode::Ignore => smallvec![],\n+        PassMode::Direct(_) => smallvec![arg.load_scalar(fx)],\n+        PassMode::Pair(_, _) => {\n             let (a, b) = arg.load_scalar_pair(fx);\n-            Pair(a, b)\n+            smallvec![a, b]\n         }\n-        PassMode::ByRef { size: _ } => match arg.force_stack(fx) {\n-            (ptr, None) => Single(ptr.get_addr(fx)),\n-            (ptr, Some(meta)) => Pair(ptr.get_addr(fx), meta),\n+        PassMode::Cast(cast) => to_casted_value(fx, arg, cast),\n+        PassMode::Indirect { .. } => match arg.force_stack(fx) {\n+            (ptr, None) => smallvec![ptr.get_addr(fx)],\n+            (ptr, Some(meta)) => smallvec![ptr.get_addr(fx), meta],\n         },\n     }\n }\n@@ -143,46 +282,72 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n-    start_block: Block,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n     #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n-    arg_ty: Ty<'tcx>,\n+    arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n-    let layout = fx.layout_of(arg_ty);\n-    let pass_mode = get_pass_mode(fx.tcx, layout);\n-\n-    if let PassMode::NoPass = pass_mode {\n-        return None;\n-    }\n-\n-    let clif_types = pass_mode.get_param_ty(fx.tcx);\n-    let block_params = clif_types.map(|t| fx.bcx.append_block_param(start_block, t));\n+    let block_params = arg_abi\n+        .get_abi_param(fx.tcx)\n+        .into_iter()\n+        .map(|abi_param| {\n+            let block_param = block_params_iter.next().unwrap();\n+            assert_eq!(\n+                fx.bcx.func.dfg.value_type(block_param),\n+                abi_param.value_type\n+            );\n+            block_param\n+        })\n+        .collect::<SmallVec<[_; 2]>>();\n \n     #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\",\n         local,\n         local_field,\n-        block_params,\n-        pass_mode,\n-        arg_ty,\n+        &block_params,\n+        arg_abi.mode,\n+        arg_abi.layout,\n     );\n \n-    match pass_mode {\n-        PassMode::NoPass => unreachable!(),\n-        PassMode::ByVal(_) => Some(CValue::by_val(block_params.assert_single(), layout)),\n-        PassMode::ByValPair(_, _) => {\n-            let (a, b) = block_params.assert_pair();\n-            Some(CValue::by_val_pair(a, b, layout))\n+    match arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Direct(_) => {\n+            assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n+            Some(CValue::by_val(block_params[0], arg_abi.layout))\n+        }\n+        PassMode::Pair(_, _) => {\n+            assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n+            Some(CValue::by_val_pair(\n+                block_params[0],\n+                block_params[1],\n+                arg_abi.layout,\n+            ))\n+        }\n+        PassMode::Cast(cast) => Some(from_casted_value(fx, &block_params, arg_abi.layout, cast)),\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n+            assert_eq!(block_params.len(), 1, \"{:?}\", block_params);\n+            Some(CValue::by_ref(\n+                Pointer::new(block_params[0]),\n+                arg_abi.layout,\n+            ))\n         }\n-        PassMode::ByRef { size: Some(_) } => Some(CValue::by_ref(\n-            Pointer::new(block_params.assert_single()),\n-            layout,\n-        )),\n-        PassMode::ByRef { size: None } => {\n-            let (ptr, meta) = block_params.assert_pair();\n-            Some(CValue::by_ref_unsized(Pointer::new(ptr), meta, layout))\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => {\n+            assert_eq!(block_params.len(), 2, \"{:?}\", block_params);\n+            Some(CValue::by_ref_unsized(\n+                Pointer::new(block_params[0]),\n+                block_params[1],\n+                arg_abi.layout,\n+            ))\n         }\n     }\n }"}, {"sha": "a382963bf1ed743b0963690b2fb3800c3da3ef40", "filename": "src/abi/returning.rs", "status": "modified", "additions": 146, "deletions": 48, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -1,21 +1,57 @@\n //! Return value handling\n \n-use crate::abi::pass_mode::*;\n use crate::prelude::*;\n \n-fn return_layout<'a, 'tcx>(fx: &mut FunctionCx<'a, 'tcx, impl Module>) -> TyAndLayout<'tcx> {\n-    fx.layout_of(fx.monomorphize(&fx.mir.local_decls[RETURN_PLACE].ty))\n-}\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n+use smallvec::{smallvec, SmallVec};\n \n /// Can the given type be returned into an ssa var or does it need to be returned on the stack.\n pub(crate) fn can_return_to_ssa_var<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    dest_layout: TyAndLayout<'tcx>,\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    func: &mir::Operand<'tcx>,\n+    args: &[mir::Operand<'tcx>],\n ) -> bool {\n-    match get_pass_mode(tcx, dest_layout) {\n-        PassMode::NoPass | PassMode::ByVal(_) | PassMode::ByValPair(_, _) => true,\n-        // FIXME Make it possible to return ByRef to an ssa var.\n-        PassMode::ByRef { size: _ } => false,\n+    let fn_ty = fx.monomorphize(func.ty(fx.mir, fx.tcx));\n+    let fn_sig = fx\n+        .tcx\n+        .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), fn_ty.fn_sig(fx.tcx));\n+\n+    // Handle special calls like instrinsics and empty drop glue.\n+    let instance = if let ty::FnDef(def_id, substs) = *fn_ty.kind() {\n+        let instance = ty::Instance::resolve(fx.tcx, ty::ParamEnv::reveal_all(), def_id, substs)\n+            .unwrap()\n+            .unwrap()\n+            .polymorphize(fx.tcx);\n+\n+        match instance.def {\n+            InstanceDef::Intrinsic(_) | InstanceDef::DropGlue(_, _) => {\n+                return true;\n+            }\n+            _ => Some(instance),\n+        }\n+    } else {\n+        None\n+    };\n+\n+    let extra_args = &args[fn_sig.inputs().len()..];\n+    let extra_args = extra_args\n+        .iter()\n+        .map(|op_arg| fx.monomorphize(op_arg.ty(fx.mir, fx.tcx)))\n+        .collect::<Vec<_>>();\n+    let fn_abi = if let Some(instance) = instance {\n+        FnAbi::of_instance(&RevealAllLayoutCx(fx.tcx), instance, &extra_args)\n+    } else {\n+        FnAbi::of_fn_ptr(\n+            &RevealAllLayoutCx(fx.tcx),\n+            fn_ty.fn_sig(fx.tcx),\n+            &extra_args,\n+        )\n+    };\n+    match fn_abi.ret.mode {\n+        PassMode::Ignore | PassMode::Direct(_) | PassMode::Pair(_, _) => true,\n+        // FIXME Make it possible to return Cast and Indirect to an ssa var.\n+        PassMode::Cast(_) | PassMode::Indirect { .. } => false,\n     }\n }\n \n@@ -24,27 +60,45 @@ pub(crate) fn can_return_to_ssa_var<'tcx>(\n pub(super) fn codegen_return_param<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n     ssa_analyzed: &rustc_index::vec::IndexVec<Local, crate::analyze::SsaKind>,\n-    start_block: Block,\n+    block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> CPlace<'tcx> {\n-    let ret_layout = return_layout(fx);\n-    let ret_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let (ret_place, ret_param) = match ret_pass_mode {\n-        PassMode::NoPass => (CPlace::no_place(ret_layout), Empty),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => {\n+    let (ret_place, ret_param): (_, SmallVec<[_; 2]>) = match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore => (\n+            CPlace::no_place(fx.fn_abi.as_ref().unwrap().ret.layout),\n+            smallvec![],\n+        ),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => {\n             let is_ssa = ssa_analyzed[RETURN_PLACE] == crate::analyze::SsaKind::Ssa;\n             (\n-                super::make_local_place(fx, RETURN_PLACE, ret_layout, is_ssa),\n-                Empty,\n+                super::make_local_place(\n+                    fx,\n+                    RETURN_PLACE,\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                    is_ssa,\n+                ),\n+                smallvec![],\n             )\n         }\n-        PassMode::ByRef { size: Some(_) } => {\n-            let ret_param = fx.bcx.append_block_param(start_block, fx.pointer_type);\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n+            let ret_param = block_params_iter.next().unwrap();\n+            assert_eq!(fx.bcx.func.dfg.value_type(ret_param), pointer_ty(fx.tcx));\n             (\n-                CPlace::for_ptr(Pointer::new(ret_param), ret_layout),\n-                Single(ret_param),\n+                CPlace::for_ptr(\n+                    Pointer::new(ret_param),\n+                    fx.fn_abi.as_ref().unwrap().ret.layout,\n+                ),\n+                smallvec![ret_param],\n             )\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     };\n \n     #[cfg(not(debug_assertions))]\n@@ -56,9 +110,9 @@ pub(super) fn codegen_return_param<'tcx>(\n         \"ret\",\n         Some(RETURN_PLACE),\n         None,\n-        ret_param,\n-        ret_pass_mode,\n-        ret_layout.ty,\n+        &ret_param,\n+        fx.fn_abi.as_ref().unwrap().ret.mode,\n+        fx.fn_abi.as_ref().unwrap().ret.layout,\n     );\n \n     ret_place\n@@ -68,63 +122,107 @@ pub(super) fn codegen_return_param<'tcx>(\n /// returns the call return value(s) if any are written to the correct place.\n pub(super) fn codegen_with_call_return_arg<'tcx, M: Module, T>(\n     fx: &mut FunctionCx<'_, 'tcx, M>,\n-    fn_sig: FnSig<'tcx>,\n+    ret_arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     ret_place: Option<CPlace<'tcx>>,\n     f: impl FnOnce(&mut FunctionCx<'_, 'tcx, M>, Option<Value>) -> (Inst, T),\n ) -> (Inst, T) {\n-    let ret_layout = fx.layout_of(fn_sig.output());\n-\n-    let output_pass_mode = get_pass_mode(fx.tcx, ret_layout);\n-    let return_ptr = match output_pass_mode {\n-        PassMode::NoPass => None,\n-        PassMode::ByRef { size: Some(_) } => match ret_place {\n+    let return_ptr = match ret_arg_abi.mode {\n+        PassMode::Ignore => None,\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => match ret_place {\n             Some(ret_place) => Some(ret_place.to_ptr().get_addr(fx)),\n             None => Some(fx.bcx.ins().iconst(fx.pointer_type, 43)), // FIXME allocate temp stack slot\n         },\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) | PassMode::ByValPair(_, _) => None,\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        PassMode::Direct(_) | PassMode::Pair(_, _) | PassMode::Cast(_) => None,\n     };\n \n     let (call_inst, meta) = f(fx, return_ptr);\n \n-    match output_pass_mode {\n-        PassMode::NoPass => {}\n-        PassMode::ByVal(_) => {\n+    match ret_arg_abi.mode {\n+        PassMode::Ignore => {}\n+        PassMode::Direct(_) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val = fx.bcx.inst_results(call_inst)[0];\n-                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_layout));\n+                ret_place.write_cvalue(fx, CValue::by_val(ret_val, ret_arg_abi.layout));\n             }\n         }\n-        PassMode::ByValPair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             if let Some(ret_place) = ret_place {\n                 let ret_val_a = fx.bcx.inst_results(call_inst)[0];\n                 let ret_val_b = fx.bcx.inst_results(call_inst)[1];\n-                ret_place.write_cvalue(fx, CValue::by_val_pair(ret_val_a, ret_val_b, ret_layout));\n+                ret_place.write_cvalue(\n+                    fx,\n+                    CValue::by_val_pair(ret_val_a, ret_val_b, ret_arg_abi.layout),\n+                );\n             }\n         }\n-        PassMode::ByRef { size: Some(_) } => {}\n-        PassMode::ByRef { size: None } => todo!(),\n+        PassMode::Cast(cast) => {\n+            if let Some(ret_place) = ret_place {\n+                let results = fx\n+                    .bcx\n+                    .inst_results(call_inst)\n+                    .into_iter()\n+                    .copied()\n+                    .collect::<SmallVec<[Value; 2]>>();\n+                let result =\n+                    super::pass_mode::from_casted_value(fx, &results, ret_place.layout(), cast);\n+                ret_place.write_cvalue(fx, result);\n+            }\n+        }\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {}\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n     }\n \n     (call_inst, meta)\n }\n \n /// Codegen a return instruction with the right return value(s) if any.\n pub(crate) fn codegen_return(fx: &mut FunctionCx<'_, '_, impl Module>) {\n-    match get_pass_mode(fx.tcx, return_layout(fx)) {\n-        PassMode::NoPass | PassMode::ByRef { size: Some(_) } => {\n+    match fx.fn_abi.as_ref().unwrap().ret.mode {\n+        PassMode::Ignore\n+        | PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: None,\n+            on_stack: _,\n+        } => {\n             fx.bcx.ins().return_(&[]);\n         }\n-        PassMode::ByRef { size: None } => todo!(),\n-        PassMode::ByVal(_) => {\n+        PassMode::Indirect {\n+            attrs: _,\n+            extra_attrs: Some(_),\n+            on_stack: _,\n+        } => unreachable!(\"unsized return value\"),\n+        PassMode::Direct(_) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let ret_val = place.to_cvalue(fx).load_scalar(fx);\n             fx.bcx.ins().return_(&[ret_val]);\n         }\n-        PassMode::ByValPair(_, _) => {\n+        PassMode::Pair(_, _) => {\n             let place = fx.get_local_place(RETURN_PLACE);\n             let (ret_val_a, ret_val_b) = place.to_cvalue(fx).load_scalar_pair(fx);\n             fx.bcx.ins().return_(&[ret_val_a, ret_val_b]);\n         }\n+        PassMode::Cast(cast) => {\n+            let place = fx.get_local_place(RETURN_PLACE);\n+            let ret_val = place.to_cvalue(fx);\n+            let ret_vals = super::pass_mode::to_casted_value(fx, ret_val, cast);\n+            fx.bcx.ins().return_(&ret_vals);\n+        }\n     }\n }"}, {"sha": "62fbcfe3f7a5df6bda3f4c7b4093b6aa4ba875e7", "filename": "src/analyze.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -40,11 +40,14 @@ pub(crate) fn analyze(fx: &FunctionCx<'_, '_, impl Module>) -> IndexVec<Local, S\n         }\n \n         match &bb.terminator().kind {\n-            TerminatorKind::Call { destination, .. } => {\n+            TerminatorKind::Call {\n+                destination,\n+                func,\n+                args,\n+                ..\n+            } => {\n                 if let Some((dest_place, _dest_bb)) = destination {\n-                    let dest_layout = fx\n-                        .layout_of(fx.monomorphize(&dest_place.ty(&fx.mir.local_decls, fx.tcx).ty));\n-                    if !crate::abi::can_return_to_ssa_var(fx.tcx, dest_layout) {\n+                    if !crate::abi::can_return_to_ssa_var(fx, func, args) {\n                         not_ssa(&mut flag_map, dest_place.local)\n                     }\n                 }"}, {"sha": "4842628a99da7d391cc6371617961290705180f2", "filename": "src/base.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -2,6 +2,8 @@\n \n use rustc_index::vec::IndexVec;\n use rustc_middle::ty::adjustment::PointerCast;\n+use rustc_middle::ty::layout::FnAbiExt;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -19,7 +21,8 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mir = tcx.instance_mir(instance.def);\n \n     // Declare function\n-    let (name, sig) = get_function_name_and_sig(tcx, cx.module.isa().triple(), instance, false);\n+    let name = tcx.symbol_name(instance).name.to_string();\n+    let sig = get_function_sig(tcx, cx.module.isa().triple(), instance);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n \n     cx.cached_context.clear();\n@@ -50,6 +53,7 @@ pub(crate) fn codegen_fn<'tcx>(\n \n         instance,\n         mir,\n+        fn_abi: Some(FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])),\n \n         bcx,\n         block_map,\n@@ -1056,7 +1060,11 @@ pub(crate) fn codegen_panic_inner<'tcx>(\n \n     fx.lib_call(\n         &*symbol_name,\n-        vec![fx.pointer_type, fx.pointer_type, fx.pointer_type],\n+        vec![\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+            AbiParam::new(fx.pointer_type),\n+        ],\n         vec![],\n         args,\n     );"}, {"sha": "866ba90e4ae4ba5d9a73e67216f2ed7bf21872d5", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -1,5 +1,7 @@\n //! Replaces 128-bit operators with lang item calls where necessary\n \n+use cranelift_codegen::ir::ArgumentPurpose;\n+\n use crate::prelude::*;\n \n pub(crate) fn maybe_codegen<'tcx>(\n@@ -24,41 +26,41 @@ pub(crate) fn maybe_codegen<'tcx>(\n             None\n         }\n         BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Add => {\n-            let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_addo\", &[lhs, rhs], out_ty)\n+        BinOp::Mul if !checked => {\n+            let val_ty = if is_signed {\n+                fx.tcx.types.i128\n             } else {\n-                fx.easy_call(\"__rust_u128_addo\", &[lhs, rhs], out_ty)\n-            });\n+                fx.tcx.types.u128\n+            };\n+            Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n         }\n-        BinOp::Sub => {\n+        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n+            assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-            return Some(if is_signed {\n-                fx.easy_call(\"__rust_i128_subo\", &[lhs, rhs], out_ty)\n-            } else {\n-                fx.easy_call(\"__rust_u128_subo\", &[lhs, rhs], out_ty)\n-            });\n-        }\n-        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n-        BinOp::Mul => {\n-            let res = if checked {\n-                let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n-                if is_signed {\n-                    fx.easy_call(\"__rust_i128_mulo\", &[lhs, rhs], out_ty)\n-                } else {\n-                    fx.easy_call(\"__rust_u128_mulo\", &[lhs, rhs], out_ty)\n-                }\n-            } else {\n-                let val_ty = if is_signed {\n-                    fx.tcx.types.i128\n-                } else {\n-                    fx.tcx.types.u128\n-                };\n-                fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty)\n+            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n+            let param_types = vec![\n+                AbiParam::special(pointer_ty(fx.tcx), ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [\n+                out_place.to_ptr().get_addr(fx),\n+                lhs.load_scalar(fx),\n+                rhs.load_scalar(fx),\n+            ];\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Add, false) => \"__rust_u128_addo\",\n+                (BinOp::Add, true) => \"__rust_i128_addo\",\n+                (BinOp::Sub, false) => \"__rust_u128_subo\",\n+                (BinOp::Sub, true) => \"__rust_i128_subo\",\n+                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n+                (BinOp::Mul, true) => \"__rust_i128_mulo\",\n+                _ => unreachable!(),\n             };\n-            Some(res)\n+            fx.lib_call(name, param_types, vec![], &args);\n+            Some(out_place.to_cvalue(fx))\n         }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Div => {\n             assert!(!checked);\n             if is_signed {"}, {"sha": "fbee84e09f7a6e40625dc9728b3eb4dc73e6d20c", "filename": "src/common.rs", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -1,4 +1,5 @@\n use rustc_index::vec::IndexVec;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Integer, Primitive};\n use rustc_target::spec::{HasTargetSpec, Target};\n \n@@ -294,6 +295,7 @@ pub(crate) struct FunctionCx<'clif, 'tcx, M: Module> {\n \n     pub(crate) instance: Instance<'tcx>,\n     pub(crate) mir: &'tcx Body<'tcx>,\n+    pub(crate) fn_abi: Option<FnAbi<'tcx, Ty<'tcx>>>,\n \n     pub(crate) bcx: FunctionBuilder<'clif>,\n     pub(crate) block_map: IndexVec<BasicBlock, Block>,\n@@ -319,16 +321,7 @@ impl<'tcx, M: Module> LayoutOf for FunctionCx<'_, 'tcx, M> {\n     type TyAndLayout = TyAndLayout<'tcx>;\n \n     fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n-        assert!(!ty.still_further_specializable());\n-        self.tcx\n-            .layout_of(ParamEnv::reveal_all().and(&ty))\n-            .unwrap_or_else(|e| {\n-                if let layout::LayoutError::SizeOverflow(_) = e {\n-                    self.tcx.sess.fatal(&e.to_string())\n-                } else {\n-                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n+        RevealAllLayoutCx(self.tcx).layout_of(ty)\n     }\n }\n \n@@ -442,3 +435,47 @@ impl<'tcx, M: Module> FunctionCx<'_, 'tcx, M> {\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)\n     }\n }\n+\n+pub(crate) struct RevealAllLayoutCx<'tcx>(pub(crate) TyCtxt<'tcx>);\n+\n+impl<'tcx> LayoutOf for RevealAllLayoutCx<'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyAndLayout = TyAndLayout<'tcx>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> TyAndLayout<'tcx> {\n+        assert!(!ty.still_further_specializable());\n+        self.0\n+            .layout_of(ParamEnv::reveal_all().and(&ty))\n+            .unwrap_or_else(|e| {\n+                if let layout::LayoutError::SizeOverflow(_) = e {\n+                    self.0.sess.fatal(&e.to_string())\n+                } else {\n+                    bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+    }\n+}\n+\n+impl<'tcx> layout::HasTyCtxt<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.0\n+    }\n+}\n+\n+impl<'tcx> rustc_target::abi::HasDataLayout for RevealAllLayoutCx<'tcx> {\n+    fn data_layout(&self) -> &rustc_target::abi::TargetDataLayout {\n+        &self.0.data_layout\n+    }\n+}\n+\n+impl<'tcx> layout::HasParamEnv<'tcx> for RevealAllLayoutCx<'tcx> {\n+    fn param_env(&self) -> ParamEnv<'tcx> {\n+        ParamEnv::reveal_all()\n+    }\n+}\n+\n+impl<'tcx> HasTargetSpec for RevealAllLayoutCx<'tcx> {\n+    fn target_spec(&self) -> &Target {\n+        &self.0.sess.target\n+    }\n+}"}, {"sha": "2d14ff2c0221d19c868dea6be771dd18106ff136", "filename": "src/driver/jit.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -156,12 +156,8 @@ extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8\n             let jit_module = jit_module.as_mut().unwrap();\n             let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n \n-            let (name, sig) = crate::abi::get_function_name_and_sig(\n-                tcx,\n-                cx.module.isa().triple(),\n-                instance,\n-                true,\n-            );\n+            let name = tcx.symbol_name(instance).name.to_string();\n+            let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), instance);\n             let func_id = cx\n                 .module\n                 .declare_function(&name, Linkage::Export, &sig)\n@@ -246,8 +242,8 @@ pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: In\n \n     let pointer_type = cx.module.target_config().pointer_type();\n \n-    let (name, sig) =\n-        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let name = tcx.symbol_name(inst).name.to_string();\n+    let sig = crate::abi::get_function_sig(tcx, cx.module.isa().triple(), inst);\n     let func_id = cx\n         .module\n         .declare_function(&name, Linkage::Export, &sig)"}, {"sha": "2497f9dfdfbcf0d9ba8cc80972cce666549cd81b", "filename": "src/driver/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -50,12 +50,9 @@ fn predefine_mono_items<'tcx>(\n         for &(mono_item, (linkage, visibility)) in mono_items {\n             match mono_item {\n                 MonoItem::Fn(instance) => {\n-                    let (name, sig) = get_function_name_and_sig(\n-                        cx.tcx,\n-                        cx.module.isa().triple(),\n-                        instance,\n-                        false,\n-                    );\n+                    let name = cx.tcx.symbol_name(instance).name.to_string();\n+                    let _inst_guard = crate::PrintOnPanic(|| format!(\"{:?} {}\", instance, name));\n+                    let sig = get_function_sig(cx.tcx, cx.module.isa().triple(), instance);\n                     let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n                     cx.module.declare_function(&name, linkage, &sig).unwrap();\n                 }"}, {"sha": "ed7ee3b536534e648ae7c916c63e95fa2d08e190", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -90,7 +90,7 @@ mod prelude {\n     pub(crate) use rustc_middle::mir::{self, *};\n     pub(crate) use rustc_middle::ty::layout::{self, TyAndLayout};\n     pub(crate) use rustc_middle::ty::{\n-        self, FnSig, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n+        self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt, TypeAndMut, TypeFoldable,\n     };\n     pub(crate) use rustc_target::abi::{Abi, LayoutOf, Scalar, Size, VariantIdx};\n "}, {"sha": "b193cea877dad493996c9bbee8cf1a1011345bc3", "filename": "src/main_shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain_shim.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -69,8 +69,8 @@ pub(crate) fn maybe_create_entry_wrapper(\n \n         let instance = Instance::mono(tcx, rust_main_def_id).polymorphize(tcx);\n \n-        let (main_name, main_sig) =\n-            get_function_name_and_sig(tcx, m.isa().triple(), instance, false);\n+        let main_name = tcx.symbol_name(instance).name.to_string();\n+        let main_sig = get_function_sig(tcx, m.isa().triple(), instance);\n         let main_func_id = m\n             .declare_function(&main_name, Linkage::Import, &main_sig)\n             .unwrap();"}, {"sha": "f4a15ab12d5112fbc8b9c324f65ca2c7adf19e4e", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -61,7 +61,9 @@ use cranelift_codegen::{\n     write::{FuncWriter, PlainWriter},\n };\n \n+use rustc_middle::ty::layout::FnAbiExt;\n use rustc_session::config::OutputType;\n+use rustc_target::abi::call::FnAbi;\n \n use crate::prelude::*;\n \n@@ -78,11 +80,8 @@ impl CommentWriter {\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n                 format!(\n-                    \"sig {:?}\",\n-                    tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        crate::abi::fn_sig_for_fn_abi(tcx, instance)\n-                    )\n+                    \"abi {:?}\",\n+                    FnAbi::of_instance(&RevealAllLayoutCx(tcx), instance, &[])\n                 ),\n                 String::new(),\n             ]"}, {"sha": "765604e0f984ec343bba1fd8398a3b6b6008fc83", "filename": "src/value_and_place.rs", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18de1b1fde169e76c3f4941b9c8b8c009221d618/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=18de1b1fde169e76c3f4941b9c8b8c009221d618", "patch": "@@ -334,7 +334,9 @@ impl<'tcx> CPlace<'tcx> {\n \n         let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n             kind: StackSlotKind::ExplicitSlot,\n-            size: u32::try_from(layout.size.bytes()).unwrap(),\n+            // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+            // specify stack slot alignment.\n+            size: (u32::try_from(layout.size.bytes()).unwrap() + 15) / 16 * 16,\n             offset: None,\n         });\n         CPlace {\n@@ -450,64 +452,6 @@ impl<'tcx> CPlace<'tcx> {\n         fx: &mut FunctionCx<'_, 'tcx, impl Module>,\n         from: CValue<'tcx>,\n     ) {\n-        fn assert_assignable<'tcx>(\n-            fx: &FunctionCx<'_, 'tcx, impl Module>,\n-            from_ty: Ty<'tcx>,\n-            to_ty: Ty<'tcx>,\n-        ) {\n-            match (from_ty.kind(), to_ty.kind()) {\n-                (ty::Ref(_, a, _), ty::Ref(_, b, _))\n-                | (\n-                    ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n-                    ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n-                ) => {\n-                    assert_assignable(fx, a, b);\n-                }\n-                (ty::FnPtr(_), ty::FnPtr(_)) => {\n-                    let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        from_ty.fn_sig(fx.tcx),\n-                    );\n-                    let to_sig = fx.tcx.normalize_erasing_late_bound_regions(\n-                        ParamEnv::reveal_all(),\n-                        to_ty.fn_sig(fx.tcx),\n-                    );\n-                    assert_eq!(\n-                        from_sig, to_sig,\n-                        \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n-                        from_sig, to_sig, fx,\n-                    );\n-                    // fn(&T) -> for<'l> fn(&'l T) is allowed\n-                }\n-                (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n-                    for (from, to) in from_traits.iter().zip(to_traits) {\n-                        let from = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n-                        let to = fx\n-                            .tcx\n-                            .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n-                        assert_eq!(\n-                            from, to,\n-                            \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n-                            from_traits, to_traits, fx,\n-                        );\n-                    }\n-                    // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n-                }\n-                _ => {\n-                    assert_eq!(\n-                        from_ty,\n-                        to_ty,\n-                        \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n-                        from_ty,\n-                        to_ty,\n-                        fx,\n-                    );\n-                }\n-            }\n-        }\n-\n         assert_assignable(fx, from.layout().ty, self.layout().ty);\n \n         self.write_cvalue_maybe_transmute(fx, from, \"write_cvalue\");\n@@ -556,7 +500,9 @@ impl<'tcx> CPlace<'tcx> {\n                     // FIXME do something more efficient for transmutes between vectors and integers.\n                     let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n                         kind: StackSlotKind::ExplicitSlot,\n-                        size: src_ty.bytes(),\n+                        // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+                        // specify stack slot alignment.\n+                        size: (src_ty.bytes() + 15) / 16 * 16,\n                         offset: None,\n                     });\n                     let ptr = Pointer::stack_slot(stack_slot);\n@@ -794,3 +740,62 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n }\n+\n+#[track_caller]\n+pub(crate) fn assert_assignable<'tcx>(\n+    fx: &FunctionCx<'_, 'tcx, impl Module>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) {\n+    match (from_ty.kind(), to_ty.kind()) {\n+        (ty::Ref(_, a, _), ty::Ref(_, b, _))\n+        | (\n+            ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }),\n+            ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }),\n+        ) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::Ref(_, a, _), ty::RawPtr(TypeAndMut { ty: b, mutbl: _ }))\n+        | (ty::RawPtr(TypeAndMut { ty: a, mutbl: _ }), ty::Ref(_, b, _)) => {\n+            assert_assignable(fx, a, b);\n+        }\n+        (ty::FnPtr(_), ty::FnPtr(_)) => {\n+            let from_sig = fx.tcx.normalize_erasing_late_bound_regions(\n+                ParamEnv::reveal_all(),\n+                from_ty.fn_sig(fx.tcx),\n+            );\n+            let to_sig = fx\n+                .tcx\n+                .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to_ty.fn_sig(fx.tcx));\n+            assert_eq!(\n+                from_sig, to_sig,\n+                \"Can't write fn ptr with incompatible sig {:?} to place with sig {:?}\\n\\n{:#?}\",\n+                from_sig, to_sig, fx,\n+            );\n+            // fn(&T) -> for<'l> fn(&'l T) is allowed\n+        }\n+        (&ty::Dynamic(from_traits, _), &ty::Dynamic(to_traits, _)) => {\n+            for (from, to) in from_traits.iter().zip(to_traits) {\n+                let from = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), from);\n+                let to = fx\n+                    .tcx\n+                    .normalize_erasing_late_bound_regions(ParamEnv::reveal_all(), to);\n+                assert_eq!(\n+                    from, to,\n+                    \"Can't write trait object of incompatible traits {:?} to place with traits {:?}\\n\\n{:#?}\",\n+                    from_traits, to_traits, fx,\n+                );\n+            }\n+            // dyn for<'r> Trait<'r> -> dyn Trait<'_> is allowed\n+        }\n+        _ => {\n+            assert_eq!(\n+                from_ty, to_ty,\n+                \"Can't write value with incompatible type {:?} to place with type {:?}\\n\\n{:#?}\",\n+                from_ty, to_ty, fx,\n+            );\n+        }\n+    }\n+}"}]}