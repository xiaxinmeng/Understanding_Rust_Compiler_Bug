{"sha": "9f59da28648c57d7c4fcac371f9f86adddeb20a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNTlkYTI4NjQ4YzU3ZDdjNGZjYWMzNzFmOWY4NmFkZGRlYjIwYTM=", "commit": {"author": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-09-20T07:16:10Z"}, "committer": {"name": "Michael Hewson", "email": "michael@michaelhewson.ca", "date": "2018-11-01T22:15:20Z"}, "message": "Implement object-safety for arbitrary_self_types: part 2\n\nFor now, all of the receivers that we care about are just a newtyped\npointer \u2014 i.e. `Box<Self>`, `Rc<Self>`, `Pin<Box<Self>>`, `Pin<&mut\nSelf>`. This is much simpler to implement in codeine than the more\ngeneral case, because the ABI is the same as a pointer. So we add some\nchecks in typeck/coherence/builtin.rs to make sure that implementors of\nCoerceSized are just newtyped pointers. In this commit, we also\nimplement the codegen bits.", "tree": {"sha": "f5e99d63d7c3499f09b01054df0a0284bd69c25c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5e99d63d7c3499f09b01054df0a0284bd69c25c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f59da28648c57d7c4fcac371f9f86adddeb20a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f59da28648c57d7c4fcac371f9f86adddeb20a3", "html_url": "https://github.com/rust-lang/rust/commit/9f59da28648c57d7c4fcac371f9f86adddeb20a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f59da28648c57d7c4fcac371f9f86adddeb20a3/comments", "author": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikeyhew", "id": 6751033, "node_id": "MDQ6VXNlcjY3NTEwMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6751033?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikeyhew", "html_url": "https://github.com/mikeyhew", "followers_url": "https://api.github.com/users/mikeyhew/followers", "following_url": "https://api.github.com/users/mikeyhew/following{/other_user}", "gists_url": "https://api.github.com/users/mikeyhew/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikeyhew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikeyhew/subscriptions", "organizations_url": "https://api.github.com/users/mikeyhew/orgs", "repos_url": "https://api.github.com/users/mikeyhew/repos", "events_url": "https://api.github.com/users/mikeyhew/events{/privacy}", "received_events_url": "https://api.github.com/users/mikeyhew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361", "html_url": "https://github.com/rust-lang/rust/commit/d5c2c4a4339b2a6c64d16282d85bfd27bf01d361"}], "stats": {"total": 325, "additions": 304, "deletions": 21}, "files": [{"sha": "1662b57b8b319616163a359bfc64deca20de3c97", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=9f59da28648c57d7c4fcac371f9f86adddeb20a3", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n-use rustc_target::abi::{LayoutOf, Size, TyLayout};\n+use rustc_target::abi::{LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n \n@@ -302,21 +302,44 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the (thin pointer) first field of `*dyn Trait`.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n             if arg_idx == Some(0) {\n-                // FIXME(eddyb) `layout.field(cx, 0)` is not enough because e.g.\n-                // `Box<dyn Trait>` has a few newtype wrappers around the raw\n-                // pointer, so we'd have to \"dig down\" to find `*dyn Trait`.\n-                let pointee = if layout.is_unsized() {\n-                    layout.ty\n+                let fat_pointer_ty = if layout.is_unsized() {\n+                    // unsized `self` is passed as a pointer to `self`\n+                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+                    cx.tcx.mk_mut_ptr(layout.ty)\n                 } else {\n-                    layout.ty.builtin_deref(true)\n-                        .unwrap_or_else(|| {\n-                            bug!(\"FnType::new_vtable: non-pointer self {:?}\", layout)\n-                        }).ty\n+                    match layout.abi {\n+                        LayoutAbi::ScalarPair(..) => (),\n+                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n+                    }\n+\n+                    let mut fat_pointer_layout = layout;\n+                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+                        && !fat_pointer_layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                            let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                            if !field_layout.is_zst() {\n+                                fat_pointer_layout = field_layout;\n+                                continue 'descend_newtypes\n+                            }\n+                        }\n+\n+                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n+                    }\n+\n+                    fat_pointer_layout.ty\n                 };\n-                let fat_ptr_ty = cx.tcx.mk_mut_ptr(pointee);\n-                layout = cx.layout_of(fat_ptr_ty).field(cx, 0);\n+\n+                // we now have a type like `*mut RcBox<dyn Trait>`\n+                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+                // this is understood as a special case elsewhere in the compiler\n+                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n+                layout = cx.layout_of(unit_pointer_ty);\n+                layout.ty = fat_pointer_ty;\n             }\n             ArgType::new(layout)\n         })"}, {"sha": "0cb4963f97faed6f81816ee18d506635a2eb6168", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=9f59da28648c57d7c4fcac371f9f86adddeb20a3", "patch": "@@ -642,14 +642,42 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     (&args[..], None)\n                 };\n \n-                for (i, arg) in first_args.iter().enumerate() {\n+                'make_args: for (i, arg) in first_args.iter().enumerate() {\n                     let mut op = self.codegen_operand(&bx, arg);\n+\n                     if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                        if let Pair(data_ptr, meta) = op.val {\n-                            llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                .get_fn(&bx, meta, &fn_ty));\n-                            llargs.push(data_ptr);\n-                            continue;\n+                        if let Pair(..) = op.val {\n+                            // descend through newtype wrappers until `op` is a builtin pointer to\n+                            // `dyn Trait`, e.g. `*const dyn Trait`, `&mut dyn Trait`\n+                            'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                                            && !op.layout.ty.is_region_ptr()\n+                            {\n+                                'iter_fields: for i in 0..op.layout.fields.count() {\n+                                    let field = op.extract_field(&bx, i);\n+                                    if !field.layout.is_zst() {\n+                                        // we found the one non-zero-sized field that is allowed\n+                                        // now find *its* non-zero-sized field, or stop if it's a\n+                                        // pointer\n+                                        op = field;\n+                                        continue 'descend_newtypes\n+                                    }\n+                                }\n+\n+                                span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                            }\n+\n+                            // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                            // data pointer and vtable. Look up the method in the vtable, and pass\n+                            // the data pointer as the first argument\n+                            match op.val {\n+                                Pair(data_ptr, meta) => {\n+                                    llfn = Some(meth::VirtualIndex::from_index(idx)\n+                                        .get_fn(&bx, meta, &fn_ty));\n+                                    llargs.push(data_ptr);\n+                                    continue 'make_args\n+                                }\n+                                other => bug!(\"expected a Pair, got {:?}\", other)\n+                            }\n                         } else if let Ref(data_ptr, Some(meta), _) = op.val {\n                             // by-value dynamic dispatch\n                             llfn = Some(meth::VirtualIndex::from_index(idx)"}, {"sha": "eba73b1da9aab488c2cd5d9001bb07262542abcb", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 160, "deletions": 2, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9f59da28648c57d7c4fcac371f9f86adddeb20a3", "patch": "@@ -31,8 +31,8 @@ pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n         .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items().coerce_unsized_trait(),\n-               visit_implementation_of_coerce_unsized);\n+        .check(tcx.lang_items().coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n+        .check(tcx.lang_items().coerce_sized_trait(), visit_implementation_of_coerce_sized);\n }\n \n struct Checker<'a, 'tcx: 'a> {\n@@ -162,6 +162,164 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn visit_implementation_of_coerce_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+    debug!(\"visit_implementation_of_coerce_sized: impl_did={:?}\",\n+           impl_did);\n+    if impl_did.is_local() {\n+        let coerce_sized_trait = tcx.lang_items().coerce_sized_trait().unwrap();\n+\n+        let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap();\n+        let span = tcx.hir.span(impl_node_id);\n+\n+        let source = tcx.type_of(impl_did);\n+        assert!(!source.has_escaping_regions());\n+        let target = {\n+            let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+            assert_eq!(trait_ref.def_id, coerce_sized_trait);\n+\n+            trait_ref.substs.type_at(1)\n+        };\n+\n+        debug!(\"visit_implementation_of_coerce_sized: {:?} -> {:?}\",\n+            source,\n+            target);\n+\n+        let param_env = tcx.param_env(impl_did);\n+\n+        let create_err = |msg: &str| {\n+            struct_span_err!(tcx.sess, span, E0378, \"{}\", msg)\n+        };\n+\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let cause = ObligationCause::misc(span, impl_node_id);\n+\n+            use ty::TyKind::*;\n+            match (&source.sty, &target.sty) {\n+                (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n+                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok()\n+                    && mutbl_a == *mutbl_b => (),\n+                (&RawPtr(tm_a), &RawPtr(tm_b))\n+                    if tm_a.mutbl == tm_b.mutbl => (),\n+                (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n+                    if def_a.is_struct() && def_b.is_struct() =>\n+                {\n+                    if def_a != def_b {\n+                        let source_path = tcx.item_path_str(def_a.did);\n+                        let target_path = tcx.item_path_str(def_b.did);\n+\n+                        create_err(\n+                            &format!(\n+                                \"the trait `CoerceSized` may only be implemented \\\n+                                for a coercion between structures with the same \\\n+                                definition; expected {}, found {}\",\n+                                source_path, target_path,\n+                            )\n+                        ).emit();\n+\n+                        return\n+                    }\n+\n+                    let fields = &def_a.non_enum_variant().fields;\n+\n+                    let coerced_fields = fields.iter().filter_map(|field| {\n+                        if tcx.type_of(field.did).is_phantom_data() {\n+                            // ignore PhantomData fields\n+                            return None\n+                        }\n+\n+                        let ty_a = field.ty(tcx, substs_a);\n+                        let ty_b = field.ty(tcx, substs_b);\n+                        if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                            if ok.obligations.is_empty() {\n+                                create_err(\n+                                    \"the trait `CoerceSized` may only be implemented for structs \\\n+                                     containing the field being coerced, `PhantomData` fields, \\\n+                                     and nothing else\"\n+                                ).note(\n+                                    &format!(\n+                                        \"extra field `{}` of type `{}` is not allowed\",\n+                                        field.ident, ty_a,\n+                                    )\n+                                ).emit();\n+\n+                                return None;\n+                            }\n+                        }\n+\n+                        Some(field)\n+                    }).collect::<Vec<_>>();\n+\n+                    if coerced_fields.is_empty() {\n+                        create_err(\n+                            \"the trait `CoerceSized` may only be implemented \\\n+                            for a coercion between structures with a single field \\\n+                            being coerced, none found\"\n+                        ).emit();\n+                    } else if coerced_fields.len() > 1 {\n+                        create_err(\n+                            \"implementing the `CoerceSized` trait requires multiple coercions\",\n+                        ).note(\n+                            \"the trait `CoerceSized` may only be implemented \\\n+                                for a coercion between structures with a single field \\\n+                                being coerced\"\n+                        ).note(\n+                            &format!(\n+                                \"currently, {} fields need coercions: {}\",\n+                                coerced_fields.len(),\n+                                coerced_fields.iter().map(|field| {\n+                                    format!(\"{} ({} to {})\",\n+                                        field.ident,\n+                                        field.ty(tcx, substs_a),\n+                                        field.ty(tcx, substs_b),\n+                                    )\n+                                }).collect::<Vec<_>>()\n+                                .join(\", \")\n+                            )\n+                        ).emit();\n+                    } else {\n+                        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+\n+                        for field in coerced_fields {\n+\n+                            let predicate = tcx.predicate_for_trait_def(\n+                                param_env,\n+                                cause.clone(),\n+                                coerce_sized_trait,\n+                                0,\n+                                field.ty(tcx, substs_a),\n+                                &[field.ty(tcx, substs_b).into()]\n+                            );\n+\n+                            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                        }\n+\n+                        // Check that all transitive obligations are satisfied.\n+                        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+                            infcx.report_fulfillment_errors(&errors, None, false);\n+                        }\n+\n+                        // Finally, resolve all regions.\n+                        let region_scope_tree = region::ScopeTree::default();\n+                        let outlives_env = OutlivesEnvironment::new(param_env);\n+                        infcx.resolve_regions_and_report_errors(\n+                            impl_did,\n+                            &region_scope_tree,\n+                            &outlives_env,\n+                            SuppressRegionErrors::default(),\n+                        );\n+                    }\n+                }\n+                _ => {\n+                    create_err(\n+                        \"the trait `CoerceSsized` may only be implemented \\\n+                        for a coercion between structures\"\n+                    ).emit();\n+                }\n+            }\n+        })\n+    }\n+}\n+\n pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {"}, {"sha": "2cfca345c27f88daaa17a7070c93e17b47a02988", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f59da28648c57d7c4fcac371f9f86adddeb20a3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9f59da28648c57d7c4fcac371f9f86adddeb20a3", "patch": "@@ -3084,6 +3084,80 @@ containing the unsized type is the last and only unsized type field in the\n struct.\n \"##,\n \n+E0378: r##\"\n+The `CoerceSized` trait currently can only be implemented for builtin pointer\n+types and structs that are newtype wrappers around them \u2014 that is, the struct\n+must have only one field (except for`PhantomData`), and that field must itself\n+implement `CoerceSized`.\n+\n+Examples:\n+\n+```\n+#![feature(coerce_sized, unsize)]\n+use std::{\n+    marker::Unsize,\n+    ops::CoerceSized,\n+};\n+\n+struct Ptr<T: ?Sized>(*const T);\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T>\n+where\n+    T: Unsize<U>,\n+{}\n+\n+impl<T: ?Sized, U: ?Sized> CoerceSized<Ptr<T>> for Ptr<U>\n+where\n+    T: Unsize<U>,\n+{}\n+```\n+\n+```\n+#![feature(coerce_unsized, coerce_sized)]\n+use std::ops::{CoerceUnsized, CoerceSized};\n+\n+struct Wrapper<T> {\n+    ptr: T,\n+    _phantom: PhantomData<()>,\n+}\n+\n+impl<T, U> CoerceUnsized<Wrapper<U>> for Wrapper<T>\n+where\n+    T: CoerceUnsized<U>,\n+{}\n+\n+impl<T, U> CoerceSized<Wrapper<T>> for Wrapper<U>\n+where\n+    T: CoerceUnsized<U>,\n+    U: CoerceSized<T>,\n+{}\n+```\n+\n+Example of illegal CoerceSized implementation\n+(illegal because of extra field)\n+\n+```compile-fail,E0378\n+#![feature(coerce_unsized, coerce_sized)]\n+use std::ops::{CoerceUnsized, CoerceSized};\n+\n+struct WrapperWithExtraField<T> {\n+    ptr: T,\n+    extra_stuff: i32,\n+}\n+\n+impl<T, U> CoerceUnsized<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n+where\n+    T: CoerceUnsized<U>,\n+{}\n+\n+impl<T, U> CoerceSized<WrapperWithExtraField<T>> for WrapperWithExtraField<U>\n+where\n+    T: CoerceUnsized<U>,\n+    U: CoerceSized<T>,\n+{}\n+```\n+\"##,\n+\n E0390: r##\"\n You tried to implement methods for a primitive type. Erroneous code example:\n "}]}