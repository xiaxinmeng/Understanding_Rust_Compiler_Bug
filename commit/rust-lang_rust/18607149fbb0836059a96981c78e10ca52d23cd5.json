{"sha": "18607149fbb0836059a96981c78e10ca52d23cd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4NjA3MTQ5ZmJiMDgzNjA1OWE5Njk4MWM3OGUxMGNhNTJkMjNjZDU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-07-30T21:20:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-08-11T01:20:00Z"}, "message": "syntax: Add a new unstable #[linked_from] attribute\n\nTo correctly reexport statically included libraries from a DLL on Windows, the\ncompiler will soon need to have knowledge about what symbols are statically\nincluded and which are not. To solve this problem a new unstable\n`#[linked_from]` attribute is being added and recognized on `extern` blocks to\nindicate which native library the symbols are coming from.\n\nThe compiler then keeps track of what the set of FFI symbols are that are\nincluded statically. This information will be used in a future commit to\nconfigure how we invoke the linker on Windows.", "tree": {"sha": "201b0a143fb6c4cac89383f49fe9fe50bcde1fa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/201b0a143fb6c4cac89383f49fe9fe50bcde1fa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18607149fbb0836059a96981c78e10ca52d23cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18607149fbb0836059a96981c78e10ca52d23cd5", "html_url": "https://github.com/rust-lang/rust/commit/18607149fbb0836059a96981c78e10ca52d23cd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18607149fbb0836059a96981c78e10ca52d23cd5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aca49c693c9be3064d9e6db9473b1fa76834b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aca49c693c9be3064d9e6db9473b1fa76834b79", "html_url": "https://github.com/rust-lang/rust/commit/5aca49c693c9be3064d9e6db9473b1fa76834b79"}], "stats": {"total": 180, "additions": 103, "deletions": 77}, "files": [{"sha": "4d5564d9fafb082b574e0eaf8f0480d234e50b29", "filename": "src/doc/reference.md", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=18607149fbb0836059a96981c78e10ca52d23cd5", "patch": "@@ -1924,10 +1924,16 @@ On an `extern` block, the following attributes are interpreted:\n   name and type. This is feature gated and the exact behavior is\n   implementation-defined (due to variety of linker invocation syntax).\n - `link` - indicate that a native library should be linked to for the\n-  declarations in this block to be linked correctly. `link` supports an optional `kind`\n-  key with three possible values: `dylib`, `static`, and `framework`. See [external blocks](#external-blocks) for more about external blocks. Two\n+  declarations in this block to be linked correctly. `link` supports an optional\n+  `kind` key with three possible values: `dylib`, `static`, and `framework`. See\n+  [external blocks](#external-blocks) for more about external blocks. Two\n   examples: `#[link(name = \"readline\")]` and\n   `#[link(name = \"CoreFoundation\", kind = \"framework\")]`.\n+- `linked_from` - indicates what native library this block of FFI items is\n+  coming from. This attribute is of the form `#[linked_from = \"foo\"]` where\n+  `foo` is the name of a library in either `#[link]` or a `-l` flag. This\n+  attribute is currently required to export symbols from a Rust dynamic library\n+  on Windows, and it is feature gated behind the `linked_from` feature.\n \n On declarations inside an `extern` block, the following attributes are\n interpreted:"}, {"sha": "3226a99c6b3ae285cf7885fa1d67eac578ff2c29", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 77, "deletions": 73, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=18607149fbb0836059a96981c78e10ca52d23cd5", "patch": "@@ -20,6 +20,7 @@ use metadata::cstore::{CStore, CrateSource, MetadataBlob};\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n+use util::nodemap::FnvHashMap;\n \n use std::cell::RefCell;\n use std::path::PathBuf;\n@@ -47,6 +48,7 @@ pub struct LocalCrateReader<'a, 'b:'a> {\n pub struct CrateReader<'a> {\n     sess: &'a Session,\n     next_crate_num: ast::CrateNum,\n+    foreign_item_map: FnvHashMap<String, Vec<ast::NodeId>>,\n }\n \n impl<'a, 'b, 'v> visit::Visitor<'v> for LocalCrateReader<'a, 'b> {\n@@ -157,6 +159,7 @@ impl<'a> CrateReader<'a> {\n         CrateReader {\n             sess: sess,\n             next_crate_num: sess.cstore.next_crate_num(),\n+            foreign_item_map: FnvHashMap(),\n         }\n     }\n \n@@ -490,6 +493,20 @@ impl<'a> CrateReader<'a> {\n             _ => None,\n         }\n     }\n+\n+    fn register_statically_included_foreign_items(&mut self) {\n+        let libs = self.sess.cstore.get_used_libraries();\n+        for (lib, list) in self.foreign_item_map.iter() {\n+            let is_static = libs.borrow().iter().any(|&(ref name, kind)| {\n+                lib == name && kind == cstore::NativeStatic\n+            });\n+            if is_static {\n+                for id in list {\n+                    self.sess.cstore.add_statically_included_foreign_item(*id);\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'b> LocalCrateReader<'a, 'b> {\n@@ -515,6 +532,7 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n         for &(ref name, kind) in &self.sess.opts.libs {\n             register_native_lib(self.sess, None, name.clone(), kind);\n         }\n+        self.creader.register_statically_included_foreign_items();\n     }\n \n     fn process_crate(&self, c: &ast::Crate) {\n@@ -541,87 +559,73 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                                                               None,\n                                                               i.span,\n                                                               PathKind::Crate);\n-                        self.ast_map.with_path(i.id, |path|\n-                            cmeta.update_local_path(path));\n+                        self.ast_map.with_path(i.id, |path| {\n+                            cmeta.update_local_path(path)\n+                        });\n                         self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n                     }\n                     None => ()\n                 }\n             }\n-            ast::ItemForeignMod(ref fm) => {\n-                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n-                    return;\n-                }\n+            ast::ItemForeignMod(ref fm) => self.process_foreign_mod(i, fm),\n+            _ => { }\n+        }\n+    }\n \n-                // First, add all of the custom link_args attributes\n-                let link_args = i.attrs.iter()\n-                    .filter_map(|at| if at.name() == \"link_args\" {\n-                        Some(at)\n-                    } else {\n-                        None\n-                    })\n-                    .collect::<Vec<&ast::Attribute>>();\n-                for m in &link_args {\n-                    match m.value_str() {\n-                        Some(linkarg) => self.sess.cstore.add_used_link_args(&linkarg),\n-                        None => { /* fallthrough */ }\n-                    }\n-                }\n+    fn process_foreign_mod(&mut self, i: &ast::Item, fm: &ast::ForeignMod) {\n+        if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+            return;\n+        }\n \n-                // Next, process all of the #[link(..)]-style arguments\n-                let link_args = i.attrs.iter()\n-                    .filter_map(|at| if at.name() == \"link\" {\n-                        Some(at)\n-                    } else {\n-                        None\n-                    })\n-                    .collect::<Vec<&ast::Attribute>>();\n-                for m in &link_args {\n-                    match m.meta_item_list() {\n-                        Some(items) => {\n-                            let kind = items.iter().find(|k| {\n-                                k.name() == \"kind\"\n-                            }).and_then(|a| a.value_str());\n-                            let kind = match kind {\n-                                Some(k) => {\n-                                    if k == \"static\" {\n-                                        cstore::NativeStatic\n-                                    } else if self.sess.target.target.options.is_like_osx\n-                                              && k == \"framework\" {\n-                                        cstore::NativeFramework\n-                                    } else if k == \"framework\" {\n-                                        cstore::NativeFramework\n-                                    } else if k == \"dylib\" {\n-                                        cstore::NativeUnknown\n-                                    } else {\n-                                        self.sess.span_err(m.span,\n-                                            &format!(\"unknown kind: `{}`\",\n-                                                    k));\n-                                        cstore::NativeUnknown\n-                                    }\n-                                }\n-                                None => cstore::NativeUnknown\n-                            };\n-                            let n = items.iter().find(|n| {\n-                                n.name() == \"name\"\n-                            }).and_then(|a| a.value_str());\n-                            let n = match n {\n-                                Some(n) => n,\n-                                None => {\n-                                    self.sess.span_err(m.span,\n-                                        \"#[link(...)] specified without \\\n-                                         `name = \\\"foo\\\"`\");\n-                                    InternedString::new(\"foo\")\n-                                }\n-                            };\n-                            register_native_lib(self.sess, Some(m.span),\n-                                                n.to_string(), kind);\n-                        }\n-                        None => {}\n-                    }\n-                }\n+        // First, add all of the custom #[link_args] attributes\n+        for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n+            if let Some(linkarg) = m.value_str() {\n+                self.sess.cstore.add_used_link_args(&linkarg);\n             }\n-            _ => { }\n+        }\n+\n+        // Next, process all of the #[link(..)]-style arguments\n+        for m in i.attrs.iter().filter(|a| a.check_name(\"link\")) {\n+            let items = match m.meta_item_list() {\n+                Some(item) => item,\n+                None => continue,\n+            };\n+            let kind = items.iter().find(|k| {\n+                k.check_name(\"kind\")\n+            }).and_then(|a| a.value_str());\n+            let kind = match kind.as_ref().map(|s| &s[..]) {\n+                Some(\"static\") => cstore::NativeStatic,\n+                Some(\"dylib\") => cstore::NativeUnknown,\n+                Some(\"framework\") => cstore::NativeFramework,\n+                Some(k) => {\n+                    self.sess.span_err(m.span, &format!(\"unknown kind: `{}`\", k));\n+                    cstore::NativeUnknown\n+                }\n+                None => cstore::NativeUnknown\n+            };\n+            let n = items.iter().find(|n| {\n+                n.check_name(\"name\")\n+            }).and_then(|a| a.value_str());\n+            let n = match n {\n+                Some(n) => n,\n+                None => {\n+                    self.sess.span_err(m.span, \"#[link(...)] specified without \\\n+                                                `name = \\\"foo\\\"`\");\n+                    InternedString::new(\"foo\")\n+                }\n+            };\n+            register_native_lib(self.sess, Some(m.span), n.to_string(), kind);\n+        }\n+\n+        // Finally, process the #[linked_from = \"...\"] attribute\n+        for m in i.attrs.iter().filter(|a| a.check_name(\"linked_from\")) {\n+            let lib_name = match m.value_str() {\n+                Some(name) => name,\n+                None => continue,\n+            };\n+            let list = self.creader.foreign_item_map.entry(lib_name.to_string())\n+                                                    .or_insert(Vec::new());\n+            list.extend(fm.items.iter().map(|it| it.id));\n         }\n     }\n }"}, {"sha": "ae5e797a0299b591aa408c8fa29280c3da5842b8", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=18607149fbb0836059a96981c78e10ca52d23cd5", "patch": "@@ -20,7 +20,7 @@ pub use self::NativeLibraryKind::*;\n use back::svh::Svh;\n use metadata::{creader, decoder, loader};\n use session::search_paths::PathKind;\n-use util::nodemap::{FnvHashMap, NodeMap};\n+use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use std::cell::{RefCell, Ref};\n use std::rc::Rc;\n@@ -97,6 +97,7 @@ pub struct CStore {\n     used_crate_sources: RefCell<Vec<CrateSource>>,\n     used_libraries: RefCell<Vec<(String, NativeLibraryKind)>>,\n     used_link_args: RefCell<Vec<String>>,\n+    statically_included_foreign_items: RefCell<NodeSet>,\n     pub intr: Rc<IdentInterner>,\n }\n \n@@ -108,7 +109,8 @@ impl CStore {\n             used_crate_sources: RefCell::new(Vec::new()),\n             used_libraries: RefCell::new(Vec::new()),\n             used_link_args: RefCell::new(Vec::new()),\n-            intr: intr\n+            intr: intr,\n+            statically_included_foreign_items: RefCell::new(NodeSet()),\n         }\n     }\n \n@@ -167,6 +169,7 @@ impl CStore {\n         self.used_crate_sources.borrow_mut().clear();\n         self.used_libraries.borrow_mut().clear();\n         self.used_link_args.borrow_mut().clear();\n+        self.statically_included_foreign_items.borrow_mut().clear();\n     }\n \n     // This method is used when generating the command line to pass through to\n@@ -240,6 +243,14 @@ impl CStore {\n                                      -> Option<ast::CrateNum> {\n         self.extern_mod_crate_map.borrow().get(&emod_id).cloned()\n     }\n+\n+    pub fn add_statically_included_foreign_item(&self, id: ast::NodeId) {\n+        self.statically_included_foreign_items.borrow_mut().insert(id);\n+    }\n+\n+    pub fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool {\n+        self.statically_included_foreign_items.borrow().contains(&id)\n+    }\n }\n \n impl crate_metadata {"}, {"sha": "87149ff81da78ef6a3db1836849e2a7bb681d83e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18607149fbb0836059a96981c78e10ca52d23cd5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=18607149fbb0836059a96981c78e10ca52d23cd5", "patch": "@@ -85,6 +85,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"on_unimplemented\", \"1.0.0\", Active),\n     (\"simd_ffi\", \"1.0.0\", Active),\n     (\"allocator\", \"1.0.0\", Active),\n+    (\"linked_from\", \"1.3.0\", Active),\n \n     (\"if_let\", \"1.0.0\", Accepted),\n     (\"while_let\", \"1.0.0\", Accepted),\n@@ -269,6 +270,10 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n                           \"the `#[fundamental]` attribute \\\n                            is an experimental feature\")),\n \n+    (\"linked_from\", Gated(\"linked_from\",\n+                          \"the `#[linked_from]` attribute \\\n+                           is an experimental feature\")),\n+\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted),\n "}]}