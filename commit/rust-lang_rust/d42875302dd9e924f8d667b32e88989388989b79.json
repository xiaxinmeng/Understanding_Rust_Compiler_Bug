{"sha": "d42875302dd9e924f8d667b32e88989388989b79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0Mjg3NTMwMmRkOWU5MjRmOGQ2NjdiMzJlODg5ODkzODg5ODliNzk=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-08-17T19:10:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-17T19:10:44Z"}, "message": "Merge pull request #154 from rust-lang/feature/generic-element-type\n\nChange vectors to be generic over element type.", "tree": {"sha": "1885f424141142a3ca0fa062d368abc9b61e1107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1885f424141142a3ca0fa062d368abc9b61e1107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d42875302dd9e924f8d667b32e88989388989b79", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhHAm0CRBK7hj4Ov3rIwAADDgIALFo6zjcMd+Y7rbrONfXrfDC\nBvNLwSF10xZptoaH9dOOqbUeELf6p6NQBux11W1e+GaP7JXpYLqC9OnsOVDr12Or\nViy6hYEakNQzez7+OnXksXK7EgKVKRp+PY9pgIss1jPO1kogm77b1CTqikUqPbHC\ngC5/oPNX8RQWIWDyWW4yCTP14GM4cZEpoPQ1pDZYY5U9/azZ90DIUDNWlhfBMBGG\ngzBnYcpHylXURVZDgQAmBSWwMG4CR/tKygCbwQj6dbiLKpTAMtW7AkmCI199Rsxb\nPZxsJoLCBu2ceth7XJI0U51XBMpJc2s15qAfHh1NAN/0twOt/wQbwvDAL/IDQso=\n=emHi\n-----END PGP SIGNATURE-----\n", "payload": "tree 1885f424141142a3ca0fa062d368abc9b61e1107\nparent 50eb35eb3b87c37876cb925c5ac3428ef6fa080a\nparent 4aafd8e779bac1122d8218e75872c6b14007f33d\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1629227444 -0700\ncommitter GitHub <noreply@github.com> 1629227444 -0700\n\nMerge pull request #154 from rust-lang/feature/generic-element-type\n\nChange vectors to be generic over element type."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d42875302dd9e924f8d667b32e88989388989b79", "html_url": "https://github.com/rust-lang/rust/commit/d42875302dd9e924f8d667b32e88989388989b79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d42875302dd9e924f8d667b32e88989388989b79/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50eb35eb3b87c37876cb925c5ac3428ef6fa080a", "url": "https://api.github.com/repos/rust-lang/rust/commits/50eb35eb3b87c37876cb925c5ac3428ef6fa080a", "html_url": "https://github.com/rust-lang/rust/commit/50eb35eb3b87c37876cb925c5ac3428ef6fa080a"}, {"sha": "4aafd8e779bac1122d8218e75872c6b14007f33d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4aafd8e779bac1122d8218e75872c6b14007f33d", "html_url": "https://github.com/rust-lang/rust/commit/4aafd8e779bac1122d8218e75872c6b14007f33d"}], "stats": {"total": 3878, "additions": 1839, "deletions": 2039}, "files": [{"sha": "601576e094fa60ce91e796b87c15d65b9ef05099", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 42, "deletions": 70, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,77 +1,49 @@\n-use crate::{LaneCount, SupportedLaneCount};\n-\n-macro_rules! implement_mask_ops {\n-    { $($vector:ident => $mask:ident ($inner_ty:ident),)* } => {\n-        $(\n-            impl<const LANES: usize> crate::$vector<LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                /// Test if each lane is equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_eq(self, other: Self) -> crate::$mask<LANES> {\n-                    unsafe {\n-                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_eq(self, other))\n-                    }\n-                }\n-\n-                /// Test if each lane is not equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ne(self, other: Self) -> crate::$mask<LANES> {\n-                    unsafe {\n-                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_ne(self, other))\n-                    }\n-                }\n-\n-                /// Test if each lane is less than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_lt(self, other: Self) -> crate::$mask<LANES> {\n-                    unsafe {\n-                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_lt(self, other))\n-                    }\n-                }\n-\n-                /// Test if each lane is greater than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_gt(self, other: Self) -> crate::$mask<LANES> {\n-                    unsafe {\n-                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_gt(self, other))\n-                    }\n-                }\n-\n-                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_le(self, other: Self) -> crate::$mask<LANES> {\n-                    unsafe {\n-                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_le(self, other))\n-                    }\n-                }\n+use crate::{LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    T: SimdElement + PartialEq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_eq(self, other)) }\n+    }\n \n-                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ge(self, other: Self) -> crate::$mask<LANES> {\n-                    unsafe {\n-                        crate::$mask::from_int_unchecked(crate::intrinsics::simd_ge(self, other))\n-                    }\n-                }\n-            }\n-        )*\n+    /// Test if each lane is not equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_ne(self, other)) }\n     }\n }\n \n-implement_mask_ops! {\n-    SimdI8 => Mask8 (SimdI8),\n-    SimdI16 => Mask16 (SimdI16),\n-    SimdI32 => Mask32 (SimdI32),\n-    SimdI64 => Mask64 (SimdI64),\n-    SimdIsize => MaskSize (SimdIsize),\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    T: SimdElement + PartialOrd,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_lt(self, other)) }\n+    }\n \n-    SimdU8 => Mask8 (SimdI8),\n-    SimdU16 => Mask16 (SimdI16),\n-    SimdU32 => Mask32 (SimdI32),\n-    SimdU64 => Mask64 (SimdI64),\n-    SimdUsize => MaskSize (SimdIsize),\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_gt(self, other)) }\n+    }\n \n-    SimdF32 => Mask32 (SimdI32),\n-    SimdF64 => Mask64 (SimdI64),\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_le(self, other)) }\n+    }\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    #[inline]\n+    pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n+        unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_ge(self, other)) }\n+    }\n }"}, {"sha": "c3947c92f2a9ce6c7588bde6dd4998de3fb42223", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 25, "deletions": 77, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,88 +1,36 @@\n-macro_rules! debug_wrapper {\n-    { $($trait:ident => $name:ident,)* } => {\n+macro_rules! impl_fmt_trait {\n+    { $($trait:ident,)* } => {\n         $(\n-            pub(crate) fn $name<T: core::fmt::$trait>(slice: &[T], f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                #[repr(transparent)]\n-                struct Wrapper<'a, T: core::fmt::$trait>(&'a T);\n+            impl<T, const LANES: usize> core::fmt::$trait for crate::Simd<T, LANES>\n+            where\n+                crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+                T: crate::SimdElement + core::fmt::$trait,\n+            {\n+                fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                    #[repr(transparent)]\n+                    struct Wrapper<'a, T: core::fmt::$trait>(&'a T);\n \n-                impl<T: core::fmt::$trait> core::fmt::Debug for Wrapper<'_, T> {\n-                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                        self.0.fmt(f)\n+                    impl<T: core::fmt::$trait> core::fmt::Debug for Wrapper<'_, T> {\n+                        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                            self.0.fmt(f)\n+                        }\n                     }\n-                }\n-\n-                f.debug_list()\n-                    .entries(slice.iter().map(|x| Wrapper(x)))\n-                    .finish()\n-            }\n-        )*\n-    }\n-}\n \n-debug_wrapper! {\n-    Debug => format,\n-    Binary => format_binary,\n-    LowerExp => format_lower_exp,\n-    UpperExp => format_upper_exp,\n-    Octal => format_octal,\n-    LowerHex => format_lower_hex,\n-    UpperHex => format_upper_hex,\n-}\n-\n-macro_rules! impl_fmt_trait {\n-    { $($type:ident => $(($trait:ident, $format:ident)),*;)* } => {\n-        $( // repeat type\n-            $( // repeat trait\n-                impl<const LANES: usize> core::fmt::$trait for crate::$type<LANES>\n-                where\n-                    crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-                {\n-                    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                        $format(self.as_ref(), f)\n-                    }\n+                    f.debug_list()\n+                        .entries(self.as_array().iter().map(|x| Wrapper(x)))\n+                        .finish()\n                 }\n-            )*\n+            }\n         )*\n-    };\n-    { integers: $($type:ident,)* } => {\n-        impl_fmt_trait! {\n-            $($type =>\n-              (Debug, format),\n-              (Binary, format_binary),\n-              (LowerExp, format_lower_exp),\n-              (UpperExp, format_upper_exp),\n-              (Octal, format_octal),\n-              (LowerHex, format_lower_hex),\n-              (UpperHex, format_upper_hex);\n-            )*\n-        }\n-    };\n-    { floats: $($type:ident,)* } => {\n-        impl_fmt_trait! {\n-            $($type =>\n-              (Debug, format),\n-              (LowerExp, format_lower_exp),\n-              (UpperExp, format_upper_exp);\n-            )*\n-        }\n-    };\n-    { masks: $($type:ident,)* } => {\n-        impl_fmt_trait! {\n-            $($type =>\n-              (Debug, format);\n-            )*\n-        }\n     }\n }\n \n impl_fmt_trait! {\n-    integers:\n-        SimdU8, SimdU16, SimdU32, SimdU64,\n-        SimdI8, SimdI16, SimdI32, SimdI64,\n-        SimdUsize, SimdIsize,\n-}\n-\n-impl_fmt_trait! {\n-    floats:\n-        SimdF32, SimdF64,\n+    Debug,\n+    Binary,\n+    LowerExp,\n+    UpperExp,\n+    Octal,\n+    LowerHex,\n+    UpperHex,\n }"}, {"sha": "f403f4d90473a8cd3db98470559dca38aefdc3a8", "filename": "crates/core_simd/src/iter.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fiter.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,54 +1,58 @@\n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+use core::{\n+    iter::{Product, Sum},\n+    ops::{Add, Mul},\n+};\n \n macro_rules! impl_traits {\n-    { $type:ident } => {\n-        impl<const LANES: usize> core::iter::Sum<Self> for crate::$type<LANES>\n+    { $type:ty } => {\n+        impl<const LANES: usize> Sum<Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn sum<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Add::add)\n+            fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(0 as $type), Add::add)\n             }\n         }\n \n-        impl<const LANES: usize> core::iter::Product<Self> for crate::$type<LANES>\n+        impl<const LANES: usize> core::iter::Product<Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn product<I: core::iter::Iterator<Item = Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Mul::mul)\n+            fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(1 as $type), Mul::mul)\n             }\n         }\n \n-        impl<'a, const LANES: usize> core::iter::Sum<&'a Self> for crate::$type<LANES>\n+        impl<'a, const LANES: usize> Sum<&'a Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn sum<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Add::add)\n+            fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(0 as $type), Add::add)\n             }\n         }\n \n-        impl<'a, const LANES: usize> core::iter::Product<&'a Self> for crate::$type<LANES>\n+        impl<'a, const LANES: usize> Product<&'a Self> for Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn product<I: core::iter::Iterator<Item = &'a Self>>(iter: I) -> Self {\n-                iter.fold(Default::default(), core::ops::Mul::mul)\n+            fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n+                iter.fold(Simd::splat(1 as $type), Mul::mul)\n             }\n         }\n     }\n }\n \n-impl_traits! { SimdF32 }\n-impl_traits! { SimdF64 }\n-impl_traits! { SimdU8 }\n-impl_traits! { SimdU16 }\n-impl_traits! { SimdU32 }\n-impl_traits! { SimdU64 }\n-impl_traits! { SimdUsize }\n-impl_traits! { SimdI8 }\n-impl_traits! { SimdI16 }\n-impl_traits! { SimdI32 }\n-impl_traits! { SimdI64 }\n-impl_traits! { SimdIsize }\n+impl_traits! { f32 }\n+impl_traits! { f64 }\n+impl_traits! { u8 }\n+impl_traits! { u16 }\n+impl_traits! { u32 }\n+impl_traits! { u64 }\n+impl_traits! { usize }\n+impl_traits! { i8 }\n+impl_traits! { i16 }\n+impl_traits! { i32 }\n+impl_traits! { i64 }\n+impl_traits! { isize }"}, {"sha": "fc0df1813b9467284ed8772e9b5c4a6375f646f8", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,6 +2,7 @@\n #![allow(incomplete_features)]\n #![feature(\n     const_evaluatable_checked,\n+    const_fn_trait_bound,\n     const_generics,\n     platform_intrinsics,\n     repr_simd,"}, {"sha": "14b1fe08ffbd1fa8fe6608a1907d20231d8f8a47", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 414, "deletions": 419, "changes": 833, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -12,521 +12,516 @@\n )]\n mod mask_impl;\n \n-use crate::{SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n+use crate::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n \n-mod sealed {\n-    pub trait Sealed {}\n-}\n-\n-/// Helper trait for mask types.\n-pub trait Mask: sealed::Sealed {\n-    /// The number of lanes for this mask.\n-    const LANES: usize;\n-\n-    /// Generates a mask with the same value in every lane.\n-    #[must_use]\n-    fn splat(val: bool) -> Self;\n-}\n+/// Marker trait for types that may be used as SIMD mask elements.\n+pub unsafe trait MaskElement: SimdElement {\n+    #[doc(hidden)]\n+    fn valid<const LANES: usize>(values: Simd<Self, LANES>) -> bool\n+    where\n+        LaneCount<LANES>: SupportedLaneCount;\n \n-macro_rules! define_opaque_mask {\n-    {\n-        $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n-        @bits $bits_ty:ident\n-    } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        pub struct $name<const LANES: usize>($inner_ty)\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount;\n+    #[doc(hidden)]\n+    fn eq(self, other: Self) -> bool;\n \n-        impl<const LANES: usize> sealed::Sealed for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n+    #[doc(hidden)]\n+    const TRUE: Self;\n \n-        impl<const LANES: usize> Mask for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            const LANES: usize = LANES;\n+    #[doc(hidden)]\n+    const FALSE: Self;\n+}\n \n-            #[inline]\n-            fn splat(value: bool) -> Self {\n-                Self::splat(value)\n+macro_rules! impl_element {\n+    { $ty:ty } => {\n+        unsafe impl MaskElement for $ty {\n+            fn valid<const LANES: usize>(value: Simd<Self, LANES>) -> bool\n+            where\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                (value.lanes_eq(Simd::splat(0)) | value.lanes_eq(Simd::splat(-1))).all()\n             }\n-        }\n-\n-        impl_opaque_mask_reductions! { $name, $bits_ty }\n \n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty>::splat(value))\n-            }\n+            fn eq(self, other: Self) -> bool { self == other }\n \n-            /// Converts an array to a SIMD vector.\n-            pub fn from_array(array: [bool; LANES]) -> Self {\n-                let mut vector = Self::splat(false);\n-                let mut i = 0;\n-                while i < $lanes {\n-                    vector.set(i, array[i]);\n-                    i += 1;\n-                }\n-                vector\n-            }\n+            const TRUE: Self = -1;\n+            const FALSE: Self = 0;\n+        }\n+    }\n+}\n \n-            /// Converts a SIMD vector to an array.\n-            pub fn to_array(self) -> [bool; LANES] {\n-                let mut array = [false; LANES];\n-                let mut i = 0;\n-                while i < $lanes {\n-                    array[i] = self.test(i);\n-                    i += 1;\n-                }\n-                array\n-            }\n+impl_element! { i8 }\n+impl_element! { i16 }\n+impl_element! { i32 }\n+impl_element! { i64 }\n+impl_element! { isize }\n+\n+/// A SIMD vector mask for `LANES` elements of width specified by `Element`.\n+///\n+/// The layout of this type is unspecified.\n+#[repr(transparent)]\n+pub struct Mask<T, const LANES: usize>(mask_impl::Mask<T, LANES>)\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-            /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n-            /// represents `true`.\n-            ///\n-            /// # Safety\n-            /// All lanes must be either 0 or -1.\n-            #[inline]\n-            pub unsafe fn from_int_unchecked(value: $bits_ty<LANES>) -> Self {\n-                Self(<$inner_ty>::from_int_unchecked(value))\n-            }\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n \n-            /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n-            /// represents `true`.\n-            ///\n-            /// # Panics\n-            /// Panics if any lane is not 0 or -1.\n-            #[inline]\n-            pub fn from_int(value: $bits_ty<LANES>) -> Self {\n-                assert!(\n-                    (value.lanes_eq($bits_ty::splat(0)) | value.lanes_eq($bits_ty::splat(-1))).all(),\n-                    \"all values must be either 0 or -1\",\n-                );\n-                unsafe { Self::from_int_unchecked(value) }\n-            }\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Construct a mask by setting all lanes to the given value.\n+    pub fn splat(value: bool) -> Self {\n+        Self(mask_impl::Mask::splat(value))\n+    }\n \n-            /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n-            /// represents `true`.\n-            #[inline]\n-            pub fn to_int(self) -> $bits_ty<LANES> {\n-                self.0.to_int()\n-            }\n+    /// Converts an array to a SIMD vector.\n+    pub fn from_array(array: [bool; LANES]) -> Self {\n+        let mut vector = Self::splat(false);\n+        for (i, v) in array.iter().enumerate() {\n+            vector.set(i, *v);\n+        }\n+        vector\n+    }\n \n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Safety\n-            /// `lane` must be less than `LANES`.\n-            #[inline]\n-            pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n-                self.0.test_unchecked(lane)\n-            }\n+    /// Converts a SIMD vector to an array.\n+    pub fn to_array(self) -> [bool; LANES] {\n+        let mut array = [false; LANES];\n+        for (i, v) in array.iter_mut().enumerate() {\n+            *v = self.test(i);\n+        }\n+        array\n+    }\n \n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                assert!(lane < LANES, \"lane index out of range\");\n-                unsafe { self.test_unchecked(lane) }\n-            }\n+    /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+    /// represents `true`.\n+    ///\n+    /// # Safety\n+    /// All lanes must be either 0 or -1.\n+    #[inline]\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        Self(mask_impl::Mask::from_int_unchecked(value))\n+    }\n \n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Safety\n-            /// `lane` must be less than `LANES`.\n-            #[inline]\n-            pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n-                self.0.set_unchecked(lane, value);\n-            }\n+    /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+    /// represents `true`.\n+    ///\n+    /// # Panics\n+    /// Panics if any lane is not 0 or -1.\n+    #[inline]\n+    pub fn from_int(value: Simd<T, LANES>) -> Self {\n+        assert!(T::valid(value), \"all values must be either 0 or -1\",);\n+        unsafe { Self::from_int_unchecked(value) }\n+    }\n \n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                assert!(lane < LANES, \"lane index out of range\");\n-                unsafe { self.set_unchecked(lane, value); }\n-            }\n+    /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n+    /// represents `true`.\n+    #[inline]\n+    pub fn to_int(self) -> Simd<T, LANES> {\n+        self.0.to_int()\n+    }\n \n-            /// Convert this mask to a bitmask, with one bit set per lane.\n-            pub fn to_bitmask(self) -> [u8; crate::LaneCount::<LANES>::BITMASK_LEN] {\n-                self.0.to_bitmask()\n-            }\n+    /// Tests the value of the specified lane.\n+    ///\n+    /// # Safety\n+    /// `lane` must be less than `LANES`.\n+    #[inline]\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        self.0.test_unchecked(lane)\n+    }\n \n-            /// Convert a bitmask to a mask.\n-            pub fn from_bitmask(bitmask: [u8; crate::LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-                Self(<$inner_ty>::from_bitmask(bitmask))\n-            }\n-        }\n+    /// Tests the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn test(&self, lane: usize) -> bool {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        unsafe { self.test_unchecked(lane) }\n+    }\n \n-        // vector/array conversion\n-        impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn from(array: [bool; LANES]) -> Self {\n-                Self::from_array(array)\n-            }\n-        }\n+    /// Sets the value of the specified lane.\n+    ///\n+    /// # Safety\n+    /// `lane` must be less than `LANES`.\n+    #[inline]\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        self.0.set_unchecked(lane, value);\n+    }\n \n-        impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn from(vector: $name<LANES>) -> Self {\n-                vector.to_array()\n-            }\n+    /// Sets the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn set(&mut self, lane: usize, value: bool) {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        unsafe {\n+            self.set_unchecked(lane, value);\n         }\n+    }\n \n-        impl<const LANES: usize> Copy for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n-\n-        impl<const LANES: usize> Clone for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n+    /// Convert this mask to a bitmask, with one bit set per lane.\n+    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n+        self.0.to_bitmask()\n+    }\n \n-        impl<const LANES: usize> Default for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(false)\n-            }\n-        }\n+    /// Convert a bitmask to a mask.\n+    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n+        Self(mask_impl::Mask::from_bitmask(bitmask))\n+    }\n \n-        impl<const LANES: usize> PartialEq for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n+    /// Returns true if any lane is set, or false otherwise.\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        self.0.any()\n+    }\n \n-        impl<const LANES: usize> PartialOrd for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                self.0.partial_cmp(&other.0)\n-            }\n-        }\n+    /// Returns true if all lanes are set, or false otherwise.\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        self.0.all()\n+    }\n+}\n \n-        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                f.debug_list()\n-                    .entries((0..LANES).map(|lane| self.test(lane)))\n-                    .finish()\n-            }\n-        }\n+// vector/array conversion\n+impl<T, const LANES: usize> From<[bool; LANES]> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn from(array: [bool; LANES]) -> Self {\n+        Self::from_array(array)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitand(self, rhs: Self) -> Self {\n-                Self(self.0 & rhs.0)\n-            }\n-        }\n+impl<T, const LANES: usize> From<Mask<T, LANES>> for [bool; LANES]\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn from(vector: Mask<T, LANES>) -> Self {\n+        vector.to_array()\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitand(self, rhs: bool) -> Self {\n-                self & Self::splat(rhs)\n-            }\n-        }\n+impl<T, const LANES: usize> Default for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn default() -> Self {\n+        Self::splat(false)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n-                $name::<LANES>::splat(self) & rhs\n-            }\n-        }\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialEq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitor(self, rhs: Self) -> Self {\n-                Self(self.0 | rhs.0)\n-            }\n-        }\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialOrd,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitor(self, rhs: bool) -> Self {\n-                self | Self::splat(rhs)\n-            }\n-        }\n+impl<T, const LANES: usize> core::fmt::Debug for Mask<T, LANES>\n+where\n+    T: MaskElement + core::fmt::Debug,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        f.debug_list()\n+            .entries((0..LANES).map(|lane| self.test(lane)))\n+            .finish()\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n-                $name::<LANES>::splat(self) | rhs\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: Self) -> Self {\n+        Self(self.0 & rhs.0)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitxor(self, rhs: Self) -> Self::Output {\n-                Self(self.0 ^ rhs.0)\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitAnd<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: bool) -> Self {\n+        self & Self::splat(rhs)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitxor(self, rhs: bool) -> Self::Output {\n-                self ^ Self::splat(rhs)\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitAnd<Mask<T, LANES>> for bool\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn bitand(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n+        Mask::splat(self) & rhs\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n-                $name::<LANES>::splat(self) ^ rhs\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: Self) -> Self {\n+        Self(self.0 | rhs.0)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::Not for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = $name<LANES>;\n-            #[inline]\n-            fn not(self) -> Self::Output {\n-                Self(!self.0)\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitOr<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: bool) -> Self {\n+        self | Self::splat(rhs)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn bitand_assign(&mut self, rhs: Self) {\n-                self.0 = self.0 & rhs.0;\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitOr<Mask<T, LANES>> for bool\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn bitor(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n+        Mask::splat(self) | rhs\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn bitand_assign(&mut self, rhs: bool) {\n-                *self &= Self::splat(rhs);\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: Self) -> Self::Output {\n+        Self(self.0 ^ rhs.0)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn bitor_assign(&mut self, rhs: Self) {\n-                self.0 = self.0 | rhs.0;\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitXor<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: bool) -> Self::Output {\n+        self ^ Self::splat(rhs)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn bitor_assign(&mut self, rhs: bool) {\n-                *self |= Self::splat(rhs);\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::BitXor<Mask<T, LANES>> for bool\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn bitxor(self, rhs: Mask<T, LANES>) -> Self::Output {\n+        Mask::splat(self) ^ rhs\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn bitxor_assign(&mut self, rhs: Self) {\n-                self.0 = self.0 ^ rhs.0;\n-            }\n-        }\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Mask<T, LANES>;\n+    #[inline]\n+    fn not(self) -> Self::Output {\n+        Self(!self.0)\n+    }\n+}\n \n-        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn bitxor_assign(&mut self, rhs: bool) {\n-                *self ^= Self::splat(rhs);\n-            }\n-        }\n-    };\n+impl<T, const LANES: usize> core::ops::BitAndAssign for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: Self) {\n+        self.0 = self.0 & rhs.0;\n+    }\n }\n \n-define_opaque_mask! {\n-    /// Mask for vectors with `LANES` 8-bit elements.\n-    ///\n-    /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(mask_impl::Mask8<LANES>);\n-    @bits SimdI8\n+impl<T, const LANES: usize> core::ops::BitAndAssign<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: bool) {\n+        *self &= Self::splat(rhs);\n+    }\n }\n \n-define_opaque_mask! {\n-    /// Mask for vectors with `LANES` 16-bit elements.\n-    ///\n-    /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(mask_impl::Mask16<LANES>);\n-    @bits SimdI16\n+impl<T, const LANES: usize> core::ops::BitOrAssign for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        self.0 = self.0 | rhs.0;\n+    }\n }\n \n-define_opaque_mask! {\n-    /// Mask for vectors with `LANES` 32-bit elements.\n-    ///\n-    /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(mask_impl::Mask32<LANES>);\n-    @bits SimdI32\n+impl<T, const LANES: usize> core::ops::BitOrAssign<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: bool) {\n+        *self |= Self::splat(rhs);\n+    }\n }\n \n-define_opaque_mask! {\n-    /// Mask for vectors with `LANES` 64-bit elements.\n-    ///\n-    /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(mask_impl::Mask64<LANES>);\n-    @bits SimdI64\n+impl<T, const LANES: usize> core::ops::BitXorAssign for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: Self) {\n+        self.0 = self.0 ^ rhs.0;\n+    }\n }\n \n-define_opaque_mask! {\n-    /// Mask for vectors with `LANES` pointer-width elements.\n-    ///\n-    /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(mask_impl::MaskSize<LANES>);\n-    @bits SimdIsize\n+impl<T, const LANES: usize> core::ops::BitXorAssign<bool> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: bool) {\n+        *self ^= Self::splat(rhs);\n+    }\n }\n \n /// Vector of eight 8-bit masks\n-pub type mask8x8 = Mask8<8>;\n+pub type mask8x8 = Mask<i8, 8>;\n \n /// Vector of 16 8-bit masks\n-pub type mask8x16 = Mask8<16>;\n+pub type mask8x16 = Mask<i8, 16>;\n \n /// Vector of 32 8-bit masks\n-pub type mask8x32 = Mask8<32>;\n+pub type mask8x32 = Mask<i8, 32>;\n \n /// Vector of 16 8-bit masks\n-pub type mask8x64 = Mask8<64>;\n+pub type mask8x64 = Mask<i8, 64>;\n \n /// Vector of four 16-bit masks\n-pub type mask16x4 = Mask16<4>;\n+pub type mask16x4 = Mask<i16, 4>;\n \n /// Vector of eight 16-bit masks\n-pub type mask16x8 = Mask16<8>;\n+pub type mask16x8 = Mask<i16, 8>;\n \n /// Vector of 16 16-bit masks\n-pub type mask16x16 = Mask16<16>;\n+pub type mask16x16 = Mask<i16, 16>;\n \n /// Vector of 32 16-bit masks\n-pub type mask16x32 = Mask32<32>;\n+pub type mask16x32 = Mask<i32, 32>;\n \n /// Vector of two 32-bit masks\n-pub type mask32x2 = Mask32<2>;\n+pub type mask32x2 = Mask<i32, 2>;\n \n /// Vector of four 32-bit masks\n-pub type mask32x4 = Mask32<4>;\n+pub type mask32x4 = Mask<i32, 4>;\n \n /// Vector of eight 32-bit masks\n-pub type mask32x8 = Mask32<8>;\n+pub type mask32x8 = Mask<i32, 8>;\n \n /// Vector of 16 32-bit masks\n-pub type mask32x16 = Mask32<16>;\n+pub type mask32x16 = Mask<i32, 16>;\n \n /// Vector of two 64-bit masks\n-pub type mask64x2 = Mask64<2>;\n+pub type mask64x2 = Mask<i64, 2>;\n \n /// Vector of four 64-bit masks\n-pub type mask64x4 = Mask64<4>;\n+pub type mask64x4 = Mask<i64, 4>;\n \n /// Vector of eight 64-bit masks\n-pub type mask64x8 = Mask64<8>;\n+pub type mask64x8 = Mask<i64, 8>;\n \n /// Vector of two pointer-width masks\n-pub type masksizex2 = MaskSize<2>;\n+pub type masksizex2 = Mask<isize, 2>;\n \n /// Vector of four pointer-width masks\n-pub type masksizex4 = MaskSize<4>;\n+pub type masksizex4 = Mask<isize, 4>;\n \n /// Vector of eight pointer-width masks\n-pub type masksizex8 = MaskSize<8>;\n+pub type masksizex8 = Mask<isize, 8>;\n \n macro_rules! impl_from {\n-    { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n+    { $from:ty  => $($to:ty),* } => {\n         $(\n-        impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n+        impl<const LANES: usize> From<Mask<$from, LANES>> for Mask<$to, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n-            fn from(value: $from<LANES>) -> Self {\n-                Self(value.0.into())\n+            fn from(value: Mask<$from, LANES>) -> Self {\n+                Self(value.0.convert())\n             }\n         }\n         )*\n     }\n }\n-impl_from! { Mask8 (SimdI8) => Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize) }\n-impl_from! { Mask16 (SimdI16) => Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8) }\n-impl_from! { Mask32 (SimdI32) => Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16) }\n-impl_from! { Mask64 (SimdI64) => MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32) }\n-impl_from! { MaskSize (SimdIsize) => Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64) }\n+impl_from! { i8 => i16, i32, i64, isize }\n+impl_from! { i16 => i32, i64, isize, i8 }\n+impl_from! { i32 => i64, isize, i8, i16 }\n+impl_from! { i64 => isize, i8, i16, i32 }\n+impl_from! { isize => i8, i16, i32, i64 }"}, {"sha": "0b5b3a5c595eb98caef755a0bec44853bbf9753f", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 59, "deletions": 61, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,76 +1,73 @@\n-use crate::{LaneCount, SupportedLaneCount};\n-\n-/// Helper trait for limiting int conversion types\n-pub trait ConvertToInt {}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI8<LANES> where\n-    LaneCount<LANES>: SupportedLaneCount\n-{\n-}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI16<LANES> where\n-    LaneCount<LANES>: SupportedLaneCount\n-{\n-}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI32<LANES> where\n-    LaneCount<LANES>: SupportedLaneCount\n-{\n-}\n-impl<const LANES: usize> ConvertToInt for crate::SimdI64<LANES> where\n-    LaneCount<LANES>: SupportedLaneCount\n-{\n-}\n-impl<const LANES: usize> ConvertToInt for crate::SimdIsize<LANES> where\n-    LaneCount<LANES>: SupportedLaneCount\n-{\n-}\n+use crate::{LaneCount, MaskElement, Simd, SupportedLaneCount};\n+use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n #[repr(transparent)]\n-pub struct BitMask<const LANES: usize>(<LaneCount<LANES> as SupportedLaneCount>::BitMask)\n+pub struct Mask<T, const LANES: usize>(\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask,\n+    PhantomData<T>,\n+)\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount;\n \n-impl<const LANES: usize> Copy for BitMask<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-impl<const LANES: usize> Clone for BitMask<LANES>\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<const LANES: usize> PartialEq for BitMask<LANES>\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn eq(&self, other: &Self) -> bool {\n         self.0.as_ref() == other.0.as_ref()\n     }\n }\n \n-impl<const LANES: usize> PartialOrd for BitMask<LANES>\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n }\n \n-impl<const LANES: usize> Eq for BitMask<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n+impl<T, const LANES: usize> Eq for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-impl<const LANES: usize> Ord for BitMask<LANES>\n+impl<T, const LANES: usize> Ord for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.as_ref().cmp(other.0.as_ref())\n     }\n }\n \n-impl<const LANES: usize> BitMask<LANES>\n+impl<T, const LANES: usize> Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -84,7 +81,7 @@ where\n         if LANES % 8 > 0 {\n             *mask.as_mut().last_mut().unwrap() &= u8::MAX >> (8 - LANES % 8);\n         }\n-        Self(mask)\n+        Self(mask, PhantomData)\n     }\n \n     #[inline]\n@@ -98,33 +95,28 @@ where\n     }\n \n     #[inline]\n-    pub fn to_int<V>(self) -> V\n-    where\n-        V: ConvertToInt + Default + core::ops::Not<Output = V>,\n-    {\n+    pub fn to_int(self) -> Simd<T, LANES> {\n         unsafe {\n             let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n                 core::mem::transmute_copy(&self);\n-            crate::intrinsics::simd_select_bitmask(mask, !V::default(), V::default())\n+            crate::intrinsics::simd_select_bitmask(\n+                mask,\n+                Simd::splat(T::TRUE),\n+                Simd::splat(T::FALSE),\n+            )\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn from_int_unchecked<V>(value: V) -> Self\n-    where\n-        V: crate::Vector,\n-    {\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         // TODO remove the transmute when rustc is more flexible\n         assert_eq!(\n-            core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::BitMask>(\n-            ),\n-            core::mem::size_of::<\n-                <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask,\n-            >(),\n+            core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::BitMask>(),\n+            core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n         );\n         let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n             crate::intrinsics::simd_bitmask(value);\n-        Self(core::mem::transmute_copy(&mask))\n+        Self(core::mem::transmute_copy(&mask), PhantomData)\n     }\n \n     #[inline]\n@@ -136,7 +128,15 @@ where\n     #[inline]\n     pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n         // Safety: these are the same type and we are laundering the generic\n-        Self(unsafe { core::mem::transmute_copy(&bitmask) })\n+        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    }\n+\n+    #[inline]\n+    pub fn convert<U>(self) -> Mask<U, LANES>\n+    where\n+        U: MaskElement,\n+    {\n+        unsafe { core::mem::transmute_copy(&self) }\n     }\n \n     #[inline]\n@@ -150,10 +150,11 @@ where\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n-    <LaneCount<LANES> as SupportedLaneCount>::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n@@ -165,10 +166,11 @@ where\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n-    <LaneCount<LANES> as SupportedLaneCount>::BitMask: Default + AsRef<[u8]> + AsMut<[u8]>,\n+    <LaneCount<LANES> as SupportedLaneCount>::BitMask: AsRef<[u8]> + AsMut<[u8]>,\n {\n     type Output = Self;\n     #[inline]\n@@ -180,8 +182,9 @@ where\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -194,8 +197,9 @@ where\n     }\n }\n \n-impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n where\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -210,9 +214,3 @@ where\n         self\n     }\n }\n-\n-pub type Mask8<const LANES: usize> = BitMask<LANES>;\n-pub type Mask16<const LANES: usize> = BitMask<LANES>;\n-pub type Mask32<const LANES: usize> = BitMask<LANES>;\n-pub type Mask64<const LANES: usize> = BitMask<LANES>;\n-pub type MaskSize<const LANES: usize> = BitMask<LANES>;"}, {"sha": "9c1cc4623f9a84115566147668e15f04a07afcab", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 187, "deletions": 226, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,264 +1,225 @@\n //! Masks that take up full SIMD vector registers.\n \n-macro_rules! define_mask {\n-    {\n-        $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>(\n-            crate::$type:ident<$lanes2:ident>\n-        );\n-    } => {\n-        $(#[$attr])*\n-        #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>(crate::$type<$lanes>)\n-        where\n-            crate::LaneCount<$lanes>: crate::SupportedLaneCount;\n-\n-        impl_full_mask_reductions! { $name, $type }\n-\n-        impl<const LANES: usize> Copy for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n-\n-        impl<const LANES: usize> Clone for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialEq for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialOrd for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                self.0.partial_cmp(&other.0)\n-            }\n-        }\n-\n-        impl<const LANES: usize> Eq for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n+use super::MaskElement;\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n+#[repr(transparent)]\n+pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-        impl<const LANES: usize> Ord for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                self.0.cmp(&other.0)\n-            }\n-        }\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n \n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            pub fn splat(value: bool) -> Self {\n-                Self(\n-                    <crate::$type<LANES>>::splat(\n-                        if value {\n-                            -1\n-                        } else {\n-                            0\n-                        }\n-                    ),\n-                )\n-            }\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialEq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0.eq(&other.0)\n+    }\n+}\n \n-            #[inline]\n-            pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n-                self.0[lane] == -1\n-            }\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n+where\n+    T: MaskElement + PartialOrd,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.0.partial_cmp(&other.0)\n+    }\n+}\n \n-            #[inline]\n-            pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n-                self.0[lane] = if value {\n-                    -1\n-                } else {\n-                    0\n-                }\n-            }\n+impl<T, const LANES: usize> Eq for Mask<T, LANES>\n+where\n+    T: MaskElement + Eq,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-            #[inline]\n-            pub fn to_int(self) -> crate::$type<LANES> {\n-                self.0\n-            }\n+impl<T, const LANES: usize> Ord for Mask<T, LANES>\n+where\n+    T: MaskElement + Ord,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        self.0.cmp(&other.0)\n+    }\n+}\n \n-            #[inline]\n-            pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n-                Self(value)\n-            }\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    pub fn splat(value: bool) -> Self {\n+        Self(Simd::splat(if value { T::TRUE } else { T::FALSE }))\n+    }\n \n-            #[inline]\n-            pub fn to_bitmask(self) -> [u8; crate::LaneCount::<LANES>::BITMASK_LEN] {\n-                unsafe {\n-                    // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n-                    assert_eq!(\n-                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n-                        crate::LaneCount::<LANES>::BITMASK_LEN,\n-                    );\n-                    let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = crate::intrinsics::simd_bitmask(self.0);\n-                    let mut bitmask: [u8; crate::LaneCount::<LANES>::BITMASK_LEN] = core::mem::transmute_copy(&bitmask);\n+    #[inline]\n+    pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        T::eq(self.0[lane], T::TRUE)\n+    }\n \n-                    // There is a bug where LLVM appears to implement this operation with the wrong\n-                    // bit order.\n-                    // TODO fix this in a better way\n-                    if cfg!(any(target_arch = \"mips\", target_arch = \"mips64\")) {\n-                        for x in bitmask.as_mut() {\n-                            *x = x.reverse_bits();\n-                        }\n-                    }\n+    #[inline]\n+    pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        self.0[lane] = if value { T::TRUE } else { T::FALSE }\n+    }\n \n-                    bitmask\n-                }\n-            }\n+    #[inline]\n+    pub fn to_int(self) -> Simd<T, LANES> {\n+        self.0\n+    }\n \n-            #[inline]\n-            pub fn from_bitmask(mut bitmask: [u8; crate::LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-                unsafe {\n-                    // There is a bug where LLVM appears to implement this operation with the wrong\n-                    // bit order.\n-                    // TODO fix this in a better way\n-                    if cfg!(any(target_arch = \"mips\", target_arch = \"mips64\")) {\n-                        for x in bitmask.as_mut() {\n-                            *x = x.reverse_bits();\n-                        }\n-                    }\n+    #[inline]\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        Self(value)\n+    }\n \n-                    // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n-                    assert_eq!(\n-                        core::mem::size_of::<<crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask>(),\n-                        crate::LaneCount::<LANES>::BITMASK_LEN,\n-                    );\n-                    let bitmask: <crate::LaneCount::<LANES> as crate::SupportedLaneCount>::IntBitMask = core::mem::transmute_copy(&bitmask);\n+    #[inline]\n+    pub fn convert<U>(self) -> Mask<U, LANES>\n+    where\n+        U: MaskElement,\n+    {\n+        unsafe { Mask(crate::intrinsics::simd_cast(self.0)) }\n+    }\n \n-                    Self::from_int_unchecked(crate::intrinsics::simd_select_bitmask(\n-                        bitmask,\n-                        Self::splat(true).to_int(),\n-                        Self::splat(false).to_int(),\n-                    ))\n+    #[inline]\n+    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n+        unsafe {\n+            // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+            assert_eq!(\n+                core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n+                LaneCount::<LANES>::BITMASK_LEN,\n+            );\n+            let bitmask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                crate::intrinsics::simd_bitmask(self.0);\n+            let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n+                core::mem::transmute_copy(&bitmask);\n+\n+            // There is a bug where LLVM appears to implement this operation with the wrong\n+            // bit order.\n+            // TODO fix this in a better way\n+            if cfg!(any(target_arch = \"mips\", target_arch = \"mips64\")) {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n                 }\n             }\n-        }\n \n-        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn from(value: $name<LANES>) -> Self {\n-                value.0\n-            }\n+            bitmask\n         }\n+    }\n \n-        impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitand(self, rhs: Self) -> Self {\n-                Self(self.0 & rhs.0)\n+    #[inline]\n+    pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n+        unsafe {\n+            // There is a bug where LLVM appears to implement this operation with the wrong\n+            // bit order.\n+            // TODO fix this in a better way\n+            if cfg!(any(target_arch = \"mips\", target_arch = \"mips64\")) {\n+                for x in bitmask.as_mut() {\n+                    *x = x.reverse_bits();\n+                }\n             }\n-        }\n \n-        impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitor(self, rhs: Self) -> Self {\n-                Self(self.0 | rhs.0)\n-            }\n-        }\n+            // TODO remove the transmute when rustc can use arrays of u8 as bitmasks\n+            assert_eq!(\n+                core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::IntBitMask>(),\n+                LaneCount::<LANES>::BITMASK_LEN,\n+            );\n+            let bitmask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n+                core::mem::transmute_copy(&bitmask);\n \n-        impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn bitxor(self, rhs: Self) -> Self::Output {\n-                Self(self.0 ^ rhs.0)\n-            }\n+            Self::from_int_unchecked(crate::intrinsics::simd_select_bitmask(\n+                bitmask,\n+                Self::splat(true).to_int(),\n+                Self::splat(false).to_int(),\n+            ))\n         }\n+    }\n \n-        impl<const LANES: usize> core::ops::Not for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Output = Self;\n-            #[inline]\n-            fn not(self) -> Self::Output {\n-                Self(!self.0)\n-            }\n-        }\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n     }\n-}\n \n-define_mask! {\n-    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n-    /// or unset.\n-    struct Mask8<const LANES: usize>(crate::SimdI8<LANES>);\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n+    }\n }\n \n-define_mask! {\n-    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n-    /// or unset.\n-    struct Mask16<const LANES: usize>(crate::SimdI16<LANES>);\n+impl<T, const LANES: usize> core::convert::From<Mask<T, LANES>> for Simd<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn from(value: Mask<T, LANES>) -> Self {\n+        value.0\n+    }\n }\n \n-define_mask! {\n-    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n-    /// or unset.\n-    struct Mask32<const LANES: usize>(crate::SimdI32<LANES>);\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: Self) -> Self {\n+        unsafe { Self(crate::intrinsics::simd_and(self.0, rhs.0)) }\n+    }\n }\n \n-define_mask! {\n-    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n-    /// or unset.\n-    struct Mask64<const LANES: usize>(crate::SimdI64<LANES>);\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: Self) -> Self {\n+        unsafe { Self(crate::intrinsics::simd_or(self.0, rhs.0)) }\n+    }\n }\n \n-define_mask! {\n-    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n-    /// or unset.\n-    struct MaskSize<const LANES: usize>(crate::SimdIsize<LANES>);\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: Self) -> Self {\n+        unsafe { Self(crate::intrinsics::simd_xor(self.0, rhs.0)) }\n+    }\n }\n \n-macro_rules! impl_from {\n-    { $from:ident ($from_inner:ident) => $($to:ident ($to_inner:ident)),* } => {\n-        $(\n-        impl<const LANES: usize> From<$from<LANES>> for $to<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            fn from(value: $from<LANES>) -> Self {\n-                let mut new = Self::splat(false);\n-                for i in 0..LANES {\n-                    unsafe { new.set_unchecked(i, value.test_unchecked(i)) }\n-                }\n-                new\n-            }\n-        }\n-        )*\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn not(self) -> Self::Output {\n+        Self::splat(true) ^ self\n     }\n }\n-impl_from! { Mask8 (SimdI8) => Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize) }\n-impl_from! { Mask16 (SimdI16) => Mask32 (SimdI32), Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8) }\n-impl_from! { Mask32 (SimdI32) => Mask64 (SimdI64), MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16) }\n-impl_from! { Mask64 (SimdI64) => MaskSize (SimdIsize), Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32) }\n-impl_from! { MaskSize (SimdIsize) => Mask8 (SimdI8), Mask16 (SimdI16), Mask32 (SimdI32), Mask64 (SimdI64) }"}, {"sha": "7affecbafd68db235a64bc471d2f03574e1cb346", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,16 +1,18 @@\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n macro_rules! impl_uint_arith {\n-    ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+    ($($ty:ty),+) => {\n+        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::MAX;\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([2, 1, 0, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n+            /// let x = Simd::from_array([2, 1, 0, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n             /// assert_eq!(x - 1, unsat);\n@@ -27,13 +29,13 @@ macro_rules! impl_uint_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::MAX;\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([2, 1, 0, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::MAX;\")]\n+            /// let x = Simd::from_array([2, 1, 0, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n             /// assert_eq!(unsat, x + 1);\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::splat(0));\")]\n+            /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n@@ -43,22 +45,22 @@ macro_rules! impl_uint_arith {\n }\n \n macro_rules! impl_int_arith {\n-    ($(($name:ident, $n:ident)),+) => {\n-        $( impl<const LANES: usize> $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n+    ($($ty:ty),+) => {\n+        $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n \n             /// Lanewise saturating add.\n             ///\n             /// # Examples\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([MIN, 0, 1, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, 0, 1, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([-1, MAX, MIN, -2]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([-1, MAX, MAX, MAX]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([-1, MAX, MIN, -2]));\n+            /// assert_eq!(sat, Simd::from_array([-1, MAX, MAX, MAX]));\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n@@ -71,13 +73,13 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([MIN, -2, -1, MAX]);\")]\n-            #[doc = concat!(\"let max = \", stringify!($name), \"::splat(MAX);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, -2, -1, MAX]);\n+            /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([1, MAX, MIN, 0]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([MIN, MIN, MIN, 0]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([1, MAX, MIN, 0]));\n+            /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n                 unsafe { crate::intrinsics::simd_saturating_sub(self, second) }\n@@ -90,13 +92,13 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let xs = \", stringify!($name), \"::from_array([MIN, MIN +1, -5, 0]);\")]\n-            #[doc = concat!(\"assert_eq!(xs.abs(), \", stringify!($name), \"::from_array([MIN, MAX, 5, 0]));\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let xs = Simd::from_array([MIN, MIN +1, -5, 0]);\n+            /// assert_eq!(xs.abs(), Simd::from_array([MIN, MAX, 5, 0]));\n             /// ```\n             #[inline]\n             pub fn abs(self) -> Self {\n-                const SHR: $n = <$n>::BITS as $n - 1;\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n                 let m = self >> SHR;\n                 (self^m) - m\n             }\n@@ -108,17 +110,17 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let xs = \", stringify!($name), \"::from_array([MIN, -2, 0, 3]);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let xs = Simd::from_array([MIN, -2, 0, 3]);\n             /// let unsat = xs.abs();\n             /// let sat = xs.saturating_abs();\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([MIN, 2, 0, 3]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([MAX, 2, 0, 3]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([MIN, 2, 0, 3]));\n+            /// assert_eq!(sat, Simd::from_array([MAX, 2, 0, 3]));\n             /// ```\n             #[inline]\n             pub fn saturating_abs(self) -> Self {\n                 // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n-                const SHR: $n = <$n>::BITS as $n - 1;\n+                const SHR: $ty = <$ty>::BITS as $ty - 1;\n                 let m = self >> SHR;\n                 (self^m).saturating_sub(m)\n             }\n@@ -130,12 +132,12 @@ macro_rules! impl_int_arith {\n             /// ```\n             /// # #![feature(portable_simd)]\n             /// # use core_simd::*;\n-            #[doc = concat!(\"# use core::\", stringify!($n), \"::{MIN, MAX};\")]\n-            #[doc = concat!(\"let x = \", stringify!($name), \"::from_array([MIN, -2, 3, MAX]);\")]\n+            #[doc = concat!(\"# use core::\", stringify!($ty), \"::{MIN, MAX};\")]\n+            /// let x = Simd::from_array([MIN, -2, 3, MAX]);\n             /// let unsat = -x;\n             /// let sat = x.saturating_neg();\n-            #[doc = concat!(\"assert_eq!(unsat, \", stringify!($name), \"::from_array([MIN, 2, -3, MIN + 1]));\")]\n-            #[doc = concat!(\"assert_eq!(sat, \", stringify!($name), \"::from_array([MAX, 2, -3, MIN + 1]));\")]\n+            /// assert_eq!(unsat, Simd::from_array([MIN, 2, -3, MIN + 1]));\n+            /// assert_eq!(sat, Simd::from_array([MAX, 2, -3, MIN + 1]));\n             /// ```\n             #[inline]\n             pub fn saturating_neg(self) -> Self {\n@@ -145,7 +147,5 @@ macro_rules! impl_int_arith {\n     }\n }\n \n-use crate::vector::*;\n-\n-impl_uint_arith! { (SimdU8, u8), (SimdU16, u16), (SimdU32, u32), (SimdU64, u64), (SimdUsize, usize) }\n-impl_int_arith! { (SimdI8, i8), (SimdI16, i16), (SimdI32, i32), (SimdI64, i64), (SimdIsize, isize) }\n+impl_uint_arith! { u8, u16, u32, u64, usize }\n+impl_int_arith! { i8, i16, i32, i64, isize }"}, {"sha": "900315660005642eccf4d03ce24fc3c96160be0f", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 326, "deletions": 353, "changes": 679, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,4 +1,27 @@\n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+\n+impl<I, T, const LANES: usize> core::ops::Index<I> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    I: core::slice::SliceIndex<[T]>,\n+{\n+    type Output = I::Output;\n+    fn index(&self, index: I) -> &Self::Output {\n+        &self.as_array()[index]\n+    }\n+}\n+\n+impl<I, T, const LANES: usize> core::ops::IndexMut<I> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+    I: core::slice::SliceIndex<[T]>,\n+{\n+    fn index_mut(&mut self, index: I) -> &mut Self::Output {\n+        &mut self.as_mut_array()[index]\n+    }\n+}\n \n /// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n fn invalid_shift_rhs<T>(rhs: T) -> bool\n@@ -132,40 +155,40 @@ macro_rules! impl_ref_ops {\n \n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n-    { impl Add for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Add::add, AddAssign::add_assign, simd_add }\n+    { impl Add for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Add::add, AddAssign::add_assign, simd_add }\n     };\n-    { impl Sub for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+    { impl Sub for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n     };\n-    { impl Mul for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+    { impl Mul for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n     };\n-    { impl Div for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Div::div, DivAssign::div_assign, simd_div }\n+    { impl Div for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Div::div, DivAssign::div_assign, simd_div }\n     };\n-    { impl Rem for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+    { impl Rem for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n     };\n-    { impl Shl for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+    { impl Shl for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n     };\n-    { impl Shr for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+    { impl Shr for $scalar:ty } => {\n+        impl_op! { @binary $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n     };\n-    { impl BitAnd for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+    { impl BitAnd for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n     };\n-    { impl BitOr for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+    { impl BitOr for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n     };\n-    { impl BitXor for $type:ident, $scalar:ty } => {\n-        impl_op! { @binary $type, $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n+    { impl BitXor for $scalar:ty } => {\n+        impl_op! { @binary $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n     };\n \n-    { impl Not for $type:ident, $scalar:ty } => {\n+    { impl Not for $scalar:ty } => {\n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Not for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::Not for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -177,9 +200,9 @@ macro_rules! impl_op {\n         }\n     };\n \n-    { impl Neg for $type:ident, $scalar:ty } => {\n+    { impl Neg for $scalar:ty } => {\n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Neg for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::Neg for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -191,35 +214,10 @@ macro_rules! impl_op {\n         }\n     };\n \n-    { impl Index for $type:ident, $scalar:ty } => {\n-        impl<I, const LANES: usize> core::ops::Index<I> for crate::$type<LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-            I: core::slice::SliceIndex<[$scalar]>,\n-        {\n-            type Output = I::Output;\n-            fn index(&self, index: I) -> &Self::Output {\n-                let slice: &[_] = self.as_ref();\n-                &slice[index]\n-            }\n-        }\n-\n-        impl<I, const LANES: usize> core::ops::IndexMut<I> for crate::$type<LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-            I: core::slice::SliceIndex<[$scalar]>,\n-        {\n-            fn index_mut(&mut self, index: I) -> &mut Self::Output {\n-                let slice: &mut [_] = self.as_mut();\n-                &mut slice[index]\n-            }\n-        }\n-    };\n-\n     // generic binary op with assignment when output is `Self`\n-    { @binary $type:ident, $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Self> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -235,7 +233,7 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<$scalar> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$trait<$scalar> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -249,21 +247,21 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<crate::$type<LANES>> for $scalar\n+            impl<const LANES: usize> core::ops::$trait<Simd<$scalar, LANES>> for $scalar\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n-                type Output = crate::$type<LANES>;\n+                type Output = Simd<$scalar, LANES>;\n \n                 #[inline]\n-                fn $trait_fn(self, rhs: crate::$type<LANES>) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(crate::$type::splat(self), rhs)\n+                fn $trait_fn(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                    core::ops::$trait::$trait_fn(Simd::splat(self), rhs)\n                 }\n             }\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<Self> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$assign_trait<Self> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -277,7 +275,7 @@ macro_rules! impl_op {\n         }\n \n         impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for crate::$type<LANES>\n+            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for Simd<$scalar, LANES>\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n@@ -292,379 +290,354 @@ macro_rules! impl_op {\n \n /// Implements floating-point operators for the provided types.\n macro_rules! impl_float_ops {\n-    { $($scalar:ty => $($vector:ident),*;)* } => {\n-        $( // scalar\n-            $( // vector\n-                impl_op! { impl Add for $vector, $scalar }\n-                impl_op! { impl Sub for $vector, $scalar }\n-                impl_op! { impl Mul for $vector, $scalar }\n-                impl_op! { impl Div for $vector, $scalar }\n-                impl_op! { impl Rem for $vector, $scalar }\n-                impl_op! { impl Neg for $vector, $scalar }\n-                impl_op! { impl Index for $vector, $scalar }\n-            )*\n+    { $($scalar:ty),* } => {\n+        $(\n+            impl_op! { impl Add for $scalar }\n+            impl_op! { impl Sub for $scalar }\n+            impl_op! { impl Mul for $scalar }\n+            impl_op! { impl Div for $scalar }\n+            impl_op! { impl Rem for $scalar }\n+            impl_op! { impl Neg for $scalar }\n         )*\n     };\n }\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_unsigned_int_ops {\n-    { $($scalar:ty => $($vector:ident),*;)* } => {\n-        $( // scalar\n-            $( // vector\n-                impl_op! { impl Add for $vector, $scalar }\n-                impl_op! { impl Sub for $vector, $scalar }\n-                impl_op! { impl Mul for $vector, $scalar }\n-                impl_op! { impl BitAnd for $vector, $scalar }\n-                impl_op! { impl BitOr  for $vector, $scalar }\n-                impl_op! { impl BitXor for $vector, $scalar }\n-                impl_op! { impl Not for $vector, $scalar }\n-                impl_op! { impl Index for $vector, $scalar }\n-\n-                // Integers panic on divide by 0\n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Div<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn div(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_array()\n-                                .iter()\n-                                .any(|x| *x == 0)\n-                            {\n-                                panic!(\"attempt to divide by zero\");\n-                            }\n-\n-                            // Guards for div(MIN, -1),\n-                            // this check only applies to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                    .zip(rhs.as_array().iter())\n-                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                                panic!(\"attempt to divide with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_div(self, rhs) }\n+    { $($scalar:ty),* } => {\n+        $(\n+            impl_op! { impl Add for $scalar }\n+            impl_op! { impl Sub for $scalar }\n+            impl_op! { impl Mul for $scalar }\n+            impl_op! { impl BitAnd for $scalar }\n+            impl_op! { impl BitOr  for $scalar }\n+            impl_op! { impl BitXor for $scalar }\n+            impl_op! { impl Not for $scalar }\n+\n+            // Integers panic on divide by 0\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn div(self, rhs: Self) -> Self::Output {\n+                        if rhs.as_array()\n+                            .iter()\n+                            .any(|x| *x == 0)\n+                        {\n+                            panic!(\"attempt to divide by zero\");\n+                        }\n+\n+                        // Guards for div(MIN, -1),\n+                        // this check only applies to signed ints\n+                        if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                .zip(rhs.as_array().iter())\n+                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                            panic!(\"attempt to divide with overflow\");\n                         }\n+                        unsafe { crate::intrinsics::simd_div(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Div<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn div(self, rhs: $scalar) -> Self::Output {\n-                            if rhs == 0 {\n-                                panic!(\"attempt to divide by zero\");\n-                            }\n-                            if <$scalar>::MIN != 0 &&\n-                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                                rhs == -1 as _ {\n-                                    panic!(\"attempt to divide with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_div(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn div(self, rhs: $scalar) -> Self::Output {\n+                        if rhs == 0 {\n+                            panic!(\"attempt to divide by zero\");\n+                        }\n+                        if <$scalar>::MIN != 0 &&\n+                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n+                            rhs == -1 as _ {\n+                                panic!(\"attempt to divide with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_div(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Div<crate::$vector<LANES>> for $scalar\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = crate::$vector<LANES>;\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Div<Simd<$scalar, LANES>> for $scalar\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Simd<$scalar, LANES>;\n \n-                        #[inline]\n-                        fn div(self, rhs: crate::$vector<LANES>) -> Self::Output {\n-                            crate::$vector::splat(self) / rhs\n-                        }\n+                    #[inline]\n+                    fn div(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                        Simd::splat(self) / rhs\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::DivAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn div_assign(&mut self, rhs: Self) {\n-                            *self = *self / rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::DivAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn div_assign(&mut self, rhs: Self) {\n+                        *self = *self / rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::DivAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn div_assign(&mut self, rhs: $scalar) {\n-                            *self = *self / rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::DivAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn div_assign(&mut self, rhs: $scalar) {\n+                        *self = *self / rhs;\n                     }\n                 }\n+            }\n \n-                // remainder panics on zero divisor\n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Rem<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn rem(self, rhs: Self) -> Self::Output {\n-                            if rhs.as_array()\n-                                .iter()\n-                                .any(|x| *x == 0)\n-                            {\n-                                panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                            }\n-\n-                            // Guards for rem(MIN, -1)\n-                            // this branch applies the check only to signed ints\n-                            if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                    .zip(rhs.as_array().iter())\n-                                    .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                                panic!(\"attempt to calculate the remainder with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_rem(self, rhs) }\n+            // remainder panics on zero divisor\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: Self) -> Self::Output {\n+                        if rhs.as_array()\n+                            .iter()\n+                            .any(|x| *x == 0)\n+                        {\n+                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n                         }\n+\n+                        // Guards for rem(MIN, -1)\n+                        // this branch applies the check only to signed ints\n+                        if <$scalar>::MIN != 0 && self.as_array().iter()\n+                                .zip(rhs.as_array().iter())\n+                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n+                            panic!(\"attempt to calculate the remainder with overflow\");\n+                        }\n+                        unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Rem<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn rem(self, rhs: $scalar) -> Self::Output {\n-                            if rhs == 0 {\n-                                panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                            }\n-                            if <$scalar>::MIN != 0 &&\n-                                self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                                rhs == -1 as _ {\n-                                    panic!(\"attempt to calculate the remainder with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_rem(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn rem(self, rhs: $scalar) -> Self::Output {\n+                        if rhs == 0 {\n+                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n+                        }\n+                        if <$scalar>::MIN != 0 &&\n+                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n+                            rhs == -1 as _ {\n+                                panic!(\"attempt to calculate the remainder with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_rem(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Rem<crate::$vector<LANES>> for $scalar\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = crate::$vector<LANES>;\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Rem<Simd<$scalar, LANES>> for $scalar\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Simd<$scalar, LANES>;\n \n-                        #[inline]\n-                        fn rem(self, rhs: crate::$vector<LANES>) -> Self::Output {\n-                            crate::$vector::splat(self) % rhs\n-                        }\n+                    #[inline]\n+                    fn rem(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n+                        Simd::splat(self) % rhs\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::RemAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn rem_assign(&mut self, rhs: Self) {\n-                            *self = *self % rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::RemAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn rem_assign(&mut self, rhs: Self) {\n+                        *self = *self % rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::RemAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn rem_assign(&mut self, rhs: $scalar) {\n-                            *self = *self % rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::RemAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn rem_assign(&mut self, rhs: $scalar) {\n+                        *self = *self % rhs;\n                     }\n                 }\n+            }\n \n-                // shifts panic on overflow\n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shl<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shl(self, rhs: Self) -> Self::Output {\n-                            // TODO there is probably a better way of doing this\n-                            if rhs.as_array()\n-                                .iter()\n-                                .copied()\n-                                .any(invalid_shift_rhs)\n-                            {\n-                                panic!(\"attempt to shift left with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_shl(self, rhs) }\n+            // shifts panic on overflow\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shl(self, rhs: Self) -> Self::Output {\n+                        // TODO there is probably a better way of doing this\n+                        if rhs.as_array()\n+                            .iter()\n+                            .copied()\n+                            .any(invalid_shift_rhs)\n+                        {\n+                            panic!(\"attempt to shift left with overflow\");\n                         }\n+                        unsafe { crate::intrinsics::simd_shl(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shl<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shl(self, rhs: $scalar) -> Self::Output {\n-                            if invalid_shift_rhs(rhs) {\n-                                panic!(\"attempt to shift left with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_shl(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shl<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shl(self, rhs: $scalar) -> Self::Output {\n+                        if invalid_shift_rhs(rhs) {\n+                            panic!(\"attempt to shift left with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_shl(self, rhs) }\n                     }\n                 }\n+            }\n \n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShlAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shl_assign(&mut self, rhs: Self) {\n-                            *self = *self << rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShlAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shl_assign(&mut self, rhs: Self) {\n+                        *self = *self << rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShlAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shl_assign(&mut self, rhs: $scalar) {\n-                            *self = *self << rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShlAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shl_assign(&mut self, rhs: $scalar) {\n+                        *self = *self << rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shr<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shr(self, rhs: Self) -> Self::Output {\n-                            // TODO there is probably a better way of doing this\n-                            if rhs.as_array()\n-                                .iter()\n-                                .copied()\n-                                .any(invalid_shift_rhs)\n-                            {\n-                                panic!(\"attempt to shift with overflow\");\n-                            }\n-                            unsafe { crate::intrinsics::simd_shr(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shr(self, rhs: Self) -> Self::Output {\n+                        // TODO there is probably a better way of doing this\n+                        if rhs.as_array()\n+                            .iter()\n+                            .copied()\n+                            .any(invalid_shift_rhs)\n+                        {\n+                            panic!(\"attempt to shift with overflow\");\n                         }\n+                        unsafe { crate::intrinsics::simd_shr(self, rhs) }\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::Shr<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        type Output = Self;\n-\n-                        #[inline]\n-                        fn shr(self, rhs: $scalar) -> Self::Output {\n-                            if invalid_shift_rhs(rhs) {\n-                                panic!(\"attempt to shift with overflow\");\n-                            }\n-                            let rhs = Self::splat(rhs);\n-                            unsafe { crate::intrinsics::simd_shr(self, rhs) }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::Shr<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    type Output = Self;\n+\n+                    #[inline]\n+                    fn shr(self, rhs: $scalar) -> Self::Output {\n+                        if invalid_shift_rhs(rhs) {\n+                            panic!(\"attempt to shift with overflow\");\n                         }\n+                        let rhs = Self::splat(rhs);\n+                        unsafe { crate::intrinsics::simd_shr(self, rhs) }\n                     }\n                 }\n+            }\n \n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShrAssign<Self> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shr_assign(&mut self, rhs: Self) {\n-                            *self = *self >> rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShrAssign<Self> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shr_assign(&mut self, rhs: Self) {\n+                        *self = *self >> rhs;\n                     }\n                 }\n+            }\n \n-                impl_ref_ops! {\n-                    impl<const LANES: usize> core::ops::ShrAssign<$scalar> for crate::$vector<LANES>\n-                    where\n-                        LaneCount<LANES>: SupportedLaneCount,\n-                    {\n-                        #[inline]\n-                        fn shr_assign(&mut self, rhs: $scalar) {\n-                            *self = *self >> rhs;\n-                        }\n+            impl_ref_ops! {\n+                impl<const LANES: usize> core::ops::ShrAssign<$scalar> for Simd<$scalar, LANES>\n+                where\n+                    LaneCount<LANES>: SupportedLaneCount,\n+                {\n+                    #[inline]\n+                    fn shr_assign(&mut self, rhs: $scalar) {\n+                        *self = *self >> rhs;\n                     }\n                 }\n-            )*\n+            }\n         )*\n     };\n }\n \n /// Implements unsigned integer operators for the provided types.\n macro_rules! impl_signed_int_ops {\n-    { $($scalar:ty => $($vector:ident),*;)* } => {\n-        impl_unsigned_int_ops! { $($scalar => $($vector),*;)* }\n+    { $($scalar:ty),* } => {\n+        impl_unsigned_int_ops! { $($scalar),* }\n         $( // scalar\n-            $( // vector\n-                impl_op! { impl Neg for $vector, $scalar }\n-            )*\n+            impl_op! { impl Neg for $scalar }\n         )*\n     };\n }\n \n-impl_unsigned_int_ops! {\n-    u8 => SimdU8;\n-    u16 => SimdU16;\n-    u32 => SimdU32;\n-    u64 => SimdU64;\n-    usize => SimdUsize;\n-}\n-\n-impl_signed_int_ops! {\n-    i8 => SimdI8;\n-    i16 => SimdI16;\n-    i32 => SimdI32;\n-    i64 => SimdI64;\n-    isize => SimdIsize;\n-}\n-\n-impl_float_ops! {\n-    f32 => SimdF32;\n-    f64 => SimdF64;\n-}\n+impl_unsigned_int_ops! { u8, u16, u32, u64, usize }\n+impl_signed_int_ops! { i8, i16, i32, i64, isize }\n+impl_float_ops! { f32, f64 }"}, {"sha": "cc58778b6b4b35fc3d36f4783a27cbb86bf362b0", "filename": "crates/core_simd/src/permute.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,6 +1,9 @@\n macro_rules! impl_shuffle_lane {\n-    { $name:ident, $fn:ident, $n:literal } => {\n-        impl $name<$n> {\n+    { $fn:ident, $n:literal } => {\n+        impl<T> crate::Simd<T, $n>\n+        where\n+            T: crate::SimdElement,\n+        {\n             /// A const SIMD shuffle that takes 2 SIMD vectors and produces another vector, using\n             /// the indices in the const parameter. The first or \"self\" vector will have its lanes\n             /// indexed from 0, and the second vector will have its first lane indexed at $n.\n@@ -12,12 +15,12 @@ macro_rules! impl_shuffle_lane {\n             ///\n             /// ```\n             /// #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let a = f32x4::from_array([1.0, 2.0, 3.0, 4.0]);\n-            /// let b = f32x4::from_array([5.0, 6.0, 7.0, 8.0]);\n+            /// # use core_simd::Simd;\n+            /// let a = Simd::from_array([1.0, 2.0, 3.0, 4.0]);\n+            /// let b = Simd::from_array([5.0, 6.0, 7.0, 8.0]);\n             /// const IDXS: [u32; 4] = [4,0,3,7];\n-            /// let c = f32x4::shuffle::<IDXS>(a,b);\n-            /// assert_eq!(f32x4::from_array([5.0, 1.0, 4.0, 8.0]), c);\n+            /// let c = Simd::<_, 4>::shuffle::<IDXS>(a,b);\n+            /// assert_eq!(Simd::from_array([5.0, 1.0, 4.0, 8.0]), c);\n             /// ```\n             #[inline]\n             pub fn shuffle<const IDX: [u32; $n]>(self, second: Self) -> Self {\n@@ -53,9 +56,9 @@ macro_rules! impl_shuffle_lane {\n             ///\n             /// ```\n             /// #![feature(portable_simd)]\n-            /// # use core_simd::SimdU32;\n-            /// let a = SimdU32::from_array([0, 1, 2, 3]);\n-            /// let b = SimdU32::from_array([4, 5, 6, 7]);\n+            /// # use core_simd::Simd;\n+            /// let a = Simd::from_array([0, 1, 2, 3]);\n+            /// let b = Simd::from_array([4, 5, 6, 7]);\n             /// let (x, y) = a.interleave(b);\n             /// assert_eq!(x.to_array(), [0, 4, 1, 5]);\n             /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n@@ -105,9 +108,9 @@ macro_rules! impl_shuffle_lane {\n             ///\n             /// ```\n             /// #![feature(portable_simd)]\n-            /// # use core_simd::SimdU32;\n-            /// let a = SimdU32::from_array([0, 4, 1, 5]);\n-            /// let b = SimdU32::from_array([2, 6, 3, 7]);\n+            /// # use core_simd::Simd;\n+            /// let a = Simd::from_array([0, 4, 1, 5]);\n+            /// let b = Simd::from_array([2, 6, 3, 7]);\n             /// let (x, y) = a.deinterleave(b);\n             /// assert_eq!(x.to_array(), [0, 1, 2, 3]);\n             /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n@@ -138,12 +141,8 @@ macro_rules! impl_shuffle_lane {\n     }\n }\n \n-macro_rules! impl_shuffle_2pow_lanes {\n-    { $name:ident } => {\n-        impl_shuffle_lane!{ $name, simd_shuffle2, 2 }\n-        impl_shuffle_lane!{ $name, simd_shuffle4, 4 }\n-        impl_shuffle_lane!{ $name, simd_shuffle8, 8 }\n-        impl_shuffle_lane!{ $name, simd_shuffle16, 16 }\n-        impl_shuffle_lane!{ $name, simd_shuffle32, 32 }\n-    }\n-}\n+impl_shuffle_lane! { simd_shuffle2, 2 }\n+impl_shuffle_lane! { simd_shuffle4, 4 }\n+impl_shuffle_lane! { simd_shuffle8, 8 }\n+impl_shuffle_lane! { simd_shuffle16, 16 }\n+impl_shuffle_lane! { simd_shuffle32, 32 }"}, {"sha": "943d2856e359034760003d784e45c18ce5abd18c", "filename": "crates/core_simd/src/reduction.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,8 +1,10 @@\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n macro_rules! impl_integer_reductions {\n-    { $name:ident, $scalar:ty } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $scalar:ty } => {\n+        impl<const LANES: usize> Simd<$scalar, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n@@ -52,11 +54,22 @@ macro_rules! impl_integer_reductions {\n     }\n }\n \n+impl_integer_reductions! { i8 }\n+impl_integer_reductions! { i16 }\n+impl_integer_reductions! { i32 }\n+impl_integer_reductions! { i64 }\n+impl_integer_reductions! { isize }\n+impl_integer_reductions! { u8 }\n+impl_integer_reductions! { u16 }\n+impl_integer_reductions! { u32 }\n+impl_integer_reductions! { u64 }\n+impl_integer_reductions! { usize }\n+\n macro_rules! impl_float_reductions {\n-    { $name:ident, $scalar:ty } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $scalar:ty } => {\n+        impl<const LANES: usize> Simd<$scalar, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n \n             /// Horizontal add.  Returns the sum of the lanes of the vector.\n@@ -102,42 +115,5 @@ macro_rules! impl_float_reductions {\n     }\n }\n \n-macro_rules! impl_full_mask_reductions {\n-    { $name:ident, $bits_ty:ident } => {\n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[inline]\n-            pub fn any(self) -> bool {\n-                unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n-            }\n-\n-            #[inline]\n-            pub fn all(self) -> bool {\n-                unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n-            }\n-        }\n-    }\n-}\n-\n-macro_rules! impl_opaque_mask_reductions {\n-    { $name:ident, $bits_ty:ident } => {\n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            /// Returns true if any lane is set, or false otherwise.\n-            #[inline]\n-            pub fn any(self) -> bool {\n-                self.0.any()\n-            }\n-\n-            /// Returns true if all lanes are set, or false otherwise.\n-            #[inline]\n-            pub fn all(self) -> bool {\n-                self.0.all()\n-            }\n-        }\n-    }\n-}\n+impl_float_reductions! { f32 }\n+impl_float_reductions! { f64 }"}, {"sha": "96d46b9a12320c47ddab809abb2a644c0adf47d6", "filename": "crates/core_simd/src/round.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,11 +1,13 @@\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n+\n macro_rules! implement {\n     {\n-        $type:ident, $int_type:ident\n+        $type:ty, $int_type:ty\n     } => {\n         #[cfg(feature = \"std\")]\n-        impl<const LANES: usize> crate::$type<LANES>\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Returns the smallest integer greater than or equal to each lane.\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n@@ -43,9 +45,9 @@ macro_rules! implement {\n             }\n         }\n \n-        impl<const LANES: usize> crate::$type<LANES>\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n+            LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Rounds toward zero and converts to the same-width integer type, assuming that\n             /// the value is finite and fits in that type.\n@@ -57,19 +59,19 @@ macro_rules! implement {\n             /// * Not be infinite\n             /// * Be representable in the return type, after truncating off its fractional part\n             #[inline]\n-            pub unsafe fn to_int_unchecked(self) -> crate::$int_type<LANES> {\n+            pub unsafe fn to_int_unchecked(self) -> Simd<$int_type, LANES> {\n                 crate::intrinsics::simd_cast(self)\n             }\n \n             /// Creates a floating-point vector from an integer vector.  Rounds values that are\n             /// not exactly representable.\n             #[inline]\n-            pub fn round_from_int(value: crate::$int_type<LANES>) -> Self {\n+            pub fn round_from_int(value: Simd<$int_type, LANES>) -> Self {\n                 unsafe { crate::intrinsics::simd_cast(value) }\n             }\n         }\n     }\n }\n \n-implement! { SimdF32, SimdI32 }\n-implement! { SimdF64, SimdI64 }\n+implement! { f32, i32 }\n+implement! { f64, i64 }"}, {"sha": "0951639c9426c3e9e12711db8f8d5b0227c8b60d", "filename": "crates/core_simd/src/select.rs", "status": "modified", "additions": 68, "deletions": 70, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,3 +1,5 @@\n+use crate::{LaneCount, Mask, MaskElement, Simd, SimdElement, SupportedLaneCount};\n+\n mod sealed {\n     pub trait Sealed {}\n }\n@@ -9,79 +11,75 @@ pub trait Select<Mask>: Sealed {\n     fn select(mask: Mask, true_values: Self, false_values: Self) -> Self;\n }\n \n-macro_rules! impl_select {\n-    {\n-        $mask:ident ($bits_ty:ident): $($type:ident),*\n-    } => {\n-        $(\n-        impl<const LANES: usize> Sealed for crate::$type<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n-        impl<const LANES: usize> Select<crate::$mask<LANES>> for crate::$type<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[doc(hidden)]\n-            #[inline]\n-            fn select(mask: crate::$mask<LANES>, true_values: Self, false_values: Self) -> Self {\n-                unsafe { crate::intrinsics::simd_select(mask.to_int(), true_values, false_values) }\n-            }\n-        }\n-        )*\n+impl<T, const LANES: usize> Sealed for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-        impl<const LANES: usize> Sealed for crate::$mask<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n+impl<T, const LANES: usize> Select<Mask<T::Mask, LANES>> for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn select(mask: Mask<T::Mask, LANES>, true_values: Self, false_values: Self) -> Self {\n+        unsafe { crate::intrinsics::simd_select(mask.to_int(), true_values, false_values) }\n+    }\n+}\n \n-        impl<const LANES: usize> Select<Self> for crate::$mask<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            #[doc(hidden)]\n-            #[inline]\n-            fn select(mask: Self, true_values: Self, false_values: Self) -> Self {\n-                mask & true_values | !mask & false_values\n-            }\n-        }\n+impl<T, const LANES: usize> Sealed for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n-        impl<const LANES: usize> crate::$mask<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            /// Choose lanes from two vectors.\n-            ///\n-            /// For each lane in the mask, choose the corresponding lane from `true_values` if\n-            /// that lane mask is true, and `false_values` if that lane mask is false.\n-            ///\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::{Mask32, SimdI32};\n-            /// let a = SimdI32::from_array([0, 1, 2, 3]);\n-            /// let b = SimdI32::from_array([4, 5, 6, 7]);\n-            /// let mask = Mask32::from_array([true, false, false, true]);\n-            /// let c = mask.select(a, b);\n-            /// assert_eq!(c.to_array(), [0, 5, 6, 3]);\n-            /// ```\n-            ///\n-            /// `select` can also be used on masks:\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::Mask32;\n-            /// let a = Mask32::from_array([true, true, false, false]);\n-            /// let b = Mask32::from_array([false, false, true, true]);\n-            /// let mask = Mask32::from_array([true, false, false, true]);\n-            /// let c = mask.select(a, b);\n-            /// assert_eq!(c.to_array(), [true, false, true, false]);\n-            /// ```\n-            #[inline]\n-            pub fn select<S: Select<Self>>(self, true_values: S, false_values: S) -> S {\n-                S::select(self, true_values, false_values)\n-            }\n-        }\n+impl<T, const LANES: usize> Select<Self> for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[doc(hidden)]\n+    #[inline]\n+    fn select(mask: Self, true_values: Self, false_values: Self) -> Self {\n+        mask & true_values | !mask & false_values\n     }\n }\n \n-impl_select! { Mask8 (SimdI8): SimdU8, SimdI8 }\n-impl_select! { Mask16 (SimdI16): SimdU16, SimdI16 }\n-impl_select! { Mask32 (SimdI32): SimdU32, SimdI32, SimdF32}\n-impl_select! { Mask64 (SimdI64): SimdU64, SimdI64, SimdF64}\n-impl_select! { MaskSize (SimdIsize): SimdUsize, SimdIsize }\n+impl<T, const LANES: usize> Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Choose lanes from two vectors.\n+    ///\n+    /// For each lane in the mask, choose the corresponding lane from `true_values` if\n+    /// that lane mask is true, and `false_values` if that lane mask is false.\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::{Mask, Simd};\n+    /// let a = Simd::from_array([0, 1, 2, 3]);\n+    /// let b = Simd::from_array([4, 5, 6, 7]);\n+    /// let mask = Mask::from_array([true, false, false, true]);\n+    /// let c = mask.select(a, b);\n+    /// assert_eq!(c.to_array(), [0, 5, 6, 3]);\n+    /// ```\n+    ///\n+    /// `select` can also be used on masks:\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::Mask;\n+    /// let a = Mask::<i32, 4>::from_array([true, true, false, false]);\n+    /// let b = Mask::<i32, 4>::from_array([false, false, true, true]);\n+    /// let mask = Mask::<i32, 4>::from_array([true, false, false, true]);\n+    /// let c = mask.select(a, b);\n+    /// assert_eq!(c.to_array(), [true, false, true, false]);\n+    /// ```\n+    #[inline]\n+    pub fn select<S: Select<Self>>(self, true_values: S, false_values: S) -> S {\n+        S::select(self, true_values, false_values)\n+    }\n+}"}, {"sha": "bd818f5321182a93d85e9a4f4c38c041eabccd45", "filename": "crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,39 +1,39 @@\n macro_rules! impl_to_bytes {\n-    { $name:ident, $size:literal } => {\n-        impl<const LANES: usize> crate::$name<LANES>\n+    { $ty:ty, $size:literal } => {\n+        impl<const LANES: usize> crate::Simd<$ty, LANES>\n         where\n             crate::LaneCount<LANES>: crate::SupportedLaneCount,\n             crate::LaneCount<{{ $size * LANES }}>: crate::SupportedLaneCount,\n         {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order.\n-            pub fn to_ne_bytes(self) -> crate::SimdU8<{{ $size * LANES }}> {\n+            pub fn to_ne_bytes(self) -> crate::Simd<u8, {{ $size * LANES }}> {\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Create a native endian integer value from its memory representation as a byte array\n             /// in native endianness.\n-            pub fn from_ne_bytes(bytes: crate::SimdU8<{{ $size * LANES }}>) -> Self {\n+            pub fn from_ne_bytes(bytes: crate::Simd<u8, {{ $size * LANES }}>) -> Self {\n                 unsafe { core::mem::transmute_copy(&bytes) }\n             }\n         }\n     }\n }\n \n-impl_to_bytes! { SimdU8, 1 }\n-impl_to_bytes! { SimdU16, 2 }\n-impl_to_bytes! { SimdU32, 4 }\n-impl_to_bytes! { SimdU64, 8 }\n+impl_to_bytes! { u8, 1 }\n+impl_to_bytes! { u16, 2 }\n+impl_to_bytes! { u32, 4 }\n+impl_to_bytes! { u64, 8 }\n #[cfg(target_pointer_width = \"32\")]\n-impl_to_bytes! { SimdUsize, 4 }\n+impl_to_bytes! { usize, 4 }\n #[cfg(target_pointer_width = \"64\")]\n-impl_to_bytes! { SimdUsize, 8 }\n+impl_to_bytes! { usize, 8 }\n \n-impl_to_bytes! { SimdI8, 1 }\n-impl_to_bytes! { SimdI16, 2 }\n-impl_to_bytes! { SimdI32, 4 }\n-impl_to_bytes! { SimdI64, 8 }\n+impl_to_bytes! { i8, 1 }\n+impl_to_bytes! { i16, 2 }\n+impl_to_bytes! { i32, 4 }\n+impl_to_bytes! { i64, 8 }\n #[cfg(target_pointer_width = \"32\")]\n-impl_to_bytes! { SimdIsize, 4 }\n+impl_to_bytes! { isize, 4 }\n #[cfg(target_pointer_width = \"64\")]\n-impl_to_bytes! { SimdIsize, 8 }\n+impl_to_bytes! { isize, 8 }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "crates/core_simd/src/transmute.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/50eb35eb3b87c37876cb925c5ac3428ef6fa080a/crates%2Fcore_simd%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50eb35eb3b87c37876cb925c5ac3428ef6fa080a/crates%2Fcore_simd%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ftransmute.rs?ref=50eb35eb3b87c37876cb925c5ac3428ef6fa080a"}, {"sha": "07e8a6c5926cbdbd5f9092acf1e8a56270c62e40", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 389, "deletions": 14, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,6 +1,3 @@\n-#[macro_use]\n-mod vector_impl;\n-\n mod float;\n mod int;\n mod uint;\n@@ -12,21 +9,399 @@ pub use uint::*;\n // Vectors of pointers are not for public use at the current time.\n pub(crate) mod ptr;\n \n+use crate::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n+\n+/// A SIMD vector of `LANES` elements of type `T`.\n+#[repr(simd)]\n+pub struct Simd<T, const LANES: usize>([T; LANES])\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount;\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    /// Construct a SIMD vector by setting all lanes to the given value.\n+    pub const fn splat(value: T) -> Self {\n+        Self([value; LANES])\n+    }\n+\n+    /// Returns an array reference containing the entire SIMD vector.\n+    pub const fn as_array(&self) -> &[T; LANES] {\n+        &self.0\n+    }\n+\n+    /// Returns a mutable array reference containing the entire SIMD vector.\n+    pub fn as_mut_array(&mut self) -> &mut [T; LANES] {\n+        &mut self.0\n+    }\n+\n+    /// Converts an array to a SIMD vector.\n+    pub const fn from_array(array: [T; LANES]) -> Self {\n+        Self(array)\n+    }\n+\n+    /// Converts a SIMD vector to an array.\n+    pub const fn to_array(self) -> [T; LANES] {\n+        self.0\n+    }\n+\n+    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    ///\n+    /// let result = Simd::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, 15]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_or(slice: &[T], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+        Self::gather_select(slice, Mask::splat(true), idxs, or)\n+    }\n+\n+    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds indices instead use the default value for that lane (0).\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    ///\n+    /// let result = Simd::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([0, 13, 10, 15]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, LANES>) -> Self\n+    where\n+        T: Default,\n+    {\n+        Self::gather_or(slice, idxs, Self::splat(T::default()))\n+    }\n+\n+    /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    ///\n+    /// let result = Simd::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    pub fn gather_select(\n+        slice: &[T],\n+        mask: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+        or: Self,\n+    ) -> Self {\n+        let mask = (mask & idxs.lanes_lt(Simd::splat(slice.len()))).to_int();\n+        let base_ptr = crate::vector::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        // Ferris forgive me, I have done pointer arithmetic here.\n+        let ptrs = base_ptr.wrapping_add(idxs);\n+        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+        unsafe { crate::intrinsics::simd_gather(or, ptrs, mask) }\n+    }\n+\n+    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds indices are not written.\n+    /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    ///\n+    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+    /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, LANES>) {\n+        self.scatter_select(slice, Mask::splat(true), idxs)\n+    }\n+\n+    /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n+    /// Out-of-bounds or masked indices are not written.\n+    /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # use core_simd::*;\n+    /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    ///\n+    /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n+    /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n+    /// ```\n+    #[inline]\n+    pub fn scatter_select(\n+        self,\n+        slice: &mut [T],\n+        mask: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n+    ) {\n+        // We must construct our scatter mask before we derive a pointer!\n+        let mask = (mask & idxs.lanes_lt(Simd::splat(slice.len()))).to_int();\n+        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+        // which means it is delicate in Rust's borrowing model, circa 2021:\n+        // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n+        // Even though this block is largely safe methods, it must be almost exactly this way\n+        // to prevent invalidating the raw ptrs while they're live.\n+        // Thus, entering this block requires all values to use being already ready:\n+        // 0. idxs we want to write to, which are used to construct the mask.\n+        // 1. mask, which depends on an initial &'a [T] and the idxs.\n+        // 2. actual values to scatter (self).\n+        // 3. &mut [T] which will become our base ptr.\n+        unsafe {\n+            // Now Entering \u2622\ufe0f *mut T Zone\n+            let base_ptr = crate::vector::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            // Ferris forgive me, I have done pointer arithmetic here.\n+            let ptrs = base_ptr.wrapping_add(idxs);\n+            // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n+            crate::intrinsics::simd_scatter(self, ptrs, mask)\n+            // Cleared \u2622\ufe0f *mut T Zone\n+        }\n+    }\n+}\n+\n+impl<T, const LANES: usize> Copy for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+impl<T, const LANES: usize> Clone for Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+impl<T, const LANES: usize> Default for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + Default,\n+{\n+    #[inline]\n+    fn default() -> Self {\n+        Self::splat(T::default())\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialEq for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + PartialEq,\n+{\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        // TODO use SIMD equality\n+        self.to_array() == other.to_array()\n+    }\n+}\n+\n+impl<T, const LANES: usize> PartialOrd for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + PartialOrd,\n+{\n+    #[inline]\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        // TODO use SIMD equality\n+        self.to_array().partial_cmp(other.as_ref())\n+    }\n+}\n+\n+impl<T, const LANES: usize> Eq for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + Eq,\n+{\n+}\n+\n+impl<T, const LANES: usize> Ord for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + Ord,\n+{\n+    #[inline]\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        // TODO use SIMD equality\n+        self.to_array().cmp(other.as_ref())\n+    }\n+}\n+\n+impl<T, const LANES: usize> core::hash::Hash for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + core::hash::Hash,\n+{\n+    #[inline]\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: core::hash::Hasher,\n+    {\n+        self.as_array().hash(state)\n+    }\n+}\n+\n+// array references\n+impl<T, const LANES: usize> AsRef<[T; LANES]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T; LANES] {\n+        &self.0\n+    }\n+}\n+\n+impl<T, const LANES: usize> AsMut<[T; LANES]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T; LANES] {\n+        &mut self.0\n+    }\n+}\n+\n+// slice references\n+impl<T, const LANES: usize> AsRef<[T]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_ref(&self) -> &[T] {\n+        &self.0\n+    }\n+}\n+\n+impl<T, const LANES: usize> AsMut<[T]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    #[inline]\n+    fn as_mut(&mut self) -> &mut [T] {\n+        &mut self.0\n+    }\n+}\n+\n+// vector/array conversion\n+impl<T, const LANES: usize> From<[T; LANES]> for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    fn from(array: [T; LANES]) -> Self {\n+        Self(array)\n+    }\n+}\n+\n+impl<T, const LANES: usize> From<Simd<T, LANES>> for [T; LANES]\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    fn from(vector: Simd<T, LANES>) -> Self {\n+        vector.to_array()\n+    }\n+}\n+\n mod sealed {\n     pub trait Sealed {}\n }\n+use sealed::Sealed;\n+\n+/// Marker trait for types that may be used as SIMD vector elements.\n+/// SAFETY: This trait, when implemented, asserts the compiler can monomorphize\n+/// `#[repr(simd)]` structs with the marked type as an element.\n+/// Strictly, it is valid to impl if the vector will not be miscompiled.\n+/// Practically, it is user-unfriendly to impl it if the vector won't compile,\n+/// even when no soundness guarantees are broken by allowing the user to try.\n+pub unsafe trait SimdElement: Sealed + Copy {\n+    /// The mask element type corresponding to this element type.\n+    type Mask: MaskElement;\n+}\n \n-/// A representation of a vector as an \"array\" with indices, implementing\n-/// operations applicable to any vector type based solely on \"having lanes\",\n-/// and describing relationships between vector and scalar types.\n-pub trait Vector: sealed::Sealed {\n-    /// The scalar type in every lane of this vector type.\n-    type Scalar: Copy + Sized;\n+impl Sealed for u8 {}\n+unsafe impl SimdElement for u8 {\n+    type Mask = i8;\n+}\n \n-    /// The number of lanes for this vector.\n-    const LANES: usize;\n+impl Sealed for u16 {}\n+unsafe impl SimdElement for u16 {\n+    type Mask = i16;\n+}\n \n-    /// Generates a SIMD vector with the same value in every lane.\n-    #[must_use]\n-    fn splat(val: Self::Scalar) -> Self;\n+impl Sealed for u32 {}\n+unsafe impl SimdElement for u32 {\n+    type Mask = i32;\n+}\n+\n+impl Sealed for u64 {}\n+unsafe impl SimdElement for u64 {\n+    type Mask = i64;\n+}\n+\n+impl Sealed for usize {}\n+unsafe impl SimdElement for usize {\n+    type Mask = isize;\n+}\n+\n+impl Sealed for i8 {}\n+unsafe impl SimdElement for i8 {\n+    type Mask = i8;\n+}\n+\n+impl Sealed for i16 {}\n+unsafe impl SimdElement for i16 {\n+    type Mask = i16;\n+}\n+\n+impl Sealed for i32 {}\n+unsafe impl SimdElement for i32 {\n+    type Mask = i32;\n+}\n+\n+impl Sealed for i64 {}\n+unsafe impl SimdElement for i64 {\n+    type Mask = i64;\n+}\n+\n+impl Sealed for isize {}\n+unsafe impl SimdElement for isize {\n+    type Mask = isize;\n+}\n+\n+impl Sealed for f32 {}\n+unsafe impl SimdElement for f32 {\n+    type Mask = i32;\n+}\n+\n+impl Sealed for f64 {}\n+unsafe impl SimdElement for f64 {\n+    type Mask = i64;\n }"}, {"sha": "6ef88ddebc68a010624141c9545819a97033d784", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 31, "deletions": 47, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,32 +1,29 @@\n #![allow(non_camel_case_types)]\n \n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Mask, Simd, SupportedLaneCount};\n \n-/// Implements inherent methods for a float vector `$name` containing multiple\n+/// Implements inherent methods for a float vector containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n-/// representation. Called from `define_float_vector!`.\n+/// representation.\n macro_rules! impl_float_vector {\n-    { $name:ident, $type:ident, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl_vector! { $name, $type }\n-        impl_float_reductions! { $name, $type }\n-\n-        impl<const LANES: usize> $name<LANES>\n+    { $type:ty, $bits_ty:ty, $mask_ty:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n-            pub fn to_bits(self) -> crate::$bits_ty<LANES> {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+            pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Raw transmutation from an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n-            pub fn from_bits(bits: crate::$bits_ty<LANES>) -> Self {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+            pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&bits) }\n             }\n \n@@ -67,58 +64,58 @@ macro_rules! impl_float_vector {\n             #[inline]\n             pub fn to_degrees(self) -> Self {\n                 // to_degrees uses a special constant for better precision, so extract that constant\n-                self * Self::splat($type::to_degrees(1.))\n+                self * Self::splat(<$type>::to_degrees(1.))\n             }\n \n             /// Converts each lane from degrees to radians.\n             #[inline]\n             pub fn to_radians(self) -> Self {\n-                self * Self::splat($type::to_radians(1.))\n+                self * Self::splat(<$type>::to_radians(1.))\n             }\n \n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n-            pub fn is_sign_positive(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n                 !self.is_sign_negative()\n             }\n \n             /// Returns true for each lane if it has a negative sign, including\n             /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n             #[inline]\n-            pub fn is_sign_negative(self) -> crate::$mask_ty<LANES> {\n-                let sign_bits = self.to_bits() & crate::$bits_ty::splat((!0 >> 1) + 1);\n-                sign_bits.lanes_gt(crate::$bits_ty::splat(0))\n+            pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n+                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n+                sign_bits.lanes_gt(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is `NaN`.\n             #[inline]\n-            pub fn is_nan(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n                 self.lanes_ne(self)\n             }\n \n             /// Returns true for each lane if its value is positive infinity or negative infinity.\n             #[inline]\n-            pub fn is_infinite(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is neither infinite nor `NaN`.\n             #[inline]\n-            pub fn is_finite(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is subnormal.\n             #[inline]\n-            pub fn is_subnormal(self) -> crate::$mask_ty<LANES> {\n-                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(crate::$bits_ty::splat(0))\n+            pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n+                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is neither neither zero, infinite,\n             /// subnormal, or `NaN`.\n             #[inline]\n-            pub fn is_normal(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n                 !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n             }\n \n@@ -129,7 +126,7 @@ macro_rules! impl_float_vector {\n             /// * `NAN` if the number is `NAN`\n             #[inline]\n             pub fn signum(self) -> Self {\n-                self.is_nan().select(Self::splat($type::NAN), Self::splat(1.0).copysign(self))\n+                self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n             }\n \n             /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n@@ -186,39 +183,26 @@ macro_rules! impl_float_vector {\n     };\n }\n \n-/// A SIMD vector of containing `LANES` `f32` values.\n-#[repr(simd)]\n-pub struct SimdF32<const LANES: usize>([f32; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_float_vector! { SimdF32, f32, SimdU32, Mask32, SimdI32 }\n-\n-/// A SIMD vector of containing `LANES` `f64` values.\n-#[repr(simd)]\n-pub struct SimdF64<const LANES: usize>([f64; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_float_vector! { SimdF64, f64, SimdU64, Mask64, SimdI64 }\n+impl_float_vector! { f32, u32, i32 }\n+impl_float_vector! { f64, u64, i64 }\n \n /// Vector of two `f32` values\n-pub type f32x2 = SimdF32<2>;\n+pub type f32x2 = Simd<f32, 2>;\n \n /// Vector of four `f32` values\n-pub type f32x4 = SimdF32<4>;\n+pub type f32x4 = Simd<f32, 4>;\n \n /// Vector of eight `f32` values\n-pub type f32x8 = SimdF32<8>;\n+pub type f32x8 = Simd<f32, 8>;\n \n /// Vector of 16 `f32` values\n-pub type f32x16 = SimdF32<16>;\n+pub type f32x16 = Simd<f32, 16>;\n \n /// Vector of two `f64` values\n-pub type f64x2 = SimdF64<2>;\n+pub type f64x2 = Simd<f64, 2>;\n \n /// Vector of four `f64` values\n-pub type f64x4 = SimdF64<4>;\n+pub type f64x4 = Simd<f64, 4>;\n \n /// Vector of eight `f64` values\n-pub type f64x8 = SimdF64<8>;\n+pub type f64x8 = Simd<f64, 8>;"}, {"sha": "5f435e16b6877edc8ef35421e671ea6532ea4efd", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 30, "deletions": 90, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,49 +1,23 @@\n #![allow(non_camel_case_types)]\n \n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Mask, Simd, SupportedLaneCount};\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n-    { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl_vector! { $name, $type }\n-        impl_integer_reductions! { $name, $type }\n-\n-        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n-\n-        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n-            #[inline]\n-            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                // TODO use SIMD cmp\n-                self.as_array().cmp(other.as_ref())\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn hash<H>(&self, state: &mut H)\n-            where\n-                H: core::hash::Hasher\n-            {\n-                self.as_array().hash(state)\n-            }\n-        }\n-\n-        impl<const LANES: usize> $name<LANES>\n+    { $type:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             #[inline]\n-            pub fn is_positive(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_positive(self) -> Mask<$type, LANES> {\n                 self.lanes_gt(Self::splat(0))\n             }\n \n             /// Returns true for each negative lane and false if it is zero or positive.\n             #[inline]\n-            pub fn is_negative(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_negative(self) -> Mask<$type, LANES> {\n                 self.lanes_lt(Self::splat(0))\n             }\n \n@@ -62,102 +36,68 @@ macro_rules! impl_integer_vector {\n     }\n }\n \n-/// A SIMD vector of containing `LANES` `isize` values.\n-#[repr(simd)]\n-pub struct SimdIsize<const LANES: usize>([isize; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_integer_vector! { SimdIsize, isize, MaskSize, SimdIsize }\n-\n-/// A SIMD vector of containing `LANES` `i16` values.\n-#[repr(simd)]\n-pub struct SimdI16<const LANES: usize>([i16; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_integer_vector! { SimdI16, i16, Mask16, SimdI16 }\n-\n-/// A SIMD vector of containing `LANES` `i32` values.\n-#[repr(simd)]\n-pub struct SimdI32<const LANES: usize>([i32; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_integer_vector! { SimdI32, i32, Mask32, SimdI32 }\n-\n-/// A SIMD vector of containing `LANES` `i64` values.\n-#[repr(simd)]\n-pub struct SimdI64<const LANES: usize>([i64; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_integer_vector! { SimdI64, i64, Mask64, SimdI64 }\n-\n-/// A SIMD vector of containing `LANES` `i8` values.\n-#[repr(simd)]\n-pub struct SimdI8<const LANES: usize>([i8; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_integer_vector! { SimdI8, i8, Mask8, SimdI8 }\n+impl_integer_vector! { isize }\n+impl_integer_vector! { i16 }\n+impl_integer_vector! { i32 }\n+impl_integer_vector! { i64 }\n+impl_integer_vector! { i8 }\n \n /// Vector of two `isize` values\n-pub type isizex2 = SimdIsize<2>;\n+pub type isizex2 = Simd<isize, 2>;\n \n /// Vector of four `isize` values\n-pub type isizex4 = SimdIsize<4>;\n+pub type isizex4 = Simd<isize, 4>;\n \n /// Vector of eight `isize` values\n-pub type isizex8 = SimdIsize<8>;\n+pub type isizex8 = Simd<isize, 8>;\n \n /// Vector of two `i16` values\n-pub type i16x2 = SimdI16<2>;\n+pub type i16x2 = Simd<i16, 2>;\n \n /// Vector of four `i16` values\n-pub type i16x4 = SimdI16<4>;\n+pub type i16x4 = Simd<i16, 4>;\n \n /// Vector of eight `i16` values\n-pub type i16x8 = SimdI16<8>;\n+pub type i16x8 = Simd<i16, 8>;\n \n /// Vector of 16 `i16` values\n-pub type i16x16 = SimdI16<16>;\n+pub type i16x16 = Simd<i16, 16>;\n \n /// Vector of 32 `i16` values\n-pub type i16x32 = SimdI16<32>;\n+pub type i16x32 = Simd<i16, 32>;\n \n /// Vector of two `i32` values\n-pub type i32x2 = SimdI32<2>;\n+pub type i32x2 = Simd<i32, 2>;\n \n /// Vector of four `i32` values\n-pub type i32x4 = SimdI32<4>;\n+pub type i32x4 = Simd<i32, 4>;\n \n /// Vector of eight `i32` values\n-pub type i32x8 = SimdI32<8>;\n+pub type i32x8 = Simd<i32, 8>;\n \n /// Vector of 16 `i32` values\n-pub type i32x16 = SimdI32<16>;\n+pub type i32x16 = Simd<i32, 16>;\n \n /// Vector of two `i64` values\n-pub type i64x2 = SimdI64<2>;\n+pub type i64x2 = Simd<i64, 2>;\n \n /// Vector of four `i64` values\n-pub type i64x4 = SimdI64<4>;\n+pub type i64x4 = Simd<i64, 4>;\n \n /// Vector of eight `i64` values\n-pub type i64x8 = SimdI64<8>;\n+pub type i64x8 = Simd<i64, 8>;\n \n /// Vector of four `i8` values\n-pub type i8x4 = SimdI8<4>;\n+pub type i8x4 = Simd<i8, 4>;\n \n /// Vector of eight `i8` values\n-pub type i8x8 = SimdI8<8>;\n+pub type i8x8 = Simd<i8, 8>;\n \n /// Vector of 16 `i8` values\n-pub type i8x16 = SimdI8<16>;\n+pub type i8x16 = Simd<i8, 16>;\n \n /// Vector of 32 `i8` values\n-pub type i8x32 = SimdI8<32>;\n+pub type i8x32 = Simd<i8, 32>;\n \n /// Vector of 64 `i8` values\n-pub type i8x64 = SimdI8<64>;\n+pub type i8x64 = Simd<i8, 64>;"}, {"sha": "fc4082a4b555a1a3fd045559d3b34ccdd9283a59", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,5 +1,5 @@\n //! Private implementation details of public gather/scatter APIs.\n-use crate::{LaneCount, SimdUsize, SupportedLaneCount};\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n use core::mem;\n \n /// A vector of *const T.\n@@ -20,9 +20,9 @@ where\n \n     #[inline]\n     #[must_use]\n-    pub fn wrapping_add(self, addend: SimdUsize<LANES>) -> Self {\n+    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n-            let x: SimdUsize<LANES> = mem::transmute_copy(&self);\n+            let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n         }\n     }\n@@ -46,9 +46,9 @@ where\n \n     #[inline]\n     #[must_use]\n-    pub fn wrapping_add(self, addend: SimdUsize<LANES>) -> Self {\n+    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n-            let x: SimdUsize<LANES> = mem::transmute_copy(&self);\n+            let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n         }\n     }"}, {"sha": "b3dd199a54630bec303a9a5eee4ed07282ff3648", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 21, "deletions": 92, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,134 +1,63 @@\n #![allow(non_camel_case_types)]\n \n-use crate::{LaneCount, SupportedLaneCount};\n-\n-/// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_unsigned_vector {\n-    { $name:ident, $type:ty } => {\n-        impl_vector! { $name, $type }\n-        impl_integer_reductions! { $name, $type }\n-\n-        impl<const LANES: usize> Eq for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {}\n-\n-        impl<const LANES: usize> Ord for $name<LANES> where LaneCount<LANES>: SupportedLaneCount {\n-            #[inline]\n-            fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n-                // TODO use SIMD cmp\n-                self.as_array().cmp(other.as_ref())\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::hash::Hash for $name<LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            #[inline]\n-            fn hash<H>(&self, state: &mut H)\n-            where\n-                H: core::hash::Hasher\n-            {\n-                self.as_array().hash(state)\n-            }\n-        }\n-    }\n-}\n-\n-/// A SIMD vector of containing `LANES` `usize` values.\n-#[repr(simd)]\n-pub struct SimdUsize<const LANES: usize>([usize; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_unsigned_vector! { SimdUsize, usize }\n-\n-/// A SIMD vector of containing `LANES` `u16` values.\n-#[repr(simd)]\n-pub struct SimdU16<const LANES: usize>([u16; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_unsigned_vector! { SimdU16, u16 }\n-\n-/// A SIMD vector of containing `LANES` `u32` values.\n-#[repr(simd)]\n-pub struct SimdU32<const LANES: usize>([u32; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_unsigned_vector! { SimdU32, u32 }\n-\n-/// A SIMD vector of containing `LANES` `u64` values.\n-#[repr(simd)]\n-pub struct SimdU64<const LANES: usize>([u64; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_unsigned_vector! { SimdU64, u64 }\n-\n-/// A SIMD vector of containing `LANES` `u8` values.\n-#[repr(simd)]\n-pub struct SimdU8<const LANES: usize>([u8; LANES])\n-where\n-    LaneCount<LANES>: SupportedLaneCount;\n-\n-impl_unsigned_vector! { SimdU8, u8 }\n+use crate::Simd;\n \n /// Vector of two `usize` values\n-pub type usizex2 = SimdUsize<2>;\n+pub type usizex2 = Simd<usize, 2>;\n \n /// Vector of four `usize` values\n-pub type usizex4 = SimdUsize<4>;\n+pub type usizex4 = Simd<usize, 4>;\n \n /// Vector of eight `usize` values\n-pub type usizex8 = SimdUsize<8>;\n+pub type usizex8 = Simd<usize, 8>;\n \n /// Vector of two `u16` values\n-pub type u16x2 = SimdU16<2>;\n+pub type u16x2 = Simd<u16, 2>;\n \n /// Vector of four `u16` values\n-pub type u16x4 = SimdU16<4>;\n+pub type u16x4 = Simd<u16, 4>;\n \n /// Vector of eight `u16` values\n-pub type u16x8 = SimdU16<8>;\n+pub type u16x8 = Simd<u16, 8>;\n \n /// Vector of 16 `u16` values\n-pub type u16x16 = SimdU16<16>;\n+pub type u16x16 = Simd<u16, 16>;\n \n /// Vector of 32 `u16` values\n-pub type u16x32 = SimdU16<32>;\n+pub type u16x32 = Simd<u16, 32>;\n \n /// Vector of two `u32` values\n-pub type u32x2 = SimdU32<2>;\n+pub type u32x2 = Simd<u32, 2>;\n \n /// Vector of four `u32` values\n-pub type u32x4 = SimdU32<4>;\n+pub type u32x4 = Simd<u32, 4>;\n \n /// Vector of eight `u32` values\n-pub type u32x8 = SimdU32<8>;\n+pub type u32x8 = Simd<u32, 8>;\n \n /// Vector of 16 `u32` values\n-pub type u32x16 = SimdU32<16>;\n+pub type u32x16 = Simd<u32, 16>;\n \n /// Vector of two `u64` values\n-pub type u64x2 = SimdU64<2>;\n+pub type u64x2 = Simd<u64, 2>;\n \n /// Vector of four `u64` values\n-pub type u64x4 = SimdU64<4>;\n+pub type u64x4 = Simd<u64, 4>;\n \n /// Vector of eight `u64` values\n-pub type u64x8 = SimdU64<8>;\n+pub type u64x8 = Simd<u64, 8>;\n \n /// Vector of four `u8` values\n-pub type u8x4 = SimdU8<4>;\n+pub type u8x4 = Simd<u8, 4>;\n \n /// Vector of eight `u8` values\n-pub type u8x8 = SimdU8<8>;\n+pub type u8x8 = Simd<u8, 8>;\n \n /// Vector of 16 `u8` values\n-pub type u8x16 = SimdU8<16>;\n+pub type u8x16 = Simd<u8, 16>;\n \n /// Vector of 32 `u8` values\n-pub type u8x32 = SimdU8<32>;\n+pub type u8x32 = Simd<u8, 32>;\n \n /// Vector of 64 `u8` values\n-pub type u8x64 = SimdU8<64>;\n+pub type u8x64 = Simd<u8, 64>;"}, {"sha": "58ea244adfcb097637604c53eb72f508ffaf2729", "filename": "crates/core_simd/src/vector/vector_impl.rs", "status": "removed", "additions": 0, "deletions": 257, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/50eb35eb3b87c37876cb925c5ac3428ef6fa080a/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50eb35eb3b87c37876cb925c5ac3428ef6fa080a/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fvector_impl.rs?ref=50eb35eb3b87c37876cb925c5ac3428ef6fa080a", "patch": "@@ -1,257 +0,0 @@\n-/// Implements common traits on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n-macro_rules! impl_vector {\n-    { $name:ident, $type:ty } => {\n-        impl<const LANES: usize> crate::vector::sealed::Sealed for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {}\n-\n-        impl<const LANES: usize> crate::vector::Vector for $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            type Scalar = $type;\n-            const LANES: usize = LANES;\n-\n-            #[inline]\n-            fn splat(val: Self::Scalar) -> Self {\n-                Self::splat(val)\n-            }\n-        }\n-\n-        impl<const LANES: usize> $name<LANES>\n-        where\n-            crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-        {\n-            /// Construct a SIMD vector by setting all lanes to the given value.\n-            pub const fn splat(value: $type) -> Self {\n-                Self([value; LANES])\n-            }\n-\n-            /// Returns an array reference containing the entire SIMD vector.\n-            pub const fn as_array(&self) -> &[$type; LANES] {\n-                &self.0\n-            }\n-\n-            /// Returns a mutable array reference containing the entire SIMD vector.\n-            pub fn as_mut_array(&mut self) -> &mut [$type; LANES] {\n-                &mut self.0\n-            }\n-\n-            /// Converts an array to a SIMD vector.\n-            pub const fn from_array(array: [$type; LANES]) -> Self {\n-                Self(array)\n-            }\n-\n-            /// Converts a SIMD vector to an array.\n-            pub const fn to_array(self) -> [$type; LANES] {\n-                self.0\n-            }\n-\n-            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-            /// If an index is out of bounds, that lane instead selects the value from the \"or\" vector.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-            /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-            ///\n-            /// let result = SimdI32::<4>::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n-            /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, 15]));\n-            /// ```\n-            #[must_use]\n-            #[inline]\n-            pub fn gather_or(slice: &[$type], idxs: crate::SimdUsize<LANES>, or: Self) -> Self {\n-                Self::gather_select(slice, crate::MaskSize::splat(true), idxs, or)\n-            }\n-\n-            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds indices instead use the default value for that lane (0).\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-            ///\n-            /// let result = SimdI32::<4>::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n-            /// assert_eq!(result, SimdI32::from_array([0, 13, 10, 15]));\n-            /// ```\n-            #[must_use]\n-            #[inline]\n-            pub fn gather_or_default(slice: &[$type], idxs: crate::SimdUsize<LANES>) -> Self {\n-                Self::gather_or(slice, idxs, Self::splat(<$type>::default()))\n-            }\n-\n-            /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds or masked indices instead select the value from the \"or\" vector.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-            /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-            /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n-            ///\n-            /// let result = SimdI32::<4>::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n-            /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, -2]));\n-            /// ```\n-            #[must_use]\n-            #[inline]\n-            pub fn gather_select(\n-                slice: &[$type],\n-                mask: crate::MaskSize<LANES>,\n-                idxs: crate::SimdUsize<LANES>,\n-                or: Self,\n-            ) -> Self\n-            {\n-                let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n-                let base_ptr = crate::vector::ptr::SimdConstPtr::splat(slice.as_ptr());\n-                // Ferris forgive me, I have done pointer arithmetic here.\n-                let ptrs = base_ptr.wrapping_add(idxs);\n-                // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-                unsafe { crate::intrinsics::simd_gather(or, ptrs, mask) }\n-            }\n-\n-            /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds indices are not written.\n-            /// `scatter` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-            /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-            ///\n-            /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n-            /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n-            /// ```\n-            #[inline]\n-            pub fn scatter(self, slice: &mut [$type], idxs: crate::SimdUsize<LANES>) {\n-                self.scatter_select(slice, crate::MaskSize::splat(true), idxs)\n-            }\n-\n-            /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n-            /// Out-of-bounds or masked indices are not written.\n-            /// `scatter_select` writes \"in order\", so if an index receives two writes, only the last is guaranteed.\n-            /// ```\n-            /// # #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-            /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-            /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-            /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n-            ///\n-            /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n-            /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n-            /// ```\n-            #[inline]\n-            pub fn scatter_select(\n-                self,\n-                slice: &mut [$type],\n-                mask: crate::MaskSize<LANES>,\n-                idxs: crate::SimdUsize<LANES>,\n-            )\n-            {\n-                // We must construct our scatter mask before we derive a pointer!\n-                let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n-                // SAFETY: This block works with *mut T derived from &mut 'a [T],\n-                // which means it is delicate in Rust's borrowing model, circa 2021:\n-                // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n-                // Even though this block is largely safe methods, it must be almost exactly this way\n-                // to prevent invalidating the raw ptrs while they're live.\n-                // Thus, entering this block requires all values to use being already ready:\n-                // 0. idxs we want to write to, which are used to construct the mask.\n-                // 1. mask, which depends on an initial &'a [T] and the idxs.\n-                // 2. actual values to scatter (self).\n-                // 3. &mut [T] which will become our base ptr.\n-                unsafe {\n-                    // Now Entering \u2622\ufe0f *mut T Zone\n-                    let base_ptr = crate::vector::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n-                    // Ferris forgive me, I have done pointer arithmetic here.\n-                    let ptrs = base_ptr.wrapping_add(idxs);\n-                    // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-                    crate::intrinsics::simd_scatter(self, ptrs, mask)\n-                    // Cleared \u2622\ufe0f *mut T Zone\n-                }\n-            }\n-        }\n-\n-        impl<const LANES: usize> Copy for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {}\n-\n-        impl<const LANES: usize> Clone for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl<const LANES: usize> Default for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(<$type>::default())\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialEq for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                // TODO use SIMD equality\n-                self.to_array() == other.to_array()\n-            }\n-        }\n-\n-        impl<const LANES: usize> PartialOrd for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                // TODO use SIMD equalitya\n-                self.to_array().partial_cmp(other.as_ref())\n-            }\n-        }\n-\n-        // array references\n-        impl<const LANES: usize> AsRef<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_ref(&self) -> &[$type; LANES] {\n-                &self.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> AsMut<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_mut(&mut self) -> &mut [$type; LANES] {\n-                &mut self.0\n-            }\n-        }\n-\n-        // slice references\n-        impl<const LANES: usize> AsRef<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_ref(&self) -> &[$type] {\n-                &self.0\n-            }\n-        }\n-\n-        impl<const LANES: usize> AsMut<[$type]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            #[inline]\n-            fn as_mut(&mut self) -> &mut [$type] {\n-                &mut self.0\n-            }\n-        }\n-\n-        // vector/array conversion\n-        impl<const LANES: usize> From<[$type; LANES]> for $name<LANES> where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            fn from(array: [$type; LANES]) -> Self {\n-                Self(array)\n-            }\n-        }\n-\n-        impl <const LANES: usize> From<$name<LANES>> for [$type; LANES] where crate::LaneCount<LANES>: crate::SupportedLaneCount {\n-            fn from(vector: $name<LANES>) -> Self {\n-                vector.to_array()\n-            }\n-        }\n-\n-        impl_shuffle_2pow_lanes!{ $name }\n-    }\n-}"}, {"sha": "e39173a9c3c40506fd2dc46bcca896f0cc8038c9", "filename": "crates/core_simd/src/vendor/arm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvendor%2Farm.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -28,26 +28,26 @@ from_transmute! { unsafe u32x4 => uint32x4_t }\n from_transmute! { unsafe i32x2 => int32x2_t }\n from_transmute! { unsafe i32x4 => int32x4_t }\n \n-from_transmute! { unsafe SimdU64<1> => uint64x1_t }\n+from_transmute! { unsafe Simd<u64, 1> => uint64x1_t }\n from_transmute! { unsafe u64x2 => uint64x2_t }\n-from_transmute! { unsafe SimdI64<1> => int64x1_t }\n+from_transmute! { unsafe Simd<i64, 1> => int64x1_t }\n from_transmute! { unsafe i64x2 => int64x2_t }\n-from_transmute! { unsafe SimdU64<1> => poly64x1_t }\n+from_transmute! { unsafe Simd<u64, 1> => poly64x1_t }\n from_transmute! { unsafe u64x2 => poly64x2_t }\n \n #[cfg(target_arch = \"arm\")]\n mod arm {\n     use super::*;\n-    from_transmute! { unsafe SimdU8<4> => uint8x4_t }\n-    from_transmute! { unsafe SimdI8<4> => int8x4_t }\n+    from_transmute! { unsafe Simd<u8, 4> => uint8x4_t }\n+    from_transmute! { unsafe Simd<i8, 4> => int8x4_t }\n \n-    from_transmute! { unsafe SimdU16<2> => uint16x2_t }\n-    from_transmute! { unsafe SimdI16<2> => int16x2_t }\n+    from_transmute! { unsafe Simd<u16, 2> => uint16x2_t }\n+    from_transmute! { unsafe Simd<i16, 2> => int16x2_t }\n }\n \n #[cfg(target_arch = \"aarch64\")]\n mod aarch64 {\n     use super::*;\n-    from_transmute! { unsafe SimdF64<1> => float64x1_t }\n+    from_transmute! { unsafe Simd<f64, 1> => float64x1_t }\n     from_transmute! { unsafe f64x2 => float64x2_t }\n }"}, {"sha": "0090c37564813952c33f38957a6e026136d11436", "filename": "crates/core_simd/src/vendor/x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvendor%2Fx86.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -45,10 +45,10 @@ mod p32 {\n     use super::*;\n     from_transmute! { unsafe usizex4 => __m128i }\n     from_transmute! { unsafe usizex8 => __m256i }\n-    from_transmute! { unsafe SimdUsize<16> => __m512i }\n+    from_transmute! { unsafe Simd<usize, 16> => __m512i }\n     from_transmute! { unsafe isizex4 => __m128i }\n     from_transmute! { unsafe isizex8 => __m256i }\n-    from_transmute! { unsafe SimdIsize<16> => __m512i }\n+    from_transmute! { unsafe Simd<isize, 16> => __m512i }\n }\n \n #[cfg(target_pointer_width = \"64\")]"}, {"sha": "414a832b1be4128d4d3d162ea9982c9601791703", "filename": "crates/core_simd/tests/f32_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff32_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_float_tests! { SimdF32, f32, i32 }\n+impl_float_tests! { f32, i32 }"}, {"sha": "e0a1fa33f33270c1204f00bbade90d3f1fb22a63", "filename": "crates/core_simd/tests/f64_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Ff64_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_float_tests! { SimdF64, f64, i64 }\n+impl_float_tests! { f64, i64 }"}, {"sha": "f6c5d74fbbcc62ffcd2f044b33b9ed594e31abbd", "filename": "crates/core_simd/tests/i16_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi16_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_signed_tests! { SimdI16, i16 }\n+impl_signed_tests! { i16 }"}, {"sha": "69a831c52a3faacdaf57305058cac5e4bf287e2f", "filename": "crates/core_simd/tests/i32_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi32_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_signed_tests! { SimdI32, i32 }\n+impl_signed_tests! { i32 }"}, {"sha": "37ac08117424c5515c85d70032c3d773a966da46", "filename": "crates/core_simd/tests/i64_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi64_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_signed_tests! { SimdI64, i64 }\n+impl_signed_tests! { i64 }"}, {"sha": "11e4a5cd6a9a75e42798902ac65bbdfa04448265", "filename": "crates/core_simd/tests/i8_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi8_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fi8_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fi8_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_signed_tests! { SimdI8, i8 }\n+impl_signed_tests! { i8 }"}, {"sha": "5cc9de2b7ff8297c883c8cab5f2f78cfa5021ad5", "filename": "crates/core_simd/tests/isize_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fisize_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fisize_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fisize_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_signed_tests! { SimdIsize, isize }\n+impl_signed_tests! { isize }"}, {"sha": "cf8039d153d565ce7bb0323b9e8f720f7bebad1f", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -7,17 +7,17 @@ use wasm_bindgen_test::*;\n wasm_bindgen_test_configure!(run_in_browser);\n \n macro_rules! test_mask_api {\n-    { $name:ident } => {\n+    { $type:ident } => {\n         #[allow(non_snake_case)]\n-        mod $name {\n+        mod $type {\n             #[cfg(target_arch = \"wasm32\")]\n             use wasm_bindgen_test::*;\n \n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn set_and_test() {\n                 let values = [true, false, false, true, false, false, true, false];\n-                let mut mask = core_simd::$name::<8>::splat(false);\n+                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n                 for (lane, value) in values.iter().copied().enumerate() {\n                     mask.set(lane, value);\n                 }\n@@ -29,43 +29,43 @@ macro_rules! test_mask_api {\n             #[test]\n             #[should_panic]\n             fn set_invalid_lane() {\n-                let mut mask = core_simd::$name::<8>::splat(false);\n+                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n                 mask.set(8, true);\n                 let _ = mask;\n             }\n \n             #[test]\n             #[should_panic]\n             fn test_invalid_lane() {\n-                let mask = core_simd::$name::<8>::splat(false);\n+                let mask = core_simd::Mask::<$type, 8>::splat(false);\n                 let _ = mask.test(8);\n             }\n \n             #[test]\n             fn any() {\n-                assert!(!core_simd::$name::<8>::splat(false).any());\n-                assert!(core_simd::$name::<8>::splat(true).any());\n-                let mut v = core_simd::$name::<8>::splat(false);\n+                assert!(!core_simd::Mask::<$type, 8>::splat(false).any());\n+                assert!(core_simd::Mask::<$type, 8>::splat(true).any());\n+                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n                 v.set(2, true);\n                 assert!(v.any());\n             }\n \n             #[test]\n             fn all() {\n-                assert!(!core_simd::$name::<8>::splat(false).all());\n-                assert!(core_simd::$name::<8>::splat(true).all());\n-                let mut v = core_simd::$name::<8>::splat(false);\n+                assert!(!core_simd::Mask::<$type, 8>::splat(false).all());\n+                assert!(core_simd::Mask::<$type, 8>::splat(true).all());\n+                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n                 v.set(2, true);\n                 assert!(!v.all());\n             }\n \n             #[test]\n             fn roundtrip_int_conversion() {\n                 let values = [true, false, false, true, false, false, true, false];\n-                let mask = core_simd::$name::<8>::from_array(values);\n+                let mask = core_simd::Mask::<$type, 8>::from_array(values);\n                 let int = mask.to_int();\n                 assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n-                assert_eq!(core_simd::$name::<8>::from_int(int), mask);\n+                assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n             }\n \n             #[test]\n@@ -74,24 +74,24 @@ macro_rules! test_mask_api {\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n-                let mask = core_simd::$name::<16>::from_array(values);\n+                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, [0b01001001, 0b10000011]);\n-                assert_eq!(core_simd::$name::<16>::from_bitmask(bitmask), mask);\n+                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n         }\n     }\n }\n \n mod mask_api {\n-    test_mask_api! { Mask8 }\n+    test_mask_api! { i8 }\n }\n \n #[test]\n fn convert() {\n     let values = [true, false, false, true, false, false, true, false];\n     assert_eq!(\n-        core_simd::Mask8::from_array(values),\n-        core_simd::Mask32::from_array(values).into()\n+        core_simd::Mask::<i8, 8>::from_array(values),\n+        core_simd::Mask::<i32, 8>::from_array(values).into()\n     );\n }"}, {"sha": "0c45ea2367c935d3ffcf1507d1dc3168a0e48157", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -3,19 +3,19 @@\n /// Compares the vector operation to the equivalent scalar operation.\n #[macro_export]\n macro_rules! impl_unary_op_test {\n-    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $scalar_fn:expr } => {\n+    { $scalar:ty, $trait:ident :: $fn:ident, $scalar_fn:expr } => {\n         test_helpers::test_lanes! {\n             fn $fn<const LANES: usize>() {\n                 test_helpers::test_unary_elementwise(\n-                    &<$vector as core::ops::$trait>::$fn,\n+                    &<core_simd::Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n                     &$scalar_fn,\n                     &|_| true,\n                 );\n             }\n         }\n     };\n-    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident } => {\n-        impl_unary_op_test! { $vector, $scalar, $trait::$fn, <$scalar as core::ops::$trait>::$fn }\n+    { $scalar:ty, $trait:ident :: $fn:ident } => {\n+        impl_unary_op_test! { $scalar, $trait::$fn, <$scalar as core::ops::$trait>::$fn }\n     };\n }\n \n@@ -24,55 +24,56 @@ macro_rules! impl_unary_op_test {\n /// Compares the vector operation to the equivalent scalar operation.\n #[macro_export]\n macro_rules! impl_binary_op_test {\n-    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n         mod $fn {\n             use super::*;\n+            use core_simd::Simd;\n \n             test_helpers::test_lanes! {\n                 fn normal<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n-                        &<$vector as core::ops::$trait>::$fn,\n+                        &<Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n \n                 fn scalar_rhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<$vector as core::ops::$trait<$scalar>>::$fn,\n+                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n \n                 fn scalar_lhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<$vector>>::$fn,\n+                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n \n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n-                        &|mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n \n                 fn assign_scalar_rhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n             }\n         }\n     };\n-    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident } => {\n-        impl_binary_op_test! { $vector, $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn }\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident } => {\n+        impl_binary_op_test! { $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn }\n     };\n }\n \n@@ -84,55 +85,56 @@ macro_rules! impl_binary_op_test {\n /// Compares the vector operation to the equivalent scalar operation.\n #[macro_export]\n macro_rules! impl_binary_checked_op_test {\n-    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n         mod $fn {\n             use super::*;\n+            use core_simd::Simd;\n \n             test_helpers::test_lanes! {\n                 fn normal<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n-                        &<$vector as core::ops::$trait>::$fn,\n+                        &<Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n                         &$scalar_fn,\n                         &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n                     );\n                 }\n \n                 fn scalar_rhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<$vector as core::ops::$trait<$scalar>>::$fn,\n+                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n                         &$scalar_fn,\n                         &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n                     );\n                 }\n \n                 fn scalar_lhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<$vector>>::$fn,\n+                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n                         &$scalar_fn,\n                         &|x, y| y.iter().all(|y| $check_fn(x, *y)),\n                     );\n                 }\n \n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n-                        &|mut a, b| { <$vector as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n                     )\n                 }\n \n                 fn assign_scalar_rhs<const LANES: usize>() {\n                     test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <$vector as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n+                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n                     )\n                 }\n             }\n         }\n     };\n-    { $vector:ty, $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $check_fn:expr } => {\n-        impl_binary_nonzero_rhs_op_test! { $vector, $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn, $check_fn }\n+    { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $check_fn:expr } => {\n+        impl_binary_checked_op_test! { $scalar, $trait::$fn, $trait_assign::$fn_assign, <$scalar as core::ops::$trait>::$fn, $check_fn }\n     };\n }\n \n@@ -216,9 +218,9 @@ macro_rules! impl_common_integer_tests {\n /// Implement tests for signed integers.\n #[macro_export]\n macro_rules! impl_signed_tests {\n-    { $vector:ident, $scalar:tt } => {\n+    { $scalar:tt } => {\n         mod $scalar {\n-            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_common_integer_tests! { Vector, Scalar }\n@@ -305,28 +307,28 @@ macro_rules! impl_signed_tests {\n                 }\n             }\n \n-            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+            impl_binary_op_test!(Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n \n             // Exclude Div and Rem panicking cases\n-            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n-            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+            impl_binary_checked_op_test!(Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n+            impl_binary_checked_op_test!(Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |x, y| y != 0 && !(x == Scalar::MIN && y == -1));\n \n-            impl_unary_op_test!(Vector<LANES>, Scalar, Not::not);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+            impl_unary_op_test!(Scalar, Not::not);\n+            impl_binary_op_test!(Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n         }\n     }\n }\n \n /// Implement tests for unsigned integers.\n #[macro_export]\n macro_rules! impl_unsigned_tests {\n-    { $vector:ident, $scalar:tt } => {\n+    { $scalar:tt } => {\n         mod $scalar {\n-            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_common_integer_tests! { Vector, Scalar }\n@@ -339,36 +341,36 @@ macro_rules! impl_unsigned_tests {\n                 }\n             }\n \n-            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n+            impl_binary_op_test!(Scalar, Add::add, AddAssign::add_assign, Scalar::wrapping_add);\n+            impl_binary_op_test!(Scalar, Sub::sub, SubAssign::sub_assign, Scalar::wrapping_sub);\n+            impl_binary_op_test!(Scalar, Mul::mul, MulAssign::mul_assign, Scalar::wrapping_mul);\n \n             // Exclude Div and Rem panicking cases\n-            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |_, y| y != 0);\n-            impl_binary_checked_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |_, y| y != 0);\n+            impl_binary_checked_op_test!(Scalar, Div::div, DivAssign::div_assign, Scalar::wrapping_div, |_, y| y != 0);\n+            impl_binary_checked_op_test!(Scalar, Rem::rem, RemAssign::rem_assign, Scalar::wrapping_rem, |_, y| y != 0);\n \n-            impl_unary_op_test!(Vector<LANES>, Scalar, Not::not);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n+            impl_unary_op_test!(Scalar, Not::not);\n+            impl_binary_op_test!(Scalar, BitAnd::bitand, BitAndAssign::bitand_assign);\n+            impl_binary_op_test!(Scalar, BitOr::bitor, BitOrAssign::bitor_assign);\n+            impl_binary_op_test!(Scalar, BitXor::bitxor, BitXorAssign::bitxor_assign);\n         }\n     }\n }\n \n /// Implement tests for floating point numbers.\n #[macro_export]\n macro_rules! impl_float_tests {\n-    { $vector:ident, $scalar:tt, $int_scalar:tt } => {\n+    { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n-            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n-            impl_unary_op_test!(Vector<LANES>, Scalar, Neg::neg);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Add::add, AddAssign::add_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Sub::sub, SubAssign::sub_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Mul::mul, MulAssign::mul_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Div::div, DivAssign::div_assign);\n-            impl_binary_op_test!(Vector<LANES>, Scalar, Rem::rem, RemAssign::rem_assign);\n+            impl_unary_op_test!(Scalar, Neg::neg);\n+            impl_binary_op_test!(Scalar, Add::add, AddAssign::add_assign);\n+            impl_binary_op_test!(Scalar, Sub::sub, SubAssign::sub_assign);\n+            impl_binary_op_test!(Scalar, Mul::mul, MulAssign::mul_assign);\n+            impl_binary_op_test!(Scalar, Div::div, DivAssign::div_assign);\n+            impl_binary_op_test!(Scalar, Rem::rem, RemAssign::rem_assign);\n \n             test_helpers::test_lanes! {\n                 fn is_sign_positive<const LANES: usize>() {"}, {"sha": "ea52e8f5ca7348dff1baa1054432f92279a30b34", "filename": "crates/core_simd/tests/permute.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fpermute.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,6 +1,6 @@\n #![feature(portable_simd)]\n \n-use core_simd::SimdU32;\n+use core_simd::Simd;\n \n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;\n@@ -11,23 +11,23 @@ wasm_bindgen_test_configure!(run_in_browser);\n #[test]\n #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n fn simple_shuffle() {\n-    let a = SimdU32::from_array([2, 4, 1, 9]);\n+    let a = Simd::from_array([2, 4, 1, 9]);\n     let b = a;\n     assert_eq!(a.shuffle::<{ [3, 1, 4, 6] }>(b).to_array(), [9, 4, 2, 1]);\n }\n \n #[test]\n #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n fn reverse() {\n-    let a = SimdU32::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n     assert_eq!(a.reverse().to_array(), [7, 6, 5, 4, 3, 2, 1, 0]);\n }\n \n #[test]\n #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n fn interleave() {\n-    let a = SimdU32::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n-    let b = SimdU32::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n+    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let b = Simd::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n     let (lo, hi) = a.interleave(b);\n     assert_eq!(lo.to_array(), [0, 8, 1, 9, 2, 10, 3, 11]);\n     assert_eq!(hi.to_array(), [4, 12, 5, 13, 6, 14, 7, 15]);"}, {"sha": "11d617a6c2c56a639a066025de2c0488ec1fa7c9", "filename": "crates/core_simd/tests/round.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fround.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -1,9 +1,9 @@\n #![feature(portable_simd)]\n \n macro_rules! float_rounding_test {\n-    { $vector:ident, $scalar:tt, $int_scalar:tt } => {\n+    { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n-            type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n+            type Vector<const LANES: usize> = core_simd::Simd<$scalar, LANES>;\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;\n \n@@ -88,5 +88,5 @@ macro_rules! float_rounding_test {\n     }\n }\n \n-float_rounding_test! { SimdF32, f32, i32 }\n-float_rounding_test! { SimdF64, f64, i64 }\n+float_rounding_test! { f32, i32 }\n+float_rounding_test! { f64, i64 }"}, {"sha": "c66c9d5bd36f59510e1905cbe12b85cdce9201e0", "filename": "crates/core_simd/tests/to_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,13 +2,13 @@\n #![allow(incomplete_features)]\n #![cfg(feature = \"const_evaluatable_checked\")]\n \n-use core_simd::SimdU32;\n+use core_simd::Simd;\n \n #[test]\n fn byte_convert() {\n-    let int = SimdU32::from_array([0xdeadbeef, 0x8badf00d]);\n+    let int = Simd::<u32, 2>::from_array([0xdeadbeef, 0x8badf00d]);\n     let bytes = int.to_ne_bytes();\n     assert_eq!(int[0].to_ne_bytes(), bytes[..4]);\n     assert_eq!(int[1].to_ne_bytes(), bytes[4..]);\n-    assert_eq!(SimdU32::from_ne_bytes(bytes), int);\n+    assert_eq!(Simd::<u32, 2>::from_ne_bytes(bytes), int);\n }"}, {"sha": "9ae3bd6a47d00f511375d791bbc878c4e9b8d350", "filename": "crates/core_simd/tests/u16_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu16_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu16_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu16_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_unsigned_tests! { SimdU16, u16 }\n+impl_unsigned_tests! { u16 }"}, {"sha": "de34b73d652621e31881e928a2705342af3cdc3d", "filename": "crates/core_simd/tests/u32_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu32_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu32_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu32_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_unsigned_tests! { SimdU32, u32 }\n+impl_unsigned_tests! { u32 }"}, {"sha": "8ee5a318c83d75afe5a29d56cff28ff42d96e70f", "filename": "crates/core_simd/tests/u64_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu64_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu64_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu64_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_unsigned_tests! { SimdU64, u64 }\n+impl_unsigned_tests! { u64 }"}, {"sha": "6d7211121284bcbfcc1622df9ca0e504e0cfa2a3", "filename": "crates/core_simd/tests/u8_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu8_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fu8_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fu8_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_unsigned_tests! { SimdU8, u8 }\n+impl_unsigned_tests! { u8 }"}, {"sha": "9c7b1687a08554f757b42184c6a12e8a5da2b208", "filename": "crates/core_simd/tests/usize_ops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fusize_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42875302dd9e924f8d667b32e88989388989b79/crates%2Fcore_simd%2Ftests%2Fusize_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fusize_ops.rs?ref=d42875302dd9e924f8d667b32e88989388989b79", "patch": "@@ -2,4 +2,4 @@\n \n #[macro_use]\n mod ops_macros;\n-impl_unsigned_tests! { SimdUsize, usize }\n+impl_unsigned_tests! { usize }"}]}