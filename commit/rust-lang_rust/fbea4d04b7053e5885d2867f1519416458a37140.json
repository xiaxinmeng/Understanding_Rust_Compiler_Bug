{"sha": "fbea4d04b7053e5885d2867f1519416458a37140", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZWE0ZDA0YjcwNTNlNTg4NWQyODY3ZjE1MTk0MTY0NThhMzcxNDA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-28T17:30:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-28T17:30:34Z"}, "message": "More rustc expr-parsing logic.", "tree": {"sha": "3f649b21df47ba83f24651494b3389ca52ec5d46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f649b21df47ba83f24651494b3389ca52ec5d46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbea4d04b7053e5885d2867f1519416458a37140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbea4d04b7053e5885d2867f1519416458a37140", "html_url": "https://github.com/rust-lang/rust/commit/fbea4d04b7053e5885d2867f1519416458a37140", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbea4d04b7053e5885d2867f1519416458a37140/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b4b035c7a041badcc656e3c403417f16d9a05f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4b035c7a041badcc656e3c403417f16d9a05f8", "html_url": "https://github.com/rust-lang/rust/commit/5b4b035c7a041badcc656e3c403417f16d9a05f8"}], "stats": {"total": 260, "additions": 238, "deletions": 22}, "files": [{"sha": "c74e16202ac5567f5a7bb4031bc18f2ced43d17f", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fbea4d04b7053e5885d2867f1519416458a37140/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbea4d04b7053e5885d2867f1519416458a37140/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=fbea4d04b7053e5885d2867f1519416458a37140", "patch": "@@ -10,12 +10,14 @@ type crate = rec(_mod module);\n type block = vec[@stmt];\n \n tag binop {\n-    plus;\n-    minus;\n-    star;\n-    slash;\n-    percent;\n-    caret;\n+    add;\n+    sub;\n+    mul;\n+    div;\n+    rem;\n+    and;\n+    or;\n+    bitxor;\n     bitand;\n     bitor;\n     lsl;\n@@ -30,11 +32,11 @@ tag binop {\n }\n \n tag unop {\n+    box;\n+    deref;\n     bitnot;\n     not;\n     neg;\n-    deref;\n-    cast(@ty);\n }\n \n tag stmt {\n@@ -49,22 +51,18 @@ tag decl {\n     decl_item(ident, @item);\n }\n \n-tag lval {\n-    lval_ident(ident);\n-    lval_ext(@lval, ident);\n-    lval_idx(@lval, @expr);\n-}\n-\n tag expr {\n-    expr_box(@expr);\n     expr_vec(vec[@expr]);\n     expr_tup(vec[@expr]);\n     expr_rec(vec[tup(ident,@expr)]);\n     expr_call(@expr, vec[@expr]);\n     expr_binary(binop, @expr, @expr);\n     expr_unary(unop, @expr);\n     expr_lit(@lit);\n-    expr_lval(@lval);\n+    expr_ident(ident);\n+    expr_field(@expr, ident);\n+    expr_index(@expr, @expr);\n+    expr_cast(@expr, ty);\n }\n \n tag lit {"}, {"sha": "ea9839685441ea01a38669b5ed80783b5867bb5f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 224, "deletions": 6, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/fbea4d04b7053e5885d2867f1519416458a37140/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbea4d04b7053e5885d2867f1519416458a37140/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=fbea4d04b7053e5885d2867f1519416458a37140", "patch": "@@ -166,34 +166,252 @@ state fn parse_bottom_expr(parser p) -> @ast.expr {\n             ret e;\n         }\n \n+        case (token.TUP) {\n+            p.bump();\n+            auto pf = parse_expr;\n+            auto es = parse_seq[@ast.expr](token.LPAREN,\n+                                           token.RPAREN,\n+                                           some(token.COMMA),\n+                                           pf, p);\n+            ret @ast.expr_tup(es);\n+        }\n+\n+        case (token.VEC) {\n+            p.bump();\n+            auto pf = parse_expr;\n+            auto es = parse_seq[@ast.expr](token.LPAREN,\n+                                           token.RPAREN,\n+                                           some(token.COMMA),\n+                                           pf, p);\n+            ret @ast.expr_vec(es);\n+        }\n+\n+        case (token.REC) {\n+            p.bump();\n+            state fn parse_entry(parser p) ->\n+                tup(ast.ident, @ast.expr) {\n+                auto i = parse_ident(p);\n+                expect(p, token.EQ);\n+                auto e = parse_expr(p);\n+                ret tup(i, e);\n+            }\n+            auto pf = parse_entry;\n+            auto es =\n+                parse_seq[tup(ast.ident, @ast.expr)](token.LPAREN,\n+                                                     token.RPAREN,\n+                                                     some(token.COMMA),\n+                                                     pf, p);\n+            ret @ast.expr_rec(es);\n+        }\n+\n+        case (token.IDENT(?i)) {\n+            p.bump();\n+            ret @ast.expr_ident(i);\n+        }\n+\n         case (_) {\n             ret @ast.expr_lit(parse_lit(p));\n         }\n     }\n }\n \n+state fn parse_path_expr(parser p) -> @ast.expr {\n+    auto e = parse_bottom_expr(p);\n+    while (true) {\n+        alt (p.peek()) {\n+            case (token.DOT) {\n+                p.bump();\n+                alt (p.peek()) {\n+\n+                    case (token.IDENT(?i)) {\n+                        p.bump();\n+                        e = @ast.expr_field(e, i);\n+                    }\n+\n+                    case (token.LPAREN) {\n+                        auto ix = parse_bottom_expr(p);\n+                        e = @ast.expr_index(e, ix);\n+                    }\n+                }\n+            }\n+            case (_) {\n+                ret e;\n+            }\n+        }\n+    }\n+    ret e;\n+}\n \n-state fn parse_negation_expr(parser p) -> @ast.expr {\n+state fn parse_prefix_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n \n         case (token.NOT) {\n-            auto e = parse_negation_expr(p);\n+            auto e = parse_prefix_expr(p);\n             ret @ast.expr_unary(ast.not, e);\n         }\n \n         case (token.TILDE) {\n-            auto e = parse_negation_expr(p);\n+            auto e = parse_prefix_expr(p);\n             ret @ast.expr_unary(ast.bitnot, e);\n         }\n \n+        case (token.BINOP(?b)) {\n+            alt (b) {\n+\n+                case (token.MINUS) {\n+                    auto e = parse_prefix_expr(p);\n+                    ret @ast.expr_unary(ast.neg, e);\n+                }\n+\n+                case (token.STAR) {\n+                    auto e = parse_prefix_expr(p);\n+                    ret @ast.expr_unary(ast.deref, e);\n+                }\n+\n+                case (_) {\n+                    ret parse_path_expr(p);\n+                }\n+            }\n+        }\n+\n+        case (token.AT) {\n+            p.bump();\n+            auto e = parse_prefix_expr(p);\n+            ret @ast.expr_unary(ast.box, e);\n+        }\n+\n         case (_) {\n-            ret parse_bottom_expr(p);\n+            ret parse_path_expr(p);\n+        }\n+    }\n+}\n+\n+state fn parse_binops(parser p,\n+                      (state fn(parser) -> @ast.expr) sub,\n+                      vec[tup(token.binop, ast.binop)] ops)\n+    -> @ast.expr {\n+    auto e = sub(p);\n+    auto more = true;\n+    while (more) {\n+        more = false;\n+        auto t = p.peek();\n+        alt (t) {\n+            case (token.BINOP(?op)) {\n+                for (tup(token.binop, ast.binop) pair in ops) {\n+                    if (pair._0 == op) {\n+                        e = @ast.expr_binary(pair._1, e, sub(p));\n+                        more = true;\n+                        t = p.peek();\n+                    }\n+                }\n+            }\n+            case (_) {\n+            }\n+        }\n+    }\n+    ret e;\n+}\n+\n+state fn parse_binary_exprs(parser p,\n+                            (state fn(parser) -> @ast.expr) sub,\n+                            vec[tup(token.token, ast.binop)] ops)\n+    -> @ast.expr {\n+    auto e = sub(p);\n+    auto more = true;\n+    while (more) {\n+        more = false;\n+        auto t = p.peek();\n+        for (tup(token.token, ast.binop) pair in ops) {\n+            if (pair._0 == t) {\n+                e = @ast.expr_binary(pair._1, e, sub(p));\n+                more = true;\n+                t = p.peek();\n+            }\n         }\n     }\n+    ret e;\n+}\n+\n+state fn parse_factor_expr(parser p) -> @ast.expr {\n+    auto sub = parse_prefix_expr;\n+    ret parse_binops(p, sub, vec(tup(token.STAR, ast.mul),\n+                                 tup(token.SLASH, ast.div),\n+                                 tup(token.PERCENT, ast.rem)));\n+}\n+\n+state fn parse_term_expr(parser p) -> @ast.expr {\n+    auto sub = parse_factor_expr;\n+    ret parse_binops(p, sub, vec(tup(token.PLUS, ast.add),\n+                                 tup(token.MINUS, ast.sub)));\n+}\n+\n+state fn parse_shift_expr(parser p) -> @ast.expr {\n+    auto sub = parse_term_expr;\n+    ret parse_binops(p, sub, vec(tup(token.LSL, ast.lsl),\n+                                 tup(token.LSR, ast.lsr),\n+                                 tup(token.ASR, ast.asr)));\n+}\n+\n+state fn parse_bitand_expr(parser p) -> @ast.expr {\n+    auto sub = parse_shift_expr;\n+    ret parse_binops(p, sub, vec(tup(token.AND, ast.bitand)));\n+}\n+\n+state fn parse_bitxor_expr(parser p) -> @ast.expr {\n+    auto sub = parse_bitand_expr;\n+    ret parse_binops(p, sub, vec(tup(token.CARET, ast.bitxor)));\n+}\n+\n+state fn parse_bitor_expr(parser p) -> @ast.expr {\n+    auto sub = parse_bitxor_expr;\n+    ret parse_binops(p, sub, vec(tup(token.OR, ast.bitor)));\n+}\n+\n+state fn parse_cast_expr(parser p) -> @ast.expr {\n+    auto e = parse_bitor_expr(p);\n+    while (true) {\n+        alt (p.peek()) {\n+            case (token.AS) {\n+                p.bump();\n+                auto t = parse_ty(p);\n+                e = @ast.expr_cast(e, t);\n+            }\n+\n+            case (_) {\n+                ret e;\n+            }\n+        }\n+    }\n+    ret e;\n+}\n+\n+state fn parse_relational_expr(parser p) -> @ast.expr {\n+    auto sub = parse_cast_expr;\n+    ret parse_binary_exprs(p, sub, vec(tup(token.LT, ast.lt),\n+                                       tup(token.LE, ast.le),\n+                                       tup(token.GE, ast.ge),\n+                                       tup(token.GT, ast.gt)));\n+}\n+\n+\n+state fn parse_equality_expr(parser p) -> @ast.expr {\n+    auto sub = parse_relational_expr;\n+    ret parse_binary_exprs(p, sub, vec(tup(token.EQEQ, ast.eq),\n+                                       tup(token.NE, ast.ne)));\n+}\n+\n+state fn parse_and_expr(parser p) -> @ast.expr {\n+    auto sub = parse_equality_expr;\n+    ret parse_binary_exprs(p, sub, vec(tup(token.ANDAND, ast.and)));\n+}\n+\n+state fn parse_or_expr(parser p) -> @ast.expr {\n+    auto sub = parse_and_expr;\n+    ret parse_binary_exprs(p, sub, vec(tup(token.OROR, ast.or)));\n }\n \n state fn parse_expr(parser p) -> @ast.expr {\n-    ret parse_negation_expr(p);\n+    ret parse_or_expr(p);\n }\n \n state fn parse_stmt(parser p) -> @ast.stmt {\n@@ -221,7 +439,7 @@ state fn parse_block(parser p) -> ast.block {\n state fn parse_slot_ident_pair(parser p) ->\n     rec(ast.slot slot, ast.ident ident) {\n     auto s = parse_slot(p);\n-    auto i =  parse_ident(p);\n+    auto i = parse_ident(p);\n     ret rec(slot=s, ident=i);\n }\n "}]}