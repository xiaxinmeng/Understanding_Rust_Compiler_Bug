{"sha": "75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MDE0ZjdiMTc5MGU3ZWJkZjEzZDM4YWNjMDRkZmRhYjZlNDUwZTk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T07:01:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-07T06:00:01Z"}, "message": "libs: Fix miscellaneous fallout of librustrt", "tree": {"sha": "46fb046e002a37ba60f6e8b8ef5ee0675fbb7fd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46fb046e002a37ba60f6e8b8ef5ee0675fbb7fd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "html_url": "https://github.com/rust-lang/rust/commit/75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d743b8831e6dc5b390af112cc23159d667cf583b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d743b8831e6dc5b390af112cc23159d667cf583b", "html_url": "https://github.com/rust-lang/rust/commit/d743b8831e6dc5b390af112cc23159d667cf583b"}], "stats": {"total": 551, "additions": 263, "deletions": 288}, "files": [{"sha": "ca7ed6f4ba05bda7329cc0139c0138d92de67330", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -96,6 +96,21 @@ pub mod owned;\n pub mod arc;\n pub mod rc;\n \n+// FIXME(#14344): When linking liballoc with libstd, this library will be linked\n+//                as an rlib (it only exists as an rlib). It turns out that an\n+//                optimized standard library doesn't actually use *any* symbols\n+//                from this library. Everything is inlined and optimized away.\n+//                This means that linkers will actually omit the object for this\n+//                file, even though it may be needed in the future.\n+//\n+//                To get around this for now, we define a dummy symbol which\n+//                will never get inlined so the stdlib can call it. The stdlib's\n+//                reference to this symbol will cause this library's object file\n+//                to get linked in to libstd successfully (the linker won't\n+//                optimize it out).\n+#[doc(hidden)]\n+pub fn fixme_14344_be_sure_to_link_to_collections() {}\n+\n #[cfg(not(test))]\n #[doc(hidden)]\n mod std {"}, {"sha": "7e35af79eab1cf10f8d10699edff49ca73b378ba", "filename": "src/liballoc/util.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Fliballoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Fliballoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Futil.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -28,20 +28,3 @@ fn align_to(size: uint, align: uint) -> uint {\n     assert!(align != 0);\n     (size + align - 1) & !(align - 1)\n }\n-\n-// FIXME(#14344): When linking liballoc with libstd, this library will be linked\n-//                as an rlib (it only exists as an rlib). It turns out that an\n-//                optimized standard library doesn't actually use *any* symbols\n-//                from this library. Everything is inlined and optimized away.\n-//                This means that linkers will actually omit the object for this\n-//                file, even though it may be needed in the future.\n-//\n-//                To get around this for now, we define a dummy symbol which\n-//                will never get inlined so the stdlib can call it. The stdlib's\n-//                reference to this symbol will cause this library's object file\n-//                to get linked in to libstd successfully (the linker won't\n-//                optimize it out).\n-#[deprecated]\n-#[doc(hidden)]\n-pub fn make_stdlib_link_work() {}\n-"}, {"sha": "c46ea84a765cea9adace56d880d220a5f8c6fdb7", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -72,6 +72,10 @@ fn expect<T>(a: core::option::Option<T>, b: &str) -> T {\n     }\n }\n \n+// FIXME(#14344) this shouldn't be necessary\n+#[doc(hidden)]\n+pub fn fixme_14344_be_sure_to_link_to_collections() {}\n+\n #[cfg(not(test))]\n mod std {\n     pub use core::fmt;      // necessary for fail!()"}, {"sha": "4798218e3ff25dbc9653882f2d64c51c38799b18", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -862,7 +862,7 @@ mod tests {\n     use std::prelude::*;\n     use std::rand::{Rng, task_rng};\n     use std::rc::Rc;\n-    use std::unstable;\n+    use std::rt;\n     use slice::*;\n \n     use vec::Vec;\n@@ -1104,9 +1104,9 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = vec![unstable::sync::Exclusive::new(()),\n-                         unstable::sync::Exclusive::new(()),\n-                         unstable::sync::Exclusive::new(())];\n+        let mut v = vec![rt::exclusive::Exclusive::new(()),\n+                         rt::exclusive::Exclusive::new(()),\n+                         rt::exclusive::Exclusive::new(())];\n         let mut _e = v.swap_remove(0);\n         assert_eq!(v.len(), 2);\n         _e = v.swap_remove(1);"}, {"sha": "7f033a1bc6163a5d542767ee4cc11072c3a61102", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -20,7 +20,7 @@ use std::sync::atomics;\n use std::mem;\n use std::rt::rtio::{EventLoop, IoFactory, RemoteCallback};\n use std::rt::rtio::{PausableIdleCallback, Callback};\n-use std::unstable::sync::Exclusive;\n+use std::rt::exclusive::Exclusive;\n \n /// This is the only exported function from this module.\n pub fn event_loop() -> Box<EventLoop:Send> {\n@@ -31,7 +31,7 @@ struct BasicLoop {\n     work: Vec<proc():Send>,             // pending work\n     remotes: Vec<(uint, Box<Callback:Send>)>,\n     next_remote: uint,\n-    messages: Exclusive<Vec<Message>>,\n+    messages: Arc<Exclusive<Vec<Message>>>,\n     idle: Option<Box<Callback:Send>>,\n     idle_active: Option<Arc<atomics::AtomicBool>>,\n }\n@@ -46,7 +46,7 @@ impl BasicLoop {\n             idle_active: None,\n             next_remote: 0,\n             remotes: vec![],\n-            messages: Exclusive::new(vec![]),\n+            messages: Arc::new(Exclusive::new(Vec::new())),\n         }\n     }\n \n@@ -61,19 +61,10 @@ impl BasicLoop {\n \n     fn remote_work(&mut self) {\n         let messages = unsafe {\n-            self.messages.with(|messages| {\n-                if messages.len() > 0 {\n-                    Some(mem::replace(messages, vec![]))\n-                } else {\n-                    None\n-                }\n-            })\n-        };\n-        let messages = match messages {\n-            Some(m) => m, None => return\n+            mem::replace(&mut *self.messages.lock(), Vec::new())\n         };\n-        for message in messages.iter() {\n-            self.message(*message);\n+        for message in messages.move_iter() {\n+            self.message(message);\n         }\n     }\n \n@@ -125,13 +116,13 @@ impl EventLoop for BasicLoop {\n             }\n \n             unsafe {\n+                let mut messages = self.messages.lock();\n                 // We block here if we have no messages to process and we may\n                 // receive a message at a later date\n-                self.messages.hold_and_wait(|messages| {\n-                    self.remotes.len() > 0 &&\n-                        messages.len() == 0 &&\n-                        self.work.len() == 0\n-                })\n+                if self.remotes.len() > 0 && messages.len() == 0 &&\n+                   self.work.len() == 0 {\n+                    messages.wait()\n+                }\n             }\n         }\n     }\n@@ -165,33 +156,29 @@ impl EventLoop for BasicLoop {\n }\n \n struct BasicRemote {\n-    queue: Exclusive<Vec<Message>>,\n+    queue: Arc<Exclusive<Vec<Message>>>,\n     id: uint,\n }\n \n impl BasicRemote {\n-    fn new(queue: Exclusive<Vec<Message>>, id: uint) -> BasicRemote {\n+    fn new(queue: Arc<Exclusive<Vec<Message>>>, id: uint) -> BasicRemote {\n         BasicRemote { queue: queue, id: id }\n     }\n }\n \n impl RemoteCallback for BasicRemote {\n     fn fire(&mut self) {\n-        unsafe {\n-            self.queue.hold_and_signal(|queue| {\n-                queue.push(RunRemote(self.id));\n-            })\n-        }\n+        let mut queue = unsafe { self.queue.lock() };\n+        queue.push(RunRemote(self.id));\n+        queue.signal();\n     }\n }\n \n impl Drop for BasicRemote {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.queue.hold_and_signal(|queue| {\n-                queue.push(RemoveRemote(self.id));\n-            })\n-        }\n+        let mut queue = unsafe { self.queue.lock() };\n+        queue.push(RemoveRemote(self.id));\n+        queue.signal();\n     }\n }\n \n@@ -216,7 +203,7 @@ impl Drop for BasicPausable {\n \n #[cfg(test)]\n mod test {\n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n \n     use basic;\n     use PoolConfig;"}, {"sha": "333ac80907f6a9012a2ea6e5040674e0fddc4983", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -160,7 +160,7 @@\n //! # Using a scheduler pool\n //!\n //! ```rust\n-//! use std::task::TaskOpts;\n+//! use std::rt::task::TaskOpts;\n //! use green::{SchedPool, PoolConfig};\n //! use green::sched::{PinnedTask, TaskFromFriend};\n //!\n@@ -221,10 +221,10 @@ use std::mem::replace;\n use std::os;\n use std::rt::rtio;\n use std::rt::thread::Thread;\n+use std::rt::task::TaskOpts;\n use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n-use std::task::TaskOpts;\n \n use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n use sleeper_list::SleeperList;\n@@ -319,7 +319,7 @@ pub fn run(event_loop_factory: fn() -> Box<rtio::EventLoop:Send>,\n     let mut pool = SchedPool::new(cfg);\n     let (tx, rx) = channel();\n     let mut opts = TaskOpts::new();\n-    opts.notify_chan = Some(tx);\n+    opts.on_exit = Some(proc(r) tx.send(r));\n     opts.name = Some(\"<main>\".into_maybe_owned());\n     pool.spawn(opts, main);\n "}, {"sha": "f55dc92eac610c5d58240a93bf8f0b9c43defdd1", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -10,11 +10,11 @@\n \n use std::mem;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio::{RemoteCallback, PausableIdleCallback, Callback, EventLoop};\n use std::rt::task::BlockedTask;\n use std::rt::task::Task;\n use std::sync::deque;\n-use std::unstable::mutex::NativeMutex;\n use std::raw;\n \n use std::rand::{XorShiftRng, Rng, Rand};\n@@ -1022,7 +1022,7 @@ fn new_sched_rng() -> XorShiftRng {\n mod test {\n     use rustuv;\n \n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n     use std::rt::task::Task;\n     use std::rt::local::Local;\n \n@@ -1475,7 +1475,7 @@ mod test {\n \n     #[test]\n     fn test_spawn_sched_blocking() {\n-        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n         // Testing that a task in one scheduler can block in foreign code"}, {"sha": "7b738ed9c7c158d3ac10f0b107e55ef5f2671adb", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -15,10 +15,9 @@ use std::any::Any;\n use std::mem;\n use std::rt::Runtime;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio;\n-use std::rt::task::{Task, BlockedTask};\n-use std::task::TaskOpts;\n-use std::unstable::mutex::NativeMutex;\n+use std::rt::task::{Task, BlockedTask, TaskOpts};\n \n struct SimpleTask {\n     lock: NativeMutex,"}, {"sha": "2e385f75e1d3e21c47943bb7b15a0299f76e3f84", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rt::env::max_cached_stacks;\n+use std::sync::atomics;\n use std::os::{errno, page_size, MemoryMap, MapReadable, MapWritable,\n-              MapNonStandardFlags, MapVirtual};\n+              MapNonStandardFlags, MapVirtual, getenv};\n use libc;\n \n /// A task's stack. The name \"Stack\" is a vestige of segmented stacks.\n@@ -151,6 +151,22 @@ impl StackPool {\n     }\n }\n \n+fn max_cached_stacks() -> uint {\n+    static mut AMT: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n+    match unsafe { AMT.load(atomics::SeqCst) } {\n+        0 => {}\n+        n => return n - 1,\n+    }\n+    let amt = getenv(\"RUST_MAX_CACHED_STACKS\").and_then(|s| from_str(s.as_slice()));\n+    // This default corresponds to 20M of cache per scheduler (at the\n+    // default size).\n+    let amt = amt.unwrap_or(10);\n+    // 0 is our sentinel value, so ensure that we'll never see 0 after\n+    // initialization has run\n+    unsafe { AMT.store(amt + 1, atomics::SeqCst); }\n+    return amt;\n+}\n+\n extern {\n     fn rust_valgrind_stack_register(start: *libc::uintptr_t,\n                                     end: *libc::uintptr_t) -> libc::c_uint;"}, {"sha": "91ebad3b3f8ab0418e2cd578c037f13da2f6c77d", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -22,13 +22,12 @@ use std::any::Any;\n use std::mem;\n use std::raw;\n use std::rt::Runtime;\n-use std::rt::env;\n use std::rt::local::Local;\n+use std::rt::mutex::NativeMutex;\n use std::rt::rtio;\n use std::rt::stack;\n-use std::rt::task::{Task, BlockedTask, SendMessage};\n-use std::task::TaskOpts;\n-use std::unstable::mutex::NativeMutex;\n+use std::rt::task::{Task, BlockedTask, TaskOpts};\n+use std::rt;\n \n use context::Context;\n use coroutine::Coroutine;\n@@ -142,7 +141,7 @@ impl GreenTask {\n         let mut ops = GreenTask::new_typed(None, TypeGreen(Some(home)));\n \n         // Allocate a stack for us to run on\n-        let stack_size = stack_size.unwrap_or_else(|| env::min_stack());\n+        let stack_size = stack_size.unwrap_or_else(|| rt::min_stack());\n         let mut stack = stack_pool.take_stack(stack_size);\n         let context = Context::new(bootstrap_green_task, ops.as_uint(), start,\n                                    &mut stack);\n@@ -176,23 +175,13 @@ impl GreenTask {\n     pub fn configure(pool: &mut StackPool,\n                      opts: TaskOpts,\n                      f: proc():Send) -> Box<GreenTask> {\n-        let TaskOpts {\n-            notify_chan, name, stack_size,\n-            stderr, stdout,\n-        } = opts;\n+        let TaskOpts { name, stack_size, on_exit } = opts;\n \n         let mut green = GreenTask::new(pool, stack_size, f);\n         {\n             let task = green.task.get_mut_ref();\n             task.name = name;\n-            task.stderr = stderr;\n-            task.stdout = stdout;\n-            match notify_chan {\n-                Some(chan) => {\n-                    task.death.on_exit = Some(SendMessage(chan));\n-                }\n-                None => {}\n-            }\n+            task.death.on_exit = on_exit;\n         }\n         return green;\n     }\n@@ -490,7 +479,7 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::Task;\n     use std::task;\n-    use std::task::TaskOpts;\n+    use std::rt::task::TaskOpts;\n \n     use super::super::{PoolConfig, SchedPool};\n     use super::GreenTask;\n@@ -529,7 +518,7 @@ mod tests {\n         opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() {});\n         assert!(rx.recv().is_ok());\n     }\n@@ -538,7 +527,7 @@ mod tests {\n     fn smoke_opts_fail() {\n         let mut opts = TaskOpts::new();\n         let (tx, rx) = channel();\n-        opts.notify_chan = Some(tx);\n+        opts.on_exit = Some(proc(r) tx.send(r));\n         spawn_opts(opts, proc() { fail!() });\n         assert!(rx.recv().is_err());\n     }"}, {"sha": "b833b2a65158d90b26db3ad51b7beb9b411b7d07", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -172,6 +172,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(unix)] pub use consts::os::posix88::{ENOTCONN, ECONNABORTED, EADDRNOTAVAIL, EINTR};\n #[cfg(unix)] pub use consts::os::posix88::{EADDRINUSE, ENOENT, EISDIR, EAGAIN, EWOULDBLOCK};\n #[cfg(unix)] pub use consts::os::posix88::{ECANCELED, SIGINT, EINPROGRESS};\n+#[cfg(unix)] pub use consts::os::posix88::{ENOSYS, ENOTTY, ETIMEDOUT};\n #[cfg(unix)] pub use consts::os::posix88::{SIGTERM, SIGKILL, SIGPIPE, PROT_NONE};\n #[cfg(unix)] pub use consts::os::posix01::{SIG_IGN};\n #[cfg(unix)] pub use consts::os::bsd44::{AF_UNIX};\n@@ -195,7 +196,7 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::c95::{WSAECONNREFUSED, WSAECONNRESET, WSAEACCES};\n #[cfg(windows)] pub use consts::os::c95::{WSAEWOULDBLOCK, WSAENOTCONN, WSAECONNABORTED};\n #[cfg(windows)] pub use consts::os::c95::{WSAEADDRNOTAVAIL, WSAEADDRINUSE, WSAEINTR};\n-#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS};\n+#[cfg(windows)] pub use consts::os::c95::{WSAEINPROGRESS, WSAEINVAL};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_INSUFFICIENT_BUFFER};\n #[cfg(windows)] pub use consts::os::extra::{O_BINARY, O_NOINHERIT, PAGE_NOACCESS};\n #[cfg(windows)] pub use consts::os::extra::{PAGE_READONLY, PAGE_READWRITE, PAGE_EXECUTE};\n@@ -205,6 +206,9 @@ pub use funcs::bsd43::{shutdown};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_ALREADY_EXISTS, ERROR_NO_DATA};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_FILE_NOT_FOUND, ERROR_INVALID_NAME};\n #[cfg(windows)] pub use consts::os::extra::{ERROR_BROKEN_PIPE, ERROR_INVALID_FUNCTION};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_CALL_NOT_IMPLEMENTED};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_NOTHING_TO_TERMINATE};\n+#[cfg(windows)] pub use consts::os::extra::{ERROR_INVALID_HANDLE};\n #[cfg(windows)] pub use consts::os::extra::{TRUE, FALSE, INFINITE};\n #[cfg(windows)] pub use consts::os::extra::{PROCESS_TERMINATE, PROCESS_QUERY_INFORMATION};\n #[cfg(windows)] pub use consts::os::extra::{STILL_ACTIVE, DETACHED_PROCESS};\n@@ -1758,6 +1762,7 @@ pub mod consts {\n             pub static ERROR_NO_DATA: c_int = 232;\n             pub static ERROR_INVALID_ADDRESS : c_int = 487;\n             pub static ERROR_PIPE_CONNECTED: c_int = 535;\n+            pub static ERROR_NOTHING_TO_TERMINATE: c_int = 758;\n             pub static ERROR_OPERATION_ABORTED: c_int = 995;\n             pub static ERROR_IO_PENDING: c_int = 997;\n             pub static ERROR_FILE_INVALID : c_int = 1006;"}, {"sha": "255c3f4bd213dd8c510791c6f6adad4dc627bd66", "filename": "src/libnative/io/addrinfo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Faddrinfo.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -92,8 +92,6 @@ extern \"system\" {\n     fn freeaddrinfo(res: *mut libc::addrinfo);\n     #[cfg(not(windows))]\n     fn gai_strerror(errcode: c_int) -> *c_char;\n-    #[cfg(windows)]\n-    fn WSAGetLastError() -> c_int;\n }\n \n #[cfg(windows)]"}, {"sha": "2a5b78e55067cb75e5ef369981b210157f6f2309", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 66, "deletions": 92, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -14,17 +14,14 @@ use alloc::arc::Arc;\n use libc::{c_int, c_void};\n use libc;\n use std::c_str::CString;\n-use std::io::IoError;\n-use std::io;\n use std::mem;\n use std::os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::IoResult;\n use std::str;\n use std::vec;\n \n-use io::IoResult;\n-\n pub type fd_t = libc::c_int;\n \n struct Inner {\n@@ -52,7 +49,7 @@ impl FileDesc {\n         }) }\n     }\n \n-    pub fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    pub fn inner_read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut read = 0;\n         let ret = unsafe {\n             libc::ReadFile(self.handle(), buf.as_ptr() as libc::LPVOID,\n@@ -65,7 +62,7 @@ impl FileDesc {\n             Err(super::last_error())\n         }\n     }\n-    pub fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    pub fn inner_write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n         while remaining > 0 {\n@@ -93,11 +90,11 @@ impl FileDesc {\n \n     // A version of seek that takes &self so that tell can call it\n     //   - the private seek should of course take &mut self.\n-    fn seek_common(&self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek_common(&self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n         let whence = match style {\n-            io::SeekSet => libc::FILE_BEGIN,\n-            io::SeekEnd => libc::FILE_END,\n-            io::SeekCur => libc::FILE_CURRENT,\n+            rtio::SeekSet => libc::FILE_BEGIN,\n+            rtio::SeekEnd => libc::FILE_END,\n+            rtio::SeekCur => libc::FILE_CURRENT,\n         };\n         unsafe {\n             let mut newpos = 0;\n@@ -111,27 +108,15 @@ impl FileDesc {\n \n }\n \n-impl io::Reader for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n-        self.inner_read(buf)\n-    }\n-}\n-\n-impl io::Writer for FileDesc {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.inner_write(buf)\n-    }\n-}\n-\n impl rtio::RtioFileStream for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<int> {\n         self.inner_read(buf).map(|i| i as int)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n \n-    fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n+    fn pread(&mut self, buf: &mut [u8], offset: u64) -> IoResult<int> {\n         let mut read = 0;\n         let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n         overlap.Offset = offset as libc::DWORD;\n@@ -147,7 +132,7 @@ impl rtio::RtioFileStream for FileDesc {\n             Err(super::last_error())\n         }\n     }\n-    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> Result<(), IoError> {\n+    fn pwrite(&mut self, buf: &[u8], mut offset: u64) -> IoResult<()> {\n         let mut cur = buf.as_ptr();\n         let mut remaining = buf.len();\n         let mut overlap: libc::OVERLAPPED = unsafe { mem::zeroed() };\n@@ -171,36 +156,36 @@ impl rtio::RtioFileStream for FileDesc {\n         Ok(())\n     }\n \n-    fn seek(&mut self, pos: i64, style: io::SeekStyle) -> Result<u64, IoError> {\n+    fn seek(&mut self, pos: i64, style: rtio::SeekStyle) -> IoResult<u64> {\n         self.seek_common(pos, style)\n     }\n \n-    fn tell(&self) -> Result<u64, IoError> {\n-        self.seek_common(0, io::SeekCur)\n+    fn tell(&self) -> IoResult<u64> {\n+        self.seek_common(0, rtio::SeekCur)\n     }\n \n-    fn fsync(&mut self) -> Result<(), IoError> {\n+    fn fsync(&mut self) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n             libc::FlushFileBuffers(self.handle())\n         })\n     }\n \n-    fn datasync(&mut self) -> Result<(), IoError> { return self.fsync(); }\n+    fn datasync(&mut self) -> IoResult<()> { return self.fsync(); }\n \n-    fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n+    fn truncate(&mut self, offset: i64) -> IoResult<()> {\n         let orig_pos = try!(self.tell());\n-        let _ = try!(self.seek(offset, io::SeekSet));\n+        let _ = try!(self.seek(offset, rtio::SeekSet));\n         let ret = unsafe {\n             match libc::SetEndOfFile(self.handle()) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(())\n             }\n         };\n-        let _ = self.seek(orig_pos as i64, io::SeekSet);\n+        let _ = self.seek(orig_pos as i64, rtio::SeekSet);\n         return ret;\n     }\n \n-    fn fstat(&mut self) -> IoResult<io::FileStat> {\n+    fn fstat(&mut self) -> IoResult<rtio::FileStat> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         match unsafe { libc::fstat(self.fd(), &mut stat) } {\n             0 => Ok(mkstat(&stat)),\n@@ -210,10 +195,10 @@ impl rtio::RtioFileStream for FileDesc {\n }\n \n impl rtio::RtioPipe for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n     fn clone(&self) -> Box<rtio::RtioPipe:Send> {\n@@ -225,27 +210,27 @@ impl rtio::RtioPipe for FileDesc {\n     // std::io::PipeStream. If the functionality is exposed in the future, then\n     // these methods will need to be implemented.\n     fn close_read(&mut self) -> IoResult<()> {\n-        Err(io::standard_error(io::InvalidInput))\n+        Err(super::unimpl())\n     }\n     fn close_write(&mut self) -> IoResult<()> {\n-        Err(io::standard_error(io::InvalidInput))\n+        Err(super::unimpl())\n     }\n     fn set_timeout(&mut self, _t: Option<u64>) {}\n     fn set_read_timeout(&mut self, _t: Option<u64>) {}\n     fn set_write_timeout(&mut self, _t: Option<u64>) {}\n }\n \n impl rtio::RtioTTY for FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.inner_read(buf)\n     }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.inner_write(buf)\n     }\n-    fn set_raw(&mut self, _raw: bool) -> Result<(), IoError> {\n+    fn set_raw(&mut self, _raw: bool) -> IoResult<()> {\n         Err(super::unimpl())\n     }\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n+    fn get_winsize(&mut self) -> IoResult<(int, int)> {\n         Err(super::unimpl())\n     }\n     fn isatty(&self) -> bool { false }\n@@ -268,24 +253,24 @@ impl Drop for Inner {\n     }\n }\n \n-pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n+pub fn open(path: &CString, fm: rtio::FileMode, fa: rtio::FileAccess)\n         -> IoResult<FileDesc> {\n     // Flags passed to open_osfhandle\n     let flags = match fm {\n-        io::Open => 0,\n-        io::Append => libc::O_APPEND,\n-        io::Truncate => libc::O_TRUNC,\n+        rtio::Open => 0,\n+        rtio::Append => libc::O_APPEND,\n+        rtio::Truncate => libc::O_TRUNC,\n     };\n     let flags = match fa {\n-        io::Read => flags | libc::O_RDONLY,\n-        io::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n-        io::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n+        rtio::Read => flags | libc::O_RDONLY,\n+        rtio::Write => flags | libc::O_WRONLY | libc::O_CREAT,\n+        rtio::ReadWrite => flags | libc::O_RDWR | libc::O_CREAT,\n     };\n \n     let mut dwDesiredAccess = match fa {\n-        io::Read => libc::FILE_GENERIC_READ,\n-        io::Write => libc::FILE_GENERIC_WRITE,\n-        io::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n+        rtio::Read => libc::FILE_GENERIC_READ,\n+        rtio::Write => libc::FILE_GENERIC_WRITE,\n+        rtio::ReadWrite => libc::FILE_GENERIC_READ | libc::FILE_GENERIC_WRITE\n     };\n \n     // libuv has a good comment about this, but the basic idea is what we try to\n@@ -295,15 +280,15 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n                       libc::FILE_SHARE_DELETE;\n \n     let dwCreationDisposition = match (fm, fa) {\n-        (io::Truncate, io::Read) => libc::TRUNCATE_EXISTING,\n-        (io::Truncate, _) => libc::CREATE_ALWAYS,\n-        (io::Open, io::Read) => libc::OPEN_EXISTING,\n-        (io::Open, _) => libc::OPEN_ALWAYS,\n-        (io::Append, io::Read) => {\n+        (rtio::Truncate, rtio::Read) => libc::TRUNCATE_EXISTING,\n+        (rtio::Truncate, _) => libc::CREATE_ALWAYS,\n+        (rtio::Open, rtio::Read) => libc::OPEN_EXISTING,\n+        (rtio::Open, _) => libc::OPEN_ALWAYS,\n+        (rtio::Append, rtio::Read) => {\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_EXISTING\n         }\n-        (io::Append, _) => {\n+        (rtio::Append, _) => {\n             dwDesiredAccess &= !libc::FILE_WRITE_DATA;\n             dwDesiredAccess |= libc::FILE_APPEND_DATA;\n             libc::OPEN_ALWAYS\n@@ -338,7 +323,7 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n     }\n }\n \n-pub fn mkdir(p: &CString, _mode: io::FilePermission) -> IoResult<()> {\n+pub fn mkdir(p: &CString, _mode: uint) -> IoResult<()> {\n     super::mkerr_winbool(unsafe {\n         // FIXME: turn mode into something useful? #2623\n         as_utf16_p(p.as_str().unwrap(), |buf| {\n@@ -413,9 +398,9 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     })\n }\n \n-pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n+pub fn chmod(p: &CString, mode: uint) -> IoResult<()> {\n     super::mkerr_libc(as_utf16_p(p.as_str().unwrap(), |p| unsafe {\n-        libc::wchmod(p, mode.bits() as libc::c_int)\n+        libc::wchmod(p, mode as libc::c_int)\n     }))\n }\n \n@@ -430,7 +415,7 @@ pub fn chown(_p: &CString, _uid: int, _gid: int) -> IoResult<()> {\n     Ok(())\n }\n \n-pub fn readlink(p: &CString) -> IoResult<Path> {\n+pub fn readlink(p: &CString) -> IoResult<CString> {\n     // FIXME: I have a feeling that this reads intermediate symlinks as well.\n     use io::c::compat::kernel32::GetFinalPathNameByHandleW;\n     let handle = unsafe {\n@@ -457,9 +442,9 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     });\n     let ret = match ret {\n         Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => {\n-            Ok(Path::new(s.as_slice().slice_from(4)))\n+            Ok(Path::new(s.as_slice().slice_from(4)).to_c_str())\n         }\n-        Some(s) => Ok(Path::new(s)),\n+        Some(s) => Ok(Path::new(s).to_c_str()),\n         None => Err(super::last_error()),\n     };\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n@@ -483,39 +468,28 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n     }))\n }\n \n-fn mkstat(stat: &libc::stat) -> io::FileStat {\n-    let kind = match (stat.st_mode as c_int) & libc::S_IFMT {\n-        libc::S_IFREG => io::TypeFile,\n-        libc::S_IFDIR => io::TypeDirectory,\n-        libc::S_IFIFO => io::TypeNamedPipe,\n-        libc::S_IFBLK => io::TypeBlockSpecial,\n-        libc::S_IFLNK => io::TypeSymlink,\n-        _ => io::TypeUnknown,\n-    };\n-\n-    io::FileStat {\n+fn mkstat(stat: &libc::stat) -> rtio::FileStat {\n+    rtio::FileStat {\n         size: stat.st_size as u64,\n-        kind: kind,\n-        perm: io::FilePermission::from_bits_truncate(stat.st_mode as u32),\n+        kind: stat.st_mode as u64,\n+        perm: stat.st_mode as u64,\n         created: stat.st_ctime as u64,\n         modified: stat.st_mtime as u64,\n         accessed: stat.st_atime as u64,\n-        unstable: io::UnstableFileStat {\n-            device: stat.st_dev as u64,\n-            inode: stat.st_ino as u64,\n-            rdev: stat.st_rdev as u64,\n-            nlink: stat.st_nlink as u64,\n-            uid: stat.st_uid as u64,\n-            gid: stat.st_gid as u64,\n-            blksize: 0,\n-            blocks: 0,\n-            flags: 0,\n-            gen: 0,\n-        }\n+        device: stat.st_dev as u64,\n+        inode: stat.st_ino as u64,\n+        rdev: stat.st_rdev as u64,\n+        nlink: stat.st_nlink as u64,\n+        uid: stat.st_uid as u64,\n+        gid: stat.st_gid as u64,\n+        blksize: 0,\n+        blocks: 0,\n+        flags: 0,\n+        gen: 0,\n     }\n }\n \n-pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n+pub fn stat(p: &CString) -> IoResult<rtio::FileStat> {\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     as_utf16_p(p.as_str().unwrap(), |up| {\n         match unsafe { libc::wstat(up, &mut stat) } {\n@@ -525,7 +499,7 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n     })\n }\n \n-pub fn lstat(_p: &CString) -> IoResult<io::FileStat> {\n+pub fn lstat(_p: &CString) -> IoResult<rtio::FileStat> {\n     // FIXME: implementation is missing\n     Err(super::unimpl())\n }"}, {"sha": "24956e514ec83e09cb85ce4234040e270ad2d03d", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -135,10 +135,12 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n }\n \n #[cfg(windows)]\n-fn last_error() -> IoError {\n+pub fn last_error() -> IoError {\n+    use std::os;\n     let code = unsafe { c::WSAGetLastError() as uint };\n     IoError {\n         code: code,\n+        extra: 0,\n         detail: Some(os::error_string(code)),\n     }\n }\n@@ -225,7 +227,7 @@ pub fn init() {}\n pub fn init() {\n \n     unsafe {\n-        use std::unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+        use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n         static mut INITIALIZED: bool = false;\n         static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n "}, {"sha": "a5694436b97200016f91a4d4463493a7029b6531", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -87,16 +87,15 @@\n use alloc::arc::Arc;\n use libc;\n use std::c_str::CString;\n-use std::io;\n use std::mem;\n use std::os::win32::as_utf16_p;\n use std::os;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::{IoResult, IoError};\n use std::sync::atomics;\n-use std::unstable::mutex;\n+use std::rt::mutex;\n \n-use super::IoResult;\n use super::c;\n use super::util;\n \n@@ -190,6 +189,14 @@ pub fn await(handle: libc::HANDLE, deadline: u64,\n     }\n }\n \n+fn epipe() -> IoError {\n+    IoError {\n+        code: libc::ERROR_BROKEN_PIPE as uint,\n+        extra: 0,\n+        detail: None,\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Unix Streams\n ////////////////////////////////////////////////////////////////////////////////\n@@ -355,7 +362,7 @@ impl rtio::RtioPipe for UnixStream {\n         // See comments in close_read() about why this lock is necessary.\n         let guard = unsafe { self.inner.lock.lock() };\n         if self.read_closed() {\n-            return Err(io::standard_error(io::EndOfFile))\n+            return Err(util::eof())\n         }\n \n         // Issue a nonblocking requests, succeeding quickly if it happened to\n@@ -403,10 +410,10 @@ impl rtio::RtioPipe for UnixStream {\n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n             if !succeeded {\n-                return Err(io::standard_error(io::TimedOut))\n+                return Err(util::timeout(\"read timed out\"))\n             }\n             if self.read_closed() {\n-                return Err(io::standard_error(io::EndOfFile))\n+                return Err(util::eof())\n             }\n         }\n     }\n@@ -431,7 +438,7 @@ impl rtio::RtioPipe for UnixStream {\n             // See comments in close_read() about why this lock is necessary.\n             let guard = unsafe { self.inner.lock.lock() };\n             if self.write_closed() {\n-                return Err(io::standard_error(io::BrokenPipe))\n+                return Err(epipe())\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n@@ -445,7 +452,11 @@ impl rtio::RtioPipe for UnixStream {\n \n             if ret == 0 {\n                 if err != libc::ERROR_IO_PENDING as uint {\n-                    return Err(io::IoError::from_errno(err, true));\n+                    return Err(IoError {\n+                        code: err as uint,\n+                        extra: 0,\n+                        detail: Some(os::error_string(err as uint)),\n+                    })\n                 }\n                 // Process a timeout if one is pending\n                 let succeeded = await(self.handle(), self.write_deadline,\n@@ -466,17 +477,17 @@ impl rtio::RtioPipe for UnixStream {\n                     if !succeeded {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n-                            Err(io::IoError {\n-                                kind: io::ShortWrite(amt),\n-                                desc: \"short write during write\",\n-                                detail: None,\n+                            Err(IoError {\n+                                code: libc::ERROR_OPERATION_ABORTED as uint,\n+                                extra: amt,\n+                                detail: Some(\"short write during write\".to_str()),\n                             })\n                         } else {\n                             Err(util::timeout(\"write timed out\"))\n                         }\n                     }\n                     if self.write_closed() {\n-                        return Err(io::standard_error(io::BrokenPipe))\n+                        return Err(epipe())\n                     }\n                     continue // retry\n                 }"}, {"sha": "2c2b7cec1dec4806a3d32835de56b458b825d85f", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -210,23 +210,23 @@ unsafe fn killpid(pid: pid_t, signal: int) -> IoResult<()> {\n             if ret == 0 {\n                 Err(super::last_error())\n             } else if status != libc::STILL_ACTIVE {\n-                Err(io::IoError {\n-                    kind: io::OtherIoError,\n-                    desc: \"process no longer alive\",\n+                Err(IoError {\n+                    code: libc::ERROR_NOTHING_TO_TERMINATE as uint,\n+                    extra: 0,\n                     detail: None,\n                 })\n             } else {\n                 Ok(())\n             }\n         }\n-        io::process::PleaseExitSignal | io::process::MustDieSignal => {\n+        15 | 9 => { // sigterm or sigkill\n             let ret = libc::TerminateProcess(handle, 1);\n             super::mkerr_winbool(ret)\n         }\n-        _ => Err(io::IoError {\n-            kind: io::OtherIoError,\n-            desc: \"unsupported signal on windows\",\n-            detail: None,\n+        _ => Err(IoError {\n+            code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n+            extra: 0,\n+            detail: Some(\"unsupported signal on windows\".to_string()),\n         })\n     };\n     let _ = libc::CloseHandle(handle);\n@@ -266,10 +266,10 @@ fn spawn_process_os(cfg: ProcessConfig,\n     use std::mem;\n \n     if cfg.gid.is_some() || cfg.uid.is_some() {\n-        return Err(io::IoError {\n-            kind: io::OtherIoError,\n-            desc: \"unsupported gid/uid requested on windows\",\n-            detail: None,\n+        return Err(IoError {\n+            code: libc::ERROR_CALL_NOT_IMPLEMENTED as uint,\n+            extra: 0,\n+            detail: Some(\"unsupported gid/uid requested on windows\".to_str()),\n         })\n     }\n "}, {"sha": "d175060dd98606f04502e01e96c3d240d8e86a93", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -23,10 +23,10 @@\n use libc;\n use std::ptr;\n use std::rt::rtio;\n+use std::rt::rtio::{IoResult, Callback};\n use std::comm;\n \n use io::helper_thread::Helper;\n-use io::IoResult;\n \n helper_init!(static mut HELPER: Helper<Req>)\n \n@@ -36,7 +36,7 @@ pub struct Timer {\n }\n \n pub enum Req {\n-    NewTimer(libc::HANDLE, Sender<()>, bool),\n+    NewTimer(libc::HANDLE, Box<Callback:Send>, bool),\n     RemoveTimer(libc::HANDLE, Sender<()>),\n }\n \n@@ -79,8 +79,8 @@ fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n             }\n         } else {\n             let remove = {\n-                match chans.get(idx as uint - 1) {\n-                    &(ref c, oneshot) => c.send_opt(()).is_err() || oneshot\n+                match chans.get_mut(idx as uint - 1) {\n+                    &(ref mut c, oneshot) => { c.call(); oneshot }\n                 }\n             };\n             if remove {\n@@ -148,9 +148,8 @@ impl rtio::RtioTimer for Timer {\n         let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+    fn oneshot(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         self.remove();\n-        let (tx, rx) = channel();\n \n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n@@ -159,14 +158,12 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        unsafe { HELPER.send(NewTimer(self.obj, tx, true)) }\n+        unsafe { HELPER.send(NewTimer(self.obj, cb, true)) }\n         self.on_worker = true;\n-        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Receiver<()> {\n+    fn period(&mut self, msecs: u64, cb: Box<Callback:Send>) {\n         self.remove();\n-        let (tx, rx) = channel();\n \n         // see above for the calculation\n         let due = -(msecs as i64 * 10000) as libc::LARGE_INTEGER;\n@@ -175,10 +172,8 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null(), ptr::mut_null(), 0)\n         }, 1);\n \n-        unsafe { HELPER.send(NewTimer(self.obj, tx, false)) }\n+        unsafe { HELPER.send(NewTimer(self.obj, cb, false)) }\n         self.on_worker = true;\n-\n-        return rx;\n     }\n }\n "}, {"sha": "4234c085148cb575acbe2856a8ba099b220c44e2", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -238,9 +238,15 @@ impl Container for CString {\n     #[inline]\n     fn len(&self) -> uint {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        let mut cur = self.buf;\n+        let mut len = 0;\n         unsafe {\n-            ptr::position(self.buf, |c| *c == 0)\n+            while *cur != 0 {\n+                len += 1;\n+                cur = cur.offset(1);\n+            }\n         }\n+        return len;\n     }\n }\n "}, {"sha": "3158687c6ab937e04be0b278f4a2252e17eba01f", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -113,6 +113,7 @@ pub fn init(argc: int, argv: **u8) {\n     // FIXME(#14344) this shouldn't be necessary\n     collections::fixme_14344_be_sure_to_link_to_collections();\n     alloc::fixme_14344_be_sure_to_link_to_collections();\n+    libc::issue_14344_workaround();\n }\n \n /// Enqueues a procedure to run when the runtime is cleaned up"}, {"sha": "6b468bd0827c6144ba0c63eec06c10a922f7bf67", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -95,8 +95,6 @@ type TLSValue = Box<LocalData:Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map() -> Option<&mut Map> {\n-    use rt::local::Local;\n-\n     if !Local::exists(None::<Task>) { return None }\n \n     let task: *mut Task = Local::unsafe_borrow();"}, {"sha": "0640b2b9c77aeefe06c80b52d7885000becf27e6", "filename": "src/librustrt/task.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Ftask.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -18,10 +18,11 @@ use core::prelude::*;\n use alloc::arc::Arc;\n use alloc::owned::{AnyOwnExt, Box};\n use core::any::Any;\n+use core::atomics::{AtomicUint, SeqCst};\n+use core::finally::Finally;\n use core::iter::Take;\n use core::mem;\n-use core::finally::Finally;\n-use core::atomics::{AtomicUint, SeqCst};\n+use core::raw;\n \n use local_data;\n use Runtime;\n@@ -142,18 +143,17 @@ impl Task {\n                 // TLS, or possibly some destructors for those objects being\n                 // annihilated invoke TLS. Sadly these two operations seemed to\n                 // be intertwined, and miraculously work for now...\n-                let mut task = Local::borrow(None::<Task>);\n-                let storage_map = {\n+                drop({\n+                    let mut task = Local::borrow(None::<Task>);\n                     let &LocalStorage(ref mut optmap) = &mut task.storage;\n                     optmap.take()\n-                };\n-                drop(task);\n-                drop(storage_map);\n+                });\n \n                 // Destroy remaining boxes. Also may run user dtors.\n-                let mut task = Local::borrow(None::<Task>);\n-                let mut heap = mem::replace(&mut task.heap, LocalHeap::new());\n-                drop(task);\n+                let mut heap = {\n+                    let mut task = Local::borrow(None::<Task>);\n+                    mem::replace(&mut task.heap, LocalHeap::new())\n+                };\n                 unsafe { heap.annihilate() }\n                 drop(heap);\n             })\n@@ -202,13 +202,16 @@ impl Task {\n         //      crops up.\n         unsafe {\n             let imp = self.imp.take_unwrap();\n-            let &(vtable, _): &(uint, uint) = mem::transmute(&imp);\n+            let vtable = mem::transmute::<_, &raw::TraitObject>(&imp).vtable;\n             match imp.wrap().move::<T>() {\n                 Ok(t) => Some(t),\n                 Err(t) => {\n-                    let (_, obj): (uint, uint) = mem::transmute(t);\n+                    let data = mem::transmute::<_, raw::TraitObject>(t).data;\n                     let obj: Box<Runtime:Send> =\n-                        mem::transmute((vtable, obj));\n+                        mem::transmute(raw::TraitObject {\n+                            vtable: vtable,\n+                            data: data,\n+                        });\n                     self.put_runtime(obj);\n                     None\n                 }"}, {"sha": "2fd9f4ef1f18cadf9e6d8ebddcaa24efa058e96d", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -121,7 +121,7 @@ impl Unwinder {\n         self.cause = unsafe { try(f) }.err();\n     }\n \n-    pub fn result(&mut self) -> TaskResult {\n+    pub fn result(&mut self) -> Result {\n         if self.unwinding {\n             Err(self.cause.take().unwrap())\n         } else {\n@@ -150,10 +150,7 @@ impl Unwinder {\n ///   guaranteed that a rust task is in place when invoking this function.\n ///   Unwinding twice can lead to resource leaks where some destructors are not\n ///   run.\n-pub unsafe fn try(f: ||) -> Result<(), Box<Any:Send>> {\n-    use raw::Closure;\n-    use libc::{c_void};\n-\n+pub unsafe fn try(f: ||) -> ::core::result::Result<(), Box<Any:Send>> {\n     let closure: Closure = mem::transmute(f);\n     let ep = rust_try(try_fn, closure.code as *c_void,\n                       closure.env as *c_void);\n@@ -300,7 +297,7 @@ pub mod eabi {\n #[cfg(target_arch = \"arm\", not(test))]\n #[allow(visible_private_types)]\n pub mod eabi {\n-    use uw = rt::libunwind;\n+    use uw = libunwind;\n     use libc::c_int;\n \n     extern \"C\" {\n@@ -432,9 +429,9 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n     // Now that we've run all the necessary unwind callbacks, we actually\n     // perform the unwinding. If we don't have a task, then it's time to die\n     // (hopefully someone printed something about this).\n-    let task: Box<Task> = match Local::try_take() {\n+    let mut task: Box<Task> = match Local::try_take() {\n         Some(task) => task,\n-        None => unsafe { intrinsics::abort() }\n+        None => rust_fail(msg),\n     };\n \n     if task.unwinder.unwinding {\n@@ -445,17 +442,13 @@ fn begin_unwind_inner(msg: Box<Any:Send>,\n         rterrln!(\"task failed during unwinding. aborting.\");\n         unsafe { intrinsics::abort() }\n     }\n+    task.unwinder.unwinding = true;\n \n     // Put the task back in TLS because the unwinding process may run code which\n     // requires the task. We need a handle to its unwinder, however, so after\n     // this we unsafely extract it and continue along.\n     Local::put(task);\n-    unsafe {\n-        let task: *mut Task = Local::unsafe_borrow();\n-        (*task).unwinder.begin_unwind(msg);\n-    }\n-    task.name = name;\n-    Local::put(task);\n+    rust_fail(msg);\n }\n \n /// Register a callback to be invoked when a task unwinds."}, {"sha": "c08652cc08c792feb14864b46660875ec289adc7", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -73,9 +73,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n     let mut w = BufWriter { buf: msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n     let msg = str::from_utf8(w.buf.slice_to(w.pos)).unwrap_or(\"aborted\");\n-    let msg = if msg.is_empty() {\n-        \"aborted\"\n-    } else { \"aborted\" };\n+    let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message\n     let hash = msg.bytes().fold(0, |accum, val| accum + (val as uint) );"}, {"sha": "e2122aea0365ebeb2167df272a4ace6927df9aa8", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -404,22 +404,23 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n     let UvError(errcode) = uverr;\n     IoError {\n         code: match errcode {\n-            uvll::EOF => io::EOF,\n-            uvll::EACCES => io::ERROR_ACCESS_DENIED,\n-            uvll::ECONNREFUSED => io::WSAECONNREFUSED,\n-            uvll::ECONNRESET => io::WSAECONNRESET,\n-            uvll::ENOTCONN => io::WSAENOTCONN,\n-            uvll::ENOENT => io::ERROR_NOT_FOUND,\n-            uvll::EPIPE => io::ERROR_BROKEN_PIPE,\n-            uvll::ECONNABORTED => io::WSAECONNABORTED,\n-            uvll::EADDRNOTAVAIL => io::WSAEADDRNOTAVAIL,\n+            uvll::EOF => libc::EOF,\n+            uvll::EACCES => libc::ERROR_ACCESS_DENIED,\n+            uvll::ECONNREFUSED => libc::WSAECONNREFUSED,\n+            uvll::ECONNRESET => libc::WSAECONNRESET,\n+            uvll::ENOTCONN => libc::WSAENOTCONN,\n+            uvll::ENOENT => libc::ERROR_FILE_NOT_FOUND,\n+            uvll::EPIPE => libc::ERROR_NO_DATA,\n+            uvll::ECONNABORTED => libc::WSAECONNABORTED,\n+            uvll::EADDRNOTAVAIL => libc::WSAEADDRNOTAVAIL,\n             uvll::ECANCELED => libc::ERROR_OPERATION_ABORTED,\n+            uvll::EADDRINUSE => libc::WSAEADDRINUSE,\n             err => {\n                 uvdebug!(\"uverr.code {}\", err as int);\n                 // FIXME: Need to map remaining uv error types\n                 -1\n             }\n-        },\n+        } as uint,\n         extra: 0,\n         detail: Some(uverr.desc()),\n     }"}, {"sha": "f6c6d6c9068e0cbbfc46a43811f50d22dd183382", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -38,7 +38,8 @@ use std::rt::libc_heap::malloc_raw;\n use libc::uintptr_t;\n \n pub use self::errors::{EACCES, ECONNREFUSED, ECONNRESET, EPIPE, ECONNABORTED,\n-                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL};\n+                       ECANCELED, EBADF, ENOTCONN, ENOENT, EADDRNOTAVAIL,\n+                       EADDRINUSE};\n \n pub static OK: c_int = 0;\n pub static EOF: c_int = -4095;\n@@ -61,6 +62,7 @@ pub mod errors {\n     pub static ECANCELED: c_int = -4081;\n     pub static EBADF: c_int = -4083;\n     pub static EADDRNOTAVAIL: c_int = -4090;\n+    pub static EADDRINUSE: c_int = -4091;\n }\n #[cfg(not(windows))]\n pub mod errors {\n@@ -77,6 +79,7 @@ pub mod errors {\n     pub static ECANCELED : c_int = -libc::ECANCELED;\n     pub static EBADF : c_int = -libc::EBADF;\n     pub static EADDRNOTAVAIL : c_int = -libc::EADDRNOTAVAIL;\n+    pub static EADDRINUSE : c_int = -libc::EADDRINUSE;\n }\n \n pub static PROCESS_SETUID: c_int = 1 << 0;"}, {"sha": "c72cc0ded9bc3ca7c5f0210de3de15f75c394302", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -313,7 +313,8 @@ impl IoError {\n                 libc::ERROR_INVALID_NAME => (InvalidInput, \"invalid file name\"),\n                 libc::WSAECONNREFUSED => (ConnectionRefused, \"connection refused\"),\n                 libc::WSAECONNRESET => (ConnectionReset, \"connection reset\"),\n-                libc::WSAEACCES => (PermissionDenied, \"permission denied\"),\n+                libc::ERROR_ACCESS_DENIED | libc::WSAEACCES =>\n+                    (PermissionDenied, \"permission denied\"),\n                 libc::WSAEWOULDBLOCK => {\n                     (ResourceUnavailable, \"resource temporarily unavailable\")\n                 }\n@@ -327,7 +328,7 @@ impl IoError {\n                 libc::WSAEINVAL => (InvalidInput, \"invalid argument\"),\n                 libc::ERROR_CALL_NOT_IMPLEMENTED =>\n                     (IoUnavailable, \"function not implemented\"),\n-                libc::ERROR_CALL_NOT_IMPLEMENTED =>\n+                libc::ERROR_INVALID_HANDLE =>\n                     (MismatchedFileTypeForOperation,\n                      \"invalid handle provided to function\"),\n                 libc::ERROR_NOTHING_TO_TERMINATE =>"}, {"sha": "6c773467553d2f055d46a744cc3a251521bd1413", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -982,7 +982,8 @@ mod test {\n         match TcpListener::bind(ip_str.as_slice(), port).listen() {\n             Ok(..) => fail!(),\n             Err(e) => {\n-                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError);\n+                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n+                        \"unknown error: {} {}\", e, e.kind);\n             }\n         }\n     })"}, {"sha": "bac4d26b4e49a6e8ce114fd5ce816efd671c449b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -256,11 +256,6 @@ pub mod unstable;\n pub mod rt;\n mod failure;\n \n-#[doc(hidden)]\n-pub fn issue_14344_workaround() { // FIXME #14344 force linkage to happen correctly\n-    libc::issue_14344_workaround();\n-}\n-\n // A curious inner-module that's not exported that contains the binding\n // 'std' so that macro-expanded references to std::error and such\n // can be resolved within libstd."}, {"sha": "766901fa04f32f663e559c16cda477b6ee2f9606", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -603,18 +603,18 @@ mod imp {\n mod imp {\n     use c_str::CString;\n     use container::Container;\n+    use intrinsics;\n     use io::{IoResult, Writer};\n     use libc;\n     use mem;\n     use ops::Drop;\n     use option::{Some, None};\n     use path::Path;\n     use result::{Ok, Err};\n+    use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+    use slice::ImmutableVector;\n     use str::StrSlice;\n     use unstable::dynamic_lib::DynamicLibrary;\n-    use intrinsics;\n-    use unstable::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-    use slice::ImmutableVector;\n \n     #[allow(non_snake_case_functions)]\n     extern \"system\" {"}, {"sha": "a68a632bc37e0b13cc249d28a0f72c3be1a458df", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -57,10 +57,11 @@ Several modules in `core` are clients of `rt`:\n use failure;\n use rustrt;\n \n-// TODO: dox\n+// Reexport some of our utilities which are expected by other crates.\n pub use self::util::{default_sched_threads, min_stack, running_on_valgrind};\n \n-// TODO: dox\n+// Reexport functionality from librustrt and other crates underneath the\n+// standard library which work together to create the entire runtime.\n pub use alloc::{heap, libc_heap};\n pub use rustrt::{task, local, mutex, exclusive, stack, args, rtio};\n pub use rustrt::{Stdio, Stdout, Stderr, begin_unwind, begin_unwind_fmt};"}, {"sha": "9ee62ee3d81b6c5269e1b2ecc06d5c4b993ea5ea", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -182,14 +182,8 @@ impl TaskBuilder {\n         };\n         if stdout.is_some() || stderr.is_some() {\n             t.spawn_sibling(opts, proc() {\n-                match stdout {\n-                    Some(handle) => { let _ = stdio::set_stdout(handle); }\n-                    None => {}\n-                }\n-                match stderr {\n-                    Some(handle) => { let _ = stdio::set_stderr(handle); }\n-                    None => {}\n-                }\n+                let _ = stdout.map(stdio::set_stdout);\n+                let _ = stderr.map(stdio::set_stderr);\n                 f();\n             });\n         } else {"}, {"sha": "bcf5a43fb6b3e684fee7634bde5d8abfac82e436", "filename": "src/libsync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Flibsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fmutex.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -64,7 +64,7 @@ use std::rt::task::{BlockedTask, Task};\n use std::rt::thread::Thread;\n use std::sync::atomics;\n use std::ty::Unsafe;\n-use std::unstable::mutex;\n+use std::rt::mutex;\n \n use q = mpsc_intrusive;\n "}, {"sha": "0ef48c9978251e09cbde006d0ab789fe1e0fc35c", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -28,7 +28,7 @@ fn start(argc: int, argv: **u8) -> int {\n                 4 => assert!(try(|| fail!()).is_err()),\n                 5 => assert!(try(|| spawn(proc() {})).is_err()),\n                 6 => assert!(Command::new(\"test\").spawn().is_err()),\n-                7 => assert!(foo.get().is_some()),\n+                7 => assert!(foo.get().is_none()),\n                 8 => assert!(try(|| { foo.replace(Some(3)); }).is_err()),\n                 _ => fail!()\n             }\n@@ -49,6 +49,8 @@ fn main() {\n     pass(Command::new(me).arg(&[4u8]).output().unwrap());\n     pass(Command::new(me).arg(&[5u8]).output().unwrap());\n     pass(Command::new(me).arg(&[6u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[7u8]).output().unwrap());\n+    pass(Command::new(me).arg(&[8u8]).output().unwrap());\n }\n \n fn pass(output: ProcessOutput) {"}, {"sha": "a9a6e25adf38b88809efe909b35e9f4eee1f09a8", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75014f7b1790e7ebdf13d38acc04dfdab6e450e9/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=75014f7b1790e7ebdf13d38acc04dfdab6e450e9", "patch": "@@ -61,7 +61,7 @@ fn main() {\n     for _ in range(0, 1000) {\n         let tx = tx.clone();\n         let mut builder = TaskBuilder::new();\n-        builder.opts.stack_size = Some(32 * 1024);\n+        builder.opts.stack_size = Some(64 * 1024);\n         builder.spawn(proc() {\n             let host = addr.ip.to_str();\n             let port = addr.port;"}]}