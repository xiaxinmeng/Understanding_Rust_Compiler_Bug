{"sha": "92f2b6243d717b6ff711fdf9fe9d579d41669ee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjJiNjI0M2Q3MTdiNmZmNzExZmRmOWZlOWQ1NzlkNDE2NjllZTE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-24T09:56:24Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-24T09:56:24Z"}, "message": "Rustup to rustc 1.38.0-nightly (a7f28678b 2019-07-23)", "tree": {"sha": "dce60e25ffba43969532019c5f897e12570178f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dce60e25ffba43969532019c5f897e12570178f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f2b6243d717b6ff711fdf9fe9d579d41669ee1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f2b6243d717b6ff711fdf9fe9d579d41669ee1", "html_url": "https://github.com/rust-lang/rust/commit/92f2b6243d717b6ff711fdf9fe9d579d41669ee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f2b6243d717b6ff711fdf9fe9d579d41669ee1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "853234006ef12376d0f4574b6b726895f5d79210", "url": "https://api.github.com/repos/rust-lang/rust/commits/853234006ef12376d0f4574b6b726895f5d79210", "html_url": "https://github.com/rust-lang/rust/commit/853234006ef12376d0f4574b6b726895f5d79210"}], "stats": {"total": 132, "additions": 72, "deletions": 60}, "files": [{"sha": "243c660368d3a78bfe71108c2043f6b9092c6130", "filename": "src/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f2b6243d717b6ff711fdf9fe9d579d41669ee1/src%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f2b6243d717b6ff711fdf9fe9d579d41669ee1/src%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fanalyze.rs?ref=92f2b6243d717b6ff711fdf9fe9d579d41669ee1", "patch": "@@ -47,8 +47,8 @@ pub fn analyze<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>) -> HashMap\n }\n \n fn analyze_non_ssa_place(flag_map: &mut HashMap<Local, Flags>, place: &Place) {\n-    match place {\n-        Place::Base(PlaceBase::Local(local)) => not_ssa(flag_map, local),\n+    match place.base {\n+        PlaceBase::Local(local) => not_ssa(flag_map, local),\n         _ => {}\n     }\n }"}, {"sha": "1adcec046e033cc8768622f1334499e4839f5f77", "filename": "src/base.rs", "status": "modified", "additions": 70, "deletions": 58, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/92f2b6243d717b6ff711fdf9fe9d579d41669ee1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f2b6243d717b6ff711fdf9fe9d579d41669ee1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=92f2b6243d717b6ff711fdf9fe9d579d41669ee1", "patch": "@@ -1148,70 +1148,82 @@ pub fn trans_place<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     place: &Place<'tcx>,\n ) -> CPlace<'tcx> {\n-    match place {\n-        Place::Base(base) => match base {\n-            PlaceBase::Local(local) => fx.get_local_place(*local),\n-            PlaceBase::Static(static_) => match static_.kind {\n-                StaticKind::Static(def_id) => {\n-                    crate::constant::codegen_static_ref(fx, def_id, static_.ty)\n-                }\n-                StaticKind::Promoted(promoted) => {\n-                    crate::constant::trans_promoted(fx, promoted, static_.ty)\n-                }\n+    let base = match &place.base {\n+        PlaceBase::Local(local) => fx.get_local_place(*local),\n+        PlaceBase::Static(static_) => match static_.kind {\n+            StaticKind::Static(def_id) => {\n+                crate::constant::codegen_static_ref(fx, def_id, static_.ty)\n+            }\n+            StaticKind::Promoted(promoted) => {\n+                crate::constant::trans_promoted(fx, promoted, static_.ty)\n             }\n         }\n-        Place::Projection(projection) => {\n-            let base = trans_place(fx, &projection.base);\n-            match projection.elem {\n-                ProjectionElem::Deref => base.place_deref(fx),\n-                ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n-                ProjectionElem::Index(local) => {\n-                    let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n-                    base.place_index(fx, index)\n-                }\n-                ProjectionElem::ConstantIndex {\n-                    offset,\n-                    min_length: _,\n-                    from_end,\n-                } => {\n-                    let index = if !from_end {\n-                        fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n-                    } else {\n-                        let len = codegen_array_len(fx, base);\n-                        fx.bcx.ins().iadd_imm(len, -(offset as i64))\n-                    };\n-                    base.place_index(fx, index)\n+    };\n+\n+    trans_place_projection(fx, base, &place.projection)\n+}\n+\n+pub fn trans_place_projection<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    base: CPlace<'tcx>,\n+    projection: &Option<Box<Projection<'tcx>>>,\n+) -> CPlace<'tcx> {\n+    let projection = if let Some(projection) = projection {\n+        projection\n+    } else {\n+        return base;\n+    };\n+\n+    let base = trans_place_projection(fx, base, &projection.base);\n+\n+    match projection.elem {\n+        ProjectionElem::Deref => base.place_deref(fx),\n+        ProjectionElem::Field(field, _ty) => base.place_field(fx, field),\n+        ProjectionElem::Index(local) => {\n+            let index = fx.get_local_place(local).to_cvalue(fx).load_scalar(fx);\n+            base.place_index(fx, index)\n+        }\n+        ProjectionElem::ConstantIndex {\n+            offset,\n+            min_length: _,\n+            from_end,\n+        } => {\n+            let index = if !from_end {\n+                fx.bcx.ins().iconst(fx.pointer_type, offset as i64)\n+            } else {\n+                let len = codegen_array_len(fx, base);\n+                fx.bcx.ins().iadd_imm(len, -(offset as i64))\n+            };\n+            base.place_index(fx, index)\n+        }\n+        ProjectionElem::Subslice { from, to } => {\n+            // These indices are generated by slice patterns.\n+            // slice[from:-to] in Python terms.\n+\n+            match base.layout().ty.sty {\n+                ty::Array(elem_ty, len) => {\n+                    let elem_layout = fx.layout_of(elem_ty);\n+                    let ptr = base.to_addr(fx);\n+                    let len = crate::constant::force_eval_const(fx, len).unwrap_usize(fx.tcx);\n+                    CPlace::for_addr(\n+                        fx.bcx.ins().iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                        fx.layout_of(fx.tcx.mk_array(elem_ty, len - from as u64 - to as u64)),\n+                    )\n                 }\n-                ProjectionElem::Subslice { from, to } => {\n-                    // These indices are generated by slice patterns.\n-                    // slice[from:-to] in Python terms.\n-\n-                    match base.layout().ty.sty {\n-                        ty::Array(elem_ty, len) => {\n-                            let elem_layout = fx.layout_of(elem_ty);\n-                            let ptr = base.to_addr(fx);\n-                            let len = crate::constant::force_eval_const(fx, len).unwrap_usize(fx.tcx);\n-                            CPlace::for_addr(\n-                                fx.bcx.ins().iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n-                                fx.layout_of(fx.tcx.mk_array(elem_ty, len - from as u64 - to as u64)),\n-                            )\n-                        }\n-                        ty::Slice(elem_ty) => {\n-                            let elem_layout = fx.layout_of(elem_ty);\n-                            let (ptr, len) = base.to_addr_maybe_unsized(fx);\n-                            let len = len.unwrap();\n-                            CPlace::for_addr_with_extra(\n-                                fx.bcx.ins().iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n-                                fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n-                                base.layout(),\n-                            )\n-                        }\n-                        _ => unreachable!(),\n-                    }\n+                ty::Slice(elem_ty) => {\n+                    let elem_layout = fx.layout_of(elem_ty);\n+                    let (ptr, len) = base.to_addr_maybe_unsized(fx);\n+                    let len = len.unwrap();\n+                    CPlace::for_addr_with_extra(\n+                        fx.bcx.ins().iadd_imm(ptr, elem_layout.size.bytes() as i64 * from as i64),\n+                        fx.bcx.ins().iadd_imm(len, -(from as i64 + to as i64)),\n+                        base.layout(),\n+                    )\n                 }\n-                ProjectionElem::Downcast(_adt_def, variant) => base.downcast_variant(fx, variant),\n+                _ => unreachable!(),\n             }\n         }\n+        ProjectionElem::Downcast(_adt_def, variant) => base.downcast_variant(fx, variant),\n     }\n }\n "}]}