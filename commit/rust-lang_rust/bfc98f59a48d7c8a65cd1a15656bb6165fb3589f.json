{"sha": "bfc98f59a48d7c8a65cd1a15656bb6165fb3589f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYzk4ZjU5YTQ4ZDdjOGE2NWNkMWExNTY1NmJiNjE2NWZiMzU4OWY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-01T20:43:48Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:22:47Z"}, "message": "Refactor away `module.resolve_name()`.", "tree": {"sha": "028642028ed8e70f1da728ac80e0abecb62f18f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/028642028ed8e70f1da728ac80e0abecb62f18f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f", "html_url": "https://github.com/rust-lang/rust/commit/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89de52eff08d7416b9fd4ab0adc2e818590e84d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/89de52eff08d7416b9fd4ab0adc2e818590e84d0", "html_url": "https://github.com/rust-lang/rust/commit/89de52eff08d7416b9fd4ab0adc2e818590e84d0"}], "stats": {"total": 152, "additions": 75, "deletions": 77}, "files": [{"sha": "71dee48f3396d82ed7961fdfa4d12b8a232f4d94", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bfc98f59a48d7c8a65cd1a15656bb6165fb3589f", "patch": "@@ -1250,12 +1250,13 @@ impl<'a> Resolver<'a> {\n                                      index: usize,\n                                      span: Span)\n                                      -> ResolveResult<Module<'a>> {\n-        fn search_parent_externals(needle: Name, module: Module) -> Option<Module> {\n-            match module.resolve_name(needle, TypeNS, false) {\n+        fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n+                                       -> Option<Module<'a>> {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, false) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n-                        search_parent_externals(needle, parent)\n+                        search_parent_externals(this, needle, parent)\n                     }\n                     _ => None,\n                 },\n@@ -1275,11 +1276,12 @@ impl<'a> Resolver<'a> {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let msg = if \"???\" == &module_name {\n-                        match search_parent_externals(name, &self.current_module) {\n+                        let current_module = self.current_module;\n+                        match search_parent_externals(self, name, current_module) {\n                             Some(module) => {\n                                 let path_str = names_to_string(module_path);\n                                 let target_mod_str = module_to_string(&module);\n-                                let current_mod_str = module_to_string(&self.current_module);\n+                                let current_mod_str = module_to_string(current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -1436,8 +1438,8 @@ impl<'a> Resolver<'a> {\n                 if module.def.is_some() {\n                     return match self.prelude {\n                         Some(prelude) if !module.no_implicit_prelude.get() => {\n-                            prelude.resolve_name(name, ns, false).success()\n-                                   .map(LexicalScopeBinding::Item)\n+                            self.resolve_name_in_module(prelude, name, ns, false, false).success()\n+                                .map(LexicalScopeBinding::Item)\n                         }\n                         _ => None,\n                     };\n@@ -1523,27 +1525,6 @@ impl<'a> Resolver<'a> {\n         return Success(PrefixFound(containing_module, i));\n     }\n \n-    /// Attempts to resolve the supplied name in the given module for the\n-    /// given namespace. If successful, returns the binding corresponding to\n-    /// the name.\n-    fn resolve_name_in_module(&mut self,\n-                              module: Module<'a>,\n-                              name: Name,\n-                              namespace: Namespace,\n-                              use_lexical_scope: bool,\n-                              record_used: bool)\n-                              -> ResolveResult<&'a NameBinding<'a>> {\n-        debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n-\n-        self.populate_module_if_necessary(module);\n-        module.resolve_name(name, namespace, use_lexical_scope).and_then(|binding| {\n-            if record_used {\n-                self.record_use(name, namespace, binding);\n-            }\n-            Success(binding)\n-        })\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs."}, {"sha": "0905632d4e6273ace97233dd692ae824534f8793", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 66, "deletions": 49, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc98f59a48d7c8a65cd1a15656bb6165fb3589f/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=bfc98f59a48d7c8a65cd1a15656bb6165fb3589f", "patch": "@@ -133,27 +133,85 @@ impl<'a> NameResolution<'a> {\n             _ => None, // The binding could be shadowed by a single import, so it is not known.\n         })\n     }\n+}\n+\n+impl<'a> ::ModuleS<'a> {\n+    fn resolution(&self, name: Name, ns: Namespace) -> &'a RefCell<NameResolution<'a>> {\n+        *self.resolutions.borrow_mut().entry((name, ns))\n+             .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    /// Attempts to resolve the supplied name in the given module for the given namespace.\n+    /// If successful, returns the binding corresponding to the name.\n+    pub fn resolve_name_in_module(&mut self,\n+                                  module: Module<'a>,\n+                                  name: Name,\n+                                  ns: Namespace,\n+                                  allow_private_imports: bool,\n+                                  record_used: bool)\n+                                  -> ResolveResult<&'a NameBinding<'a>> {\n+        self.populate_module_if_necessary(module);\n+\n+        let resolution = module.resolution(name, ns);\n+        let resolution = match resolution.borrow_state() {\n+            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n+            _ => return Failed(None), // This happens when there is a cycle of imports\n+        };\n+\n+        if let Some(result) = self.try_result(&resolution, ns, allow_private_imports) {\n+            // If the resolution doesn't depend on glob definability, check privacy and return.\n+            return result.and_then(|binding| {\n+                if !allow_private_imports && binding.is_import() && !binding.is_pseudo_public() {\n+                    return Failed(None);\n+                }\n+                if record_used {\n+                    self.record_use(name, ns, binding);\n+                }\n+                Success(binding)\n+            });\n+        }\n+\n+        // Check if the globs are determined\n+        for directive in module.globs.borrow().iter() {\n+            if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n+            if let Some(target_module) = directive.target_module.get() {\n+                let result = self.resolve_name_in_module(target_module, name, ns, false, false);\n+                if let Indeterminate = result {\n+                    return Indeterminate;\n+                }\n+            } else {\n+                return Indeterminate;\n+            }\n+        }\n+\n+        Failed(None)\n+    }\n \n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n-    fn try_result(&self, ns: Namespace, allow_private_imports: bool)\n+    fn try_result(&mut self,\n+                  resolution: &NameResolution<'a>,\n+                  ns: Namespace,\n+                  allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n-        match self.binding {\n+        match resolution.binding {\n             Some(binding) if !binding.is_glob_import() =>\n-                return Some(Success(binding)),\n-            _ => {} // Items and single imports are not shadowable\n+                return Some(Success(binding)), // Items and single imports are not shadowable.\n+            _ => {}\n         };\n \n         // Check if a single import can still define the name.\n-        match self.single_imports {\n+        match resolution.single_imports {\n             SingleImports::None => {},\n             SingleImports::AtLeastOne => return Some(Indeterminate),\n             SingleImports::MaybeOne(directive) => {\n                 // If (1) we don't allow private imports, (2) no public single import can define\n                 // the name, and (3) no public glob has defined the name, the resolution depends\n                 // on whether more globs can define the name.\n                 if !allow_private_imports && directive.vis != ty::Visibility::Public &&\n-                   !self.binding.map(NameBinding::is_pseudo_public).unwrap_or(false) {\n+                   !resolution.binding.map(NameBinding::is_pseudo_public).unwrap_or(false) {\n                     return None;\n                 }\n \n@@ -165,57 +223,16 @@ impl<'a> NameResolution<'a> {\n                     SingleImport { source, .. } => source,\n                     GlobImport { .. } => unreachable!(),\n                 };\n-                match target_module.resolve_name(name, ns, false) {\n+                match self.resolve_name_in_module(target_module, name, ns, false, false) {\n                     Failed(_) => {}\n                     _ => return Some(Indeterminate),\n                 }\n             }\n         }\n \n-        self.binding.map(Success)\n-    }\n-}\n-\n-impl<'a> ::ModuleS<'a> {\n-    fn resolution(&self, name: Name, ns: Namespace) -> &'a RefCell<NameResolution<'a>> {\n-        *self.resolutions.borrow_mut().entry((name, ns))\n-             .or_insert_with(|| self.arenas.alloc_name_resolution())\n-    }\n-\n-    pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n-                        -> ResolveResult<&'a NameBinding<'a>> {\n-        let resolution = self.resolution(name, ns);\n-        let resolution = match resolution.borrow_state() {\n-            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n-            _ => return Failed(None), // This happens when there is a cycle of imports\n-        };\n-\n-        if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n-            // If the resolution doesn't depend on glob definability, check privacy and return.\n-            return result.and_then(|binding| {\n-                let allowed = allow_private_imports || !binding.is_import() ||\n-                                                       binding.is_pseudo_public();\n-                if allowed { Success(binding) } else { Failed(None) }\n-            });\n-        }\n-\n-        // Check if the globs are determined\n-        for directive in self.globs.borrow().iter() {\n-            if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n-            match directive.target_module.get() {\n-                None => return Indeterminate,\n-                Some(target_module) => match target_module.resolve_name(name, ns, false) {\n-                    Indeterminate => return Indeterminate,\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        Failed(None)\n+        resolution.binding.map(Success)\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     // Add an import directive to the current module.\n     pub fn add_import_directive(&mut self,\n                                 module_path: Vec<Name>,"}]}