{"sha": "c8a0b0eece9e3ac852413bc715f788261a217e74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTBiMGVlY2U5ZTNhYzg1MjQxM2JjNzE1Zjc4ODI2MWEyMTdlNzQ=", "commit": {"author": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2015-06-15T16:28:14Z"}, "committer": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2015-06-20T01:08:20Z"}, "message": "Handle error case safely with a fallback", "tree": {"sha": "0aadf3a632ee15b175479b968ded915c51f7e7f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0aadf3a632ee15b175479b968ded915c51f7e7f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a0b0eece9e3ac852413bc715f788261a217e74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a0b0eece9e3ac852413bc715f788261a217e74", "html_url": "https://github.com/rust-lang/rust/commit/c8a0b0eece9e3ac852413bc715f788261a217e74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a0b0eece9e3ac852413bc715f788261a217e74/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0230a530ce54102325537dc63dcabc45f5935771", "url": "https://api.github.com/repos/rust-lang/rust/commits/0230a530ce54102325537dc63dcabc45f5935771", "html_url": "https://github.com/rust-lang/rust/commit/0230a530ce54102325537dc63dcabc45f5935771"}], "stats": {"total": 55, "additions": 32, "deletions": 23}, "files": [{"sha": "2abb53e55f64b48ef09787638d9389af1d014d56", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c8a0b0eece9e3ac852413bc715f788261a217e74/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a0b0eece9e3ac852413bc715f788261a217e74/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c8a0b0eece9e3ac852413bc715f788261a217e74", "patch": "@@ -73,33 +73,42 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                         // snippet\n                     };\n \n-                    // Determine if the field can be used as a function in some way\n-                    let fn_once_trait_did = match cx.lang_items.require(FnOnceTraitLangItem) {\n-                        Ok(trait_did) => trait_did,\n-                        Err(err) => cx.sess.fatal(&err[..])\n-                    };\n+                    fn span_stored_function() {\n+                        cx.sess.span_note(span, &format!(\"use `({0}.{1})(...)` if you meant to call \\\n+                                                          the function stored in the `{1}` field\",\n+                                                         expr_string, item_name));\n+                    }\n \n-                    let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n-                    let field_ty_substs = Substs::new_trait(vec![fcx.inh.infcx.next_ty_var()],\n-                                                            Vec::new(),\n-                                                            field_ty);\n-                    let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n-                                                      cx.mk_substs(field_ty_substs));\n-                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                    let obligation = Obligation::misc(span,\n-                                                      fcx.body_id,\n-                                                      poly_trait_ref.as_predicate());\n-                    let mut selcx = SelectionContext::new(fcx.infcx(), fcx);\n-\n-                    if selcx.evaluate_obligation(&obligation) {\n-                        cx.sess.span_note(span,\n-                            &format!(\"use `({0}.{1})(...)` if you meant to call the \\\n-                                      function stored in the `{1}` field\",\n-                                expr_string, item_name));\n-                    } else {\n+                    fn span_did_you_mean() {\n                         cx.sess.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n                                                          expr_string, item_name));\n                     }\n+\n+                    // Determine if the field can be used as a function in some way\n+                    let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n+                    if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n+                        let fn_once_substs = Substs::new_trait(vec![fcx.inh.infcx.next_ty_var()],\n+                                                               Vec::new(),\n+                                                               field_ty);\n+                        let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n+                                                          cx.mk_substs(fn_once_substs));\n+                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                        let obligation = Obligation::misc(span,\n+                                                          fcx.body_id,\n+                                                          poly_trait_ref.as_predicate());\n+                        let mut selcx = SelectionContext::new(fcx.infcx(), fcx);\n+\n+                        if selcx.evaluate_obligation(&obligation) {\n+                            span_stored_function();\n+                        } else {\n+                            span_did_you_mean();\n+                        }\n+                    } else {\n+                        match field_ty.sty {\n+                            ty::TyClosure(_,_) | ty::TyFnPtr(_,_) => span_stored_function(),\n+                            _ => span_did_you_mean(),\n+                        }\n+                    }\n                 }\n             }\n "}]}