{"sha": "a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "node_id": "C_kwDOAAsO6NoAKGE1MmM3OWU4NTkxNDJjMWNkNWMwYzViZGI3M2YxNmI3NTRlMWI5OGY", "commit": {"author": {"name": "Rain", "email": "rain@sunshowers.io", "date": "2022-09-23T05:48:14Z"}, "committer": {"name": "Rain", "email": "rain@sunshowers.io", "date": "2022-10-20T21:53:38Z"}, "message": "Change process spawning to inherit the parent's signal mask by default\n\nPreviously, the signal mask is always reset when a child process is\nstarted. This breaks tools like `nohup` which expect `SIGHUP` to be\nblocked.\n\nWith this change, the default behavior changes to inherit the signal mask.\n\nThis also changes the signal disposition for `SIGPIPE` to only be\nchanged if the `#[unix_sigpipe]` attribute isn't set.", "tree": {"sha": "ac8aea871f084c1521a9ee86c6adc3cf19313967", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac8aea871f084c1521a9ee86c6adc3cf19313967"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "html_url": "https://github.com/rust-lang/rust/commit/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/comments", "author": {"login": "sunshowers", "id": 180618, "node_id": "MDQ6VXNlcjE4MDYxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/180618?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunshowers", "html_url": "https://github.com/sunshowers", "followers_url": "https://api.github.com/users/sunshowers/followers", "following_url": "https://api.github.com/users/sunshowers/following{/other_user}", "gists_url": "https://api.github.com/users/sunshowers/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunshowers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunshowers/subscriptions", "organizations_url": "https://api.github.com/users/sunshowers/orgs", "repos_url": "https://api.github.com/users/sunshowers/repos", "events_url": "https://api.github.com/users/sunshowers/events{/privacy}", "received_events_url": "https://api.github.com/users/sunshowers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sunshowers", "id": 180618, "node_id": "MDQ6VXNlcjE4MDYxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/180618?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sunshowers", "html_url": "https://github.com/sunshowers", "followers_url": "https://api.github.com/users/sunshowers/followers", "following_url": "https://api.github.com/users/sunshowers/following{/other_user}", "gists_url": "https://api.github.com/users/sunshowers/gists{/gist_id}", "starred_url": "https://api.github.com/users/sunshowers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sunshowers/subscriptions", "organizations_url": "https://api.github.com/users/sunshowers/orgs", "repos_url": "https://api.github.com/users/sunshowers/repos", "events_url": "https://api.github.com/users/sunshowers/events{/privacy}", "received_events_url": "https://api.github.com/users/sunshowers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "542febd2d383b5082277c7d165b098c0a3b513f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/542febd2d383b5082277c7d165b098c0a3b513f6", "html_url": "https://github.com/rust-lang/rust/commit/542febd2d383b5082277c7d165b098c0a3b513f6"}], "stats": {"total": 222, "additions": 143, "deletions": 79}, "files": [{"sha": "53692ad7cc92b8d56ffc5a88a955ddbc6e283a02", "filename": "compiler/rustc_session/src/config/sigpipe.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/compiler%2Frustc_session%2Fsrc%2Fconfig%2Fsigpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/compiler%2Frustc_session%2Fsrc%2Fconfig%2Fsigpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig%2Fsigpipe.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -1,5 +1,13 @@\n //! NOTE: Keep these constants in sync with `library/std/src/sys/unix/mod.rs`!\n \n+/// The default value if `#[unix_sigpipe]` is not specified. This resolves\n+/// to `SIG_IGN` in `library/std/src/sys/unix/mod.rs`.\n+///\n+/// Note that `SIG_IGN` has been the Rust default since 2014. See\n+/// <https://github.com/rust-lang/rust/issues/62569>.\n+#[allow(dead_code)]\n+pub const DEFAULT: u8 = 0;\n+\n /// Do not touch `SIGPIPE`. Use whatever the parent process uses.\n #[allow(dead_code)]\n pub const INHERIT: u8 = 1;\n@@ -15,8 +23,3 @@ pub const SIG_IGN: u8 = 2;\n /// such as `head -n 1`.\n #[allow(dead_code)]\n pub const SIG_DFL: u8 = 3;\n-\n-/// `SIG_IGN` has been the Rust default since 2014. See\n-/// <https://github.com/rust-lang/rust/issues/62569>.\n-#[allow(dead_code)]\n-pub const DEFAULT: u8 = SIG_IGN;"}, {"sha": "9c2f0c1dd3eb669fe04fd01c604363bae111ac38", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -89,7 +89,7 @@ macro_rules! rtunwrap {\n // `src/tools/tidy/src/pal.rs` for more info. On all other platforms, `sigpipe`\n // has a value, but its value is ignored.\n //\n-// Even though it is an `u8`, it only ever has 3 values. These are documented in\n+// Even though it is an `u8`, it only ever has 4 values. These are documented in\n // `compiler/rustc_session/src/config/sigpipe.rs`.\n #[cfg_attr(test, allow(dead_code))]\n unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {"}, {"sha": "4a9f356b63cc1f6ee450b5b9e0935a11066404c8", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -163,24 +163,54 @@ pub unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) {\n             // See the other file for docs. NOTE: Make sure to keep them in\n             // sync!\n             mod sigpipe {\n+                pub const DEFAULT: u8 = 0;\n                 pub const INHERIT: u8 = 1;\n                 pub const SIG_IGN: u8 = 2;\n                 pub const SIG_DFL: u8 = 3;\n             }\n \n-            let handler = match sigpipe {\n-                sigpipe::INHERIT => None,\n-                sigpipe::SIG_IGN => Some(libc::SIG_IGN),\n-                sigpipe::SIG_DFL => Some(libc::SIG_DFL),\n+            let (sigpipe_attr_specified, handler) = match sigpipe {\n+                sigpipe::DEFAULT => (false, Some(libc::SIG_IGN)),\n+                sigpipe::INHERIT => (true, None),\n+                sigpipe::SIG_IGN => (true, Some(libc::SIG_IGN)),\n+                sigpipe::SIG_DFL => (true, Some(libc::SIG_DFL)),\n                 _ => unreachable!(),\n             };\n+            // The bootstrap compiler doesn't know about sigpipe::DEFAULT, and always passes in\n+            // SIG_IGN. This causes some tests to fail because they expect SIGPIPE to be reset to\n+            // default on process spawning (which doesn't happen if #[unix_sigpipe] is specified).\n+            // Since we can't differentiate between the cases here, treat SIG_IGN as DEFAULT\n+            // unconditionally.\n+            if sigpipe_attr_specified && !(cfg!(bootstrap) && sigpipe == sigpipe::SIG_IGN) {\n+                UNIX_SIGPIPE_ATTR_SPECIFIED.store(true, crate::sync::atomic::Ordering::Relaxed);\n+            }\n             if let Some(handler) = handler {\n                 rtassert!(signal(libc::SIGPIPE, handler) != libc::SIG_ERR);\n             }\n         }\n     }\n }\n \n+// This is set (up to once) in reset_sigpipe.\n+#[cfg(not(any(\n+    target_os = \"espidf\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_os = \"horizon\"\n+)))]\n+static UNIX_SIGPIPE_ATTR_SPECIFIED: crate::sync::atomic::AtomicBool =\n+    crate::sync::atomic::AtomicBool::new(false);\n+\n+#[cfg(not(any(\n+    target_os = \"espidf\",\n+    target_os = \"emscripten\",\n+    target_os = \"fuchsia\",\n+    target_os = \"horizon\"\n+)))]\n+pub(crate) fn unix_sigpipe_attr_specified() -> bool {\n+    UNIX_SIGPIPE_ATTR_SPECIFIED.load(crate::sync::atomic::Ordering::Relaxed)\n+}\n+\n // SAFETY: must be called only once during runtime cleanup.\n // NOTE: this is not guaranteed to run, for example when the program aborts.\n pub unsafe fn cleanup() {"}, {"sha": "848adca78c076f99fdec48c553410fe7a753c549", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -39,10 +39,12 @@ cfg_if::cfg_if! {\n // https://github.com/aosp-mirror/platform_bionic/blob/ad8dcd6023294b646e5a8288c0ed431b0845da49/libc/include/android/legacy_signal_inlines.h\n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"android\")] {\n+        #[allow(dead_code)]\n         pub unsafe fn sigemptyset(set: *mut libc::sigset_t) -> libc::c_int {\n             set.write_bytes(0u8, 1);\n             return 0;\n         }\n+\n         #[allow(dead_code)]\n         pub unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n             use crate::{"}, {"sha": "03631e4e33bf5d073993cfc15ecfdb86cc7fac43", "filename": "library/std/src/sys/unix/process/process_common/tests.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -31,41 +31,54 @@ macro_rules! t {\n     ignore\n )]\n fn test_process_mask() {\n-    unsafe {\n-        // Test to make sure that a signal mask does not get inherited.\n-        let mut cmd = Command::new(OsStr::new(\"cat\"));\n-\n-        let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n-        let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n-        t!(cvt(sigemptyset(set.as_mut_ptr())));\n-        t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n-        t!(cvt_nz(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), old_set.as_mut_ptr())));\n-\n-        cmd.stdin(Stdio::MakePipe);\n-        cmd.stdout(Stdio::MakePipe);\n-\n-        let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n-        let stdin_write = pipes.stdin.take().unwrap();\n-        let stdout_read = pipes.stdout.take().unwrap();\n-\n-        t!(cvt_nz(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n-\n-        t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n-        // We need to wait until SIGINT is definitely delivered. The\n-        // easiest way is to write something to cat, and try to read it\n-        // back: if SIGINT is unmasked, it'll get delivered when cat is\n-        // next scheduled.\n-        let _ = stdin_write.write(b\"Hello\");\n-        drop(stdin_write);\n-\n-        // Either EOF or failure (EPIPE) is okay.\n-        let mut buf = [0; 5];\n-        if let Ok(ret) = stdout_read.read(&mut buf) {\n-            assert_eq!(ret, 0);\n+    // Test to make sure that a signal mask *does* get inherited.\n+    fn test_inner(mut cmd: Command) {\n+        unsafe {\n+            let mut set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            let mut old_set = mem::MaybeUninit::<libc::sigset_t>::uninit();\n+            t!(cvt(sigemptyset(set.as_mut_ptr())));\n+            t!(cvt(sigaddset(set.as_mut_ptr(), libc::SIGINT)));\n+            t!(cvt_nz(libc::pthread_sigmask(\n+                libc::SIG_SETMASK,\n+                set.as_ptr(),\n+                old_set.as_mut_ptr()\n+            )));\n+\n+            cmd.stdin(Stdio::MakePipe);\n+            cmd.stdout(Stdio::MakePipe);\n+\n+            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n+            let stdin_write = pipes.stdin.take().unwrap();\n+            let stdout_read = pipes.stdout.take().unwrap();\n+\n+            t!(cvt_nz(libc::pthread_sigmask(libc::SIG_SETMASK, old_set.as_ptr(), ptr::null_mut())));\n+\n+            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n+            // We need to wait until SIGINT is definitely delivered. The\n+            // easiest way is to write something to cat, and try to read it\n+            // back: if SIGINT is unmasked, it'll get delivered when cat is\n+            // next scheduled.\n+            let _ = stdin_write.write(b\"Hello\");\n+            drop(stdin_write);\n+\n+            // Exactly 5 bytes should be read.\n+            let mut buf = [0; 5];\n+            let ret = t!(stdout_read.read(&mut buf));\n+            assert_eq!(ret, 5);\n+            assert_eq!(&buf, b\"Hello\");\n+\n+            t!(cat.wait());\n         }\n-\n-        t!(cat.wait());\n     }\n+\n+    // A plain `Command::new` uses the posix_spawn path on many platforms.\n+    let cmd = Command::new(OsStr::new(\"cat\"));\n+    test_inner(cmd);\n+\n+    // Specifying `pre_exec` forces the fork/exec path.\n+    let mut cmd = Command::new(OsStr::new(\"cat\"));\n+    unsafe { cmd.pre_exec(Box::new(|| Ok(()))) };\n+    test_inner(cmd);\n }\n \n #[test]"}, {"sha": "56a805cef7318fe8e6ed00f57997d90647a03b22", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -2,7 +2,6 @@ use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n use crate::num::NonZeroI32;\n-use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n@@ -310,7 +309,7 @@ impl Command {\n                 //FIXME: Redox kernel does not support setgroups yet\n                 #[cfg(not(target_os = \"redox\"))]\n                 if libc::getuid() == 0 && self.get_groups().is_none() {\n-                    cvt(libc::setgroups(0, ptr::null()))?;\n+                    cvt(libc::setgroups(0, crate::ptr::null()))?;\n                 }\n                 cvt(libc::setuid(u as uid_t))?;\n             }\n@@ -326,30 +325,26 @@ impl Command {\n         // emscripten has no signal support.\n         #[cfg(not(target_os = \"emscripten\"))]\n         {\n-            use crate::mem::MaybeUninit;\n-            use crate::sys::cvt_nz;\n-            // Reset signal handling so the child process starts in a\n-            // standardized state. libstd ignores SIGPIPE, and signal-handling\n-            // libraries often set a mask. Child processes inherit ignored\n-            // signals and the signal mask from their parent, but most\n-            // UNIX programs do not reset these things on their own, so we\n-            // need to clean things up now to avoid confusing the program\n-            // we're about to run.\n-            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            cvt(sigemptyset(set.as_mut_ptr()))?;\n-            cvt_nz(libc::pthread_sigmask(libc::SIG_SETMASK, set.as_ptr(), ptr::null_mut()))?;\n-\n-            #[cfg(target_os = \"android\")] // see issue #88585\n-            {\n-                let mut action: libc::sigaction = mem::zeroed();\n-                action.sa_sigaction = libc::SIG_DFL;\n-                cvt(libc::sigaction(libc::SIGPIPE, &action, ptr::null_mut()))?;\n-            }\n-            #[cfg(not(target_os = \"android\"))]\n-            {\n-                let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n-                if ret == libc::SIG_ERR {\n-                    return Err(io::Error::last_os_error());\n+            // Inherit the signal mask from the parent rather than resetting it (i.e. do not call\n+            // pthread_sigmask).\n+\n+            // If #[unix_sigpipe] is specified, don't reset SIGPIPE to SIG_DFL.\n+            // If #[unix_sigpipe] is not specified, reset SIGPIPE to SIG_DFL for backward compatibility.\n+            //\n+            // #[unix_sigpipe] is an opportunity to change the default here.\n+            if !crate::sys::unix_sigpipe_attr_specified() {\n+                #[cfg(target_os = \"android\")] // see issue #88585\n+                {\n+                    let mut action: libc::sigaction = mem::zeroed();\n+                    action.sa_sigaction = libc::SIG_DFL;\n+                    cvt(libc::sigaction(libc::SIGPIPE, &action, crate::ptr::null_mut()))?;\n+                }\n+                #[cfg(not(target_os = \"android\"))]\n+                {\n+                    let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n+                    if ret == libc::SIG_ERR {\n+                        return Err(io::Error::last_os_error());\n+                    }\n                 }\n             }\n         }\n@@ -411,7 +406,7 @@ impl Command {\n         envp: Option<&CStringArray>,\n     ) -> io::Result<Option<Process>> {\n         use crate::mem::MaybeUninit;\n-        use crate::sys::{self, cvt_nz};\n+        use crate::sys::{self, cvt_nz, unix_sigpipe_attr_specified};\n \n         if self.get_gid().is_some()\n             || self.get_uid().is_some()\n@@ -531,13 +526,24 @@ impl Command {\n                 cvt_nz(libc::posix_spawnattr_setpgroup(attrs.0.as_mut_ptr(), pgroup))?;\n             }\n \n-            let mut set = MaybeUninit::<libc::sigset_t>::uninit();\n-            cvt(sigemptyset(set.as_mut_ptr()))?;\n-            cvt_nz(libc::posix_spawnattr_setsigmask(attrs.0.as_mut_ptr(), set.as_ptr()))?;\n-            cvt(sigaddset(set.as_mut_ptr(), libc::SIGPIPE))?;\n-            cvt_nz(libc::posix_spawnattr_setsigdefault(attrs.0.as_mut_ptr(), set.as_ptr()))?;\n+            // Inherit the signal mask from this process rather than resetting it (i.e. do not call\n+            // posix_spawnattr_setsigmask).\n+\n+            // If #[unix_sigpipe] is specified, don't reset SIGPIPE to SIG_DFL.\n+            // If #[unix_sigpipe] is not specified, reset SIGPIPE to SIG_DFL for backward compatibility.\n+            //\n+            // #[unix_sigpipe] is an opportunity to change the default here.\n+            if !unix_sigpipe_attr_specified() {\n+                let mut default_set = MaybeUninit::<libc::sigset_t>::uninit();\n+                cvt(sigemptyset(default_set.as_mut_ptr()))?;\n+                cvt(sigaddset(default_set.as_mut_ptr(), libc::SIGPIPE))?;\n+                cvt_nz(libc::posix_spawnattr_setsigdefault(\n+                    attrs.0.as_mut_ptr(),\n+                    default_set.as_ptr(),\n+                ))?;\n+                flags |= libc::POSIX_SPAWN_SETSIGDEF;\n+            }\n \n-            flags |= libc::POSIX_SPAWN_SETSIGDEF | libc::POSIX_SPAWN_SETSIGMASK;\n             cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n \n             // Make sure we synchronize access to the global `environ` resource"}, {"sha": "7ed6a7de895c11edca78401ca12c9a79dbfa384d", "filename": "src/doc/unstable-book/src/language-features/unix-sigpipe.md", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funix-sigpipe.md", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funix-sigpipe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funix-sigpipe.md?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -36,7 +36,7 @@ hello world\n \n Set the `SIGPIPE` handler to `SIG_IGN` before invoking `fn main()`. This will result in `ErrorKind::BrokenPipe` errors if you program tries to write to a closed pipe. This is normally what you want if you for example write socket servers, socket clients, or pipe peers.\n \n-This is what libstd has done by default since 2014. Omitting `#[unix_sigpipe = \"...\"]` is the same as having `#[unix_sigpipe = \"sig_ign\"]`.\n+This is what libstd has done by default since 2014. (However, see the note on child processes below.)\n \n ### Example\n \n@@ -52,3 +52,11 @@ hello world\n thread 'main' panicked at 'failed printing to stdout: Broken pipe (os error 32)', library/std/src/io/stdio.rs:1016:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n ```\n+\n+### Note on child processes\n+\n+When spawning child processes, the legacy Rust behavior if `#[unix_sigpipe]` is not specified is to\n+reset `SIGPIPE` to `SIG_DFL`.\n+\n+If `#[unix_sigpipe = \"...\"]` is specified, no matter what its value is, the signal disposition of\n+`SIGPIPE` is no longer reset. This means that the child inherits the parent's `SIGPIPE` behavior."}, {"sha": "74fbae0350e483f55e56b20c6daea786364fba3a", "filename": "src/test/ui/attributes/unix_sigpipe/auxiliary/sigpipe-utils.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/src%2Ftest%2Fui%2Fattributes%2Funix_sigpipe%2Fauxiliary%2Fsigpipe-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a52c79e859142c1cd5c0c5bdb73f16b754e1b98f/src%2Ftest%2Fui%2Fattributes%2Funix_sigpipe%2Fauxiliary%2Fsigpipe-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Funix_sigpipe%2Fauxiliary%2Fsigpipe-utils.rs?ref=a52c79e859142c1cd5c0c5bdb73f16b754e1b98f", "patch": "@@ -23,9 +23,11 @@ pub fn assert_sigpipe_handler(expected_handler: SignalHandler) {\n             SignalHandler::Ignore => libc::SIG_IGN,\n             SignalHandler::Default => libc::SIG_DFL,\n         };\n-        assert_eq!(prev, expected);\n+        assert_eq!(prev, expected, \"expected sigpipe value matches actual value\");\n \n         // Unlikely to matter, but restore the old value anyway\n-        unsafe { libc::signal(libc::SIGPIPE, prev); };\n+        unsafe {\n+            libc::signal(libc::SIGPIPE, prev);\n+        };\n     }\n }"}]}