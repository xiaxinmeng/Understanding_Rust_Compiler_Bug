{"sha": "9a4daffe16f81e154b542a195fdf81463e5212bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNGRhZmZlMTZmODFlMTU0YjU0MmExOTVmZGY4MTQ2M2U1MjEyYmI=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-01T13:25:26Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2020-12-07T21:41:08Z"}, "message": "Resolve import inserts better", "tree": {"sha": "12ae871613ee93e2032c8f4d44bca706e1c97a70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12ae871613ee93e2032c8f4d44bca706e1c97a70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a4daffe16f81e154b542a195fdf81463e5212bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4daffe16f81e154b542a195fdf81463e5212bb", "html_url": "https://github.com/rust-lang/rust/commit/9a4daffe16f81e154b542a195fdf81463e5212bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a4daffe16f81e154b542a195fdf81463e5212bb/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a539267c3b18ff3b58d9e33105fcae27a35316c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a539267c3b18ff3b58d9e33105fcae27a35316c5", "html_url": "https://github.com/rust-lang/rust/commit/a539267c3b18ff3b58d9e33105fcae27a35316c5"}], "stats": {"total": 129, "additions": 91, "deletions": 38}, "files": [{"sha": "ba4bf2eeb9bdb435ae490398330f909e3015a352", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4daffe16f81e154b542a195fdf81463e5212bb/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4daffe16f81e154b542a195fdf81463e5212bb/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=9a4daffe16f81e154b542a195fdf81463e5212bb", "patch": "@@ -69,7 +69,7 @@ pub(crate) struct GlobalState {\n     pub(crate) config: Config,\n     pub(crate) analysis_host: AnalysisHost,\n     pub(crate) diagnostics: DiagnosticCollection,\n-    pub(crate) additional_imports: FxHashMap<String, ImportToAdd>,\n+    pub(crate) additional_imports: FxHashMap<usize, ImportToAdd>,\n     pub(crate) mem_docs: FxHashMap<VfsPath, DocumentData>,\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,"}, {"sha": "d9fdf043460fc7baf52fa7596464b3971d5da33b", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 90, "deletions": 37, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9a4daffe16f81e154b542a195fdf81463e5212bb/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4daffe16f81e154b542a195fdf81463e5212bb/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=9a4daffe16f81e154b542a195fdf81463e5212bb", "patch": "@@ -5,11 +5,12 @@\n use std::{\n     io::Write as _,\n     process::{self, Stdio},\n+    sync::Arc,\n };\n \n use ide::{\n-    FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, NavigationTarget, Query,\n-    RangeInfo, Runnable, RunnableKind, SearchScope, TextEdit,\n+    FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, ImportToAdd, LineIndex,\n+    NavigationTarget, Query, RangeInfo, Runnable, RunnableKind, SearchScope, TextEdit,\n };\n use ide_db::helpers::{insert_use, mod_path_to_ast};\n use itertools::Itertools;\n@@ -36,6 +37,7 @@ use crate::{\n     config::RustfmtConfig,\n     from_json, from_proto,\n     global_state::{GlobalState, GlobalStateSnapshot},\n+    line_endings::LineEndings,\n     lsp_ext::{self, InlayHint, InlayHintsParams},\n     to_proto, LspError, Result,\n };\n@@ -536,6 +538,12 @@ pub(crate) fn handle_runnables(\n     Ok(res)\n }\n \n+#[derive(Debug, Copy, Clone, Serialize, Deserialize)]\n+pub(crate) struct ResolveCompletionData {\n+    completion_id: usize,\n+    completion_file_id: u32,\n+}\n+\n pub(crate) fn handle_completion(\n     global_state: &mut GlobalState,\n     params: lsp_types::CompletionParams,\n@@ -575,20 +583,31 @@ pub(crate) fn handle_completion(\n \n     let items: Vec<CompletionItem> = items\n         .into_iter()\n-        .flat_map(|item| {\n+        .enumerate()\n+        .flat_map(|(item_index, item)| {\n+            let resolve_completion_data = ResolveCompletionData {\n+                completion_id: item_index,\n+                completion_file_id: position.file_id.0,\n+            };\n             let import_to_add = item.import_to_add().cloned();\n-            let new_completion_items = to_proto::completion_item(&line_index, line_endings, item);\n+            let mut new_completion_items =\n+                to_proto::completion_item(&line_index, line_endings, item);\n+\n             if let Some(import_to_add) = import_to_add {\n-                for new_item in &new_completion_items {\n-                    additional_imports.insert(new_item.label.clone(), import_to_add.clone());\n+                for new_item in &mut new_completion_items {\n+                    match serde_json::to_value(&resolve_completion_data) {\n+                        Ok(resolve_value) => {\n+                            new_item.data = Some(resolve_value);\n+                            additional_imports.insert(item_index, import_to_add.clone());\n+                        }\n+                        Err(e) => {\n+                            log::error!(\"Failed to serialize completion resolve metadata: {}\", e)\n+                        }\n+                    }\n                 }\n             }\n             new_completion_items\n         })\n-        .map(|mut item| {\n-            item.data = Some(position.file_id.0.into());\n-            item\n-        })\n         .collect();\n \n     global_state.additional_imports = additional_imports;\n@@ -601,41 +620,75 @@ pub(crate) fn handle_resolve_completion(\n     global_state: &mut GlobalState,\n     mut original_completion: lsp_types::CompletionItem,\n ) -> Result<lsp_types::CompletionItem> {\n-    // TODO kb slow, takes over 130ms\n     let _p = profile::span(\"handle_resolve_completion\");\n \n-    if let Some(import_data) =\n-        global_state.additional_imports.get(dbg!(original_completion.label.as_str()))\n-    {\n-        let rewriter = insert_use::insert_use(\n-            &import_data.import_scope,\n-            mod_path_to_ast(&import_data.import_path),\n-            import_data.merge_behaviour,\n-        );\n-        if let Some((old_ast, file_id)) =\n-            // TODO kb for file_id, better use &str and then cast to u32?\n-            rewriter\n-            .rewrite_root()\n-            .zip(original_completion.data.as_ref().and_then(|value| Some(value.as_u64()? as u32)))\n-        {\n-            let snap = global_state.snapshot();\n-            let mut import_insert = TextEdit::builder();\n-            algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n-            let line_index = snap.analysis.file_line_index(FileId(file_id))?;\n-            let line_endings = snap.file_line_endings(FileId(file_id));\n-            let text_edit = import_insert.finish();\n-\n-            let mut new_edits = original_completion.additional_text_edits.unwrap_or_default();\n-            for indel in text_edit {\n-                new_edits.push(to_proto::text_edit(&line_index, line_endings, indel));\n+    match original_completion.data.as_ref() {\n+        Some(completion_data) => {\n+            match serde_json::from_value::<ResolveCompletionData>(completion_data.clone()) {\n+                Ok(resolve_completion_data) => {\n+                    if let Some(import_to_add) =\n+                        global_state.additional_imports.get(&resolve_completion_data.completion_id)\n+                    {\n+                        let snap = global_state.snapshot();\n+                        let file_id = FileId(resolve_completion_data.completion_file_id);\n+                        let line_index = snap.analysis.file_line_index(file_id)?;\n+                        let line_endings = snap.file_line_endings(file_id);\n+\n+                        let resolved_edits =\n+                            resolve_additional_edits(import_to_add, line_index, line_endings);\n+\n+                        original_completion.additional_text_edits =\n+                            match original_completion.additional_text_edits {\n+                                Some(mut original_additional_edits) => {\n+                                    if let Some(mut new_edits) = resolved_edits {\n+                                        original_additional_edits.extend(new_edits.drain(..))\n+                                    }\n+                                    Some(original_additional_edits)\n+                                }\n+                                None => resolved_edits,\n+                            };\n+                    } else {\n+                        log::error!(\n+                            \"Got no import data for completion with label {}, id {}\",\n+                            original_completion.label,\n+                            resolve_completion_data.completion_id\n+                        )\n+                    }\n+                }\n+                Err(e) => log::error!(\"Failed to deserialize completion resolve metadata: {}\", e),\n             }\n-            original_completion.additional_text_edits = Some(new_edits);\n         }\n+        None => (),\n     }\n-\n     Ok(original_completion)\n }\n \n+// TODO kb what to do when no resolve is available on the client?\n+fn resolve_additional_edits(\n+    import_to_add: &ImportToAdd,\n+    line_index: Arc<LineIndex>,\n+    line_endings: LineEndings,\n+) -> Option<Vec<lsp_types::TextEdit>> {\n+    let _p = profile::span(\"resolve_additional_edits\");\n+\n+    let rewriter = insert_use::insert_use(\n+        &import_to_add.import_scope,\n+        mod_path_to_ast(&import_to_add.import_path),\n+        import_to_add.merge_behaviour,\n+    );\n+    let old_ast = rewriter.rewrite_root()?;\n+    let mut import_insert = TextEdit::builder();\n+    algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n+    let text_edit = import_insert.finish();\n+\n+    Some(\n+        text_edit\n+            .into_iter()\n+            .map(|indel| to_proto::text_edit(&line_index, line_endings, indel))\n+            .collect_vec(),\n+    )\n+}\n+\n pub(crate) fn handle_folding_range(\n     snap: GlobalStateSnapshot,\n     params: FoldingRangeParams,"}]}