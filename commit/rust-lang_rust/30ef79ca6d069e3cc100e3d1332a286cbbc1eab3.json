{"sha": "30ef79ca6d069e3cc100e3d1332a286cbbc1eab3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZWY3OWNhNmQwNjllM2NjMTAwZTNkMTMzMmEyODZjYmJjMWVhYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-18T06:52:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-18T06:52:40Z"}, "message": "auto merge of #7851 : dotdash/rust/intrinsics, r=pcwalton", "tree": {"sha": "181e00e2df0b8430a72e168828f3bd7e34be93f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/181e00e2df0b8430a72e168828f3bd7e34be93f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3", "html_url": "https://github.com/rust-lang/rust/commit/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d300a64520294eac39a649c276b0b41a62a0fb99", "url": "https://api.github.com/repos/rust-lang/rust/commits/d300a64520294eac39a649c276b0b41a62a0fb99", "html_url": "https://github.com/rust-lang/rust/commit/d300a64520294eac39a649c276b0b41a62a0fb99"}, {"sha": "15ea4a8dd8242a0ee01169872bc538c974e748c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/15ea4a8dd8242a0ee01169872bc538c974e748c9", "html_url": "https://github.com/rust-lang/rust/commit/15ea4a8dd8242a0ee01169872bc538c974e748c9"}], "stats": {"total": 519, "additions": 169, "deletions": 350}, "files": [{"sha": "588b0b5c75f48b1178d5474e5cde7ccd0874a334", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=30ef79ca6d069e3cc100e3d1332a286cbbc1eab3", "patch": "@@ -1612,6 +1612,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n                         output_type: ty::t,\n+                        skip_retptr: bool,\n                         param_substs: Option<@param_substs>,\n                         sp: Option<span>)\n                      -> fn_ctxt {\n@@ -1655,7 +1656,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     fcx.llenv = unsafe {\n           llvm::LLVMGetParam(llfndecl, fcx.env_arg_pos() as c_uint)\n     };\n-    if !ty::type_is_nil(substd_output_type) {\n+    if !ty::type_is_nil(substd_output_type) && !(is_immediate && skip_retptr) {\n         fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n     }\n     fcx\n@@ -1667,7 +1668,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n                    output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, sp)\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, false, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1861,6 +1862,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n                                llfndecl,\n                                id,\n                                output_type,\n+                               false,\n                                param_substs,\n                                Some(body.span));\n     let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n@@ -2079,6 +2081,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n                                llfndecl,\n                                ctor_id,\n                                result_ty,\n+                               false,\n                                param_substs,\n                                None);\n "}, {"sha": "f7d0e71387b4d37ddeae33465609b4b238d3875b", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 164, "deletions": 348, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ef79ca6d069e3cc100e3d1332a286cbbc1eab3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=30ef79ca6d069e3cc100e3d1332a286cbbc1eab3", "patch": "@@ -10,7 +10,7 @@\n \n \n use back::{link, abi};\n-use lib::llvm::{ValueRef};\n+use lib::llvm::{Pointer, ValueRef};\n use lib;\n use middle::trans::base::*;\n use middle::trans::cabi;\n@@ -550,23 +550,85 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n+    fn simple_llvm_intrinsic(bcx: block, name: &'static str, num_args: uint) {\n+        assert!(num_args <= 4);\n+        let mut args = [0 as ValueRef, ..4];\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        for uint::range(0, num_args) |i| {\n+            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n+        }\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Ret(bcx, Call(bcx, llfn, args.slice(0, num_args)));\n+    }\n+\n+    fn memcpy_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n+    }\n+\n+    fn memset_intrinsic(bcx: block, name: &'static str, tp_ty: ty::t, sizebits: u8) {\n+        let ccx = bcx.ccx();\n+        let lltp_ty = type_of::type_of(ccx, tp_ty);\n+        let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n+        let size = match sizebits {\n+            32 => C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32),\n+            64 => C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64),\n+            _ => ccx.sess.fatal(\"Invalid value for sizebits\")\n+        };\n+\n+        let decl = bcx.fcx.llfn;\n+        let first_real_arg = bcx.fcx.arg_pos(0u);\n+        let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n+        let val = get_param(decl, first_real_arg + 1);\n+        let count = get_param(decl, first_real_arg + 2);\n+        let volatile = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n+        RetVoid(bcx);\n+    }\n+\n+    fn count_zeros_intrinsic(bcx: block, name: &'static str) {\n+        let x = get_param(bcx.fcx.llfn, bcx.fcx.arg_pos(0u));\n+        let y = C_i1(false);\n+        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n+        Ret(bcx, Call(bcx, llfn, [x, y]));\n+    }\n+\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n     let fcx = new_fn_ctxt_w_id(ccx,\n                                path,\n                                decl,\n                                item.id,\n                                output_type,\n+                               true,\n                                Some(substs),\n                                Some(item.span));\n \n+    set_always_inline(fcx.llfn);\n+\n     // Set the fixed stack segment flag if necessary.\n     if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n         set_fixed_stack_segment(fcx.llfn);\n     }\n \n     let mut bcx = top_scope_block(fcx, None);\n-    let lltop = bcx.llbb;\n     let first_real_arg = fcx.arg_pos(0u);\n \n     let nm = ccx.sess.str_of(item.ident);\n@@ -595,17 +657,18 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                                         get_param(decl, first_real_arg + 1u),\n                                         get_param(decl, first_real_arg + 2u),\n                                         order);\n-                Store(bcx, old, fcx.llretptr.get());\n+                Ret(bcx, old);\n             }\n             \"load\" => {\n                 let old = AtomicLoad(bcx, get_param(decl, first_real_arg),\n                                      order);\n-                Store(bcx, old, fcx.llretptr.get());\n+                Ret(bcx, old);\n             }\n             \"store\" => {\n                 AtomicStore(bcx, get_param(decl, first_real_arg + 1u),\n                             get_param(decl, first_real_arg),\n                             order);\n+                RetVoid(bcx);\n             }\n             op => {\n                 // These are all AtomicRMW ops\n@@ -627,21 +690,18 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 let old = AtomicRMW(bcx, atom_op, get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     order);\n-                Store(bcx, old, fcx.llretptr.get());\n+                Ret(bcx, old);\n             }\n         }\n \n-        finish_fn(fcx, lltop, bcx);\n-\n         return;\n     }\n \n     match name {\n         \"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)));\n         }\n         \"move_val\" => {\n             // Create a datum reflecting the value being moved.\n@@ -655,6 +715,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n         }\n         \"move_val_init\" => {\n             // See comments for `\"move_val\"`.\n@@ -663,18 +724,17 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n+            RetVoid(bcx);\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)));\n         }\n         \"pref_align_of\"=> {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            Store(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)));\n         }\n         \"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n@@ -687,19 +747,31 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             // the llvm type of intrinsic::TyDesc struct.\n             let userland_tydesc_ty = type_of::type_of(ccx, output_type);\n             let td = PointerCast(bcx, static_ti.tydesc, userland_tydesc_ty);\n-            Store(bcx, td, fcx.llretptr.get());\n+            Ret(bcx, td);\n         }\n         \"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            if !ty::type_is_nil(tp_ty) {\n-                Store(bcx, C_null(lltp_ty), fcx.llretptr.get());\n+            match bcx.fcx.llretptr {\n+                Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n+                None if ty::type_is_nil(tp_ty) => RetVoid(bcx),\n+                None => Ret(bcx, C_null(lltp_ty)),\n             }\n         }\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n+            let retty = substs.tys[0];\n+            if ty::type_is_immediate(ccx.tcx, retty) && !ty::type_is_nil(retty) {\n+                unsafe {\n+                    Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n+                }\n+            } else {\n+                RetVoid(bcx)\n+            }\n+        }\n+        \"forget\" => {\n+            RetVoid(bcx);\n         }\n-        \"forget\" => {}\n         \"transmute\" => {\n             let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n             let llintype = type_of::type_of(ccx, in_type);\n@@ -726,34 +798,45 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             }\n \n             if !ty::type_is_nil(out_type) {\n-                let lldestptr = fcx.llretptr.get();\n                 let llsrcval = get_param(decl, first_real_arg);\n                 if ty::type_is_immediate(ccx.tcx, in_type) {\n-                    let lldestptr = PointerCast(bcx, lldestptr, llintype.ptr_to());\n-                    Store(bcx, llsrcval, lldestptr);\n+                    match fcx.llretptr {\n+                        Some(llretptr) => {\n+                            Store(bcx, llsrcval, PointerCast(bcx, llretptr, llintype.ptr_to()));\n+                            RetVoid(bcx);\n+                        }\n+                        None => match (llintype.kind(), llouttype.kind()) {\n+                            (Pointer, other) | (other, Pointer) if other != Pointer => {\n+                                let tmp = Alloca(bcx, llouttype, \"\");\n+                                Store(bcx, llsrcval, PointerCast(bcx, tmp, llintype.ptr_to()));\n+                                Ret(bcx, Load(bcx, tmp));\n+                            }\n+                            _ => Ret(bcx, BitCast(bcx, llsrcval, llouttype))\n+                        }\n+                    }\n                 } else {\n                     // NB: Do not use a Load and Store here. This causes massive\n                     // code bloat when `transmute` is used on large structural\n                     // types.\n+                    let lldestptr = fcx.llretptr.get();\n                     let lldestptr = PointerCast(bcx, lldestptr, Type::i8p());\n                     let llsrcptr = PointerCast(bcx, llsrcval, Type::i8p());\n \n                     let llsize = llsize_of(ccx, llintype);\n                     call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n+                    RetVoid(bcx);\n                 };\n+            } else {\n+                RetVoid(bcx);\n             }\n         }\n         \"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx,\n-                  C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n         }\n         \"contains_managed\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx,\n-                  C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()),\n-                  fcx.llretptr.get());\n+            Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).contains_managed()));\n         }\n         \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n@@ -763,6 +846,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let td = PointerCast(bcx, td, ccx.tydesc_type.ptr_to());\n             glue::call_tydesc_glue_full(bcx, visitor, td,\n                                         abi::tydesc_field_visit_glue, None);\n+            RetVoid(bcx);\n         }\n         \"frame_address\" => {\n             let frameaddress = ccx.intrinsics.get_copy(& &\"llvm.frameaddress\");\n@@ -789,6 +873,7 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n                 bcx, None, fty, ty::mk_nil(),\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n                 ArgVals(arg_vals), Some(Ignore), DontAutorefArg).bcx;\n+            RetVoid(bcx);\n         }\n         \"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular\n@@ -798,334 +883,65 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, \"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n-            Store(bcx, morestack_addr, fcx.llretptr.get());\n-        }\n-        \"memcpy32\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memcpy64\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memmove32\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memmove64\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), Type::i8p());\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memmove.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memset32\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i32(machine::llsize_of_real(ccx, lltp_ty) as i32);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let val = get_param(decl, first_real_arg + 1);\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memset.p0i8.i32\");\n-            Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"memset64\" => {\n-            let tp_ty = substs.tys[0];\n-            let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n-            let size = C_i64(machine::llsize_of_real(ccx, lltp_ty) as i64);\n-\n-            let dst_ptr = PointerCast(bcx, get_param(decl, first_real_arg), Type::i8p());\n-            let val = get_param(decl, first_real_arg + 1);\n-            let count = get_param(decl, first_real_arg + 2);\n-            let volatile = C_i1(false);\n-            let llfn = bcx.ccx().intrinsics.get_copy(& &\"llvm.memset.p0i8.i64\");\n-            Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n-        }\n-        \"sqrtf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get_copy(& &\"llvm.sqrt.f32\");\n-            Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n-        }\n-        \"sqrtf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get_copy(& &\"llvm.sqrt.f64\");\n-            Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n-        }\n-        \"powif32\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get_copy(& &\"llvm.powi.f32\");\n-            Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n-        }\n-        \"powif64\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get_copy(& &\"llvm.powi.f64\");\n-            Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n-        }\n-        \"sinf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get_copy(& &\"llvm.sin.f32\");\n-            Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n-        }\n-        \"sinf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get_copy(& &\"llvm.sin.f64\");\n-            Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n-        }\n-        \"cosf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get_copy(& &\"llvm.cos.f32\");\n-            Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n-        }\n-        \"cosf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get_copy(& &\"llvm.cos.f64\");\n-            Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n-        }\n-        \"powf32\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get_copy(& &\"llvm.pow.f32\");\n-            Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n-        }\n-        \"powf64\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get_copy(& &\"llvm.pow.f64\");\n-            Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n-        }\n-        \"expf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get_copy(& &\"llvm.exp.f32\");\n-            Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n-        }\n-        \"expf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get_copy(& &\"llvm.exp.f64\");\n-            Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n-        }\n-        \"exp2f32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get_copy(& &\"llvm.exp2.f32\");\n-            Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n-        }\n-        \"exp2f64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get_copy(& &\"llvm.exp2.f64\");\n-            Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n-        }\n-        \"logf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get_copy(& &\"llvm.log.f32\");\n-            Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n-        }\n-        \"logf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get_copy(& &\"llvm.log.f64\");\n-            Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n-        }\n-        \"log10f32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get_copy(& &\"llvm.log10.f32\");\n-            Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n-        }\n-        \"log10f64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get_copy(& &\"llvm.log10.f64\");\n-            Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n-        }\n-        \"log2f32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get_copy(& &\"llvm.log2.f32\");\n-            Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n-        }\n-        \"log2f64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get_copy(& &\"llvm.log2.f64\");\n-            Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n-        }\n-        \"fmaf32\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let b = get_param(decl, first_real_arg + 1u);\n-            let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get_copy(& &\"llvm.fma.f32\");\n-            Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n-        }\n-        \"fmaf64\" => {\n-            let a = get_param(decl, first_real_arg);\n-            let b = get_param(decl, first_real_arg + 1u);\n-            let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get_copy(& &\"llvm.fma.f64\");\n-            Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n-        }\n-        \"fabsf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get_copy(& &\"llvm.fabs.f32\");\n-            Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n-        }\n-        \"fabsf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get_copy(& &\"llvm.fabs.f64\");\n-            Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n-        }\n-        \"floorf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get_copy(& &\"llvm.floor.f32\");\n-            Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n-        }\n-        \"floorf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get_copy(& &\"llvm.floor.f64\");\n-            Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n-        }\n-        \"ceilf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get_copy(& &\"llvm.ceil.f32\");\n-            Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n-        }\n-        \"ceilf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get_copy(& &\"llvm.ceil.f64\");\n-            Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n-        }\n-        \"truncf32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get_copy(& &\"llvm.trunc.f32\");\n-            Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n-        }\n-        \"truncf64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get_copy(& &\"llvm.trunc.f64\");\n-            Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n-        }\n-        \"ctpop8\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i8\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctpop16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i16\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctpop32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i32\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctpop64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get_copy(& &\"llvm.ctpop.i64\");\n-            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n-        }\n-        \"ctlz8\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i8\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"ctlz16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i16\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"ctlz32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i32\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"ctlz64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let ctlz = ccx.intrinsics.get_copy(& &\"llvm.ctlz.i64\");\n-            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz8\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i8\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i16\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i32\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"cttz64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let y = C_i1(false);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.cttz.i64\");\n-            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n-        }\n-        \"bswap16\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i16\");\n-            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n-        }\n-        \"bswap32\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i32\");\n-            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n-        }\n-        \"bswap64\" => {\n-            let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get_copy(& &\"llvm.bswap.i64\");\n-            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n-        }\n+            Ret(bcx, morestack_addr);\n+        }\n+        \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),\n+        \"memmove64\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i64\", substs.tys[0], 64),\n+        \"memset32\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i32\", substs.tys[0], 32),\n+        \"memset64\" => memset_intrinsic(bcx, \"llvm.memset.p0i8.i64\", substs.tys[0], 64),\n+        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n+        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n+        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n+        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n+        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n+        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n+        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n+        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n+        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n+        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n+        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n+        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n+        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n+        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n+        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n+        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n+        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n+        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n+        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n+        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n+        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n+        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n+        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n+        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n+        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n+        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n+        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n+        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n+        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n+        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n+        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n+        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n+        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n+        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n+        \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n+        \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n+        \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n+        \"ctlz64\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\"),\n+        \"cttz8\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\"),\n+        \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n+        \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n+        \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n+        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n+        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n+        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n             // checked earlier?\n             ccx.sess.span_bug(item.span, \"unknown intrinsic\");\n         }\n     }\n-    finish_fn(fcx, lltop, bcx);\n }\n \n /**"}]}