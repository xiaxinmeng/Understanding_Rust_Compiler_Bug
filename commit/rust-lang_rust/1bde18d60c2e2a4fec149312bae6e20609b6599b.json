{"sha": "1bde18d60c2e2a4fec149312bae6e20609b6599b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZGUxOGQ2MGMyZTJhNGZlYzE0OTMxMmJhZTZlMjA2MDliNjU5OWI=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2016-01-24T21:46:39Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2016-01-26T09:32:58Z"}, "message": "Use interpolated token span when building spans for bigger expressions", "tree": {"sha": "c09697d0cb233d611e3914df8c3107bb1384a648", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c09697d0cb233d611e3914df8c3107bb1384a648"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bde18d60c2e2a4fec149312bae6e20609b6599b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bde18d60c2e2a4fec149312bae6e20609b6599b", "html_url": "https://github.com/rust-lang/rust/commit/1bde18d60c2e2a4fec149312bae6e20609b6599b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bde18d60c2e2a4fec149312bae6e20609b6599b/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20edb366e7d16da946c2484a8542dffb07b79837", "url": "https://api.github.com/repos/rust-lang/rust/commits/20edb366e7d16da946c2484a8542dffb07b79837", "html_url": "https://github.com/rust-lang/rust/commit/20edb366e7d16da946c2484a8542dffb07b79837"}], "stats": {"total": 81, "additions": 42, "deletions": 39}, "files": [{"sha": "8878c606d6a2c80a0c4b86b1d956adf50511308d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=1bde18d60c2e2a4fec149312bae6e20609b6599b", "patch": "@@ -10,13 +10,12 @@\n use self::LockstepIterSize::*;\n \n use ast;\n-use ptr;\n use ast::{TokenTree, Ident, Name};\n use codemap::{Span, DUMMY_SP};\n use errors::Handler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n-use parse::token::{Token, NtIdent, NtExpr, SpecialMacroVar};\n+use parse::token::{Token, NtIdent, SpecialMacroVar};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n \n@@ -174,11 +173,6 @@ fn lockstep_iter_size(t: &TokenTree, r: &TtReader) -> LockstepIterSize {\n     }\n }\n \n-fn update_span(base: Span, expr: &mut ast::Expr) {\n-    expr.span.lo = base.lo;\n-    expr.span.hi = base.hi;\n-}\n-\n /// Return the next token from the TtReader.\n /// EFFECT: advances the reader's token field\n pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n@@ -285,7 +279,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             }\n             // FIXME #2887: think about span stuff here\n             TokenTree::Token(sp, SubstNt(ident, namep)) => {\n-                //println!(\"SubstNt {:?} {:?}\", ident, sp);\n                 r.stack.last_mut().unwrap().idx += 1;\n                 match lookup_cur_matched(r, ident) {\n                     None => {\n@@ -304,14 +297,6 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                 r.cur_tok = token::Ident(sn.node, b);\n                                 return ret_val;\n                             }\n-                            MatchedNonterminal(NtExpr(ref expr)) => {\n-                                let mut expr = (**expr).clone();\n-                                //update_span(sp, &mut expr);\n-                                // FIXME(pcwalton): Bad copy.\n-                                r.cur_span = sp;\n-                                r.cur_tok = token::Interpolated(NtExpr(ptr::P(expr)));\n-                                return ret_val;\n-                            }\n                             MatchedNonterminal(ref other_whole_nt) => {\n                                 // FIXME(pcwalton): Bad copy.\n                                 r.cur_span = sp;"}, {"sha": "6b41900282845bb0c351d04edb72b8b59f14e8e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1bde18d60c2e2a4fec149312bae6e20609b6599b", "patch": "@@ -928,6 +928,7 @@ impl<'a> Parser<'a> {\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         self.last_token = if self.token.is_ident() ||\n                           self.token.is_path() ||\n+                          self.token.is_interpolated() ||\n                           self.token == token::Comma {\n             Some(Box::new(self.token.clone()))\n         } else {\n@@ -2322,13 +2323,9 @@ impl<'a> Parser<'a> {\n                                   -> PResult<'a, P<Expr>> {\n         let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n \n-        let interp = if let token::Interpolated(..) = self.token {\n-            true\n-        } else {\n-            false\n-        };\n+        let is_interpolated = self.token.is_interpolated();\n         let b = try!(self.parse_bottom_expr());\n-        let lo = if interp {\n+        let lo = if is_interpolated {\n             self.last_span.lo\n         } else {\n             b.span.lo\n@@ -2719,27 +2716,31 @@ impl<'a> Parser<'a> {\n         let ex = match self.token {\n             token::Not => {\n                 self.bump();\n+                let (interpolated, prev_span) = (self.token.is_interpolated(), self.span);\n                 let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                hi = if interpolated { prev_span.hi } else { e.span.hi };\n                 self.mk_unary(UnNot, e)\n             }\n             token::BinOp(token::Minus) => {\n                 self.bump();\n+                let (interpolated, prev_span) = (self.token.is_interpolated(), self.span);\n                 let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                hi = if interpolated { prev_span.hi } else { e.span.hi };\n                 self.mk_unary(UnNeg, e)\n             }\n             token::BinOp(token::Star) => {\n                 self.bump();\n+                let (interpolated, prev_span) = (self.token.is_interpolated(), self.span);\n                 let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                hi = if interpolated { prev_span.hi } else { e.span.hi };\n                 self.mk_unary(UnDeref, e)\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 try!(self.expect_and());\n                 let m = try!(self.parse_mutability());\n+                let (interpolated, prev_span) = (self.token.is_interpolated(), self.span);\n                 let e = try!(self.parse_prefix_expr(None));\n-                hi = e.span.hi;\n+                hi = if interpolated { prev_span.hi } else { e.span.hi };\n                 ExprAddrOf(m, e)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n@@ -2757,8 +2758,9 @@ impl<'a> Parser<'a> {\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n+                let (interpolated, prev_span) = (self.token.is_interpolated(), self.span);\n                 let subexpression = try!(self.parse_prefix_expr(None));\n-                hi = subexpression.span.hi;\n+                hi = if interpolated { prev_span.hi } else { subexpression.span.hi };\n                 ExprBox(subexpression)\n             }\n             _ => return self.parse_dot_or_call_expr(Some(attrs))\n@@ -2794,12 +2796,20 @@ impl<'a> Parser<'a> {\n                 try!(self.parse_prefix_expr(attrs))\n             }\n         };\n+\n+\n         if self.expr_is_complete(&*lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n             return Ok(lhs);\n         }\n         self.expected_tokens.push(TokenType::Operator);\n         while let Some(op) = AssocOp::from_token(&self.token) {\n+\n+            let lhs_span = match self.last_token {\n+                Some(ref lt) if lt.is_interpolated() => self.last_span,\n+                _ => lhs.span\n+            };\n+\n             let cur_op_span = self.span;\n             let restrictions = if op.is_assign_like() {\n                 self.restrictions & Restrictions::RESTRICTION_NO_STRUCT_LITERAL\n@@ -2815,13 +2825,13 @@ impl<'a> Parser<'a> {\n             }\n             // Special cases:\n             if op == AssocOp::As {\n-                let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+               let rhs = try!(self.parse_ty());\n+                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n                                    ExprCast(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                lhs = self.mk_expr(lhs_span.lo, rhs.span.hi,\n                                    ExprType(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n@@ -2843,7 +2853,7 @@ impl<'a> Parser<'a> {\n                     } else {\n                         None\n                     };\n-                    let (lhs_span, rhs_span) = (lhs.span, if let Some(ref x) = rhs {\n+                    let (lhs_span, rhs_span) = (lhs_span, if let Some(ref x) = rhs {\n                         x.span\n                     } else {\n                         cur_op_span\n@@ -2883,14 +2893,14 @@ impl<'a> Parser<'a> {\n                 AssocOp::Equal | AssocOp::Less | AssocOp::LessEqual | AssocOp::NotEqual |\n                 AssocOp::Greater | AssocOp::GreaterEqual => {\n                     let ast_op = op.to_ast_binop().unwrap();\n-                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n+                    self.mk_expr(lhs_span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BiAdd,\n@@ -2904,7 +2914,7 @@ impl<'a> Parser<'a> {\n                         token::Shl =>     BiShl,\n                         token::Shr =>     BiShr\n                     };\n-                    let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n+                    let (lhs_span, rhs_span) = (lhs_span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n                     self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }"}, {"sha": "220d0aff2e3af64ae6c1020b0827631838dd9d76", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=1bde18d60c2e2a4fec149312bae6e20609b6599b", "patch": "@@ -223,6 +223,14 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token is interpolated.\n+    pub fn is_interpolated(&self) -> bool {\n+        match *self {\n+            Interpolated(..) => true,\n+            _                => false,\n+        }\n+    }\n+\n     /// Returns `true` if the token is an interpolated path.\n     pub fn is_path(&self) -> bool {\n         match *self {"}, {"sha": "aa941bc5691304d45f0c654c9c1fc2627733a9d3", "filename": "src/test/compile-fail/issue-25385.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25385.rs?ref=1bde18d60c2e2a4fec149312bae6e20609b6599b", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     foo!(a);\n \n     foo!(1i32.foo());\n-    //~^ ERROR attempted access of field `i32` on type `_`, but no field with that name was found\n+    //~^ ERROR no method named `foo` found for type `i32` in the current scope\n }"}, {"sha": "3489a2ca9be1517f920ee2a2c008512acc4d87d5", "filename": "src/test/compile-fail/issue-26093.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Ftest%2Fcompile-fail%2Fissue-26093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Ftest%2Fcompile-fail%2Fissue-26093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26093.rs?ref=1bde18d60c2e2a4fec149312bae6e20609b6599b", "patch": "@@ -16,7 +16,5 @@ macro_rules! not_an_lvalue {\n }\n \n fn main() {\n-\n-    0 = 42;\n     not_an_lvalue!(99);\n }"}, {"sha": "642bb0c4a107e92c3b07706d7b1b104bf1908935", "filename": "src/test/compile-fail/issue-28308.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Ftest%2Fcompile-fail%2Fissue-28308.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bde18d60c2e2a4fec149312bae6e20609b6599b/src%2Ftest%2Fcompile-fail%2Fissue-28308.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28308.rs?ref=1bde18d60c2e2a4fec149312bae6e20609b6599b", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// this error is dispayed in `<std macros>`\n+// error-pattern:cannot apply unary operator `!` to type `&'static str`\n+\n fn main() {\n     assert!(\"foo\");\n-    //~^ ERROR cannot apply unary operator `!` to type `&'static str`\n }"}]}