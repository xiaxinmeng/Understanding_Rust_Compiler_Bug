{"sha": "7608bbdea869b061a65c996cac6c15d840436a7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MDhiYmRlYTg2OWIwNjFhNjVjOTk2Y2FjNmMxNWQ4NDA0MzZhN2M=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-15T20:51:19Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T03:22:47Z"}, "message": "Refactor `resolve_module_path` to take an `Option<Span>` instead of a `Span`.", "tree": {"sha": "934aafaa0a9c19f42eabcc2eff5c747d992eb8d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/934aafaa0a9c19f42eabcc2eff5c747d992eb8d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7608bbdea869b061a65c996cac6c15d840436a7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7608bbdea869b061a65c996cac6c15d840436a7c", "html_url": "https://github.com/rust-lang/rust/commit/7608bbdea869b061a65c996cac6c15d840436a7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7608bbdea869b061a65c996cac6c15d840436a7c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c", "html_url": "https://github.com/rust-lang/rust/commit/05afe15d1f7b29b5f8f006f6e9ec16c8a7cd4a0c"}], "stats": {"total": 38, "additions": 17, "deletions": 21}, "files": [{"sha": "d514d7e906a8d3e3387cfd6ee95cac8c2efa3e92", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7608bbdea869b061a65c996cac6c15d840436a7c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7608bbdea869b061a65c996cac6c15d840436a7c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7608bbdea869b061a65c996cac6c15d840436a7c", "patch": "@@ -1242,7 +1242,7 @@ impl<'a> Resolver<'a> {\n                                      mut search_module: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n-                                     span: Span)\n+                                     span: Option<Span>)\n                                      -> ResolveResult<Module<'a>> {\n         fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n                                        -> Option<Module<'a>> {\n@@ -1265,7 +1265,7 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, Some(span)) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n@@ -1291,7 +1291,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"Could not find `{}` in `{}`\", segment_name, module_name)\n                     };\n \n-                    return Failed(Some((span, msg)));\n+                    return Failed(span.map(|span| (span, msg)));\n                 }\n                 Failed(err) => return Failed(err),\n                 Indeterminate => {\n@@ -1304,11 +1304,13 @@ impl<'a> Resolver<'a> {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n-                        self.check_privacy(name, binding, span);\n+                        if let Some(span) = span {\n+                            self.check_privacy(name, binding, span);\n+                        }\n                         search_module = module_def;\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n-                        return Failed(Some((span, msg)));\n+                        return Failed(span.map(|span| (span, msg)));\n                     }\n                 }\n             }\n@@ -1324,7 +1326,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_module_path(&mut self,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n-                           span: Span)\n+                           span: Option<Span>)\n                            -> ResolveResult<Module<'a>> {\n         if module_path.len() == 0 {\n             return Success(self.graph_root) // Use the crate root\n@@ -1361,7 +1363,7 @@ impl<'a> Resolver<'a> {\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n                         let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n-                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, Some(span))\n+                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, span)\n                                   .and_then(LexicalScopeBinding::module) {\n                             None => return Failed(None),\n                             Some(containing_module) => {\n@@ -1378,10 +1380,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.resolve_module_path_from_root(search_module,\n-                                           module_path,\n-                                           start_index,\n-                                           span)\n+        self.resolve_module_path_from_root(search_module, module_path, start_index, span)\n     }\n \n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n@@ -1485,7 +1484,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Span)\n+    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n@@ -1504,7 +1503,7 @@ impl<'a> Resolver<'a> {\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => {\n                     let msg = \"There are too many initial `super`s.\".into();\n-                    return Failed(Some((span, msg)));\n+                    return Failed(span.map(|span| (span, msg)));\n                 }\n                 Some(new_module) => {\n                     containing_module = new_module;\n@@ -2592,7 +2591,7 @@ impl<'a> Resolver<'a> {\n                                   .collect::<Vec<_>>();\n \n         let containing_module;\n-        match self.resolve_module_path(&module_path, UseLexicalScope, span) {\n+        match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -2632,10 +2631,7 @@ impl<'a> Resolver<'a> {\n         let root_module = self.graph_root;\n \n         let containing_module;\n-        match self.resolve_module_path_from_root(root_module,\n-                                                 &module_path,\n-                                                 0,\n-                                                 span) {\n+        match self.resolve_module_path_from_root(root_module, &module_path, 0, Some(span)) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -2915,7 +2911,7 @@ impl<'a> Resolver<'a> {\n \n                                     match self.resolve_module_path(&name_path[..],\n                                                                    UseLexicalScope,\n-                                                                   expr.span) {\n+                                                                   Some(expr.span)) {\n                                         Success(e) => {\n                                             if let Some(def_type) = e.def {\n                                                 def = def_type;\n@@ -3253,7 +3249,7 @@ impl<'a> Resolver<'a> {\n \n         let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n         let mut path_resolution = err_path_resolution();\n-        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, path.span) {\n+        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n                 let def = module.def.unwrap();\n                 path_resolution = PathResolution::new(def);"}, {"sha": "3c44051503634eb91eb284941090288bcc987d0c", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7608bbdea869b061a65c996cac6c15d840436a7c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7608bbdea869b061a65c996cac6c15d840436a7c/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7608bbdea869b061a65c996cac6c15d840436a7c", "patch": "@@ -480,7 +480,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             Some(module) => module,\n             _ => match self.resolve_module_path(&directive.module_path,\n                                                 DontUseLexicalScope,\n-                                                directive.span) {\n+                                                Some(directive.span)) {\n                 Success(module) => module,\n                 Indeterminate => return Indeterminate,\n                 Failed(err) => return Failed(err),"}]}