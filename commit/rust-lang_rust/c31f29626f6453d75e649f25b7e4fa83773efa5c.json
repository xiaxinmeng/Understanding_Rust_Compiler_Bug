{"sha": "c31f29626f6453d75e649f25b7e4fa83773efa5c", "node_id": "C_kwDOAAsO6NoAKGMzMWYyOTYyNmY2NDUzZDc1ZTY0OWYyNWI3ZTRmYTgzNzczZWZhNWM", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-08-21T22:44:39Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-08-22T01:41:17Z"}, "message": "Refactor query modifier parsing", "tree": {"sha": "14f297b21411b3b16397aa2f552c6573aa0dc1ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f297b21411b3b16397aa2f552c6573aa0dc1ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c31f29626f6453d75e649f25b7e4fa83773efa5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c31f29626f6453d75e649f25b7e4fa83773efa5c", "html_url": "https://github.com/rust-lang/rust/commit/c31f29626f6453d75e649f25b7e4fa83773efa5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c31f29626f6453d75e649f25b7e4fa83773efa5c/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd01122b5c62a04e64b4109c5576eeea9ae4145b", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd01122b5c62a04e64b4109c5576eeea9ae4145b", "html_url": "https://github.com/rust-lang/rust/commit/dd01122b5c62a04e64b4109c5576eeea9ae4145b"}], "stats": {"total": 385, "additions": 125, "deletions": 260}, "files": [{"sha": "52c93133f79c44cbaa4bf85055f052360fe5777e", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 125, "deletions": 260, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/c31f29626f6453d75e649f25b7e4fa83773efa5c/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c31f29626f6453d75e649f25b7e4fa83773efa5c/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=c31f29626f6453d75e649f25b7e4fa83773efa5c", "patch": "@@ -1,139 +1,17 @@\n use proc_macro::TokenStream;\n-use proc_macro2::{Delimiter, TokenTree};\n use quote::{quote, quote_spanned};\n use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n use syn::{\n-    braced, parenthesized, parse_macro_input, parse_quote, AttrStyle, Attribute, Block, Error,\n-    Expr, Ident, ReturnType, Token, Type,\n+    braced, parenthesized, parse_macro_input, parse_quote, token, AttrStyle, Attribute, Block,\n+    Error, Expr, Ident, Pat, ReturnType, Token, Type,\n };\n \n mod kw {\n     syn::custom_keyword!(query);\n }\n \n-/// Ident or a wildcard `_`.\n-struct IdentOrWild(Ident);\n-\n-impl Parse for IdentOrWild {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        Ok(if input.peek(Token![_]) {\n-            let underscore = input.parse::<Token![_]>()?;\n-            IdentOrWild(Ident::new(\"_\", underscore.span()))\n-        } else {\n-            IdentOrWild(input.parse()?)\n-        })\n-    }\n-}\n-\n-/// A modifier for a query\n-enum QueryModifier {\n-    /// The description of the query.\n-    Desc(Option<Ident>, Punctuated<Expr, Token![,]>),\n-\n-    /// Use this type for the in-memory cache.\n-    Storage(Type),\n-\n-    /// Cache the query to disk if the `Expr` returns true.\n-    Cache(Option<IdentOrWild>, Block),\n-\n-    /// Custom code to load the query from disk.\n-    LoadCached(Ident, Ident, Block),\n-\n-    /// A cycle error for this query aborting the compilation with a fatal error.\n-    FatalCycle(Ident),\n-\n-    /// A cycle error results in a delay_bug call\n-    CycleDelayBug(Ident),\n-\n-    /// Don't hash the result, instead just mark a query red if it runs\n-    NoHash(Ident),\n-\n-    /// Generate a dep node based on the dependencies of the query\n-    Anon(Ident),\n-\n-    /// Always evaluate the query, ignoring its dependencies\n-    EvalAlways(Ident),\n-\n-    /// Use a separate query provider for local and extern crates\n-    SeparateProvideExtern(Ident),\n-\n-    /// Always remap the ParamEnv's constness before hashing and passing to the query provider\n-    RemapEnvConstness(Ident),\n-}\n-\n-impl Parse for QueryModifier {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let modifier: Ident = input.parse()?;\n-        if modifier == \"desc\" {\n-            // Parse a description modifier like:\n-            // `desc { |tcx| \"foo {}\", tcx.item_path(key) }`\n-            let attr_content;\n-            braced!(attr_content in input);\n-            let tcx = if attr_content.peek(Token![|]) {\n-                attr_content.parse::<Token![|]>()?;\n-                let tcx = attr_content.parse()?;\n-                attr_content.parse::<Token![|]>()?;\n-                Some(tcx)\n-            } else {\n-                None\n-            };\n-            let desc = attr_content.parse_terminated(Expr::parse)?;\n-            Ok(QueryModifier::Desc(tcx, desc))\n-        } else if modifier == \"cache_on_disk_if\" {\n-            // Parse a cache modifier like:\n-            // `cache(tcx, value) { |tcx| key.is_local() }`\n-            let has_args = if let TokenTree::Group(group) = input.fork().parse()? {\n-                group.delimiter() == Delimiter::Parenthesis\n-            } else {\n-                false\n-            };\n-            let args = if has_args {\n-                let args;\n-                parenthesized!(args in input);\n-                let tcx = args.parse()?;\n-                Some(tcx)\n-            } else {\n-                None\n-            };\n-            let block = input.parse()?;\n-            Ok(QueryModifier::Cache(args, block))\n-        } else if modifier == \"load_cached\" {\n-            // Parse a load_cached modifier like:\n-            // `load_cached(tcx, id) { tcx.on_disk_cache.try_load_query_result(tcx, id) }`\n-            let args;\n-            parenthesized!(args in input);\n-            let tcx = args.parse()?;\n-            args.parse::<Token![,]>()?;\n-            let id = args.parse()?;\n-            let block = input.parse()?;\n-            Ok(QueryModifier::LoadCached(tcx, id, block))\n-        } else if modifier == \"storage\" {\n-            let args;\n-            parenthesized!(args in input);\n-            let ty = args.parse()?;\n-            Ok(QueryModifier::Storage(ty))\n-        } else if modifier == \"fatal_cycle\" {\n-            Ok(QueryModifier::FatalCycle(modifier))\n-        } else if modifier == \"cycle_delay_bug\" {\n-            Ok(QueryModifier::CycleDelayBug(modifier))\n-        } else if modifier == \"no_hash\" {\n-            Ok(QueryModifier::NoHash(modifier))\n-        } else if modifier == \"anon\" {\n-            Ok(QueryModifier::Anon(modifier))\n-        } else if modifier == \"eval_always\" {\n-            Ok(QueryModifier::EvalAlways(modifier))\n-        } else if modifier == \"separate_provide_extern\" {\n-            Ok(QueryModifier::SeparateProvideExtern(modifier))\n-        } else if modifier == \"remap_env_constness\" {\n-            Ok(QueryModifier::RemapEnvConstness(modifier))\n-        } else {\n-            Err(Error::new(modifier.span(), \"unknown query modifier\"))\n-        }\n-    }\n-}\n-\n /// Ensures only doc comment attributes are used\n fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n     let inner = |attr: Attribute| {\n@@ -154,16 +32,16 @@ fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n /// A compiler query. `query ... { ... }`\n struct Query {\n     doc_comments: Vec<Attribute>,\n-    modifiers: List<QueryModifier>,\n+    modifiers: QueryModifiers,\n     name: Ident,\n-    key: IdentOrWild,\n+    key: Pat,\n     arg: Type,\n     result: ReturnType,\n }\n \n impl Parse for Query {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let doc_comments = check_attributes(input.call(Attribute::parse_outer)?)?;\n+        let mut doc_comments = check_attributes(input.call(Attribute::parse_outer)?)?;\n \n         // Parse the query declaration. Like `query type_of(key: DefId) -> Ty<'tcx>`\n         input.parse::<kw::query>()?;\n@@ -178,7 +56,13 @@ impl Parse for Query {\n         // Parse the query modifiers\n         let content;\n         braced!(content in input);\n-        let modifiers = content.parse()?;\n+        let modifiers = parse_query_modifiers(&content)?;\n+\n+        // If there are no doc-comments, give at least some idea of what\n+        // it does by showing the query description.\n+        if doc_comments.is_empty() {\n+            doc_comments.push(doc_comment_from_desc(&modifiers.desc.1)?);\n+        }\n \n         Ok(Query { doc_comments, modifiers, name, key, arg, result })\n     }\n@@ -205,7 +89,7 @@ struct QueryModifiers {\n     storage: Option<Type>,\n \n     /// Cache the query to disk if the `Block` returns true.\n-    cache: Option<(Option<IdentOrWild>, Block)>,\n+    cache: Option<(Option<Pat>, Block)>,\n \n     /// Custom code to load the query from disk.\n     load_cached: Option<(Ident, Ident, Block)>,\n@@ -232,8 +116,7 @@ struct QueryModifiers {\n     remap_env_constness: Option<Ident>,\n }\n \n-/// Process query modifiers into a struct, erroring on duplicates\n-fn process_modifiers(query: &mut Query) -> QueryModifiers {\n+fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut load_cached = None;\n     let mut storage = None;\n     let mut cache = None;\n@@ -245,117 +128,84 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut eval_always = None;\n     let mut separate_provide_extern = None;\n     let mut remap_env_constness = None;\n-    for modifier in query.modifiers.0.drain(..) {\n-        match modifier {\n-            QueryModifier::LoadCached(tcx, id, block) => {\n-                if load_cached.is_some() {\n-                    panic!(\"duplicate modifier `load_cached` for query `{}`\", query.name);\n-                }\n-                load_cached = Some((tcx, id, block));\n-            }\n-            QueryModifier::Storage(ty) => {\n-                if storage.is_some() {\n-                    panic!(\"duplicate modifier `storage` for query `{}`\", query.name);\n-                }\n-                storage = Some(ty);\n-            }\n-            QueryModifier::Cache(args, expr) => {\n-                if cache.is_some() {\n-                    panic!(\"duplicate modifier `cache` for query `{}`\", query.name);\n-                }\n-                cache = Some((args, expr));\n-            }\n-            QueryModifier::Desc(tcx, list) => {\n-                if desc.is_some() {\n-                    panic!(\"duplicate modifier `desc` for query `{}`\", query.name);\n-                }\n-                // If there are no doc-comments, give at least some idea of what\n-                // it does by showing the query description.\n-                if query.doc_comments.is_empty() {\n-                    use ::syn::*;\n-                    let mut list = list.iter();\n-                    let format_str: String = match list.next() {\n-                        Some(&Expr::Lit(ExprLit { lit: Lit::Str(ref lit_str), .. })) => {\n-                            lit_str.value().replace(\"`{}`\", \"{}\") // We add them later anyways for consistency\n-                        }\n-                        _ => panic!(\"Expected a string literal\"),\n-                    };\n-                    let mut fmt_fragments = format_str.split(\"{}\");\n-                    let mut doc_string = fmt_fragments.next().unwrap().to_string();\n-                    list.map(::quote::ToTokens::to_token_stream).zip(fmt_fragments).for_each(\n-                        |(tts, next_fmt_fragment)| {\n-                            use ::core::fmt::Write;\n-                            write!(\n-                                &mut doc_string,\n-                                \" `{}` {}\",\n-                                tts.to_string().replace(\" . \", \".\"),\n-                                next_fmt_fragment,\n-                            )\n-                            .unwrap();\n-                        },\n-                    );\n-                    let doc_string = format!(\n-                        \"[query description - consider adding a doc-comment!] {}\",\n-                        doc_string\n-                    );\n-                    let comment = parse_quote! {\n-                        #[doc = #doc_string]\n-                    };\n-                    query.doc_comments.push(comment);\n-                }\n-                desc = Some((tcx, list));\n-            }\n-            QueryModifier::FatalCycle(ident) => {\n-                if fatal_cycle.is_some() {\n-                    panic!(\"duplicate modifier `fatal_cycle` for query `{}`\", query.name);\n-                }\n-                fatal_cycle = Some(ident);\n-            }\n-            QueryModifier::CycleDelayBug(ident) => {\n-                if cycle_delay_bug.is_some() {\n-                    panic!(\"duplicate modifier `cycle_delay_bug` for query `{}`\", query.name);\n-                }\n-                cycle_delay_bug = Some(ident);\n-            }\n-            QueryModifier::NoHash(ident) => {\n-                if no_hash.is_some() {\n-                    panic!(\"duplicate modifier `no_hash` for query `{}`\", query.name);\n-                }\n-                no_hash = Some(ident);\n-            }\n-            QueryModifier::Anon(ident) => {\n-                if anon.is_some() {\n-                    panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n-                }\n-                anon = Some(ident);\n-            }\n-            QueryModifier::EvalAlways(ident) => {\n-                if eval_always.is_some() {\n-                    panic!(\"duplicate modifier `eval_always` for query `{}`\", query.name);\n-                }\n-                eval_always = Some(ident);\n-            }\n-            QueryModifier::SeparateProvideExtern(ident) => {\n-                if separate_provide_extern.is_some() {\n-                    panic!(\n-                        \"duplicate modifier `separate_provide_extern` for query `{}`\",\n-                        query.name\n-                    );\n-                }\n-                separate_provide_extern = Some(ident);\n-            }\n-            QueryModifier::RemapEnvConstness(ident) => {\n-                if remap_env_constness.is_some() {\n-                    panic!(\"duplicate modifier `remap_env_constness` for query `{}`\", query.name);\n+\n+    while !input.is_empty() {\n+        let modifier: Ident = input.parse()?;\n+\n+        macro_rules! try_insert {\n+            ($name:ident = $expr:expr) => {\n+                if $name.is_some() {\n+                    return Err(Error::new(modifier.span(), \"duplicate modifier\"));\n                 }\n-                remap_env_constness = Some(ident)\n-            }\n+                $name = Some($expr);\n+            };\n+        }\n+\n+        if modifier == \"desc\" {\n+            // Parse a description modifier like:\n+            // `desc { |tcx| \"foo {}\", tcx.item_path(key) }`\n+            let attr_content;\n+            braced!(attr_content in input);\n+            let tcx = if attr_content.peek(Token![|]) {\n+                attr_content.parse::<Token![|]>()?;\n+                let tcx = attr_content.parse()?;\n+                attr_content.parse::<Token![|]>()?;\n+                Some(tcx)\n+            } else {\n+                None\n+            };\n+            let list = attr_content.parse_terminated(Expr::parse)?;\n+            try_insert!(desc = (tcx, list));\n+        } else if modifier == \"cache_on_disk_if\" {\n+            // Parse a cache modifier like:\n+            // `cache(tcx) { |tcx| key.is_local() }`\n+            let args = if input.peek(token::Paren) {\n+                let args;\n+                parenthesized!(args in input);\n+                let tcx = args.parse()?;\n+                Some(tcx)\n+            } else {\n+                None\n+            };\n+            let block = input.parse()?;\n+            try_insert!(cache = (args, block));\n+        } else if modifier == \"load_cached\" {\n+            // Parse a load_cached modifier like:\n+            // `load_cached(tcx, id) { tcx.on_disk_cache.try_load_query_result(tcx, id) }`\n+            let args;\n+            parenthesized!(args in input);\n+            let tcx = args.parse()?;\n+            args.parse::<Token![,]>()?;\n+            let id = args.parse()?;\n+            let block = input.parse()?;\n+            try_insert!(load_cached = (tcx, id, block));\n+        } else if modifier == \"storage\" {\n+            let args;\n+            parenthesized!(args in input);\n+            let ty = args.parse()?;\n+            try_insert!(storage = ty);\n+        } else if modifier == \"fatal_cycle\" {\n+            try_insert!(fatal_cycle = modifier);\n+        } else if modifier == \"cycle_delay_bug\" {\n+            try_insert!(cycle_delay_bug = modifier);\n+        } else if modifier == \"no_hash\" {\n+            try_insert!(no_hash = modifier);\n+        } else if modifier == \"anon\" {\n+            try_insert!(anon = modifier);\n+        } else if modifier == \"eval_always\" {\n+            try_insert!(eval_always = modifier);\n+        } else if modifier == \"separate_provide_extern\" {\n+            try_insert!(separate_provide_extern = modifier);\n+        } else if modifier == \"remap_env_constness\" {\n+            try_insert!(remap_env_constness = modifier);\n+        } else {\n+            return Err(Error::new(modifier.span(), \"unknown query modifier\"));\n         }\n     }\n-    let desc = desc.unwrap_or_else(|| {\n-        panic!(\"no description provided for query `{}`\", query.name);\n-    });\n-    QueryModifiers {\n+    let Some(desc) = desc else {\n+        return Err(input.error(\"no description provided\"));\n+    };\n+    Ok(QueryModifiers {\n         load_cached,\n         storage,\n         cache,\n@@ -367,17 +217,41 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n         eval_always,\n         separate_provide_extern,\n         remap_env_constness,\n-    }\n+    })\n+}\n+\n+fn doc_comment_from_desc(list: &Punctuated<Expr, token::Comma>) -> Result<Attribute> {\n+    use ::syn::*;\n+    let mut iter = list.iter();\n+    let format_str: String = match iter.next() {\n+        Some(&Expr::Lit(ExprLit { lit: Lit::Str(ref lit_str), .. })) => {\n+            lit_str.value().replace(\"`{}`\", \"{}\") // We add them later anyways for consistency\n+        }\n+        _ => return Err(Error::new(list.span(), \"Expected a string literal\")),\n+    };\n+    let mut fmt_fragments = format_str.split(\"{}\");\n+    let mut doc_string = fmt_fragments.next().unwrap().to_string();\n+    iter.map(::quote::ToTokens::to_token_stream).zip(fmt_fragments).for_each(\n+        |(tts, next_fmt_fragment)| {\n+            use ::core::fmt::Write;\n+            write!(\n+                &mut doc_string,\n+                \" `{}` {}\",\n+                tts.to_string().replace(\" . \", \".\"),\n+                next_fmt_fragment,\n+            )\n+            .unwrap();\n+        },\n+    );\n+    let doc_string = format!(\"[query description - consider adding a doc-comment!] {}\", doc_string);\n+    Ok(parse_quote! { #[doc = #doc_string] })\n }\n \n /// Add the impl of QueryDescription for the query to `impls` if one is requested\n-fn add_query_description_impl(\n-    query: &Query,\n-    modifiers: QueryModifiers,\n-    impls: &mut proc_macro2::TokenStream,\n-) {\n+fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStream) {\n     let name = &query.name;\n-    let key = &query.key.0;\n+    let key = &query.key;\n+    let modifiers = &query.modifiers;\n \n     // Find out if we should cache the query on disk\n     let cache = if let Some((args, expr)) = modifiers.cache.as_ref() {\n@@ -395,13 +269,7 @@ fn add_query_description_impl(\n             }\n         };\n \n-        let tcx = args\n-            .as_ref()\n-            .map(|t| {\n-                let t = &t.0;\n-                quote! { #t }\n-            })\n-            .unwrap_or_else(|| quote! { _ });\n+        let tcx = args.as_ref().map(|t| quote! { #t }).unwrap_or_else(|| quote! { _ });\n         // expr is a `Block`, meaning that `{ #expr }` gets expanded\n         // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n         quote! {\n@@ -427,7 +295,7 @@ fn add_query_description_impl(\n         }\n     };\n \n-    let (tcx, desc) = modifiers.desc;\n+    let (tcx, desc) = &modifiers.desc;\n     let tcx = tcx.as_ref().map_or_else(|| quote! { _ }, |t| quote! { #t });\n \n     let desc = quote! {\n@@ -456,10 +324,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut dep_node_def_stream = quote! {};\n     let mut cached_queries = quote! {};\n \n-    for mut query in queries.0 {\n-        let modifiers = process_modifiers(&mut query);\n-        let name = &query.name;\n-        let arg = &query.arg;\n+    for query in queries.0 {\n+        let Query { name, arg, modifiers, .. } = &query;\n         let result_full = &query.result;\n         let result = match query.result {\n             ReturnType::Default => quote! { -> () },\n@@ -528,7 +394,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             [#attribute_stream] #name(#arg),\n         });\n \n-        add_query_description_impl(&query, modifiers, &mut query_description_stream);\n+        add_query_description_impl(&query, &mut query_description_stream);\n     }\n \n     TokenStream::from(quote! {\n@@ -539,7 +405,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                     $($other)*\n \n                     #query_stream\n-\n                 }\n             }\n         }"}]}