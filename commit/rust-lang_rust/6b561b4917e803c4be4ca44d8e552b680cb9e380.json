{"sha": "6b561b4917e803c4be4ca44d8e552b680cb9e380", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiNTYxYjQ5MTdlODAzYzRiZTRjYTQ0ZDhlNTUyYjY4MGNiOWUzODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-20T11:17:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-20T11:17:47Z"}, "message": "Auto merge of #67449 - Centril:rollup-04hvg57, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #66755 (Remove a const-if-hack in RawVec)\n - #67127 (Use structured suggestion for disambiguating method calls)\n - #67219 (Fix up Command Debug output when arg0 is specified.)\n - #67285 (Indicate origin of where type parameter for uninferred types )\n - #67328 (Remove now-redundant range check on u128 -> f32 casts)\n - #67367 (Move command line option definitions into a dedicated file)\n - #67442 (Remove `SOCK_CLOEXEC` dummy variable on platforms that don't use it.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "fed1db0704735b342d9dec0223eddda023ee514c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed1db0704735b342d9dec0223eddda023ee514c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b561b4917e803c4be4ca44d8e552b680cb9e380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b561b4917e803c4be4ca44d8e552b680cb9e380", "html_url": "https://github.com/rust-lang/rust/commit/6b561b4917e803c4be4ca44d8e552b680cb9e380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b561b4917e803c4be4ca44d8e552b680cb9e380/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "696735f71b4408302ba166d148e9d474c51416d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/696735f71b4408302ba166d148e9d474c51416d2", "html_url": "https://github.com/rust-lang/rust/commit/696735f71b4408302ba166d148e9d474c51416d2"}, {"sha": "3a336c48c3e115ea13c53fc117b95bd9f66f1658", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a336c48c3e115ea13c53fc117b95bd9f66f1658", "html_url": "https://github.com/rust-lang/rust/commit/3a336c48c3e115ea13c53fc117b95bd9f66f1658"}], "stats": {"total": 2511, "additions": 1378, "deletions": 1133}, "files": [{"sha": "be46e632be45f967f041a24d069cdb0f920f8264", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -85,6 +85,7 @@\n #![feature(const_generic_impls_guard)]\n #![feature(const_generics)]\n #![feature(const_in_array_repeat_expressions)]\n+#![feature(const_if_match)]\n #![feature(cow_is_borrowed)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]"}, {"sha": "3201c702abb294b08a0c85c68fd726b6c421649d", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -52,15 +52,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n-        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n-        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n-        //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+        let cap = if mem::size_of::<T>() == 0 { core::usize::MAX } else { 0 };\n \n         // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n         RawVec {\n             ptr: Unique::empty(),\n-            // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n-            cap: [0, !0][(mem::size_of::<T>() == 0) as usize],\n+            cap,\n             a,\n         }\n     }\n@@ -132,19 +129,7 @@ impl<T> RawVec<T, Global> {\n     /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub const fn new() -> Self {\n-        // FIXME(Centril): Reintegrate this with `fn new_in` when we can.\n-\n-        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n-        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n-        //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n-\n-        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n-        RawVec {\n-            ptr: Unique::empty(),\n-            // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n-            cap: [0, !0][(mem::size_of::<T>() == 0) as usize],\n-            a: Global,\n-        }\n+        Self::new_in(Global)\n     }\n \n     /// Creates a `RawVec` (on the system heap) with exactly the"}, {"sha": "ebb94cc72ffe0de5e4cb49f78391c7314ddd3ff4", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -3,7 +3,7 @@ use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n-use crate::ty::{self, Ty, Infer, TyVar};\n+use crate::ty::{self, Ty, Infer, TyVar, DefIdTree};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n use syntax::symbol::kw;\n@@ -117,6 +117,8 @@ fn closure_return_type_suggestion(\n     descr: &str,\n     name: &str,\n     ret: &str,\n+    parent_name: Option<String>,\n+    parent_descr: Option<&str>,\n ) {\n     let (arrow, post) = match output {\n         FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n@@ -138,7 +140,12 @@ fn closure_return_type_suggestion(\n         suggestion,\n         Applicability::HasPlaceholders,\n     );\n-    err.span_label(span, InferCtxt::missing_type_msg(&name, &descr));\n+    err.span_label(span, InferCtxt::missing_type_msg(\n+        &name,\n+        &descr,\n+        parent_name,\n+        parent_descr\n+    ));\n }\n \n /// Given a closure signature, return a `String` containing a list of all its argument types.\n@@ -177,16 +184,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> (String, Option<Span>, Cow<'static, str>) {\n+    ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n             let ty_vars = self.type_variables.borrow();\n             let var_origin = ty_vars.var_origin(ty_vid);\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n+            if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n+                let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n+                let (parent_name, parent_desc) = if let Some(parent_def_id) = parent_def_id {\n+                    let parent_name = self.tcx.def_key(parent_def_id).disambiguated_data.data\n+                        .get_opt_name().map(|parent_symbol| parent_symbol.to_string());\n+\n+                    let type_parent_desc = self.tcx.def_kind(parent_def_id)\n+                        .map(|parent_def_kind| parent_def_kind.descr(parent_def_id));\n+\n+                    (parent_name, type_parent_desc)\n+                } else {\n+                    (None, None)\n+                };\n+\n                 if name != kw::SelfUpper {\n                     return (\n                         name.to_string(),\n                         Some(var_origin.span),\n                         \"type parameter\".into(),\n+                        parent_name,\n+                        parent_desc,\n                     );\n                 }\n             }\n@@ -198,7 +220,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             printer.region_highlight_mode = highlight;\n         }\n         let _ = ty.print(printer);\n-        (s, None, ty.prefix_string())\n+        (s, None, ty.prefix_string(), None, None)\n     }\n \n     pub fn need_type_info_err(\n@@ -209,7 +231,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         error_code: TypeAnnotationNeeded,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, name_sp, descr) = self.extract_type_name(&ty, None);\n+        let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+\n \n         let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n@@ -218,7 +241,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let ty_vars = self.type_variables.borrow();\n             let getter = move |ty_vid| {\n                 let var_origin = ty_vars.var_origin(ty_vid);\n-                if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n+                if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {\n                     return Some(name.to_string());\n                 }\n                 None\n@@ -317,6 +340,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             &descr,\n                             &name,\n                             &ret,\n+                            parent_name,\n+                            parent_descr,\n                         );\n                         // We don't want to give the other suggestions when the problem is the\n                         // closure return type.\n@@ -433,8 +458,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span\n             }) && local_visitor.found_arg_pattern.is_none()\n-        { // Avoid multiple labels pointing at `span`.\n-            err.span_label(span, InferCtxt::missing_type_msg(&name, &descr));\n+        {\n+            // Avoid multiple labels pointing at `span`.\n+            err.span_label(\n+                span,\n+                InferCtxt::missing_type_msg(&name, &descr, parent_name, parent_descr)\n+            );\n         }\n \n         err\n@@ -496,19 +525,42 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let (name, _, descr) = self.extract_type_name(&ty, None);\n+        let (name, _, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n+\n         let mut err = struct_span_err!(\n             self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n         );\n-        err.span_label(span, InferCtxt::missing_type_msg(&name, &descr));\n+        err.span_label(span, InferCtxt::missing_type_msg(\n+            &name,\n+            &descr,\n+            parent_name,\n+            parent_descr\n+        ));\n         err\n     }\n \n-    fn missing_type_msg(type_name: &str, descr: &str) -> Cow<'static, str>{\n+    fn missing_type_msg(\n+        type_name: &str,\n+        descr: &str,\n+        parent_name: Option<String>,\n+        parent_descr: Option<&str>,\n+    ) -> Cow<'static, str> {\n         if type_name == \"_\" {\n             \"cannot infer type\".into()\n         } else {\n-            format!(\"cannot infer type for {} `{}`\", descr, type_name).into()\n+            let parent_desc = if let Some(parent_name) = parent_name {\n+                let parent_type_descr = if let Some(parent_descr) = parent_descr {\n+                    format!(\" the {}\", parent_descr)\n+                } else {\n+                    \"\".into()\n+                };\n+\n+                format!(\" declared on{} `{}`\", parent_type_descr, parent_name)\n+            } else {\n+                \"\".to_string()\n+            };\n+\n+            format!(\"cannot infer type for {} `{}`{}\", descr, type_name, parent_desc).into()\n         }\n     }\n }"}, {"sha": "996a722e157fad1de1d7d3aacd7fd70f4ee49879", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1135,7 +1135,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.universe(),\n                     false,\n                     TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(param.name),\n+                        kind: TypeVariableOriginKind::TypeParameterDefinition(\n+                            param.name,\n+                            Some(param.def_id)\n+                        ),\n                         span,\n                     },\n                 );"}, {"sha": "ea4a28c22a9e7501c98d4eff41cf07e7675ac006", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                 if let ty::TyVar(ty_vid) = infer_ty {\n                     let ty_vars = self.infcx.type_variables.borrow();\n                     if let TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(_),\n+                        kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n                         span,\n                     } = *ty_vars.var_origin(ty_vid)\n                     {"}, {"sha": "5a12de25f4b759583ccae29862e6520a59c6ce2a", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1,6 +1,7 @@\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use crate::ty::{self, Ty, TyVid};\n+use crate::hir::def_id::DefId;\n \n use std::cmp;\n use std::marker::PhantomData;\n@@ -49,7 +50,7 @@ pub enum TypeVariableOriginKind {\n     MiscVariable,\n     NormalizeProjectionType,\n     TypeInference,\n-    TypeParameterDefinition(Symbol),\n+    TypeParameterDefinition(Symbol, Option<DefId>),\n \n     /// One of the upvars or closure kind parameters in a `ClosureSubsts`\n     /// (before it has been determined)."}, {"sha": "4839974d6255cc4d9007916226594c1b32a600cd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2113,7 +2113,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     self.var_map.entry(ty).or_insert_with(||\n                         infcx.next_ty_var(\n                             TypeVariableOrigin {\n-                                kind: TypeVariableOriginKind::TypeParameterDefinition(name),\n+                                kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n                                 span: DUMMY_SP,\n                             }\n                         )"}, {"sha": "15bbfa7860fa77b0285bf48bffadc0d97d1f46ce", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -212,6 +212,17 @@ pub enum AssocKind {\n     Type\n }\n \n+impl AssocKind {\n+    pub fn suggestion_descr(&self) -> &'static str {\n+        match self {\n+            ty::AssocKind::Method => \"method call\",\n+            ty::AssocKind::Type |\n+            ty::AssocKind::OpaqueTy => \"associated type\",\n+            ty::AssocKind::Const => \"associated constant\",\n+        }\n+    }\n+}\n+\n impl AssocItem {\n     pub fn def_kind(&self) -> DefKind {\n         match self.kind {"}, {"sha": "55d63f18cd906a7711940d1005a1d581b40bdc91", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -341,6 +341,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     llval\n                                 }\n                             }\n+                            (CastTy::Int(_), CastTy::Float) => {\n+                                if signed {\n+                                    bx.sitofp(llval, ll_t_out)\n+                                } else {\n+                                    bx.uitofp(llval, ll_t_out)\n+                                }\n+                            }\n                             (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                             (CastTy::FnPtr, CastTy::Ptr(_)) |\n                             (CastTy::RPtr(_), CastTy::Ptr(_)) =>\n@@ -352,8 +359,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 let usize_llval = bx.intcast(llval, bx.cx().type_isize(), signed);\n                                 bx.inttoptr(usize_llval, ll_t_out)\n                             }\n-                            (CastTy::Int(_), CastTy::Float) =>\n-                                cast_int_to_float(&mut bx, signed, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(IntTy::I)) =>\n                                 cast_float_to_int(&mut bx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n@@ -720,40 +725,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n-fn cast_int_to_float<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    signed: bool,\n-    x: Bx::Value,\n-    int_ty: Bx::Type,\n-    float_ty: Bx::Type\n-) -> Bx::Value {\n-    // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n-    // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n-    // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n-    let is_u128_to_f32 = !signed &&\n-        bx.cx().int_width(int_ty) == 128 &&\n-        bx.cx().float_width(float_ty) == 32;\n-    if is_u128_to_f32 {\n-        // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n-        // and for everything else LLVM's uitofp works just fine.\n-        use rustc_apfloat::ieee::Single;\n-        const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n-                                            << (Single::MAX_EXP - Single::PRECISION as i16);\n-        let max = bx.cx().const_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n-        let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n-        let infinity_bits = bx.cx().const_u32(ieee::Single::INFINITY.to_bits() as u32);\n-        let infinity = bx.bitcast(infinity_bits, float_ty);\n-        let fp = bx.uitofp(x, float_ty);\n-        bx.select(overflow, infinity, fp)\n-    } else {\n-        if signed {\n-            bx.sitofp(x, float_ty)\n-        } else {\n-            bx.uitofp(x, float_ty)\n-        }\n-    }\n-}\n-\n fn cast_float_to_int<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     signed: bool,"}, {"sha": "55e647729e97f31397c71b9182d1e0998d2ee8d6", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 3, "deletions": 936, "changes": 939, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1,8 +1,8 @@\n-// ignore-tidy-filelength\n-\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command-line options.\n \n+pub use crate::options::*;\n+\n use crate::lint;\n use crate::utils::NativeLibraryKind;\n use crate::{early_error, early_warn, Session};\n@@ -11,7 +11,6 @@ use crate::search_paths::SearchPath;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::impl_stable_hash_via_hash;\n \n-use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n \n use syntax_pos::source_map::{FileName, FilePathMapping};\n@@ -31,8 +30,6 @@ use std::collections::btree_map::{\n };\n use std::fmt;\n use std::str::{self, FromStr};\n-use std::hash::Hasher;\n-use std::collections::hash_map::DefaultHasher;\n use std::iter::{self, FromIterator};\n use std::path::{Path, PathBuf};\n \n@@ -382,131 +379,6 @@ impl ExternEntry {\n     }\n }\n \n-macro_rules! hash_option {\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n-    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n-        if $sub_hashes.insert(stringify!($opt_name),\n-                              $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n-            panic!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n-        }\n-    });\n-}\n-\n-macro_rules! top_level_options {\n-    (pub struct Options { $(\n-        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n-    )* } ) => (\n-        #[derive(Clone)]\n-        pub struct Options {\n-            $(pub $opt: $t),*\n-        }\n-\n-        impl Options {\n-            pub fn dep_tracking_hash(&self) -> u64 {\n-                let mut sub_hashes = BTreeMap::new();\n-                $({\n-                    hash_option!($opt,\n-                                 &self.$opt,\n-                                 &mut sub_hashes,\n-                                 [$dep_tracking_marker $($warn_val,\n-                                                         $warn_text,\n-                                                         self.error_format)*]);\n-                })*\n-                let mut hasher = DefaultHasher::new();\n-                dep_tracking::stable_hash(sub_hashes,\n-                                          &mut hasher,\n-                                          self.error_format);\n-                hasher.finish()\n-            }\n-        }\n-    );\n-}\n-\n-// The top-level command-line options struct.\n-//\n-// For each option, one has to specify how it behaves with regard to the\n-// dependency tracking system of incremental compilation. This is done via the\n-// square-bracketed directive after the field type. The options are:\n-//\n-// [TRACKED]\n-// A change in the given field will cause the compiler to completely clear the\n-// incremental compilation cache before proceeding.\n-//\n-// [UNTRACKED]\n-// Incremental compilation is not influenced by this option.\n-//\n-// If you add a new option to this struct or one of the sub-structs like\n-// `CodegenOptions`, think about how it influences incremental compilation. If in\n-// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n-// unnecessary re-compilation.\n-top_level_options!(\n-    pub struct Options {\n-        // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process.\n-        crate_types: Vec<CrateType> [TRACKED],\n-        optimize: OptLevel [TRACKED],\n-        // Include the `debug_assertions` flag in dependency tracking, since it\n-        // can influence whether overflow checks are done or not.\n-        debug_assertions: bool [TRACKED],\n-        debuginfo: DebugInfo [TRACKED],\n-        lint_opts: Vec<(String, lint::Level)> [TRACKED],\n-        lint_cap: Option<lint::Level> [TRACKED],\n-        describe_lints: bool [UNTRACKED],\n-        output_types: OutputTypes [TRACKED],\n-        search_paths: Vec<SearchPath> [UNTRACKED],\n-        libs: Vec<(String, Option<String>, Option<NativeLibraryKind>)> [TRACKED],\n-        maybe_sysroot: Option<PathBuf> [UNTRACKED],\n-\n-        target_triple: TargetTriple [TRACKED],\n-\n-        test: bool [TRACKED],\n-        error_format: ErrorOutputType [UNTRACKED],\n-\n-        // If `Some`, enable incremental compilation, using the given\n-        // directory to store intermediate results.\n-        incremental: Option<PathBuf> [UNTRACKED],\n-\n-        debugging_opts: DebuggingOptions [TRACKED],\n-        prints: Vec<PrintRequest> [UNTRACKED],\n-        // Determines which borrow checker(s) to run. This is the parsed, sanitized\n-        // version of `debugging_opts.borrowck`, which is just a plain string.\n-        borrowck_mode: BorrowckMode [UNTRACKED],\n-        cg: CodegenOptions [TRACKED],\n-        externs: Externs [UNTRACKED],\n-        crate_name: Option<String> [TRACKED],\n-        // An optional name to use as the crate for std during std injection,\n-        // written `extern crate name as std`. Defaults to `std`. Used by\n-        // out-of-tree drivers.\n-        alt_std_name: Option<String> [TRACKED],\n-        // Indicates how the compiler should treat unstable features.\n-        unstable_features: UnstableFeatures [TRACKED],\n-\n-        // Indicates whether this run of the compiler is actually rustdoc. This\n-        // is currently just a hack and will be removed eventually, so please\n-        // try to not rely on this too much.\n-        actually_rustdoc: bool [TRACKED],\n-\n-        // Specifications of codegen units / ThinLTO which are forced as a\n-        // result of parsing command line options. These are not necessarily\n-        // what rustc was invoked with, but massaged a bit to agree with\n-        // commands like `--emit llvm-ir` which they're often incompatible with\n-        // if we otherwise use the defaults of rustc.\n-        cli_forced_codegen_units: Option<usize> [UNTRACKED],\n-        cli_forced_thinlto_off: bool [UNTRACKED],\n-\n-        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n-        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n-\n-        edition: Edition [TRACKED],\n-\n-        // `true` if we're emitting JSON blobs about each artifact produced\n-        // by the compiler.\n-        json_artifact_notifications: bool [TRACKED],\n-\n-        pretty: Option<PpMode> [UNTRACKED],\n-    }\n-);\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum PrintRequest {\n     FileNames,\n@@ -767,811 +639,6 @@ impl Passes {\n     }\n }\n \n-/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n-/// macro is to define an interface that can be programmatically used by the option parser\n-/// to initialize the struct without hardcoding field names all over the place.\n-///\n-/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n-/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n-/// generated code to parse an option into its respective field in the struct. There are a few\n-/// hand-written parsers for parsing specific types of values in this module.\n-macro_rules! options {\n-    ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n-     $buildfn:ident, $prefix:expr, $outputname:expr,\n-     $stat:ident, $mod_desc:ident, $mod_set:ident,\n-     $($opt:ident : $t:ty = (\n-        $init:expr,\n-        $parse:ident,\n-        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n-        $desc:expr)\n-     ),* ,) =>\n-(\n-    #[derive(Clone)]\n-    pub struct $struct_name { $(pub $opt: $t),* }\n-\n-    pub fn $defaultfn() -> $struct_name {\n-        $struct_name { $($opt: $init),* }\n-    }\n-\n-    pub fn $buildfn(matches: &getopts::Matches, error_format: ErrorOutputType) -> $struct_name\n-    {\n-        let mut op = $defaultfn();\n-        for option in matches.opt_strs($prefix) {\n-            let mut iter = option.splitn(2, '=');\n-            let key = iter.next().unwrap();\n-            let value = iter.next();\n-            let option_to_lookup = key.replace(\"-\", \"_\");\n-            let mut found = false;\n-            for &(candidate, setter, opt_type_desc, _) in $stat {\n-                if option_to_lookup != candidate { continue }\n-                if !setter(&mut op, value) {\n-                    match (value, opt_type_desc) {\n-                        (Some(..), None) => {\n-                            early_error(error_format, &format!(\"{} option `{}` takes no \\\n-                                                                value\", $outputname, key))\n-                        }\n-                        (None, Some(type_desc)) => {\n-                            early_error(error_format, &format!(\"{0} option `{1}` requires \\\n-                                                                {2} ({3} {1}=<value>)\",\n-                                                               $outputname, key,\n-                                                               type_desc, $prefix))\n-                        }\n-                        (Some(value), Some(type_desc)) => {\n-                            early_error(error_format, &format!(\"incorrect value `{}` for {} \\\n-                                                                option `{}` - {} was expected\",\n-                                                               value, $outputname,\n-                                                               key, type_desc))\n-                        }\n-                        (None, None) => panic!()\n-                    }\n-                }\n-                found = true;\n-                break;\n-            }\n-            if !found {\n-                early_error(error_format, &format!(\"unknown {} option: `{}`\",\n-                                                   $outputname, key));\n-            }\n-        }\n-        return op;\n-    }\n-\n-    impl dep_tracking::DepTrackingHash for $struct_name {\n-        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n-            let mut sub_hashes = BTreeMap::new();\n-            $({\n-                hash_option!($opt,\n-                             &self.$opt,\n-                             &mut sub_hashes,\n-                             [$dep_tracking_marker $($dep_warn_val,\n-                                                     $dep_warn_text,\n-                                                     error_format)*]);\n-            })*\n-            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n-        }\n-    }\n-\n-    pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n-    pub const $stat: &[(&str, $setter_name, Option<&str>, &str)] =\n-        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n-\n-    #[allow(non_upper_case_globals, dead_code)]\n-    mod $mod_desc {\n-        pub const parse_bool: Option<&str> = None;\n-        pub const parse_opt_bool: Option<&str> =\n-            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n-        pub const parse_string: Option<&str> = Some(\"a string\");\n-        pub const parse_string_push: Option<&str> = Some(\"a string\");\n-        pub const parse_pathbuf_push: Option<&str> = Some(\"a path\");\n-        pub const parse_opt_string: Option<&str> = Some(\"a string\");\n-        pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n-        pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n-        pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n-        pub const parse_opt_comma_list: Option<&str> = Some(\"a comma-separated list of strings\");\n-        pub const parse_threads: Option<&str> = Some(\"a number\");\n-        pub const parse_uint: Option<&str> = Some(\"a number\");\n-        pub const parse_passes: Option<&str> =\n-            Some(\"a space-separated list of passes, or `all`\");\n-        pub const parse_opt_uint: Option<&str> =\n-            Some(\"a number\");\n-        pub const parse_panic_strategy: Option<&str> =\n-            Some(\"either `unwind` or `abort`\");\n-        pub const parse_relro_level: Option<&str> =\n-            Some(\"one of: `full`, `partial`, or `off`\");\n-        pub const parse_sanitizer: Option<&str> =\n-            Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n-        pub const parse_sanitizer_list: Option<&str> =\n-            Some(\"comma separated list of sanitizers\");\n-        pub const parse_sanitizer_memory_track_origins: Option<&str> = None;\n-        pub const parse_linker_flavor: Option<&str> =\n-            Some(::rustc_target::spec::LinkerFlavor::one_of());\n-        pub const parse_optimization_fuel: Option<&str> =\n-            Some(\"crate=integer\");\n-        pub const parse_unpretty: Option<&str> =\n-            Some(\"`string` or `string=string`\");\n-        pub const parse_treat_err_as_bug: Option<&str> =\n-            Some(\"either no value or a number bigger than 0\");\n-        pub const parse_lto: Option<&str> =\n-            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n-                  `fat`, or omitted\");\n-        pub const parse_linker_plugin_lto: Option<&str> =\n-            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n-                  or the path to the linker plugin\");\n-        pub const parse_switch_with_opt_path: Option<&str> =\n-            Some(\"an optional path to the profiling data output directory\");\n-        pub const parse_merge_functions: Option<&str> =\n-            Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n-        pub const parse_symbol_mangling_version: Option<&str> =\n-            Some(\"either `legacy` or `v0` (RFC 2603)\");\n-    }\n-\n-    #[allow(dead_code)]\n-    mod $mod_set {\n-        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n-            SymbolManglingVersion};\n-        use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n-        use std::path::PathBuf;\n-        use std::str::FromStr;\n-\n-        $(\n-            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n-                $parse(&mut cg.$opt, v)\n-            }\n-        )*\n-\n-        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n-            match v {\n-                Some(..) => false,\n-                None => { *slot = true; true }\n-            }\n-        }\n-\n-        fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    match s {\n-                        \"n\" | \"no\" | \"off\" => {\n-                            *slot = Some(false);\n-                        }\n-                        \"y\" | \"yes\" | \"on\" => {\n-                            *slot = Some(true);\n-                        }\n-                        _ => { return false; }\n-                    }\n-\n-                    true\n-                },\n-                None => { *slot = Some(true); true }\n-            }\n-        }\n-\n-        fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(s.to_string()); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = Some(PathBuf::from(s)); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.to_string(); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { slot.push(s.to_string()); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_pathbuf_push(slot: &mut Vec<PathBuf>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { slot.push(PathBuf::from(s)); true },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    slot.extend(s.split_whitespace().map(|s| s.to_string()));\n-                    true\n-                },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_opt_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    let v = s.split_whitespace().map(|s| s.to_string()).collect();\n-                    *slot = Some(v);\n-                    true\n-                },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n-                      -> bool {\n-            match v {\n-                Some(s) => {\n-                    let v = s.split(',').map(|s| s.to_string()).collect();\n-                    *slot = Some(v);\n-                    true\n-                },\n-                None => false,\n-            }\n-        }\n-\n-        fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse().ok()) {\n-                Some(0) => { *slot = ::num_cpus::get(); true },\n-                Some(i) => { *slot = i; true },\n-                None => false\n-            }\n-        }\n-\n-        fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.and_then(|s| s.parse().ok()) {\n-                Some(i) => { *slot = i; true },\n-                None => false\n-            }\n-        }\n-\n-        fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n-                None => { *slot = None; false }\n-            }\n-        }\n-\n-        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"all\") => {\n-                    *slot = Passes::All;\n-                    true\n-                }\n-                v => {\n-                    let mut passes = vec![];\n-                    if parse_list(&mut passes, v) {\n-                        *slot = Passes::Some(passes);\n-                        true\n-                    } else {\n-                        false\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n-                Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n-                _ => return false\n-            }\n-            true\n-        }\n-\n-        fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => {\n-                    match s.parse::<RelroLevel>() {\n-                        Ok(level) => *slot = Some(level),\n-                        _ => return false\n-                    }\n-                },\n-                _ => return false\n-            }\n-            true\n-        }\n-\n-        fn parse_sanitizer(slot: &mut Option<Sanitizer>, v: Option<&str>) -> bool {\n-            if let Some(Ok(s)) =  v.map(str::parse) {\n-                *slot = Some(s);\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n-        fn parse_sanitizer_list(slot: &mut Vec<Sanitizer>, v: Option<&str>) -> bool {\n-            if let Some(v) = v {\n-                for s in v.split(',').map(str::parse) {\n-                    if let Ok(s) = s {\n-                        if !slot.contains(&s) {\n-                            slot.push(s);\n-                        }\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n-        fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n-            match v.map(|s| s.parse()) {\n-                None => {\n-                    *slot = 2;\n-                    true\n-                }\n-                Some(Ok(i)) if i <= 2 => {\n-                    *slot = i;\n-                    true\n-                }\n-                _ => {\n-                    false\n-                }\n-            }\n-        }\n-\n-        fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n-            match v.and_then(LinkerFlavor::from_str) {\n-                Some(lf) => *slote = Some(lf),\n-                _ => return false,\n-            }\n-            true\n-        }\n-\n-        fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n-            match v {\n-                None => false,\n-                Some(s) => {\n-                    let parts = s.split('=').collect::<Vec<_>>();\n-                    if parts.len() != 2 { return false; }\n-                    let crate_name = parts[0].to_string();\n-                    let fuel = parts[1].parse::<u64>();\n-                    if fuel.is_err() { return false; }\n-                    *slot = Some((crate_name, fuel.unwrap()));\n-                    true\n-                }\n-            }\n-        }\n-\n-        fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n-            match v {\n-                None => false,\n-                Some(s) if s.split('=').count() <= 2 => {\n-                    *slot = Some(s.to_string());\n-                    true\n-                }\n-                _ => false,\n-            }\n-        }\n-\n-        fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n-            match v {\n-                Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n-                None => { *slot = Some(1); true }\n-            }\n-        }\n-\n-        fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        LtoCli::Yes\n-                    } else {\n-                        LtoCli::No\n-                    };\n-                    return true\n-                }\n-            }\n-\n-            *slot = match v {\n-                None => LtoCli::NoParam,\n-                Some(\"thin\") => LtoCli::Thin,\n-                Some(\"fat\") => LtoCli::Fat,\n-                Some(_) => return false,\n-            };\n-            true\n-        }\n-\n-        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n-            if v.is_some() {\n-                let mut bool_arg = None;\n-                if parse_opt_bool(&mut bool_arg, v) {\n-                    *slot = if bool_arg.unwrap() {\n-                        LinkerPluginLto::LinkerPluginAuto\n-                    } else {\n-                        LinkerPluginLto::Disabled\n-                    };\n-                    return true\n-                }\n-            }\n-\n-            *slot = match v {\n-                None => LinkerPluginLto::LinkerPluginAuto,\n-                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n-            };\n-            true\n-        }\n-\n-        fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n-            *slot = match v {\n-                None => SwitchWithOptPath::Enabled(None),\n-                Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n-            };\n-            true\n-        }\n-\n-        fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n-            match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n-                Some(mergefunc) => *slot = Some(mergefunc),\n-                _ => return false,\n-            }\n-            true\n-        }\n-\n-        fn parse_symbol_mangling_version(\n-            slot: &mut SymbolManglingVersion,\n-            v: Option<&str>,\n-        ) -> bool {\n-            *slot = match v {\n-                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n-                Some(\"v0\") => SymbolManglingVersion::V0,\n-                _ => return false,\n-            };\n-            true\n-        }\n-    }\n-) }\n-\n-options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n-          build_codegen_options, \"C\", \"codegen\",\n-          CG_OPTIONS, cg_type_desc, cgsetters,\n-    ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"this option is deprecated and does nothing\"),\n-    linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n-        \"system linker to link outputs with\"),\n-    link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n-        \"a single extra argument to append to the linker invocation (can be used several times)\"),\n-    link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n-        \"extra arguments to append to the linker invocation (space separated)\"),\n-    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n-        \"perform LLVM link-time optimizations\"),\n-    target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"select target processor (`rustc --print target-cpus` for details)\"),\n-    target_feature: String = (String::new(), parse_string, [TRACKED],\n-        \"target specific attributes. (`rustc --print target-features` for details). \\\n-        This feature is unsafe.\"),\n-    passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n-        \"a list of extra LLVM passes to run (space separated)\"),\n-    llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n-        \"a list of arguments to pass to LLVM (space separated)\"),\n-    save_temps: bool = (false, parse_bool, [UNTRACKED],\n-        \"save all temporary output files during compilation\"),\n-    rpath: bool = (false, parse_bool, [UNTRACKED],\n-        \"set rpath values in libs/exes\"),\n-    overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"use overflow checks for integer arithmetic\"),\n-    no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n-        \"don't pre-populate the pass manager with a list of passes\"),\n-    no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n-        \"don't run the loop vectorization optimization passes\"),\n-    no_vectorize_slp: bool = (false, parse_bool, [TRACKED],\n-        \"don't run LLVM's SLP vectorization pass\"),\n-    soft_float: bool = (false, parse_bool, [TRACKED],\n-        \"use soft float ABI (*eabihf targets only)\"),\n-    prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n-        \"prefer dynamic linking to static linking\"),\n-    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n-        \"use an external assembler rather than LLVM's integrated one\"),\n-    no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"disable the use of the redzone\"),\n-    relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"choose the relocation model to use (`rustc --print relocation-models` for details)\"),\n-    code_model: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"choose the code model to use (`rustc --print code-models` for details)\"),\n-    metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n-        \"metadata to mangle symbol names with\"),\n-    extra_filename: String = (String::new(), parse_string, [UNTRACKED],\n-        \"extra data to put in each output filename\"),\n-    codegen_units: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n-        \"divide crate into N units to optimize in parallel\"),\n-    remark: Passes = (Passes::Some(Vec::new()), parse_passes, [UNTRACKED],\n-        \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n-    no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n-        \"the `--no-stack-check` flag is deprecated and does nothing\"),\n-    debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n-        \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n-         2 = full debug info with variable and type information\"),\n-    opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"optimize with possible levels 0-3, s, or z\"),\n-    force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"force use of the frame pointers\"),\n-    debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"explicitly enable the `cfg(debug_assertions)` directive\"),\n-    inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n-        \"set the threshold for inlining a function (default: 225)\"),\n-    panic: Option<PanicStrategy> = (None, parse_panic_strategy,\n-        [TRACKED], \"panic strategy to compile crate with\"),\n-    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"enable incremental compilation\"),\n-    default_linker_libraries: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n-        \"allow the linker to link its default libraries\"),\n-    linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n-                                           \"linker flavor\"),\n-    linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n-        parse_linker_plugin_lto, [TRACKED],\n-        \"generate build artifacts that are compatible with linker-based LTO.\"),\n-    profile_generate: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n-        parse_switch_with_opt_path, [TRACKED],\n-        \"compile the program with profiling instrumentation\"),\n-    profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n-        \"use the given `.profdata` file for profile-guided optimization\"),\n-}\n-\n-options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n-          build_debugging_options, \"Z\", \"debugging\",\n-          DB_OPTIONS, db_type_desc, dbsetters,\n-    codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"the backend to use\"),\n-    verbose: bool = (false, parse_bool, [UNTRACKED],\n-        \"in general, enable more debug printouts\"),\n-    span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n-        \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n-    identify_regions: bool = (false, parse_bool, [UNTRACKED],\n-        \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n-    borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"select which borrowck is used (`mir` or `migrate`)\"),\n-    time_passes: bool = (false, parse_bool, [UNTRACKED],\n-        \"measure time of each rustc pass\"),\n-    time: bool = (false, parse_bool, [UNTRACKED],\n-        \"measure time of rustc processes\"),\n-    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n-        \"measure time of each LLVM pass\"),\n-    input_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"gather statistics about the input\"),\n-    asm_comments: bool = (false, parse_bool, [TRACKED],\n-        \"generate comments into the assembly (may change behavior)\"),\n-    verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n-        \"verify LLVM IR\"),\n-    borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"gather borrowck statistics\"),\n-    no_landing_pads: bool = (false, parse_bool, [TRACKED],\n-        \"omit landing pads for unwinding\"),\n-    fewer_names: bool = (false, parse_bool, [TRACKED],\n-        \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR)\"),\n-    meta_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"gather metadata statistics\"),\n-    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the arguments passed to the linker\"),\n-    print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n-        \"prints the LLVM optimization passes being run\"),\n-    ast_json: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the AST as JSON and halt\"),\n-    // We default to 1 here since we want to behave like\n-    // a sequential compiler for now. This'll likely be adjusted\n-    // in the future. Note that -Zthreads=0 is the way to get\n-    // the num_cpus behavior.\n-    threads: usize = (1, parse_threads, [UNTRACKED],\n-        \"use a thread pool with N threads\"),\n-    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n-        \"print the pre-expansion AST as JSON and halt\"),\n-    ls: bool = (false, parse_bool, [UNTRACKED],\n-        \"list the symbols defined by a library crate\"),\n-    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in JSON format) information, in \\\n-         addition to normal output\"),\n-    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"prints region inference graph. \\\n-         Use with RUST_REGION_GRAPH=help for more info\"),\n-    parse_only: bool = (false, parse_bool, [UNTRACKED],\n-        \"parse only; do not compile, assemble, or link\"),\n-    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n-        \"load proc macros for both target and host, but only link to the target\"),\n-    no_codegen: bool = (false, parse_bool, [TRACKED],\n-        \"run all passes except codegen; no output\"),\n-    treat_err_as_bug: Option<usize> = (None, parse_treat_err_as_bug, [TRACKED],\n-        \"treat error number `val` that occurs as bug\"),\n-    report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n-        \"immediately print bugs registered with `delay_span_bug`\"),\n-    external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n-        \"show macro backtraces even for non-local macros\"),\n-    teach: bool = (false, parse_bool, [TRACKED],\n-        \"show extended diagnostic help\"),\n-    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n-        \"set the current terminal width\"),\n-    panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n-        \"support compiling tests with panic=abort\"),\n-    continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n-        \"attempt to recover from parse errors (experimental)\"),\n-    dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n-        \"print tasks that execute and the color their dep node gets (requires debug build)\"),\n-    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"enable incremental compilation (experimental)\"),\n-    incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n-        \"enable incremental compilation support for queries (experimental)\"),\n-    incremental_info: bool = (false, parse_bool, [UNTRACKED],\n-        \"print high-level information about incremental reuse (or the lack thereof)\"),\n-    incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n-        \"dump hash information in textual format to stdout\"),\n-    incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n-        \"verify incr. comp. hashes of green query instances\"),\n-    incremental_ignore_spans: bool = (false, parse_bool, [UNTRACKED],\n-        \"ignore spans during ICH computation -- used for testing\"),\n-    instrument_mcount: bool = (false, parse_bool, [TRACKED],\n-        \"insert function instrument code for mcount-based tracing\"),\n-    dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n-    query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"enable queries of the dependency graph for regression testing\"),\n-    no_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"parse and expand the source, but run no analysis\"),\n-    unstable_options: bool = (false, parse_bool, [UNTRACKED],\n-        \"adds unstable command line options to rustc interface\"),\n-    force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"force overflow checks on or off\"),\n-    trace_macros: bool = (false, parse_bool, [UNTRACKED],\n-        \"for every macro invocation, print its name and arguments\"),\n-    debug_macros: bool = (false, parse_bool, [TRACKED],\n-        \"emit line numbers debug info inside macros\"),\n-    generate_arange_section: bool = (true, parse_bool, [TRACKED],\n-        \"generate DWARF address ranges for faster lookups\"),\n-    keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't clear the hygiene data after analysis\"),\n-    keep_ast: bool = (false, parse_bool, [UNTRACKED],\n-        \"keep the AST after lowering it to HIR\"),\n-    show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"show spans for compiler debugging (expr|pat|ty)\"),\n-    print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n-        \"print layout information for each type encountered\"),\n-    print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"print the result of the monomorphization collection pass\"),\n-    mir_opt_level: usize = (1, parse_uint, [TRACKED],\n-        \"set the MIR optimization level (0-3, default: 1)\"),\n-    mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"emit noalias metadata for mutable references (default: no)\"),\n-    dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"dump MIR state to file.\n-        `val` is used to select which passes and functions to dump. For example:\n-        `all` matches all passes and functions,\n-        `foo` matches all passes for functions whose name contains 'foo',\n-        `foo & ConstProp` only the 'ConstProp' pass for function names containing 'foo',\n-        `foo | bar` all passes for function names containing 'foo' or 'bar'.\"),\n-\n-    dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n-        \"the directory the MIR is dumped into\"),\n-    dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n-        \"in addition to `.mir` files, create graphviz `.dot` files\"),\n-    dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n-        \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n-    mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n-        \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0\"),\n-    perf_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some performance-related statistics\"),\n-    query_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some statistics about the query system\"),\n-    hir_stats: bool = (false, parse_bool, [UNTRACKED],\n-        \"print some statistics about AST and HIR\"),\n-    always_encode_mir: bool = (false, parse_bool, [TRACKED],\n-        \"encode MIR of all functions into the crate metadata\"),\n-    json_rendered: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"describes how to render the `rendered` field of json diagnostics\"),\n-    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n-        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n-    osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n-        \"pass `-install_name @rpath/...` to the macOS linker\"),\n-    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n-                                    \"use a sanitizer\"),\n-    sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],\n-        \"Enable recovery for selected sanitizers\"),\n-    sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n-        \"Enable origins tracking in MemorySanitizer\"),\n-    fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n-        \"set the optimization fuel quota for a crate\"),\n-    print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"make rustc print the total optimization fuel used by a crate\"),\n-    force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n-        \"force all crates to be `rustc_private` unstable\"),\n-    pre_link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n-        \"a single extra argument to prepend the linker invocation (can be used several times)\"),\n-    pre_link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n-        \"extra arguments to prepend to the linker invocation (space separated)\"),\n-    profile: bool = (false, parse_bool, [TRACKED],\n-                     \"insert profiling code\"),\n-    disable_instrumentation_preinliner: bool = (false, parse_bool, [TRACKED],\n-        \"Disable the instrumentation pre-inliner, useful for profiling / PGO.\"),\n-    relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n-        \"choose which RELRO level to use\"),\n-    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n-                       \"dump facts from NLL analysis into side files\"),\n-    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n-        \"in match codegen, do not include FakeRead statements (used by mir-borrowck)\"),\n-    dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n-        \"emit diagnostics rather than buffering (breaks NLL error downgrading, sorting).\"),\n-    polonius: bool = (false, parse_bool, [UNTRACKED],\n-        \"enable polonius-based borrow-checker\"),\n-    codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n-    thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"enable ThinLTO when possible\"),\n-    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"control whether `#[inline]` functions are in all CGUs\"),\n-    tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n-    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n-        \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n-         the max/min integer respectively, and NaN is mapped to 0\"),\n-    human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],\n-        \"generate human-readable, predictable names for codegen units\"),\n-    dep_info_omit_d_target: bool = (false, parse_bool, [TRACKED],\n-        \"in dep-info output, omit targets for tracking dependencies of the dep-info files \\\n-         themselves\"),\n-    unpretty: Option<String> = (None, parse_unpretty, [UNTRACKED],\n-        \"present the input source, unstable (and less-pretty) variants;\n-        valid types are any of the types for `--pretty`, as well as:\n-        `expanded`, `expanded,identified`,\n-        `expanded,hygiene` (with internal representations),\n-        `everybody_loops` (all function bodies replaced with `loop {}`),\n-        `hir` (the HIR), `hir,identified`,\n-        `hir,typed` (HIR with types for each node),\n-        `hir-tree` (dump the raw HIR),\n-        `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\"),\n-    run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"run `dsymutil` and delete intermediate object files\"),\n-    ui_testing: bool = (false, parse_bool, [UNTRACKED],\n-        \"format compiler diagnostics in a way that's better suitable for UI testing\"),\n-    embed_bitcode: bool = (false, parse_bool, [TRACKED],\n-        \"embed LLVM bitcode in object files\"),\n-    strip_debuginfo_if_disabled: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n-    share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-        \"make the current crate share its generic instantiations\"),\n-    chalk: bool = (false, parse_bool, [TRACKED],\n-        \"enable the experimental Chalk-based trait solving engine\"),\n-    no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n-    no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n-        \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n-    no_interleave_lints: bool = (false, parse_bool, [UNTRACKED],\n-        \"don't interleave execution of lints; allows benchmarking individual lints\"),\n-    crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n-        \"inject the given attribute in the crate\"),\n-    self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n-        parse_switch_with_opt_path, [UNTRACKED],\n-        \"run the self profiler and output the raw event data\"),\n-    self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n-        \"specifies which kinds of events get recorded by the self profiler\"),\n-    emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n-        \"emits a section containing stack size metadata\"),\n-    plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n-          \"whether to use the PLT when calling into shared libraries;\n-          only has effect for PIC code on systems with ELF binaries\n-          (default: PLT is disabled if full relro is enabled)\"),\n-    merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n-        \"control the operation of the MergeFunctions LLVM pass, taking\n-         the same values as the target option of the same name\"),\n-    allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n-        \"only allow the listed language features to be enabled in code (space separated)\"),\n-    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n-        parse_symbol_mangling_version, [TRACKED],\n-        \"which mangling version to use for symbol names\"),\n-    binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n-        \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info\"),\n-    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n-        \"fix undefined behavior when a thread doesn't eventually make progress \\\n-         (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n-}\n-\n pub const fn default_lib_output() -> CrateType {\n     CrateType::Rlib\n }\n@@ -2953,7 +2020,7 @@ impl PpMode {\n /// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n-mod dep_tracking {\n+crate mod dep_tracking {\n     use crate::lint;\n     use crate::utils::NativeLibraryKind;\n     use std::collections::BTreeMap;"}, {"sha": "39e997a3b91accf3d2345cb212c60b5f5f03bd7a", "filename": "src/librustc_session/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_session%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_session%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flib.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1,3 +1,4 @@\n+#![feature(crate_visibility_modifier)]\n #![feature(test)]\n \n // Use the test crate here so we depend on getopts through it. This allow tools to link to both\n@@ -13,7 +14,9 @@ pub mod node_id;\n pub mod parse;\n \n mod code_stats;\n+#[macro_use]\n pub mod config;\n+mod options;\n pub mod filesearch;\n pub mod search_paths;\n "}, {"sha": "9ddc9c0d602af4967fdc208514c1f1837baaa70d", "filename": "src/librustc_session/options.rs", "status": "added", "additions": 951, "deletions": 0, "changes": 951, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -0,0 +1,951 @@\n+use crate::config::*;\n+\n+use crate::lint;\n+use crate::utils::NativeLibraryKind;\n+use crate::early_error;\n+use crate::search_paths::SearchPath;\n+\n+use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n+use rustc_target::spec::TargetTriple;\n+\n+use syntax_pos::edition::Edition;\n+use rustc_feature::UnstableFeatures;\n+\n+use getopts;\n+\n+use std::collections::BTreeMap;\n+\n+use std::str;\n+use std::hash::Hasher;\n+use std::collections::hash_map::DefaultHasher;\n+use std::path::PathBuf;\n+\n+macro_rules! hash_option {\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [UNTRACKED]) => ({});\n+    ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n+        if $sub_hashes.insert(stringify!($opt_name),\n+                              $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n+            panic!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+        }\n+    });\n+}\n+\n+macro_rules! top_level_options {\n+    (pub struct Options { $(\n+        $opt:ident : $t:ty [$dep_tracking_marker:ident $($warn_val:expr, $warn_text:expr)*],\n+    )* } ) => (\n+        #[derive(Clone)]\n+        pub struct Options {\n+            $(pub $opt: $t),*\n+        }\n+\n+        impl Options {\n+            pub fn dep_tracking_hash(&self) -> u64 {\n+                let mut sub_hashes = BTreeMap::new();\n+                $({\n+                    hash_option!($opt,\n+                                 &self.$opt,\n+                                 &mut sub_hashes,\n+                                 [$dep_tracking_marker $($warn_val,\n+                                                         $warn_text,\n+                                                         self.error_format)*]);\n+                })*\n+                let mut hasher = DefaultHasher::new();\n+                dep_tracking::stable_hash(sub_hashes,\n+                                          &mut hasher,\n+                                          self.error_format);\n+                hasher.finish()\n+            }\n+        }\n+    );\n+}\n+\n+// The top-level command-line options struct.\n+//\n+// For each option, one has to specify how it behaves with regard to the\n+// dependency tracking system of incremental compilation. This is done via the\n+// square-bracketed directive after the field type. The options are:\n+//\n+// [TRACKED]\n+// A change in the given field will cause the compiler to completely clear the\n+// incremental compilation cache before proceeding.\n+//\n+// [UNTRACKED]\n+// Incremental compilation is not influenced by this option.\n+//\n+// If you add a new option to this struct or one of the sub-structs like\n+// `CodegenOptions`, think about how it influences incremental compilation. If in\n+// doubt, specify [TRACKED], which is always \"correct\" but might lead to\n+// unnecessary re-compilation.\n+top_level_options!(\n+    pub struct Options {\n+        // The crate config requested for the session, which may be combined\n+        // with additional crate configurations during the compile process.\n+        crate_types: Vec<CrateType> [TRACKED],\n+        optimize: OptLevel [TRACKED],\n+        // Include the `debug_assertions` flag in dependency tracking, since it\n+        // can influence whether overflow checks are done or not.\n+        debug_assertions: bool [TRACKED],\n+        debuginfo: DebugInfo [TRACKED],\n+        lint_opts: Vec<(String, lint::Level)> [TRACKED],\n+        lint_cap: Option<lint::Level> [TRACKED],\n+        describe_lints: bool [UNTRACKED],\n+        output_types: OutputTypes [TRACKED],\n+        search_paths: Vec<SearchPath> [UNTRACKED],\n+        libs: Vec<(String, Option<String>, Option<NativeLibraryKind>)> [TRACKED],\n+        maybe_sysroot: Option<PathBuf> [UNTRACKED],\n+\n+        target_triple: TargetTriple [TRACKED],\n+\n+        test: bool [TRACKED],\n+        error_format: ErrorOutputType [UNTRACKED],\n+\n+        // If `Some`, enable incremental compilation, using the given\n+        // directory to store intermediate results.\n+        incremental: Option<PathBuf> [UNTRACKED],\n+\n+        debugging_opts: DebuggingOptions [TRACKED],\n+        prints: Vec<PrintRequest> [UNTRACKED],\n+        // Determines which borrow checker(s) to run. This is the parsed, sanitized\n+        // version of `debugging_opts.borrowck`, which is just a plain string.\n+        borrowck_mode: BorrowckMode [UNTRACKED],\n+        cg: CodegenOptions [TRACKED],\n+        externs: Externs [UNTRACKED],\n+        crate_name: Option<String> [TRACKED],\n+        // An optional name to use as the crate for std during std injection,\n+        // written `extern crate name as std`. Defaults to `std`. Used by\n+        // out-of-tree drivers.\n+        alt_std_name: Option<String> [TRACKED],\n+        // Indicates how the compiler should treat unstable features.\n+        unstable_features: UnstableFeatures [TRACKED],\n+\n+        // Indicates whether this run of the compiler is actually rustdoc. This\n+        // is currently just a hack and will be removed eventually, so please\n+        // try to not rely on this too much.\n+        actually_rustdoc: bool [TRACKED],\n+\n+        // Specifications of codegen units / ThinLTO which are forced as a\n+        // result of parsing command line options. These are not necessarily\n+        // what rustc was invoked with, but massaged a bit to agree with\n+        // commands like `--emit llvm-ir` which they're often incompatible with\n+        // if we otherwise use the defaults of rustc.\n+        cli_forced_codegen_units: Option<usize> [UNTRACKED],\n+        cli_forced_thinlto_off: bool [UNTRACKED],\n+\n+        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n+        remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n+\n+        edition: Edition [TRACKED],\n+\n+        // `true` if we're emitting JSON blobs about each artifact produced\n+        // by the compiler.\n+        json_artifact_notifications: bool [TRACKED],\n+\n+        pretty: Option<PpMode> [UNTRACKED],\n+    }\n+);\n+\n+/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n+/// macro is to define an interface that can be programmatically used by the option parser\n+/// to initialize the struct without hardcoding field names all over the place.\n+///\n+/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n+/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n+/// generated code to parse an option into its respective field in the struct. There are a few\n+/// hand-written parsers for parsing specific types of values in this module.\n+macro_rules! options {\n+    ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n+     $buildfn:ident, $prefix:expr, $outputname:expr,\n+     $stat:ident, $mod_desc:ident, $mod_set:ident,\n+     $($opt:ident : $t:ty = (\n+        $init:expr,\n+        $parse:ident,\n+        [$dep_tracking_marker:ident $(($dep_warn_val:expr, $dep_warn_text:expr))*],\n+        $desc:expr)\n+     ),* ,) =>\n+(\n+    #[derive(Clone)]\n+    pub struct $struct_name { $(pub $opt: $t),* }\n+\n+    pub fn $defaultfn() -> $struct_name {\n+        $struct_name { $($opt: $init),* }\n+    }\n+\n+    pub fn $buildfn(matches: &getopts::Matches, error_format: ErrorOutputType) -> $struct_name\n+    {\n+        let mut op = $defaultfn();\n+        for option in matches.opt_strs($prefix) {\n+            let mut iter = option.splitn(2, '=');\n+            let key = iter.next().unwrap();\n+            let value = iter.next();\n+            let option_to_lookup = key.replace(\"-\", \"_\");\n+            let mut found = false;\n+            for &(candidate, setter, opt_type_desc, _) in $stat {\n+                if option_to_lookup != candidate { continue }\n+                if !setter(&mut op, value) {\n+                    match (value, opt_type_desc) {\n+                        (Some(..), None) => {\n+                            early_error(error_format, &format!(\"{} option `{}` takes no \\\n+                                                                value\", $outputname, key))\n+                        }\n+                        (None, Some(type_desc)) => {\n+                            early_error(error_format, &format!(\"{0} option `{1}` requires \\\n+                                                                {2} ({3} {1}=<value>)\",\n+                                                               $outputname, key,\n+                                                               type_desc, $prefix))\n+                        }\n+                        (Some(value), Some(type_desc)) => {\n+                            early_error(error_format, &format!(\"incorrect value `{}` for {} \\\n+                                                                option `{}` - {} was expected\",\n+                                                               value, $outputname,\n+                                                               key, type_desc))\n+                        }\n+                        (None, None) => panic!()\n+                    }\n+                }\n+                found = true;\n+                break;\n+            }\n+            if !found {\n+                early_error(error_format, &format!(\"unknown {} option: `{}`\",\n+                                                   $outputname, key));\n+            }\n+        }\n+        return op;\n+    }\n+\n+    impl dep_tracking::DepTrackingHash for $struct_name {\n+        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+            let mut sub_hashes = BTreeMap::new();\n+            $({\n+                hash_option!($opt,\n+                             &self.$opt,\n+                             &mut sub_hashes,\n+                             [$dep_tracking_marker $($dep_warn_val,\n+                                                     $dep_warn_text,\n+                                                     error_format)*]);\n+            })*\n+            dep_tracking::stable_hash(sub_hashes, hasher, error_format);\n+        }\n+    }\n+\n+    pub type $setter_name = fn(&mut $struct_name, v: Option<&str>) -> bool;\n+    pub const $stat: &[(&str, $setter_name, Option<&str>, &str)] =\n+        &[ $( (stringify!($opt), $mod_set::$opt, $mod_desc::$parse, $desc) ),* ];\n+\n+    #[allow(non_upper_case_globals, dead_code)]\n+    mod $mod_desc {\n+        pub const parse_bool: Option<&str> = None;\n+        pub const parse_opt_bool: Option<&str> =\n+            Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n+        pub const parse_string: Option<&str> = Some(\"a string\");\n+        pub const parse_string_push: Option<&str> = Some(\"a string\");\n+        pub const parse_pathbuf_push: Option<&str> = Some(\"a path\");\n+        pub const parse_opt_string: Option<&str> = Some(\"a string\");\n+        pub const parse_opt_pathbuf: Option<&str> = Some(\"a path\");\n+        pub const parse_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_list: Option<&str> = Some(\"a space-separated list of strings\");\n+        pub const parse_opt_comma_list: Option<&str> = Some(\"a comma-separated list of strings\");\n+        pub const parse_threads: Option<&str> = Some(\"a number\");\n+        pub const parse_uint: Option<&str> = Some(\"a number\");\n+        pub const parse_passes: Option<&str> =\n+            Some(\"a space-separated list of passes, or `all`\");\n+        pub const parse_opt_uint: Option<&str> =\n+            Some(\"a number\");\n+        pub const parse_panic_strategy: Option<&str> =\n+            Some(\"either `unwind` or `abort`\");\n+        pub const parse_relro_level: Option<&str> =\n+            Some(\"one of: `full`, `partial`, or `off`\");\n+        pub const parse_sanitizer: Option<&str> =\n+            Some(\"one of: `address`, `leak`, `memory` or `thread`\");\n+        pub const parse_sanitizer_list: Option<&str> =\n+            Some(\"comma separated list of sanitizers\");\n+        pub const parse_sanitizer_memory_track_origins: Option<&str> = None;\n+        pub const parse_linker_flavor: Option<&str> =\n+            Some(::rustc_target::spec::LinkerFlavor::one_of());\n+        pub const parse_optimization_fuel: Option<&str> =\n+            Some(\"crate=integer\");\n+        pub const parse_unpretty: Option<&str> =\n+            Some(\"`string` or `string=string`\");\n+        pub const parse_treat_err_as_bug: Option<&str> =\n+            Some(\"either no value or a number bigger than 0\");\n+        pub const parse_lto: Option<&str> =\n+            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, \\\n+                  `fat`, or omitted\");\n+        pub const parse_linker_plugin_lto: Option<&str> =\n+            Some(\"either a boolean (`yes`, `no`, `on`, `off`, etc), \\\n+                  or the path to the linker plugin\");\n+        pub const parse_switch_with_opt_path: Option<&str> =\n+            Some(\"an optional path to the profiling data output directory\");\n+        pub const parse_merge_functions: Option<&str> =\n+            Some(\"one of: `disabled`, `trampolines`, or `aliases`\");\n+        pub const parse_symbol_mangling_version: Option<&str> =\n+            Some(\"either `legacy` or `v0` (RFC 2603)\");\n+    }\n+\n+    #[allow(dead_code)]\n+    mod $mod_set {\n+        use super::{$struct_name, Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n+            SymbolManglingVersion};\n+        use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n+        use std::path::PathBuf;\n+        use std::str::FromStr;\n+\n+        $(\n+            pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n+                $parse(&mut cg.$opt, v)\n+            }\n+        )*\n+\n+        fn parse_bool(slot: &mut bool, v: Option<&str>) -> bool {\n+            match v {\n+                Some(..) => false,\n+                None => { *slot = true; true }\n+            }\n+        }\n+\n+        fn parse_opt_bool(slot: &mut Option<bool>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    match s {\n+                        \"n\" | \"no\" | \"off\" => {\n+                            *slot = Some(false);\n+                        }\n+                        \"y\" | \"yes\" | \"on\" => {\n+                            *slot = Some(true);\n+                        }\n+                        _ => { return false; }\n+                    }\n+\n+                    true\n+                },\n+                None => { *slot = Some(true); true }\n+            }\n+        }\n+\n+        fn parse_opt_string(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = Some(s.to_string()); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = Some(PathBuf::from(s)); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.to_string(); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_string_push(slot: &mut Vec<String>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { slot.push(s.to_string()); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_pathbuf_push(slot: &mut Vec<PathBuf>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { slot.push(PathBuf::from(s)); true },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    slot.extend(s.split_whitespace().map(|s| s.to_string()));\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_opt_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.split_whitespace().map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_opt_comma_list(slot: &mut Option<Vec<String>>, v: Option<&str>)\n+                      -> bool {\n+            match v {\n+                Some(s) => {\n+                    let v = s.split(',').map(|s| s.to_string()).collect();\n+                    *slot = Some(v);\n+                    true\n+                },\n+                None => false,\n+            }\n+        }\n+\n+        fn parse_threads(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.and_then(|s| s.parse().ok()) {\n+                Some(0) => { *slot = ::num_cpus::get(); true },\n+                Some(i) => { *slot = i; true },\n+                None => false\n+            }\n+        }\n+\n+        fn parse_uint(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.and_then(|s| s.parse().ok()) {\n+                Some(i) => { *slot = i; true },\n+                None => false\n+            }\n+        }\n+\n+        fn parse_opt_uint(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.parse().ok(); slot.is_some() }\n+                None => { *slot = None; false }\n+            }\n+        }\n+\n+        fn parse_passes(slot: &mut Passes, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"all\") => {\n+                    *slot = Passes::All;\n+                    true\n+                }\n+                v => {\n+                    let mut passes = vec![];\n+                    if parse_list(&mut passes, v) {\n+                        *slot = Passes::Some(passes);\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn parse_panic_strategy(slot: &mut Option<PanicStrategy>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(\"unwind\") => *slot = Some(PanicStrategy::Unwind),\n+                Some(\"abort\") => *slot = Some(PanicStrategy::Abort),\n+                _ => return false\n+            }\n+            true\n+        }\n+\n+        fn parse_relro_level(slot: &mut Option<RelroLevel>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => {\n+                    match s.parse::<RelroLevel>() {\n+                        Ok(level) => *slot = Some(level),\n+                        _ => return false\n+                    }\n+                },\n+                _ => return false\n+            }\n+            true\n+        }\n+\n+        fn parse_sanitizer(slot: &mut Option<Sanitizer>, v: Option<&str>) -> bool {\n+            if let Some(Ok(s)) =  v.map(str::parse) {\n+                *slot = Some(s);\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn parse_sanitizer_list(slot: &mut Vec<Sanitizer>, v: Option<&str>) -> bool {\n+            if let Some(v) = v {\n+                for s in v.split(',').map(str::parse) {\n+                    if let Ok(s) = s {\n+                        if !slot.contains(&s) {\n+                            slot.push(s);\n+                        }\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn parse_sanitizer_memory_track_origins(slot: &mut usize, v: Option<&str>) -> bool {\n+            match v.map(|s| s.parse()) {\n+                None => {\n+                    *slot = 2;\n+                    true\n+                }\n+                Some(Ok(i)) if i <= 2 => {\n+                    *slot = i;\n+                    true\n+                }\n+                _ => {\n+                    false\n+                }\n+            }\n+        }\n+\n+        fn parse_linker_flavor(slote: &mut Option<LinkerFlavor>, v: Option<&str>) -> bool {\n+            match v.and_then(LinkerFlavor::from_str) {\n+                Some(lf) => *slote = Some(lf),\n+                _ => return false,\n+            }\n+            true\n+        }\n+\n+        fn parse_optimization_fuel(slot: &mut Option<(String, u64)>, v: Option<&str>) -> bool {\n+            match v {\n+                None => false,\n+                Some(s) => {\n+                    let parts = s.split('=').collect::<Vec<_>>();\n+                    if parts.len() != 2 { return false; }\n+                    let crate_name = parts[0].to_string();\n+                    let fuel = parts[1].parse::<u64>();\n+                    if fuel.is_err() { return false; }\n+                    *slot = Some((crate_name, fuel.unwrap()));\n+                    true\n+                }\n+            }\n+        }\n+\n+        fn parse_unpretty(slot: &mut Option<String>, v: Option<&str>) -> bool {\n+            match v {\n+                None => false,\n+                Some(s) if s.split('=').count() <= 2 => {\n+                    *slot = Some(s.to_string());\n+                    true\n+                }\n+                _ => false,\n+            }\n+        }\n+\n+        fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n+                None => { *slot = Some(1); true }\n+            }\n+        }\n+\n+        fn parse_lto(slot: &mut LtoCli, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        LtoCli::Yes\n+                    } else {\n+                        LtoCli::No\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            *slot = match v {\n+                None => LtoCli::NoParam,\n+                Some(\"thin\") => LtoCli::Thin,\n+                Some(\"fat\") => LtoCli::Fat,\n+                Some(_) => return false,\n+            };\n+            true\n+        }\n+\n+        fn parse_linker_plugin_lto(slot: &mut LinkerPluginLto, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        LinkerPluginLto::LinkerPluginAuto\n+                    } else {\n+                        LinkerPluginLto::Disabled\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            *slot = match v {\n+                None => LinkerPluginLto::LinkerPluginAuto,\n+                Some(path) => LinkerPluginLto::LinkerPlugin(PathBuf::from(path)),\n+            };\n+            true\n+        }\n+\n+        fn parse_switch_with_opt_path(slot: &mut SwitchWithOptPath, v: Option<&str>) -> bool {\n+            *slot = match v {\n+                None => SwitchWithOptPath::Enabled(None),\n+                Some(path) => SwitchWithOptPath::Enabled(Some(PathBuf::from(path))),\n+            };\n+            true\n+        }\n+\n+        fn parse_merge_functions(slot: &mut Option<MergeFunctions>, v: Option<&str>) -> bool {\n+            match v.and_then(|s| MergeFunctions::from_str(s).ok()) {\n+                Some(mergefunc) => *slot = Some(mergefunc),\n+                _ => return false,\n+            }\n+            true\n+        }\n+\n+        fn parse_symbol_mangling_version(\n+            slot: &mut SymbolManglingVersion,\n+            v: Option<&str>,\n+        ) -> bool {\n+            *slot = match v {\n+                Some(\"legacy\") => SymbolManglingVersion::Legacy,\n+                Some(\"v0\") => SymbolManglingVersion::V0,\n+                _ => return false,\n+            };\n+            true\n+        }\n+    }\n+) }\n+\n+options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n+          build_codegen_options, \"C\", \"codegen\",\n+          CG_OPTIONS, cg_type_desc, cgsetters,\n+    ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"this option is deprecated and does nothing\"),\n+    linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n+        \"system linker to link outputs with\"),\n+    link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n+        \"a single extra argument to append to the linker invocation (can be used several times)\"),\n+    link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n+        \"extra arguments to append to the linker invocation (space separated)\"),\n+    link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n+    lto: LtoCli = (LtoCli::Unspecified, parse_lto, [TRACKED],\n+        \"perform LLVM link-time optimizations\"),\n+    target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"select target processor (`rustc --print target-cpus` for details)\"),\n+    target_feature: String = (String::new(), parse_string, [TRACKED],\n+        \"target specific attributes. (`rustc --print target-features` for details). \\\n+        This feature is unsafe.\"),\n+    passes: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n+        \"a list of extra LLVM passes to run (space separated)\"),\n+    llvm_args: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n+        \"a list of arguments to pass to LLVM (space separated)\"),\n+    save_temps: bool = (false, parse_bool, [UNTRACKED],\n+        \"save all temporary output files during compilation\"),\n+    rpath: bool = (false, parse_bool, [UNTRACKED],\n+        \"set rpath values in libs/exes\"),\n+    overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use overflow checks for integer arithmetic\"),\n+    no_prepopulate_passes: bool = (false, parse_bool, [TRACKED],\n+        \"don't pre-populate the pass manager with a list of passes\"),\n+    no_vectorize_loops: bool = (false, parse_bool, [TRACKED],\n+        \"don't run the loop vectorization optimization passes\"),\n+    no_vectorize_slp: bool = (false, parse_bool, [TRACKED],\n+        \"don't run LLVM's SLP vectorization pass\"),\n+    soft_float: bool = (false, parse_bool, [TRACKED],\n+        \"use soft float ABI (*eabihf targets only)\"),\n+    prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n+        \"prefer dynamic linking to static linking\"),\n+    no_integrated_as: bool = (false, parse_bool, [TRACKED],\n+        \"use an external assembler rather than LLVM's integrated one\"),\n+    no_redzone: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"disable the use of the redzone\"),\n+    relocation_model: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"choose the relocation model to use (`rustc --print relocation-models` for details)\"),\n+    code_model: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"choose the code model to use (`rustc --print code-models` for details)\"),\n+    metadata: Vec<String> = (Vec::new(), parse_list, [TRACKED],\n+        \"metadata to mangle symbol names with\"),\n+    extra_filename: String = (String::new(), parse_string, [UNTRACKED],\n+        \"extra data to put in each output filename\"),\n+    codegen_units: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"divide crate into N units to optimize in parallel\"),\n+    remark: Passes = (Passes::Some(Vec::new()), parse_passes, [UNTRACKED],\n+        \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n+    no_stack_check: bool = (false, parse_bool, [UNTRACKED],\n+        \"the `--no-stack-check` flag is deprecated and does nothing\"),\n+    debuginfo: Option<usize> = (None, parse_opt_uint, [TRACKED],\n+        \"debug info emission level, 0 = no debug info, 1 = line tables only, \\\n+         2 = full debug info with variable and type information\"),\n+    opt_level: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"optimize with possible levels 0-3, s, or z\"),\n+    force_frame_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"force use of the frame pointers\"),\n+    debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"explicitly enable the `cfg(debug_assertions)` directive\"),\n+    inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n+        \"set the threshold for inlining a function (default: 225)\"),\n+    panic: Option<PanicStrategy> = (None, parse_panic_strategy,\n+        [TRACKED], \"panic strategy to compile crate with\"),\n+    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"enable incremental compilation\"),\n+    default_linker_libraries: Option<bool> = (None, parse_opt_bool, [UNTRACKED],\n+        \"allow the linker to link its default libraries\"),\n+    linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n+                                           \"linker flavor\"),\n+    linker_plugin_lto: LinkerPluginLto = (LinkerPluginLto::Disabled,\n+        parse_linker_plugin_lto, [TRACKED],\n+        \"generate build artifacts that are compatible with linker-based LTO.\"),\n+    profile_generate: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [TRACKED],\n+        \"compile the program with profiling instrumentation\"),\n+    profile_use: Option<PathBuf> = (None, parse_opt_pathbuf, [TRACKED],\n+        \"use the given `.profdata` file for profile-guided optimization\"),\n+}\n+\n+options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n+          build_debugging_options, \"Z\", \"debugging\",\n+          DB_OPTIONS, db_type_desc, dbsetters,\n+    codegen_backend: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"the backend to use\"),\n+    verbose: bool = (false, parse_bool, [UNTRACKED],\n+        \"in general, enable more debug printouts\"),\n+    span_free_formats: bool = (false, parse_bool, [UNTRACKED],\n+        \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n+    identify_regions: bool = (false, parse_bool, [UNTRACKED],\n+        \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n+    borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"select which borrowck is used (`mir` or `migrate`)\"),\n+    time_passes: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of each rustc pass\"),\n+    time: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of rustc processes\"),\n+    time_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n+        \"measure time of each LLVM pass\"),\n+    input_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"gather statistics about the input\"),\n+    asm_comments: bool = (false, parse_bool, [TRACKED],\n+        \"generate comments into the assembly (may change behavior)\"),\n+    verify_llvm_ir: bool = (false, parse_bool, [TRACKED],\n+        \"verify LLVM IR\"),\n+    borrowck_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"gather borrowck statistics\"),\n+    no_landing_pads: bool = (false, parse_bool, [TRACKED],\n+        \"omit landing pads for unwinding\"),\n+    fewer_names: bool = (false, parse_bool, [TRACKED],\n+        \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR)\"),\n+    meta_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"gather metadata statistics\"),\n+    print_link_args: bool = (false, parse_bool, [UNTRACKED],\n+        \"print the arguments passed to the linker\"),\n+    print_llvm_passes: bool = (false, parse_bool, [UNTRACKED],\n+        \"prints the LLVM optimization passes being run\"),\n+    ast_json: bool = (false, parse_bool, [UNTRACKED],\n+        \"print the AST as JSON and halt\"),\n+    // We default to 1 here since we want to behave like\n+    // a sequential compiler for now. This'll likely be adjusted\n+    // in the future. Note that -Zthreads=0 is the way to get\n+    // the num_cpus behavior.\n+    threads: usize = (1, parse_threads, [UNTRACKED],\n+        \"use a thread pool with N threads\"),\n+    ast_json_noexpand: bool = (false, parse_bool, [UNTRACKED],\n+        \"print the pre-expansion AST as JSON and halt\"),\n+    ls: bool = (false, parse_bool, [UNTRACKED],\n+        \"list the symbols defined by a library crate\"),\n+    save_analysis: bool = (false, parse_bool, [UNTRACKED],\n+        \"write syntax and type analysis (in JSON format) information, in \\\n+         addition to normal output\"),\n+    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"prints region inference graph. \\\n+         Use with RUST_REGION_GRAPH=help for more info\"),\n+    parse_only: bool = (false, parse_bool, [UNTRACKED],\n+        \"parse only; do not compile, assemble, or link\"),\n+    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n+        \"load proc macros for both target and host, but only link to the target\"),\n+    no_codegen: bool = (false, parse_bool, [TRACKED],\n+        \"run all passes except codegen; no output\"),\n+    treat_err_as_bug: Option<usize> = (None, parse_treat_err_as_bug, [TRACKED],\n+        \"treat error number `val` that occurs as bug\"),\n+    report_delayed_bugs: bool = (false, parse_bool, [TRACKED],\n+        \"immediately print bugs registered with `delay_span_bug`\"),\n+    external_macro_backtrace: bool = (false, parse_bool, [UNTRACKED],\n+        \"show macro backtraces even for non-local macros\"),\n+    teach: bool = (false, parse_bool, [TRACKED],\n+        \"show extended diagnostic help\"),\n+    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"set the current terminal width\"),\n+    panic_abort_tests: bool = (false, parse_bool, [TRACKED],\n+        \"support compiling tests with panic=abort\"),\n+    continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n+        \"attempt to recover from parse errors (experimental)\"),\n+    dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n+        \"print tasks that execute and the color their dep node gets (requires debug build)\"),\n+    incremental: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"enable incremental compilation (experimental)\"),\n+    incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n+        \"enable incremental compilation support for queries (experimental)\"),\n+    incremental_info: bool = (false, parse_bool, [UNTRACKED],\n+        \"print high-level information about incremental reuse (or the lack thereof)\"),\n+    incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n+        \"dump hash information in textual format to stdout\"),\n+    incremental_verify_ich: bool = (false, parse_bool, [UNTRACKED],\n+        \"verify incr. comp. hashes of green query instances\"),\n+    incremental_ignore_spans: bool = (false, parse_bool, [UNTRACKED],\n+        \"ignore spans during ICH computation -- used for testing\"),\n+    instrument_mcount: bool = (false, parse_bool, [TRACKED],\n+        \"insert function instrument code for mcount-based tracing\"),\n+    dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n+    query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"enable queries of the dependency graph for regression testing\"),\n+    no_analysis: bool = (false, parse_bool, [UNTRACKED],\n+        \"parse and expand the source, but run no analysis\"),\n+    unstable_options: bool = (false, parse_bool, [UNTRACKED],\n+        \"adds unstable command line options to rustc interface\"),\n+    force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"force overflow checks on or off\"),\n+    trace_macros: bool = (false, parse_bool, [UNTRACKED],\n+        \"for every macro invocation, print its name and arguments\"),\n+    debug_macros: bool = (false, parse_bool, [TRACKED],\n+        \"emit line numbers debug info inside macros\"),\n+    generate_arange_section: bool = (true, parse_bool, [TRACKED],\n+        \"generate DWARF address ranges for faster lookups\"),\n+    keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't clear the hygiene data after analysis\"),\n+    keep_ast: bool = (false, parse_bool, [UNTRACKED],\n+        \"keep the AST after lowering it to HIR\"),\n+    show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"show spans for compiler debugging (expr|pat|ty)\"),\n+    print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n+        \"print layout information for each type encountered\"),\n+    print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"print the result of the monomorphization collection pass\"),\n+    mir_opt_level: usize = (1, parse_uint, [TRACKED],\n+        \"set the MIR optimization level (0-3, default: 1)\"),\n+    mutable_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"emit noalias metadata for mutable references (default: no)\"),\n+    dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"dump MIR state to file.\n+        `val` is used to select which passes and functions to dump. For example:\n+        `all` matches all passes and functions,\n+        `foo` matches all passes for functions whose name contains 'foo',\n+        `foo & ConstProp` only the 'ConstProp' pass for function names containing 'foo',\n+        `foo | bar` all passes for function names containing 'foo' or 'bar'.\"),\n+\n+    dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],\n+        \"the directory the MIR is dumped into\"),\n+    dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n+        \"in addition to `.mir` files, create graphviz `.dot` files\"),\n+    dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n+        \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n+    mir_emit_retag: bool = (false, parse_bool, [TRACKED],\n+        \"emit Retagging MIR statements, interpreted e.g., by miri; implies -Zmir-opt-level=0\"),\n+    perf_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"print some performance-related statistics\"),\n+    query_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"print some statistics about the query system\"),\n+    hir_stats: bool = (false, parse_bool, [UNTRACKED],\n+        \"print some statistics about AST and HIR\"),\n+    always_encode_mir: bool = (false, parse_bool, [TRACKED],\n+        \"encode MIR of all functions into the crate metadata\"),\n+    json_rendered: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"describes how to render the `rendered` field of json diagnostics\"),\n+    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n+        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n+    osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n+        \"pass `-install_name @rpath/...` to the macOS linker\"),\n+    sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],\n+                                    \"use a sanitizer\"),\n+    sanitizer_recover: Vec<Sanitizer> = (vec![], parse_sanitizer_list, [TRACKED],\n+        \"Enable recovery for selected sanitizers\"),\n+    sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n+        \"Enable origins tracking in MemorySanitizer\"),\n+    fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n+        \"set the optimization fuel quota for a crate\"),\n+    print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"make rustc print the total optimization fuel used by a crate\"),\n+    force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n+        \"force all crates to be `rustc_private` unstable\"),\n+    pre_link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n+        \"a single extra argument to prepend the linker invocation (can be used several times)\"),\n+    pre_link_args: Option<Vec<String>> = (None, parse_opt_list, [UNTRACKED],\n+        \"extra arguments to prepend to the linker invocation (space separated)\"),\n+    profile: bool = (false, parse_bool, [TRACKED],\n+                     \"insert profiling code\"),\n+    disable_instrumentation_preinliner: bool = (false, parse_bool, [TRACKED],\n+        \"Disable the instrumentation pre-inliner, useful for profiling / PGO.\"),\n+    relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n+        \"choose which RELRO level to use\"),\n+    nll_facts: bool = (false, parse_bool, [UNTRACKED],\n+                       \"dump facts from NLL analysis into side files\"),\n+    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n+        \"in match codegen, do not include FakeRead statements (used by mir-borrowck)\"),\n+    dont_buffer_diagnostics: bool = (false, parse_bool, [UNTRACKED],\n+        \"emit diagnostics rather than buffering (breaks NLL error downgrading, sorting).\"),\n+    polonius: bool = (false, parse_bool, [UNTRACKED],\n+        \"enable polonius-based borrow-checker\"),\n+    codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n+    thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"enable ThinLTO when possible\"),\n+    inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"control whether `#[inline]` functions are in all CGUs\"),\n+    tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n+        \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n+    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n+        \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n+         the max/min integer respectively, and NaN is mapped to 0\"),\n+    human_readable_cgu_names: bool = (false, parse_bool, [TRACKED],\n+        \"generate human-readable, predictable names for codegen units\"),\n+    dep_info_omit_d_target: bool = (false, parse_bool, [TRACKED],\n+        \"in dep-info output, omit targets for tracking dependencies of the dep-info files \\\n+         themselves\"),\n+    unpretty: Option<String> = (None, parse_unpretty, [UNTRACKED],\n+        \"present the input source, unstable (and less-pretty) variants;\n+        valid types are any of the types for `--pretty`, as well as:\n+        `expanded`, `expanded,identified`,\n+        `expanded,hygiene` (with internal representations),\n+        `everybody_loops` (all function bodies replaced with `loop {}`),\n+        `hir` (the HIR), `hir,identified`,\n+        `hir,typed` (HIR with types for each node),\n+        `hir-tree` (dump the raw HIR),\n+        `mir` (the MIR), or `mir-cfg` (graphviz formatted MIR)\"),\n+    run_dsymutil: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"run `dsymutil` and delete intermediate object files\"),\n+    ui_testing: bool = (false, parse_bool, [UNTRACKED],\n+        \"format compiler diagnostics in a way that's better suitable for UI testing\"),\n+    embed_bitcode: bool = (false, parse_bool, [TRACKED],\n+        \"embed LLVM bitcode in object files\"),\n+    strip_debuginfo_if_disabled: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"tell the linker to strip debuginfo when building without debuginfo enabled.\"),\n+    share_generics: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"make the current crate share its generic instantiations\"),\n+    chalk: bool = (false, parse_bool, [TRACKED],\n+        \"enable the experimental Chalk-based trait solving engine\"),\n+    no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n+    no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n+        \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n+    no_interleave_lints: bool = (false, parse_bool, [UNTRACKED],\n+        \"don't interleave execution of lints; allows benchmarking individual lints\"),\n+    crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n+        \"inject the given attribute in the crate\"),\n+    self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n+        parse_switch_with_opt_path, [UNTRACKED],\n+        \"run the self profiler and output the raw event data\"),\n+    self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n+        \"specifies which kinds of events get recorded by the self profiler\"),\n+    emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n+        \"emits a section containing stack size metadata\"),\n+    plt: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+          \"whether to use the PLT when calling into shared libraries;\n+          only has effect for PIC code on systems with ELF binaries\n+          (default: PLT is disabled if full relro is enabled)\"),\n+    merge_functions: Option<MergeFunctions> = (None, parse_merge_functions, [TRACKED],\n+        \"control the operation of the MergeFunctions LLVM pass, taking\n+         the same values as the target option of the same name\"),\n+    allow_features: Option<Vec<String>> = (None, parse_opt_comma_list, [TRACKED],\n+        \"only allow the listed language features to be enabled in code (space separated)\"),\n+    symbol_mangling_version: SymbolManglingVersion = (SymbolManglingVersion::Legacy,\n+        parse_symbol_mangling_version, [TRACKED],\n+        \"which mangling version to use for symbol names\"),\n+    binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n+        \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info\"),\n+    insert_sideeffect: bool = (false, parse_bool, [TRACKED],\n+        \"fix undefined behavior when a thread doesn't eventually make progress \\\n+         (such as entering an empty infinite loop) by inserting llvm.sideeffect\"),\n+}"}, {"sha": "19441be87b9591522ebf8c0f6e01f8a1f6fd0937", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -1425,8 +1425,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: ast::Ident,\n     ) -> Ty<'tcx> {\n         let expr_t = self.check_expr_with_needs(base, needs);\n-        let expr_t = self.structurally_resolved_type(base.span,\n-                                                     expr_t);\n+        let expr_t = self.structurally_resolved_type(base.span, expr_t);\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, _)) = autoderef.next() {"}, {"sha": "9cd8c9abfd783e2519321cb0d81dcde8e42bf3f3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 118, "deletions": 43, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -15,7 +15,7 @@ use rustc::traits::Obligation;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use rustc::ty::print::with_crate_prefix;\n use syntax_pos::{Span, FileName};\n-use syntax::ast;\n+use syntax::{ast, source_map};\n use syntax::util::lev_distance;\n \n use rustc_error_codes::*;\n@@ -79,37 +79,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        let print_disambiguation_help = |\n-            err: &mut DiagnosticBuilder<'_>,\n-            trait_name: String,\n-        | {\n-            err.help(&format!(\n-                \"to disambiguate the method call, write `{}::{}({}{})` instead\",\n-                trait_name,\n-                item_name,\n-                if rcvr_ty.is_region_ptr() && args.is_some() {\n-                    if rcvr_ty.is_mutable_ptr() {\n-                        \"&mut \"\n-                    } else {\n-                        \"&\"\n-                    }\n-                } else {\n-                    \"\"\n-                },\n-                args.map(|arg| arg\n-                    .iter()\n-                    .map(|arg| self.tcx.sess.source_map().span_to_snippet(arg.span)\n-                        .unwrap_or_else(|_| \"...\".to_owned()))\n-                    .collect::<Vec<_>>()\n-                    .join(\", \")\n-                ).unwrap_or_else(|| \"...\".to_owned())\n-            ));\n-        };\n-\n         let report_candidates = |\n             span: Span,\n             err: &mut DiagnosticBuilder<'_>,\n             mut sources: Vec<CandidateSource>,\n+            sugg_span: Span,\n         | {\n             sources.sort();\n             sources.dedup();\n@@ -150,15 +124,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                         };\n \n-                        let note_str = if sources.len() > 1 {\n-                            format!(\"candidate #{} is defined in an impl{} for the type `{}`\",\n-                                    idx + 1,\n-                                    insertion,\n-                                    impl_ty)\n+                        let (note_str, idx) = if sources.len() > 1 {\n+                            (format!(\n+                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n+                                idx + 1,\n+                                insertion,\n+                                impl_ty,\n+                            ), Some(idx + 1))\n                         } else {\n-                            format!(\"the candidate is defined in an impl{} for the type `{}`\",\n-                                    insertion,\n-                                    impl_ty)\n+                            (format!(\n+                                \"the candidate is defined in an impl{} for the type `{}`\",\n+                                insertion,\n+                                impl_ty,\n+                            ), None)\n                         };\n                         if let Some(note_span) = note_span {\n                             // We have a span pointing to the method. Show note with snippet.\n@@ -168,7 +146,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             err.note(&note_str);\n                         }\n                         if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n-                            print_disambiguation_help(err, self.tcx.def_path_str(trait_ref.def_id));\n+                            let path = self.tcx.def_path_str(trait_ref.def_id);\n+\n+                            let ty = match item.kind {\n+                                ty::AssocKind::Const |\n+                                ty::AssocKind::Type |\n+                                ty::AssocKind::OpaqueTy => rcvr_ty,\n+                                ty::AssocKind::Method => self.tcx.fn_sig(item.def_id)\n+                                    .inputs()\n+                                    .skip_binder()\n+                                    .get(0)\n+                                    .filter(|ty| ty.is_region_ptr() && !rcvr_ty.is_region_ptr())\n+                                    .map(|ty| *ty)\n+                                    .unwrap_or(rcvr_ty),\n+                            };\n+                            print_disambiguation_help(\n+                                item_name,\n+                                args,\n+                                err,\n+                                path,\n+                                ty,\n+                                item.kind,\n+                                sugg_span,\n+                                idx,\n+                                self.tcx.sess.source_map(),\n+                            );\n                         }\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n@@ -182,19 +184,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         let item_span = self.tcx.sess.source_map()\n                             .def_span(self.tcx.def_span(item.def_id));\n-                        if sources.len() > 1 {\n+                        let idx = if sources.len() > 1 {\n                             span_note!(err,\n                                        item_span,\n                                        \"candidate #{} is defined in the trait `{}`\",\n                                        idx + 1,\n                                        self.tcx.def_path_str(trait_did));\n+                            Some(idx + 1)\n                         } else {\n                             span_note!(err,\n                                        item_span,\n                                        \"the candidate is defined in the trait `{}`\",\n                                        self.tcx.def_path_str(trait_did));\n-                        }\n-                        print_disambiguation_help(err, self.tcx.def_path_str(trait_did));\n+                            None\n+                        };\n+                        let path = self.tcx.def_path_str(trait_did);\n+                        print_disambiguation_help(\n+                            item_name,\n+                            args,\n+                            err,\n+                            path,\n+                            rcvr_ty,\n+                            item.kind,\n+                            sugg_span,\n+                            idx,\n+                            self.tcx.sess.source_map(),\n+                        );\n                     }\n                 }\n             }\n@@ -203,6 +218,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n+        let sugg_span = if let SelfSource::MethodCall(expr) = source {\n+            // Given `foo.bar(baz)`, `expr` is `bar`, but we want to point to the whole thing.\n+            self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id)).span\n+        } else {\n+            span\n+        };\n+\n         match error {\n             MethodError::NoMatch(NoMatchData {\n                 static_candidates: static_sources,\n@@ -495,9 +517,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ));\n                     }\n \n-                    report_candidates(span, &mut err, static_sources);\n+                    report_candidates(span, &mut err, static_sources, sugg_span);\n                 } else if static_sources.len() > 1 {\n-                    report_candidates(span, &mut err, static_sources);\n+                    report_candidates(span, &mut err, static_sources, sugg_span);\n                 }\n \n                 if !unsatisfied_predicates.is_empty() {\n@@ -584,7 +606,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                \"multiple applicable items in scope\");\n                 err.span_label(span, format!(\"multiple `{}` found\", item_name));\n \n-                report_candidates(span, &mut err, sources);\n+                report_candidates(span, &mut err, sources, sugg_span);\n                 err.emit();\n             }\n \n@@ -1123,3 +1145,56 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n         hir::intravisit::NestedVisitorMap::None\n     }\n }\n+\n+fn print_disambiguation_help(\n+    item_name: ast::Ident,\n+    args: Option<&'tcx [hir::Expr]>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    trait_name: String,\n+    rcvr_ty: Ty<'_>,\n+    kind: ty::AssocKind,\n+    span: Span,\n+    candidate: Option<usize>,\n+    source_map: &source_map::SourceMap,\n+) {\n+    let mut applicability = Applicability::MachineApplicable;\n+    let sugg_args = if let (ty::AssocKind::Method, Some(args)) = (kind, args) {\n+        format!(\n+            \"({}{})\",\n+            if rcvr_ty.is_region_ptr() {\n+                if rcvr_ty.is_mutable_ptr() {\n+                    \"&mut \"\n+                } else {\n+                    \"&\"\n+                }\n+            } else {\n+                \"\"\n+            },\n+            args.iter()\n+                .map(|arg| source_map.span_to_snippet(arg.span)\n+                    .unwrap_or_else(|_| {\n+                        applicability = Applicability::HasPlaceholders;\n+                        \"_\".to_owned()\n+                    }))\n+                .collect::<Vec<_>>()\n+                .join(\", \"),\n+        )\n+    } else {\n+        String::new()\n+    };\n+    let sugg = format!(\"{}::{}{}\", trait_name, item_name, sugg_args);\n+    err.span_suggestion(\n+        span,\n+        &format!(\n+            \"disambiguate the {} for {}\",\n+            kind.suggestion_descr(),\n+            if let Some(candidate) = candidate {\n+                format!(\"candidate #{}\", candidate)\n+            } else {\n+                \"the candidate\".to_string()\n+            },\n+        ),\n+        sugg,\n+        applicability,\n+    );\n+}"}, {"sha": "4c23aabf49741493e8b6676f83485c2103ea96da", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -18,16 +18,6 @@ pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n \n-// See below for the usage of SOCK_CLOEXEC, but this constant is only defined on\n-// Linux currently (e.g., support doesn't exist on other platforms). In order to\n-// get name resolution to work and things to compile we just define a dummy\n-// SOCK_CLOEXEC here for other platforms. Note that the dummy constant isn't\n-// actually ever used (the blocks below are wrapped in `if cfg!` as well.\n-#[cfg(target_os = \"linux\")]\n-use libc::SOCK_CLOEXEC;\n-#[cfg(not(target_os = \"linux\"))]\n-const SOCK_CLOEXEC: c_int = 0;\n-\n pub struct Socket(FileDesc);\n \n pub fn init() {}\n@@ -69,8 +59,9 @@ impl Socket {\n             // this option, however, was added in 2.6.27, and we still support\n             // 2.6.18 as a kernel, so if the returned error is EINVAL we\n             // fallthrough to the fallback.\n-            if cfg!(target_os = \"linux\") {\n-                match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n+            #[cfg(target_os = \"linux\")]\n+            {\n+                match cvt(libc::socket(fam, ty | libc::SOCK_CLOEXEC, 0)) {\n                     Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n                     Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n                     Err(e) => return Err(e),\n@@ -96,8 +87,9 @@ impl Socket {\n             let mut fds = [0, 0];\n \n             // Like above, see if we can set cloexec atomically\n-            if cfg!(target_os = \"linux\") {\n-                match cvt(libc::socketpair(fam, ty | SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n+            #[cfg(target_os = \"linux\")]\n+            {\n+                match cvt(libc::socketpair(fam, ty | libc::SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n                     Ok(_) => {\n                         return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));\n                     }\n@@ -187,7 +179,8 @@ impl Socket {\n         // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n         // Linux. This was added in 2.6.28, however, and because we support\n         // 2.6.18 we must detect this support dynamically.\n-        if cfg!(target_os = \"linux\") {\n+        #[cfg(target_os = \"linux\")]\n+        {\n             syscall! {\n                 fn accept4(\n                     fd: c_int,\n@@ -196,7 +189,7 @@ impl Socket {\n                     flags: c_int\n                 ) -> c_int\n             }\n-            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, SOCK_CLOEXEC) });\n+            let res = cvt_r(|| unsafe { accept4(self.0.raw(), storage, len, libc::SOCK_CLOEXEC) });\n             match res {\n                 Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n                 Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}"}, {"sha": "e66d6fdc56ac634d83741b66b6df25b98d6f42a2", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -375,8 +375,12 @@ impl ChildStdio {\n \n impl fmt::Debug for Command {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.program)?;\n-        for arg in &self.args {\n+        if self.program != self.args[0] {\n+            write!(f, \"[{:?}] \", self.program)?;\n+        }\n+        write!(f, \"{:?}\", self.args[0])?;\n+\n+        for arg in &self.args[1..] {\n             write!(f, \" {:?}\", arg)?;\n         }\n         Ok(())"}, {"sha": "74cbd246fe8198b8266719cc70de0ac4a705dbea", "filename": "src/libstd/sys/vxworks/net.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fnet.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -18,8 +18,6 @@ pub extern crate libc as netc;\n \n pub type wrlen_t = size_t;\n \n-const SOCK_CLOEXEC: c_int = 0;\n-\n pub struct Socket(FileDesc);\n \n pub fn init() {}"}, {"sha": "92a8d19021a2c2610564b027dba837792301a229", "filename": "src/test/ui/associated-const/associated-const-ambiguity-report.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-ambiguity-report.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-ambiguity-report.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-const%2Fassociated-const-ambiguity-report.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `Foo` for the type `i32`\n    |\n LL |     const ID: i32 = 1;\n    |     ^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `Foo::ID(...)` instead\n note: candidate #2 is defined in an impl of the trait `Bar` for the type `i32`\n   --> $DIR/associated-const-ambiguity-report.rs:14:5\n    |\n LL |     const ID: i32 = 3;\n    |     ^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `Bar::ID(...)` instead\n+help: disambiguate the associated constant for candidate #1\n+   |\n+LL | const X: i32 = Foo::ID;\n+   |                ^^^^^^^\n+help: disambiguate the associated constant for candidate #2\n+   |\n+LL | const X: i32 = Bar::ID;\n+   |                ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3ffdb8ce6b9a1634b2c345e7190b4cb8c016024c", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0698]: type inside `async fn` body must be known in this context\n   --> $DIR/unresolved_type_param.rs:9:5\n    |\n LL |     bar().await;\n-   |     ^^^ cannot infer type for type parameter `T`\n+   |     ^^^ cannot infer type for type parameter `T` declared on the function `bar`\n    |\n note: the type is part of the `async fn` body because of this `await`\n   --> $DIR/unresolved_type_param.rs:9:5"}, {"sha": "133d2ada2b26379b22540faaf9150ec4bb176329", "filename": "src/test/ui/command/command-argv0-debug.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-argv0-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-argv0-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-argv0-debug.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -0,0 +1,24 @@\n+// run-pass\n+\n+// ignore-windows - this is a unix-specific test\n+// ignore-cloudabi no processes\n+// ignore-emscripten no processes\n+// ignore-sgx no processes\n+#![feature(process_set_argv0)]\n+\n+use std::os::unix::process::CommandExt;\n+use std::process::Command;\n+\n+fn main() {\n+    let mut command = Command::new(\"some-boring-name\");\n+\n+    assert_eq!(format!(\"{:?}\", command), r#\"\"some-boring-name\"\"#);\n+\n+    command.args(&[\"1\", \"2\", \"3\"]);\n+\n+    assert_eq!(format!(\"{:?}\", command), r#\"\"some-boring-name\" \"1\" \"2\" \"3\"\"#);\n+\n+    command.arg0(\"exciting-name\");\n+\n+    assert_eq!(format!(\"{:?}\", command), r#\"[\"some-boring-name\"] \"exciting-name\" \"1\" \"2\" \"3\"\"#);\n+}"}, {"sha": "56a9fb4d39125d9855543368fb11f603fe18e2a4", "filename": "src/test/ui/command/command-argv0.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-argv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-argv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-argv0.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "previous_filename": "src/test/ui/command-argv0.rs"}, {"sha": "568be67abe372bf106e50f3ca9b4b598abf8d75c", "filename": "src/test/ui/command/command-exec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-exec.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "previous_filename": "src/test/ui/command-exec.rs"}, {"sha": "c0fc554183a43fa1262d94c5eeeed7d2590a50fa", "filename": "src/test/ui/command/command-pre-exec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-pre-exec.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "previous_filename": "src/test/ui/command-pre-exec.rs"}, {"sha": "f867106c35d0789f289f9e8482fb8f7ce2dd9373", "filename": "src/test/ui/command/command-uid-gid.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-uid-gid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fcommand%2Fcommand-uid-gid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-uid-gid.rs?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "previous_filename": "src/test/ui/command-uid-gid.rs"}, {"sha": "44eab8baa40a6571651cac2887f64ab8ab214ecd", "filename": "src/test/ui/const-generics/fn-const-param-infer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -30,7 +30,7 @@ error[E0282]: type annotations needed\n   --> $DIR/fn-const-param-infer.rs:22:23\n    |\n LL |     let _ = Checked::<generic>;\n-   |                       ^^^^^^^ cannot infer type for type parameter `T`\n+   |                       ^^^^^^^ cannot infer type for type parameter `T` declared on the function `generic`\n \n error[E0308]: mismatched types\n   --> $DIR/fn-const-param-infer.rs:25:40"}, {"sha": "dd281e911da9669d764cca24111217bc4262da39", "filename": "src/test/ui/consts/issue-64662.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-64662.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,13 +2,13 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-64662.rs:2:9\n    |\n LL |     A = foo(),\n-   |         ^^^ cannot infer type for type parameter `T`\n+   |         ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n \n error[E0282]: type annotations needed\n   --> $DIR/issue-64662.rs:3:9\n    |\n LL |     B = foo(),\n-   |         ^^^ cannot infer type for type parameter `T`\n+   |         ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6db2ef5051d83ab0c32f3ee0734c11a9f5d790b5", "filename": "src/test/ui/error-codes/E0034.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0034.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `Trait1` for the type `Tes\n    |\n LL |     fn foo() {}\n    |     ^^^^^^^^\n-   = help: to disambiguate the method call, write `Trait1::foo(...)` instead\n note: candidate #2 is defined in an impl of the trait `Trait2` for the type `Test`\n   --> $DIR/E0034.rs:16:5\n    |\n LL |     fn foo() {}\n    |     ^^^^^^^^\n-   = help: to disambiguate the method call, write `Trait2::foo(...)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     Trait1::foo()\n+   |     ^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     Trait2::foo()\n+   |     ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "8b1d4e6c07cebead561ddc337abc33c3643d7186", "filename": "src/test/ui/error-codes/E0401.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0401.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -36,7 +36,7 @@ error[E0282]: type annotations needed\n   --> $DIR/E0401.rs:11:5\n    |\n LL |     bfnr(x);\n-   |     ^^^^ cannot infer type for type parameter `U`\n+   |     ^^^^ cannot infer type for type parameter `U` declared on the function `bfnr`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "fa908440e41ea6833779f21525f09ae516c0e9fd", "filename": "src/test/ui/inference/inference_unstable_featured.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Finference%2Finference_unstable_featured.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Finference%2Finference_unstable_featured.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finference_unstable_featured.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -5,9 +5,15 @@ LL |     assert_eq!('x'.ipu_flatten(), 0);\n    |                    ^^^^^^^^^^^ multiple `ipu_flatten` found\n    |\n    = note: candidate #1 is defined in an impl of the trait `inference_unstable_iterator::IpuIterator` for the type `char`\n-   = help: to disambiguate the method call, write `inference_unstable_iterator::IpuIterator::ipu_flatten('x')` instead\n    = note: candidate #2 is defined in an impl of the trait `inference_unstable_itertools::IpuItertools` for the type `char`\n-   = help: to disambiguate the method call, write `inference_unstable_itertools::IpuItertools::ipu_flatten('x')` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     assert_eq!(inference_unstable_iterator::IpuIterator::ipu_flatten(&'x'), 0);\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     assert_eq!(inference_unstable_itertools::IpuItertools::ipu_flatten(&'x'), 0);\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "fe7e8f89f7f1adc7514fa750d3d9ed6a10776246", "filename": "src/test/ui/issues/issue-12028.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12028.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0284]: type annotations needed\n   --> $DIR/issue-12028.rs:27:14\n    |\n LL |         self.input_stream(&mut stream);\n-   |              ^^^^^^^^^^^^ cannot infer type for type parameter `H`\n+   |              ^^^^^^^^^^^^ cannot infer type for type parameter `H` declared on the trait `StreamHash`\n    |\n    = note: cannot resolve `<_ as StreamHasher>::S == <H as StreamHasher>::S`\n "}, {"sha": "49a12cc20094799bcf650da32b85d3e1b0e0f630", "filename": "src/test/ui/issues/issue-16966.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16966.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-16966.rs:2:5\n    |\n LL |     panic!(std::default::Default::default());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `M`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `M` declared on the function `begin_panic`\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n "}, {"sha": "48405a292f3aa9d0e8e8fa4c984f14e068830f63", "filename": "src/test/ui/issues/issue-17551.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17551.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed for `B<T>`\n   --> $DIR/issue-17551.rs:6:15\n    |\n LL |     let foo = B(marker::PhantomData);\n-   |         ---   ^ cannot infer type for type parameter `T`\n+   |         ---   ^ cannot infer type for type parameter `T` declared on the struct `B`\n    |         |\n    |         consider giving `foo` the explicit type `B<T>`, where the type parameter `T` is specified\n "}, {"sha": "3422add9dd96b701bbae7fee4052f38b96500f89", "filename": "src/test/ui/issues/issue-18446.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-18446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-18446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18446.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,10 @@ error[E0034]: multiple applicable items in scope\n   --> $DIR/issue-18446.rs:18:7\n    |\n LL |     x.foo();\n-   |       ^^^ multiple `foo` found\n+   |     --^^^--\n+   |     | |\n+   |     | multiple `foo` found\n+   |     help: disambiguate the method call for candidate #2: `T::foo(&x)`\n    |\n note: candidate #1 is defined in an impl for the type `dyn T`\n   --> $DIR/issue-18446.rs:9:5\n@@ -14,7 +17,6 @@ note: candidate #2 is defined in the trait `T`\n    |\n LL |     fn foo(&self);\n    |     ^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `T::foo(&x)` instead\n \n error: aborting due to previous error\n "}, {"sha": "a09de86a708f8ccb96159f4276a462a73a057aeb", "filename": "src/test/ui/issues/issue-25368.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25368.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -5,7 +5,7 @@ LL |     let (tx, rx) = channel();\n    |         -------- consider giving this pattern the explicit type `(std::sync::mpsc::Sender<Foo<T>>, std::sync::mpsc::Receiver<Foo<T>>)`, where the type parameter `T` is specified\n ...\n LL |         tx.send(Foo{ foo: PhantomData });\n-   |                 ^^^ cannot infer type for type parameter `T`\n+   |                 ^^^ cannot infer type for type parameter `T` declared on the struct `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "b18e407c3d464d9f3b03bf8533becd860cee5154", "filename": "src/test/ui/issues/issue-3702-2.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-3702-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-3702-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3702-2.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `ToPrimitive` for the type\n    |\n LL |     fn to_int(&self) -> isize { 0 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `ToPrimitive::to_int(&self)` instead\n note: candidate #2 is defined in an impl of the trait `Add` for the type `isize`\n   --> $DIR/issue-3702-2.rs:14:5\n    |\n LL |     fn to_int(&self) -> isize { *self }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `Add::to_int(&self)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |         ToPrimitive::to_int(&self) + other.to_int()\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |         Add::to_int(&self) + other.to_int()\n+   |         ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "9fa15dc9679147bfeb8dca8c6cc8df4fb5622353", "filename": "src/test/ui/issues/issue-5062.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5062.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-5062.rs:1:29\n    |\n LL | fn main() { format!(\"{:?}\", None); }\n-   |                             ^^^^ cannot infer type for type parameter `T`\n+   |                             ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n \n error: aborting due to previous error\n "}, {"sha": "da16f95dc3de657075db68693ed9b6018f838486", "filename": "src/test/ui/issues/issue-6458-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-2.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-2.rs:3:21\n    |\n LL |     format!(\"{:?}\", None);\n-   |                     ^^^^ cannot infer type for type parameter `T`\n+   |                     ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n \n error: aborting due to previous error\n "}, {"sha": "a71c159db0b0ebb1a32e60c327d7f22df21a952b", "filename": "src/test/ui/issues/issue-6458-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458-3.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458-3.rs:4:5\n    |\n LL |     mem::transmute(0);\n-   |     ^^^^^^^^^^^^^^ cannot infer type for type parameter `U`\n+   |     ^^^^^^^^^^^^^^ cannot infer type for type parameter `U` declared on the function `transmute`\n \n error: aborting due to previous error\n "}, {"sha": "f1a982616a4a13e1447735b985267f516e8bb74e", "filename": "src/test/ui/issues/issue-6458.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-6458.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-6458.rs:9:4\n    |\n LL |    foo(TypeWithState(marker::PhantomData));\n-   |    ^^^ cannot infer type for type parameter `State`\n+   |    ^^^ cannot infer type for type parameter `State` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "feaf3dc753ffbaf89dbb00fe0c159066d12f7402", "filename": "src/test/ui/issues/issue-65634-raw-ident-suggestion.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-65634-raw-ident-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fissues%2Fissue-65634-raw-ident-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-65634-raw-ident-suggestion.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `async` for the type `r#fn\n    |\n LL |     fn r#struct(&self) {\n    |     ^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `async::r#struct(r#fn {})` instead\n note: candidate #2 is defined in an impl of the trait `await` for the type `r#fn`\n   --> $DIR/issue-65634-raw-ident-suggestion.rs:10:5\n    |\n LL |     fn r#struct(&self) {\n    |     ^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `await::r#struct(r#fn {})` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     async::r#struct(&r#fn {});\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     await::r#struct(&r#fn {});\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "fa3add81a28f5af1b5db7e4d5981fb50da301cca", "filename": "src/test/ui/methods/method-ambig-two-traits-cross-crate.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-cross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-cross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-cross-crate.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,9 +9,15 @@ note: candidate #1 is defined in an impl of the trait `Me2` for the type `usize`\n    |\n LL | impl Me2 for usize { fn me(&self) -> usize { *self } }\n    |                      ^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `Me2::me(1_usize)` instead\n    = note: candidate #2 is defined in an impl of the trait `ambig_impl_2_lib::Me` for the type `usize`\n-   = help: to disambiguate the method call, write `ambig_impl_2_lib::Me::me(1_usize)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL | fn main() { Me2::me(&1_usize); }\n+   |             ^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL | fn main() { ambig_impl_2_lib::Me::me(&1_usize); }\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "b6c81c2377ee44ddc634943690d08d12dff3bea4", "filename": "src/test/ui/methods/method-ambig-two-traits-from-bounds.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-bounds.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in the trait `A`\n    |\n LL | trait A { fn foo(&self); }\n    |           ^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `A::foo(t)` instead\n note: candidate #2 is defined in the trait `B`\n   --> $DIR/method-ambig-two-traits-from-bounds.rs:2:11\n    |\n LL | trait B { fn foo(&self); }\n    |           ^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `B::foo(t)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     A::foo(t);\n+   |     ^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     B::foo(t);\n+   |     ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "71c65f7ccc68d3229fd3187cffc790d6b0d3bdbe", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `A` for the type `AB`\n    |\n LL |     fn foo(self) {}\n    |     ^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `A::foo(AB {})` instead\n note: candidate #2 is defined in an impl of the trait `B` for the type `AB`\n   --> $DIR/method-ambig-two-traits-from-impls.rs:11:5\n    |\n LL |     fn foo(self) {}\n    |     ^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `B::foo(AB {})` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     A::foo(AB {});\n+   |     ^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     B::foo(AB {});\n+   |     ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "44f85071505d2c33b594b151b4266ebbe5db083c", "filename": "src/test/ui/methods/method-ambig-two-traits-from-impls2.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-from-impls2.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `A` for the type `AB`\n    |\n LL |     fn foo() {}\n    |     ^^^^^^^^\n-   = help: to disambiguate the method call, write `A::foo(...)` instead\n note: candidate #2 is defined in an impl of the trait `B` for the type `AB`\n   --> $DIR/method-ambig-two-traits-from-impls2.rs:11:5\n    |\n LL |     fn foo() {}\n    |     ^^^^^^^^\n-   = help: to disambiguate the method call, write `B::foo(...)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     A::foo();\n+   |     ^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     B::foo();\n+   |     ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "3dbb17371004a9706fa9b7b0e96ecade7aeddef4", "filename": "src/test/ui/methods/method-ambig-two-traits-with-default-method.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-with-default-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-with-default-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-two-traits-with-default-method.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `Foo` for the type `usize`\n    |\n LL | trait Foo { fn method(&self) {} }\n    |             ^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `Foo::method(1_usize)` instead\n note: candidate #2 is defined in an impl of the trait `Bar` for the type `usize`\n   --> $DIR/method-ambig-two-traits-with-default-method.rs:6:13\n    |\n LL | trait Bar { fn method(&self) {} }\n    |             ^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `Bar::method(1_usize)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     Foo::method(&1_usize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     Bar::method(&1_usize);\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e7f295df8c482642c7ea78a1fb71e0ee975ad094", "filename": "src/test/ui/methods/method-deref-to-same-trait-object-with-separate-params.stderr", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-deref-to-same-trait-object-with-separate-params.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -25,19 +25,28 @@ note: candidate #1 is defined in an impl of the trait `internal::X` for the type\n    |\n LL |         fn foo(self: Smaht<Self, u64>) -> u64 {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `internal::X::foo(x)` instead\n note: candidate #2 is defined in an impl of the trait `nuisance_foo::NuisanceFoo` for the type `_`\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:70:9\n    |\n LL |         fn foo(self) {}\n    |         ^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `nuisance_foo::NuisanceFoo::foo(x)` instead\n note: candidate #3 is defined in the trait `FinalFoo`\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:57:5\n    |\n LL |     fn foo(&self) -> u8;\n    |     ^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `FinalFoo::foo(x)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     let z = internal::X::foo(x);\n+   |             ^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     let z = nuisance_foo::NuisanceFoo::foo(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #3\n+   |\n+LL |     let z = FinalFoo::foo(x);\n+   |             ^^^^^^^^^^^^^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/method-deref-to-same-trait-object-with-separate-params.rs:137:24"}, {"sha": "1219badc5b3fcfca96001cfd251772d2c762fb21", "filename": "src/test/ui/missing/missing-items/missing-type-parameter.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-items%2Fmissing-type-parameter.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/missing-type-parameter.rs:4:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for type parameter `X`\n+   |     ^^^ cannot infer type for type parameter `X` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "9ed6c8b826f79f04b2e59f40ace4832c7846ad91", "filename": "src/test/ui/span/issue-37767.stderr", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fspan%2Fissue-37767.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fspan%2Fissue-37767.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-37767.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in the trait `A`\n    |\n LL |     fn foo(&mut self) {}\n    |     ^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `A::foo(&a)` instead\n note: candidate #2 is defined in the trait `B`\n   --> $DIR/issue-37767.rs:6:5\n    |\n LL |     fn foo(&mut self) {}\n    |     ^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `B::foo(&a)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     A::foo(&a)\n+   |     ^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     B::foo(&a)\n+   |     ^^^^^^^^^^\n \n error[E0034]: multiple applicable items in scope\n   --> $DIR/issue-37767.rs:22:7\n@@ -28,13 +34,19 @@ note: candidate #1 is defined in the trait `C`\n    |\n LL |     fn foo(&self) {}\n    |     ^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `C::foo(&a)` instead\n note: candidate #2 is defined in the trait `D`\n   --> $DIR/issue-37767.rs:18:5\n    |\n LL |     fn foo(&self) {}\n    |     ^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `D::foo(&a)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     C::foo(&a)\n+   |     ^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     D::foo(&a)\n+   |     ^^^^^^^^^^\n \n error[E0034]: multiple applicable items in scope\n   --> $DIR/issue-37767.rs:34:7\n@@ -47,13 +59,19 @@ note: candidate #1 is defined in the trait `E`\n    |\n LL |     fn foo(self) {}\n    |     ^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `E::foo(a)` instead\n note: candidate #2 is defined in the trait `F`\n   --> $DIR/issue-37767.rs:30:5\n    |\n LL |     fn foo(self) {}\n    |     ^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `F::foo(a)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     E::foo(a)\n+   |     ^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     F::foo(a)\n+   |     ^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "53a6238422b571217f1b1a854f438540d0e6b031", "filename": "src/test/ui/span/issue-7575.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -10,24 +10,33 @@ note: candidate #1 is defined in the trait `CtxtFn`\n    |\n LL |     fn f9(_: usize) -> usize;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `CtxtFn::f9(u, 342)` instead\n note: candidate #2 is defined in the trait `OtherTrait`\n   --> $DIR/issue-7575.rs:8:5\n    |\n LL |     fn f9(_: usize) -> usize;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `OtherTrait::f9(u, 342)` instead\n note: candidate #3 is defined in the trait `UnusedTrait`\n   --> $DIR/issue-7575.rs:17:5\n    |\n LL |     fn f9(_: usize) -> usize;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `UnusedTrait::f9(u, 342)` instead\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following traits define an item `f9`, perhaps you need to implement one of them:\n            candidate #1: `CtxtFn`\n            candidate #2: `OtherTrait`\n            candidate #3: `UnusedTrait`\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     u.f8(42) + CtxtFn::f9(u, 342) + m.fff(42)\n+   |                ^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     u.f8(42) + OtherTrait::f9(u, 342) + m.fff(42)\n+   |                ^^^^^^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #3\n+   |\n+LL |     u.f8(42) + UnusedTrait::f9(u, 342) + m.fff(42)\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0599]: no method named `fff` found for type `Myisize` in the current scope\n   --> $DIR/issue-7575.rs:62:30\n@@ -60,8 +69,11 @@ note: the candidate is defined in the trait `ManyImplTrait`\n    |\n LL |     fn is_str() -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `ManyImplTrait::is_str(t)` instead\n    = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: disambiguate the method call for the candidate\n+   |\n+LL |     ManyImplTrait::is_str(t)\n+   |\n help: the following trait defines an item `is_str`, perhaps you need to restrict type parameter `T` with it:\n    |\n LL | fn param_bound<T: ManyImplTrait + ManyImplTrait>(t: T) -> bool {"}, {"sha": "2b92f9b93bff202d649abff9553db97955d293ad", "filename": "src/test/ui/span/type-annotations-needed-expr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftype-annotations-needed-expr.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed\n LL |     let _ = (vec![1,2,3]).into_iter().sum() as f64;\n    |                                       ^^^\n    |                                       |\n-   |                                       cannot infer type for type parameter `S`\n+   |                                       cannot infer type for type parameter `S` declared on the method `sum`\n    |                                       help: consider specifying the type argument in the method call: `sum::<S>`\n    |\n    = note: type must be known at this point"}, {"sha": "48a029104aeca8842485eef2035c67c3a644ac86", "filename": "src/test/ui/traits/trait-alias-ambiguous.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-alias-ambiguous.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -9,13 +9,19 @@ note: candidate #1 is defined in an impl of the trait `inner::A` for the type `u\n    |\n LL |         fn foo(&self) {}\n    |         ^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `inner::A::foo(t)` instead\n note: candidate #2 is defined in an impl of the trait `inner::B` for the type `u8`\n   --> $DIR/trait-alias-ambiguous.rs:11:9\n    |\n LL |         fn foo(&self) {}\n    |         ^^^^^^^^^^^^^\n-   = help: to disambiguate the method call, write `inner::B::foo(t)` instead\n+help: disambiguate the method call for candidate #1\n+   |\n+LL |     inner::A::foo(&t);\n+   |     ^^^^^^^^^^^^^^^^^\n+help: disambiguate the method call for candidate #2\n+   |\n+LL |     inner::B::foo(&t);\n+   |     ^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "338c8cbf2e4f2e6851b930d9298c0d2ba8e77ae9", "filename": "src/test/ui/traits/traits-multidispatch-convert-ambig-dest.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftraits%2Ftraits-multidispatch-convert-ambig-dest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftraits%2Ftraits-multidispatch-convert-ambig-dest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftraits-multidispatch-convert-ambig-dest.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/traits-multidispatch-convert-ambig-dest.rs:26:5\n    |\n LL |     test(22, std::default::Default::default());\n-   |     ^^^^ cannot infer type for type parameter `U`\n+   |     ^^^^ cannot infer type for type parameter `U` declared on the function `test`\n \n error: aborting due to previous error\n "}, {"sha": "b9258b20f5addebb58e9bea0231ecd6a688d2afa", "filename": "src/test/ui/type-inference/or_else-multiple-type-params.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2For_else-multiple-type-params.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed\n LL |         .or_else(|err| {\n    |          ^^^^^^^\n    |          |\n-   |          cannot infer type for type parameter `F`\n+   |          cannot infer type for type parameter `F` declared on the method `or_else`\n    |          help: consider specifying the type arguments in the method call: `or_else::<F, O>`\n \n error: aborting due to previous error"}, {"sha": "e74c0dfa5e20c8e1e316e0ef29982c68e8be0339", "filename": "src/test/ui/type-inference/sort_by_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Fsort_by_key.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -4,7 +4,7 @@ error[E0282]: type annotations needed\n LL |     lst.sort_by_key(|&(v, _)| v.iter().sum());\n    |         ^^^^^^^^^^^                    --- help: consider specifying the type argument in the method call: `sum::<S>`\n    |         |\n-   |         cannot infer type for type parameter `K`\n+   |         cannot infer type for type parameter `K` declared on the method `sort_by_key`\n \n error: aborting due to previous error\n "}, {"sha": "19e2bd4513dc51ded1545baf22dfbfca5f8f5c0e", "filename": "src/test/ui/type-inference/unbounded-associated-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-associated-type.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -8,7 +8,7 @@ LL |     S(std::marker::PhantomData).foo();\n    |     ^--------------------------------\n    |     |\n    |     this method call resolves to `<Self as T>::A`\n-   |     cannot infer type for type parameter `X`\n+   |     cannot infer type for type parameter `X` declared on the struct `S`\n \n error: aborting due to previous error\n "}, {"sha": "d60ca4a49325c112b3e0e95edbe2b16deaf78108", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn-with-assoc-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn-with-assoc-type.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/unbounded-type-param-in-fn-with-assoc-type.rs:8:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for type parameter `T`\n+   |     ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "45d879d8d5670647ccf57e766b3dc8a013f438c1", "filename": "src/test/ui/type-inference/unbounded-type-param-in-fn.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-inference%2Funbounded-type-param-in-fn.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/unbounded-type-param-in-fn.rs:6:5\n    |\n LL |     foo();\n-   |     ^^^ cannot infer type for type parameter `T`\n+   |     ^^^ cannot infer type for type parameter `T` declared on the function `foo`\n \n error: aborting due to previous error\n "}, {"sha": "c6a811e836342b6552ba8920112ba1b50fb3a959", "filename": "src/test/ui/type/type-annotation-needed.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-annotation-needed.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -7,7 +7,7 @@ LL | fn foo<T: Into<String>>(x: i32) {}\n LL |     foo(42);\n    |     ^^^\n    |     |\n-   |     cannot infer type for type parameter `T`\n+   |     cannot infer type for type parameter `T` declared on the function `foo`\n    |     help: consider specifying the type argument in the function call: `foo::<T>`\n    |\n    = note: cannot resolve `_: std::convert::Into<std::string::String>`"}, {"sha": "fbd71bd091d0b6ed300d9eb4301e6783fac1930b", "filename": "src/test/ui/unconstrained-none.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Funconstrained-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Funconstrained-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funconstrained-none.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/unconstrained-none.rs:4:5\n    |\n LL |     None;\n-   |     ^^^^ cannot infer type for type parameter `T`\n+   |     ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n \n error: aborting due to previous error\n "}, {"sha": "eb8ebb5165d180da4b9a3db4afee28e2ab464367", "filename": "src/test/ui/unconstrained-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Funconstrained-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6b561b4917e803c4be4ca44d8e552b680cb9e380/src%2Ftest%2Fui%2Funconstrained-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funconstrained-ref.stderr?ref=6b561b4917e803c4be4ca44d8e552b680cb9e380", "patch": "@@ -2,7 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/unconstrained-ref.rs:6:5\n    |\n LL |     S { o: &None };\n-   |     ^ cannot infer type for type parameter `T`\n+   |     ^ cannot infer type for type parameter `T` declared on the struct `S`\n \n error: aborting due to previous error\n "}]}