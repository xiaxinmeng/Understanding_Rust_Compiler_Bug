{"sha": "2bfed908e39f162532be56d9680295bb383ddcf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZmVkOTA4ZTM5ZjE2MjUzMmJlNTZkOTY4MDI5NWJiMzgzZGRjZjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-07T23:13:31Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-08T02:06:29Z"}, "message": "Fix #1941: inlining of items that themselves contain nested items\n\nThe fix is to drop nested items from the encoded AST.  Nested items may\nthemselves be inlined, but that is an independent question.", "tree": {"sha": "8bb5b9cb6d3cfc773dd321eedf07985a962cd2d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bb5b9cb6d3cfc773dd321eedf07985a962cd2d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bfed908e39f162532be56d9680295bb383ddcf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bfed908e39f162532be56d9680295bb383ddcf2", "html_url": "https://github.com/rust-lang/rust/commit/2bfed908e39f162532be56d9680295bb383ddcf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bfed908e39f162532be56d9680295bb383ddcf2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9375fed8d55197a528edb3c3182aaf3b71abe76", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9375fed8d55197a528edb3c3182aaf3b71abe76", "html_url": "https://github.com/rust-lang/rust/commit/c9375fed8d55197a528edb3c3182aaf3b71abe76"}], "stats": {"total": 137, "additions": 132, "deletions": 5}, "files": [{"sha": "d7215fbfcab30eaa78e2844938453c7554d2ffea", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=2bfed908e39f162532be56d9680295bb383ddcf2", "patch": "@@ -63,7 +63,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n     let id_range = compute_id_range(ii);\n     ebml_w.wr_tag(c::tag_ast as uint) {||\n         encode_id_range(ebml_w, id_range);\n-        encode_ast(ebml_w, ii);\n+        encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, ebml_w, ii);\n     }\n \n@@ -326,6 +326,44 @@ fn encode_ast(ebml_w: ebml::writer, item: ast::inlined_item) {\n     }\n }\n \n+// Produces a simplified copy of the AST which does not include things\n+// that we do not need to or do not want to export.  For example, we\n+// do not include any nested items: if these nested items are to be\n+// inlined, their AST will be exported separately (this only makes\n+// sense because, in Rust, nested items are independent except for\n+// their visibility).\n+//\n+// As it happens, trans relies on the fact that we do not export\n+// nested items, as otherwise it would get confused when translating\n+// inlined items.\n+fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n+    fn drop_nested_items(blk: ast::blk_, fld: fold::ast_fold) -> ast::blk_ {\n+        let stmts_sans_items = vec::filter(blk.stmts) {|stmt|\n+            alt stmt.node {\n+              ast::stmt_expr(_, _) | ast::stmt_semi(_, _) |\n+              ast::stmt_decl(@{node: ast::decl_local(_), span: _}, _) { true }\n+              ast::stmt_decl(@{node: ast::decl_item(_), span: _}, _) { false }\n+            }\n+        };\n+        let blk_sans_items = { stmts: stmts_sans_items with blk };\n+        fold::noop_fold_block(blk_sans_items, fld)\n+    }\n+\n+    let fld = fold::make_fold({\n+        fold_block: fold::wrap(drop_nested_items)\n+        with *fold::default_ast_fold()\n+    });\n+\n+    alt ii {\n+      ast::ii_item(i) {\n+        ast::ii_item(fld.fold_item(i))\n+      }\n+      ast::ii_method(d, m) {\n+        ast::ii_method(d, fld.fold_method(m))\n+      }\n+    }\n+}\n+\n fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree];\n     let d = serialization::mk_ebml_deserializer(chi_doc);\n@@ -923,3 +961,26 @@ fn test_more() {\n         }\n     });\n }\n+\n+#[test]\n+fn test_simplification() {\n+    let ext_cx = mk_ctxt();\n+    let item_in = ast::ii_item(#ast(item) {\n+        fn new_int_alist<B: copy>() -> alist<int, B> {\n+            fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+            ret {eq_fn: eq_int, mut data: []};\n+        }\n+    });\n+    let item_out = simplify_ast(item_in);\n+    let item_exp = ast::ii_item(#ast(item) {\n+        fn new_int_alist<B: copy>() -> alist<int, B> {\n+            ret {eq_fn: eq_int, mut data: []};\n+        }\n+    });\n+    alt (item_out, item_exp) {\n+      (ast::ii_item(item_out), ast::ii_item(item_exp)) {\n+        assert pprust::item_to_str(item_out) == pprust::item_to_str(item_exp);\n+      }\n+      _ { fail; }\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "910c6c93ac59c271ec8937093a01a5be43591117", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2bfed908e39f162532be56d9680295bb383ddcf2", "patch": "@@ -2146,18 +2146,31 @@ fn monomorphic_fn(ccx: crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n fn maybe_instantiate_inline(ccx: crate_ctxt, fn_id: ast::def_id)\n     -> ast::def_id {\n     alt ccx.external.find(fn_id) {\n-      some(some(node_id)) { local_def(node_id) } // Already inline\n+      some(some(node_id)) {\n+        // Already inline\n+        #debug[\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+               ty::item_path_str(ccx.tcx, fn_id), node_id];\n+        local_def(node_id)\n+      }\n       some(none) { fn_id } // Not inlinable\n       none { // Not seen yet\n         alt csearch::maybe_get_item_ast(ccx.tcx, ccx.maps, fn_id) {\n           none { ccx.external.insert(fn_id, none); fn_id }\n           some(ast::ii_item(item)) {\n+            #debug[\"maybe_instantiate_inline(%s): inlining to local id %d\",\n+                   ty::item_path_str(ccx.tcx, fn_id),\n+                   item.id];\n             ccx.external.insert(fn_id, some(item.id));\n             collect_item(ccx, @mutable none, item);\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n           some(ast::ii_method(impl_did, mth)) {\n+            #debug[\"maybe_instantiate_inline(%s): \\\n+                    inlining method of %s to %d\",\n+                   ty::item_path_str(ccx.tcx, fn_id),\n+                   ty::item_path_str(ccx.tcx, impl_did),\n+                   mth.id];\n             ccx.external.insert(fn_id, some(mth.id));\n             compute_ii_method_info(ccx, impl_did, mth) {|ty, bounds, path|\n                 let mth_ty = ty::node_id_to_type(ccx.tcx, mth.id);\n@@ -3586,7 +3599,7 @@ fn zero_alloca(cx: block, llptr: ValueRef, t: ty::t)\n }\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n-    #debug[\"trans_expr(%s)\", stmt_to_str(s)];\n+    #debug[\"trans_stmt(%s)\", stmt_to_str(s)];\n \n     if (!cx.sess().opts.no_asm_comments) {\n         add_span_comment(cx, s.span, stmt_to_str(s));\n@@ -4330,8 +4343,10 @@ fn trans_item(ccx: crate_ctxt, item: ast::item) {\n         let llfndecl = alt ccx.item_ids.find(item.id) {\n           some(llfndecl) { llfndecl }\n           _ {\n-            ccx.sess.span_bug(item.span,\n-                                \"unbound function item in trans_item\");\n+            ccx.sess.span_bug(\n+                item.span,\n+                #fmt[\"unbound function item %s in trans_item\",\n+                     ast_map::path_to_str(*path)]);\n           }\n         };\n         if decl.purity != ast::crust_fn  {"}, {"sha": "42ac5ca7da628af4b5482dbc21159fc1950ca99c", "filename": "src/rustc/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Frustc%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Frustc%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Ffold.rs?ref=2bfed908e39f162532be56d9680295bb383ddcf2", "patch": "@@ -11,6 +11,7 @@ export noop_fold_expr;\n export noop_fold_pat;\n export noop_fold_mod;\n export noop_fold_ty;\n+export noop_fold_block;\n export wrap;\n \n type ast_fold = @mutable a_f;"}, {"sha": "9e3169119bcd12760b749fc31be99c537ef7586a", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=2bfed908e39f162532be56d9680295bb383ddcf2", "patch": "@@ -0,0 +1,29 @@\n+type alist<A,B> = { eq_fn: fn@(A,A) -> bool, mut data: [(A,B)] };\n+\n+fn alist_add<A: copy, B: copy>(lst: alist<A,B>, k: A, v: B) {\n+    lst.data += [(k, v)];\n+}\n+\n+fn alist_get<A: copy, B: copy>(lst: alist<A,B>, k: A) -> B {\n+    let eq_fn = lst.eq_fn;\n+    for pair in lst.data {\n+        let (ki, vi) = pair; // copy req'd for alias analysis\n+        if eq_fn(k, ki) { ret vi; }\n+    }\n+    fail;\n+}\n+\n+#[inline]\n+fn new_int_alist<B: copy>() -> alist<int, B> {\n+    fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+    ret {eq_fn: eq_int,\n+         mut data: []};\n+}\n+\n+#[inline]\n+fn new_int_alist_2<B: copy>() -> alist<int, B> {\n+    #[inline]\n+    fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n+    ret {eq_fn: eq_int,\n+         mut data: []};\n+}\n\\ No newline at end of file"}, {"sha": "c258d2d15b675de0ca843616ac4d32b5fbe25dd3", "filename": "src/test/run-pass/cci_nested_exe.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bfed908e39f162532be56d9680295bb383ddcf2/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_nested_exe.rs?ref=2bfed908e39f162532be56d9680295bb383ddcf2", "patch": "@@ -0,0 +1,21 @@\n+// xfail-fast - check-fast doesn't understand aux-build\n+// aux-build:cci_nested_lib.rs\n+\n+use std;\n+use cci_nested_lib;\n+import std::io;\n+import cci_nested_lib::*;\n+\n+fn main() {\n+    let lst = new_int_alist();\n+    alist_add(lst, 22, \"hi\");\n+    alist_add(lst, 44, \"ho\");\n+    assert alist_get(lst, 22) == \"hi\";\n+    assert alist_get(lst, 44) == \"ho\";\n+\n+    let lst = new_int_alist_2();\n+    alist_add(lst, 22, \"hi\");\n+    alist_add(lst, 44, \"ho\");\n+    assert alist_get(lst, 22) == \"hi\";\n+    assert alist_get(lst, 44) == \"ho\";\n+}"}]}