{"sha": "f633537f3e4d47a2e1f96daee68e1063e0da17d4", "node_id": "C_kwDOAAsO6NoAKGY2MzM1MzdmM2U0ZDQ3YTJlMWY5NmRhZWU2OGUxMDYzZTBkYTE3ZDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-06T15:01:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-06T15:01:44Z"}, "message": "Auto merge of #2469 - RalfJung:math, r=RalfJung\n\nimplement some missing float functions\n\nWith this we support the entire float API surface of the standard library. :)\n\nAlso fixes https://github.com/rust-lang/miri/issues/2468 by using host floats to implement FMA.", "tree": {"sha": "b572061aaaff27e3cf144e16dc4c14d2188a4ff5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b572061aaaff27e3cf144e16dc4c14d2188a4ff5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f633537f3e4d47a2e1f96daee68e1063e0da17d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f633537f3e4d47a2e1f96daee68e1063e0da17d4", "html_url": "https://github.com/rust-lang/rust/commit/f633537f3e4d47a2e1f96daee68e1063e0da17d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f633537f3e4d47a2e1f96daee68e1063e0da17d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6b750e48d5ec04b29e3f8897c288ac0b0fb52ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b750e48d5ec04b29e3f8897c288ac0b0fb52ff", "html_url": "https://github.com/rust-lang/rust/commit/d6b750e48d5ec04b29e3f8897c288ac0b0fb52ff"}, {"sha": "b1316eca922655f5d81559c1c26f457693aa5c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1316eca922655f5d81559c1c26f457693aa5c2b", "html_url": "https://github.com/rust-lang/rust/commit/b1316eca922655f5d81559c1c26f457693aa5c2b"}], "stats": {"total": 178, "additions": 127, "deletions": 51}, "files": [{"sha": "e7cfd43f1b1e7dd184752c1c96d294d21e81252b", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f633537f3e4d47a2e1f96daee68e1063e0da17d4/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f633537f3e4d47a2e1f96daee68e1063e0da17d4/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=f633537f3e4d47a2e1f96daee68e1063e0da17d4", "patch": "@@ -575,88 +575,106 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_machine_usize(u64::try_from(n).unwrap(), this), dest)?;\n             }\n \n-            // math functions\n+            // math functions (note that there are also intrinsics for some other functions)\n             #[rustfmt::skip]\n             | \"cbrtf\"\n             | \"coshf\"\n             | \"sinhf\"\n             | \"tanf\"\n+            | \"tanhf\"\n             | \"acosf\"\n             | \"asinf\"\n             | \"atanf\"\n+            | \"log1pf\"\n+            | \"expm1f\"\n             => {\n                 let [f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n-                let f = match link_name.as_str() {\n+                let res = match link_name.as_str() {\n                     \"cbrtf\" => f.cbrt(),\n                     \"coshf\" => f.cosh(),\n                     \"sinhf\" => f.sinh(),\n                     \"tanf\" => f.tan(),\n+                    \"tanhf\" => f.tanh(),\n                     \"acosf\" => f.acos(),\n                     \"asinf\" => f.asin(),\n                     \"atanf\" => f.atan(),\n+                    \"log1pf\" => f.ln_1p(),\n+                    \"expm1f\" => f.exp_m1(),\n                     _ => bug!(),\n                 };\n-                this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n             }\n             #[rustfmt::skip]\n             | \"_hypotf\"\n             | \"hypotf\"\n             | \"atan2f\"\n+            | \"fdimf\"\n             => {\n                 let [f1, f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // underscore case for windows, here and below\n                 // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n                 // FIXME: Using host floats.\n                 let f1 = f32::from_bits(this.read_scalar(f1)?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n-                let n = match link_name.as_str() {\n+                let res = match link_name.as_str() {\n                     \"_hypotf\" | \"hypotf\" => f1.hypot(f2),\n                     \"atan2f\" => f1.atan2(f2),\n+                    #[allow(deprecated)]\n+                    \"fdimf\" => f1.abs_sub(f2),\n                     _ => bug!(),\n                 };\n-                this.write_scalar(Scalar::from_u32(n.to_bits()), dest)?;\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n             }\n             #[rustfmt::skip]\n             | \"cbrt\"\n             | \"cosh\"\n             | \"sinh\"\n             | \"tan\"\n+            | \"tanh\"\n             | \"acos\"\n             | \"asin\"\n             | \"atan\"\n+            | \"log1p\"\n+            | \"expm1\"\n             => {\n                 let [f] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n-                let f = match link_name.as_str() {\n+                let res = match link_name.as_str() {\n                     \"cbrt\" => f.cbrt(),\n                     \"cosh\" => f.cosh(),\n                     \"sinh\" => f.sinh(),\n                     \"tan\" => f.tan(),\n+                    \"tanh\" => f.tanh(),\n                     \"acos\" => f.acos(),\n                     \"asin\" => f.asin(),\n                     \"atan\" => f.atan(),\n+                    \"log1p\" => f.ln_1p(),\n+                    \"expm1\" => f.exp_m1(),\n                     _ => bug!(),\n                 };\n-                this.write_scalar(Scalar::from_u64(f.to_bits()), dest)?;\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n             }\n             #[rustfmt::skip]\n             | \"_hypot\"\n             | \"hypot\"\n             | \"atan2\"\n+            | \"fdim\"\n             => {\n                 let [f1, f2] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 // FIXME: Using host floats.\n                 let f1 = f64::from_bits(this.read_scalar(f1)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n-                let n = match link_name.as_str() {\n+                let res = match link_name.as_str() {\n                     \"_hypot\" | \"hypot\" => f1.hypot(f2),\n                     \"atan2\" => f1.atan2(f2),\n+                    #[allow(deprecated)]\n+                    \"fdim\" => f1.abs_sub(f2),\n                     _ => bug!(),\n                 };\n-                this.write_scalar(Scalar::from_u64(n.to_bits()), dest)?;\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n             }\n             #[rustfmt::skip]\n             | \"_ldexp\"\n@@ -668,7 +686,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let x = this.read_scalar(x)?.to_f64()?;\n                 let exp = this.read_scalar(exp)?.to_i32()?;\n \n-                // Saturating cast to i16. Even those are outside the valid exponent range to\n+                // Saturating cast to i16. Even those are outside the valid exponent range so\n                 // `scalbn` below will do its over/underflow handling.\n                 let exp = if exp > i32::from(i16::MAX) {\n                     i16::MAX"}, {"sha": "08a6e0fcc0eef9070241083f9625a3cc87c589b8", "filename": "src/shims/intrinsics/mod.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f633537f3e4d47a2e1f96daee68e1063e0da17d4/src%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f633537f3e4d47a2e1f96daee68e1063e0da17d4/src%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fmod.rs?ref=f633537f3e4d47a2e1f96daee68e1063e0da17d4", "patch": "@@ -285,49 +285,55 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(f2)?.to_u32()?);\n-                this.write_scalar(Scalar::from_u32(f.powf(f2).to_bits()), dest)?;\n+                let res = f.powf(f2);\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n             }\n \n             \"powf64\" => {\n                 let [f, f2] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let f2 = f64::from_bits(this.read_scalar(f2)?.to_u64()?);\n-                this.write_scalar(Scalar::from_u64(f.powf(f2).to_bits()), dest)?;\n+                let res = f.powf(f2);\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n             }\n \n             \"fmaf32\" => {\n                 let [a, b, c] = check_arg_count(args)?;\n-                let a = this.read_scalar(a)?.to_f32()?;\n-                let b = this.read_scalar(b)?.to_f32()?;\n-                let c = this.read_scalar(c)?.to_f32()?;\n-                let res = a.mul_add(b, c).value;\n-                this.write_scalar(Scalar::from_f32(res), dest)?;\n+                // FIXME: Using host floats, to work around https://github.com/rust-lang/miri/issues/2468.\n+                let a = f32::from_bits(this.read_scalar(a)?.to_u32()?);\n+                let b = f32::from_bits(this.read_scalar(b)?.to_u32()?);\n+                let c = f32::from_bits(this.read_scalar(c)?.to_u32()?);\n+                let res = a.mul_add(b, c);\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n             }\n \n             \"fmaf64\" => {\n                 let [a, b, c] = check_arg_count(args)?;\n-                let a = this.read_scalar(a)?.to_f64()?;\n-                let b = this.read_scalar(b)?.to_f64()?;\n-                let c = this.read_scalar(c)?.to_f64()?;\n-                let res = a.mul_add(b, c).value;\n-                this.write_scalar(Scalar::from_f64(res), dest)?;\n+                // FIXME: Using host floats, to work around https://github.com/rust-lang/miri/issues/2468.\n+                let a = f64::from_bits(this.read_scalar(a)?.to_u64()?);\n+                let b = f64::from_bits(this.read_scalar(b)?.to_u64()?);\n+                let c = f64::from_bits(this.read_scalar(c)?.to_u64()?);\n+                let res = a.mul_add(b, c);\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n             }\n \n             \"powif32\" => {\n                 let [f, i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f32::from_bits(this.read_scalar(f)?.to_u32()?);\n                 let i = this.read_scalar(i)?.to_i32()?;\n-                this.write_scalar(Scalar::from_u32(f.powi(i).to_bits()), dest)?;\n+                let res = f.powi(i);\n+                this.write_scalar(Scalar::from_u32(res.to_bits()), dest)?;\n             }\n \n             \"powif64\" => {\n                 let [f, i] = check_arg_count(args)?;\n                 // FIXME: Using host floats.\n                 let f = f64::from_bits(this.read_scalar(f)?.to_u64()?);\n                 let i = this.read_scalar(i)?.to_i32()?;\n-                this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n+                let res = f.powi(i);\n+                this.write_scalar(Scalar::from_u64(res.to_bits()), dest)?;\n             }\n \n             \"float_to_int_unchecked\" => {"}, {"sha": "0c3241683a186d64ffd98b6da6cbda77968ab1a4", "filename": "src/shims/intrinsics/simd.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f633537f3e4d47a2e1f96daee68e1063e0da17d4/src%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f633537f3e4d47a2e1f96daee68e1063e0da17d4/src%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fsimd.rs?ref=f633537f3e4d47a2e1f96daee68e1063e0da17d4", "patch": "@@ -238,14 +238,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let dest = this.mplace_index(&dest, i)?;\n \n                     // Works for f32 and f64.\n+                    // FIXME: using host floats to work around https://github.com/rust-lang/miri/issues/2468.\n                     let ty::Float(float_ty) = dest.layout.ty.kind() else {\n                         span_bug!(this.cur_span(), \"{} operand is not a float\", intrinsic_name)\n                     };\n                     let val = match float_ty {\n-                        FloatTy::F32 =>\n-                            Scalar::from_f32(a.to_f32()?.mul_add(b.to_f32()?, c.to_f32()?).value),\n-                        FloatTy::F64 =>\n-                            Scalar::from_f64(a.to_f64()?.mul_add(b.to_f64()?, c.to_f64()?).value),\n+                        FloatTy::F32 => {\n+                            let a = f32::from_bits(a.to_u32()?);\n+                            let b = f32::from_bits(b.to_u32()?);\n+                            let c = f32::from_bits(c.to_u32()?);\n+                            let res = a.mul_add(b, c);\n+                            Scalar::from_u32(res.to_bits())\n+                        }\n+                        FloatTy::F64 => {\n+                            let a = f64::from_bits(a.to_u64()?);\n+                            let b = f64::from_bits(b.to_u64()?);\n+                            let c = f64::from_bits(c.to_u64()?);\n+                            let res = a.mul_add(b, c);\n+                            Scalar::from_u64(res.to_bits())\n+                        }\n                     };\n                     this.write_scalar(val, &dest.into())?;\n                 }"}, {"sha": "5973f4cd197fe78a0a8e7545dc3cac689222c8dc", "filename": "tests/pass/intrinsics-math.rs", "status": "modified", "additions": 54, "deletions": 23, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f633537f3e4d47a2e1f96daee68e1063e0da17d4/tests%2Fpass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f633537f3e4d47a2e1f96daee68e1063e0da17d4/tests%2Fpass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fintrinsics-math.rs?ref=f633537f3e4d47a2e1f96daee68e1063e0da17d4", "patch": "@@ -32,24 +32,24 @@ pub fn main() {\n     assert_approx_eq!(25f32.powi(-2), 0.0016f32);\n     assert_approx_eq!(23.2f64.powi(2), 538.24f64);\n \n-    assert_approx_eq!(0f32.sin(), 0f32);\n-    assert_approx_eq!((f64::consts::PI / 2f64).sin(), 1f64);\n-\n-    assert_approx_eq!(0f32.cos(), 1f32);\n-    assert_approx_eq!((f64::consts::PI * 2f64).cos(), 1f64);\n-\n     assert_approx_eq!(25f32.powf(-2f32), 0.0016f32);\n     assert_approx_eq!(400f64.powf(0.5f64), 20f64);\n \n-    assert_approx_eq!((1f32.exp() - f32::consts::E).abs(), 0f32);\n+    assert_approx_eq!(1f32.exp(), f32::consts::E);\n     assert_approx_eq!(1f64.exp(), f64::consts::E);\n \n+    assert_approx_eq!(1f32.exp_m1(), f32::consts::E - 1.0);\n+    assert_approx_eq!(1f64.exp_m1(), f64::consts::E - 1.0);\n+\n     assert_approx_eq!(10f32.exp2(), 1024f32);\n     assert_approx_eq!(50f64.exp2(), 1125899906842624f64);\n \n-    assert_approx_eq!((f32::consts::E.ln() - 1f32).abs(), 0f32);\n+    assert_approx_eq!(f32::consts::E.ln(), 1f32);\n     assert_approx_eq!(1f64.ln(), 0f64);\n \n+    assert_approx_eq!(0f32.ln_1p(), 0f32);\n+    assert_approx_eq!(0f64.ln_1p(), 0f64);\n+\n     assert_approx_eq!(10f32.log10(), 1f32);\n     assert_approx_eq!(f64::consts::E.log10(), f64::consts::LOG10_E);\n \n@@ -60,10 +60,18 @@ pub fn main() {\n     assert_eq!(0.0f32.mul_add(-2.0, f32::consts::E), f32::consts::E);\n     assert_approx_eq!(3.0f64.mul_add(2.0, 5.0), 11.0);\n     assert_eq!(0.0f64.mul_add(-2.0f64, f64::consts::E), f64::consts::E);\n+    assert_eq!((-3.2f32).mul_add(2.4, f32::NEG_INFINITY), f32::NEG_INFINITY);\n+    assert_eq!((-3.2f64).mul_add(2.4, f64::NEG_INFINITY), f64::NEG_INFINITY);\n \n     assert_approx_eq!((-1.0f32).abs(), 1.0f32);\n     assert_approx_eq!(34.2f64.abs(), 34.2f64);\n \n+    #[allow(deprecated)]\n+    {\n+        assert_approx_eq!(5.0f32.abs_sub(3.0), 2.0);\n+        assert_approx_eq!(3.0f64.abs_sub(5.0), 0.0);\n+    }\n+\n     assert_approx_eq!(3.8f32.floor(), 3.0f32);\n     assert_approx_eq!((-1.1f64).floor(), -2.0f64);\n \n@@ -79,31 +87,54 @@ pub fn main() {\n     assert_approx_eq!(3.0f32.hypot(4.0f32), 5.0f32);\n     assert_approx_eq!(3.0f64.hypot(4.0f64), 5.0f64);\n \n-    assert_approx_eq!(1.0f32.atan2(2.0f32), 0.46364761f32);\n-    assert_approx_eq!(1.0f32.atan2(2.0f32), 0.46364761f32);\n+    assert_eq!(3.3_f32.round(), 3.0);\n+    assert_eq!(3.3_f64.round(), 3.0);\n \n-    assert_approx_eq!(1.0f32.cosh(), 1.54308f32);\n-    assert_approx_eq!(1.0f64.cosh(), 1.54308f64);\n+    assert_eq!(ldexp(0.65f64, 3i32), 5.2f64);\n+    assert_eq!(ldexp(1.42, 0xFFFF), f64::INFINITY);\n+    assert_eq!(ldexp(1.42, -0xFFFF), 0f64);\n+\n+    // Trigonometric functions.\n+\n+    assert_approx_eq!(0f32.sin(), 0f32);\n+    assert_approx_eq!((f64::consts::PI / 2f64).sin(), 1f64);\n+    assert_approx_eq!(f32::consts::FRAC_PI_6.sin(), 0.5);\n+    assert_approx_eq!(f64::consts::FRAC_PI_6.sin(), 0.5);\n+    assert_approx_eq!(f32::consts::FRAC_PI_4.sin().asin(), f32::consts::FRAC_PI_4);\n+    assert_approx_eq!(f64::consts::FRAC_PI_4.sin().asin(), f64::consts::FRAC_PI_4);\n \n     assert_approx_eq!(1.0f32.sinh(), 1.1752012f32);\n     assert_approx_eq!(1.0f64.sinh(), 1.1752012f64);\n+    assert_approx_eq!(2.0f32.asinh(), 1.443635475178810342493276740273105f32);\n+    assert_approx_eq!((-2.0f64).asinh(), -1.443635475178810342493276740273105f64);\n \n-    assert_approx_eq!(1.0f32.tan(), 1.557408f32);\n-    assert_approx_eq!(1.0f64.tan(), 1.557408f64);\n-\n+    assert_approx_eq!(0f32.cos(), 1f32);\n+    assert_approx_eq!((f64::consts::PI * 2f64).cos(), 1f64);\n+    assert_approx_eq!(f32::consts::FRAC_PI_3.cos(), 0.5);\n+    assert_approx_eq!(f64::consts::FRAC_PI_3.cos(), 0.5);\n     assert_approx_eq!(f32::consts::FRAC_PI_4.cos().acos(), f32::consts::FRAC_PI_4);\n     assert_approx_eq!(f64::consts::FRAC_PI_4.cos().acos(), f64::consts::FRAC_PI_4);\n \n-    assert_approx_eq!(f32::consts::FRAC_PI_4.sin().asin(), f32::consts::FRAC_PI_4);\n-    assert_approx_eq!(f64::consts::FRAC_PI_4.sin().asin(), f64::consts::FRAC_PI_4);\n+    assert_approx_eq!(1.0f32.cosh(), 1.54308f32);\n+    assert_approx_eq!(1.0f64.cosh(), 1.54308f64);\n+    assert_approx_eq!(2.0f32.acosh(), 1.31695789692481670862504634730796844f32);\n+    assert_approx_eq!(3.0f64.acosh(), 1.76274717403908605046521864995958461f64);\n \n+    assert_approx_eq!(1.0f32.tan(), 1.557408f32);\n+    assert_approx_eq!(1.0f64.tan(), 1.557408f64);\n     assert_approx_eq!(1.0_f32, 1.0_f32.tan().atan());\n     assert_approx_eq!(1.0_f64, 1.0_f64.tan().atan());\n+    assert_approx_eq!(1.0f32.atan2(2.0f32), 0.46364761f32);\n+    assert_approx_eq!(1.0f32.atan2(2.0f32), 0.46364761f32);\n \n-    assert_eq!(3.3_f32.round(), 3.0);\n-    assert_eq!(3.3_f64.round(), 3.0);\n-\n-    assert_eq!(ldexp(0.65f64, 3i32), 5.2f64);\n-    assert_eq!(ldexp(1.42, 0xFFFF), f64::INFINITY);\n-    assert_eq!(ldexp(1.42, -0xFFFF), 0f64);\n+    assert_approx_eq!(\n+        1.0f32.tanh(),\n+        (1.0 - f32::consts::E.powi(-2)) / (1.0 + f32::consts::E.powi(-2))\n+    );\n+    assert_approx_eq!(\n+        1.0f64.tanh(),\n+        (1.0 - f64::consts::E.powi(-2)) / (1.0 + f64::consts::E.powi(-2))\n+    );\n+    assert_approx_eq!(0.5f32.atanh(), 0.54930614433405484569762261846126285f32);\n+    assert_approx_eq!(0.5f64.atanh(), 0.54930614433405484569762261846126285f64);\n }"}, {"sha": "173ac654b03d5e74aec5e1c9c209483aa5c31119", "filename": "tests/pass/portable-simd.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f633537f3e4d47a2e1f96daee68e1063e0da17d4/tests%2Fpass%2Fportable-simd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f633537f3e4d47a2e1f96daee68e1063e0da17d4/tests%2Fpass%2Fportable-simd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fportable-simd.rs?ref=f633537f3e4d47a2e1f96daee68e1063e0da17d4", "patch": "@@ -18,6 +18,11 @@ fn simd_ops_f32() {\n \n     assert_eq!(a.mul_add(b, a), (a * b) + a);\n     assert_eq!(b.mul_add(b, a), (b * b) + a);\n+    assert_eq!(a.mul_add(b, b), (a * b) + b);\n+    assert_eq!(\n+        f32x4::splat(-3.2).mul_add(b, f32x4::splat(f32::NEG_INFINITY)),\n+        f32x4::splat(f32::NEG_INFINITY)\n+    );\n     assert_eq!((a * a).sqrt(), a);\n     assert_eq!((b * b).sqrt(), b.abs());\n \n@@ -67,6 +72,11 @@ fn simd_ops_f64() {\n \n     assert_eq!(a.mul_add(b, a), (a * b) + a);\n     assert_eq!(b.mul_add(b, a), (b * b) + a);\n+    assert_eq!(a.mul_add(b, b), (a * b) + b);\n+    assert_eq!(\n+        f64x4::splat(-3.2).mul_add(b, f64x4::splat(f64::NEG_INFINITY)),\n+        f64x4::splat(f64::NEG_INFINITY)\n+    );\n     assert_eq!((a * a).sqrt(), a);\n     assert_eq!((b * b).sqrt(), b.abs());\n "}]}