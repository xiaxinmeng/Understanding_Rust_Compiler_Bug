{"sha": "cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNWMyNmYwZWI0OGM4ZjMyZWE4NmU5ZjI0MzRkOTA1ZmYyY2ZjNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-03T16:31:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-03T16:31:34Z"}, "message": "Auto merge of #53697 - Cyres:const-fn-int-ops, r=oli-obk\n\nAdd more const int ops\n\nr? @oli-obk\n\nTracking Issue: #53718\n\nlist of `const fn`s in this PR:\n\n- `feature = const_int_rotate`\n  - `rotate_left`\n  - `rotate_right`\n- `feature = const_int_wrapping`\n  - `wrapping_add`\n  - `wrapping_sub`\n  - `wrapping_mul`\n  - `wrapping_shl`\n  - `wrapping_shr`\n- `feature = const_int_overflowing`\n  - `overflowing_add`\n  - `overflowing_sub`\n  - `overflowing_mul`\n  - `overflowing_shl`\n  - `overflowing_shr`\n- `feature = const_int_sign`\n  - `is_positive`\n  - `is_negative`\n- `feature = const_int_conversion`\n  - `reverse_bits`\n  - `to_le_bytes`\n  - `to_ne_bytes`\n  - `from_be_bytes`\n  - `from_le_bytes`\n  - `from_ne_bytes`\n  - `reverse_bits`", "tree": {"sha": "155c8f01c3c62548c76441cb207504e1024345d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155c8f01c3c62548c76441cb207504e1024345d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "html_url": "https://github.com/rust-lang/rust/commit/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee73f80dc963707df3b3da82976556d64cac5752", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee73f80dc963707df3b3da82976556d64cac5752", "html_url": "https://github.com/rust-lang/rust/commit/ee73f80dc963707df3b3da82976556d64cac5752"}, {"sha": "4811e5b6c71657772b4c12e6f5cbb5c1624bf669", "url": "https://api.github.com/repos/rust-lang/rust/commits/4811e5b6c71657772b4c12e6f5cbb5c1624bf669", "html_url": "https://github.com/rust-lang/rust/commit/4811e5b6c71657772b4c12e6f5cbb5c1624bf669"}], "stats": {"total": 1091, "additions": 1033, "deletions": 58}, "files": [{"sha": "b0c93316301c44dbf822d01c28809a48ef1ad4f9", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -120,6 +120,13 @@\n #![feature(const_slice_len)]\n #![feature(const_str_as_bytes)]\n #![feature(const_str_len)]\n+#![feature(const_let)]\n+#![feature(const_int_rotate)]\n+#![feature(const_int_wrapping)]\n+#![feature(const_int_sign)]\n+#![feature(const_int_conversion)]\n+#![feature(const_transmute)]\n+#![feature(reverse_bits)]\n #![feature(non_exhaustive)]\n \n #[prelude_import]"}, {"sha": "19d3ad20247130fa6c33ec920eec8f1a78aab6a8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 497, "deletions": 56, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -338,6 +338,14 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn rotate_left(self, n: u32) -> Self {\n+            (self as $UnsignedT).rotate_left(n) as Self\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts the bits to the left by a specified amount, `n`,\n wrapping the truncated bits to the end of the resulting integer.\n@@ -355,12 +363,22 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n-            pub fn rotate_left(self, n: u32) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn rotate_left(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_left(n) as Self\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn rotate_right(self, n: u32) -> Self {\n+            (self as $UnsignedT).rotate_right(n) as Self\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts the bits to the right by a specified amount, `n`,\n wrapping the truncated bits to the beginning of the resulting\n@@ -379,11 +397,14 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n-            pub fn rotate_right(self, n: u32) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn rotate_right(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_right(n) as Self\n             }\n         }\n+\n         doc_comment! {\n             concat!(\"Reverses the byte order of the integer.\n \n@@ -406,6 +427,14 @@ assert_eq!(m, \", $swapped, \");\n             }\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn reverse_bits(self) -> Self {\n+            (self as $UnsignedT).reverse_bits() as Self\n+        }\n+\n         doc_comment! {\n             concat!(\"Reverses the bit pattern of the integer.\n \n@@ -422,8 +451,10 @@ let m = n.reverse_bits();\n assert_eq!(m, \", $reversed, \");\n ```\"),\n             #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n-            pub fn reverse_bits(self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn reverse_bits(self) -> Self {\n                 (self as $UnsignedT).reverse_bits() as Self\n             }\n         }\n@@ -973,6 +1004,16 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_add(self, rhs: Self) -> Self {\n+            unsafe {\n+                intrinsics::overflowing_add(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n boundary of the type.\n@@ -988,14 +1029,26 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!(\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_add(self, rhs: Self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_add(self, rhs: Self) -> Self {\n                 unsafe {\n                     intrinsics::overflowing_add(self, rhs)\n                 }\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_sub(self, rhs: Self) -> Self {\n+            unsafe {\n+                intrinsics::overflowing_sub(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n boundary of the type.\n@@ -1011,14 +1064,26 @@ stringify!($SelfT), \"::max_value());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_sub(self, rhs: Self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_sub(self, rhs: Self) -> Self {\n                 unsafe {\n                     intrinsics::overflowing_sub(self, rhs)\n                 }\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_mul(self, rhs: Self) -> Self {\n+            unsafe {\n+                intrinsics::overflowing_mul(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n the boundary of the type.\n@@ -1033,8 +1098,10 @@ assert_eq!(11i8.wrapping_mul(12), -124);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_mul(self, rhs: Self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_mul(self, rhs: Self) -> Self {\n                 unsafe {\n                     intrinsics::overflowing_mul(self, rhs)\n                 }\n@@ -1177,6 +1244,16 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n@@ -1196,14 +1273,26 @@ assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n                     intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n@@ -1223,8 +1312,10 @@ assert_eq!((-128i16).wrapping_shr(64), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n                     intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -1302,6 +1393,18 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = unsafe {\n+                intrinsics::add_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT)\n+            };\n+            (a as Self, b)\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` + `rhs`\n \n@@ -1319,9 +1422,11 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT),\n \"::MIN, true));\", $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = unsafe {\n                     intrinsics::add_with_overflow(self as $ActualT,\n                                                   rhs as $ActualT)\n@@ -1330,6 +1435,18 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($Sel\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = unsafe {\n+                intrinsics::sub_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT)\n+            };\n+            (a as Self, b)\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` - `rhs`\n \n@@ -1347,9 +1464,11 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT),\n \"::MAX, true));\", $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = unsafe {\n                     intrinsics::sub_with_overflow(self as $ActualT,\n                                                   rhs as $ActualT)\n@@ -1358,6 +1477,18 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($Sel\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = unsafe {\n+                intrinsics::mul_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT)\n+            };\n+            (a as Self, b)\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates the multiplication of `self` and `rhs`.\n \n@@ -1373,9 +1504,11 @@ Basic usage:\n assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = unsafe {\n                     intrinsics::mul_with_overflow(self as $ActualT,\n                                                   rhs as $ActualT)\n@@ -1545,6 +1678,14 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($Self\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts self left by `rhs` bits.\n \n@@ -1561,13 +1702,23 @@ Basic usage:\n assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts self right by `rhs` bits.\n \n@@ -1584,9 +1735,11 @@ Basic usage:\n assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n             }\n         }\n@@ -1850,6 +2003,12 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn is_positive(self) -> bool { self > 0 }\n+\n         doc_comment! {\n             concat!(\"Returns `true` if `self` is positive and `false` if the number is zero or\n negative.\n@@ -1864,10 +2023,18 @@ assert!(!(-10\", stringify!($SelfT), \").is_positive());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_sign\")]\n             #[inline]\n-            pub fn is_positive(self) -> bool { self > 0 }\n+            #[cfg(not(stage0))]\n+            pub const fn is_positive(self) -> bool { self > 0 }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn is_negative(self) -> bool { self < 0 }\n+\n         doc_comment! {\n             concat!(\"Returns `true` if `self` is negative and `false` if the number is zero or\n positive.\n@@ -1882,8 +2049,18 @@ assert!(!10\", stringify!($SelfT), \".is_negative());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_sign\")]\n             #[inline]\n-            pub fn is_negative(self) -> bool { self < 0 }\n+            #[cfg(not(stage0))]\n+            pub const fn is_negative(self) -> bool { self < 0 }\n+        }\n+\n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n         }\n \n         /// Return the memory representation of this integer as a byte array in\n@@ -1898,11 +2075,21 @@ $EndFeature, \"\n         /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        #[cfg(not(stage0))]\n+        pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             self.to_be().to_ne_bytes()\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n         /// Return the memory representation of this integer as a byte array in\n         /// little-endian byte order.\n         ///\n@@ -1915,11 +2102,21 @@ $EndFeature, \"\n         /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        #[cfg(not(stage0))]\n+        pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             self.to_le().to_ne_bytes()\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            unsafe { mem::transmute(self) }\n+        }\n+\n         /// Return the memory representation of this integer as a byte array in\n         /// native byte order.\n         ///\n@@ -1939,11 +2136,21 @@ $EndFeature, \"\n         /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        #[cfg(not(stage0))]\n+        pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n         /// Create an integer value from its representation as a byte array in\n         /// big endian.\n         ///\n@@ -1956,11 +2163,21 @@ $EndFeature, \"\n         /// assert_eq!(int, 0x12_34_56_78);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             Self::from_be(Self::from_ne_bytes(bytes))\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n         /// Create an integer value from its representation as a byte array in\n         /// little endian.\n         ///\n@@ -1973,11 +2190,21 @@ $EndFeature, \"\n         /// assert_eq!(int, 0x78_56_34_12);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             Self::from_le(Self::from_ne_bytes(bytes))\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            unsafe { mem::transmute(bytes) }\n+        }\n+\n         /// Create an integer value from its memory representation as a byte\n         /// array in native endianness.\n         ///\n@@ -1997,8 +2224,10 @@ $EndFeature, \"\n         /// assert_eq!(int, i32::min_value());\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }\n@@ -2217,6 +2446,16 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn rotate_left(self, n: u32) -> Self {\n+            // Protect against undefined behaviour for over-long bit shifts\n+            let n = n % $BITS;\n+            (self << n) | (self >> (($BITS - n) % $BITS))\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts the bits to the left by a specified amount, `n`,\n wrapping the truncated bits to the end of the resulting integer.\n@@ -2234,14 +2473,24 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n-            pub fn rotate_left(self, n: u32) -> Self {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self << n) | (self >> (($BITS - n) % $BITS))\n+            #[cfg(not(stage0))]\n+            pub const fn rotate_left(self, n: u32) -> Self {\n+                (self << (n % $BITS)) | (self >> (($BITS - (n % $BITS)) % $BITS))\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn rotate_right(self, n: u32) -> Self {\n+            // Protect against undefined behaviour for over-long bit shifts\n+            let n = n % $BITS;\n+            (self >> n) | (self << (($BITS - n) % $BITS))\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts the bits to the right by a specified amount, `n`,\n wrapping the truncated bits to the beginning of the resulting\n@@ -2260,11 +2509,11 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_rotate\")]\n             #[inline]\n-            pub fn rotate_right(self, n: u32) -> Self {\n-                // Protect against undefined behaviour for over-long bit shifts\n-                let n = n % $BITS;\n-                (self >> n) | (self << (($BITS - n) % $BITS))\n+            #[cfg(not(stage0))]\n+            pub const fn rotate_right(self, n: u32) -> Self {\n+                (self >> (n % $BITS)) | (self << (($BITS - (n % $BITS)) % $BITS))\n             }\n         }\n \n@@ -2290,6 +2539,14 @@ assert_eq!(m, \", $swapped, \");\n             }\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn reverse_bits(self) -> Self {\n+            unsafe { intrinsics::bitreverse(self as $ActualT) as Self }\n+        }\n+\n         doc_comment! {\n             concat!(\"Reverses the bit pattern of the integer.\n \n@@ -2306,8 +2563,10 @@ let m = n.reverse_bits();\n assert_eq!(m, \", $reversed, \");\n ```\"),\n             #[unstable(feature = \"reverse_bits\", issue = \"48763\")]\n+            #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n-            pub fn reverse_bits(self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn reverse_bits(self) -> Self {\n                 unsafe { intrinsics::bitreverse(self as $ActualT) as Self }\n             }\n         }\n@@ -2795,6 +3054,16 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_add(self, rhs: Self) -> Self {\n+            unsafe {\n+                intrinsics::overflowing_add(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) addition. Computes `self + rhs`,\n wrapping around at the boundary of the type.\n@@ -2809,14 +3078,26 @@ assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_add(self, rhs: Self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_add(self, rhs: Self) -> Self {\n                 unsafe {\n                     intrinsics::overflowing_add(self, rhs)\n                 }\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_sub(self, rhs: Self) -> Self {\n+            unsafe {\n+                intrinsics::overflowing_sub(self, rhs)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Wrapping (modular) subtraction. Computes `self - rhs`,\n wrapping around at the boundary of the type.\n@@ -2831,14 +3112,26 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_sub(self, rhs: Self) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_sub(self, rhs: Self) -> Self {\n                 unsafe {\n                     intrinsics::overflowing_sub(self, rhs)\n                 }\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_mul(self, rhs: Self) -> Self {\n+            unsafe {\n+                intrinsics::overflowing_mul(self, rhs)\n+            }\n+        }\n+\n         /// Wrapping (modular) multiplication. Computes `self *\n         /// rhs`, wrapping around at the boundary of the type.\n         ///\n@@ -2854,8 +3147,10 @@ $EndFeature, \"\n         /// assert_eq!(25u8.wrapping_mul(12), 44);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n         #[inline]\n-        pub fn wrapping_mul(self, rhs: Self) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_mul(self, rhs)\n             }\n@@ -2976,6 +3271,16 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_mod_euc(10), 0);\n             self.overflowing_neg().0\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n where `mask` removes any high-order bits of `rhs` that\n@@ -2997,14 +3302,26 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_shl(self, rhs: u32) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n                     intrinsics::unchecked_shl(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            unsafe {\n+                intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n+            }\n+        }\n+\n         doc_comment! {\n             concat!(\"Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n where `mask` removes any high-order bits of `rhs` that\n@@ -3026,8 +3343,10 @@ Basic usage:\n assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_wrapping\")]\n             #[inline]\n-            pub fn wrapping_shr(self, rhs: u32) -> Self {\n+            #[cfg(not(stage0))]\n+            pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n                     intrinsics::unchecked_shr(self, (rhs & ($BITS - 1)) as $SelfT)\n                 }\n@@ -3072,6 +3391,18 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = unsafe {\n+                intrinsics::add_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT)\n+            };\n+            (a as Self, b)\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` + `rhs`\n \n@@ -3089,9 +3420,11 @@ Basic usage\n assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = unsafe {\n                     intrinsics::add_with_overflow(self as $ActualT,\n                                                   rhs as $ActualT)\n@@ -3100,6 +3433,18 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndF\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = unsafe {\n+                intrinsics::sub_with_overflow(self as $ActualT,\n+                                                rhs as $ActualT)\n+            };\n+            (a as Self, b)\n+        }\n+\n         doc_comment! {\n             concat!(\"Calculates `self` - `rhs`\n \n@@ -3118,9 +3463,11 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\n assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\",\n $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = unsafe {\n                     intrinsics::sub_with_overflow(self as $ActualT,\n                                                   rhs as $ActualT)\n@@ -3129,6 +3476,18 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+            let (a, b) = unsafe {\n+                intrinsics::mul_with_overflow(self as $ActualT,\n+                                              rhs as $ActualT)\n+            };\n+            (a as Self, b)\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean\n@@ -3146,9 +3505,11 @@ $EndFeature, \"\n         /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n         /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n         /// ```\n-        #[inline]\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-        pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n+        #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+        #[inline]\n+        #[cfg(not(stage0))]\n+        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n             let (a, b) = unsafe {\n                 intrinsics::mul_with_overflow(self as $ActualT,\n                                               rhs as $ActualT)\n@@ -3286,6 +3647,14 @@ assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!(\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts self left by `rhs` bits.\n \n@@ -3303,13 +3672,23 @@ Basic usage\n \", $Feature, \"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\n assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n             }\n         }\n \n+        /// no docs here\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n+        }\n+\n         doc_comment! {\n             concat!(\"Shifts self right by `rhs` bits.\n \n@@ -3327,9 +3706,11 @@ Basic usage\n \", $Feature, \"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\n assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n ```\"),\n-            #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n-            pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n+            #[rustc_const_unstable(feature = \"const_int_overflowing\")]\n+            #[inline]\n+            #[cfg(not(stage0))]\n+            pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n             }\n         }\n@@ -3571,6 +3952,14 @@ $EndFeature, \"\n             }\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_be().to_ne_bytes()\n+        }\n+\n         /// Return the memory representation of this integer as a byte array in\n         /// big-endian (network) byte order.\n         ///\n@@ -3583,11 +3972,21 @@ $EndFeature, \"\n         /// assert_eq!(bytes, [0x12, 0x34, 0x56, 0x78]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        #[cfg(not(stage0))]\n+        pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             self.to_be().to_ne_bytes()\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            self.to_le().to_ne_bytes()\n+        }\n+\n         /// Return the memory representation of this integer as a byte array in\n         /// little-endian byte order.\n         ///\n@@ -3600,11 +3999,21 @@ $EndFeature, \"\n         /// assert_eq!(bytes, [0x78, 0x56, 0x34, 0x12]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        #[cfg(not(stage0))]\n+        pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             self.to_le().to_ne_bytes()\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+            unsafe { mem::transmute(self) }\n+        }\n+\n         /// Return the memory representation of this integer as a byte array in\n         /// native byte order.\n         ///\n@@ -3624,11 +4033,21 @@ $EndFeature, \"\n         /// assert_eq!(bytes, [0x80, 0, 0, 0]);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n+        #[cfg(not(stage0))]\n+        pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n             unsafe { mem::transmute(self) }\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_be(Self::from_ne_bytes(bytes))\n+        }\n+\n         /// Create an integer value from its representation as a byte array in\n         /// big endian.\n         ///\n@@ -3641,11 +4060,21 @@ $EndFeature, \"\n         /// assert_eq!(int, 0x12_34_56_78);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             Self::from_be(Self::from_ne_bytes(bytes))\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            Self::from_le(Self::from_ne_bytes(bytes))\n+        }\n+\n         /// Create an integer value from its representation as a byte array in\n         /// little endian.\n         ///\n@@ -3658,11 +4087,21 @@ $EndFeature, \"\n         /// assert_eq!(int, 0x78_56_34_12);\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             Self::from_le(Self::from_ne_bytes(bytes))\n         }\n \n+        /// no docs here\n+        #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[inline]\n+        #[cfg(stage0)]\n+        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+            unsafe { mem::transmute(bytes) }\n+        }\n+\n         /// Create an integer value from its memory representation as a byte\n         /// array in native endianness.\n         ///\n@@ -3682,8 +4121,10 @@ $EndFeature, \"\n         /// assert_eq!(int, i32::min_value());\n         /// ```\n         #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+        #[rustc_const_unstable(feature = \"const_int_conversion\")]\n         #[inline]\n-        pub fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n+        #[cfg(not(stage0))]\n+        pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n             unsafe { mem::transmute(bytes) }\n         }\n     }"}, {"sha": "8cdb0e37f55075ba2e610cd93038050f52a75bad", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -15,6 +15,7 @@\n use syntax::symbol::Symbol;\n use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive};\n+use rustc::mir::BinOp;\n use rustc::mir::interpret::{\n     EvalResult, EvalErrorKind, Scalar,\n };\n@@ -39,6 +40,7 @@ fn numeric_intrinsic<'tcx>(\n         \"ctlz\" => bits.leading_zeros() as u128 - extra,\n         \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n         \"bswap\" => (bits << extra).swap_bytes(),\n+        \"bitreverse\" => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n     Ok(Scalar::from_uint(bits_out, size))\n@@ -76,7 +78,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let id_val = Scalar::from_uint(type_id, dest.layout.size);\n                 self.write_scalar(id_val, dest)?;\n             }\n-            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n+            | \"ctpop\"\n+            | \"cttz\"\n+            | \"cttz_nonzero\"\n+            | \"ctlz\"\n+            | \"ctlz_nonzero\"\n+            | \"bswap\"\n+            | \"bitreverse\" => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n                 let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n@@ -94,6 +102,33 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 self.write_scalar(out_val, dest)?;\n             }\n+            | \"overflowing_add\"\n+            | \"overflowing_sub\"\n+            | \"overflowing_mul\"\n+            | \"unchecked_shl\"\n+            | \"unchecked_shr\"\n+            | \"add_with_overflow\"\n+            | \"sub_with_overflow\"\n+            | \"mul_with_overflow\" => {\n+                let lhs = self.read_value(args[0])?;\n+                let rhs = self.read_value(args[1])?;\n+                let (bin_op, ignore_overflow) = match intrinsic_name {\n+                    \"overflowing_add\" => (BinOp::Add, true),\n+                    \"overflowing_sub\" => (BinOp::Sub, true),\n+                    \"overflowing_mul\" => (BinOp::Mul, true),\n+                    \"unchecked_shl\" => (BinOp::Shl, true),\n+                    \"unchecked_shr\" => (BinOp::Shr, true),\n+                    \"add_with_overflow\" => (BinOp::Add, false),\n+                    \"sub_with_overflow\" => (BinOp::Sub, false),\n+                    \"mul_with_overflow\" => (BinOp::Mul, false),\n+                    _ => bug!(\"Already checked for int ops\")\n+                };\n+                if ignore_overflow {\n+                    self.binop_ignore_overflow(bin_op, lhs, rhs, dest)?;\n+                } else {\n+                    self.binop_with_overflow(bin_op, lhs, rhs, dest)?;\n+                }\n+            }\n             \"transmute\" => {\n                 // Go through an allocation, to make sure the completely different layouts\n                 // do not pose a problem.  (When the user transmutes through a union,"}, {"sha": "be04f75c7260c3dfe8699c7592745961fe0b797a", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -37,6 +37,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(slice_concat_ext)]\n #![feature(if_while_or_patterns)]\n #![feature(try_from)]\n+#![feature(reverse_bits)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "050901b9b508a7ab7f3cca1c8e8b7eed7dfd3b17", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -826,11 +826,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             | \"min_align_of\"\n                             | \"type_id\"\n                             | \"bswap\"\n+                            | \"bitreverse\"\n                             | \"ctpop\"\n                             | \"cttz\"\n                             | \"cttz_nonzero\"\n                             | \"ctlz\"\n-                            | \"ctlz_nonzero\" => is_const_fn = Some(def_id),\n+                            | \"ctlz_nonzero\"\n+                            | \"overflowing_add\"\n+                            | \"overflowing_sub\"\n+                            | \"overflowing_mul\"\n+                            | \"unchecked_shl\"\n+                            | \"unchecked_shr\"\n+                            | \"add_with_overflow\"\n+                            | \"sub_with_overflow\"\n+                            | \"mul_with_overflow\" => is_const_fn = Some(def_id),\n                             \"transmute\" => {\n                                 if self.mode != Mode::Fn {\n                                     is_const_fn = Some(def_id);"}, {"sha": "790c62288d38b68e3df77f0076a01623ba0fdc54", "filename": "src/test/run-pass/const-int-conversion.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-conversion.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_conversion, const_int_ops, reverse_bits, int_to_from_bytes)]\n+\n+const REVERSE: u32 = 0x12345678_u32.reverse_bits();\n+const FROM_BE_BYTES: i32 = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);\n+const FROM_LE_BYTES: i32 = i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]);\n+const FROM_NE_BYTES: i32 = i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0]));\n+const TO_BE_BYTES: [u8; 4] = 0x12_34_56_78_i32.to_be_bytes();\n+const TO_LE_BYTES: [u8; 4] = 0x12_34_56_78_i32.to_le_bytes();\n+const TO_NE_BYTES: [u8; 4] = i32::min_value().to_be().to_ne_bytes();\n+\n+fn ident<T>(ident: T) -> T {\n+    ident\n+}\n+\n+fn main() {\n+    assert_eq!(REVERSE, ident(0x1e6a2c48));\n+    assert_eq!(FROM_BE_BYTES, ident(0x12_34_56_78));\n+    assert_eq!(FROM_LE_BYTES, ident(0x78_56_34_12));\n+    assert_eq!(FROM_NE_BYTES, ident(i32::min_value()));\n+    assert_eq!(TO_BE_BYTES, ident([0x12, 0x34, 0x56, 0x78]));\n+    assert_eq!(TO_LE_BYTES, ident([0x78, 0x56, 0x34, 0x12]));\n+    assert_eq!(TO_NE_BYTES, ident([0x80, 0, 0, 0]));\n+}\n+"}, {"sha": "0f8f230f456bd32c824d7a3ed310616447f8a795", "filename": "src/test/run-pass/const-int-overflowing.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-overflowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-overflowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-overflowing.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_overflowing)]\n+\n+const ADD_A: (u32, bool) = 5u32.overflowing_add(2);\n+const ADD_B: (u32, bool) = u32::max_value().overflowing_add(1);\n+\n+const SUB_A: (u32, bool) = 5u32.overflowing_sub(2);\n+const SUB_B: (u32, bool) = 0u32.overflowing_sub(1);\n+\n+const MUL_A: (u32, bool) = 5u32.overflowing_mul(2);\n+const MUL_B: (u32, bool) = 1_000_000_000u32.overflowing_mul(10);\n+\n+const SHL_A: (u32, bool) = 0x1u32.overflowing_shl(4);\n+const SHL_B: (u32, bool) = 0x1u32.overflowing_shl(132);\n+\n+const SHR_A: (u32, bool) = 0x10u32.overflowing_shr(4);\n+const SHR_B: (u32, bool) = 0x10u32.overflowing_shr(132);\n+\n+fn ident<T>(ident: T) -> T {\n+    ident\n+}\n+\n+fn main() {\n+    assert_eq!(ADD_A, ident((7, false)));\n+    assert_eq!(ADD_B, ident((0, true)));\n+\n+    assert_eq!(SUB_A, ident((3, false)));\n+    assert_eq!(SUB_B, ident((u32::max_value(), true)));\n+\n+    assert_eq!(MUL_A, ident((10, false)));\n+    assert_eq!(MUL_B, ident((1410065408, true)));\n+\n+    assert_eq!(SHL_A, ident((0x10, false)));\n+    assert_eq!(SHL_B, ident((0x10, true)));\n+\n+    assert_eq!(SHR_A, ident((0x1, false)));\n+    assert_eq!(SHR_B, ident((0x1, true)));\n+}"}, {"sha": "ee8e0b0b9dd7f905ab976eacb1f83f094f4d8faf", "filename": "src/test/run-pass/const-int-rotate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-rotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-rotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-rotate.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_rotate)]\n+\n+const LEFT: u32 = 0x10000b3u32.rotate_left(8);\n+const RIGHT: u32 = 0xb301u32.rotate_right(8);\n+\n+fn ident<T>(ident: T) -> T {\n+    ident\n+}\n+\n+fn main() {\n+    assert_eq!(LEFT, ident(0xb301));\n+    assert_eq!(RIGHT, ident(0x10000b3));\n+}"}, {"sha": "e095cfb000c5fa6c6574cc374fabf9124ea22d0e", "filename": "src/test/run-pass/const-int-sign.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-sign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-sign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-sign.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_sign)]\n+\n+const NEGATIVE_A: bool = (-10i32).is_negative();\n+const NEGATIVE_B: bool = 10i32.is_negative();\n+const POSITIVE_A: bool= (-10i32).is_positive();\n+const POSITIVE_B: bool= 10i32.is_positive();\n+\n+fn main() {\n+    assert!(NEGATIVE_A);\n+    assert!(!NEGATIVE_B);\n+    assert!(!POSITIVE_A);\n+    assert!(POSITIVE_B);\n+}"}, {"sha": "ab7c98f9824ec45f779508b72e97f005692c4a13", "filename": "src/test/run-pass/const-int-wrapping.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Frun-pass%2Fconst-int-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-wrapping.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_int_wrapping)]\n+\n+const ADD_A: u32 = 200u32.wrapping_add(55);\n+const ADD_B: u32 = 200u32.wrapping_add(u32::max_value());\n+\n+const SUB_A: u32 = 100u32.wrapping_sub(100);\n+const SUB_B: u32 = 100u32.wrapping_sub(u32::max_value());\n+\n+const MUL_A: u8 = 10u8.wrapping_mul(12);\n+const MUL_B: u8 = 25u8.wrapping_mul(12);\n+\n+const SHL_A: u32 = 1u32.wrapping_shl(7);\n+const SHL_B: u32 = 1u32.wrapping_shl(128);\n+\n+const SHR_A: u32 = 128u32.wrapping_shr(7);\n+const SHR_B: u32 = 128u32.wrapping_shr(128);\n+\n+fn ident<T>(ident: T) -> T {\n+    ident\n+}\n+\n+fn main() {\n+    assert_eq!(ADD_A, ident(255));\n+    assert_eq!(ADD_B, ident(199));\n+\n+    assert_eq!(SUB_A, ident(0));\n+    assert_eq!(SUB_B, ident(101));\n+\n+    assert_eq!(MUL_A, ident(120));\n+    assert_eq!(MUL_B, ident(44));\n+\n+    assert_eq!(SHL_A, ident(128));\n+    assert_eq!(SHL_B, ident(1));\n+\n+    assert_eq!(SHR_A, ident(1));\n+    assert_eq!(SHR_B, ident(128));\n+}"}, {"sha": "0abe6b4a1e49fea969c68fd5f4262a733846b28d", "filename": "src/test/ui/consts/const-int-conversion.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(reverse_bits, int_to_from_bytes)]\n+\n+fn main() {\n+    let x: &'static i32 = &(5_i32.reverse_bits());\n+        //~^ ERROR does not live long enough\n+    let y: &'static i32 = &(i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]));\n+        //~^ ERROR does not live long enough\n+    let z: &'static i32 = &(i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]));\n+        //~^ ERROR does not live long enough\n+    let a: &'static i32 = &(i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0])));\n+        //~^ ERROR does not live long enough\n+    let b: &'static [u8] = &(0x12_34_56_78_i32.to_be_bytes());\n+        //~^ ERROR does not live long enough\n+    let c: &'static [u8] = &(0x12_34_56_78_i32.to_le_bytes());\n+        //~^ ERROR does not live long enough\n+    let d: &'static [u8] = &(i32::min_value().to_be().to_ne_bytes());\n+        //~^ ERROR does not live long enough\n+}"}, {"sha": "fc2472a7b5879765ef720138e889ac19dd0763cb", "filename": "src/test/ui/consts/const-int-conversion.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.stderr?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,80 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:14:28\n+   |\n+LL |     let x: &'static i32 = &(5_i32.reverse_bits());\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:16:28\n+   |\n+LL |     let y: &'static i32 = &(i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]));\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:18:28\n+   |\n+LL |     let z: &'static i32 = &(i32::from_le_bytes([0x12, 0x34, 0x56, 0x78]));\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:20:28\n+   |\n+LL |     let a: &'static i32 = &(i32::from_be(i32::from_ne_bytes([0x80, 0, 0, 0])));\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:22:29\n+   |\n+LL |     let b: &'static [u8] = &(0x12_34_56_78_i32.to_be_bytes());\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:24:29\n+   |\n+LL |     let c: &'static [u8] = &(0x12_34_56_78_i32.to_le_bytes());\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-conversion.rs:26:29\n+   |\n+LL |     let d: &'static [u8] = &(i32::min_value().to_be().to_ne_bytes());\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |         //~^ ERROR does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "7bff6b9adb0c782f580a1599928c1b1ab8ca8d45", "filename": "src/test/ui/consts/const-int-overflowing.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: &'static (i32, bool) = &(5_i32.overflowing_add(3)); //~ ERROR does not live long enough\n+    let y: &'static (i32, bool) = &(5_i32.overflowing_sub(3)); //~ ERROR does not live long enough\n+    let z: &'static (i32, bool) = &(5_i32.overflowing_mul(3)); //~ ERROR does not live long enough\n+}"}, {"sha": "e06fb6af1a643fc55ab0bb72f9c4815cf55e28e2", "filename": "src/test/ui/consts/const-int-overflowing.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-overflowing.stderr?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,35 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-overflowing.rs:12:36\n+   |\n+LL |     let x: &'static (i32, bool) = &(5_i32.overflowing_add(3)); //~ ERROR does not live long enough\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-overflowing.rs:13:36\n+   |\n+LL |     let y: &'static (i32, bool) = &(5_i32.overflowing_sub(3)); //~ ERROR does not live long enough\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |     let z: &'static (i32, bool) = &(5_i32.overflowing_mul(3)); //~ ERROR does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-overflowing.rs:14:36\n+   |\n+LL |     let z: &'static (i32, bool) = &(5_i32.overflowing_mul(3)); //~ ERROR does not live long enough\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "e6f05338c849e64b65a19dd0baaa013dc4c4affd", "filename": "src/test/ui/consts/const-int-rotate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-rotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-rotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-rotate.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: &'static i32 = &(5_i32.rotate_left(3)); //~ ERROR does not live long enough\n+    let y: &'static i32 = &(5_i32.rotate_right(3)); //~ ERROR does not live long enough\n+}"}, {"sha": "fa2f6255e01f2fa34c9664731e6e624432bf6d76", "filename": "src/test/ui/consts/const-int-rotate.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-rotate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-rotate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-rotate.stderr?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,24 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-rotate.rs:12:28\n+   |\n+LL |     let x: &'static i32 = &(5_i32.rotate_left(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |     let y: &'static i32 = &(5_i32.rotate_right(3)); //~ ERROR does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-rotate.rs:13:28\n+   |\n+LL |     let y: &'static i32 = &(5_i32.rotate_right(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "1082c385cd402394be4a9dda175e0e7f27338bbb", "filename": "src/test/ui/consts/const-int-sign.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-sign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-sign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-sign.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: &'static bool = &(5_i32.is_negative()); //~ ERROR does not live long enough\n+    let y: &'static bool = &(5_i32.is_positive()); //~ ERROR does not live long enough\n+}"}, {"sha": "1d456287bd88379662cfd4441bc364c779d19139", "filename": "src/test/ui/consts/const-int-sign.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-sign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-sign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-sign.stderr?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,24 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-sign.rs:12:29\n+   |\n+LL |     let x: &'static bool = &(5_i32.is_negative()); //~ ERROR does not live long enough\n+   |                             ^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |     let y: &'static bool = &(5_i32.is_positive()); //~ ERROR does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-sign.rs:13:29\n+   |\n+LL |     let y: &'static bool = &(5_i32.is_positive()); //~ ERROR does not live long enough\n+   |                             ^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "bd11d5df232bd30ad87042d97d8ebffaef5fb497", "filename": "src/test/ui/consts/const-int-wrapping.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping.rs?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x: &'static i32 = &(5_i32.wrapping_add(3)); //~ ERROR does not live long enough\n+    let y: &'static i32 = &(5_i32.wrapping_sub(3)); //~ ERROR does not live long enough\n+    let z: &'static i32 = &(5_i32.wrapping_mul(3)); //~ ERROR does not live long enough\n+    let a: &'static i32 = &(5_i32.wrapping_shl(3)); //~ ERROR does not live long enough\n+    let b: &'static i32 = &(5_i32.wrapping_shr(3)); //~ ERROR does not live long enough\n+}"}, {"sha": "94974e09939bba94aaa2a657515cadbf5e2642df", "filename": "src/test/ui/consts/const-int-wrapping.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-wrapping.stderr?ref=cd5c26f0eb48c8f32ea86e9f2434d905ff2cfc74", "patch": "@@ -0,0 +1,57 @@\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-wrapping.rs:12:28\n+   |\n+LL |     let x: &'static i32 = &(5_i32.wrapping_add(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-wrapping.rs:13:28\n+   |\n+LL |     let y: &'static i32 = &(5_i32.wrapping_sub(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-wrapping.rs:14:28\n+   |\n+LL |     let z: &'static i32 = &(5_i32.wrapping_mul(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+...\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-wrapping.rs:15:28\n+   |\n+LL |     let a: &'static i32 = &(5_i32.wrapping_shl(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL |     let b: &'static i32 = &(5_i32.wrapping_shr(3)); //~ ERROR does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/const-int-wrapping.rs:16:28\n+   |\n+LL |     let b: &'static i32 = &(5_i32.wrapping_shr(3)); //~ ERROR does not live long enough\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n+LL | }\n+   | - temporary value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}]}