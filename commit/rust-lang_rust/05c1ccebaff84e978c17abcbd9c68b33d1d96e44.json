{"sha": "05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YzFjY2ViYWZmODRlOTc4YzE3YWJjYmQ5YzY4YjMzZDFkOTZlNDQ=", "commit": {"author": {"name": "Donald Robertson", "email": "donaldarobertson89@gmail.com", "date": "2018-05-28T19:00:45Z"}, "committer": {"name": "Donald Robertson", "email": "donaldarobertson89@gmail.com", "date": "2018-06-04T18:43:03Z"}, "message": "Warn if non-trivial work is done inside .expect\n- added tests for common usages of format and as_str arguments to expect\n- added tests for usages of Option and Result types\n- given performance impact of passing non literal expressions to expect, added to perf group", "tree": {"sha": "b3642e2d4c88570b18f60398c6e92bd7e3e90289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3642e2d4c88570b18f60398c6e92bd7e3e90289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "html_url": "https://github.com/rust-lang/rust/commit/05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/comments", "author": null, "committer": null, "parents": [{"sha": "3d7cdd4ac5311b7166d14de9ce8e6c1768674f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d7cdd4ac5311b7166d14de9ce8e6c1768674f44", "html_url": "https://github.com/rust-lang/rust/commit/3d7cdd4ac5311b7166d14de9ce8e6c1768674f44"}], "stats": {"total": 177, "additions": 152, "deletions": 25}, "files": [{"sha": "70adaa273ebe31aa28b3b3f93a2e8055a2246302", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "patch": "@@ -590,6 +590,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_OR_NONE,\n         methods::OR_FUN_CALL,\n+        methods::EXPECT_FUN_CALL,\n         methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::SINGLE_CHAR_PATTERN,\n@@ -899,6 +900,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         loops::UNUSED_COLLECT,\n         methods::ITER_NTH,\n         methods::OR_FUN_CALL,\n+        methods::EXPECT_FUN_CALL,\n         methods::SINGLE_CHAR_PATTERN,\n         misc::CMP_OWNED,\n         mutex_atomic::MUTEX_ATOMIC,"}, {"sha": "553198ae446ba3f6ee7a73370e95e0715b3a6b66", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "patch": "@@ -329,6 +329,32 @@ declare_clippy_lint! {\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n+/// **What it does:** Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n+/// etc., and suggests to use `unwrap_or_else` instead\n+///\n+/// **Why is this bad?** The function will always be called.\n+///\n+/// **Known problems:** If the function has side-effects, not calling it will\n+/// change the semantic of the program, but you shouldn't rely on that anyway.\n+/// \n+/// **Example:**\n+/// ```rust\n+/// foo.expect(&format(\"Err {}: {}\", err_code, err_msg))\n+/// ```\n+/// or\n+/// ```rust\n+/// foo.expect(format(\"Err {}: {}\", err_code, err_msg).as_str())\n+/// ```\n+/// this can instead be written:\n+/// ```rust\n+/// foo.unwrap_or_else(|_| panic!(&format(\"Err {}: {}\", err_code, err_msg)))\n+/// ```\n+declare_clippy_lint! {\n+    pub EXPECT_FUN_CALL,\n+    perf,\n+    \"using any `expect` method with a function call\"\n+}\n+\n /// **What it does:** Checks for usage of `.clone()` on a `Copy` type.\n ///\n /// **Why is this bad?** The only reason `Copy` types implement `Clone` is for\n@@ -657,6 +683,7 @@ impl LintPass for Pass {\n             RESULT_MAP_UNWRAP_OR_ELSE,\n             OPTION_MAP_OR_NONE,\n             OR_FUN_CALL,\n+            EXPECT_FUN_CALL,\n             CHARS_NEXT_CMP,\n             CHARS_LAST_CMP,\n             CLONE_ON_COPY,\n@@ -741,6 +768,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n \n                 lint_or_fun_call(cx, expr, *method_span, &method_call.name.as_str(), args);\n+                lint_expect_fun_call(cx, expr, *method_span, &method_call.name.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.name == \"clone\" {\n@@ -964,6 +992,48 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n     }\n }\n \n+/// Checks for the `EXPECT_FUN_CALL` lint.\n+fn lint_expect_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+    #[allow(too_many_arguments)]\n+    fn check_general_case(\n+        cx: &LateContext,\n+        name: &str,\n+        method_span: Span,\n+        arg: &hir::Expr,\n+        span: Span,\n+    ) {\n+        if name != \"expect\" {\n+            return;\n+        }\n+\n+        // don't lint for constant values\n+        let owner_def = cx.tcx.hir.get_parent_did(arg.id);\n+        let promotable = cx.tcx.rvalue_promotable_map(owner_def).contains(&arg.hir_id.local_id);\n+        if promotable {\n+            return;\n+        }\n+\n+        let sugg: Cow<_> = snippet(cx, arg.span, \"..\");\n+        let span_replace_word = method_span.with_hi(span.hi());\n+        \n+        span_lint_and_sugg(\n+            cx,\n+            EXPECT_FUN_CALL,\n+            span_replace_word,\n+            &format!(\"use of `{}` followed by a function call\", name),\n+            \"try this\",\n+            format!(\"unwrap_or_else(|_| panic!({}))\", sugg),\n+        );\n+    }\n+\n+    if args.len() == 2 {\n+        match args[1].node {\n+            hir::ExprLit(_) => {},\n+            _ => check_general_case(cx, name, method_span, &args[1], expr.span),\n+        }\n+    }\n+}\n+\n /// Checks for the `CLONE_ON_COPY` lint.\n fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n     let ty = cx.tables.expr_ty(expr);"}, {"sha": "04e3ec13b8664ef2e23c012cf13bb5d435ea8afe", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "patch": "@@ -342,6 +342,35 @@ fn or_fun_call() {\n     let _ = stringy.unwrap_or(\"\".to_owned());\n }\n \n+/// Checks implementation of the `EXPECT_FUN_CALL` lint\n+fn expect_fun_call() {\n+    let with_some = Some(\"value\");\n+    with_some.expect(\"error\");\n+\n+    let with_none: Option<i32> = None;\n+    with_none.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_none_and_format: Option<i32> = None;\n+    with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_none_and_as_str: Option<i32> = None;\n+    with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+\n+    let with_ok: Result<(), ()> = Ok(());\n+    with_ok.expect(\"error\");\n+\n+    let with_err: Result<(), ()> = Err(());\n+    with_err.expect(\"error\");\n+\n+    let error_code = 123_i32;\n+    let with_err_and_format: Result<(), ()> = Err(());\n+    with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+\n+    let with_err_and_as_str: Result<(), ()> = Err(());\n+    with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+}\n+\n /// Checks implementation of `ITER_NTH` lint\n fn iter_nth() {\n     let mut some_vec = vec![0, 1, 2, 3];"}, {"sha": "2fe374f35412b0ba6ceb1154e9bf82548b4c8e59", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05c1ccebaff84e978c17abcbd9c68b33d1d96e44/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=05c1ccebaff84e978c17abcbd9c68b33d1d96e44", "patch": "@@ -423,83 +423,109 @@ error: use of `unwrap_or` followed by a function call\n 342 |     let _ = stringy.unwrap_or(\"\".to_owned());\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| \"\".to_owned())`\n \n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:355:26\n+    |\n+355 |     with_none_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(&format!(\"Error {}: fake error\", error_code)))`\n+    |\n+    = note: `-D expect-fun-call` implied by `-D warnings`\n+\n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:358:26\n+    |\n+358 |     with_none_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(format!(\"Error {}: fake error\", error_code).as_str()))`\n+\n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:368:25\n+    |\n+368 |     with_err_and_format.expect(&format!(\"Error {}: fake error\", error_code));\n+    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(&format!(\"Error {}: fake error\", error_code)))`\n+\n+error: use of `expect` followed by a function call\n+   --> $DIR/methods.rs:371:25\n+    |\n+371 |     with_err_and_as_str.expect(format!(\"Error {}: fake error\", error_code).as_str());\n+    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|_| panic!(format!(\"Error {}: fake error\", error_code).as_str()))`\n+\n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:353:23\n+   --> $DIR/methods.rs:382:23\n     |\n-353 |         let bad_vec = some_vec.iter().nth(3);\n+382 |         let bad_vec = some_vec.iter().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:354:26\n+   --> $DIR/methods.rs:383:26\n     |\n-354 |         let bad_slice = &some_vec[..].iter().nth(3);\n+383 |         let bad_slice = &some_vec[..].iter().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:355:31\n+   --> $DIR/methods.rs:384:31\n     |\n-355 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n+384 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n     |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:356:29\n+   --> $DIR/methods.rs:385:29\n     |\n-356 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n+385 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:361:23\n+   --> $DIR/methods.rs:390:23\n     |\n-361 |         let bad_vec = some_vec.iter_mut().nth(3);\n+390 |         let bad_vec = some_vec.iter_mut().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:364:26\n+   --> $DIR/methods.rs:393:26\n     |\n-364 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n+393 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:367:29\n+   --> $DIR/methods.rs:396:29\n     |\n-367 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n+396 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:379:13\n+   --> $DIR/methods.rs:408:13\n     |\n-379 |     let _ = some_vec.iter().skip(42).next();\n+408 |     let _ = some_vec.iter().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-skip-next` implied by `-D warnings`\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:380:13\n+   --> $DIR/methods.rs:409:13\n     |\n-380 |     let _ = some_vec.iter().cycle().skip(42).next();\n+409 |     let _ = some_vec.iter().cycle().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:381:13\n+   --> $DIR/methods.rs:410:13\n     |\n-381 |     let _ = (1..10).skip(10).next();\n+410 |     let _ = (1..10).skip(10).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:382:14\n+   --> $DIR/methods.rs:411:14\n     |\n-382 |     let _ = &some_vec[..].iter().skip(3).next();\n+411 |     let _ = &some_vec[..].iter().skip(3).next();\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:391:13\n+   --> $DIR/methods.rs:420:13\n     |\n-391 |     let _ = opt.unwrap();\n+420 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 66 previous errors\n+error: aborting due to 70 previous errors\n "}]}