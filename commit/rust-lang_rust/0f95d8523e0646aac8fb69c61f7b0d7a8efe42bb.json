{"sha": "0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOTVkODUyM2UwNjQ2YWFjOGZiNjljNjFmN2IwZDdhOGVmZTQyYmI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-30T15:07:27Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-30T15:07:27Z"}, "message": "Merge #365\n\n365: implement struct shorthand initialization diagnostic r=matklad a=gfreezy\n\n\n\nCo-authored-by: gfreezy <gfreezy@gmail.com>", "tree": {"sha": "cdbd8fd24c5d9b187da0f8da069f5e270205d6a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdbd8fd24c5d9b187da0f8da069f5e270205d6a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb", "html_url": "https://github.com/rust-lang/rust/commit/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "55b57227e469c84f7888c538e9644d230cd449ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/55b57227e469c84f7888c538e9644d230cd449ca", "html_url": "https://github.com/rust-lang/rust/commit/55b57227e469c84f7888c538e9644d230cd449ca"}, {"sha": "e1ef205a1915442229638dbb296de4466ee3d3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1ef205a1915442229638dbb296de4466ee3d3da", "html_url": "https://github.com/rust-lang/rust/commit/e1ef205a1915442229638dbb296de4466ee3d3da"}], "stats": {"total": 390, "additions": 278, "deletions": 112}, "files": [{"sha": "1b336cfe2e85e39d07c4d1ef313ce78b619e4f4d", "filename": "crates/ra_editor/src/diagnostics.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fdiagnostics.rs?ref=0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb", "patch": "@@ -0,0 +1,276 @@\n+use itertools::Itertools;\n+\n+use ra_syntax::{\n+    ast::{self, AstNode},\n+    Location,\n+    SourceFileNode,\n+    SyntaxKind,\n+    TextRange,\n+};\n+use ra_syntax::SyntaxNodeRef;\n+use ra_text_edit::{\n+    TextEdit,\n+    TextEditBuilder,\n+};\n+\n+use crate::{\n+    Diagnostic,\n+    LocalEdit,\n+    Severity,\n+};\n+\n+pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n+    fn location_to_range(location: Location) -> TextRange {\n+        match location {\n+            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n+            Location::Range(range) => range,\n+        }\n+    }\n+\n+    let mut errors: Vec<Diagnostic> = file\n+        .errors()\n+        .into_iter()\n+        .map(|err| Diagnostic {\n+            range: location_to_range(err.location()),\n+            msg: format!(\"Syntax Error: {}\", err),\n+            severity: Severity::Error,\n+            fix: None,\n+        })\n+        .collect();\n+\n+    for node in file.syntax().descendants() {\n+        check_unnecessary_braces_in_use_statement(&mut errors, node);\n+        check_struct_shorthand_initialization(&mut errors, node);\n+    }\n+\n+    errors\n+}\n+\n+fn check_unnecessary_braces_in_use_statement(\n+    acc: &mut Vec<Diagnostic>,\n+    node: SyntaxNodeRef,\n+) -> Option<()> {\n+    let use_tree_list = ast::UseTreeList::cast(node)?;\n+    if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n+        let range = use_tree_list.syntax().range();\n+        let edit =\n+            text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(single_use_tree)\n+                .unwrap_or_else(|| {\n+                    let to_replace = single_use_tree.syntax().text().to_string();\n+                    let mut edit_builder = TextEditBuilder::new();\n+                    edit_builder.delete(range);\n+                    edit_builder.insert(range.start(), to_replace);\n+                    edit_builder.finish()\n+                });\n+\n+        acc.push(Diagnostic {\n+            range,\n+            msg: format!(\"Unnecessary braces in use statement\"),\n+            severity: Severity::WeakWarning,\n+            fix: Some(LocalEdit {\n+                label: \"Remove unnecessary braces\".to_string(),\n+                edit,\n+                cursor_position: None,\n+            }),\n+        });\n+    }\n+\n+    Some(())\n+}\n+\n+fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n+    single_use_tree: ast::UseTree,\n+) -> Option<TextEdit> {\n+    let use_tree_list_node = single_use_tree.syntax().parent()?;\n+    if single_use_tree\n+        .path()?\n+        .segment()?\n+        .syntax()\n+        .first_child()?\n+        .kind()\n+        == SyntaxKind::SELF_KW\n+    {\n+        let start = use_tree_list_node.prev_sibling()?.range().start();\n+        let end = use_tree_list_node.range().end();\n+        let range = TextRange::from_to(start, end);\n+        let mut edit_builder = TextEditBuilder::new();\n+        edit_builder.delete(range);\n+        return Some(edit_builder.finish());\n+    }\n+    None\n+}\n+\n+fn check_struct_shorthand_initialization(\n+    acc: &mut Vec<Diagnostic>,\n+    node: SyntaxNodeRef,\n+) -> Option<()> {\n+    let struct_lit = ast::StructLit::cast(node)?;\n+    let named_field_list = struct_lit.named_field_list()?;\n+    for named_field in named_field_list.fields() {\n+        if let (Some(name_ref), Some(expr)) = (named_field.name_ref(), named_field.expr()) {\n+            let field_name = name_ref.syntax().text().to_string();\n+            let field_expr = expr.syntax().text().to_string();\n+            if field_name == field_expr {\n+                let mut edit_builder = TextEditBuilder::new();\n+                edit_builder.delete(named_field.syntax().range());\n+                edit_builder.insert(named_field.syntax().range().start(), field_name);\n+                let edit = edit_builder.finish();\n+\n+                acc.push(Diagnostic {\n+                    range: named_field.syntax().range(),\n+                    msg: format!(\"Shorthand struct initialization\"),\n+                    severity: Severity::WeakWarning,\n+                    fix: Some(LocalEdit {\n+                        label: \"use struct shorthand initialization\".to_string(),\n+                        edit,\n+                        cursor_position: None,\n+                    }),\n+                });\n+            }\n+        }\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::test_utils::assert_eq_text;\n+\n+    use super::*;\n+\n+    type DiagnosticChecker = fn(&mut Vec<Diagnostic>, SyntaxNodeRef) -> Option<()>;\n+\n+    fn check_not_applicable(code: &str, func: DiagnosticChecker) {\n+        let file = SourceFileNode::parse(code);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(&mut diagnostics, node);\n+        }\n+        assert!(diagnostics.is_empty());\n+    }\n+\n+    fn check_apply(before: &str, after: &str, func: DiagnosticChecker) {\n+        let file = SourceFileNode::parse(before);\n+        let mut diagnostics = Vec::new();\n+        for node in file.syntax().descendants() {\n+            func(&mut diagnostics, node);\n+        }\n+        let diagnostic = diagnostics\n+            .pop()\n+            .unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n+        let fix = diagnostic.fix.unwrap();\n+        let actual = fix.edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    #[test]\n+    fn test_check_unnecessary_braces_in_use_statement() {\n+        check_not_applicable(\n+            \"\n+            use a;\n+            use a::{c, d::e};\n+        \",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use {b};\",\n+            \"use b;\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use a::{c};\",\n+            \"use a::c;\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use a::{self};\",\n+            \"use a;\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+        check_apply(\n+            \"use a::{c, d::{e}};\",\n+            \"use a::{c, d::e};\",\n+            check_unnecessary_braces_in_use_statement,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_check_struct_shorthand_initialization() {\n+        check_not_applicable(\n+            r#\"\n+            struct A {\n+                a: &'static str\n+            }\n+\n+            fn main() {\n+                A {\n+                    a: \"hello\"\n+                }\n+            }\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a: a\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    A {\n+        a\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+\n+        check_apply(\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a: a,\n+        b\n+    }\n+}\n+        \"#,\n+            r#\"\n+struct A {\n+    a: &'static str,\n+    b: &'static str\n+}\n+\n+fn main() {\n+    let a = \"haha\";\n+    let b = \"bb\";\n+    A {\n+        a,\n+        b\n+    }\n+}\n+        \"#,\n+            check_struct_shorthand_initialization,\n+        );\n+    }\n+}"}, {"sha": "a65637d52e8b165640000bbee38abbd7c5dacc0c", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 112, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=0f95d8523e0646aac8fb69c61f7b0d7a8efe42bb", "patch": "@@ -7,6 +7,7 @@ mod symbols;\n #[cfg(test)]\n mod test_utils;\n mod typing;\n+mod diagnostics;\n \n pub use self::{\n     code_actions::{add_derive, add_impl, flip_comma, introduce_variable, make_pub_crate, LocalEdit},\n@@ -16,17 +17,16 @@ pub use self::{\n     line_index_utils::translate_offset_with_edit,\n     symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n     typing::{join_lines, on_enter, on_eq_typed},\n+    diagnostics::diagnostics\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_syntax::{\n     algo::find_leaf_at_offset,\n     ast::{self, AstNode, NameOwner},\n     SourceFileNode,\n-    Location,\n     SyntaxKind::{self, *},\n     SyntaxNodeRef, TextRange, TextUnit, Direction,\n };\n-use itertools::Itertools;\n use rustc_hash::FxHashSet;\n \n #[derive(Debug)]\n@@ -129,87 +129,6 @@ pub fn highlight(file: &SourceFileNode) -> Vec<HighlightedRange> {\n     res\n }\n \n-pub fn diagnostics(file: &SourceFileNode) -> Vec<Diagnostic> {\n-    fn location_to_range(location: Location) -> TextRange {\n-        match location {\n-            Location::Offset(offset) => TextRange::offset_len(offset, 1.into()),\n-            Location::Range(range) => range,\n-        }\n-    }\n-\n-    let mut errors: Vec<Diagnostic> = file\n-        .errors()\n-        .into_iter()\n-        .map(|err| Diagnostic {\n-            range: location_to_range(err.location()),\n-            msg: format!(\"Syntax Error: {}\", err),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n-        .collect();\n-\n-    let warnings = check_unnecessary_braces_in_use_statement(file);\n-\n-    errors.extend(warnings);\n-    errors\n-}\n-\n-fn check_unnecessary_braces_in_use_statement(file: &SourceFileNode) -> Vec<Diagnostic> {\n-    let mut diagnostics = Vec::new();\n-    for node in file.syntax().descendants() {\n-        if let Some(use_tree_list) = ast::UseTreeList::cast(node) {\n-            if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-                let range = use_tree_list.syntax().range();\n-                let edit = text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-                    single_use_tree,\n-                )\n-                .unwrap_or_else(|| {\n-                    let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEditBuilder::new();\n-                    edit_builder.delete(range);\n-                    edit_builder.insert(range.start(), to_replace);\n-                    edit_builder.finish()\n-                });\n-\n-                diagnostics.push(Diagnostic {\n-                    range: range,\n-                    msg: format!(\"Unnecessary braces in use statement\"),\n-                    severity: Severity::WeakWarning,\n-                    fix: Some(LocalEdit {\n-                        label: \"Remove unnecessary braces\".to_string(),\n-                        edit: edit,\n-                        cursor_position: None,\n-                    }),\n-                })\n-            }\n-        }\n-    }\n-\n-    diagnostics\n-}\n-\n-fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n-    single_use_tree: ast::UseTree,\n-) -> Option<TextEdit> {\n-    let use_tree_list_node = single_use_tree.syntax().parent()?;\n-    if single_use_tree\n-        .path()?\n-        .segment()?\n-        .syntax()\n-        .first_child()?\n-        .kind()\n-        == SyntaxKind::SELF_KW\n-    {\n-        let start = use_tree_list_node.prev_sibling()?.range().start();\n-        let end = use_tree_list_node.range().end();\n-        let range = TextRange::from_to(start, end);\n-        let mut edit_builder = TextEditBuilder::new();\n-        edit_builder.delete(range);\n-        return Some(edit_builder.finish());\n-    }\n-    None\n-}\n-\n pub fn syntax_tree(file: &SourceFileNode) -> String {\n     ::ra_syntax::utils::dump_tree(file.syntax())\n }\n@@ -310,33 +229,4 @@ fn test_foo() {}\n         do_check(\"struct Foo { a: i32, }<|>\", \"struct Foo <|>{ a: i32, }\");\n     }\n \n-    #[test]\n-    fn test_check_unnecessary_braces_in_use_statement() {\n-        fn check_not_applicable(code: &str) {\n-            let file = SourceFileNode::parse(code);\n-            let diagnostics = check_unnecessary_braces_in_use_statement(&file);\n-            assert!(diagnostics.is_empty());\n-        }\n-\n-        fn check_apply(before: &str, after: &str) {\n-            let file = SourceFileNode::parse(before);\n-            let diagnostic = check_unnecessary_braces_in_use_statement(&file)\n-                .pop()\n-                .unwrap_or_else(|| panic!(\"no diagnostics for:\\n{}\\n\", before));\n-            let fix = diagnostic.fix.unwrap();\n-            let actual = fix.edit.apply(&before);\n-            assert_eq_text!(after, &actual);\n-        }\n-\n-        check_not_applicable(\n-            \"\n-            use a;\n-            use a::{c, d::e};\n-        \",\n-        );\n-        check_apply(\"use {b};\", \"use b;\");\n-        check_apply(\"use a::{c};\", \"use a::c;\");\n-        check_apply(\"use a::{self};\", \"use a;\");\n-        check_apply(\"use a::{c, d::{e}};\", \"use a::{c, d::e};\");\n-    }\n }"}]}