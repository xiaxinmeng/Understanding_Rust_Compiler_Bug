{"sha": "6dc452335a410e139220c4ecadbbda9dd15fe8e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYzQ1MjMzNWE0MTBlMTM5MjIwYzRlY2FkYmJkYTlkZDE1ZmU4ZTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T20:02:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T20:02:44Z"}, "message": "rustc: Get tag variants from the crate metadata", "tree": {"sha": "96d3fe1107c175f3792eb960cf3d9b9cc87731b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96d3fe1107c175f3792eb960cf3d9b9cc87731b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dc452335a410e139220c4ecadbbda9dd15fe8e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc452335a410e139220c4ecadbbda9dd15fe8e2", "html_url": "https://github.com/rust-lang/rust/commit/6dc452335a410e139220c4ecadbbda9dd15fe8e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dc452335a410e139220c4ecadbbda9dd15fe8e2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec9d7abf8ce7f8c62894b772928303e5ee71970f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec9d7abf8ce7f8c62894b772928303e5ee71970f", "html_url": "https://github.com/rust-lang/rust/commit/ec9d7abf8ce7f8c62894b772928303e5ee71970f"}], "stats": {"total": 94, "additions": 78, "deletions": 16}, "files": [{"sha": "151411c6bcac67053a6ae7f6fa8b7822b35723d1", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=6dc452335a410e139220c4ecadbbda9dd15fe8e2", "patch": "@@ -8,6 +8,7 @@ import lib.llvm.mk_object_file;\n import lib.llvm.mk_section_iter;\n import middle.fold;\n import middle.metadata;\n+import middle.trans;\n import middle.ty;\n import back.x86;\n import util.common;\n@@ -324,7 +325,8 @@ impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n     auto eqer = bind eq_item(_, item_id);\n     auto hash = metadata.hash_def_num(item_id);\n     ebml.move_to_sibling_with_id(ebml_r, metadata.tag_items);\n-    lookup_hash_entry(ebml_r, eqer, hash);\n+    auto found = lookup_hash_entry(ebml_r, eqer, hash);\n+    check (found);\n }\n \n // Looks up an item in the given metadata and returns an EBML reader pointing\n@@ -409,17 +411,17 @@ impure fn get_item_type(&ebml.reader ebml_r, int this_cnum) -> @ty.t {\n     ret get_item_generic[@ty.t](ebml_r, metadata.tag_items_data_item_type, f);\n }\n \n-impure fn get_item_ty_params(&ebml.reader ebml_r, int this_cnum)\n+impure fn collect_def_ids(&ebml.reader ebml_r, int this_cnum, uint tag_id)\n         -> vec[ast.def_id] {\n-    let vec[ast.def_id] tps = vec();\n+    let vec[ast.def_id] def_ids = vec();\n     while (ebml.bytes_left(ebml_r) > 0u) {\n         auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == metadata.tag_items_data_item_ty_param) {\n+        if (ebml_tag.id == tag_id) {\n             ebml.move_to_first_child(ebml_r);\n \n             auto data = ebml.read_data(ebml_r);\n             auto external_def_id = parse_def_id(data);\n-            tps += vec(tup(this_cnum, external_def_id._1));\n+            def_ids += vec(tup(this_cnum, external_def_id._1));\n \n             ebml.move_to_parent(ebml_r);\n         }\n@@ -430,7 +432,19 @@ impure fn get_item_ty_params(&ebml.reader ebml_r, int this_cnum)\n     ebml.move_to_parent(ebml_r);\n     ebml.move_to_first_child(ebml_r);\n \n-    ret tps;\n+    ret def_ids;\n+}\n+\n+impure fn get_item_ty_params(&ebml.reader ebml_r, int this_cnum)\n+        -> vec[ast.def_id] {\n+    ret collect_def_ids(ebml_r, this_cnum,\n+                        metadata.tag_items_data_item_ty_param);\n+}\n+\n+impure fn collect_tag_variant_ids(&ebml.reader ebml_r, int this_cnum)\n+        -> vec[ast.def_id] {\n+    ret collect_def_ids(ebml_r, this_cnum,\n+                        metadata.tag_items_data_item_variant);\n }\n \n \n@@ -590,6 +604,35 @@ fn get_symbol(session.session sess, ast.def_id def) -> str {\n     ret get_item_symbol(ebml_r);\n }\n \n+fn get_tag_variants(session.session sess, ast.def_id def)\n+        -> vec[trans.variant_info] {\n+    auto external_crate_id = def._0;\n+    auto data = sess.get_external_crate(external_crate_id);\n+    auto ebml_r = lookup_item(def._1, data);\n+\n+    let vec[trans.variant_info] infos = vec();\n+    auto variant_ids = collect_tag_variant_ids(ebml_r, external_crate_id);\n+    for (ast.def_id did in variant_ids) {\n+        ebml.reset_reader(ebml_r, 0u);\n+        move_to_item(ebml_r, did._1);\n+        auto ctor_ty = get_item_type(ebml_r, external_crate_id);\n+        let vec[@ty.t] arg_tys = vec();\n+        alt (ctor_ty.struct) {\n+            case (ty.ty_fn(_, ?args, _)) {\n+                for (ty.arg a in args) {\n+                    arg_tys += vec(a.ty);\n+                }\n+            }\n+            case (_) {\n+                // Nullary tag variant.\n+            }\n+        }\n+        infos += vec(rec(args=arg_tys, ctor_ty=ctor_ty, id=did));\n+    }\n+\n+    ret infos;\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "587db223af8b4581cd3fd9dd3b21b3d98c28d512", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=6dc452335a410e139220c4ecadbbda9dd15fe8e2", "patch": "@@ -176,8 +176,12 @@ fn encode_def_id(&ebml.writer ebml_w, &ast.def_id id) {\n     ebml.end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_paths(&ebml.writer ebml_w, vec[ast.variant] variants) {\n+fn encode_tag_variant_paths(&ebml.writer ebml_w,\n+                            vec[ast.variant] variants,\n+                            vec[str] path,\n+                            &mutable vec[tup(str, uint)] index) {\n     for (ast.variant variant in variants) {\n+        add_to_index(ebml_w, path, index, variant.node.name);\n         ebml.start_tag(ebml_w, tag_paths_data_item);\n         encode_name(ebml_w, variant.node.name);\n         encode_def_id(ebml_w, variant.node.id);\n@@ -266,9 +270,10 @@ fn encode_module_item_paths(&ebml.writer ebml_w,\n                 add_to_index(ebml_w, path, index, id);\n                 ebml.start_tag(ebml_w, tag_paths_data_item);\n                 encode_name(ebml_w, id);\n-                encode_tag_variant_paths(ebml_w, variants);\n                 encode_def_id(ebml_w, did);\n                 ebml.end_tag(ebml_w);\n+\n+                encode_tag_variant_paths(ebml_w, variants, path, index);\n             }\n             case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n                 add_to_index(ebml_w, path, index, id);\n@@ -314,6 +319,12 @@ fn encode_type_params(&ebml.writer ebml_w, vec[ast.ty_param] tps) {\n     }\n }\n \n+fn encode_variant_id(&ebml.writer ebml_w, ast.def_id vid) {\n+    ebml.start_tag(ebml_w, tag_items_data_item_variant);\n+    ebml_w.writer.write(_str.bytes(def_to_str(vid)));\n+    ebml.end_tag(ebml_w);\n+}\n+\n fn encode_type(&ebml.writer ebml_w, @ty.t typ) {\n     ebml.start_tag(ebml_w, tag_items_data_item_type);\n     auto f = def_to_str;\n@@ -348,23 +359,24 @@ fn encode_obj_type_id(&ebml.writer ebml_w, &ast.def_id id) {\n \n \n fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n-                           ast.def_id did, vec[ast.variant] variants) {\n+                           ast.def_id did, vec[ast.variant] variants,\n+                           &mutable vec[tup(int, uint)] index) {\n     for (ast.variant variant in variants) {\n+        index += vec(tup(variant.node.id._1, ebml_w.writer.tell()));\n+\n         ebml.start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, variant.node.id);\n         encode_kind(ebml_w, 'v' as u8);\n         encode_tag_id(ebml_w, did);\n         encode_type(ebml_w, trans.node_ann_type(cx, variant.node.ann));\n-        if (_vec.len[ast.variant_arg](variant.node.args) > 0u) {\n-            encode_symbol(cx, ebml_w, variant.node.id);\n-        }\n+        encode_symbol(cx, ebml_w, variant.node.id);\n         encode_discriminant(cx, ebml_w, variant.node.id);\n         ebml.end_tag(ebml_w);\n     }\n }\n \n fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n-                        @ast.item item) {\n+                        @ast.item item, &mutable vec[tup(int, uint)] index) {\n     alt (item.node) {\n         case (ast.item_const(_, _, _, ?did, ?ann)) {\n             ebml.start_tag(ebml_w, tag_items_data_item);\n@@ -409,9 +421,12 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_kind(ebml_w, 't' as u8);\n             encode_type_params(ebml_w, tps);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n+            for (ast.variant v in variants) {\n+                encode_variant_id(ebml_w, v.node.id);\n+            }\n             ebml.end_tag(ebml_w);\n \n-            encode_tag_variant_info(cx, ebml_w, did, variants);\n+            encode_tag_variant_info(cx, ebml_w, did, variants, index);\n         }\n         case (ast.item_obj(?id, _, ?tps, ?odid, ?ann)) {\n             ebml.start_tag(ebml_w, tag_items_data_item);\n@@ -458,7 +473,7 @@ fn encode_info_for_items(@trans.crate_ctxt cx, &ebml.writer ebml_w)\n     ebml.start_tag(ebml_w, tag_items_data);\n     for each (@tup(ast.def_id, @ast.item) kvp in cx.items.items()) {\n         index += vec(tup(kvp._0._1, ebml_w.writer.tell()));\n-        encode_info_for_item(cx, ebml_w, kvp._1);\n+        encode_info_for_item(cx, ebml_w, kvp._1, index);\n     }\n     for each (@tup(ast.def_id, @ast.native_item) kvp in\n             cx.native_items.items()) {"}, {"sha": "7859393e56d303daa21a74eeeb5000df72393f25", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6dc452335a410e139220c4ecadbbda9dd15fe8e2", "patch": "@@ -1911,7 +1911,10 @@ type variant_info = rec(vec[@ty.t] args, @ty.t ctor_ty, ast.def_id id);\n \n // Returns information about the variants in a tag.\n fn tag_variants(@crate_ctxt cx, ast.def_id id) -> vec[variant_info] {\n-    // FIXME: This doesn't work for external variants.\n+    if (cx.sess.get_targ_crate_num() != id._0) {\n+        ret creader.get_tag_variants(cx.sess, id);\n+    }\n+\n     check (cx.items.contains_key(id));\n     alt (cx.items.get(id).node) {\n         case (ast.item_tag(_, ?variants, _, _, _)) {"}, {"sha": "98fae38b232a9895c6447b509a4377020c731481", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6dc452335a410e139220c4ecadbbda9dd15fe8e2/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=6dc452335a410e139220c4ecadbbda9dd15fe8e2", "patch": "@@ -47,6 +47,7 @@ auth front.creader.load_crate = unsafe;\n auth front.creader.lookup_def = impure;\n auth front.creader.get_type = impure;\n auth front.creader.get_symbol = impure;\n+auth front.creader.get_tag_variants = impure;\n auth front.creader.impure_no_op = impure;\n auth middle.metadata = unsafe;\n auth middle.metadata.encode_index = impure;"}]}