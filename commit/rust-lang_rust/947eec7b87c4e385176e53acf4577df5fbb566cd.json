{"sha": "947eec7b87c4e385176e53acf4577df5fbb566cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0N2VlYzdiODdjNGUzODUxNzZlNTNhY2Y0NTc3ZGY1ZmJiNTY2Y2Q=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-30T21:40:50Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-01-11T22:33:04Z"}, "message": "Use super, don't use private imports", "tree": {"sha": "d5211f8d8d891985bbb749682c25750caf9f7f23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5211f8d8d891985bbb749682c25750caf9f7f23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/947eec7b87c4e385176e53acf4577df5fbb566cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/947eec7b87c4e385176e53acf4577df5fbb566cd", "html_url": "https://github.com/rust-lang/rust/commit/947eec7b87c4e385176e53acf4577df5fbb566cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/947eec7b87c4e385176e53acf4577df5fbb566cd/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df9d3bd25e9e80a7c55f6a786ccccdcca4a7eb03", "url": "https://api.github.com/repos/rust-lang/rust/commits/df9d3bd25e9e80a7c55f6a786ccccdcca4a7eb03", "html_url": "https://github.com/rust-lang/rust/commit/df9d3bd25e9e80a7c55f6a786ccccdcca4a7eb03"}], "stats": {"total": 50, "additions": 48, "deletions": 2}, "files": [{"sha": "be34ee6626117fc3fad9e3a9c4045a975ff660e8", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/947eec7b87c4e385176e53acf4577df5fbb566cd/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/947eec7b87c4e385176e53acf4577df5fbb566cd/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=947eec7b87c4e385176e53acf4577df5fbb566cd", "patch": "@@ -8,8 +8,6 @@ use crate::{\n };\n use hir_expand::name::Name;\n \n-// TODO don't import from super imports? or at least deprioritize\n-// TODO use super?\n // TODO performance / memoize\n \n pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n@@ -27,6 +25,13 @@ pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Optio\n         return Some(ModPath::from_simple_segments(PathKind::Crate, Vec::new()));\n     }\n \n+    // - if the item is the parent module, use `super` (this is not used recursively, since `super::super` is ugly)\n+    if let Some(parent_id) = def_map.modules[from.local_id].parent {\n+        if item == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId { krate: from.krate, local_id: parent_id })) {\n+            return Some(ModPath::from_simple_segments(PathKind::Super(1), Vec::new()));\n+        }\n+    }\n+\n     // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n     for (name, def_id) in &def_map.extern_prelude {\n         if item == ItemInNs::Types(*def_id) {\n@@ -80,6 +85,19 @@ fn find_importable_locations(db: &impl DefDatabase, item: ItemInNs, from: Module\n         let def_map = db.crate_def_map(krate);\n         for (local_id, data) in def_map.modules.iter() {\n             if let Some((name, vis)) = data.scope.reverse_get(item) {\n+                let is_private = if let crate::visibility::Visibility::Module(private_to) = vis {\n+                    private_to.local_id == local_id\n+                } else { false };\n+                let is_original_def = if let Some(module_def_id) = item.as_module_def_id() {\n+                    data.scope.declarations().any(|it| it == module_def_id)\n+                } else { false };\n+                if is_private && !is_original_def {\n+                    // Ignore private imports. these could be used if we are\n+                    // in a submodule of this module, but that's usually not\n+                    // what the user wants; and if this module can import\n+                    // the item and we're a submodule of it, so can we.\n+                    continue;\n+                }\n                 if vis.is_visible_from(db, from) {\n                     result.push((ModuleId { krate, local_id }, name.clone()));\n                 }\n@@ -160,6 +178,20 @@ mod tests {\n         check_found_path(code, \"foo::S\");\n     }\n \n+    #[test]\n+    fn super_module() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            //- /foo.rs\n+            mod bar;\n+            struct S;\n+            //- /foo/bar.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"super::S\");\n+    }\n+\n     #[test]\n     fn crate_root() {\n         let code = r#\"\n@@ -290,4 +322,18 @@ mod tests {\n         \"#;\n         check_found_path(code, \"baz::S\");\n     }\n+\n+    #[test]\n+    fn discount_private_imports() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            pub mod bar { pub struct S; }\n+            use bar::S;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        // crate::S would be shorter, but using private imports seems wrong\n+        check_found_path(code, \"crate::bar::S\");\n+    }\n }"}]}