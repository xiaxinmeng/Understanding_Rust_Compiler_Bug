{"sha": "bdea34387945aee7d18981a8c59f5b04beb560fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZWEzNDM4Nzk0NWFlZTdkMTg5ODFhOGM1OWY1YjA0YmViNTYwZmM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T01:28:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-01T01:28:59Z"}, "message": "rustc: Use the path index. Speeds up compilation a lot.", "tree": {"sha": "faaa284bb575ade6e1f0f1b1fe415be89a088fc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faaa284bb575ade6e1f0f1b1fe415be89a088fc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdea34387945aee7d18981a8c59f5b04beb560fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdea34387945aee7d18981a8c59f5b04beb560fc", "html_url": "https://github.com/rust-lang/rust/commit/bdea34387945aee7d18981a8c59f5b04beb560fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdea34387945aee7d18981a8c59f5b04beb560fc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/fffc5d3b3dd495d2301304cab1100df6f89b6aa7", "html_url": "https://github.com/rust-lang/rust/commit/fffc5d3b3dd495d2301304cab1100df6f89b6aa7"}], "stats": {"total": 139, "additions": 48, "deletions": 91}, "files": [{"sha": "22c38c3172c76ada5f21433b2e928b41ff89ffb0", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 48, "deletions": 91, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/bdea34387945aee7d18981a8c59f5b04beb560fc/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdea34387945aee7d18981a8c59f5b04beb560fc/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=bdea34387945aee7d18981a8c59f5b04beb560fc", "patch": "@@ -35,7 +35,7 @@ type env = @rec(\n \n tag resolve_result {\n     rr_ok(ast.def_id);\n-    rr_not_found(vec[ast.ident], ast.ident);\n+    rr_not_found(ast.ident);\n }\n \n // Type decoding\n@@ -253,94 +253,15 @@ fn parse_def_id(vec[u8] buf) -> ast.def_id {\n     ret tup(crate_num, def_num);\n }\n \n-// Given a path and serialized crate metadata, returns the ID of the\n-// definition the path refers to.\n-impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n-    impure fn resolve_path_inner(vec[ast.ident] path, &ebml.reader ebml_r)\n-            -> resolve_result {\n-        auto i = 0u;\n-        auto len = _vec.len[ast.ident](path);\n-        while (i < len) {\n-            auto name = path.(i);\n-            auto last = i == len - 1u;\n-\n-            // Search this level for the identifier.\n-            auto found = false;\n-            while (ebml.bytes_left(ebml_r) > 0u && !found) {\n-                auto ebml_tag = ebml.peek(ebml_r);\n-                if ((ebml_tag.id == metadata.tag_paths_data_item) ||\n-                        (ebml_tag.id == metadata.tag_paths_data_mod)) {\n-                    ebml.move_to_first_child(ebml_r);\n-                    auto did_opt = none[ast.def_id];\n-                    auto name_opt = none[ast.ident];\n-                    while (ebml.bytes_left(ebml_r) > 0u) {\n-                        auto inner_tag = ebml.peek(ebml_r);\n-                        if (inner_tag.id == metadata.tag_paths_data_name) {\n-                            ebml.move_to_first_child(ebml_r);\n-                            auto name_data = ebml.read_data(ebml_r);\n-                            ebml.move_to_parent(ebml_r);\n-                            auto nm = _str.unsafe_from_bytes(name_data);\n-                            name_opt = some[ast.ident](nm);\n-                        } else if (inner_tag.id == metadata.tag_def_id) {\n-                            ebml.move_to_first_child(ebml_r);\n-                            auto did_data = ebml.read_data(ebml_r);\n-                            ebml.move_to_parent(ebml_r);\n-                            auto did = parse_def_id(did_data);\n-                            did_opt = some[ast.def_id](did);\n-                        }\n-                        ebml.move_to_next_sibling(ebml_r);\n-                    }\n-                    ebml.move_to_parent(ebml_r);\n-\n-                    if (_str.eq(option.get[ast.ident](name_opt), name)) {\n-                        // Matched!\n-                        if (last) {\n-                            ret rr_ok(option.get[ast.def_id](did_opt));\n-                        }\n-\n-                        // Move to the module/item we found for the next\n-                        // iteration of the loop...\n-                        ebml.move_to_first_child(ebml_r);\n-                        found = true;\n-                    }\n-                }\n-                ebml.move_to_next_sibling(ebml_r);\n-            }\n-\n-            if (!found) {\n-                auto prev = _vec.slice[ast.ident](path, 0u, i);\n-                ret rr_not_found(prev, name);\n-            }\n-\n-            i += 1u;\n-        }\n-\n-        fail;   // not reached\n-    }\n-\n-    auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n-    auto ebml_r = ebml.create_reader(io_r);\n-    while (ebml.bytes_left(ebml_r) > 0u) {\n-        auto ebml_tag = ebml.peek(ebml_r);\n-        if (ebml_tag.id == metadata.tag_paths) {\n-            ebml.move_to_first_child(ebml_r);\n-            ret resolve_path_inner(path, ebml_r);\n-        }\n-        ebml.move_to_next_sibling(ebml_r);\n-    }\n-\n-    log \"resolve_path(): no names in file\";\n-    fail;\n-}\n-\n-impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n-    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_items);\n+impure fn lookup_hash_entry(&ebml.reader ebml_r,\n+                            impure fn(&ebml.reader) -> bool eq_fn,\n+                            uint hash) -> bool {\n     ebml.move_to_child_with_id(ebml_r, metadata.tag_index);\n     ebml.move_to_child_with_id(ebml_r, metadata.tag_index_table);\n     ebml.move_to_first_child(ebml_r);\n \n     // Move to the bucket.\n-    auto bucket_index = metadata.hash_def_num(item_id) % 256u;\n+    auto bucket_index = hash % 256u;\n     auto buf_reader = ebml_r.reader.get_buf_reader();\n     buf_reader.seek((bucket_index * 4u) as int, io.seek_cur);\n     auto bucket_pos = ebml_r.reader.read_be_uint(4u);\n@@ -353,21 +274,57 @@ impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n         if (ebml.peek(ebml_r).id == metadata.tag_index_buckets_bucket_elt) {\n             ebml.move_to_first_child(ebml_r);\n             auto pos = ebml_r.reader.read_be_uint(4u);\n-            auto this_item_id = ebml_r.reader.read_be_uint(4u) as int;\n-            if (item_id == this_item_id) {\n+            if (eq_fn(ebml_r)) {\n                 // Found the item. Move to its data and return.\n                 ebml.reset_reader(ebml_r, pos);\n-                check (ebml.peek(ebml_r).id == metadata.tag_items_data_item);\n                 ebml.move_to_first_child(ebml_r);\n-                ret;\n+                ret true;\n             }\n             ebml.move_to_parent(ebml_r);\n         }\n         ebml.move_to_next_sibling(ebml_r);\n     }\n \n-    log #fmt(\"item %d not found in bucket at pos %u\", item_id, bucket_pos);\n-    fail;\n+    ret false;\n+}\n+\n+// Given a path and serialized crate metadata, returns the ID of the\n+// definition the path refers to.\n+impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n+    impure fn eq_item(&ebml.reader ebml_r, str s) -> bool {\n+        auto this_str = _str.unsafe_from_bytes(ebml.read_data(ebml_r));\n+        ret _str.eq(this_str, s);\n+    }\n+\n+    auto s = _str.connect(path, \".\");\n+\n+    auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n+    auto ebml_r = ebml.create_reader(io_r);\n+    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_paths);\n+\n+    auto eqer = bind eq_item(_, s);\n+    auto hash = metadata.hash_path(s);\n+    if (!lookup_hash_entry(ebml_r, eqer, hash)) {\n+        ret rr_not_found(s);\n+    }\n+\n+    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_def_id);\n+    ebml.move_to_first_child(ebml_r);\n+    auto did_data = ebml.read_data(ebml_r);\n+    ebml.move_to_parent(ebml_r);\n+    auto did = parse_def_id(did_data);\n+    ret rr_ok(did);\n+}\n+\n+impure fn move_to_item(&ebml.reader ebml_r, int item_id) {\n+    impure fn eq_item(&ebml.reader ebml_r, int item_id) -> bool {\n+        ret (ebml_r.reader.read_be_uint(4u) as int) == item_id;\n+    }\n+\n+    auto eqer = bind eq_item(_, item_id);\n+    auto hash = metadata.hash_def_num(item_id);\n+    ebml.move_to_sibling_with_id(ebml_r, metadata.tag_items);\n+    lookup_hash_entry(ebml_r, eqer, hash);\n }\n \n // Looks up an item in the given metadata and returns an EBML reader pointing\n@@ -573,7 +530,7 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     auto did;\n     alt (resolve_path(path, data)) {\n         case (rr_ok(?di)) { did = di; }\n-        case (rr_not_found(?prev, ?name)) {\n+        case (rr_not_found(?name)) {\n             ret none[ast.def];\n         }\n     }"}]}