{"sha": "daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYWY0NjE3N2U1ZGM2M2UyMGU1YTFlYzU2OTJlNTNjYzhmN2JjMzQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-26T19:37:03Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-26T21:03:39Z"}, "message": "Add SubstsBuilder\n\n+ further refactoring.", "tree": {"sha": "2229733948df98f119aee5eca600a50726192c68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2229733948df98f119aee5eca600a50726192c68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "html_url": "https://github.com/rust-lang/rust/commit/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1002e470747fe5887a2915689e21d9be3a1ca5d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1002e470747fe5887a2915689e21d9be3a1ca5d8", "html_url": "https://github.com/rust-lang/rust/commit/1002e470747fe5887a2915689e21d9be3a1ca5d8"}], "stats": {"total": 338, "additions": 212, "deletions": 126}, "files": [{"sha": "fd7afcbb6422e5e57090829c2661c4274bf9cf39", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -339,10 +339,14 @@ pub struct Struct {\n }\n \n impl Struct {\n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         db.struct_data(self).name.clone()\n     }\n@@ -423,10 +427,14 @@ pub struct Enum {\n }\n \n impl Enum {\n-    pub fn module(self, db: &impl HirDatabase) -> Module {\n+    pub fn module(self, db: &impl DefDatabase) -> Module {\n         self.id.module(db)\n     }\n \n+    pub fn krate(self, db: &impl DefDatabase) -> Option<Crate> {\n+        self.module(db).krate(db)\n+    }\n+\n     pub fn name(self, db: &impl DefDatabase) -> Option<Name> {\n         db.enum_data(self).name.clone()\n     }\n@@ -514,7 +522,7 @@ impl Adt {\n         }\n     }\n \n-    pub(crate) fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n+    pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n         match self {\n             Adt::Struct(s) => s.module(db),\n             Adt::Union(s) => s.module(db),"}, {"sha": "125e0beea490889f0c47ea5e3e1da84a726ee944", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -9,7 +9,6 @@ test_utils::marks!(\n     glob_across_crates\n     std_prelude\n     match_ergonomics_ref\n-    trait_resolution_on_fn_type\n     infer_while_let\n     macro_rules_from_other_crates_are_visible_with_macro_use\n     prelude_is_macro_use"}, {"sha": "d161735e8fbf7338e4976160b4517bfdc6827448", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 135, "deletions": 6, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -14,11 +14,11 @@ pub(crate) mod display;\n \n use std::ops::Deref;\n use std::sync::Arc;\n-use std::{fmt, mem};\n+use std::{fmt, iter, mem};\n \n use crate::{\n-    db::HirDatabase, expr::ExprId, type_ref::Mutability, Adt, DefWithBody, GenericParams, Name,\n-    Trait, TypeAlias,\n+    db::HirDatabase, expr::ExprId, type_ref::Mutability, Adt, Crate, DefWithBody, GenericParams,\n+    HasGenericParams, Name, Trait, TypeAlias,\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -111,6 +111,81 @@ pub enum TypeCtor {\n     Closure { def: DefWithBody, expr: ExprId },\n }\n \n+impl TypeCtor {\n+    pub fn num_ty_params(self, db: &impl HirDatabase) -> usize {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never => 0,\n+            TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n+            => 1,\n+            TypeCtor::Adt(adt) => {\n+                let generic_params = adt.generic_params(db);\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::FnDef(callable) => {\n+                let generic_params = callable.generic_params(db);\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::AssociatedType(type_alias) => {\n+                let generic_params = type_alias.generic_params(db);\n+                generic_params.count_params_including_parent()\n+            }\n+            TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n+            TypeCtor::Tuple { cardinality } => cardinality as usize,\n+        }\n+    }\n+\n+    pub fn krate(self, db: &impl HirDatabase) -> Option<Crate> {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never\n+            | TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Tuple { .. } => None,\n+            TypeCtor::Closure { def, .. } => def.krate(db),\n+            TypeCtor::Adt(adt) => adt.krate(db),\n+            TypeCtor::FnDef(callable) => callable.krate(db),\n+            TypeCtor::AssociatedType(type_alias) => type_alias.krate(db),\n+        }\n+    }\n+\n+    pub fn as_generic_def(self) -> Option<crate::generics::GenericDef> {\n+        match self {\n+            TypeCtor::Bool\n+            | TypeCtor::Char\n+            | TypeCtor::Int(_)\n+            | TypeCtor::Float(_)\n+            | TypeCtor::Str\n+            | TypeCtor::Never\n+            | TypeCtor::Slice\n+            | TypeCtor::Array\n+            | TypeCtor::RawPtr(_)\n+            | TypeCtor::Ref(_)\n+            | TypeCtor::FnPtr { .. }\n+            | TypeCtor::Tuple { .. }\n+            | TypeCtor::Closure { .. } => None,\n+            TypeCtor::Adt(adt) => Some(adt.into()),\n+            TypeCtor::FnDef(callable) => Some(callable.into()),\n+            TypeCtor::AssociatedType(type_alias) => Some(type_alias.into()),\n+        }\n+    }\n+}\n+\n /// A nominal type with (maybe 0) type parameters. This might be a primitive\n /// type like `bool`, a struct, tuple, function pointer, reference or\n /// several other things.\n@@ -271,11 +346,65 @@ impl Substs {\n                 .into(),\n         )\n     }\n+\n+    pub fn build_for_def(\n+        db: &impl HirDatabase,\n+        def: impl crate::HasGenericParams,\n+    ) -> SubstsBuilder {\n+        let params = def.generic_params(db);\n+        let param_count = params.count_params_including_parent();\n+        Substs::builder(param_count)\n+    }\n+\n+    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n+        Substs::builder(generic_params.count_params_including_parent())\n+    }\n+\n+    pub fn build_for_type_ctor(db: &impl HirDatabase, type_ctor: TypeCtor) -> SubstsBuilder {\n+        Substs::builder(type_ctor.num_ty_params(db))\n+    }\n+\n+    fn builder(param_count: usize) -> SubstsBuilder {\n+        SubstsBuilder { vec: Vec::with_capacity(param_count), param_count }\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct SubstsBuilder {\n+    vec: Vec<Ty>,\n+    param_count: usize,\n }\n \n-impl From<Vec<Ty>> for Substs {\n-    fn from(v: Vec<Ty>) -> Self {\n-        Substs(v.into())\n+impl SubstsBuilder {\n+    pub fn build(self) -> Substs {\n+        assert_eq!(self.vec.len(), self.param_count);\n+        Substs(self.vec.into())\n+    }\n+\n+    pub fn push(mut self, ty: Ty) -> Self {\n+        self.vec.push(ty);\n+        self\n+    }\n+\n+    fn remaining(&self) -> usize {\n+        self.param_count - self.vec.len()\n+    }\n+\n+    pub fn fill_with_bound_vars(mut self, starting_from: u32) -> Self {\n+        self.vec.extend((starting_from..starting_from + self.remaining() as u32).map(Ty::Bound));\n+        self\n+    }\n+\n+    pub fn fill_with_unknown(mut self) -> Self {\n+        self.vec.extend(iter::repeat(Ty::Unknown).take(self.remaining()));\n+        self\n+    }\n+\n+    pub fn use_parent_substs(mut self, parent_substs: &Substs) -> Self {\n+        assert!(self.vec.is_empty());\n+        assert!(parent_substs.len() <= self.param_count);\n+        self.vec.extend(parent_substs.iter().cloned());\n+        self\n     }\n }\n "}, {"sha": "02492ca145070624b7129de0dc47d7cf81158b91", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -7,7 +7,7 @@ use std::iter::successors;\n \n use log::{info, warn};\n \n-use super::{traits::Solution, Canonical, Ty, TypeWalk};\n+use super::{traits::Solution, Canonical, Substs, Ty, TypeWalk};\n use crate::{db::HirDatabase, name, HasGenericParams, Resolver};\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -44,7 +44,8 @@ fn deref_by_trait(\n     };\n     let target = deref_trait.associated_type_by_name(db, &name::TARGET_TYPE)?;\n \n-    if target.generic_params(db).count_params_including_parent() != 1 {\n+    let generic_params = target.generic_params(db);\n+    if generic_params.count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type\n         return None;\n@@ -54,12 +55,13 @@ fn deref_by_trait(\n \n     let env = super::lower::trait_env(db, resolver);\n \n+    let parameters = Substs::build_for_generics(&generic_params)\n+        .push(ty.value.clone().shift_bound_vars(1))\n+        .build();\n+\n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(0),\n-        projection_ty: super::ProjectionTy {\n-            associated_ty: target,\n-            parameters: vec![ty.value.clone().shift_bound_vars(1)].into(),\n-        },\n+        projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n     let obligation = super::Obligation::Projection(projection);"}, {"sha": "8e07fc18641802d2b7aa5f99603da123d14b6ffc", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -688,14 +688,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 };\n                 let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n \n-                let inner_tys: Substs = args\n+                let inner_tys = args\n                     .iter()\n                     .zip(expectations_iter)\n                     .map(|(&pat, ty)| self.infer_pat(pat, ty, default_bm))\n-                    .collect::<Vec<_>>()\n-                    .into();\n+                    .collect();\n \n-                Ty::apply(TypeCtor::Tuple { cardinality: inner_tys.len() as u16 }, inner_tys)\n+                Ty::apply(TypeCtor::Tuple { cardinality: args.len() as u16 }, Substs(inner_tys))\n             }\n             Pat::Ref { pat, mutability } => {\n                 let expectation = match expected.as_reference() {\n@@ -1229,7 +1228,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             ty: pat_ty.clone(),\n                             projection_ty: ProjectionTy {\n                                 associated_ty: into_iter_item_alias,\n-                                parameters: vec![iterable_ty].into(),\n+                                parameters: Substs::single(iterable_ty),\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n@@ -1262,7 +1261,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = Ty::apply(\n                     TypeCtor::FnPtr { num_args: sig_tys.len() as u16 - 1 },\n-                    sig_tys.into(),\n+                    Substs(sig_tys.into()),\n                 );\n                 let closure_ty = Ty::apply_one(\n                     TypeCtor::Closure { def: self.body.owner(), expr: tgt_expr },\n@@ -1400,7 +1399,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n                                 associated_ty: future_future_output_alias,\n-                                parameters: vec![inner_ty].into(),\n+                                parameters: Substs::single(inner_ty),\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));\n@@ -1419,7 +1418,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             ty: ty.clone(),\n                             projection_ty: ProjectionTy {\n                                 associated_ty: ops_try_ok_alias,\n-                                parameters: vec![inner_ty].into(),\n+                                parameters: Substs::single(inner_ty),\n                             },\n                         };\n                         self.obligations.push(Obligation::Projection(projection));"}, {"sha": "db979353a09af26a393dac208e8591a55bc753d5", "filename": "crates/ra_hir/src/ty/infer/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Fpath.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -158,13 +158,13 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             AssocItem::Const(c) => ValueNs::Const(c),\n             AssocItem::TypeAlias(_) => unreachable!(),\n         };\n-        let generics = item.generic_params(self.db);\n-        let mut substs = Vec::with_capacity(generics.count_params_including_parent());\n-        substs.extend(trait_ref.substs.iter().cloned());\n-        substs.extend(std::iter::repeat(Ty::Unknown).take(generics.params.len()));\n+        let substs = Substs::build_for_def(self.db, item)\n+            .use_parent_substs(&trait_ref.substs)\n+            .fill_with_unknown()\n+            .build();\n \n         self.write_assoc_resolution(id, item);\n-        Some((def, Some(substs.into())))\n+        Some((def, Some(substs)))\n     }\n \n     fn resolve_ty_assoc_item("}, {"sha": "d161aa6b390710516843eba2607c84aa7b12abe8", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -3,7 +3,8 @@\n use super::{InferenceContext, Obligation};\n use crate::db::HirDatabase;\n use crate::ty::{\n-    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty, TypeWalk,\n+    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n+    TypeWalk,\n };\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n@@ -74,12 +75,9 @@ where\n     }\n \n     fn do_canonicalize_trait_ref(&mut self, trait_ref: TraitRef) -> TraitRef {\n-        let substs = trait_ref\n-            .substs\n-            .iter()\n-            .map(|ty| self.do_canonicalize_ty(ty.clone()))\n-            .collect::<Vec<_>>();\n-        TraitRef { trait_: trait_ref.trait_, substs: substs.into() }\n+        let substs =\n+            trait_ref.substs.iter().map(|ty| self.do_canonicalize_ty(ty.clone())).collect();\n+        TraitRef { trait_: trait_ref.trait_, substs: Substs(substs) }\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n@@ -90,12 +88,9 @@ where\n     }\n \n     fn do_canonicalize_projection_ty(&mut self, projection_ty: ProjectionTy) -> ProjectionTy {\n-        let params = projection_ty\n-            .parameters\n-            .iter()\n-            .map(|ty| self.do_canonicalize_ty(ty.clone()))\n-            .collect::<Vec<_>>();\n-        ProjectionTy { associated_ty: projection_ty.associated_ty, parameters: params.into() }\n+        let params =\n+            projection_ty.parameters.iter().map(|ty| self.do_canonicalize_ty(ty.clone())).collect();\n+        ProjectionTy { associated_ty: projection_ty.associated_ty, parameters: Substs(params) }\n     }\n \n     fn do_canonicalize_projection_predicate(\n@@ -153,8 +148,7 @@ impl<T> Canonicalized<T> {\n         solution: Canonical<Vec<Ty>>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n-        let new_vars =\n-            (0..solution.num_vars).map(|_| ctx.new_type_var()).collect::<Vec<_>>().into();\n+        let new_vars = Substs((0..solution.num_vars).map(|_| ctx.new_type_var()).collect());\n         for (i, ty) in solution.value.into_iter().enumerate() {\n             let var = self.free_vars[i];\n             ctx.unify(&Ty::Infer(var), &ty.subst_bound_vars(&new_vars));"}, {"sha": "4b67c82e777091147b2effb0767787d9ec037e97", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -239,14 +239,10 @@ impl Ty {\n         let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n         for t in traits {\n             if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n-                let generics = t.generic_params(db);\n-                let mut substs = Vec::new();\n-                substs.push(self_ty.clone());\n-                substs.extend(\n-                    iter::repeat(Ty::Unknown).take(generics.count_params_including_parent() - 1),\n-                );\n+                let substs =\n+                    Substs::build_for_def(db, t).push(self_ty.clone()).fill_with_unknown().build();\n                 // FIXME handle type parameters on the segment\n-                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs.into() });\n+                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs });\n             }\n         }\n         Ty::Unknown\n@@ -766,6 +762,16 @@ pub enum CallableDef {\n }\n impl_froms!(CallableDef: Function, Struct, EnumVariant);\n \n+impl CallableDef {\n+    pub fn krate(self, db: &impl HirDatabase) -> Option<crate::Crate> {\n+        match self {\n+            CallableDef::Function(f) => f.krate(db),\n+            CallableDef::Struct(s) => s.krate(db),\n+            CallableDef::EnumVariant(e) => e.parent_enum(db).krate(db),\n+        }\n+    }\n+}\n+\n impl From<CallableDef> for GenericDef {\n     fn from(def: CallableDef) -> GenericDef {\n         match def {"}, {"sha": "ad2ab560d8e563d9ce72b1b4c5a55f5660890766", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -10,7 +10,6 @@ use rustc_hash::FxHashMap;\n use super::{autoderef, lower, Canonical, InEnvironment, TraitEnvironment, TraitRef};\n use crate::{\n     db::HirDatabase,\n-    generics::HasGenericParams,\n     impl_block::{ImplBlock, ImplId},\n     nameres::CrateModuleId,\n     resolve::Resolver,\n@@ -331,20 +330,13 @@ fn generic_implements_goal(\n     trait_: Trait,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::Obligation>> {\n-    let mut substs = Vec::new();\n-    let generics = trait_.generic_params(db);\n     let num_vars = self_ty.num_vars;\n-    substs.push(self_ty.value);\n-    substs.extend(\n-        generics\n-            .params_including_parent()\n-            .into_iter()\n-            .skip(1)\n-            .enumerate()\n-            .map(|(i, _p)| Ty::Bound((i + num_vars) as u32)),\n-    );\n+    let substs = super::Substs::build_for_def(db, trait_)\n+        .push(self_ty.value)\n+        .fill_with_bound_vars(num_vars as u32)\n+        .build();\n     let num_vars = substs.len() - 1 + self_ty.num_vars;\n-    let trait_ref = TraitRef { trait_, substs: substs.into() };\n+    let trait_ref = TraitRef { trait_, substs };\n     let obligation = super::Obligation::Trait(trait_ref);\n     Canonical { num_vars, value: InEnvironment::new(env, obligation) }\n }"}, {"sha": "7de434180626663fbd7f769c7d2da3c39fd6b37d", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -3321,7 +3321,6 @@ fn test() { S2.into()<|>; }\n \n #[test]\n fn method_resolution_encountering_fn_type() {\n-    covers!(trait_resolution_on_fn_type);\n     type_at(\n         r#\"\n //- /main.rs"}, {"sha": "2642a54bf9572885dd9e1294d01bc36dcc5d54a5", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 19, "deletions": 61, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=daaf46177e5dc63e20e5a1ec5692e53cc8f7bc34", "patch": "@@ -10,17 +10,13 @@ use chalk_ir::{\n use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n \n use ra_db::salsa::{InternId, InternKey};\n-use test_utils::tested_by;\n \n use super::{Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n     db::HirDatabase,\n     generics::GenericDef,\n     ty::display::HirDisplay,\n-    ty::{\n-        ApplicationTy, CallableDef, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n-    },\n+    ty::{ApplicationTy, GenericPredicate, ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk},\n     AssocItem, Crate, HasGenericParams, ImplBlock, Trait, TypeAlias,\n };\n \n@@ -124,14 +120,15 @@ impl ToChalk for Substs {\n     }\n \n     fn from_chalk(db: &impl HirDatabase, parameters: Vec<chalk_ir::Parameter>) -> Substs {\n-        parameters\n+        let tys = parameters\n             .into_iter()\n             .map(|p| match p {\n                 chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n                 chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n             })\n             .collect::<Vec<_>>()\n-            .into()\n+            .into();\n+        Substs(tys)\n     }\n }\n \n@@ -539,60 +536,18 @@ pub(crate) fn struct_datum_query(\n     struct_id: chalk_ir::StructId,\n ) -> Arc<StructDatum> {\n     debug!(\"struct_datum {:?}\", struct_id);\n-    let type_ctor = from_chalk(db, struct_id);\n+    let type_ctor: TypeCtor = from_chalk(db, struct_id);\n     debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n-    // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n-    // FIXME extract this to a method on Ty\n-    let (num_params, where_clauses, upstream) = match type_ctor {\n-        TypeCtor::Bool\n-        | TypeCtor::Char\n-        | TypeCtor::Int(_)\n-        | TypeCtor::Float(_)\n-        | TypeCtor::Never\n-        | TypeCtor::Str => (0, vec![], true),\n-        TypeCtor::Slice | TypeCtor::Array | TypeCtor::RawPtr(_) | TypeCtor::Ref(_) => {\n-            (1, vec![], true)\n-        }\n-        TypeCtor::FnPtr { num_args } => (num_args as usize + 1, vec![], true),\n-        TypeCtor::Tuple { cardinality } => (cardinality as usize, vec![], true),\n-        TypeCtor::FnDef(callable) => {\n-            tested_by!(trait_resolution_on_fn_type);\n-            let upstream = match callable {\n-                CallableDef::Function(f) => f.module(db).krate(db),\n-                CallableDef::Struct(s) => s.module(db).krate(db),\n-                CallableDef::EnumVariant(v) => v.parent_enum(db).module(db).krate(db),\n-            } != Some(krate);\n-            let generic_def: GenericDef = callable.into();\n+    let num_params = type_ctor.num_ty_params(db);\n+    let upstream = type_ctor.krate(db) != Some(krate);\n+    let where_clauses = type_ctor\n+        .as_generic_def()\n+        .map(|generic_def| {\n             let generic_params = generic_def.generic_params(db);\n             let bound_vars = Substs::bound_vars(&generic_params);\n-            let where_clauses = convert_where_clauses(db, generic_def, &bound_vars);\n-            (generic_params.count_params_including_parent(), where_clauses, upstream)\n-        }\n-        TypeCtor::Adt(adt) => {\n-            let generic_params = adt.generic_params(db);\n-            let bound_vars = Substs::bound_vars(&generic_params);\n-            let where_clauses = convert_where_clauses(db, adt.into(), &bound_vars);\n-            (\n-                generic_params.count_params_including_parent(),\n-                where_clauses,\n-                adt.krate(db) != Some(krate),\n-            )\n-        }\n-        TypeCtor::AssociatedType(type_alias) => {\n-            let generic_params = type_alias.generic_params(db);\n-            let bound_vars = Substs::bound_vars(&generic_params);\n-            let where_clauses = convert_where_clauses(db, type_alias.into(), &bound_vars);\n-            (\n-                generic_params.count_params_including_parent(),\n-                where_clauses,\n-                type_alias.krate(db) != Some(krate),\n-            )\n-        }\n-        TypeCtor::Closure { def, .. } => {\n-            let upstream = def.krate(db) != Some(krate);\n-            (1, vec![], upstream)\n-        }\n-    };\n+            convert_where_clauses(db, generic_def, &bound_vars)\n+        })\n+        .unwrap_or_else(Vec::new);\n     let flags = chalk_rust_ir::StructFlags {\n         upstream,\n         // FIXME set fundamental flag correctly\n@@ -729,17 +684,20 @@ fn closure_fn_trait_impl_datum(\n \n     let arg_ty = Ty::apply(\n         TypeCtor::Tuple { cardinality: num_args },\n-        (0..num_args).map(|i| Ty::Bound(i.into())).collect::<Vec<_>>().into(),\n+        Substs::builder(num_args as usize).fill_with_bound_vars(0).build(),\n     );\n     let output_ty = Ty::Bound(num_args.into());\n     let sig_ty = Ty::apply(\n         TypeCtor::FnPtr { num_args },\n-        (0..num_args + 1).map(|i| Ty::Bound(i.into())).collect::<Vec<_>>().into(),\n+        Substs::builder(num_args as usize + 1).fill_with_bound_vars(0).build(),\n     );\n \n     let self_ty = Ty::apply_one(TypeCtor::Closure { def: data.def, expr: data.expr }, sig_ty);\n \n-    let trait_ref = TraitRef { trait_, substs: vec![self_ty, arg_ty].into() };\n+    let trait_ref = TraitRef {\n+        trait_,\n+        substs: Substs::build_for_def(db, trait_).push(self_ty).push(arg_ty).build(),\n+    };\n \n     let output_ty_id = fn_once_trait.associated_type_by_name(db, &crate::name::OUTPUT_TYPE)?;\n "}]}