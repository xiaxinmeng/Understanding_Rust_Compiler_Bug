{"sha": "19d100278d9609c389780e2692dddaeb45fba301", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ZDEwMDI3OGQ5NjA5YzM4OTc4MGUyNjkyZGRkYWViNDVmYmEzMDE=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-21T19:00:30Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-05T17:48:19Z"}, "message": "Fix failures to resolve primitives\n\nPreviously, when looking for the associated items for primitives,\nrustdoc would look for primitives in the current namespace.\nBut all primitives are in the type namespace. To fix this, rustdoc now\nalways looks for primitives in the namespace when considering them as a\nstepping stone to the associated item.\n\nHowever, fixing that bug caused several duplicate errors because rustdoc\nnow reports the same error in each namespace. To avoid this, rustdoc now\nignores all duplicate errors when issuing them.", "tree": {"sha": "1bbeef2e0f4c13c85a2c65da58b8d5eb0c5e433e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bbeef2e0f4c13c85a2c65da58b8d5eb0c5e433e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19d100278d9609c389780e2692dddaeb45fba301", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19d100278d9609c389780e2692dddaeb45fba301", "html_url": "https://github.com/rust-lang/rust/commit/19d100278d9609c389780e2692dddaeb45fba301", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19d100278d9609c389780e2692dddaeb45fba301/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2d69f2eb115b0b6a433977ae7c5a73c249a4f98", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d69f2eb115b0b6a433977ae7c5a73c249a4f98", "html_url": "https://github.com/rust-lang/rust/commit/e2d69f2eb115b0b6a433977ae7c5a73c249a4f98"}], "stats": {"total": 20, "additions": 15, "deletions": 5}, "files": [{"sha": "9a88c8eb42ad6a55fd515a63f66ed42459e7e89b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19d100278d9609c389780e2692dddaeb45fba301/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19d100278d9609c389780e2692dddaeb45fba301/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=19d100278d9609c389780e2692dddaeb45fba301", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     ErrorKind::Resolve(ResolutionFailure::NotInScope(item_name.to_string().into()))\n                 })?;\n \n-            if let Some((path, prim)) = is_primitive(&path_root, ns) {\n+            if let Some((path, prim)) = is_primitive(&path_root, TypeNS) {\n                 let impls = primitive_impl(cx, &path).ok_or_else(|| {\n                     ErrorKind::Resolve(ResolutionFailure::NoPrimitiveImpl(prim, path_root.into()))\n                 })?;\n@@ -355,6 +355,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         return Ok(link);\n                     }\n                 }\n+                debug!(\n+                    \"returning primitive error for {}::{} in {} namespace\",\n+                    path,\n+                    item_name,\n+                    ns.descr()\n+                );\n                 return Err(ErrorKind::Resolve(ResolutionFailure::NoPrimitiveAssocItem {\n                     res: prim,\n                     prim_name: path,\n@@ -1404,7 +1410,6 @@ fn resolution_failure(\n         &link_range,\n         |diag, sp| {\n             let in_scope = kinds.iter().any(|kind| kind.res().is_some());\n-            let mut reported_not_in_scope = false;\n             let item = |res: Res| {\n                 format!(\"the {} `{}`\", res.descr(), cx.tcx.item_name(res.def_id()).to_string())\n             };\n@@ -1419,14 +1424,19 @@ fn resolution_failure(\n                 );\n                 diag.note(&note);\n             };\n+            // ignore duplicates\n+            let mut variants_seen = SmallVec::<[_; 3]>::new();\n             for failure in kinds {\n+                let variant = std::mem::discriminant(&failure);\n+                if variants_seen.contains(&variant) {\n+                    continue;\n+                }\n+                variants_seen.push(variant);\n                 match failure {\n-                    // already handled above\n                     ResolutionFailure::NotInScope(base) => {\n-                        if in_scope || reported_not_in_scope {\n+                        if in_scope {\n                             continue;\n                         }\n-                        reported_not_in_scope = true;\n                         diag.note(&format!(\"no item named `{}` is in scope\", base));\n                         diag.help(r#\"to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\"#);\n                     }"}]}