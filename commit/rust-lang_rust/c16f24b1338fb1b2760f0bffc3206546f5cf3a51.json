{"sha": "c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNmYyNGIxMzM4ZmIxYjI3NjBmMGJmZmMzMjA2NTQ2ZjVjZjNhNTE=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-06-05T21:40:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-05T21:40:01Z"}, "message": "Merge pull request #177 from RalfJung/drop-glue\n\nremove our array drop glue and use rustc's instead", "tree": {"sha": "9a985bf39cee4f7bdfe001f7ff173318858d962a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a985bf39cee4f7bdfe001f7ff173318858d962a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "html_url": "https://github.com/rust-lang/rust/commit/c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14848b3badb64bf0c9eab43eb87ce07d61f8a4d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/14848b3badb64bf0c9eab43eb87ce07d61f8a4d2", "html_url": "https://github.com/rust-lang/rust/commit/14848b3badb64bf0c9eab43eb87ce07d61f8a4d2"}, {"sha": "1b5f77e4c1520853816e4a40e92ac049833d031b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5f77e4c1520853816e4a40e92ac049833d031b", "html_url": "https://github.com/rust-lang/rust/commit/1b5f77e4c1520853816e4a40e92ac049833d031b"}], "stats": {"total": 504, "additions": 174, "deletions": 330}, "files": [{"sha": "142d90f8dc4d39dddbc36e7ddc72191294a2326e", "filename": "src/eval_context.rs", "status": "modified", "additions": 10, "deletions": 182, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -4,7 +4,6 @@ use std::fmt::Write;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_math::{ConstInt, ConstUsize};\n use rustc::mir;\n use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size};\n@@ -15,7 +14,6 @@ use rustc_data_structures::indexed_vec::Idx;\n use syntax::codemap::{self, DUMMY_SP, Span};\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::symbol::Symbol;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n@@ -43,9 +41,6 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n     pub(crate) steps_remaining: u64,\n-\n-    /// Drop glue for arrays and slices\n-    pub(crate) seq_drop_glue: &'tcx mir::Mir<'tcx>,\n }\n \n /// A stack frame.\n@@ -127,188 +122,13 @@ impl Default for ResourceLimits {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, limits: ResourceLimits) -> Self {\n-        // Register array drop glue code\n-        let source_info = mir::SourceInfo {\n-            span: DUMMY_SP,\n-            scope: mir::ARGUMENT_VISIBILITY_SCOPE\n-        };\n-        // i = 0; len = Len(*a0); goto head;\n-        let start_block = mir::BasicBlockData {\n-            statements: vec![\n-                mir::Statement {\n-                    source_info,\n-                    kind: mir::StatementKind::Assign(\n-                        mir::Lvalue::Local(mir::Local::new(2)),\n-                        mir::Rvalue::Use(mir::Operand::Constant(Box::new(mir::Constant {\n-                            span: DUMMY_SP,\n-                            ty: tcx.types.usize,\n-                            literal: mir::Literal::Value {\n-                                value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(0, tcx.sess.target.uint_type).unwrap())),\n-                            },\n-                        })))\n-                    )\n-                },\n-                mir::Statement {\n-                    source_info,\n-                    kind: mir::StatementKind::Assign(\n-                        mir::Lvalue::Local(mir::Local::new(3)),\n-                        mir::Rvalue::Len(mir::Lvalue::Projection(Box::new(mir::LvalueProjection {\n-                            base: mir::Lvalue::Local(mir::Local::new(1)),\n-                            elem: mir::ProjectionElem::Deref,\n-                        }))),\n-                    )\n-                },\n-            ],\n-            terminator: Some(mir::Terminator {\n-                source_info: source_info,\n-                kind: mir::TerminatorKind::Goto { target: mir::BasicBlock::new(1) },\n-            }),\n-            is_cleanup: false\n-        };\n-        // head: done = i == len; switch done { 1 => ret, 0 => loop }\n-        let head = mir::BasicBlockData {\n-            statements: vec![\n-                mir::Statement {\n-                    source_info,\n-                    kind: mir::StatementKind::Assign(\n-                        mir::Lvalue::Local(mir::Local::new(4)),\n-                        mir::Rvalue::BinaryOp(\n-                            mir::BinOp::Eq,\n-                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n-                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(3))),\n-                        )\n-                    )\n-                },\n-            ],\n-            terminator: Some(mir::Terminator {\n-                source_info: source_info,\n-                kind: mir::TerminatorKind::SwitchInt {\n-                    targets: vec![\n-                        mir::BasicBlock::new(2),\n-                        mir::BasicBlock::new(4),\n-                    ],\n-                    discr: mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(4))),\n-                    switch_ty: tcx.types.bool,\n-                    values: vec![ConstInt::U8(0)].into(),\n-                },\n-            }),\n-            is_cleanup: false\n-        };\n-        // loop: drop (*a0)[i]; goto inc;\n-        let loop_ = mir::BasicBlockData {\n-            statements: Vec::new(),\n-            terminator: Some(mir::Terminator {\n-                source_info: source_info,\n-                kind: mir::TerminatorKind::Drop {\n-                    target: mir::BasicBlock::new(3),\n-                    unwind: None,\n-                    location: mir::Lvalue::Projection(Box::new(\n-                        mir::LvalueProjection {\n-                            base: mir::Lvalue::Projection(Box::new(\n-                                mir::LvalueProjection {\n-                                    base: mir::Lvalue::Local(mir::Local::new(1)),\n-                                    elem: mir::ProjectionElem::Deref,\n-                                }\n-                            )),\n-                            elem: mir::ProjectionElem::Index(mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2)))),\n-                        }\n-                    )),\n-                },\n-            }),\n-            is_cleanup: false\n-        };\n-        // inc: i++; goto head;\n-        let inc = mir::BasicBlockData {\n-            statements: vec![\n-                mir::Statement {\n-                    source_info,\n-                    kind: mir::StatementKind::Assign(\n-                        mir::Lvalue::Local(mir::Local::new(2)),\n-                        mir::Rvalue::BinaryOp(\n-                            mir::BinOp::Add,\n-                            mir::Operand::Consume(mir::Lvalue::Local(mir::Local::new(2))),\n-                            mir::Operand::Constant(Box::new(mir::Constant {\n-                                span: DUMMY_SP,\n-                                ty: tcx.types.usize,\n-                                literal: mir::Literal::Value {\n-                                    value: ConstVal::Integral(ConstInt::Usize(ConstUsize::new(1, tcx.sess.target.uint_type).unwrap())),\n-                                },\n-                            })),\n-                        )\n-                    )\n-                },\n-            ],\n-            terminator: Some(mir::Terminator {\n-                source_info: source_info,\n-                kind: mir::TerminatorKind::Goto { target: mir::BasicBlock::new(1) },\n-            }),\n-            is_cleanup: false\n-        };\n-        // ret: return;\n-        let ret = mir::BasicBlockData {\n-            statements: Vec::new(),\n-            terminator: Some(mir::Terminator {\n-                source_info: source_info,\n-                kind: mir::TerminatorKind::Return,\n-            }),\n-            is_cleanup: false\n-        };\n-        let locals = vec![\n-            mir::LocalDecl {\n-                mutability: mir::Mutability::Mut,\n-                ty: tcx.mk_nil(),\n-                name: None,\n-                source_info,\n-                is_user_variable: false,\n-            },\n-            mir::LocalDecl {\n-                mutability: mir::Mutability::Mut,\n-                ty: tcx.mk_mut_ptr(tcx.mk_slice(tcx.mk_param(0, Symbol::intern(\"T\")))),\n-                name: None,\n-                source_info,\n-                is_user_variable: false,\n-            },\n-            mir::LocalDecl {\n-                mutability: mir::Mutability::Mut,\n-                ty: tcx.types.usize,\n-                name: None,\n-                source_info,\n-                is_user_variable: false,\n-            },\n-            mir::LocalDecl {\n-                mutability: mir::Mutability::Mut,\n-                ty: tcx.types.usize,\n-                name: None,\n-                source_info,\n-                is_user_variable: false,\n-            },\n-            mir::LocalDecl {\n-                mutability: mir::Mutability::Mut,\n-                ty: tcx.types.bool,\n-                name: None,\n-                source_info,\n-                is_user_variable: false,\n-            },\n-        ];\n-        let seq_drop_glue = mir::Mir::new(\n-            vec![start_block, head, loop_, inc, ret].into_iter().collect(),\n-            Vec::new().into_iter().collect(), // vis scopes\n-            Vec::new().into_iter().collect(), // promoted\n-            tcx.mk_nil(), // return type\n-            locals.into_iter().collect(),\n-            1, // arg_count\n-            Vec::new(), // upvars\n-            DUMMY_SP,\n-        );\n-        let seq_drop_glue = tcx.alloc_mir(seq_drop_glue);\n         EvalContext {\n             tcx,\n             memory: Memory::new(&tcx.data_layout, limits.memory_size),\n             globals: HashMap::new(),\n             stack: Vec::new(),\n             stack_limit: limits.stack_limit,\n             steps_remaining: limits.step_limit,\n-            seq_drop_glue: seq_drop_glue,\n         }\n     }\n \n@@ -823,8 +643,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_primval(dest, PrimVal::Ptr(ptr), dest_ty)?;\n             }\n \n-            NullaryOp(mir::NullOp::SizeOf, _ty) => {\n-                unimplemented!()\n+            NullaryOp(mir::NullOp::SizeOf, ty) => {\n+                let size = self.type_size(ty)?.expect(\"SizeOf nullary MIR operator called for unsized type\");\n+                self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n@@ -1020,6 +841,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n+    pub(super) fn pointer_offset(&self, ptr: Pointer, pointee_ty: Ty<'tcx>, offset: i64) -> EvalResult<'tcx, Pointer> {\n+        // FIXME: assuming here that type size is < i64::max_value()\n+        let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n+        // FIXME: Check overflow, out-of-bounds\n+        Ok(ptr.signed_offset(offset * pointee_size))\n+    }\n+\n     pub(super) fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         let value = self.eval_operand(op)?;\n         let ty = self.operand_ty(op);"}, {"sha": "1d796d254d78464a0e2d1739bda1affbfbf9cbe6", "filename": "src/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let n_ptr = self.eval_operand(operand)?;\n                 let usize = self.tcx.types.usize;\n                 let n = self.value_to_primval(n_ptr, usize)?.to_u64()?;\n-                assert!(n < len);\n+                assert!(n < len, \"Tried to access element {} of array/slice with length {}\", n, len);\n                 let ptr = base_ptr.offset(n * elem_size);\n                 (ptr, LvalueExtra::None)\n             }"}, {"sha": "0109cddb5736e5e17a7d14db93ba0428d5114b22", "filename": "src/operator.rs", "status": "modified", "additions": 122, "deletions": 102, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::ty::Ty;\n+use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n@@ -25,11 +25,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         let left_ty    = self.operand_ty(left);\n         let right_ty   = self.operand_ty(right);\n-        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n-        let right_kind = self.ty_to_primval_kind(right_ty)?;\n         let left_val   = self.eval_operand_to_primval(left)?;\n         let right_val  = self.eval_operand_to_primval(right)?;\n-        binary_op(op, left_val, left_kind, right_val, right_kind)\n+        self.binary_op(op, left_val, left_ty, right_val, right_ty)\n     }\n \n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n@@ -132,119 +130,141 @@ macro_rules! f64_arithmetic {\n     )\n }\n \n-/// Returns the result of the specified operation and whether it overflowed.\n-pub fn binary_op<'tcx>(\n-    bin_op: mir::BinOp,\n-    left: PrimVal,\n-    left_kind: PrimValKind,\n-    right: PrimVal,\n-    right_kind: PrimValKind,\n-) -> EvalResult<'tcx, (PrimVal, bool)> {\n-    use rustc::mir::BinOp::*;\n-    use value::PrimValKind::*;\n-\n-    // FIXME(solson): Temporary hack. It will go away when we get rid of Pointer's ability to store\n-    // plain bytes, and leave that to PrimVal::Bytes.\n-    fn normalize(val: PrimVal) -> PrimVal {\n-        if let PrimVal::Ptr(ptr) = val {\n-            if let Ok(bytes) = ptr.to_int() {\n-                return PrimVal::Bytes(bytes as u128);\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+    /// Returns the result of the specified operation and whether it overflowed.\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: PrimVal,\n+        left_ty: Ty<'tcx>,\n+        right: PrimVal,\n+        right_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, (PrimVal, bool)> {\n+        use rustc::mir::BinOp::*;\n+        use value::PrimValKind::*;\n+\n+        // FIXME(solson): Temporary hack. It will go away when we get rid of Pointer's ability to store\n+        // plain bytes, and leave that to PrimVal::Bytes.\n+        fn normalize(val: PrimVal) -> PrimVal {\n+            if let PrimVal::Ptr(ptr) = val {\n+                if let Ok(bytes) = ptr.to_int() {\n+                    return PrimVal::Bytes(bytes as u128);\n+                }\n             }\n+            val\n         }\n-        val\n-    }\n-    let (left, right) = (normalize(left), normalize(right));\n+        let (left, right) = (normalize(left), normalize(right));\n \n-    let (l, r) = match (left, right) {\n-        (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n-\n-        (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n-            if left_ptr.alloc_id == right_ptr.alloc_id {\n-                // If the pointers are into the same allocation, fall through to the more general\n-                // match later, which will do comparisons on the pointer offsets.\n-                (left_ptr.offset as u128, right_ptr.offset as u128)\n-            } else {\n-                return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n-            }\n+        // Offset is handled early, before we dispatch to unrelated_ptr_ops.  We have to also catch the case where both arguments *are* convertible to integers.\n+        if bin_op == Offset {\n+            let pointee_ty = left_ty.builtin_deref(true, ty::LvaluePreference::NoPreference).expect(\"Offset called on non-ptr type\").ty;\n+            let ptr = self.pointer_offset(left.to_ptr()?, pointee_ty, right.to_bytes()? as i64)?;\n+            return Ok((PrimVal::Ptr(ptr), false));\n         }\n \n-        (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n-        (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n-            return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n-        }\n+        let (l, r) = match (left, right) {\n+            (PrimVal::Bytes(left_bytes), PrimVal::Bytes(right_bytes)) => (left_bytes, right_bytes),\n+\n+            (PrimVal::Ptr(left_ptr), PrimVal::Ptr(right_ptr)) => {\n+                if left_ptr.alloc_id == right_ptr.alloc_id {\n+                    // If the pointers are into the same allocation, fall through to the more general\n+                    // match later, which will do comparisons on the pointer offsets.\n+                    (left_ptr.offset as u128, right_ptr.offset as u128)\n+                } else {\n+                    return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n+                }\n+            }\n \n-        (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n-    };\n+            (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n+            (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n+                return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n+            }\n \n-    // These ops can have an RHS with a different numeric type.\n-    if bin_op == Shl || bin_op == Shr {\n-        return match bin_op {\n-            Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n-            Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n-            _ => bug!(\"it has already been checked that this is a shift op\"),\n+            (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n         };\n-    }\n \n-    if left_kind != right_kind {\n-        let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n-        return Err(EvalError::Unimplemented(msg));\n-    }\n+        let left_kind  = self.ty_to_primval_kind(left_ty)?;\n+        let right_kind = self.ty_to_primval_kind(right_ty)?;\n \n-    let val = match (bin_op, left_kind) {\n-        (Eq, F32) => PrimVal::from_bool(bytes_to_f32(l) == bytes_to_f32(r)),\n-        (Ne, F32) => PrimVal::from_bool(bytes_to_f32(l) != bytes_to_f32(r)),\n-        (Lt, F32) => PrimVal::from_bool(bytes_to_f32(l) <  bytes_to_f32(r)),\n-        (Le, F32) => PrimVal::from_bool(bytes_to_f32(l) <= bytes_to_f32(r)),\n-        (Gt, F32) => PrimVal::from_bool(bytes_to_f32(l) >  bytes_to_f32(r)),\n-        (Ge, F32) => PrimVal::from_bool(bytes_to_f32(l) >= bytes_to_f32(r)),\n-\n-        (Eq, F64) => PrimVal::from_bool(bytes_to_f64(l) == bytes_to_f64(r)),\n-        (Ne, F64) => PrimVal::from_bool(bytes_to_f64(l) != bytes_to_f64(r)),\n-        (Lt, F64) => PrimVal::from_bool(bytes_to_f64(l) <  bytes_to_f64(r)),\n-        (Le, F64) => PrimVal::from_bool(bytes_to_f64(l) <= bytes_to_f64(r)),\n-        (Gt, F64) => PrimVal::from_bool(bytes_to_f64(l) >  bytes_to_f64(r)),\n-        (Ge, F64) => PrimVal::from_bool(bytes_to_f64(l) >= bytes_to_f64(r)),\n-\n-        (Add, F32) => f32_arithmetic!(+, l, r),\n-        (Sub, F32) => f32_arithmetic!(-, l, r),\n-        (Mul, F32) => f32_arithmetic!(*, l, r),\n-        (Div, F32) => f32_arithmetic!(/, l, r),\n-        (Rem, F32) => f32_arithmetic!(%, l, r),\n-\n-        (Add, F64) => f64_arithmetic!(+, l, r),\n-        (Sub, F64) => f64_arithmetic!(-, l, r),\n-        (Mul, F64) => f64_arithmetic!(*, l, r),\n-        (Div, F64) => f64_arithmetic!(/, l, r),\n-        (Rem, F64) => f64_arithmetic!(%, l, r),\n-\n-        (Eq, _) => PrimVal::from_bool(l == r),\n-        (Ne, _) => PrimVal::from_bool(l != r),\n-        (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n-        (Lt, _) => PrimVal::from_bool(l <  r),\n-        (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n-        (Le, _) => PrimVal::from_bool(l <= r),\n-        (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n-        (Gt, _) => PrimVal::from_bool(l >  r),\n-        (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n-        (Ge, _) => PrimVal::from_bool(l >= r),\n-\n-        (BitOr,  _) => PrimVal::Bytes(l | r),\n-        (BitAnd, _) => PrimVal::Bytes(l & r),\n-        (BitXor, _) => PrimVal::Bytes(l ^ r),\n-\n-        (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n-        (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n-        (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n-        (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n-        (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+        // These ops can have an RHS with a different numeric type.\n+        if bin_op == Shl || bin_op == Shr {\n+            return match bin_op {\n+                Shl => int_shift!(left_kind, overflowing_shl, l, r as u32),\n+                Shr => int_shift!(left_kind, overflowing_shr, l, r as u32),\n+                _ => bug!(\"it has already been checked that this is a shift op\"),\n+            };\n+        }\n+        if bin_op == Offset {\n+            // We permit offset-by-0 in any case.  Drop glue actually does this, and it's probably (TM) fine for LLVM.\n+            if left_kind == PrimValKind::Ptr && right_kind.is_int() && r == 0 {\n+                return Ok((PrimVal::Bytes(l), false));\n+            } else {\n+                let msg = format!(\"unimplemented Offset: {:?}, {:?}\", left, right);\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n+        }\n \n-        _ => {\n+        if left_kind != right_kind {\n             let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n             return Err(EvalError::Unimplemented(msg));\n         }\n-    };\n \n-    Ok((val, false))\n+        let val = match (bin_op, left_kind) {\n+            (Eq, F32) => PrimVal::from_bool(bytes_to_f32(l) == bytes_to_f32(r)),\n+            (Ne, F32) => PrimVal::from_bool(bytes_to_f32(l) != bytes_to_f32(r)),\n+            (Lt, F32) => PrimVal::from_bool(bytes_to_f32(l) <  bytes_to_f32(r)),\n+            (Le, F32) => PrimVal::from_bool(bytes_to_f32(l) <= bytes_to_f32(r)),\n+            (Gt, F32) => PrimVal::from_bool(bytes_to_f32(l) >  bytes_to_f32(r)),\n+            (Ge, F32) => PrimVal::from_bool(bytes_to_f32(l) >= bytes_to_f32(r)),\n+\n+            (Eq, F64) => PrimVal::from_bool(bytes_to_f64(l) == bytes_to_f64(r)),\n+            (Ne, F64) => PrimVal::from_bool(bytes_to_f64(l) != bytes_to_f64(r)),\n+            (Lt, F64) => PrimVal::from_bool(bytes_to_f64(l) <  bytes_to_f64(r)),\n+            (Le, F64) => PrimVal::from_bool(bytes_to_f64(l) <= bytes_to_f64(r)),\n+            (Gt, F64) => PrimVal::from_bool(bytes_to_f64(l) >  bytes_to_f64(r)),\n+            (Ge, F64) => PrimVal::from_bool(bytes_to_f64(l) >= bytes_to_f64(r)),\n+\n+            (Add, F32) => f32_arithmetic!(+, l, r),\n+            (Sub, F32) => f32_arithmetic!(-, l, r),\n+            (Mul, F32) => f32_arithmetic!(*, l, r),\n+            (Div, F32) => f32_arithmetic!(/, l, r),\n+            (Rem, F32) => f32_arithmetic!(%, l, r),\n+\n+            (Add, F64) => f64_arithmetic!(+, l, r),\n+            (Sub, F64) => f64_arithmetic!(-, l, r),\n+            (Mul, F64) => f64_arithmetic!(*, l, r),\n+            (Div, F64) => f64_arithmetic!(/, l, r),\n+            (Rem, F64) => f64_arithmetic!(%, l, r),\n+\n+            (Eq, _) => PrimVal::from_bool(l == r),\n+            (Ne, _) => PrimVal::from_bool(l != r),\n+            (Lt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) < (r as i128)),\n+            (Lt, _) => PrimVal::from_bool(l <  r),\n+            (Le, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) <= (r as i128)),\n+            (Le, _) => PrimVal::from_bool(l <= r),\n+            (Gt, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) > (r as i128)),\n+            (Gt, _) => PrimVal::from_bool(l >  r),\n+            (Ge, k) if k.is_signed_int() => PrimVal::from_bool((l as i128) >= (r as i128)),\n+            (Ge, _) => PrimVal::from_bool(l >= r),\n+\n+            (BitOr,  _) => PrimVal::Bytes(l | r),\n+            (BitAnd, _) => PrimVal::Bytes(l & r),\n+            (BitXor, _) => PrimVal::Bytes(l ^ r),\n+\n+            (Add, k) if k.is_int() => return int_arithmetic!(k, overflowing_add, l, r),\n+            (Sub, k) if k.is_int() => return int_arithmetic!(k, overflowing_sub, l, r),\n+            (Mul, k) if k.is_int() => return int_arithmetic!(k, overflowing_mul, l, r),\n+            (Div, k) if k.is_int() => return int_arithmetic!(k, overflowing_div, l, r),\n+            (Rem, k) if k.is_int() => return int_arithmetic!(k, overflowing_rem, l, r),\n+\n+            _ => {\n+                let msg = format!(\"unimplemented binary op: {:?}, {:?}, {:?}\", left, right, bin_op);\n+                return Err(EvalError::Unimplemented(msg));\n+            }\n+        };\n+\n+        Ok((val, false))\n+    }\n }\n \n fn unrelated_ptr_ops<'tcx>(bin_op: mir::BinOp, left: Pointer, right: Pointer) -> EvalResult<'tcx, PrimVal> {"}, {"sha": "776061954251c59c5f1467aa5df47edf2ce09d7e", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -1,6 +1,5 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::Kind;\n use syntax::codemap::Span;\n \n use error::EvalResult;\n@@ -21,7 +20,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         };\n         self.drop(val, instance, ty, span)\n     }\n-    pub(crate) fn drop(&mut self, mut arg: Value, mut instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n+    pub(crate) fn drop(&mut self, arg: Value, mut instance: ty::Instance<'tcx>, ty: Ty<'tcx>, span: Span) -> EvalResult<'tcx> {\n         trace!(\"drop: {:#?}, {:?}, {:?}\", arg, ty.sty, instance.def);\n \n         if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n@@ -44,23 +43,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     None => return Ok(()),\n                 }\n             },\n-            ty::TyArray(elem, n) => {\n-                instance.substs = self.tcx.mk_substs([\n-                    Kind::from(elem),\n-                ].iter().cloned());\n-                let ptr = match arg {\n-                    Value::ByVal(PrimVal::Ptr(src_ptr)) => src_ptr,\n-                    _ => bug!(\"expected thin ptr, got {:?}\", arg),\n-                };\n-                arg = Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::Bytes(n as u128));\n-                self.seq_drop_glue\n-            },\n-            ty::TySlice(elem) => {\n-                instance.substs = self.tcx.mk_substs([\n-                    Kind::from(elem),\n-                ].iter().cloned());\n-                self.seq_drop_glue\n-            },\n             _ => self.load_mir(instance.def)?,\n         };\n "}, {"sha": "843a5b06b6a0420be6c6754c3f07fd0aa9c16300", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -7,7 +7,6 @@ use rustc::ty::{self, Ty};\n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::{Lvalue, LvalueExtra};\n-use operator;\n use value::{PrimVal, PrimValKind, Value};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -103,8 +102,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByRef(_) => bug!(\"just read the value, can't be byref\"),\n                     Value::ByValPair(..) => bug!(\"atomic_cxchg doesn't work with nonprimitives\"),\n                 };\n-                let kind = self.ty_to_primval_kind(ty)?;\n-                let (val, _) = operator::binary_op(mir::BinOp::Eq, old, kind, expect_old, kind)?;\n+                let (val, _) = self.binary_op(mir::BinOp::Eq, old, ty, expect_old, ty)?;\n                 let dest = self.force_allocation(dest)?.to_ptr();\n                 self.write_pair_to_ptr(old, val, dest, dest_ty)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), change, ty)?;\n@@ -125,7 +123,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Value::ByValPair(..) => bug!(\"atomic_xadd_relaxed doesn't work with nonprimitives\"),\n                 };\n                 self.write_primval(dest, old, ty)?;\n-                let kind = self.ty_to_primval_kind(ty)?;\n                 let op = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => mir::BinOp::BitOr,\n                     \"xor\" => mir::BinOp::BitXor,\n@@ -135,7 +132,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => bug!(),\n                 };\n                 // FIXME: what do atomics do on overflow?\n-                let (val, _) = operator::binary_op(op, old, kind, change, kind)?;\n+                let (val, _) = self.binary_op(op, old, ty, change, ty)?;\n                 self.write_primval(Lvalue::from_ptr(ptr), val, ty)?;\n             },\n \n@@ -219,7 +216,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n                 let ty = substs.type_at(0);\n-                let kind = self.ty_to_primval_kind(ty)?;\n                 let a = self.value_to_primval(arg_vals[0], ty)?;\n                 let b = self.value_to_primval(arg_vals[1], ty)?;\n                 let op = match intrinsic_name {\n@@ -230,7 +226,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     \"frem_fast\" => mir::BinOp::Rem,\n                     _ => bug!(),\n                 };\n-                let result = operator::binary_op(op, a, kind, b, kind)?;\n+                let result = self.binary_op(op, a, ty, b, ty)?;\n                 self.write_primval(dest, result.0, dest_ty)?;\n             }\n \n@@ -298,13 +294,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"offset\" => {\n-                let pointee_ty = substs.type_at(0);\n-                // FIXME: assuming here that type size is < i64::max_value()\n-                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n-\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let result_ptr = ptr.signed_offset(offset * pointee_size);\n+                let result_ptr = self.pointer_offset(ptr, substs.type_at(0), offset)?;\n                 self.write_primval(dest, PrimVal::Ptr(result_ptr), dest_ty)?;\n             }\n \n@@ -360,11 +352,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n-                // FIXME: change the `box_free` lang item to take `T: ?Sized` and have it use the\n-                // `size_of_val` intrinsic, then change this back to\n-                // .expect(\"size_of intrinsic called on unsized value\")\n-                // see https://github.com/rust-lang/rust/pull/37708\n-                let size = self.type_size(ty)?.unwrap_or(!0) as u128;\n+                let size = self.type_size(ty)?.expect(\"size_of intrinsic called on unsized value\") as u128;\n                 self.write_primval(dest, PrimVal::from_u128(size), dest_ty)?;\n             }\n "}, {"sha": "c2131d6627edde55e7c2f5c5c2dba4bc1be325e2", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, TypeVariants, Ty, TypeAndMut};\n+use rustc::ty::{self, TypeVariants, Ty};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::attr;\n@@ -730,12 +730,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dtor = if dtor_ptr.is_null_ptr() { None } else { Some(self.memory.get_fn(dtor_ptr.alloc_id)?) };\n \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n-                let key_size = match self.operand_ty(&arg_operands[0]).sty {\n-                    TypeVariants::TyRawPtr(TypeAndMut { ty, .. }) => {\n-                        let layout = self.type_layout(ty)?;\n-                        layout.size(&self.tcx.data_layout)\n-                    }\n-                    _ => return Err(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))\n+                let key_type = self.operand_ty(&arg_operands[0]).builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                                   .ok_or(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))?.ty;\n+                let key_size = {\n+                    let layout = self.type_layout(key_type)?;\n+                    layout.size(&self.tcx.data_layout)\n                 };\n \n                 // Create key and write it into the memory where key_ptr wants it"}, {"sha": "c9b59f635e14506815a4d8f410b6d5fb47f5326e", "filename": "tests/run-pass/call_drop_on_array_elements.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_array_elements.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -1,16 +1,22 @@\n-struct Bar;\n+struct Bar(u16); // ZSTs are tested separately\n \n static mut DROP_COUNT: usize = 0;\n \n impl Drop for Bar {\n     fn drop(&mut self) {\n+        assert_eq!(self.0 as usize, unsafe { DROP_COUNT }); // tests whether we are called at a valid address\n         unsafe { DROP_COUNT += 1; }\n     }\n }\n \n fn main() {\n-    let b = [Bar, Bar, Bar, Bar];\n+    let b = [Bar(0), Bar(1), Bar(2), Bar(3)];\n     assert_eq!(unsafe { DROP_COUNT }, 0);\n     drop(b);\n     assert_eq!(unsafe { DROP_COUNT }, 4);\n+\n+    // check empty case\n+    let b : [Bar; 0] = [];\n+    drop(b);\n+    assert_eq!(unsafe { DROP_COUNT }, 4);\n }"}, {"sha": "1887130fdd8a4704b64990e5228e8c03ef0dd67f", "filename": "tests/run-pass/call_drop_on_zst_array_elements.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/tests%2Frun-pass%2Fcall_drop_on_zst_array_elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16f24b1338fb1b2760f0bffc3206546f5cf3a51/tests%2Frun-pass%2Fcall_drop_on_zst_array_elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcall_drop_on_zst_array_elements.rs?ref=c16f24b1338fb1b2760f0bffc3206546f5cf3a51", "patch": "@@ -0,0 +1,21 @@\n+struct Bar;\n+\n+static mut DROP_COUNT: usize = 0;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        unsafe { DROP_COUNT += 1; }\n+    }\n+}\n+\n+fn main() {\n+    let b = [Bar, Bar, Bar, Bar];\n+    assert_eq!(unsafe { DROP_COUNT }, 0);\n+    drop(b);\n+    assert_eq!(unsafe { DROP_COUNT }, 4);\n+\n+    // check empty case\n+    let b : [Bar; 0] = [];\n+    drop(b);\n+    assert_eq!(unsafe { DROP_COUNT }, 4);\n+}"}]}