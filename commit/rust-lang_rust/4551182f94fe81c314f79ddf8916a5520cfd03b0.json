{"sha": "4551182f94fe81c314f79ddf8916a5520cfd03b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NTExODJmOTRmZTgxYzMxNGY3OWRkZjg5MTZhNTUyMGNmZDAzYjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-16T23:54:22Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-09-17T12:51:48Z"}, "message": "use usual token tree for macro expansion", "tree": {"sha": "e6c7b46cabe1f10f7da28f3db209df2260045fa8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6c7b46cabe1f10f7da28f3db209df2260045fa8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4551182f94fe81c314f79ddf8916a5520cfd03b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4551182f94fe81c314f79ddf8916a5520cfd03b0", "html_url": "https://github.com/rust-lang/rust/commit/4551182f94fe81c314f79ddf8916a5520cfd03b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4551182f94fe81c314f79ddf8916a5520cfd03b0/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ef8927c373b8eadd63edc1f70055428c49290e", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ef8927c373b8eadd63edc1f70055428c49290e", "html_url": "https://github.com/rust-lang/rust/commit/37ef8927c373b8eadd63edc1f70055428c49290e"}], "stats": {"total": 1686, "additions": 753, "deletions": 933}, "files": [{"sha": "41720df79f56e8e0e456c10a253cf76e4d59e6c3", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 61, "deletions": 96, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -3,30 +3,19 @@\n /// interface, although it contains some code to bridge `SyntaxNode`s and\n /// `TokenTree`s as well!\n \n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident), *) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-mod mbe_parser;\n+mod parser;\n mod mbe_expander;\n mod syntax_bridge;\n-mod tt_cursor;\n+mod tt_iter;\n mod subtree_source;\n-mod subtree_parser;\n-\n-use ra_syntax::SmolStr;\n-use smallvec::SmallVec;\n \n pub use tt::{Delimiter, Punct};\n \n+use crate::{\n+    parser::{parse_pattern, Op},\n+    tt_iter::TtIter,\n+};\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum ParseError {\n     Expected(String),\n@@ -38,6 +27,7 @@ pub enum ExpandError {\n     UnexpectedToken,\n     BindingError(String),\n     ConversionError,\n+    InvalidRepeat,\n }\n \n pub use crate::syntax_bridge::{\n@@ -54,97 +44,72 @@ pub struct MacroRules {\n     pub(crate) rules: Vec<Rule>,\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) struct Rule {\n+    pub(crate) lhs: tt::Subtree,\n+    pub(crate) rhs: tt::Subtree,\n+}\n+\n impl MacroRules {\n     pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n-        mbe_parser::parse(tt)\n+        let mut src = TtIter::new(tt);\n+        let mut rules = Vec::new();\n+        while src.len() > 0 {\n+            let rule = Rule::parse(&mut src)?;\n+            rules.push(rule);\n+            if let Err(()) = src.expect_char(';') {\n+                if src.len() > 0 {\n+                    return Err(ParseError::Expected(\"expected `:`\".to_string()));\n+                }\n+                break;\n+            }\n+        }\n+        Ok(MacroRules { rules })\n     }\n     pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n         mbe_expander::expand(self, tt)\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Rule {\n-    pub(crate) lhs: Subtree,\n-    pub(crate) rhs: Subtree,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum TokenTree {\n-    Leaf(Leaf),\n-    Subtree(Subtree),\n-    Repeat(Repeat),\n-}\n-impl_froms!(TokenTree: Leaf, Subtree, Repeat);\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum Leaf {\n-    Literal(Literal),\n-    Punct(Punct),\n-    Ident(Ident),\n-    Var(Var),\n-}\n-impl_froms!(Leaf: Literal, Punct, Ident, Var);\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Subtree {\n-    pub(crate) delimiter: Delimiter,\n-    pub(crate) token_trees: Vec<TokenTree>,\n-}\n-\n-#[derive(Clone, Debug, Eq)]\n-pub(crate) enum Separator {\n-    Literal(tt::Literal),\n-    Ident(tt::Ident),\n-    Puncts(SmallVec<[tt::Punct; 3]>),\n+impl Rule {\n+    fn parse(src: &mut TtIter) -> Result<Rule, ParseError> {\n+        let mut lhs = src\n+            .expect_subtree()\n+            .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?\n+            .clone();\n+        validate(&lhs)?;\n+        lhs.delimiter = tt::Delimiter::None;\n+        src.expect_char('=').map_err(|()| ParseError::Expected(\"expected `=`\".to_string()))?;\n+        src.expect_char('>').map_err(|()| ParseError::Expected(\"expected `>`\".to_string()))?;\n+        let mut rhs = src\n+            .expect_subtree()\n+            .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?\n+            .clone();\n+        rhs.delimiter = tt::Delimiter::None;\n+        Ok(crate::Rule { lhs, rhs })\n+    }\n }\n \n-// Note that when we compare a Separator, we just care about its textual value.\n-impl PartialEq for crate::Separator {\n-    fn eq(&self, other: &crate::Separator) -> bool {\n-        use crate::Separator::*;\n-\n-        match (self, other) {\n-            (Ident(ref a), Ident(ref b)) => a.text == b.text,\n-            (Literal(ref a), Literal(ref b)) => a.text == b.text,\n-            (Puncts(ref a), Puncts(ref b)) if a.len() == b.len() => {\n-                let a_iter = a.iter().map(|a| a.char);\n-                let b_iter = b.iter().map(|b| b.char);\n-                a_iter.eq(b_iter)\n+fn validate(pattern: &tt::Subtree) -> Result<(), ParseError> {\n+    for op in parse_pattern(pattern) {\n+        let op = match op {\n+            Ok(it) => it,\n+            Err(e) => {\n+                let msg = match e {\n+                    ExpandError::InvalidRepeat => \"invalid repeat\".to_string(),\n+                    _ => \"invalid macro definition\".to_string(),\n+                };\n+                return Err(ParseError::Expected(msg));\n+            }\n+        };\n+        match op {\n+            Op::TokenTree(tt::TokenTree::Subtree(subtree)) | Op::Repeat { subtree, .. } => {\n+                validate(subtree)?\n             }\n-            _ => false,\n+            _ => (),\n         }\n     }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Repeat {\n-    pub(crate) subtree: Subtree,\n-    pub(crate) kind: RepeatKind,\n-    pub(crate) separator: Option<Separator>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) enum RepeatKind {\n-    ZeroOrMore,\n-    OneOrMore,\n-    ZeroOrOne,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Literal {\n-    pub(crate) text: SmolStr,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Ident {\n-    pub(crate) text: SmolStr,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct Var {\n-    pub(crate) text: SmolStr,\n-    pub(crate) kind: Option<SmolStr>,\n+    Ok(())\n }\n \n #[cfg(test)]"}, {"sha": "b455b7321b625bec50029ad74bfe9e1b84ec8bbe", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -8,7 +8,6 @@ mod transcriber;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n \n-use crate::tt_cursor::TtCursor;\n use crate::ExpandError;\n \n pub(crate) fn expand(\n@@ -19,12 +18,8 @@ pub(crate) fn expand(\n }\n \n fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n-    let mut input = TtCursor::new(input);\n-    let bindings = matcher::match_lhs(&rule.lhs, &mut input)?;\n-    if !input.is_eof() {\n-        return Err(ExpandError::UnexpectedToken);\n-    }\n-    let res = transcriber::transcribe(&bindings, &rule.rhs)?;\n+    let bindings = matcher::match_(&rule.lhs, input)?;\n+    let res = transcriber::transcribe(&rule.rhs, &bindings)?;\n     Ok(res)\n }\n \n@@ -103,13 +98,6 @@ mod tests {\n \n     #[test]\n     fn test_expand_rule() {\n-        // FIXME: The missing $var check should be in parsing phase\n-        // assert_err(\n-        //     \"($i:ident) => ($j)\",\n-        //     \"foo!{a}\",\n-        //     ExpandError::BindingError(String::from(\"could not find binding `j`\")),\n-        // );\n-\n         assert_err(\n             \"($($i:ident);*) => ($i)\",\n             \"foo!{a}\",\n@@ -118,9 +106,6 @@ mod tests {\n             )),\n         );\n \n-        assert_err(\"($i) => ($i)\", \"foo!{a}\", ExpandError::UnexpectedToken);\n-        assert_err(\"($i:) => ($i)\", \"foo!{a}\", ExpandError::UnexpectedToken);\n-\n         // FIXME:\n         // Add an err test case for ($($i:ident)) => ($())\n     }"}, {"sha": "aff95310292036d616fa868226121bbd04f94324", "filename": "crates/ra_mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 242, "deletions": 119, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -1,11 +1,14 @@\n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n-    tt_cursor::TtCursor,\n+    parser::{parse_pattern, Op, RepeatKind, Separator},\n+    subtree_source::SubtreeTokenSource,\n+    tt_iter::TtIter,\n     ExpandError,\n };\n \n-use ra_parser::FragmentKind::*;\n-use ra_syntax::SmolStr;\n+use ra_parser::{FragmentKind::*, TreeSink};\n+use ra_syntax::{SmolStr, SyntaxKind};\n+use tt::buffer::{Cursor, TokenBuffer};\n \n impl Bindings {\n     fn push_optional(&mut self, name: &SmolStr) {\n@@ -42,121 +45,247 @@ impl Bindings {\n         }\n         Ok(())\n     }\n+}\n \n-    fn merge(&mut self, nested: Bindings) {\n-        self.inner.extend(nested.inner);\n-    }\n+macro_rules! err {\n+    () => {\n+        ExpandError::BindingError(format!(\"\"))\n+    };\n+    ($($tt:tt)*) => {\n+        ExpandError::BindingError(format!($($tt)*))\n+    };\n }\n \n-pub(super) fn match_lhs(\n-    pattern: &crate::Subtree,\n-    input: &mut TtCursor,\n-) -> Result<Bindings, ExpandError> {\n+macro_rules! bail {\n+    ($($tt:tt)*) => {\n+        return Err(err!($($tt)*))\n+    };\n+}\n+\n+pub(super) fn match_(pattern: &tt::Subtree, src: &tt::Subtree) -> Result<Bindings, ExpandError> {\n+    assert!(pattern.delimiter == tt::Delimiter::None);\n+\n     let mut res = Bindings::default();\n-    for pat in pattern.token_trees.iter() {\n-        match pat {\n-            crate::TokenTree::Leaf(leaf) => match leaf {\n-                crate::Leaf::Var(crate::Var { text, kind }) => {\n-                    let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n-                    match match_meta_var(kind.as_str(), input)? {\n-                        Some(fragment) => {\n-                            res.inner.insert(text.clone(), Binding::Fragment(fragment));\n-                        }\n-                        None => res.push_optional(text),\n-                    }\n+    let mut src = TtIter::new(src);\n+\n+    match_subtree(&mut res, pattern, &mut src)?;\n+\n+    if src.len() > 0 {\n+        bail!(\"leftover tokens\");\n+    }\n+\n+    Ok(res)\n+}\n+\n+fn match_subtree(\n+    bindings: &mut Bindings,\n+    pattern: &tt::Subtree,\n+    src: &mut TtIter,\n+) -> Result<(), ExpandError> {\n+    for op in parse_pattern(pattern) {\n+        match op? {\n+            Op::TokenTree(tt::TokenTree::Leaf(lhs)) => {\n+                let rhs = src.expect_leaf().map_err(|()| err!(\"expected leaf: `{}`\", lhs))?;\n+                match (lhs, rhs) {\n+                    (\n+                        tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n+                        tt::Leaf::Punct(tt::Punct { char: rhs, .. }),\n+                    ) if lhs == rhs => (),\n+                    (\n+                        tt::Leaf::Ident(tt::Ident { text: lhs, .. }),\n+                        tt::Leaf::Ident(tt::Ident { text: rhs, .. }),\n+                    ) if lhs == rhs => (),\n+                    (\n+                        tt::Leaf::Literal(tt::Literal { text: lhs, .. }),\n+                        tt::Leaf::Literal(tt::Literal { text: rhs, .. }),\n+                    ) if lhs == rhs => (),\n+                    _ => Err(ExpandError::UnexpectedToken)?,\n                 }\n-                crate::Leaf::Punct(punct) => {\n-                    if !input.eat_punct().map(|p| p.char == punct.char).unwrap_or(false) {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n+            }\n+            Op::TokenTree(tt::TokenTree::Subtree(lhs)) => {\n+                let rhs = src.expect_subtree().map_err(|()| err!(\"expected subtree\"))?;\n+                if lhs.delimiter != rhs.delimiter {\n+                    bail!(\"mismatched delimiter\")\n                 }\n-                crate::Leaf::Ident(ident) => {\n-                    if input.eat_ident().map(|i| &i.text) != Some(&ident.text) {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n+                let mut src = TtIter::new(rhs);\n+                match_subtree(bindings, lhs, &mut src)?;\n+                if src.len() > 0 {\n+                    bail!(\"leftover tokens\");\n                 }\n-                crate::Leaf::Literal(literal) => {\n-                    if input.eat_literal().map(|i| &i.text) != Some(&literal.text) {\n-                        return Err(ExpandError::UnexpectedToken);\n+            }\n+            Op::Var { name, kind } => {\n+                let kind = kind.as_ref().ok_or(ExpandError::UnexpectedToken)?;\n+                match match_meta_var(kind.as_str(), src)? {\n+                    Some(fragment) => {\n+                        bindings.inner.insert(name.clone(), Binding::Fragment(fragment));\n                     }\n+                    None => bindings.push_optional(name),\n                 }\n+                ()\n+            }\n+            Op::Repeat { subtree, kind, separator } => {\n+                match_repeat(bindings, subtree, kind, separator, src)?\n+            }\n+        }\n+    }\n+    Ok(())\n+}\n+\n+impl<'a> TtIter<'a> {\n+    fn eat_separator(&mut self, separator: &Separator) -> bool {\n+        let mut fork = self.clone();\n+        let ok = match separator {\n+            Separator::Ident(lhs) => match fork.expect_ident() {\n+                Ok(rhs) => rhs.text == lhs.text,\n+                _ => false,\n             },\n-            crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n-                // Dirty hack to make macro-expansion terminate.\n-                // This should be replaced by a propper macro-by-example implementation\n-                let mut limit = 65536;\n-                let mut counter = 0;\n-\n-                let mut memento = input.save();\n-\n-                loop {\n-                    match match_lhs(subtree, input) {\n-                        Ok(nested) => {\n-                            limit -= 1;\n-                            if limit == 0 {\n-                                log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", subtree, input, kind, separator);\n-                                break;\n-                            }\n-\n-                            memento = input.save();\n-                            res.push_nested(counter, nested)?;\n-                            counter += 1;\n-                            if counter == 1 {\n-                                if let crate::RepeatKind::ZeroOrOne = kind {\n-                                    break;\n-                                }\n-                            }\n-\n-                            if let Some(separator) = separator {\n-                                if !input\n-                                    .eat_seperator()\n-                                    .map(|sep| sep == *separator)\n-                                    .unwrap_or(false)\n-                                {\n-                                    input.rollback(memento);\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        Err(_) => {\n-                            input.rollback(memento);\n-                            break;\n-                        }\n-                    }\n-                }\n+            Separator::Literal(lhs) => match fork.expect_literal() {\n+                Ok(rhs) => rhs.text == lhs.text,\n+                _ => false,\n+            },\n+            Separator::Puncts(lhss) => lhss.iter().all(|lhs| match fork.expect_punct() {\n+                Ok(rhs) => rhs.char == lhs.char,\n+                _ => false,\n+            }),\n+        };\n+        if ok {\n+            *self = fork;\n+        }\n+        ok\n+    }\n \n-                match kind {\n-                    crate::RepeatKind::OneOrMore if counter == 0 => {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-                    _ if counter == 0 => {\n-                        // Collect all empty variables in subtrees\n-                        collect_vars(subtree).iter().for_each(|s| res.push_empty(s));\n-                    }\n-                    _ => {}\n+    pub(crate) fn expect_lifetime(&mut self) -> Result<&tt::Ident, ()> {\n+        let ident = self.expect_ident()?;\n+        // check if it start from \"`\"\n+        if ident.text.chars().next() != Some('\\'') {\n+            return Err(());\n+        }\n+        Ok(ident)\n+    }\n+\n+    pub(crate) fn expect_fragment(\n+        &mut self,\n+        fragment_kind: ra_parser::FragmentKind,\n+    ) -> Result<tt::TokenTree, ()> {\n+        pub(crate) struct OffsetTokenSink<'a> {\n+            pub(crate) cursor: Cursor<'a>,\n+            pub(crate) error: bool,\n+        }\n+\n+        impl<'a> TreeSink for OffsetTokenSink<'a> {\n+            fn token(&mut self, _kind: SyntaxKind, n_tokens: u8) {\n+                for _ in 0..n_tokens {\n+                    self.cursor = self.cursor.bump_subtree();\n                 }\n             }\n-            crate::TokenTree::Subtree(subtree) => {\n-                let input_subtree =\n-                    input.eat_subtree().map_err(|_| ExpandError::UnexpectedToken)?;\n-                if subtree.delimiter != input_subtree.delimiter {\n-                    return Err(ExpandError::UnexpectedToken);\n+            fn start_node(&mut self, _kind: SyntaxKind) {}\n+            fn finish_node(&mut self) {}\n+            fn error(&mut self, _error: ra_parser::ParseError) {\n+                self.error = true;\n+            }\n+        }\n+\n+        let buffer = TokenBuffer::new(self.inner.as_slice());\n+        let mut src = SubtreeTokenSource::new(&buffer);\n+        let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n+\n+        ra_parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n+\n+        if !sink.cursor.is_root() || sink.error {\n+            return Err(());\n+        }\n+\n+        let mut curr = buffer.begin();\n+        let mut res = vec![];\n+\n+        while curr != sink.cursor {\n+            if let Some(token) = curr.token_tree() {\n+                res.push(token);\n+            }\n+            curr = curr.bump();\n+        }\n+        self.inner = self.inner.as_slice()[res.len()..].iter();\n+        match res.len() {\n+            0 => Err(()),\n+            1 => Ok(res[0].clone()),\n+            _ => Ok(tt::TokenTree::Subtree(tt::Subtree {\n+                delimiter: tt::Delimiter::None,\n+                token_trees: res.into_iter().cloned().collect(),\n+            })),\n+        }\n+    }\n+\n+    pub(crate) fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n+        let mut fork = self.clone();\n+        match fork.expect_fragment(Visibility) {\n+            Ok(tt) => {\n+                *self = fork;\n+                Some(tt)\n+            }\n+            Err(()) => None,\n+        }\n+    }\n+}\n+\n+pub(super) fn match_repeat(\n+    bindings: &mut Bindings,\n+    pattern: &tt::Subtree,\n+    kind: RepeatKind,\n+    separator: Option<Separator>,\n+    src: &mut TtIter,\n+) -> Result<(), ExpandError> {\n+    // Dirty hack to make macro-expansion terminate.\n+    // This should be replaced by a propper macro-by-example implementation\n+    let mut limit = 65536;\n+    let mut counter = 0;\n+\n+    for i in 0.. {\n+        let mut fork = src.clone();\n+\n+        if let Some(separator) = &separator {\n+            if i != 0 && !fork.eat_separator(separator) {\n+                break;\n+            }\n+        }\n+\n+        let mut nested = Bindings::default();\n+        match match_subtree(&mut nested, pattern, &mut fork) {\n+            Ok(()) => {\n+                limit -= 1;\n+                if limit == 0 {\n+                    log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", pattern, src, kind, separator);\n+                    break;\n                 }\n+                *src = fork;\n \n-                let mut input = TtCursor::new(input_subtree);\n-                let bindings = match_lhs(&subtree, &mut input)?;\n-                if !input.is_eof() {\n-                    return Err(ExpandError::UnexpectedToken);\n+                bindings.push_nested(counter, nested)?;\n+                counter += 1;\n+                if counter == 1 {\n+                    if let RepeatKind::ZeroOrOne = kind {\n+                        break;\n+                    }\n                 }\n+            }\n+            Err(_) => break,\n+        }\n+    }\n \n-                res.merge(bindings);\n+    match (kind, counter) {\n+        (RepeatKind::OneOrMore, 0) => return Err(ExpandError::UnexpectedToken),\n+        (_, 0) => {\n+            // Collect all empty variables in subtrees\n+            let mut vars = Vec::new();\n+            collect_vars(&mut vars, pattern)?;\n+            for var in vars {\n+                bindings.push_empty(&var)\n             }\n         }\n+        _ => (),\n     }\n-    Ok(res)\n+    Ok(())\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>, ExpandError> {\n+fn match_meta_var(kind: &str, input: &mut TtIter) -> Result<Option<Fragment>, ExpandError> {\n     let fragment = match kind {\n         \"path\" => Path,\n         \"expr\" => Expr,\n@@ -169,17 +298,20 @@ fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>,\n         _ => {\n             let tt = match kind {\n                 \"ident\" => {\n-                    let ident = input.eat_ident().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                    let ident = input.expect_ident().map_err(|()| err!(\"expected ident\"))?.clone();\n                     tt::Leaf::from(ident).into()\n                 }\n-                \"tt\" => input.eat().ok_or(ExpandError::UnexpectedToken)?.clone(),\n-                \"lifetime\" => input.eat_lifetime().ok_or(ExpandError::UnexpectedToken)?.clone(),\n+                \"tt\" => input.next().ok_or_else(|| err!())?.clone(),\n+                \"lifetime\" => {\n+                    let ident = input.expect_lifetime().map_err(|()| err!())?;\n+                    tt::Leaf::Ident(ident.clone()).into()\n+                }\n                 \"literal\" => {\n-                    let literal = input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                    let literal = input.expect_literal().map_err(|()| err!())?.clone();\n                     tt::Leaf::from(literal).into()\n                 }\n                 // `vis` is optional\n-                \"vis\" => match input.try_eat_vis() {\n+                \"vis\" => match input.eat_vis() {\n                     Some(vis) => vis,\n                     None => return Ok(None),\n                 },\n@@ -188,28 +320,19 @@ fn match_meta_var(kind: &str, input: &mut TtCursor) -> Result<Option<Fragment>,\n             return Ok(Some(Fragment::Tokens(tt)));\n         }\n     };\n-    let tt = input.eat_fragment(fragment).ok_or(ExpandError::UnexpectedToken)?;\n+    let tt = input.expect_fragment(fragment).map_err(|()| err!())?;\n     let fragment = if kind == \"expr\" { Fragment::Ast(tt) } else { Fragment::Tokens(tt) };\n     Ok(Some(fragment))\n }\n \n-fn collect_vars(subtree: &crate::Subtree) -> Vec<SmolStr> {\n-    let mut res = Vec::new();\n-\n-    for tkn in subtree.token_trees.iter() {\n-        match tkn {\n-            crate::TokenTree::Leaf(crate::Leaf::Var(crate::Var { text, .. })) => {\n-                res.push(text.clone());\n-            }\n-            crate::TokenTree::Subtree(subtree) => {\n-                res.extend(collect_vars(subtree));\n-            }\n-            crate::TokenTree::Repeat(crate::Repeat { subtree, .. }) => {\n-                res.extend(collect_vars(subtree));\n-            }\n-            _ => {}\n+fn collect_vars(buf: &mut Vec<SmolStr>, pattern: &tt::Subtree) -> Result<(), ExpandError> {\n+    for op in parse_pattern(pattern) {\n+        match op? {\n+            Op::Var { name, .. } => buf.push(name.clone()),\n+            Op::TokenTree(tt::TokenTree::Leaf(_)) => (),\n+            Op::TokenTree(tt::TokenTree::Subtree(subtree)) => collect_vars(buf, subtree)?,\n+            Op::Repeat { subtree, .. } => collect_vars(buf, subtree)?,\n         }\n     }\n-\n-    res\n+    Ok(())\n }"}, {"sha": "c22680b93a488c71d92c795eb95ee0a0ceb661a3", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 146, "deletions": 142, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -1,16 +1,20 @@\n+//! Transcraber takes a template, like `fn $ident() {}`, a set of bindings like\n+//! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n+\n use ra_syntax::SmolStr;\n \n use crate::{\n     mbe_expander::{Binding, Bindings, Fragment},\n+    parser::{parse_template, Op, RepeatKind, Separator},\n     ExpandError,\n };\n \n impl Bindings {\n-    fn contains(&self, name: &SmolStr) -> bool {\n+    fn contains(&self, name: &str) -> bool {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Result<&Fragment, ExpandError> {\n+    fn get(&self, name: &str, nesting: &[usize]) -> Result<&Fragment, ExpandError> {\n         let mut b = self.inner.get(name).ok_or_else(|| {\n             ExpandError::BindingError(format!(\"could not find binding `{}`\", name))\n         })?;\n@@ -43,11 +47,12 @@ impl Bindings {\n }\n \n pub(super) fn transcribe(\n+    template: &tt::Subtree,\n     bindings: &Bindings,\n-    template: &crate::Subtree,\n ) -> Result<tt::Subtree, ExpandError> {\n+    assert!(template.delimiter == tt::Delimiter::None);\n     let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new(), var_expanded: false };\n-    expand_subtree(template, &mut ctx)\n+    expand_subtree(&mut ctx, template)\n }\n \n #[derive(Debug)]\n@@ -57,159 +62,158 @@ struct ExpandCtx<'a> {\n     var_expanded: bool,\n }\n \n-fn expand_subtree(\n-    template: &crate::Subtree,\n-    ctx: &mut ExpandCtx,\n-) -> Result<tt::Subtree, ExpandError> {\n+fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n     let mut buf: Vec<tt::TokenTree> = Vec::new();\n-    for tt in template.token_trees.iter() {\n-        let tt = expand_tt(tt, ctx)?;\n-        push_fragment(&mut buf, tt);\n+    for op in parse_template(template) {\n+        match op? {\n+            Op::TokenTree(tt @ tt::TokenTree::Leaf(..)) => buf.push(tt.clone()),\n+            Op::TokenTree(tt::TokenTree::Subtree(tt)) => {\n+                let tt = expand_subtree(ctx, tt)?;\n+                buf.push(tt.into());\n+            }\n+            Op::Var { name, kind: _ } => {\n+                let fragment = expand_var(ctx, name)?;\n+                push_fragment(&mut buf, fragment);\n+            }\n+            Op::Repeat { subtree, kind, separator } => {\n+                let fragment = expand_repeat(ctx, subtree, kind, separator)?;\n+                push_fragment(&mut buf, fragment)\n+            }\n+        }\n     }\n-\n     Ok(tt::Subtree { delimiter: template.delimiter, token_trees: buf })\n }\n \n-fn expand_tt(template: &crate::TokenTree, ctx: &mut ExpandCtx) -> Result<Fragment, ExpandError> {\n-    let res: tt::TokenTree = match template {\n-        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n-        crate::TokenTree::Repeat(repeat) => {\n-            let mut buf: Vec<tt::TokenTree> = Vec::new();\n-            ctx.nesting.push(0);\n-            // Dirty hack to make macro-expansion terminate.\n-            // This should be replaced by a propper macro-by-example implementation\n-            let mut limit = 65536;\n-            let mut has_seps = 0;\n-            let mut counter = 0;\n-\n-            // We store the old var expanded value, and restore it later\n-            // It is because before this `$repeat`,\n-            // it is possible some variables already expanad in the same subtree\n-            //\n-            // `some_var_expanded` keep check if the deeper subtree has expanded variables\n-            let mut some_var_expanded = false;\n-            let old_var_expanded = ctx.var_expanded;\n-            ctx.var_expanded = false;\n-\n-            while let Ok(t) = expand_subtree(&repeat.subtree, ctx) {\n-                // if no var expanded in the child, we count it as a fail\n-                if !ctx.var_expanded {\n-                    break;\n-                }\n+fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError> {\n+    let res = if v == \"crate\" {\n+        // FIXME: Properly handle $crate token\n+        let tt =\n+            tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n+                .into();\n+        Fragment::Tokens(tt)\n+    } else if !ctx.bindings.contains(v) {\n+        // Note that it is possible to have a `$var` inside a macro which is not bound.\n+        // For example:\n+        // ```\n+        // macro_rules! foo {\n+        //     ($a:ident, $b:ident, $c:tt) => {\n+        //         macro_rules! bar {\n+        //             ($bi:ident) => {\n+        //                 fn $bi() -> u8 {$c}\n+        //             }\n+        //         }\n+        //     }\n+        // ```\n+        // We just treat it a normal tokens\n+        let tt = tt::Subtree {\n+            delimiter: tt::Delimiter::None,\n+            token_trees: vec![\n+                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone }).into(),\n+                tt::Leaf::from(tt::Ident { text: v.clone(), id: tt::TokenId::unspecified() })\n+                    .into(),\n+            ],\n+        }\n+        .into();\n+        Fragment::Tokens(tt)\n+    } else {\n+        let fragment = ctx.bindings.get(&v, &ctx.nesting)?.clone();\n+        ctx.var_expanded = true;\n+        fragment\n+    };\n+    Ok(res)\n+}\n \n-                // Reset `ctx.var_expandeded` to see if there is other expanded variable\n-                // in the next matching\n-                some_var_expanded = true;\n-                ctx.var_expanded = false;\n-\n-                counter += 1;\n-                limit -= 1;\n-                if limit == 0 {\n-                    log::warn!(\n-                        \"expand_tt excced in repeat pattern exceed limit => {:#?}\\n{:#?}\",\n-                        template,\n-                        ctx\n-                    );\n-                    break;\n-                }\n+fn expand_repeat(\n+    ctx: &mut ExpandCtx,\n+    template: &tt::Subtree,\n+    kind: RepeatKind,\n+    separator: Option<Separator>,\n+) -> Result<Fragment, ExpandError> {\n+    let mut buf: Vec<tt::TokenTree> = Vec::new();\n+    ctx.nesting.push(0);\n+    // Dirty hack to make macro-expansion terminate.\n+    // This should be replaced by a propper macro-by-example implementation\n+    let mut limit = 65536;\n+    let mut has_seps = 0;\n+    let mut counter = 0;\n+\n+    // We store the old var expanded value, and restore it later\n+    // It is because before this `$repeat`,\n+    // it is possible some variables already expanad in the same subtree\n+    //\n+    // `some_var_expanded` keep check if the deeper subtree has expanded variables\n+    let mut some_var_expanded = false;\n+    let old_var_expanded = ctx.var_expanded;\n+    ctx.var_expanded = false;\n+\n+    while let Ok(mut t) = expand_subtree(ctx, template) {\n+        t.delimiter = tt::Delimiter::None;\n+        // if no var expanded in the child, we count it as a fail\n+        if !ctx.var_expanded {\n+            break;\n+        }\n \n-                let idx = ctx.nesting.pop().unwrap();\n-                ctx.nesting.push(idx + 1);\n-                push_subtree(&mut buf, t);\n-\n-                if let Some(ref sep) = repeat.separator {\n-                    match sep {\n-                        crate::Separator::Ident(ident) => {\n-                            has_seps = 1;\n-                            buf.push(tt::Leaf::from(ident.clone()).into());\n-                        }\n-                        crate::Separator::Literal(lit) => {\n-                            has_seps = 1;\n-                            buf.push(tt::Leaf::from(lit.clone()).into());\n-                        }\n-\n-                        crate::Separator::Puncts(puncts) => {\n-                            has_seps = puncts.len();\n-                            for punct in puncts {\n-                                buf.push(tt::Leaf::from(*punct).into());\n-                            }\n-                        }\n-                    }\n+        // Reset `ctx.var_expandeded` to see if there is other expanded variable\n+        // in the next matching\n+        some_var_expanded = true;\n+        ctx.var_expanded = false;\n+\n+        counter += 1;\n+        limit -= 1;\n+        if limit == 0 {\n+            log::warn!(\n+                \"expand_tt excced in repeat pattern exceed limit => {:#?}\\n{:#?}\",\n+                template,\n+                ctx\n+            );\n+            break;\n+        }\n+\n+        let idx = ctx.nesting.pop().unwrap();\n+        ctx.nesting.push(idx + 1);\n+        push_subtree(&mut buf, t);\n+\n+        if let Some(ref sep) = separator {\n+            match sep {\n+                Separator::Ident(ident) => {\n+                    has_seps = 1;\n+                    buf.push(tt::Leaf::from(ident.clone()).into());\n+                }\n+                Separator::Literal(lit) => {\n+                    has_seps = 1;\n+                    buf.push(tt::Leaf::from(lit.clone()).into());\n                 }\n \n-                if let crate::RepeatKind::ZeroOrOne = repeat.kind {\n-                    break;\n+                Separator::Puncts(puncts) => {\n+                    has_seps = puncts.len();\n+                    for punct in puncts {\n+                        buf.push(tt::Leaf::from(*punct).into());\n+                    }\n                 }\n             }\n+        }\n \n-            // Restore the `var_expanded` by combining old one and the new one\n-            ctx.var_expanded = some_var_expanded || old_var_expanded;\n+        if RepeatKind::ZeroOrOne == kind {\n+            break;\n+        }\n+    }\n \n-            ctx.nesting.pop().unwrap();\n-            for _ in 0..has_seps {\n-                buf.pop();\n-            }\n+    // Restore the `var_expanded` by combining old one and the new one\n+    ctx.var_expanded = some_var_expanded || old_var_expanded;\n \n-            if crate::RepeatKind::OneOrMore == repeat.kind && counter == 0 {\n-                return Err(ExpandError::UnexpectedToken);\n-            }\n+    ctx.nesting.pop().unwrap();\n+    for _ in 0..has_seps {\n+        buf.pop();\n+    }\n \n-            // Check if it is a single token subtree without any delimiter\n-            // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n-            tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf }.into()\n-        }\n-        crate::TokenTree::Leaf(leaf) => match leaf {\n-            crate::Leaf::Ident(ident) => tt::Leaf::from(tt::Ident {\n-                text: ident.text.clone(),\n-                id: tt::TokenId::unspecified(),\n-            })\n-            .into(),\n-            crate::Leaf::Punct(punct) => tt::Leaf::from(*punct).into(),\n-            crate::Leaf::Var(v) => {\n-                if v.text == \"crate\" {\n-                    // FIXME: Properly handle $crate token\n-                    tt::Leaf::from(tt::Ident {\n-                        text: \"$crate\".into(),\n-                        id: tt::TokenId::unspecified(),\n-                    })\n-                    .into()\n-                } else if !ctx.bindings.contains(&v.text) {\n-                    // Note that it is possible to have a `$var` inside a macro which is not bound.\n-                    // For example:\n-                    // ```\n-                    // macro_rules! foo {\n-                    //     ($a:ident, $b:ident, $c:tt) => {\n-                    //         macro_rules! bar {\n-                    //             ($bi:ident) => {\n-                    //                 fn $bi() -> u8 {$c}\n-                    //             }\n-                    //         }\n-                    //     }\n-                    // ```\n-                    // We just treat it a normal tokens\n-                    tt::Subtree {\n-                        delimiter: tt::Delimiter::None,\n-                        token_trees: vec![\n-                            tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone })\n-                                .into(),\n-                            tt::Leaf::from(tt::Ident {\n-                                text: v.text.clone(),\n-                                id: tt::TokenId::unspecified(),\n-                            })\n-                            .into(),\n-                        ],\n-                    }\n-                    .into()\n-                } else {\n-                    let fragment = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n-                    ctx.var_expanded = true;\n-                    return Ok(fragment);\n-                }\n-            }\n-            crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),\n-        },\n-    };\n-    Ok(Fragment::Tokens(res))\n+    if RepeatKind::OneOrMore == kind && counter == 0 {\n+        return Err(ExpandError::UnexpectedToken);\n+    }\n+\n+    // Check if it is a single token subtree without any delimiter\n+    // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n+    let tt = tt::Subtree { delimiter: tt::Delimiter::None, token_trees: buf }.into();\n+    Ok(Fragment::Tokens(tt))\n }\n \n fn push_fragment(buf: &mut Vec<tt::TokenTree>, fragment: Fragment) {"}, {"sha": "954b84d9d7decdd6f3181b5ea9ecd06c12c6b98c", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=37ef8927c373b8eadd63edc1f70055428c49290e", "patch": "@@ -1,187 +0,0 @@\n-use crate::tt_cursor::TtCursor;\n-/// This module parses a raw `tt::TokenStream` into macro-by-example token\n-/// stream. This is a *mostly* identify function, expect for handling of\n-/// `$var:tt_kind` and `$(repeat),*` constructs.\n-use crate::ParseError;\n-\n-pub(crate) fn parse(tt: &tt::Subtree) -> Result<crate::MacroRules, ParseError> {\n-    let mut parser = TtCursor::new(tt);\n-    let mut rules = Vec::new();\n-    while !parser.is_eof() {\n-        rules.push(parse_rule(&mut parser)?);\n-        if let Err(e) = parser.expect_char(';') {\n-            if !parser.is_eof() {\n-                return Err(e);\n-            }\n-            break;\n-        }\n-    }\n-    Ok(crate::MacroRules { rules })\n-}\n-\n-fn parse_rule(p: &mut TtCursor) -> Result<crate::Rule, ParseError> {\n-    let lhs = parse_subtree(p.eat_subtree()?, false)?;\n-    p.expect_char('=')?;\n-    p.expect_char('>')?;\n-    let mut rhs = parse_subtree(p.eat_subtree()?, true)?;\n-    rhs.delimiter = crate::Delimiter::None;\n-    Ok(crate::Rule { lhs, rhs })\n-}\n-\n-fn is_boolean_literal(lit: Option<&tt::TokenTree>) -> bool {\n-    if let Some(tt::TokenTree::Leaf(tt::Leaf::Literal(lit))) = lit {\n-        if lit.text == \"true\" || lit.text == \"false\" {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn parse_subtree(tt: &tt::Subtree, transcriber: bool) -> Result<crate::Subtree, ParseError> {\n-    let mut token_trees = Vec::new();\n-    let mut p = TtCursor::new(tt);\n-    while let Some(tt) = p.eat() {\n-        let child: crate::TokenTree = match tt {\n-            tt::TokenTree::Leaf(leaf) => match leaf {\n-                tt::Leaf::Punct(tt::Punct { char: '$', spacing }) => {\n-                    // mbe var can be an ident or keyword, including `true` and `false`\n-                    if p.at_ident().is_some() || is_boolean_literal(p.current()) {\n-                        crate::Leaf::from(parse_var(&mut p, transcriber)?).into()\n-                    } else if let Some(tt::TokenTree::Subtree(_)) = p.current() {\n-                        parse_repeat(&mut p, transcriber)?.into()\n-                    } else {\n-                        // Treat it as normal punct\n-                        crate::Leaf::from(tt::Punct { char: '$', spacing: *spacing }).into()\n-                    }\n-                }\n-                tt::Leaf::Punct(punct) => crate::Leaf::from(*punct).into(),\n-                tt::Leaf::Ident(tt::Ident { text, .. }) => {\n-                    crate::Leaf::from(crate::Ident { text: text.clone() }).into()\n-                }\n-                tt::Leaf::Literal(tt::Literal { text }) => {\n-                    crate::Leaf::from(crate::Literal { text: text.clone() }).into()\n-                }\n-            },\n-            tt::TokenTree::Subtree(subtree) => parse_subtree(&subtree, transcriber)?.into(),\n-        };\n-        token_trees.push(child);\n-    }\n-    Ok(crate::Subtree { token_trees, delimiter: tt.delimiter })\n-}\n-\n-fn parse_var(p: &mut TtCursor, transcriber: bool) -> Result<crate::Var, ParseError> {\n-    let text = {\n-        if is_boolean_literal(p.current()) {\n-            let lit = p.eat_literal().unwrap();\n-            lit.text.clone()\n-        } else {\n-            let ident = p.eat_ident().unwrap();\n-            ident.text.clone()\n-        }\n-    };\n-\n-    let kind = if !transcriber && p.at_char(':') {\n-        p.bump();\n-        if let Some(ident) = p.eat_ident() {\n-            Some(ident.text.clone())\n-        } else {\n-            p.rev_bump();\n-            None\n-        }\n-    } else {\n-        None\n-    };\n-\n-    Ok(crate::Var { text, kind })\n-}\n-\n-fn mk_repeat(\n-    rep: char,\n-    subtree: crate::Subtree,\n-    separator: Option<crate::Separator>,\n-) -> Result<crate::Repeat, ParseError> {\n-    let kind = match rep {\n-        '*' => crate::RepeatKind::ZeroOrMore,\n-        '+' => crate::RepeatKind::OneOrMore,\n-        '?' => crate::RepeatKind::ZeroOrOne,\n-        _ => return Err(ParseError::Expected(String::from(\"repeat\"))),\n-    };\n-    Ok(crate::Repeat { subtree, kind, separator })\n-}\n-\n-fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n-    let subtree = p.eat_subtree()?;\n-    let mut subtree = parse_subtree(subtree, transcriber)?;\n-    subtree.delimiter = crate::Delimiter::None;\n-\n-    if let Some(rep) = p.at_punct() {\n-        match rep.char {\n-            '*' | '+' | '?' => {\n-                p.bump();\n-                return mk_repeat(rep.char, subtree, None);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    let sep = p.eat_seperator().ok_or_else(|| ParseError::Expected(String::from(\"separator\")))?;\n-    let rep = p.eat_punct().ok_or_else(|| ParseError::Expected(String::from(\"repeat\")))?;\n-\n-    mk_repeat(rep.char, subtree, Some(sep))\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use ra_syntax::{ast, AstNode};\n-\n-    use super::*;\n-    use crate::ast_to_token_tree;\n-\n-    #[test]\n-    fn test_invalid_parse() {\n-        expect_err(\"invalid\", \"subtree\");\n-\n-        is_valid(\"($i:ident) => ()\");\n-        is_valid(\"($($i:ident)*) => ($_)\");\n-        is_valid(\"($($true:ident)*) => ($true)\");\n-        is_valid(\"($($false:ident)*) => ($false)\");\n-\n-        expect_err(\"$i:ident => ()\", \"subtree\");\n-        expect_err(\"($i:ident) ()\", \"`=`\");\n-        expect_err(\"($($i:ident)_) => ()\", \"repeat\");\n-    }\n-\n-    fn expect_err(macro_body: &str, expected: &str) {\n-        assert_eq!(\n-            create_rules(&format_macro(macro_body)),\n-            Err(ParseError::Expected(String::from(expected)))\n-        );\n-    }\n-\n-    fn is_valid(macro_body: &str) {\n-        assert!(create_rules(&format_macro(macro_body)).is_ok());\n-    }\n-\n-    fn format_macro(macro_body: &str) -> String {\n-        format!(\n-            \"\n-        macro_rules! foo {{\n-            {}\n-        }}\n-\",\n-            macro_body\n-        )\n-    }\n-\n-    fn create_rules(macro_definition: &str) -> Result<crate::MacroRules, ParseError> {\n-        let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n-        let macro_definition =\n-            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-\n-        let (definition_tt, _) =\n-            ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n-        parse(&definition_tt)\n-    }\n-\n-}"}, {"sha": "575f587cf3ce668cf456c123cb85d4695a786800", "filename": "crates/ra_mbe/src/parser.rs", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fparser.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -0,0 +1,187 @@\n+//! Parser recognizes special macro syntax, `$var` and `$(repeat)*`, in token\n+//! trees.\n+\n+use ra_syntax::SmolStr;\n+use smallvec::SmallVec;\n+\n+use crate::{tt_iter::TtIter, ExpandError};\n+\n+#[derive(Debug)]\n+pub(crate) enum Op<'a> {\n+    Var { name: &'a SmolStr, kind: Option<&'a SmolStr> },\n+    Repeat { subtree: &'a tt::Subtree, kind: RepeatKind, separator: Option<Separator> },\n+    TokenTree(&'a tt::TokenTree),\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum RepeatKind {\n+    ZeroOrMore,\n+    OneOrMore,\n+    ZeroOrOne,\n+}\n+\n+#[derive(Clone, Debug, Eq)]\n+pub(crate) enum Separator {\n+    Literal(tt::Literal),\n+    Ident(tt::Ident),\n+    Puncts(SmallVec<[tt::Punct; 3]>),\n+}\n+\n+// Note that when we compare a Separator, we just care about its textual value.\n+impl PartialEq for Separator {\n+    fn eq(&self, other: &Separator) -> bool {\n+        use Separator::*;\n+\n+        match (self, other) {\n+            (Ident(ref a), Ident(ref b)) => a.text == b.text,\n+            (Literal(ref a), Literal(ref b)) => a.text == b.text,\n+            (Puncts(ref a), Puncts(ref b)) if a.len() == b.len() => {\n+                let a_iter = a.iter().map(|a| a.char);\n+                let b_iter = b.iter().map(|b| b.char);\n+                a_iter.eq(b_iter)\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n+pub(crate) fn parse_template<'a>(\n+    template: &'a tt::Subtree,\n+) -> impl Iterator<Item = Result<Op<'a>, ExpandError>> {\n+    parse_inner(template, Mode::Template)\n+}\n+\n+pub(crate) fn parse_pattern<'a>(\n+    pattern: &'a tt::Subtree,\n+) -> impl Iterator<Item = Result<Op<'a>, ExpandError>> {\n+    parse_inner(pattern, Mode::Pattern)\n+}\n+\n+#[derive(Clone, Copy)]\n+enum Mode {\n+    Pattern,\n+    Template,\n+}\n+\n+fn parse_inner<'a>(\n+    src: &'a tt::Subtree,\n+    mode: Mode,\n+) -> impl Iterator<Item = Result<Op<'a>, ExpandError>> {\n+    let mut src = TtIter::new(src);\n+    std::iter::from_fn(move || {\n+        let first = src.next()?;\n+        Some(next_op(first, &mut src, mode))\n+    })\n+}\n+\n+macro_rules! err {\n+    ($($tt:tt)*) => {\n+        ExpandError::UnexpectedToken\n+    };\n+}\n+\n+macro_rules! bail {\n+    ($($tt:tt)*) => {\n+        return Err(err!($($tt)*))\n+    };\n+}\n+\n+fn next_op<'a>(\n+    first: &'a tt::TokenTree,\n+    src: &mut TtIter<'a>,\n+    mode: Mode,\n+) -> Result<Op<'a>, ExpandError> {\n+    let res = match first {\n+        tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n+            let second = src.next().ok_or_else(|| err!(\"bad var 1\"))?;\n+            match second {\n+                tt::TokenTree::Subtree(subtree) => {\n+                    let (separator, kind) = parse_repeat(src)?;\n+                    Op::Repeat { subtree, separator, kind }\n+                }\n+                tt::TokenTree::Leaf(leaf) => match leaf {\n+                    tt::Leaf::Punct(..) => Err(ExpandError::UnexpectedToken)?,\n+                    tt::Leaf::Ident(ident) => {\n+                        let name = &ident.text;\n+                        let kind = eat_fragment_kind(src, mode)?;\n+                        Op::Var { name, kind }\n+                    }\n+                    tt::Leaf::Literal(lit) => {\n+                        if is_boolean_literal(lit) {\n+                            let name = &lit.text;\n+                            let kind = eat_fragment_kind(src, mode)?;\n+                            Op::Var { name, kind }\n+                        } else {\n+                            bail!(\"bad var 2\");\n+                        }\n+                    }\n+                },\n+            }\n+        }\n+        tt => Op::TokenTree(tt),\n+    };\n+    Ok(res)\n+}\n+\n+fn eat_fragment_kind<'a>(\n+    src: &mut TtIter<'a>,\n+    mode: Mode,\n+) -> Result<Option<&'a SmolStr>, ExpandError> {\n+    if let Mode::Pattern = mode {\n+        src.expect_char(':').map_err(|()| err!(\"bad fragment specifier 1\"))?;\n+        let ident = src.expect_ident().map_err(|()| err!(\"bad fragment specifier 1\"))?;\n+        return Ok(Some(&ident.text));\n+    };\n+    Ok(None)\n+}\n+\n+fn is_boolean_literal(lit: &tt::Literal) -> bool {\n+    match lit.text.as_str() {\n+        \"true\" | \"false\" => true,\n+        _ => false,\n+    }\n+}\n+\n+///TOOD: impl for slice iter\n+fn parse_repeat(src: &mut TtIter) -> Result<(Option<Separator>, RepeatKind), ExpandError> {\n+    let mut separator = Separator::Puncts(SmallVec::new());\n+    for tt in src {\n+        let tt = match tt {\n+            tt::TokenTree::Leaf(leaf) => leaf,\n+            tt::TokenTree::Subtree(_) => Err(ExpandError::InvalidRepeat)?,\n+        };\n+        let has_sep = match &separator {\n+            Separator::Puncts(puncts) => puncts.len() != 0,\n+            _ => true,\n+        };\n+        match tt {\n+            tt::Leaf::Ident(_) | tt::Leaf::Literal(_) if has_sep => {\n+                Err(ExpandError::InvalidRepeat)?\n+            }\n+            tt::Leaf::Ident(ident) => separator = Separator::Ident(ident.clone()),\n+            tt::Leaf::Literal(lit) => separator = Separator::Literal(lit.clone()),\n+            tt::Leaf::Punct(punct) => {\n+                let repeat_kind = match punct.char {\n+                    '*' => RepeatKind::ZeroOrMore,\n+                    '+' => RepeatKind::OneOrMore,\n+                    '?' => RepeatKind::ZeroOrOne,\n+                    _ => {\n+                        match &mut separator {\n+                            Separator::Puncts(puncts) => {\n+                                if puncts.len() == 3 {\n+                                    Err(ExpandError::InvalidRepeat)?\n+                                }\n+                                puncts.push(punct.clone())\n+                            }\n+                            _ => Err(ExpandError::InvalidRepeat)?,\n+                        }\n+                        continue;\n+                    }\n+                };\n+                let separator = if has_sep { Some(separator) } else { None };\n+                return Ok((separator, repeat_kind));\n+            }\n+        }\n+    }\n+    Err(ExpandError::InvalidRepeat)\n+}"}, {"sha": "4440c69ff558faf3452cb3022c2889872149c29c", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=37ef8927c373b8eadd63edc1f70055428c49290e", "patch": "@@ -1,91 +0,0 @@\n-use crate::subtree_source::SubtreeTokenSource;\n-\n-use ra_parser::{FragmentKind, TokenSource, TreeSink};\n-use ra_syntax::SyntaxKind;\n-use tt::buffer::{Cursor, TokenBuffer};\n-\n-struct OffsetTokenSink<'a> {\n-    cursor: Cursor<'a>,\n-    error: bool,\n-}\n-\n-impl<'a> OffsetTokenSink<'a> {\n-    pub fn collect(&self, begin: Cursor<'a>) -> Vec<&'a tt::TokenTree> {\n-        if !self.cursor.is_root() {\n-            return vec![];\n-        }\n-\n-        let mut curr = begin;\n-        let mut res = vec![];\n-\n-        while self.cursor != curr {\n-            if let Some(token) = curr.token_tree() {\n-                res.push(token);\n-            }\n-            curr = curr.bump();\n-        }\n-\n-        res\n-    }\n-}\n-\n-impl<'a> TreeSink for OffsetTokenSink<'a> {\n-    fn token(&mut self, _kind: SyntaxKind, n_tokens: u8) {\n-        for _ in 0..n_tokens {\n-            self.cursor = self.cursor.bump_subtree();\n-        }\n-    }\n-    fn start_node(&mut self, _kind: SyntaxKind) {}\n-    fn finish_node(&mut self) {}\n-    fn error(&mut self, _error: ra_parser::ParseError) {\n-        self.error = true;\n-    }\n-}\n-\n-pub(crate) struct Parser<'a> {\n-    subtree: &'a tt::Subtree,\n-    cur_pos: &'a mut usize,\n-}\n-\n-impl<'a> Parser<'a> {\n-    pub fn new(cur_pos: &'a mut usize, subtree: &'a tt::Subtree) -> Parser<'a> {\n-        Parser { cur_pos, subtree }\n-    }\n-\n-    pub fn parse_fragment(self, fragment_kind: FragmentKind) -> Option<tt::TokenTree> {\n-        self.parse(|token_source, tree_skink| {\n-            ra_parser::parse_fragment(token_source, tree_skink, fragment_kind)\n-        })\n-    }\n-\n-    fn parse<F>(self, f: F) -> Option<tt::TokenTree>\n-    where\n-        F: FnOnce(&mut dyn TokenSource, &mut dyn TreeSink),\n-    {\n-        let buffer = TokenBuffer::new(&self.subtree.token_trees[*self.cur_pos..]);\n-        let mut src = SubtreeTokenSource::new(&buffer);\n-        let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n-\n-        f(&mut src, &mut sink);\n-\n-        let r = self.finish(buffer.begin(), &mut sink);\n-        if sink.error {\n-            return None;\n-        }\n-        r\n-    }\n-\n-    fn finish(self, begin: Cursor, sink: &mut OffsetTokenSink) -> Option<tt::TokenTree> {\n-        let res = sink.collect(begin);\n-        *self.cur_pos += res.len();\n-\n-        match res.len() {\n-            0 => None,\n-            1 => Some(res[0].clone()),\n-            _ => Some(tt::TokenTree::Subtree(tt::Subtree {\n-                delimiter: tt::Delimiter::None,\n-                token_trees: res.into_iter().cloned().collect(),\n-            })),\n-        }\n-    }\n-}"}, {"sha": "d7482c63d0c498288d096f7f2097eaaf2311e95e", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -3,6 +3,54 @@ use test_utils::assert_eq_text;\n \n use super::*;\n \n+mod rule_parsing {\n+    use ra_syntax::{ast, AstNode};\n+\n+    use super::*;\n+    use crate::ast_to_token_tree;\n+\n+    #[test]\n+    fn test_valid_arms() {\n+        fn check(macro_body: &str) {\n+            let m = parse_macro_arm(macro_body);\n+            m.unwrap();\n+        }\n+\n+        check(\"($i:ident) => ()\");\n+        check(\"($($i:ident)*) => ($_)\");\n+        check(\"($($true:ident)*) => ($true)\");\n+        check(\"($($false:ident)*) => ($false)\");\n+    }\n+\n+    #[test]\n+    fn test_invalid_arms() {\n+        fn check(macro_body: &str, err: &str) {\n+            let m = parse_macro_arm(macro_body);\n+            assert_eq!(m, Err(ParseError::Expected(String::from(err))));\n+        }\n+\n+        check(\"invalid\", \"expected subtree\");\n+\n+        check(\"$i:ident => ()\", \"expected subtree\");\n+        check(\"($i:ident) ()\", \"expected `=`\");\n+        check(\"($($i:ident)_) => ()\", \"invalid repeat\");\n+\n+        check(\"($i) => ($i)\", \"invalid macro definition\");\n+        check(\"($i:) => ($i)\", \"invalid macro definition\");\n+    }\n+\n+    fn parse_macro_arm(arm_definition: &str) -> Result<crate::MacroRules, ParseError> {\n+        let macro_definition = format!(\" macro_rules! m {{ {} }} \", arm_definition);\n+        let source_file = ast::SourceFile::parse(&macro_definition).ok().unwrap();\n+        let macro_definition =\n+            source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n+\n+        let (definition_tt, _) =\n+            ast_to_token_tree(&macro_definition.token_tree().unwrap()).unwrap();\n+        crate::MacroRules::parse(&definition_tt)\n+    }\n+}\n+\n // Good first issue (although a slightly challenging one):\n //\n // * Pick a random test from here"}, {"sha": "a69c006c76baf0368d101b09b224fa0fac47bfcb", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "removed", "additions": 0, "deletions": 281, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37ef8927c373b8eadd63edc1f70055428c49290e/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=37ef8927c373b8eadd63edc1f70055428c49290e", "patch": "@@ -1,281 +0,0 @@\n-use crate::{subtree_parser::Parser, ParseError};\n-\n-use ra_parser::FragmentKind;\n-use smallvec::{smallvec, SmallVec};\n-\n-#[derive(Debug, Clone)]\n-pub(crate) struct TtCursor<'a> {\n-    subtree: &'a tt::Subtree,\n-    pos: usize,\n-}\n-\n-pub(crate) struct TtCursorMemento {\n-    pos: usize,\n-}\n-\n-impl<'a> TtCursor<'a> {\n-    pub(crate) fn new(subtree: &'a tt::Subtree) -> TtCursor<'a> {\n-        TtCursor { subtree, pos: 0 }\n-    }\n-\n-    pub(crate) fn is_eof(&self) -> bool {\n-        self.pos == self.subtree.token_trees.len()\n-    }\n-\n-    pub(crate) fn current(&self) -> Option<&'a tt::TokenTree> {\n-        self.subtree.token_trees.get(self.pos)\n-    }\n-\n-    pub(crate) fn at_punct(&self) -> Option<&'a tt::Punct> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(it))) => Some(it),\n-            _ => None,\n-        }\n-    }\n-\n-    pub(crate) fn at_char(&self, char: char) -> bool {\n-        match self.at_punct() {\n-            Some(tt::Punct { char: c, .. }) if *c == char => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub(crate) fn at_ident(&mut self) -> Option<&'a tt::Ident> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Ident(i))) => Some(i),\n-            _ => None,\n-        }\n-    }\n-\n-    pub(crate) fn at_literal(&mut self) -> Option<&'a tt::Literal> {\n-        match self.current() {\n-            Some(tt::TokenTree::Leaf(tt::Leaf::Literal(i))) => Some(i),\n-            _ => None,\n-        }\n-    }\n-\n-    pub(crate) fn bump(&mut self) {\n-        self.pos += 1;\n-    }\n-    pub(crate) fn rev_bump(&mut self) {\n-        self.pos -= 1;\n-    }\n-\n-    pub(crate) fn eat(&mut self) -> Option<&'a tt::TokenTree> {\n-        self.current().map(|it| {\n-            self.bump();\n-            it\n-        })\n-    }\n-\n-    pub(crate) fn eat_subtree(&mut self) -> Result<&'a tt::Subtree, ParseError> {\n-        match self.current() {\n-            Some(tt::TokenTree::Subtree(sub)) => {\n-                self.bump();\n-                Ok(sub)\n-            }\n-            _ => Err(ParseError::Expected(String::from(\"subtree\"))),\n-        }\n-    }\n-\n-    pub(crate) fn eat_punct(&mut self) -> Option<&'a tt::Punct> {\n-        self.at_punct().map(|it| {\n-            self.bump();\n-            it\n-        })\n-    }\n-\n-    pub(crate) fn eat_ident(&mut self) -> Option<&'a tt::Ident> {\n-        self.at_ident().map(|i| {\n-            self.bump();\n-            i\n-        })\n-    }\n-\n-    pub(crate) fn eat_literal(&mut self) -> Option<&'a tt::Literal> {\n-        self.at_literal().map(|i| {\n-            self.bump();\n-            i\n-        })\n-    }\n-\n-    pub(crate) fn eat_fragment(&mut self, fragment_kind: FragmentKind) -> Option<tt::TokenTree> {\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-        parser.parse_fragment(fragment_kind)\n-    }\n-\n-    pub(crate) fn eat_lifetime(&mut self) -> Option<tt::TokenTree> {\n-        // check if it start from \"`\"\n-        if let Some(ident) = self.at_ident() {\n-            if ident.text.chars().next()? != '\\'' {\n-                return None;\n-            }\n-        }\n-\n-        self.eat_ident().cloned().map(|ident| tt::Leaf::from(ident).into())\n-    }\n-\n-    pub(crate) fn try_eat_vis(&mut self) -> Option<tt::TokenTree> {\n-        // `vis` matcher is optional\n-        let old_pos = self.pos;\n-        let parser = Parser::new(&mut self.pos, self.subtree);\n-\n-        let res = parser.parse_fragment(FragmentKind::Visibility);\n-        if res.is_none() {\n-            self.pos = old_pos;\n-        }\n-        res\n-    }\n-\n-    pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ParseError> {\n-        if self.at_char(char) {\n-            self.bump();\n-            Ok(())\n-        } else {\n-            Err(ParseError::Expected(format!(\"`{}`\", char)))\n-        }\n-    }\n-\n-    fn eat_punct3(&mut self, p: tt::Punct) -> Option<SmallVec<[tt::Punct; 3]>> {\n-        let sec = *self.eat_punct()?;\n-        let third = *self.eat_punct()?;\n-        Some(smallvec![p, sec, third])\n-    }\n-\n-    fn eat_punct2(&mut self, p: tt::Punct) -> Option<SmallVec<[tt::Punct; 3]>> {\n-        let sec = *self.eat_punct()?;\n-        Some(smallvec![p, sec])\n-    }\n-\n-    fn eat_multi_char_punct<'b, I>(\n-        &mut self,\n-        p: tt::Punct,\n-        iter: &mut TokenPeek<'b, I>,\n-    ) -> Option<SmallVec<[tt::Punct; 3]>>\n-    where\n-        I: Iterator<Item = &'b tt::TokenTree>,\n-    {\n-        if let Some((m, _)) = iter.current_punct3(p) {\n-            if let r @ Some(_) = match m {\n-                ('<', '<', '=') | ('>', '>', '=') | ('.', '.', '.') | ('.', '.', '=') => {\n-                    self.eat_punct3(p)\n-                }\n-                _ => None,\n-            } {\n-                return r;\n-            }\n-        }\n-\n-        if let Some((m, _)) = iter.current_punct2(p) {\n-            if let r @ Some(_) = match m {\n-                ('<', '=')\n-                | ('>', '=')\n-                | ('+', '=')\n-                | ('-', '=')\n-                | ('|', '=')\n-                | ('&', '=')\n-                | ('^', '=')\n-                | ('/', '=')\n-                | ('*', '=')\n-                | ('%', '=')\n-                | ('&', '&')\n-                | ('|', '|')\n-                | ('<', '<')\n-                | ('>', '>')\n-                | ('-', '>')\n-                | ('!', '=')\n-                | ('=', '>')\n-                | ('=', '=')\n-                | ('.', '.')\n-                | (':', ':') => self.eat_punct2(p),\n-\n-                _ => None,\n-            } {\n-                return r;\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    pub(crate) fn eat_seperator(&mut self) -> Option<crate::Separator> {\n-        match self.eat()? {\n-            tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n-                Some(crate::Separator::Literal(lit.clone()))\n-            }\n-            tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                Some(crate::Separator::Ident(ident.clone()))\n-            }\n-            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n-                match punct.char {\n-                    '*' | '+' | '?' => return None,\n-                    _ => {}\n-                };\n-\n-                // FIXME: The parser is only handle some compositeable punct,\n-                // But at this phase, some punct still is jointed.\n-                // So we by pass that check here.\n-                let mut peekable = TokenPeek::new(self.subtree.token_trees[self.pos..].iter());\n-                let puncts = self.eat_multi_char_punct(*punct, &mut peekable);\n-                let puncts = puncts.unwrap_or_else(|| smallvec![*punct]);\n-\n-                Some(crate::Separator::Puncts(puncts))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    #[must_use]\n-    pub(crate) fn save(&self) -> TtCursorMemento {\n-        TtCursorMemento { pos: self.pos }\n-    }\n-\n-    pub(crate) fn rollback(&mut self, memento: TtCursorMemento) {\n-        self.pos = memento.pos;\n-    }\n-}\n-\n-pub(crate) struct TokenPeek<'a, I>\n-where\n-    I: Iterator<Item = &'a tt::TokenTree>,\n-{\n-    iter: itertools::MultiPeek<I>,\n-}\n-\n-// helper function\n-fn to_punct(tt: &tt::TokenTree) -> Option<&tt::Punct> {\n-    if let tt::TokenTree::Leaf(tt::Leaf::Punct(pp)) = tt {\n-        return Some(pp);\n-    }\n-    None\n-}\n-\n-impl<'a, I> TokenPeek<'a, I>\n-where\n-    I: Iterator<Item = &'a tt::TokenTree>,\n-{\n-    pub fn new(iter: I) -> Self {\n-        TokenPeek { iter: itertools::multipeek(iter) }\n-    }\n-\n-    pub fn current_punct2(&mut self, p: tt::Punct) -> Option<((char, char), bool)> {\n-        if p.spacing != tt::Spacing::Joint {\n-            return None;\n-        }\n-\n-        self.iter.reset_peek();\n-        let p1 = to_punct(self.iter.peek()?)?;\n-        Some(((p.char, p1.char), p1.spacing == tt::Spacing::Joint))\n-    }\n-\n-    pub fn current_punct3(&mut self, p: tt::Punct) -> Option<((char, char, char), bool)> {\n-        self.current_punct2(p).and_then(|((p0, p1), last_joint)| {\n-            if !last_joint {\n-                None\n-            } else {\n-                let p2 = to_punct(*self.iter.peek()?)?;\n-                Some(((p0, p1, p2.char), p2.spacing == tt::Spacing::Joint))\n-            }\n-        })\n-    }\n-}"}, {"sha": "c53f99d1ea77206194b039a5a2e1f917d94ff9c8", "filename": "crates/ra_mbe/src/tt_iter.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4551182f94fe81c314f79ddf8916a5520cfd03b0/crates%2Fra_mbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_iter.rs?ref=4551182f94fe81c314f79ddf8916a5520cfd03b0", "patch": "@@ -0,0 +1,67 @@\n+#[derive(Debug, Clone)]\n+pub(crate) struct TtIter<'a> {\n+    pub(crate) inner: std::slice::Iter<'a, tt::TokenTree>,\n+}\n+\n+impl<'a> TtIter<'a> {\n+    pub(crate) fn new(subtree: &'a tt::Subtree) -> TtIter<'a> {\n+        TtIter { inner: subtree.token_trees.iter() }\n+    }\n+\n+    pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ()> {\n+        match self.next() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: c, .. }))) if *c == char => {\n+                Ok(())\n+            }\n+            _ => Err(()),\n+        }\n+    }\n+\n+    pub(crate) fn expect_subtree(&mut self) -> Result<&'a tt::Subtree, ()> {\n+        match self.next() {\n+            Some(tt::TokenTree::Subtree(it)) => Ok(it),\n+            _ => Err(()),\n+        }\n+    }\n+\n+    pub(crate) fn expect_leaf(&mut self) -> Result<&'a tt::Leaf, ()> {\n+        match self.next() {\n+            Some(tt::TokenTree::Leaf(it)) => Ok(it),\n+            _ => Err(()),\n+        }\n+    }\n+\n+    pub(crate) fn expect_ident(&mut self) -> Result<&'a tt::Ident, ()> {\n+        match self.expect_leaf()? {\n+            tt::Leaf::Ident(it) => Ok(it),\n+            _ => Err(()),\n+        }\n+    }\n+\n+    pub(crate) fn expect_literal(&mut self) -> Result<&'a tt::Literal, ()> {\n+        match self.expect_leaf()? {\n+            tt::Leaf::Literal(it) => Ok(it),\n+            _ => Err(()),\n+        }\n+    }\n+\n+    pub(crate) fn expect_punct(&mut self) -> Result<&'a tt::Punct, ()> {\n+        match self.expect_leaf()? {\n+            tt::Leaf::Punct(it) => Ok(it),\n+            _ => Err(()),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for TtIter<'a> {\n+    type Item = &'a tt::TokenTree;\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a> std::iter::ExactSizeIterator for TtIter<'a> {}"}]}