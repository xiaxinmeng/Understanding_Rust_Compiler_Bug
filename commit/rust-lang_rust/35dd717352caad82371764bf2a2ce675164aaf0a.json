{"sha": "35dd717352caad82371764bf2a2ce675164aaf0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZGQ3MTczNTJjYWFkODIzNzE3NjRiZjJhMmNlNjc1MTY0YWFmMGE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-12T23:41:20Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-13T00:01:13Z"}, "message": "Simplify a bunch of trans functions to not need the rust type. Remove some PointerCasts.", "tree": {"sha": "3a2c0a2de0ae46b9d06fb02fdc8b38b122480270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a2c0a2de0ae46b9d06fb02fdc8b38b122480270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35dd717352caad82371764bf2a2ce675164aaf0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35dd717352caad82371764bf2a2ce675164aaf0a", "html_url": "https://github.com/rust-lang/rust/commit/35dd717352caad82371764bf2a2ce675164aaf0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35dd717352caad82371764bf2a2ce675164aaf0a/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccf4e8cf9acd555c90176e46ae21ef10337d31d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccf4e8cf9acd555c90176e46ae21ef10337d31d5", "html_url": "https://github.com/rust-lang/rust/commit/ccf4e8cf9acd555c90176e46ae21ef10337d31d5"}], "stats": {"total": 99, "additions": 33, "deletions": 66}, "files": [{"sha": "2fd4374dc093b156557366ccee153bf662aff0dc", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35dd717352caad82371764bf2a2ce675164aaf0a/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dd717352caad82371764bf2a2ce675164aaf0a/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=35dd717352caad82371764bf2a2ce675164aaf0a", "patch": "@@ -462,8 +462,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n         let box = Load(bcx, val);\n-        let box_ty = node_id_type(bcx, pat_id);\n-        let box_no_addrspace = non_gc_box_cast(bcx, box, box_ty);\n+        let box_no_addrspace = non_gc_box_cast(bcx, box);\n         let unboxed = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]\n                          + vals_left, chk, exits);\n@@ -472,8 +471,7 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n \n     if any_uniq_pat(m, col) {\n         let box = Load(bcx, val);\n-        let box_ty = node_id_type(bcx, pat_id);\n-        let box_no_addrspace = non_gc_box_cast(bcx, box, box_ty);\n+        let box_no_addrspace = non_gc_box_cast(bcx, box);\n         let unboxed = GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(dm, m, col, val),\n                          [unboxed] + vals_left, chk, exits);"}, {"sha": "fe4046c36635e96eb6f4f301416985a6f88c34a9", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/35dd717352caad82371764bf2a2ce675164aaf0a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dd717352caad82371764bf2a2ce675164aaf0a/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=35dd717352caad82371764bf2a2ce675164aaf0a", "patch": "@@ -381,10 +381,8 @@ fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n     {box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n-    let mk_ty = alt heap { heap_shared { ty::mk_imm_box }\n-                           heap_exchange { ty::mk_imm_uniq } };\n     let box = malloc_raw(bcx, t, heap);\n-    let non_gc_box = non_gc_box_cast(bcx, box, mk_ty(bcx.tcx(), t));\n+    let non_gc_box = non_gc_box_cast(bcx, box);\n     let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]);\n     ret {box: box, body: body};\n }\n@@ -2682,11 +2680,11 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n             let t = expr_ty(cx, base);\n             let val = alt check ty::get(t).struct {\n               ty::ty_box(_) {\n-                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n+                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n               ty::ty_uniq(_) {\n-                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n+                let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n               ty::ty_res(_, _, _) {\n@@ -2714,10 +2712,11 @@ Before taking a pointer to the inside of a box it should be cast into address\n space 0. Otherwise the resulting (non-box) pointer will be in the wrong\n address space and thus be the wrong type.\n \"]\n-fn non_gc_box_cast(cx: block, val: ValueRef, t: ty::t) -> ValueRef {\n+fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n     #debug(\"non_gc_box_cast\");\n     add_comment(cx, \"non_gc_box_cast\");\n-    let non_gc_t = type_of_non_gc_box(cx.ccx(), t);\n+    assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) as uint == 1u);\n+    let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n     PointerCast(cx, val, non_gc_t)\n }\n \n@@ -3885,11 +3884,8 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(e_ty) {\n-            let unit_ty = ty::mk_mach_uint(tcx, ast::ty_u8);\n-            let vec_ty = ty::mk_vec(tcx, {ty: unit_ty, mutbl: ast::m_imm});\n-            let unit_llty = type_of(ccx, unit_ty);\n-            let body = tvec::get_bodyptr(bcx, expr_res.val, vec_ty);\n-            let data = tvec::get_dataptr(bcx, body, unit_llty);\n+            let body = tvec::get_bodyptr(bcx, expr_res.val);\n+            let data = tvec::get_dataptr(bcx, body);\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n             ret bcx;"}, {"sha": "b220ec7cd42fe00407bfa5cb7f220354ba2223ae", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 23, "deletions": 50, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/35dd717352caad82371764bf2a2ce675164aaf0a/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35dd717352caad82371764bf2a2ce675164aaf0a/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=35dd717352caad82371764bf2a2ce675164aaf0a", "patch": "@@ -5,11 +5,12 @@ import back::abi;\n import base::{call_memmove,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n-               dest, bcx_icx};\n+               dest, bcx_icx, non_gc_box_cast};\n import syntax::codemap::span;\n import shape::llsize_of;\n import build::*;\n import common::*;\n+import util::ppaux::ty_to_str;\n \n fn get_fill(bcx: block, vptr: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_fill\");\n@@ -22,28 +23,14 @@ fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n \n-fn get_bodyptr(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> ValueRef {\n-    let ccx = bcx.ccx();\n-    alt ty::get(vec_ty).struct {\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq)\n-      | ty::ty_vec(_) | ty::ty_str {\n-        let boxptr = PointerCast(bcx, vptr, T_ptr(T_box_header(ccx)));\n-        let bodyptr = GEPi(bcx, boxptr, [1u]);\n-        let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-        let llunit_ty = type_of::type_of(ccx, unit_ty);\n-        PointerCast(bcx, bodyptr, T_ptr(T_vec(ccx, llunit_ty)))\n-      }\n-      _ {\n-        vptr\n-      }\n-    }\n+fn get_bodyptr(bcx: block, vptr: ValueRef) -> ValueRef {\n+    non_gc_box_cast(bcx, GEPi(bcx, vptr, [0u, abi::box_field_body]))\n }\n \n-fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n+fn get_dataptr(bcx: block, vptr: ValueRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n-    let ptr = GEPi(bcx, vptr, [0u, abi::vec_elt_elems]);\n-    PointerCast(bcx, ptr, T_ptr(unit_ty))\n+    GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n@@ -83,7 +70,7 @@ fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n     let ccx = bcx.ccx();\n-    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let body_ptr = get_bodyptr(bcx, vptr);\n     let fill = get_fill(bcx, body_ptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n \n@@ -159,8 +146,7 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n           ast::vstore_uniq {\n             let {bcx, val} = alloc_uniq(bcx, unit_ty, args.len());\n             add_clean_free(bcx, val, true);\n-            let body = get_bodyptr(bcx, val, vec_ty);\n-            let dataptr = get_dataptr(bcx, body, llunitty);\n+            let dataptr = get_dataptr(bcx, get_bodyptr(bcx, val));\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n@@ -241,10 +227,8 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq {\n-        let body = tvec::get_bodyptr(cx, v, vec_ty);\n-        let base = tvec::get_dataptr(cx, body, llunitty);\n-        let len = tvec::get_fill(cx, body);\n-        (base, len)\n+        let body = tvec::get_bodyptr(cx, v);\n+        (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n       }\n       ty::vstore_box {\n         cx.ccx().sess.unimpl(\"unhandled tvec::get_base_and_len\");\n@@ -297,14 +281,11 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(ccx.tcx, vec_ty);\n     let strings = ty::type_is_str(vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n-    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n-    let rbody = get_bodyptr(bcx, rhs, vec_ty);\n-    let lfill = get_fill(bcx, lbody);\n-    let rfill = get_fill(bcx, rbody);\n+    let lfill = get_fill(bcx, get_bodyptr(bcx, lhs));\n+    let rfill = get_fill(bcx, get_bodyptr(bcx, rhs));\n     let mut new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n@@ -315,9 +296,9 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n     let lhs = Load(bcx, lhsptr);\n     let rhs = Select(bcx, self_append, lhs, rhs);\n \n-    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n+    let lbody = get_bodyptr(bcx, lhs);\n \n-    let lhs_data = get_dataptr(bcx, lbody, llunitty);\n+    let lhs_data = get_dataptr(bcx, lbody);\n     let mut lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n@@ -342,7 +323,7 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let scratch = base::alloca(bcx, elt_llty);\n     for vec::each(vals) {|val|\n         bcx = base::trans_expr_save_in(bcx, val, scratch);\n-        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr));\n         let old_fill = get_fill(bcx, vptr);\n         let new_fill = Add(bcx, old_fill, elt_sz);\n         let do_grow = ICmp(bcx, lib::llvm::IntUGT, new_fill,\n@@ -353,9 +334,9 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n             Call(bcx, ccx.upcalls.vec_grow, [pt, new_fill]);\n             bcx\n         };\n-        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr));\n         set_fill(bcx, vptr, new_fill);\n-        let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr, elt_llty),\n+        let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr),\n                                     old_fill);\n         call_memmove(bcx, targetptr, scratch, elt_sz);\n     }\n@@ -379,18 +360,15 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n         ret base::store_in_dest(bcx, n, dest);\n     }\n \n-    let lhs_body = get_bodyptr(bcx, lhs, vec_ty);\n-    let rhs_body = get_bodyptr(bcx, rhs, vec_ty);\n-\n-    let lhs_fill = get_fill(bcx, lhs_body);\n-    let rhs_fill = get_fill(bcx, rhs_body);\n+    let lhs_fill = get_fill(bcx, get_bodyptr(bcx, lhs));\n+    let rhs_fill = get_fill(bcx, get_bodyptr(bcx, rhs));\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let mut {bcx: bcx, val: new_vec_ptr} =\n         alloc_uniq_raw(bcx, unit_ty, new_fill, new_fill);\n \n-    let new_vec_body_ptr = get_bodyptr(bcx, new_vec_ptr, vec_ty);\n+    let new_vec_body_ptr = get_bodyptr(bcx, new_vec_ptr);\n     let write_ptr_ptr = do_spill_noroot\n-        (bcx, get_dataptr(bcx, new_vec_body_ptr, llunitty));\n+        (bcx, get_dataptr(bcx, new_vec_body_ptr));\n     let copy_fn = fn@(bcx: block, addr: ValueRef,\n                       _ty: ty::t) -> block {\n         let ccx = bcx.ccx();\n@@ -443,19 +421,14 @@ fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n                  fill: ValueRef, f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec_uniq\");\n-    let ccx = bcx.ccx();\n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n-    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n-    let data_ptr = get_dataptr(bcx, body_ptr, llunitty);\n+    let data_ptr = get_dataptr(bcx, get_bodyptr(bcx, vptr));\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n-    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n-    let fill = get_fill(bcx, body_ptr);\n+    let fill = get_fill(bcx, get_bodyptr(bcx, vptr));\n     ret iter_vec_uniq(bcx, vptr, vec_ty, fill, f);\n }\n "}]}