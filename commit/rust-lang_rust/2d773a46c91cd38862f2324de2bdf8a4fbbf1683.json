{"sha": "2d773a46c91cd38862f2324de2bdf8a4fbbf1683", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNzczYTQ2YzkxY2QzODg2MmYyMzI0ZGUyYmRmOGE0ZmJiZjE2ODM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-31T17:23:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-31T17:23:56Z"}, "message": "simplify", "tree": {"sha": "203566ee540b587ccfe1f785a9fefe5c3231b4c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/203566ee540b587ccfe1f785a9fefe5c3231b4c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d773a46c91cd38862f2324de2bdf8a4fbbf1683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d773a46c91cd38862f2324de2bdf8a4fbbf1683", "html_url": "https://github.com/rust-lang/rust/commit/2d773a46c91cd38862f2324de2bdf8a4fbbf1683", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d773a46c91cd38862f2324de2bdf8a4fbbf1683/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1bda6aeda084e6e913b80959dbf6ce6260d1db2", "html_url": "https://github.com/rust-lang/rust/commit/e1bda6aeda084e6e913b80959dbf6ce6260d1db2"}], "stats": {"total": 103, "additions": 52, "deletions": 51}, "files": [{"sha": "9fc39274958c3a547cb33221b4e116b747a1c508", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/2d773a46c91cd38862f2324de2bdf8a4fbbf1683/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d773a46c91cd38862f2324de2bdf8a4fbbf1683/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=2d773a46c91cd38862f2324de2bdf8a4fbbf1683", "patch": "@@ -452,59 +452,60 @@ impl<'a> PoolDispatcher<'a> {\n             None => return Ok(self),\n             Some(req) => req,\n         };\n-        match req.cast::<R>() {\n-            Ok((id, params)) => {\n-                // Real time requests block user typing, so we should react quickly to them.\n-                // Currently this means that we try to cancel background jobs if we don't have\n-                // a spare thread.\n-                let is_real_time = TypeId::of::<R>() == TypeId::of::<req::JoinLines>()\n-                    || TypeId::of::<R>() == TypeId::of::<req::OnEnter>();\n-                if self.pool.queued_count() > 0 && is_real_time {\n-                    self.world.cancel_requests();\n-                }\n-\n-                let world = self.world.snapshot();\n-                let sender = self.sender.clone();\n-                self.pool.execute(move || {\n-                    let response = match f(world, params) {\n-                        Ok(resp) => RawResponse::ok::<R>(id, &resp),\n-                        Err(e) => match e.downcast::<LspError>() {\n-                            Ok(lsp_error) => {\n-                                RawResponse::err(id, lsp_error.code, lsp_error.message)\n-                            }\n-                            Err(e) => {\n-                                if is_canceled(&e) {\n-                                    // FIXME: When https://github.com/Microsoft/vscode-languageserver-node/issues/457\n-                                    // gets fixed, we can return the proper response.\n-                                    // This works around the issue where \"content modified\" error would continuously\n-                                    // show an message pop-up in VsCode\n-                                    // RawResponse::err(\n-                                    //     id,\n-                                    //     ErrorCode::ContentModified as i32,\n-                                    //     \"content modified\".to_string(),\n-                                    // )\n-                                    RawResponse {\n-                                        id,\n-                                        result: Some(serde_json::to_value(&()).unwrap()),\n-                                        error: None,\n-                                    }\n-                                } else {\n-                                    RawResponse::err(\n-                                        id,\n-                                        ErrorCode::InternalError as i32,\n-                                        format!(\"{}\\n{}\", e, e.backtrace()),\n-                                    )\n-                                }\n-                            }\n-                        },\n-                    };\n-                    let task = Task::Respond(response);\n-                    sender.send(task).unwrap();\n-                });\n-                self.res = Some(id);\n+        let (id, params) = match req.cast::<R>() {\n+            Ok(it) => it,\n+            Err(req) => {\n+                self.req = Some(req);\n+                return Ok(self);\n             }\n-            Err(req) => self.req = Some(req),\n+        };\n+        self.res = Some(id);\n+\n+        // Real time requests block user typing, so we should react quickly to them.\n+        // Currently this means that we try to cancel background jobs if we don't have\n+        // a spare thread.\n+        let is_real_time = TypeId::of::<R>() == TypeId::of::<req::JoinLines>()\n+            || TypeId::of::<R>() == TypeId::of::<req::OnEnter>();\n+        if self.pool.queued_count() > 0 && is_real_time {\n+            self.world.cancel_requests();\n         }\n+\n+        let world = self.world.snapshot();\n+        let sender = self.sender.clone();\n+        self.pool.execute(move || {\n+            let response = match f(world, params) {\n+                Ok(resp) => RawResponse::ok::<R>(id, &resp),\n+                Err(e) => match e.downcast::<LspError>() {\n+                    Ok(lsp_error) => RawResponse::err(id, lsp_error.code, lsp_error.message),\n+                    Err(e) => {\n+                        if is_canceled(&e) {\n+                            // FIXME: When https://github.com/Microsoft/vscode-languageserver-node/issues/457\n+                            // gets fixed, we can return the proper response.\n+                            // This works around the issue where \"content modified\" error would continuously\n+                            // show an message pop-up in VsCode\n+                            // RawResponse::err(\n+                            //     id,\n+                            //     ErrorCode::ContentModified as i32,\n+                            //     \"content modified\".to_string(),\n+                            // )\n+                            RawResponse {\n+                                id,\n+                                result: Some(serde_json::to_value(&()).unwrap()),\n+                                error: None,\n+                            }\n+                        } else {\n+                            RawResponse::err(\n+                                id,\n+                                ErrorCode::InternalError as i32,\n+                                format!(\"{}\\n{}\", e, e.backtrace()),\n+                            )\n+                        }\n+                    }\n+                },\n+            };\n+            let task = Task::Respond(response);\n+            sender.send(task).unwrap();\n+        });\n         Ok(self)\n     }\n "}]}