{"sha": "1a29934c37cf4ffa2b269c39a25245e58d3916d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhMjk5MzRjMzdjZjRmZmEyYjI2OWMzOWEyNTI0NWU1OGQzOTE2ZDU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-01-08T03:57:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-08T03:57:11Z"}, "message": "Merge #7145\n\n7145: Proper handling $crate Take 2 [DO NOT MERGE] r=edwin0cheng a=edwin0cheng\n\nSimilar to previous PR (#7133) , but improved the following things :\r\n\r\n1. Instead of storing the whole `ExpansionInfo`, we store a similar but stripped version `HygieneInfo`.\r\n2. Instread of storing the `SyntaxNode` (because every token we are interested are IDENT), we store the `TextRange` only.\r\n3. Because of 2, we now can put it in Salsa.\r\n4. And most important improvement: Instead of computing the whole frames every single time, we compute it recursively through salsa: (Such that in the best scenario, we only need to compute the first layer of frame)\r\n\r\n```rust\r\n        let def_site = db.hygiene_frame(info.def.file_id);\r\n        let call_site = db.hygiene_frame(info.arg.file_id);\r\n\r\n        HygieneFrame { expansion: Some(info), local_inner, krate, call_site, def_site }\r\n```\r\n\r\nThe overall speed compared to previous PR is much faster (65s vs 45s) :\r\n```\r\n[WITH old PR]\r\nDatabase loaded 644.86ms, 284mi\r\nCrates in this dir: 36\r\nTotal modules found: 576\r\nTotal declarations: 11153\r\nTotal functions: 8715\r\nItem Collection: 15.78s, 91562mi\r\nTotal expressions: 240721\r\nExpressions of unknown type: 2635 (1%)\r\nExpressions of partially unknown type: 2064 (0%)\r\nType mismatches: 865\r\nInference: 49.84s, 250747mi\r\nTotal: 65.62s, 342310mi\r\nrust-analyzer -q analysis-stats .  66.72s user 0.57s system 99% cpu 1:07.40 total\r\n\r\n[WITH this PR]\r\nDatabase loaded 665.83ms, 284mi\r\nCrates in this dir: 36\r\nTotal modules found: 577\r\nTotal declarations: 11188\r\nTotal functions: 8743\r\nItem Collection: 15.28s, 84919mi\r\nTotal expressions: 241229\r\nExpressions of unknown type: 2637 (1%)\r\nExpressions of partially unknown type: 2064 (0%)\r\nType mismatches: 868\r\nInference: 30.15s, 135293mi\r\nTotal: 45.43s, 220213mi   \r\nrust-analyzer -q analysis-stats .  46.26s user 0.74s system 99% cpu 47.294 total\r\n```\r\n\r\n*HOWEVER*,  it is still a perf regression (35s vs 45s):\r\n```\r\n[WITHOUT this PR]\r\nDatabase loaded 657.42ms, 284mi\r\nCrates in this dir: 36\r\nTotal modules found: 577\r\nTotal declarations: 11177\r\nTotal functions: 8735\r\nItem Collection: 12.87s, 72407mi\r\nTotal expressions: 239380\r\nExpressions of unknown type: 2643 (1%)\r\nExpressions of partially unknown type: 2064 (0%)\r\nType mismatches: 868\r\nInference: 22.88s, 97889mi\r\nTotal: 35.74s, 170297mi\r\nrust-analyzer -q analysis-stats .  36.71s user 0.63s system 99% cpu 37.498 total\r\n```\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "8481257d9c6a09a56b5377d25eadd267e6d8d3ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8481257d9c6a09a56b5377d25eadd267e6d8d3ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a29934c37cf4ffa2b269c39a25245e58d3916d5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf99gYCRBK7hj4Ov3rIwAAdHIIAJrUIgSH0fyWx7b5E77SDEAG\nmkmfSskHYsPsCYJwsdc5+qkWyIkqpoy1GXahAsJ3cYkqVQGkyQ/Kx1aVydH76Taz\nqn7XRiHXo6CGuKZ3S2w95VH/D2/y84dAl+69RM9YAkeoFDUVKWJc7Ccbc5opQMcD\nQJIxVrHXE0bRrrkITSCkseebfBv7qyGYjM4JYmHPjQphhSV0ZisGEhhD/R0rvaTm\ndgmI1rGV4PaS43vp1S7jK2o4rTO4Spp1W1rDjklX2Kt+V4IVKdINPgvCZKH7dYJ8\nOgrPV4DX09ut3WrQx+LxTOb529UCh9IK6OsSk7xAXsrXLBx1P+Hv7XtCURN6/W0=\n=J5oE\n-----END PGP SIGNATURE-----\n", "payload": "tree 8481257d9c6a09a56b5377d25eadd267e6d8d3ba\nparent a3e5dcc1778d5703a20e7f11cc0268026d121b73\nparent 76f2b9d2ef797fb995f1bd2706a7e609d014a67a\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1610078231 +0000\ncommitter GitHub <noreply@github.com> 1610078231 +0000\n\nMerge #7145\n\n7145: Proper handling $crate Take 2 [DO NOT MERGE] r=edwin0cheng a=edwin0cheng\n\nSimilar to previous PR (#7133) , but improved the following things :\r\n\r\n1. Instead of storing the whole `ExpansionInfo`, we store a similar but stripped version `HygieneInfo`.\r\n2. Instread of storing the `SyntaxNode` (because every token we are interested are IDENT), we store the `TextRange` only.\r\n3. Because of 2, we now can put it in Salsa.\r\n4. And most important improvement: Instead of computing the whole frames every single time, we compute it recursively through salsa: (Such that in the best scenario, we only need to compute the first layer of frame)\r\n\r\n```rust\r\n        let def_site = db.hygiene_frame(info.def.file_id);\r\n        let call_site = db.hygiene_frame(info.arg.file_id);\r\n\r\n        HygieneFrame { expansion: Some(info), local_inner, krate, call_site, def_site }\r\n```\r\n\r\nThe overall speed compared to previous PR is much faster (65s vs 45s) :\r\n```\r\n[WITH old PR]\r\nDatabase loaded 644.86ms, 284mi\r\nCrates in this dir: 36\r\nTotal modules found: 576\r\nTotal declarations: 11153\r\nTotal functions: 8715\r\nItem Collection: 15.78s, 91562mi\r\nTotal expressions: 240721\r\nExpressions of unknown type: 2635 (1%)\r\nExpressions of partially unknown type: 2064 (0%)\r\nType mismatches: 865\r\nInference: 49.84s, 250747mi\r\nTotal: 65.62s, 342310mi\r\nrust-analyzer -q analysis-stats .  66.72s user 0.57s system 99% cpu 1:07.40 total\r\n\r\n[WITH this PR]\r\nDatabase loaded 665.83ms, 284mi\r\nCrates in this dir: 36\r\nTotal modules found: 577\r\nTotal declarations: 11188\r\nTotal functions: 8743\r\nItem Collection: 15.28s, 84919mi\r\nTotal expressions: 241229\r\nExpressions of unknown type: 2637 (1%)\r\nExpressions of partially unknown type: 2064 (0%)\r\nType mismatches: 868\r\nInference: 30.15s, 135293mi\r\nTotal: 45.43s, 220213mi   \r\nrust-analyzer -q analysis-stats .  46.26s user 0.74s system 99% cpu 47.294 total\r\n```\r\n\r\n*HOWEVER*,  it is still a perf regression (35s vs 45s):\r\n```\r\n[WITHOUT this PR]\r\nDatabase loaded 657.42ms, 284mi\r\nCrates in this dir: 36\r\nTotal modules found: 577\r\nTotal declarations: 11177\r\nTotal functions: 8735\r\nItem Collection: 12.87s, 72407mi\r\nTotal expressions: 239380\r\nExpressions of unknown type: 2643 (1%)\r\nExpressions of partially unknown type: 2064 (0%)\r\nType mismatches: 868\r\nInference: 22.88s, 97889mi\r\nTotal: 35.74s, 170297mi\r\nrust-analyzer -q analysis-stats .  36.71s user 0.63s system 99% cpu 37.498 total\r\n```\r\n\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a29934c37cf4ffa2b269c39a25245e58d3916d5", "html_url": "https://github.com/rust-lang/rust/commit/1a29934c37cf4ffa2b269c39a25245e58d3916d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a29934c37cf4ffa2b269c39a25245e58d3916d5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3e5dcc1778d5703a20e7f11cc0268026d121b73", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3e5dcc1778d5703a20e7f11cc0268026d121b73", "html_url": "https://github.com/rust-lang/rust/commit/a3e5dcc1778d5703a20e7f11cc0268026d121b73"}, {"sha": "76f2b9d2ef797fb995f1bd2706a7e609d014a67a", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f2b9d2ef797fb995f1bd2706a7e609d014a67a", "html_url": "https://github.com/rust-lang/rust/commit/76f2b9d2ef797fb995f1bd2706a7e609d014a67a"}], "stats": {"total": 293, "additions": 235, "deletions": 58}, "files": [{"sha": "d5d4cf5b6569bd4d2e2c6b91666c15c69ec07eb0", "filename": "crates/hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -10,8 +10,8 @@ pub use hir_def::db::{\n     TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{\n-    AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,\n-    MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroExpansionQuery,\n+    AstDatabase, AstDatabaseStorage, AstIdMapQuery, HygieneFrameQuery, InternEagerExpansionQuery,\n+    InternMacroQuery, MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroExpansionQuery,\n };\n pub use hir_ty::db::*;\n "}, {"sha": "9518ac109be5f6f4858fecc0839bc6617be9225e", "filename": "crates/hir_def/src/path/lower.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -123,7 +123,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n     // We follow what it did anyway :)\n     if segments.len() == 1 && kind == PathKind::Plain {\n         if let Some(_macro_call) = path.syntax().parent().and_then(ast::MacroCall::cast) {\n-            if let Some(crate_id) = hygiene.local_inner_macros() {\n+            if let Some(crate_id) = hygiene.local_inner_macros(path) {\n                 kind = PathKind::DollarCrate(crate_id);\n             }\n         }"}, {"sha": "ab2637b8ca0a50e7aa9d26b48ed39bb35c4c73f4", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -8,9 +8,9 @@ use parser::FragmentKind;\n use syntax::{algo::diff, ast::NameOwner, AstNode, GreenNode, Parse, SyntaxKind::*, SyntaxNode};\n \n use crate::{\n-    ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId,\n-    HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc, MacroDefId, MacroDefKind,\n-    MacroFile, ProcMacroExpander,\n+    ast_id_map::AstIdMap, hygiene::HygieneFrame, BuiltinDeriveExpander, BuiltinFnLikeExpander,\n+    EagerCallLoc, EagerMacroId, HirFileId, HirFileIdRepr, LazyMacroId, MacroCallId, MacroCallLoc,\n+    MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -94,6 +94,8 @@ pub trait AstDatabase: SourceDatabase {\n     fn intern_eager_expansion(&self, eager: EagerCallLoc) -> EagerMacroId;\n \n     fn expand_proc_macro(&self, call: MacroCallId) -> Result<tt::Subtree, mbe::ExpandError>;\n+\n+    fn hygiene_frame(&self, file_id: HirFileId) -> Arc<HygieneFrame>;\n }\n \n /// This expands the given macro call, but with different arguments. This is\n@@ -369,6 +371,10 @@ fn parse_macro_with_arg(\n     }\n }\n \n+fn hygiene_frame(db: &dyn AstDatabase, file_id: HirFileId) -> Arc<HygieneFrame> {\n+    Arc::new(HygieneFrame::new(db, file_id))\n+}\n+\n /// Given a `MacroCallId`, return what `FragmentKind` it belongs to.\n /// FIXME: Not completed\n fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {"}, {"sha": "8db581b774aad2f9fbc3cf2627f59d8c6fd3b412", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 177, "deletions": 33, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -2,65 +2,209 @@\n //!\n //! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n //! this moment, this is horribly incomplete and handles only `$crate`.\n+use std::sync::Arc;\n+\n use base_db::CrateId;\n use either::Either;\n-use syntax::ast;\n+use mbe::Origin;\n+use parser::SyntaxKind;\n+use syntax::{ast, AstNode, SyntaxNode, TextRange, TextSize};\n \n use crate::{\n-    db::AstDatabase,\n+    db::{self, AstDatabase},\n     name::{AsName, Name},\n-    HirFileId, HirFileIdRepr, MacroCallId, MacroDefKind,\n+    HirFileId, HirFileIdRepr, InFile, MacroCallId, MacroCallLoc, MacroDefKind, MacroFile,\n };\n \n #[derive(Clone, Debug)]\n pub struct Hygiene {\n-    // This is what `$crate` expands to\n-    def_crate: Option<CrateId>,\n-\n-    // Indicate this is a local inner macro\n-    local_inner: bool,\n+    frames: Option<HygieneFrames>,\n }\n \n impl Hygiene {\n     pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Hygiene {\n-        let (def_crate, local_inner) = match file_id.0 {\n-            HirFileIdRepr::FileId(_) => (None, false),\n-            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n-                MacroCallId::LazyMacro(id) => {\n-                    let loc = db.lookup_intern_macro(id);\n-                    match loc.def.kind {\n-                        MacroDefKind::Declarative => (Some(loc.def.krate), loc.def.local_inner),\n-                        MacroDefKind::BuiltIn(_) => (Some(loc.def.krate), false),\n-                        MacroDefKind::BuiltInDerive(_) => (None, false),\n-                        MacroDefKind::BuiltInEager(_) => (None, false),\n-                        MacroDefKind::ProcMacro(_) => (None, false),\n-                    }\n-                }\n-                MacroCallId::EagerMacro(_id) => (None, false),\n-            },\n-        };\n-        Hygiene { def_crate, local_inner }\n+        Hygiene { frames: Some(HygieneFrames::new(db, file_id.clone())) }\n     }\n \n     pub fn new_unhygienic() -> Hygiene {\n-        Hygiene { def_crate: None, local_inner: false }\n+        Hygiene { frames: None }\n     }\n \n     // FIXME: this should just return name\n     pub fn name_ref_to_name(&self, name_ref: ast::NameRef) -> Either<Name, CrateId> {\n-        if let Some(def_crate) = self.def_crate {\n+        if let Some(frames) = &self.frames {\n             if name_ref.text() == \"$crate\" {\n-                return Either::Right(def_crate);\n+                if let Some(krate) = frames.root_crate(name_ref.syntax()) {\n+                    return Either::Right(krate);\n+                }\n             }\n         }\n+\n         Either::Left(name_ref.as_name())\n     }\n \n-    pub fn local_inner_macros(&self) -> Option<CrateId> {\n-        if self.local_inner {\n-            self.def_crate\n-        } else {\n-            None\n+    pub fn local_inner_macros(&self, path: ast::Path) -> Option<CrateId> {\n+        let mut token = path.syntax().first_token()?.text_range();\n+        let frames = self.frames.as_ref()?;\n+        let mut current = frames.0.clone();\n+\n+        loop {\n+            let (mapped, origin) = current.expansion.as_ref()?.map_ident_up(token)?;\n+            if origin == Origin::Def {\n+                return if current.local_inner { frames.root_crate(path.syntax()) } else { None };\n+            }\n+            current = current.call_site.as_ref()?.clone();\n+            token = mapped.value;\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+struct HygieneFrames(Arc<HygieneFrame>);\n+\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+pub struct HygieneFrame {\n+    expansion: Option<HygieneInfo>,\n+\n+    // Indicate this is a local inner macro\n+    local_inner: bool,\n+    krate: Option<CrateId>,\n+\n+    call_site: Option<Arc<HygieneFrame>>,\n+    def_site: Option<Arc<HygieneFrame>>,\n+}\n+\n+impl HygieneFrames {\n+    fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n+        HygieneFrames(Arc::new(HygieneFrame::new(db, file_id)))\n+    }\n+\n+    fn root_crate(&self, node: &SyntaxNode) -> Option<CrateId> {\n+        let mut token = node.first_token()?.text_range();\n+        let mut result = self.0.krate;\n+        let mut current = self.0.clone();\n+\n+        while let Some((mapped, origin)) =\n+            current.expansion.as_ref().and_then(|it| it.map_ident_up(token))\n+        {\n+            result = current.krate;\n+\n+            let site = match origin {\n+                Origin::Def => &current.def_site,\n+                Origin::Call => &current.call_site,\n+            };\n+\n+            let site = match site {\n+                None => break,\n+                Some(it) => it,\n+            };\n+\n+            current = site.clone();\n+            token = mapped.value;\n         }\n+\n+        result\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+struct HygieneInfo {\n+    arg_start: InFile<TextSize>,\n+    /// The `macro_rules!` arguments.\n+    def_start: Option<InFile<TextSize>>,\n+\n+    macro_def: Arc<(db::TokenExpander, mbe::TokenMap)>,\n+    macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    exp_map: Arc<mbe::TokenMap>,\n+}\n+\n+impl HygieneInfo {\n+    fn map_ident_up(&self, token: TextRange) -> Option<(InFile<TextRange>, Origin)> {\n+        let token_id = self.exp_map.token_by_range(token)?;\n+\n+        let (token_id, origin) = self.macro_def.0.map_id_up(token_id);\n+        let (token_map, tt) = match origin {\n+            mbe::Origin::Call => (&self.macro_arg.1, self.arg_start),\n+            mbe::Origin::Def => (\n+                &self.macro_def.1,\n+                self.def_start\n+                    .as_ref()\n+                    .expect(\"`Origin::Def` used with non-`macro_rules!` macro\")\n+                    .clone(),\n+            ),\n+        };\n+\n+        let range = token_map.range_by_token(token_id)?.by_kind(SyntaxKind::IDENT)?;\n+        Some((tt.with_value(range + tt.value), origin))\n+    }\n+}\n+\n+fn make_hygiene_info(\n+    db: &dyn AstDatabase,\n+    macro_file: MacroFile,\n+    loc: &MacroCallLoc,\n+) -> Option<HygieneInfo> {\n+    let arg_tt = loc.kind.arg(db)?;\n+\n+    let def_offset = loc.def.ast_id.and_then(|id| {\n+        let def_tt = match id.to_node(db) {\n+            ast::Macro::MacroRules(mac) => mac.token_tree()?.syntax().text_range().start(),\n+            ast::Macro::MacroDef(_) => return None,\n+        };\n+        Some(InFile::new(id.file_id, def_tt))\n+    });\n+\n+    let macro_def = db.macro_def(loc.def)?;\n+    let (_, exp_map) = db.parse_macro_expansion(macro_file).value?;\n+    let macro_arg = db.macro_arg(macro_file.macro_call_id)?;\n+\n+    Some(HygieneInfo {\n+        arg_start: InFile::new(loc.kind.file_id(), arg_tt.text_range().start()),\n+        def_start: def_offset,\n+        macro_arg,\n+        macro_def,\n+        exp_map,\n+    })\n+}\n+\n+impl HygieneFrame {\n+    pub(crate) fn new(db: &dyn AstDatabase, file_id: HirFileId) -> HygieneFrame {\n+        let (info, krate, local_inner) = match file_id.0 {\n+            HirFileIdRepr::FileId(_) => (None, None, false),\n+            HirFileIdRepr::MacroFile(macro_file) => match macro_file.macro_call_id {\n+                MacroCallId::EagerMacro(_id) => (None, None, false),\n+                MacroCallId::LazyMacro(id) => {\n+                    let loc = db.lookup_intern_macro(id);\n+                    let info = make_hygiene_info(db, macro_file, &loc);\n+                    match loc.def.kind {\n+                        MacroDefKind::Declarative => {\n+                            (info, Some(loc.def.krate), loc.def.local_inner)\n+                        }\n+                        MacroDefKind::BuiltIn(_) => (info, Some(loc.def.krate), false),\n+                        MacroDefKind::BuiltInDerive(_) => (info, None, false),\n+                        MacroDefKind::BuiltInEager(_) => (info, None, false),\n+                        MacroDefKind::ProcMacro(_) => (info, None, false),\n+                    }\n+                }\n+            },\n+        };\n+\n+        let info = match info {\n+            None => {\n+                return HygieneFrame {\n+                    expansion: None,\n+                    local_inner,\n+                    krate,\n+                    call_site: None,\n+                    def_site: None,\n+                };\n+            }\n+            Some(it) => it,\n+        };\n+\n+        let def_site = info.def_start.map(|it| db.hygiene_frame(it.file_id));\n+        let call_site = Some(db.hygiene_frame(info.arg_start.file_id));\n+\n+        HygieneFrame { expansion: Some(info), local_inner, krate, call_site, def_site }\n     }\n }"}, {"sha": "c64f0b5b53a8d100c955263baeb8c4e9ae568160", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -370,6 +370,37 @@ expand!();\n     );\n }\n \n+#[test]\n+fn infer_macro_with_dollar_crate_in_def_site() {\n+    check_types(\n+        r#\"\n+//- /main.rs crate:main deps:foo\n+use foo::expand;\n+\n+macro_rules! list {\n+    ($($tt:tt)*) => { $($tt)* }\n+}\n+\n+fn test() {\n+    let r = expand!();\n+    r;\n+  //^ u128\n+}\n+\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! expand {\n+    () => { list!($crate::m!()) };\n+}\n+\n+#[macro_export]\n+macro_rules! m {\n+    () => { 0u128 };\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn infer_type_value_non_legacy_macro_use_as() {\n     check_infer("}, {"sha": "c770a236b0906f85e9012ffd282a61b52042c056", "filename": "crates/ide_db/src/apply_change.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fide_db%2Fsrc%2Fapply_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fapply_change.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -145,6 +145,7 @@ impl RootDatabase {\n             hir::db::MacroDefQuery\n             hir::db::ParseMacroExpansionQuery\n             hir::db::MacroExpandQuery\n+            hir::db::HygieneFrameQuery\n \n             // DefDatabase\n             hir::db::ItemTreeQuery"}, {"sha": "c6d615c81beb5451bdf9eeac83cc6e643199ec75", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -150,7 +150,7 @@ fn match_subtree(\n                     res.add_err(err!(\"leftover tokens\"));\n                 }\n             }\n-            Op::Var { name, kind } => {\n+            Op::Var { name, kind, .. } => {\n                 let kind = match kind {\n                     Some(k) => k,\n                     None => {"}, {"sha": "57f3f104dcaa77707c5be1f53bc63299086cf1aa", "filename": "crates/mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -100,8 +100,8 @@ fn expand_subtree(\n                 err = err.or(e);\n                 arena.push(tt.into());\n             }\n-            Op::Var { name, .. } => {\n-                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name);\n+            Op::Var { name, id, .. } => {\n+                let ExpandResult { value: fragment, err: e } = expand_var(ctx, &name, *id);\n                 err = err.or(e);\n                 push_fragment(arena, fragment);\n             }\n@@ -118,12 +118,10 @@ fn expand_subtree(\n     ExpandResult { value: tt::Subtree { delimiter: template.delimiter, token_trees: tts }, err }\n }\n \n-fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n+fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr, id: tt::TokenId) -> ExpandResult<Fragment> {\n     if v == \"crate\" {\n         // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n-        let tt =\n-            tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n-                .into();\n+        let tt = tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id }).into();\n         ExpandResult::ok(Fragment::Tokens(tt))\n     } else if !ctx.bindings.contains(v) {\n         // Note that it is possible to have a `$var` inside a macro which is not bound.\n@@ -142,14 +140,8 @@ fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> ExpandResult<Fragment> {\n         let tt = tt::Subtree {\n             delimiter: None,\n             token_trees: vec![\n-                tt::Leaf::from(tt::Punct {\n-                    char: '$',\n-                    spacing: tt::Spacing::Alone,\n-                    id: tt::TokenId::unspecified(),\n-                })\n-                .into(),\n-                tt::Leaf::from(tt::Ident { text: v.clone(), id: tt::TokenId::unspecified() })\n-                    .into(),\n+                tt::Leaf::from(tt::Punct { char: '$', spacing: tt::Spacing::Alone, id }).into(),\n+                tt::Leaf::from(tt::Ident { text: v.clone(), id }).into(),\n             ],\n         }\n         .into();"}, {"sha": "77cc739b65707d6a3e09df2d955bb361df466451", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a29934c37cf4ffa2b269c39a25245e58d3916d5/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=1a29934c37cf4ffa2b269c39a25245e58d3916d5", "patch": "@@ -8,7 +8,7 @@ use crate::{tt_iter::TtIter, ExpandError, MetaTemplate};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n-    Var { name: SmolStr, kind: Option<SmolStr> },\n+    Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n     Repeat { subtree: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n     Leaf(tt::Leaf),\n     Subtree(MetaTemplate),\n@@ -106,18 +106,21 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                         }\n                         let name = UNDERSCORE.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n-                        Op::Var { name, kind }\n+                        let id = punct.id;\n+                        Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Ident(ident) => {\n                         let name = ident.text.clone();\n                         let kind = eat_fragment_kind(src, mode)?;\n-                        Op::Var { name, kind }\n+                        let id = ident.id;\n+                        Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Literal(lit) => {\n                         if is_boolean_literal(&lit) {\n                             let name = lit.text.clone();\n                             let kind = eat_fragment_kind(src, mode)?;\n-                            Op::Var { name, kind }\n+                            let id = lit.id;\n+                            Op::Var { name, kind, id }\n                         } else {\n                             bail!(\"bad var 2\");\n                         }"}]}