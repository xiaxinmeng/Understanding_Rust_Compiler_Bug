{"sha": "2b9a0efef470fd061c70592892f6e40844415344", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiOWEwZWZlZjQ3MGZkMDYxYzcwNTkyODkyZjZlNDA4NDQ0MTUzNDQ=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-18T18:08:57Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:03:32Z"}, "message": "Move debug_context to MirContext from FunctionContext", "tree": {"sha": "ed632b367638e155b6711cdf9b3328c4d392c0ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed632b367638e155b6711cdf9b3328c4d392c0ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b9a0efef470fd061c70592892f6e40844415344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b9a0efef470fd061c70592892f6e40844415344", "html_url": "https://github.com/rust-lang/rust/commit/2b9a0efef470fd061c70592892f6e40844415344", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b9a0efef470fd061c70592892f6e40844415344/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc8c280fbc5eb7af126857a7fc18952f042be92c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc8c280fbc5eb7af126857a7fc18952f042be92c", "html_url": "https://github.com/rust-lang/rust/commit/fc8c280fbc5eb7af126857a7fc18952f042be92c"}], "stats": {"total": 128, "additions": 66, "deletions": 62}, "files": [{"sha": "bd0b4bafe6247d21d73d97ffd9f57cd1aa1ee51a", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -602,7 +602,7 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n     let fcx = FunctionContext::new(ccx, lldecl, fn_ty, Some((instance, &sig, abi)), true);\n \n     let mir = ccx.tcx().item_mir(instance.def);\n-    mir::trans_mir(&fcx, &mir);\n+    mir::trans_mir(&fcx, &mir, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "899a3bdb20a900c9270135935c8a35c3b2a05f25", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 34, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -16,7 +16,6 @@ use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef, get_param};\n-use llvm::debuginfo::DIScope;\n use monomorphize::Instance;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n@@ -30,7 +29,6 @@ use base;\n use builder::Builder;\n use callee::Callee;\n use consts;\n-use debuginfo;\n use declare;\n use machine;\n use monomorphize;\n@@ -267,9 +265,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n     // This function's enclosing crate context.\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n \n-    // Used and maintained by the debuginfo module.\n-    pub debug_context: debuginfo::FunctionDebugContext,\n-\n     alloca_builder: Builder<'a, 'tcx>,\n }\n \n@@ -283,33 +278,12 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         definition: Option<(Instance<'tcx>, &ty::FnSig<'tcx>, Abi)>,\n         skip_retptr: bool,\n     ) -> FunctionContext<'a, 'tcx> {\n-        let (param_substs, def_id) = match definition {\n+        let param_substs = match definition {\n             Some((instance, ..)) => {\n                 assert!(!instance.substs.needs_infer());\n-                (instance.substs, Some(instance.def))\n+                instance.substs\n             }\n-            None => (ccx.tcx().intern_substs(&[]), None)\n-        };\n-\n-        let local_id = def_id.and_then(|id| ccx.tcx().map.as_local_node_id(id));\n-\n-        debug!(\"FunctionContext::new({})\", definition.map_or(String::new(), |d| d.0.to_string()));\n-\n-        let no_debug = if let Some(id) = local_id {\n-            ccx.tcx().map.attrs(id).iter().any(|item| item.check_name(\"no_debug\"))\n-        } else if let Some(def_id) = def_id {\n-            ccx.sess().cstore.item_attrs(def_id).iter().any(|item| item.check_name(\"no_debug\"))\n-        } else {\n-            false\n-        };\n-\n-        let mir = def_id.map(|id| ccx.tcx().item_mir(id));\n-\n-        let debug_context = if let (false, Some((instance, sig, abi)), &Some(ref mir)) =\n-                (no_debug, definition, &mir) {\n-            debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfndecl, mir)\n-        } else {\n-            debuginfo::empty_function_debug_context(ccx)\n+            None => ccx.tcx().intern_substs(&[])\n         };\n \n         let mut fcx = FunctionContext {\n@@ -320,7 +294,6 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             fn_ty: fn_ty,\n             param_substs: param_substs,\n             ccx: ccx,\n-            debug_context: debug_context,\n             alloca_builder: Builder::with_ccx(ccx),\n         };\n \n@@ -507,10 +480,6 @@ impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn set_source_location(&self, scope: DIScope, sp: Span) {\n-        debuginfo::set_source_location(self.fcx(), self, scope, sp)\n-    }\n-\n     pub fn at_start<F, R>(&self, f: F) -> R\n         where F: FnOnce(&BlockAndBuilder<'a, 'tcx>) -> R\n     {"}, {"sha": "f5a8eeacf38adba37051666d798402945cb92170", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir)\n+pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -53,7 +53,7 @@ pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir)\n     };\n     let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n \n-    let fn_metadata = match fcx.debug_context {\n+    let fn_metadata = match *debug_context {\n         FunctionDebugContext::RegularContext(ref data) => data.fn_metadata,\n         FunctionDebugContext::DebugInfoDisabled |\n         FunctionDebugContext::FunctionWithoutDebugInfo => {"}, {"sha": "b22bb080d052906c53f0a4d05434a7477410460a", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -28,6 +28,7 @@ use rustc::ty::subst::Substs;\n \n use abi::Abi;\n use common::{CrateContext, BlockAndBuilder};\n+use mir::MirContext;\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n@@ -225,6 +226,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     // This can be the case for functions inlined from another crate\n     if span == syntax_pos::DUMMY_SP {\n+        // FIXME(simulacrum): Probably can't happen; remove.\n         return FunctionDebugContext::FunctionWithoutDebugInfo;\n     }\n \n@@ -432,6 +434,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                               mir: &MirContext,\n                                variable_name: ast::Name,\n                                variable_type: Ty<'tcx>,\n                                scope_metadata: DIScope,\n@@ -493,7 +496,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n     match variable_kind {\n         ArgumentVariable(_) | CapturedVariable => {\n-            assert!(!bcx.fcx().debug_context.get_ref(span).source_locations_enabled.get());\n+            assert!(!mir.debug_context.get_ref(span).source_locations_enabled.get());\n             source_loc::set_debug_location(cx, bcx, UnknownLocation);\n         }\n         _ => { /* nothing to do */ }"}, {"sha": "16b32f2e3d6352f6a91c090a03a5d131713f74f6", "filename": "src/librustc_trans/debuginfo/source_loc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fsource_loc.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -17,7 +17,8 @@ use super::FunctionDebugContext;\n use llvm;\n use llvm::debuginfo::DIScope;\n use builder::Builder;\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n+use mir::MirContext;\n \n use libc::c_uint;\n use std::ptr;\n@@ -26,24 +27,24 @@ use syntax_pos::{Span, Pos};\n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...).\n-pub fn set_source_location(fcx: &FunctionContext, builder: &Builder, scope: DIScope, span: Span) {\n-    let function_debug_context = match fcx.debug_context {\n+pub fn set_source_location(mir: &MirContext, builder: &Builder, scope: DIScope, span: Span) {\n+    let function_debug_context = match mir.debug_context {\n         FunctionDebugContext::DebugInfoDisabled => return,\n         FunctionDebugContext::FunctionWithoutDebugInfo => {\n-            set_debug_location(fcx.ccx, builder, UnknownLocation);\n+            set_debug_location(mir.ccx(), builder, UnknownLocation);\n             return;\n         }\n         FunctionDebugContext::RegularContext(ref data) => data\n     };\n \n     let dbg_loc = if function_debug_context.source_locations_enabled.get() {\n-        debug!(\"set_source_location: {}\", fcx.ccx.sess().codemap().span_to_string(span));\n-        let loc = span_start(fcx.ccx, span);\n+        debug!(\"set_source_location: {}\", mir.ccx().sess().codemap().span_to_string(span));\n+        let loc = span_start(mir.ccx(), span);\n         InternalDebugLocation::new(scope, loc.line, loc.col.to_usize())\n     } else {\n         UnknownLocation\n     };\n-    set_debug_location(fcx.ccx, builder, dbg_loc);\n+    set_debug_location(mir.ccx(), builder, dbg_loc);\n }\n \n /// Enables emitting source locations for the given functions.\n@@ -52,8 +53,8 @@ pub fn set_source_location(fcx: &FunctionContext, builder: &Builder, scope: DISc\n /// they are disabled when beginning to translate a new function. This functions\n /// switches source location emitting on and must therefore be called before the\n /// first real statement/expression of the function is translated.\n-pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n-    match fcx.debug_context {\n+pub fn start_emitting_source_locations(mir: &MirContext) {\n+    match mir.debug_context {\n         FunctionDebugContext::RegularContext(ref data) => {\n             data.source_locations_enabled.set(true)\n         },"}, {"sha": "83a45b7a41e3e100728a676f8302c71416641ee0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -20,6 +20,7 @@ use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use common::{self, BlockAndBuilder, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n+use debuginfo;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n use meth;\n@@ -114,7 +115,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let span = terminator.source_info.span;\n         let (scope, debug_span) = self.debug_loc(terminator.source_info);\n-        bcx.set_source_location(scope, debug_span);\n+        debuginfo::set_source_location(self, &bcx, scope, debug_span);\n         match terminator.kind {\n             mir::TerminatorKind::Resume => {\n                 if let Some(cleanup_pad) = cleanup_pad {\n@@ -326,7 +327,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // After this point, bcx is the block for the call to panic.\n                 bcx = panic_block;\n-                bcx.set_source_location(scope, debug_span);\n+                debuginfo::set_source_location(self, &bcx, scope, debug_span);\n \n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n@@ -642,7 +643,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     if let Some((_, target)) = *destination {\n                         let ret_bcx = self.build_block(target);\n                         ret_bcx.at_start(|ret_bcx| {\n-                            bcx.set_source_location(scope, debug_span);\n+                            debuginfo::set_source_location(self, &ret_bcx, scope, debug_span);\n                             let op = OperandRef {\n                                 val: Immediate(invokeret),\n                                 ty: sig.output(),"}, {"sha": "f1fe38d7b0c5fb83904170a7825a1a3d6fdc9937", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -18,11 +18,13 @@ use session::config::FullDebugInfo;\n use base;\n use common::{self, BlockAndBuilder, CrateContext, FunctionContext, C_null, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n+use monomorphize::Instance;\n use machine;\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos, Span};\n use syntax::symbol::keywords;\n+use syntax::abi::Abi;\n \n use std::iter;\n \n@@ -38,7 +40,9 @@ use self::operand::{OperandRef, OperandValue};\n \n /// Master context for translating MIR.\n pub struct MirContext<'a, 'tcx:'a> {\n-    mir: &'a mir::Mir<'tcx>,\n+    pub mir: &'a mir::Mir<'tcx>,\n+\n+    pub debug_context: debuginfo::FunctionDebugContext,\n \n     /// Function context\n     fcx: &'a common::FunctionContext<'a, 'tcx>,\n@@ -89,7 +93,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> (DIScope, Span) {\n         // Bail out if debug info emission is not enabled.\n-        match self.fcx.debug_context {\n+        match self.debug_context {\n             FunctionDebugContext::DebugInfoDisabled |\n             FunctionDebugContext::FunctionWithoutDebugInfo => {\n                 return (self.scopes[source_info.scope].scope_metadata, source_info.span);\n@@ -142,6 +146,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             scope_metadata\n         }\n     }\n+\n+    pub fn ccx(&self) -> &'a CrateContext<'a, 'tcx> {\n+        self.fcx.ccx\n+    }\n }\n \n enum LocalRef<'tcx> {\n@@ -176,7 +184,26 @@ impl<'tcx> LocalRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<'tcx>) {\n+pub fn trans_mir<'a, 'tcx: 'a>(\n+    fcx: &'a FunctionContext<'a, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    instance: Instance<'tcx>,\n+    sig: &ty::FnSig<'tcx>,\n+    abi: Abi,\n+) {\n+    let def_id = instance.def;\n+    let local_id = fcx.ccx.tcx().map.as_local_node_id(def_id);\n+    let no_debug = if let Some(id) = local_id {\n+        fcx.ccx.tcx().map.attrs(id).iter().any(|item| item.check_name(\"no_debug\"))\n+    } else {\n+        fcx.ccx.sess().cstore.item_attrs(def_id).iter().any(|item| item.check_name(\"no_debug\"))\n+    };\n+\n+    let debug_context = if !no_debug {\n+        debuginfo::create_function_debug_context(fcx.ccx, instance, sig, abi, fcx.llfn, mir)\n+    } else {\n+        debuginfo::empty_function_debug_context(fcx.ccx)\n+    };\n     let bcx = fcx.get_entry_block();\n \n     // Analyze the temps to determine which must be lvalues\n@@ -195,7 +222,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(fcx, mir);\n+    let scopes = debuginfo::create_mir_scopes(fcx, mir, &debug_context);\n \n     let mut mircx = MirContext {\n         mir: mir,\n@@ -207,11 +234,12 @@ pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<\n         landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n         scopes: scopes,\n         locals: IndexVec::new(),\n+        debug_context: debug_context,\n     };\n \n     // Allocate variable and temp allocas\n     mircx.locals = {\n-        let args = arg_local_refs(&bcx, &mir, &mircx.scopes, &lvalue_locals);\n+        let args = arg_local_refs(&bcx, &mircx, &mircx.scopes, &lvalue_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n@@ -232,7 +260,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<\n                 let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(source_info);\n-                    declare_local(&bcx, name, ty, scope,\n+                    declare_local(&bcx, &mircx, name, ty, scope,\n                         VariableAccess::DirectVariable { alloca: lvalue.llval },\n                         VariableKind::LocalVariable, span);\n                 }\n@@ -270,7 +298,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<\n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n-    debuginfo::start_emitting_source_locations(fcx);\n+    debuginfo::start_emitting_source_locations(&mircx);\n \n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n@@ -308,10 +336,11 @@ pub fn trans_mir<'a, 'tcx: 'a>(fcx: &'a FunctionContext<'a, 'tcx>, mir: &'a Mir<\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                            mir: &mir::Mir<'tcx>,\n+                            mircx: &MirContext<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                             lvalue_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n+    let mir = mircx.mir;\n     let fcx = bcx.fcx();\n     let tcx = bcx.tcx();\n     let mut idx = 0;\n@@ -363,7 +392,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 let variable_access = VariableAccess::DirectVariable {\n                     alloca: lltemp\n                 };\n-                declare_local(bcx, arg_decl.name.unwrap_or(keywords::Invalid.name()),\n+                declare_local(bcx, mircx, arg_decl.name.unwrap_or(keywords::Invalid.name()),\n                               arg_ty, scope, variable_access,\n                               VariableKind::ArgumentVariable(arg_index + 1),\n                               DUMMY_SP);\n@@ -435,7 +464,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         arg_scope.map(|scope| {\n             // Is this a regular argument?\n             if arg_index > 0 || mir.upvar_decls.is_empty() {\n-                declare_local(bcx, arg_decl.name.unwrap_or(keywords::Invalid.name()), arg_ty,\n+                declare_local(bcx, mircx, arg_decl.name.unwrap_or(keywords::Invalid.name()), arg_ty,\n                               scope, VariableAccess::DirectVariable { alloca: llval },\n                               VariableKind::ArgumentVariable(arg_index + 1),\n                               DUMMY_SP);\n@@ -503,7 +532,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                     alloca: env_ptr,\n                     address_operations: &ops\n                 };\n-                declare_local(bcx, decl.debug_name, ty, scope, variable_access,\n+                declare_local(bcx, mircx, decl.debug_name, ty, scope, variable_access,\n                               VariableKind::CapturedVariable,\n                               DUMMY_SP);\n             }"}, {"sha": "62ee768ab075445930add3642615bd2187eda817", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b9a0efef470fd061c70592892f6e40844415344/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=2b9a0efef470fd061c70592892f6e40844415344", "patch": "@@ -11,6 +11,7 @@\n use rustc::mir;\n \n use base;\n+use debuginfo;\n use common::{self, BlockAndBuilder};\n \n use super::MirContext;\n@@ -26,7 +27,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n         let (scope, span) = self.debug_loc(statement.source_info);\n-        bcx.set_source_location(scope, span);\n+        debuginfo::set_source_location(self, &bcx, scope, span);\n         match statement.kind {\n             mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n                 if let mir::Lvalue::Local(index) = *lvalue {"}]}