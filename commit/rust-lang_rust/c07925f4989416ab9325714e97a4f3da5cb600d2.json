{"sha": "c07925f4989416ab9325714e97a4f3da5cb600d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNzkyNWY0OTg5NDE2YWI5MzI1NzE0ZTk3YTRmM2RhNWNiNjAwZDI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-12T23:55:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-12T23:55:33Z"}, "message": "Merge pull request #1647 from topecongiro/refactor-impl-format\n\nRefactor impl format", "tree": {"sha": "f36d48968b377edf5cf01ab923afa4034a2f3b30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f36d48968b377edf5cf01ab923afa4034a2f3b30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c07925f4989416ab9325714e97a4f3da5cb600d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c07925f4989416ab9325714e97a4f3da5cb600d2", "html_url": "https://github.com/rust-lang/rust/commit/c07925f4989416ab9325714e97a4f3da5cb600d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c07925f4989416ab9325714e97a4f3da5cb600d2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ed3077651f6e6672df922181a7f5ce5289c74e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed3077651f6e6672df922181a7f5ce5289c74e1", "html_url": "https://github.com/rust-lang/rust/commit/6ed3077651f6e6672df922181a7f5ce5289c74e1"}, {"sha": "62e9473d07ec9a35e1c1e63140381055d86bb478", "url": "https://api.github.com/repos/rust-lang/rust/commits/62e9473d07ec9a35e1c1e63140381055d86bb478", "html_url": "https://github.com/rust-lang/rust/commit/62e9473d07ec9a35e1c1e63140381055d86bb478"}], "stats": {"total": 882, "additions": 675, "deletions": 207}, "files": [{"sha": "40c678174a8c08698a86f50c21bed0a847ca8ffa", "filename": "src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -2089,12 +2089,12 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     // FIXME if context.config.struct_lit_style() == Visual, but we run out\n     // of space, we should fall back to BlockIndent.\n }\n+\n pub fn struct_lit_field_separator(config: &Config) -> &str {\n     colon_spaces(config.space_before_struct_lit_field_colon(),\n                  config.space_after_struct_lit_field_colon())\n }\n \n-\n fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n     let name = &field.ident.node.to_string();\n     if field.is_shorthand {"}, {"sha": "020f04e30f392fa5ad79a9deb917d472534c91c9", "filename": "src/items.rs", "status": "modified", "additions": 206, "deletions": 125, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -16,12 +16,13 @@ use utils::{format_mutability, format_visibility, contains_skip, end_typaram, wr\n             last_line_width, format_unsafety, trim_newlines, stmt_expr, semicolon_for_expr,\n             trimmed_last_line_width, colon_spaces, mk_sp};\n use lists::{write_list, itemize_list, ListItem, ListFormatting, SeparatorTactic, list_helper,\n-            DefinitiveListTactic, ListTactic, definitive_tactic, format_item_list};\n+            DefinitiveListTactic, ListTactic, definitive_tactic};\n use expr::{is_empty_block, is_simple_block_stmt, rewrite_assign_rhs};\n use comment::{FindUncommented, contains_comment, rewrite_comment, recover_comment_removed};\n use visitor::FmtVisitor;\n use rewrite::{Rewrite, RewriteContext};\n-use config::{Config, IndentStyle, Density, ReturnIndent, BraceStyle, Style, TypeDensity};\n+use config::{Config, IndentStyle, Density, ReturnIndent, BraceStyle, Style};\n+use types::join_bounds;\n \n use syntax::{ast, abi, ptr, symbol};\n use syntax::codemap::{Span, BytePos};\n@@ -527,23 +528,20 @@ pub fn format_impl(context: &RewriteContext,\n                    offset: Indent,\n                    where_span_end: Option<BytePos>)\n                    -> Option<String> {\n-    if let ast::ItemKind::Impl(_, _, _, ref generics, ref trait_ref, _, ref items) = item.node {\n+    if let ast::ItemKind::Impl(_, _, _, ref generics, _, _, ref items) = item.node {\n         let mut result = String::new();\n-        // First try to format the ref and type without a split at the 'for'.\n-        let mut ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset, false));\n-\n-        // If there is a line break present in the first result format it again\n-        // with a split at the 'for'. Skip this if there is no trait ref and\n-        // therefore no 'for'.\n-        if ref_and_type.contains('\\n') && trait_ref.is_some() {\n-            ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset, true));\n-        }\n+        let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n         result.push_str(&ref_and_type);\n \n-        let where_budget = try_opt!(context\n-                                        .config\n-                                        .max_width()\n-                                        .checked_sub(last_line_width(&result)));\n+        let where_budget = if result.contains('\\n') {\n+            context.config.max_width()\n+        } else {\n+            context\n+                .config\n+                .max_width()\n+                .checked_sub(last_line_width(&result))\n+                .unwrap_or(0)\n+        };\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n                                                              context.config.item_brace_style(),\n@@ -644,8 +642,7 @@ fn is_impl_single_line(context: &RewriteContext,\n \n fn format_impl_ref_and_type(context: &RewriteContext,\n                             item: &ast::Item,\n-                            offset: Indent,\n-                            split_at_for: bool)\n+                            offset: Indent)\n                             -> Option<String> {\n     if let ast::ItemKind::Impl(unsafety,\n                                polarity,\n@@ -665,69 +662,133 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n             Some(ref tr) => tr.path.span.lo,\n             None => self_ty.span.lo,\n         };\n-        let generics_indent = offset + last_line_width(&result);\n-        let shape = Shape::indented(generics_indent, context.config);\n-        let generics_str = try_opt!(rewrite_generics(context, generics, shape, mk_sp(lo, hi)));\n-        result.push_str(&generics_str);\n-\n-        if polarity == ast::ImplPolarity::Negative {\n-            result.push_str(\" !\");\n-        }\n-        if let Some(ref trait_ref) = *trait_ref {\n-            if polarity != ast::ImplPolarity::Negative {\n-                result.push_str(\" \");\n-            }\n-            let used_space = last_line_width(&result);\n-            let budget = try_opt!(context.config.max_width().checked_sub(used_space));\n-            let indent = offset + used_space;\n-            result.push_str(&*try_opt!(trait_ref.rewrite(context, Shape::legacy(budget, indent))));\n-\n-            if split_at_for {\n-                result.push('\\n');\n+        let shape = generics_shape_from_config(context.config,\n+                                               Shape::indented(offset + last_line_width(&result),\n+                                                               context.config),\n+                                               0);\n+        let generics_str =\n+            try_opt!(rewrite_generics_inner(context, generics, shape, shape.width, mk_sp(lo, hi)));\n \n-                // Add indentation of one additional tab.\n-                let width = offset.block_indent + context.config.tab_spaces();\n-                let for_indent = Indent::new(0, width);\n-                result.push_str(&for_indent.to_string(context.config));\n+        let polarity_str = if polarity == ast::ImplPolarity::Negative {\n+            \"!\"\n+        } else {\n+            \"\"\n+        };\n \n-                result.push_str(\"for\");\n+        if let Some(ref trait_ref) = *trait_ref {\n+            let result_len = result.len();\n+            if let Some(trait_ref_str) =\n+                rewrite_trait_ref(context,\n+                                  &trait_ref,\n+                                  offset,\n+                                  &generics_str,\n+                                  true,\n+                                  polarity_str,\n+                                  result_len) {\n+                result.push_str(&trait_ref_str);\n             } else {\n-                result.push_str(\" for\");\n+                let generics_str =\n+                    try_opt!(rewrite_generics_inner(context, generics, shape, 0, mk_sp(lo, hi)));\n+                result.push_str(&try_opt!(rewrite_trait_ref(context,\n+                                                            &trait_ref,\n+                                                            offset,\n+                                                            &generics_str,\n+                                                            false,\n+                                                            polarity_str,\n+                                                            result_len)));\n             }\n+        } else {\n+            result.push_str(&generics_str);\n         }\n \n-        let mut used_space = last_line_width(&result);\n-        if generics.where_clause.predicates.is_empty() {\n+        // Try to put the self type in a single line.\n+        // ` for`\n+        let trait_ref_overhead = if trait_ref.is_some() { 4 } else { 0 };\n+        let curly_brace_overhead = if generics.where_clause.predicates.is_empty() {\n             // If there is no where clause adapt budget for type formatting to take space and curly\n             // brace into account.\n             match context.config.item_brace_style() {\n-                BraceStyle::AlwaysNextLine => {}\n-                BraceStyle::PreferSameLine => used_space += 2,\n-                BraceStyle::SameLineWhere => used_space += 2,\n+                BraceStyle::AlwaysNextLine => 0,\n+                _ => 2,\n             }\n-        }\n-\n+        } else {\n+            0\n+        };\n+        let used_space = last_line_width(&result) + trait_ref_overhead + curly_brace_overhead;\n         // 1 = space before the type.\n-        let budget = try_opt!(context.config.max_width().checked_sub(used_space + 1));\n-        let indent = offset + result.len() + 1;\n-        let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n-        if let Some(self_ty_str) = self_ty_str {\n-            result.push_str(\" \");\n-            result.push_str(&self_ty_str);\n-            return Some(result);\n+        let budget = context\n+            .config\n+            .max_width()\n+            .checked_sub(used_space + 1)\n+            .unwrap_or(0);\n+        if let Some(self_ty_str) = self_ty.rewrite(context, Shape::legacy(budget, offset)) {\n+            if !self_ty_str.contains('\\n') {\n+                if trait_ref.is_some() {\n+                    result.push_str(\" for \");\n+                } else {\n+                    result.push(' ');\n+                }\n+                result.push_str(&self_ty_str);\n+                return Some(result);\n+            }\n         }\n \n-        // Can't fit the self type on what's left of the line, so start a new one.\n-        let indent = offset.block_indent(context.config);\n-        result.push_str(&format!(\"\\n{}\", indent.to_string(context.config)));\n-        result.push_str(&*try_opt!(self_ty.rewrite(context,\n-                                                   Shape::indented(indent, context.config))));\n+        // Couldn't fit the self type on a single line, put it on a new line.\n+        result.push('\\n');\n+        // Add indentation of one additional tab.\n+        let new_line_offset = offset.block_indent(context.config);\n+        result.push_str(&new_line_offset.to_string(context.config));\n+        if trait_ref.is_some() {\n+            result.push_str(\"for \");\n+        }\n+        let budget = context.config.max_width() - last_line_width(&result);\n+        let type_offset = match context.config.where_style() {\n+            Style::Legacy => new_line_offset + trait_ref_overhead,\n+            Style::Rfc => new_line_offset,\n+        };\n+        result.push_str(&*try_opt!(self_ty.rewrite(context, Shape::legacy(budget, type_offset))));\n         Some(result)\n     } else {\n         unreachable!();\n     }\n }\n \n+fn rewrite_trait_ref(context: &RewriteContext,\n+                     trait_ref: &ast::TraitRef,\n+                     offset: Indent,\n+                     generics_str: &str,\n+                     retry: bool,\n+                     polarity_str: &str,\n+                     result_len: usize)\n+                     -> Option<String> {\n+    // 1 = space between generics and trait_ref\n+    let used_space = 1 + polarity_str.len() +\n+                     if generics_str.contains('\\n') {\n+                         last_line_width(&generics_str)\n+                     } else {\n+                         result_len + generics_str.len()\n+                     };\n+    let shape = Shape::indented(offset + used_space, context.config);\n+    if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n+        if !(retry && trait_ref_str.contains('\\n')) {\n+            return Some(format!(\"{} {}{}\", generics_str, polarity_str, &trait_ref_str));\n+        }\n+    }\n+    // We could not make enough space for trait_ref, so put it on new line.\n+    if !retry {\n+        let offset = offset.block_indent(context.config);\n+        let shape = Shape::indented(offset, context.config);\n+        let trait_ref_str = try_opt!(trait_ref.rewrite(context, shape));\n+        Some(format!(\"{}\\n{}{}{}\",\n+                     generics_str,\n+                     &offset.to_string(context.config),\n+                     polarity_str,\n+                     &trait_ref_str))\n+    } else {\n+        None\n+    }\n+}\n+\n pub fn format_struct(context: &RewriteContext,\n                      item_name: &str,\n                      ident: ast::Ident,\n@@ -777,8 +838,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let body_lo = context.codemap.span_after(item.span, \"{\");\n \n-        let generics_indent = offset + last_line_width(&result);\n-        let shape = Shape::indented(generics_indent, context.config);\n+        let shape = Shape::indented(offset + last_line_width(&result), context.config);\n         let generics_str =\n             try_opt!(rewrite_generics(context, generics, shape, mk_sp(item.span.lo, body_lo)));\n         result.push_str(&generics_str);\n@@ -1024,10 +1084,9 @@ fn format_tuple_struct(context: &RewriteContext,\n \n     let where_clause_str = match generics {\n         Some(generics) => {\n-            let generics_indent = offset + last_line_width(&header_str);\n-            let shape = Shape::indented(generics_indent, context.config);\n-            let generics_str =\n-                try_opt!(rewrite_generics(context, generics, shape, mk_sp(span.lo, body_lo)));\n+            let shape = Shape::indented(offset + last_line_width(&header_str), context.config);\n+            let g_span = mk_sp(span.lo, body_lo);\n+            let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n             result.push_str(&generics_str);\n \n             let where_budget = try_opt!(context\n@@ -1154,11 +1213,10 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     result.push_str(\"type \");\n     result.push_str(&ident.to_string());\n \n-    let generics_indent = indent + result.len();\n-    let generics_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo);\n-    let shape = try_opt!(Shape::indented(generics_indent, context.config).sub_width(\" =\".len()));\n-    let generics_str = try_opt!(rewrite_generics(context, generics, shape, generics_span));\n-\n+    // 2 = `= `\n+    let shape = try_opt!(Shape::indented(indent + result.len(), context.config).sub_width(2));\n+    let g_span = mk_sp(context.codemap.span_after(span, \"type\"), ty.span.lo);\n+    let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n     let where_budget = try_opt!(context\n@@ -1392,23 +1450,14 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n     let prefix = format!(\"type {}\", ident);\n \n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n-        let joiner = match context.config.type_punctuation_density() {\n-            TypeDensity::Compressed => \"+\",\n-            TypeDensity::Wide => \" + \",\n-        };\n+        let shape = Shape::legacy(context.config.max_width(), indent);\n         let bounds: &[_] = ty_param_bounds;\n-        let bound_str =\n-            try_opt!(bounds\n-                         .iter()\n-                         .map(|ty_bound| {\n-                                  ty_bound.rewrite(context,\n-                                                   Shape::legacy(context.config.max_width(),\n-                                                                 indent))\n-                              })\n-                         .collect::<Option<Vec<_>>>())\n-                .join(joiner);\n+        let bound_str = try_opt!(bounds\n+                                     .iter()\n+                                     .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                                     .collect::<Option<Vec<_>>>());\n         if bounds.len() > 0 {\n-            format!(\": {}\", bound_str)\n+            format!(\": {}\", join_bounds(context, shape, &bound_str))\n         } else {\n             String::new()\n         }\n@@ -1633,10 +1682,9 @@ fn rewrite_fn_base(context: &RewriteContext,\n     result.push_str(&ident.to_string());\n \n     // Generics.\n-    let generics_indent = indent + last_line_width(&result);\n-    let generics_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n-    let shape = Shape::indented(generics_indent, context.config);\n-    let generics_str = try_opt!(rewrite_generics(context, generics, shape, generics_span));\n+    let shape = Shape::indented(indent + last_line_width(&result), context.config);\n+    let g_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n+    let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n     result.push_str(&generics_str);\n \n     let snuggle_angle_bracket = generics_str\n@@ -2109,6 +2157,17 @@ fn rewrite_generics(context: &RewriteContext,\n                     shape: Shape,\n                     span: Span)\n                     -> Option<String> {\n+    let shape = generics_shape_from_config(context.config, shape, 0);\n+    rewrite_generics_inner(context, generics, shape, shape.width, span)\n+        .or_else(|| rewrite_generics_inner(context, generics, shape, 0, span))\n+}\n+\n+fn rewrite_generics_inner(context: &RewriteContext,\n+                          generics: &ast::Generics,\n+                          shape: Shape,\n+                          one_line_width: usize,\n+                          span: Span)\n+                          -> Option<String> {\n     // FIXME: convert bounds to where clauses where they get too big or if\n     // there is a where clause at all.\n     let lifetimes: &[_] = &generics.lifetimes;\n@@ -2117,21 +2176,9 @@ fn rewrite_generics(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    let offset = match context.config.generics_indent() {\n-        IndentStyle::Block => shape.indent.block_only().block_indent(context.config),\n-        // 1 = <\n-        IndentStyle::Visual => shape.indent + 1,\n-    };\n-\n-    let h_budget = try_opt!(shape.width.checked_sub(2));\n-    // FIXME: might need to insert a newline if the generics are really long.\n-\n     // Strings for the generics.\n-    let lt_strs = lifetimes\n-        .iter()\n-        .map(|lt| lt.rewrite(context, Shape::legacy(h_budget, offset)));\n-    let ty_strs = tys.iter()\n-        .map(|ty_param| ty_param.rewrite(context, Shape::legacy(h_budget, offset)));\n+    let lt_strs = lifetimes.iter().map(|lt| lt.rewrite(context, shape));\n+    let ty_strs = tys.iter().map(|ty_param| ty_param.rewrite(context, shape));\n \n     // Extract comments between generics.\n     let lt_spans = lifetimes.iter().map(|l| {\n@@ -2153,21 +2200,64 @@ fn rewrite_generics(context: &RewriteContext,\n                              |&(_, ref str)| str.clone(),\n                              context.codemap.span_after(span, \"<\"),\n                              span.hi);\n-    let list_str =\n-        try_opt!(format_item_list(items, Shape::legacy(h_budget, offset), context.config));\n+    format_generics_item_list(context, items, shape, one_line_width)\n+}\n+\n+pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize) -> Shape {\n+    Shape {\n+        // 2 = `<>`\n+        width: shape.width.checked_sub(offset + 2).unwrap_or(0),\n+        ..match config.generics_indent() {\n+              IndentStyle::Visual => shape.visual_indent(1 + offset),\n+              IndentStyle::Block => shape.block().block_indent(config.tab_spaces()),\n+          }\n+    }\n+}\n+\n+pub fn format_generics_item_list<I>(context: &RewriteContext,\n+                                    items: I,\n+                                    shape: Shape,\n+                                    one_line_budget: usize)\n+                                    -> Option<String>\n+    where I: Iterator<Item = ListItem>\n+{\n+    let item_vec = items.collect::<Vec<_>>();\n+\n+    let fmt = ListFormatting {\n+        tactic: definitive_tactic(&item_vec, ListTactic::HorizontalVertical, one_line_budget),\n+        separator: \",\",\n+        trailing_separator: if context.config.generics_indent() == IndentStyle::Visual {\n+            SeparatorTactic::Never\n+        } else {\n+            context.config.trailing_comma()\n+        },\n+        shape: shape,\n+        ends_with_newline: false,\n+        config: context.config,\n+    };\n \n-    let result = if context.config.generics_indent() != IndentStyle::Visual &&\n-                    list_str.contains('\\n') {\n+    let list_str = try_opt!(write_list(&item_vec, &fmt));\n+\n+    Some(wrap_generics_with_angle_brackets(context, &list_str, shape.indent))\n+}\n+\n+pub fn wrap_generics_with_angle_brackets(context: &RewriteContext,\n+                                         list_str: &str,\n+                                         list_offset: Indent)\n+                                         -> String {\n+    if context.config.generics_indent() == IndentStyle::Block &&\n+       (list_str.contains('\\n') || list_str.ends_with(',')) {\n         format!(\"<\\n{}{}\\n{}>\",\n-                offset.to_string(context.config),\n+                list_offset.to_string(context.config),\n                 list_str,\n-                shape.indent.block_only().to_string(context.config))\n+                list_offset\n+                    .block_unindent(context.config)\n+                    .to_string(context.config))\n     } else if context.config.spaces_within_angle_brackets() {\n         format!(\"< {} >\", list_str)\n     } else {\n         format!(\"<{}>\", list_str)\n-    };\n-    Some(result)\n+    }\n }\n \n fn rewrite_trait_bounds(context: &RewriteContext,\n@@ -2179,20 +2269,11 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     if bounds.is_empty() {\n         return Some(String::new());\n     }\n-    let joiner = match context.config.type_punctuation_density() {\n-        TypeDensity::Compressed => \"+\",\n-        TypeDensity::Wide => \" + \",\n-    };\n     let bound_str = try_opt!(bounds\n                                  .iter()\n                                  .map(|ty_bound| ty_bound.rewrite(&context, shape))\n-                                 .collect::<Option<Vec<_>>>())\n-        .join(joiner);\n-\n-    let mut result = String::new();\n-    result.push_str(\": \");\n-    result.push_str(&bound_str);\n-    Some(result)\n+                                 .collect::<Option<Vec<_>>>());\n+    Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))\n }\n \n fn rewrite_where_clause_rfc_style(context: &RewriteContext,"}, {"sha": "d2405f390f1d2e0d93a9fc07793c9d1b030c49e3", "filename": "src/types.rs", "status": "modified", "additions": 53, "deletions": 72, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -19,9 +19,10 @@ use syntax::symbol::keywords;\n \n use {Shape, Spanned};\n use codemap::SpanUtils;\n-use lists::{format_item_list, itemize_list, format_fn_args};\n+use items::{format_generics_item_list, generics_shape_from_config};\n+use lists::{itemize_list, format_fn_args};\n use rewrite::{Rewrite, RewriteContext};\n-use utils::{extra_offset, format_mutability, colon_spaces, wrap_str, mk_sp};\n+use utils::{extra_offset, format_mutability, colon_spaces, wrap_str, mk_sp, last_line_width};\n use expr::{rewrite_unary_prefix, rewrite_pair, rewrite_tuple_type};\n use config::TypeDensity;\n \n@@ -213,31 +214,25 @@ fn rewrite_segment(path_context: PathContext,\n                     \"\"\n                 };\n \n-                // 1 for <\n-                let extra_offset = 1 + separator.len();\n-                // 1 for >\n-                // TODO bad visual indent\n-                let list_shape = try_opt!(try_opt!(shape.shrink_left(extra_offset)).sub_width(1))\n-                    .visual_indent(0);\n-\n+                let generics_shape =\n+                    generics_shape_from_config(context.config, shape, separator.len());\n                 let items = itemize_list(context.codemap,\n                                          param_list.into_iter(),\n                                          \">\",\n                                          |param| param.get_span().lo,\n                                          |param| param.get_span().hi,\n-                                         |seg| seg.rewrite(context, list_shape),\n+                                         |seg| seg.rewrite(context, generics_shape),\n                                          list_lo,\n                                          span_hi);\n-                let list_str = try_opt!(format_item_list(items, list_shape, context.config));\n+                let generics_str = try_opt!(format_generics_item_list(context,\n+                                                                      items,\n+                                                                      generics_shape,\n+                                                                      generics_shape.width));\n \n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n \n-                if context.config.spaces_within_angle_brackets() && list_str.len() > 0 {\n-                    format!(\"{}< {} >\", separator, list_str)\n-                } else {\n-                    format!(\"{}<{}>\", separator, list_str)\n-                }\n+                format!(\"{}{}\", separator, generics_str)\n             }\n             ast::PathParameters::Parenthesized(ref data) => {\n                 let output = match data.output {\n@@ -367,22 +362,15 @@ impl Rewrite for ast::WherePredicate {\n                                                             .collect::<Option<Vec<_>>>())\n                         .join(\", \");\n \n-                    let joiner = match context.config.type_punctuation_density() {\n-                        TypeDensity::Compressed => \"+\",\n-                        TypeDensity::Wide => \" + \",\n-                    };\n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n-                    let budget = try_opt!(shape.width.checked_sub(used_width));\n-                    let bounds_str: String = try_opt!(\n-                        bounds\n-                            .iter()\n-                            .map(|ty_bound| {\n-                                ty_bound.rewrite(context,\n-                                                 Shape::legacy(budget, shape.indent + used_width))\n-                            })\n-                            .collect::<Option<Vec<_>>>()\n-                    ).join(joiner);\n+                    let ty_shape = try_opt!(shape.block_left(used_width));\n+                    let bounds: Vec<_> =\n+                        try_opt!(bounds\n+                                     .iter()\n+                                     .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n+                                     .collect());\n+                    let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n                     if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                         format!(\"for< {} > {}{}{}\",\n@@ -394,21 +382,14 @@ impl Rewrite for ast::WherePredicate {\n                         format!(\"for<{}> {}{}{}\", lifetime_str, type_str, colon, bounds_str)\n                     }\n                 } else {\n-                    let joiner = match context.config.type_punctuation_density() {\n-                        TypeDensity::Compressed => \"+\",\n-                        TypeDensity::Wide => \" + \",\n-                    };\n                     let used_width = type_str.len() + colon.len();\n-                    let budget = try_opt!(shape.width.checked_sub(used_width));\n-                    let bounds_str: String = try_opt!(\n-                        bounds\n-                            .iter()\n-                            .map(|ty_bound| {\n-                                ty_bound.rewrite(context,\n-                                                 Shape::legacy(budget, shape.indent + used_width))\n-                            })\n-                            .collect::<Option<Vec<_>>>()\n-                    ).join(joiner);\n+                    let ty_shape = try_opt!(shape.block_left(used_width));\n+                    let bounds: Vec<_> =\n+                        try_opt!(bounds\n+                                     .iter()\n+                                     .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n+                                     .collect());\n+                    let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n                     format!(\"{}{}{}\", type_str, colon, bounds_str)\n                 }\n@@ -463,11 +444,11 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n                                             .map(|b| b.rewrite(context, shape))\n                                             .collect());\n         let colon = type_bound_colon(context);\n-        let joiner = match context.config.type_punctuation_density() {\n-            TypeDensity::Compressed => \"+\",\n-            TypeDensity::Wide => \" + \",\n-        };\n-        let result = format!(\"{}{}{}\", result, colon, appendix.join(joiner));\n+        let overhead = last_line_width(&result) + colon.len();\n+        let result = format!(\"{}{}{}\",\n+                             result,\n+                             colon,\n+                             join_bounds(context, try_opt!(shape.sub_width(overhead)), &appendix));\n         wrap_str(result, context.config.max_width(), shape)\n     }\n }\n@@ -499,12 +480,8 @@ impl Rewrite for ast::Lifetime {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let joiner = match context.config.type_punctuation_density() {\n-            TypeDensity::Compressed => \"+\",\n-            TypeDensity::Wide => \" + \",\n-        };\n         let strs: Vec<_> = try_opt!(self.iter().map(|b| b.rewrite(context, shape)).collect());\n-        wrap_str(strs.join(joiner), context.config.max_width(), shape)\n+        join_bounds(context, shape, &strs).rewrite(context, shape)\n     }\n }\n \n@@ -519,24 +496,12 @@ impl Rewrite for ast::TyParam {\n         result.push_str(&attr_str);\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n-            if context.config.space_before_bound() {\n-                result.push_str(\" \");\n-            }\n-            result.push_str(\":\");\n-            if context.config.space_after_bound_colon() {\n-                result.push_str(\" \");\n-            }\n-            let joiner = match context.config.type_punctuation_density() {\n-                TypeDensity::Compressed => \"+\",\n-                TypeDensity::Wide => \" + \",\n-            };\n-            let bounds: String = try_opt!(self.bounds\n-                                              .iter()\n-                                              .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                                              .collect::<Option<Vec<_>>>())\n-                .join(joiner);\n-\n-            result.push_str(&bounds);\n+            result.push_str(type_bound_colon(context));\n+            let strs: Vec<_> = try_opt!(self.bounds\n+                                            .iter()\n+                                            .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                                            .collect());\n+            result.push_str(&join_bounds(context, shape, &strs));\n         }\n         if let Some(ref def) = self.default {\n \n@@ -737,3 +702,19 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n \n     Some(result)\n }\n+\n+pub fn join_bounds(context: &RewriteContext, shape: Shape, type_strs: &Vec<String>) -> String {\n+    // Try to join types in a single line\n+    let joiner = match context.config.type_punctuation_density() {\n+        TypeDensity::Compressed => \"+\",\n+        TypeDensity::Wide => \" + \",\n+    };\n+    let result = type_strs.join(joiner);\n+    if result.contains('\\n') || result.len() > shape.width {\n+        let joiner_indent = shape.indent.block_indent(context.config);\n+        let joiner = format!(\"\\n{}+ \", joiner_indent.to_string(context.config));\n+        type_strs.join(&joiner)\n+    } else {\n+        result\n+    }\n+}"}, {"sha": "167f654cc439a853aa422312b056c51535d43cf9", "filename": "tests/source/big-impl-rfc.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Fsource%2Fbig-impl-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Fsource%2Fbig-impl-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fbig-impl-rfc.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -0,0 +1,114 @@\n+// rustfmt-fn_args_layout: Block\n+// rustfmt-fn_call_style: Block\n+// rustfmt-generics_indent: Block\n+// rustfmt-where_style: Rfc\n+\n+// #1357\n+impl<\n+    'a,\n+    Select,\n+    From,\n+    Distinct,\n+    Where,\n+    Order,\n+    Limit,\n+    Offset,\n+    Groupby,\n+    DB,\n+> InternalBoxedDsl<'a, DB>\n+    for SelectStatement<\n+        Select,\n+        From,\n+        Distinct,\n+        Where,\n+        Order,\n+        Limit,\n+        Offset,\n+        GroupBy,\n+    > where\n+        DB: Backend,\n+        Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+        Distinct: QueryFragment<DB> + 'a,\n+        Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+        Order: QueryFragment<DB> + 'a,\n+        Limit: QueryFragment<DB> + 'a,\n+        Offset: QueryFragment<DB> + 'a,\n+{\n+    type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n+\n+    fn internal_into_boxed(self) -> Self::Output {\n+        BoxedSelectStatement::new(\n+            Box::new(self.select),\n+            self.from,\n+            Box::new(self.distinct),\n+            self.where_clause.into(),\n+            Box::new(self.order),\n+            Box::new(self.limit),\n+            Box::new(self.offset),\n+        )\n+    }\n+}\n+\n+// #1369\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo for Bar {\n+    fn foo() {}\n+}\n+impl Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}\n+impl Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}"}, {"sha": "c36b7e6cadb1acc5f3f90e471d12ae4767560c4d", "filename": "tests/source/big-impl.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Fsource%2Fbig-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Fsource%2Fbig-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fbig-impl.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -0,0 +1,104 @@\n+// #1357\n+impl<\n+    'a,\n+    Select,\n+    From,\n+    Distinct,\n+    Where,\n+    Order,\n+    Limit,\n+    Offset,\n+    Groupby,\n+    DB,\n+> InternalBoxedDsl<'a, DB>\n+    for SelectStatement<\n+        Select,\n+        From,\n+        Distinct,\n+        Where,\n+        Order,\n+        Limit,\n+        Offset,\n+        GroupBy,\n+    > where\n+        DB: Backend,\n+        Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+        Distinct: QueryFragment<DB> + 'a,\n+        Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+        Order: QueryFragment<DB> + 'a,\n+        Limit: QueryFragment<DB> + 'a,\n+        Offset: QueryFragment<DB> + 'a,\n+{\n+    type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n+\n+    fn internal_into_boxed(self) -> Self::Output {\n+        BoxedSelectStatement::new(\n+            Box::new(self.select),\n+            self.from,\n+            Box::new(self.distinct),\n+            self.where_clause.into(),\n+            Box::new(self.order),\n+            Box::new(self.limit),\n+            Box::new(self.offset),\n+        )\n+    }\n+}\n+\n+// #1369\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo for Bar {\n+    fn foo() {}\n+}\n+impl Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}\n+impl Foo<\n+    ExcessivelyLongGenericName,\n+      ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> for Bar<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> {\n+    fn foo() {}\n+}\n+impl<ExcessivelyLongGenericName,\n+     ExcessivelyLongGenericName,\n+     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n+                                            ExcessivelyLongGenericName,\n+                                            AnotherExcessivelyLongGenericName>\n+    for Bar<ExcessivelyLongGenericName,\n+            ExcessivelyLongGenericName,\n+            AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}"}, {"sha": "17588fb9d3500c87a2e317880f2cb45369a58024", "filename": "tests/source/impls.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Fsource%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Fsource%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fimpls.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -122,3 +122,20 @@ impl<ConcreteThreadSafeLayoutNode: ThreadSafeLayoutNodeFoo> Issue1249<ConcreteTh\n impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n     fn drop() {}\n }\n+\n+// #1168\n+pub trait Number: Copy + Eq +      Not<Output = Self> + Shl<u8, Output = Self> +\n+    Shr<u8, Output = Self>       +\n+    BitAnd<Self, Output=Self> +    BitOr<Self, Output=Self>  + BitAndAssign + BitOrAssign\n+\n+\n+\n+{\n+    // test\n+    fn zero() -> Self;\n+}\n+\n+// #1642\n+pub trait SomeTrait : Clone + Eq + PartialEq + Ord + PartialOrd + Default + Hash + Debug + Display + Write + Read + FromStr {\n+    // comment\n+}"}, {"sha": "108968faaed722507c52adb19ba2f1e8ec25ec6d", "filename": "tests/target/big-impl-rfc.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fbig-impl-rfc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fbig-impl-rfc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fbig-impl-rfc.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -0,0 +1,77 @@\n+// rustfmt-fn_args_layout: Block\n+// rustfmt-fn_call_style: Block\n+// rustfmt-generics_indent: Block\n+// rustfmt-where_style: Rfc\n+\n+// #1357\n+impl<'a, Select, From, Distinct, Where, Order, Limit, Offset, Groupby, DB> InternalBoxedDsl<'a, DB>\n+    for SelectStatement<Select, From, Distinct, Where, Order, Limit, Offset, GroupBy>\n+where\n+    DB: Backend,\n+    Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+    Distinct: QueryFragment<DB> + 'a,\n+    Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+    Order: QueryFragment<DB> + 'a,\n+    Limit: QueryFragment<DB> + 'a,\n+    Offset: QueryFragment<DB> + 'a,\n+{\n+    type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n+\n+    fn internal_into_boxed(self) -> Self::Output {\n+        BoxedSelectStatement::new(\n+            Box::new(self.select),\n+            self.from,\n+            Box::new(self.distinct),\n+            self.where_clause.into(),\n+            Box::new(self.order),\n+            Box::new(self.limit),\n+            Box::new(self.offset),\n+        )\n+    }\n+}\n+\n+// #1369\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+    for Bar {\n+    fn foo() {}\n+}\n+impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar {\n+    fn foo() {}\n+}\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+    for Bar<\n+        ExcessivelyLongGenericName,\n+        ExcessivelyLongGenericName,\n+        AnotherExcessivelyLongGenericName,\n+    > {\n+    fn foo() {}\n+}\n+impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar<\n+        ExcessivelyLongGenericName,\n+        ExcessivelyLongGenericName,\n+        AnotherExcessivelyLongGenericName,\n+    > {\n+    fn foo() {}\n+}\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar<\n+        ExcessivelyLongGenericName,\n+        ExcessivelyLongGenericName,\n+        AnotherExcessivelyLongGenericName,\n+    > {\n+    fn foo() {}\n+}"}, {"sha": "afe2571ec68608312651c47d3a8f5c1e370b71c5", "filename": "tests/target/big-impl.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fbig-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fbig-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fbig-impl.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -0,0 +1,62 @@\n+// #1357\n+impl<'a, Select, From, Distinct, Where, Order, Limit, Offset, Groupby, DB> InternalBoxedDsl<'a, DB>\n+    for SelectStatement<Select, From, Distinct, Where, Order, Limit, Offset, GroupBy>\n+    where DB: Backend,\n+          Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+          Distinct: QueryFragment<DB> + 'a,\n+          Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+          Order: QueryFragment<DB> + 'a,\n+          Limit: QueryFragment<DB> + 'a,\n+          Offset: QueryFragment<DB> + 'a\n+{\n+    type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n+\n+    fn internal_into_boxed(self) -> Self::Output {\n+        BoxedSelectStatement::new(Box::new(self.select),\n+                                  self.from,\n+                                  Box::new(self.distinct),\n+                                  self.where_clause.into(),\n+                                  Box::new(self.order),\n+                                  Box::new(self.limit),\n+                                  Box::new(self.offset))\n+    }\n+}\n+\n+// #1369\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+    for Bar {\n+    fn foo() {}\n+}\n+impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar {\n+    fn foo() {}\n+}\n+impl<ExcessivelyLongGenericName,\n+     ExcessivelyLongGenericName,\n+     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n+                                            ExcessivelyLongGenericName,\n+                                            AnotherExcessivelyLongGenericName> for Bar {\n+    fn foo() {}\n+}\n+impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n+    for Bar<ExcessivelyLongGenericName,\n+            ExcessivelyLongGenericName,\n+            AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}\n+impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar<ExcessivelyLongGenericName,\n+            ExcessivelyLongGenericName,\n+            AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}\n+impl<ExcessivelyLongGenericName,\n+     ExcessivelyLongGenericName,\n+     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n+                                            ExcessivelyLongGenericName,\n+                                            AnotherExcessivelyLongGenericName>\n+    for Bar<ExcessivelyLongGenericName,\n+            ExcessivelyLongGenericName,\n+            AnotherExcessivelyLongGenericName> {\n+    fn foo() {}\n+}"}, {"sha": "848e59c7c0ae05b1fbb3a09f50114307f0c70678", "filename": "tests/target/configs-generics_indent-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fconfigs-generics_indent-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fconfigs-generics_indent-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-generics_indent-block.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -8,7 +8,7 @@ fn lorem<\n     Amet: Eq = usize,\n     Adipiscing: Eq = usize,\n     Consectetur: Eq = usize,\n-    Elit: Eq = usize\n+    Elit: Eq = usize,\n >(ipsum: Ipsum,\n     dolor: Dolor,\n     sit: Sit,"}, {"sha": "f0923bd1a853bf694af7d05ac0476bcc7b27328f", "filename": "tests/target/fn-custom-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Ffn-custom-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Ffn-custom-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-custom-2.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -16,7 +16,7 @@ fn foo(\n fn bar<\n     'a: 'bbbbbbbbbbbbbbbbbbbbbbbbbbb,\n     TTTTTTTTTTTTT,\n-    UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW\n+    UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW,\n >(\n     a: Aaaaaaaaaaaaaaa,\n ) {\n@@ -51,7 +51,7 @@ impl Foo {\n     fn bar<\n         'a: 'bbbbbbbbbbbbbbbbbbbbbbbbbbb,\n         TTTTTTTTTTTTT,\n-        UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW\n+        UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW,\n     >(\n         a: Aaaaaaaaaaaaaaa,\n     ) {\n@@ -69,7 +69,7 @@ struct Foo<\n     TTTTTTTTTTTTTTTTTTTTTTTTTTTT,\n     UUUUUUUUUUUUUUUUUUUUUU,\n     VVVVVVVVVVVVVVVVVVVVVVVVVVV,\n-    WWWWWWWWWWWWWWWWWWWWWWWW\n+    WWWWWWWWWWWWWWWWWWWWWWWW,\n > {\n     foo: Foo,\n }"}, {"sha": "4d26c9b695192e2b01ddb58ed78178fa248fc882", "filename": "tests/target/fn-custom-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Ffn-custom-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Ffn-custom-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-custom-3.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -16,7 +16,7 @@ fn foo(\n fn bar<\n     'a: 'bbbbbbbbbbbbbbbbbbbbbbbbbbb,\n     TTTTTTTTTTTTT,\n-    UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW\n+    UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW,\n >(\n     a: Aaaaaaaaaaaaaaa,\n ) {\n@@ -53,7 +53,7 @@ impl Foo {\n     fn bar<\n         'a: 'bbbbbbbbbbbbbbbbbbbbbbbbbbb,\n         TTTTTTTTTTTTT,\n-        UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW\n+        UUUUUUUUUUUUUUUUUUUU: WWWWWWWWWWWWWWWWWWWWWWWW,\n     >(\n         a: Aaaaaaaaaaaaaaa,\n     ) {\n@@ -65,7 +65,7 @@ struct Foo<\n     TTTTTTTTTTTTTTTTTTTTTTTTTTTT,\n     UUUUUUUUUUUUUUUUUUUUUU,\n     VVVVVVVVVVVVVVVVVVVVVVVVVVV,\n-    WWWWWWWWWWWWWWWWWWWWWWWW\n+    WWWWWWWWWWWWWWWWWWWWWWWW,\n > {\n     foo: Foo,\n }"}, {"sha": "654d4be8967b6bbbde6f817a04971f3544fc0775", "filename": "tests/target/impls.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c07925f4989416ab9325714e97a4f3da5cb600d2/tests%2Ftarget%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fimpls.rs?ref=c07925f4989416ab9325714e97a4f3da5cb600d2", "patch": "@@ -126,8 +126,8 @@ mod m {\n     impl<T> PartialEq for S<T> where T: PartialEq {}\n }\n \n-impl<BorrowType, K, V, NodeType, HandleType> Handle<NodeRef<BorrowType, K, V, NodeType>,\n-                                                    HandleType> {\n+impl<BorrowType, K, V, NodeType, HandleType>\n+    Handle<NodeRef<BorrowType, K, V, NodeType>, HandleType> {\n }\n \n impl<BorrowType, K, V, NodeType, HandleType> PartialEq\n@@ -154,3 +154,35 @@ impl<ConcreteThreadSafeLayoutNode: ThreadSafeLayoutNodeFoo>\n impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n     fn drop() {}\n }\n+\n+// #1168\n+pub trait Number\n+    : Copy\n+    + Eq\n+    + Not<Output = Self>\n+    + Shl<u8, Output = Self>\n+    + Shr<u8, Output = Self>\n+    + BitAnd<Self, Output = Self>\n+    + BitOr<Self, Output = Self>\n+    + BitAndAssign\n+    + BitOrAssign {\n+    // test\n+    fn zero() -> Self;\n+}\n+\n+// #1642\n+pub trait SomeTrait\n+    : Clone\n+    + Eq\n+    + PartialEq\n+    + Ord\n+    + PartialOrd\n+    + Default\n+    + Hash\n+    + Debug\n+    + Display\n+    + Write\n+    + Read\n+    + FromStr {\n+    // comment\n+}"}]}