{"sha": "cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYmE0OTkyNzFiYTUzMTkwYTFkMzY0N2ZmOGY3MjAyZWM5ZWQ2ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-06T04:55:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-06T04:55:09Z"}, "message": "Auto merge of #81810 - m-ou-se:rollup-q3nborp, r=m-ou-se\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #80011 (Stabilize `peekable_next_if`)\n - #81580 (Document how `MaybeUninit<Struct>` can be initialized.)\n - #81610 (BTreeMap: make Ord bound explicit, compile-test its absence)\n - #81664 (Avoid a hir access inside get_static)\n - #81675 (Make rustdoc respect `--error-format short` in doctests)\n - #81753 (Never MIR inline functions with a different instruction set)\n - #81795 (Small refactor with Iterator::reduce)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "45d9515f968b1b05cd40ec5c2b5790eb78e1f0f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45d9515f968b1b05cd40ec5c2b5790eb78e1f0f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "html_url": "https://github.com/rust-lang/rust/commit/cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16b805713c4cdb967263b9d59634fddea4372b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/16b805713c4cdb967263b9d59634fddea4372b65", "html_url": "https://github.com/rust-lang/rust/commit/16b805713c4cdb967263b9d59634fddea4372b65"}, {"sha": "51c68034b9ced3b2cf51627474d382e562fd76d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/51c68034b9ced3b2cf51627474d382e562fd76d5", "html_url": "https://github.com/rust-lang/rust/commit/51c68034b9ced3b2cf51627474d382e562fd76d5"}], "stats": {"total": 566, "additions": 440, "deletions": 126}, "files": [{"sha": "aca3fbbca1357c14a5a6167b613b5b1b0e8b319b", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -74,7 +74,7 @@ pub enum InlineAttr {\n     Never,\n }\n \n-#[derive(Clone, Encodable, Decodable, Debug)]\n+#[derive(Clone, Encodable, Decodable, Debug, PartialEq, Eq)]\n pub enum InstructionSetAttr {\n     ArmA32,\n     ArmT32,"}, {"sha": "16e1a8a1242ae32c61c6f4ec3f16d41c21dfb593", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 24, "deletions": 56, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -8,17 +8,14 @@ use crate::value::Value;\n use libc::c_uint;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::const_cstr;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::interpret::{\n     read_target_uint, Allocation, ErrorHandled, GlobalAlloc, Pointer,\n };\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::{bug, span_bug};\n-use rustc_span::symbol::sym;\n use rustc_target::abi::{AddressSpace, Align, HasDataLayout, LayoutOf, Primitive, Scalar, Size};\n use tracing::debug;\n \n@@ -209,70 +206,42 @@ impl CodegenCx<'ll, 'tcx> {\n \n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let sym = self.tcx.symbol_name(instance).name;\n+        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n \n-        debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n+        debug!(\"get_static: sym={} instance={:?} fn_attrs={:?}\", sym, instance, fn_attrs);\n \n-        let g = if let Some(local_def_id) = def_id.as_local() {\n-            let id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let g = if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n             let llty = self.layout_of(ty).llvm_type(self);\n-            // FIXME: refactor this to work without accessing the HIR\n-            let (g, attrs) = match self.tcx.hir().get(id) {\n-                Node::Item(&hir::Item { attrs, kind: hir::ItemKind::Static(..), .. }) => {\n-                    if let Some(g) = self.get_declared_value(sym) {\n-                        if self.val_ty(g) != self.type_ptr_to(llty) {\n-                            span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n-                        }\n-                    }\n-\n-                    let g = self.declare_global(sym, llty);\n-\n-                    if !self.tcx.is_reachable_non_generic(local_def_id) {\n-                        unsafe {\n-                            llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n-                        }\n-                    }\n-\n-                    (g, attrs)\n+            if let Some(g) = self.get_declared_value(sym) {\n+                if self.val_ty(g) != self.type_ptr_to(llty) {\n+                    span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n                 }\n+            }\n \n-                Node::ForeignItem(&hir::ForeignItem {\n-                    ref attrs,\n-                    kind: hir::ForeignItemKind::Static(..),\n-                    ..\n-                }) => {\n-                    let fn_attrs = self.tcx.codegen_fn_attrs(local_def_id);\n-                    (check_and_apply_linkage(&self, &fn_attrs, ty, sym, def_id), &**attrs)\n-                }\n-\n-                item => bug!(\"get_static: expected static, found {:?}\", item),\n-            };\n-\n-            debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n+            let g = self.declare_global(sym, llty);\n \n-            for attr in attrs {\n-                if self.tcx.sess.check_name(attr, sym::thread_local) {\n-                    llvm::set_thread_local_mode(g, self.tls_model);\n+            if !self.tcx.is_reachable_non_generic(def_id) {\n+                unsafe {\n+                    llvm::LLVMRustSetVisibility(g, llvm::Visibility::Hidden);\n                 }\n             }\n \n             g\n         } else {\n-            // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-            debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym, def_id)\n+        };\n \n-            let attrs = self.tcx.codegen_fn_attrs(def_id);\n-            let g = check_and_apply_linkage(&self, &attrs, ty, sym, def_id);\n-\n-            // Thread-local statics in some other crate need to *always* be linked\n-            // against in a thread-local fashion, so we need to be sure to apply the\n-            // thread-local attribute locally if it was present remotely. If we\n-            // don't do this then linker errors can be generated where the linker\n-            // complains that one object files has a thread local version of the\n-            // symbol and another one doesn't.\n-            if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n-                llvm::set_thread_local_mode(g, self.tls_model);\n-            }\n+        // Thread-local statics in some other crate need to *always* be linked\n+        // against in a thread-local fashion, so we need to be sure to apply the\n+        // thread-local attribute locally if it was present remotely. If we\n+        // don't do this then linker errors can be generated where the linker\n+        // complains that one object files has a thread local version of the\n+        // symbol and another one doesn't.\n+        if fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+            llvm::set_thread_local_mode(g, self.tls_model);\n+        }\n \n+        if !def_id.is_local() {\n             let needs_dll_storage_attr = self.use_dll_storage_attrs && !self.tcx.is_foreign_item(def_id) &&\n                 // ThinLTO can't handle this workaround in all cases, so we don't\n                 // emit the attrs. Instead we make them unnecessary by disallowing\n@@ -304,8 +273,7 @@ impl CodegenCx<'ll, 'tcx> {\n                     }\n                 }\n             }\n-            g\n-        };\n+        }\n \n         if self.use_dll_storage_attrs && self.tcx.is_dllimport_foreign_item(def_id) {\n             // For foreign (native) libs we know the exact storage type to use."}, {"sha": "1635a95f46ec82493e3aba555f9e3023fd220b7e", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -281,6 +281,11 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n+        if self.codegen_fn_attrs.instruction_set != codegen_fn_attrs.instruction_set {\n+            debug!(\"`callee has incompatible instruction set - not inlining\");\n+            return false;\n+        }\n+\n         let hinted = match codegen_fn_attrs.inline {\n             // Just treat inline(always) as a hint for now,\n             // there are cases that prevent inlining that we"}, {"sha": "3b02f74f2ca1f00aa17cdbf8b228f0efa82fef3f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -1111,10 +1111,9 @@ impl<'a> Resolver<'a> {\n             _,\n         ) = binding.kind\n         {\n-            let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n+            let def_id = self.parent(ctor_def_id).expect(\"no parent for a constructor\");\n             let fields = self.field_names.get(&def_id)?;\n-            let first_field = fields.first()?; // Handle `struct Foo()`\n-            return Some(fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)));\n+            return fields.iter().map(|name| name.span).reduce(Span::to); // None for `struct Foo()`\n         }\n         None\n     }"}, {"sha": "946267d17c0188733631f3bcd72f6c13b09a3746", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -460,7 +460,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-impl<K: Ord, V> BTreeMap<K, V> {\n+impl<K, V> BTreeMap<K, V> {\n     /// Makes a new, empty `BTreeMap`.\n     ///\n     /// Does not allocate anything on its own.\n@@ -479,7 +479,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeMap<K, V> {\n+    pub const fn new() -> BTreeMap<K, V>\n+    where\n+        K: Ord,\n+    {\n         BTreeMap { root: None, length: 0 }\n     }\n \n@@ -498,7 +501,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        K: Ord,\n+    {\n         *self = BTreeMap::new();\n     }\n \n@@ -522,7 +528,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n@@ -550,7 +556,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"map_get_key_value\", since = \"1.40.0\")]\n     pub fn get_key_value<Q: ?Sized>(&self, k: &Q) -> Option<(&K, &V)>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_ref()?.reborrow();\n@@ -578,7 +584,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.first_key_value(), Some((&1, &\"b\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_key_value(&self) -> Option<(&K, &V)> {\n+    pub fn first_key_value(&self) -> Option<(&K, &V)>\n+    where\n+        K: Ord,\n+    {\n         let root_node = self.root.as_ref()?.reborrow();\n         root_node.first_leaf_edge().right_kv().ok().map(Handle::into_kv)\n     }\n@@ -604,7 +613,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"b\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+    pub fn first_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.first_leaf_edge().right_kv().ok()?;\n@@ -631,7 +643,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_first(&mut self) -> Option<(K, V)> {\n+    pub fn pop_first(&mut self) -> Option<(K, V)>\n+    where\n+        K: Ord,\n+    {\n         self.first_entry().map(|entry| entry.remove_entry())\n     }\n \n@@ -652,7 +667,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map.last_key_value(), Some((&2, &\"a\")));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_key_value(&self) -> Option<(&K, &V)> {\n+    pub fn last_key_value(&self) -> Option<(&K, &V)>\n+    where\n+        K: Ord,\n+    {\n         let root_node = self.root.as_ref()?.reborrow();\n         root_node.last_leaf_edge().left_kv().ok().map(Handle::into_kv)\n     }\n@@ -678,7 +696,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(*map.get(&2).unwrap(), \"last\");\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>> {\n+    pub fn last_entry(&mut self) -> Option<OccupiedEntry<'_, K, V>>\n+    where\n+        K: Ord,\n+    {\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = map.root.as_mut()?.borrow_mut();\n         let kv = root_node.last_leaf_edge().left_kv().ok()?;\n@@ -705,7 +726,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert!(map.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_last(&mut self) -> Option<(K, V)> {\n+    pub fn pop_last(&mut self) -> Option<(K, V)>\n+    where\n+        K: Ord,\n+    {\n         self.last_entry().map(|entry| entry.remove_entry())\n     }\n \n@@ -729,7 +753,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.get(key).is_some()\n@@ -758,7 +782,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let root_node = self.root.as_mut()?.borrow_mut();\n@@ -795,7 +819,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V>\n+    where\n+        K: Ord,\n+    {\n         match self.entry(key) {\n             Occupied(mut entry) => Some(entry.insert(value)),\n             Vacant(entry) => {\n@@ -827,7 +854,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.remove_entry(key).map(|(_, v)| v)\n@@ -854,7 +881,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btreemap_remove_entry\", since = \"1.45.0\")]\n     pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         let (map, dormant_map) = DormantMutRef::new(self);\n@@ -886,6 +913,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n+        K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         self.drain_filter(|k, v| !f(k, v));\n@@ -920,7 +948,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(a[&5], \"f\");\n     /// ```\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n+    pub fn append(&mut self, other: &mut Self)\n+    where\n+        K: Ord,\n+    {\n         // Do we have to append anything at all?\n         if other.is_empty() {\n             return;\n@@ -971,7 +1002,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>\n     where\n         T: Ord,\n-        K: Borrow<T>,\n+        K: Borrow<T> + Ord,\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &self.root {\n@@ -1017,7 +1048,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>\n     where\n         T: Ord,\n-        K: Borrow<T>,\n+        K: Borrow<T> + Ord,\n         R: RangeBounds<T>,\n     {\n         if let Some(root) = &mut self.root {\n@@ -1048,7 +1079,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V>\n+    where\n+        K: Ord,\n+    {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         let (map, dormant_map) = DormantMutRef::new(self);\n         let root_node = Self::ensure_is_owned(&mut map.root).borrow_mut();\n@@ -1092,7 +1126,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n-        K: Borrow<Q>,\n+        K: Borrow<Q> + Ord,\n     {\n         if self.is_empty() {\n             return Self::new();\n@@ -1150,12 +1184,16 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n     where\n+        K: Ord,\n         F: FnMut(&K, &mut V) -> bool,\n     {\n         DrainFilter { pred, inner: self.drain_filter_inner() }\n     }\n \n-    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V>\n+    where\n+        K: Ord,\n+    {\n         if let Some(root) = self.root.as_mut() {\n             let (root, dormant_root) = DormantMutRef::new(root);\n             let front = root.borrow_mut().first_leaf_edge();\n@@ -1188,7 +1226,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-    pub fn into_keys(self) -> IntoKeys<K, V> {\n+    pub fn into_keys(self) -> IntoKeys<K, V>\n+    where\n+        K: Ord,\n+    {\n         IntoKeys { inner: self.into_iter() }\n     }\n \n@@ -1211,7 +1252,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"map_into_keys_values\", issue = \"75294\")]\n-    pub fn into_values(self) -> IntoValues<K, V> {\n+    pub fn into_values(self) -> IntoValues<K, V>\n+    where\n+        K: Ord,\n+    {\n         IntoValues { inner: self.into_iter() }\n     }\n }\n@@ -1968,9 +2012,9 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n+impl<K, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n where\n-    K: Borrow<Q>,\n+    K: Borrow<Q> + Ord,\n     Q: Ord,\n {\n     type Output = V;"}, {"sha": "78edf11d3934b667af86fcd9338bf369a6120297", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -1706,6 +1706,34 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_ord_absence() {\n+    fn map<K>(mut map: BTreeMap<K, ()>) {\n+        map.is_empty();\n+        map.len();\n+        map.iter();\n+        map.iter_mut();\n+        map.keys();\n+        map.values();\n+        map.values_mut();\n+        map.into_iter();\n+    }\n+\n+    fn map_debug<K: Debug>(mut map: BTreeMap<K, ()>) {\n+        format!(\"{:?}\", map);\n+        format!(\"{:?}\", map.iter());\n+        format!(\"{:?}\", map.iter_mut());\n+        format!(\"{:?}\", map.keys());\n+        format!(\"{:?}\", map.values());\n+        format!(\"{:?}\", map.values_mut());\n+        format!(\"{:?}\", map.into_iter());\n+    }\n+\n+    fn map_clone<K: Clone>(mut map: BTreeMap<K, ()>) {\n+        map.clone_from(&map.clone());\n+    }\n+}\n+\n #[allow(dead_code)]\n fn test_const() {\n     const MAP: &'static BTreeMap<(), ()> = &BTreeMap::new();"}, {"sha": "be4e50119c0d1bba2d40e90ded0a2709e0d9f596", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 73, "deletions": 28, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -222,7 +222,7 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n // and it's a power of two to make that division cheap.\n const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n \n-impl<T: Ord> BTreeSet<T> {\n+impl<T> BTreeSet<T> {\n     /// Makes a new, empty `BTreeSet`.\n     ///\n     /// Does not allocate anything on its own.\n@@ -237,7 +237,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n-    pub const fn new() -> BTreeSet<T> {\n+    pub const fn new() -> BTreeSet<T>\n+    where\n+        T: Ord,\n+    {\n         BTreeSet { map: BTreeMap::new() }\n     }\n \n@@ -267,7 +270,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>\n     where\n         K: Ord,\n-        T: Borrow<K>,\n+        T: Borrow<K> + Ord,\n         R: RangeBounds<K>,\n     {\n         Range { iter: self.map.range(range) }\n@@ -294,7 +297,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(diff, [1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n+    pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T>\n+    where\n+        T: Ord,\n+    {\n         let (self_min, self_max) =\n             if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n                 (self_min, self_max)\n@@ -352,10 +358,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn symmetric_difference<'a>(\n-        &'a self,\n-        other: &'a BTreeSet<T>,\n-    ) -> SymmetricDifference<'a, T> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>) -> SymmetricDifference<'a, T>\n+    where\n+        T: Ord,\n+    {\n         SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -380,7 +386,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n+    pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T>\n+    where\n+        T: Ord,\n+    {\n         let (self_min, self_max) =\n             if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {\n                 (self_min, self_max)\n@@ -428,7 +437,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(union, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n+    pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T>\n+    where\n+        T: Ord,\n+    {\n         Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n@@ -445,7 +457,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn clear(&mut self) {\n+    pub fn clear(&mut self)\n+    where\n+        T: Ord,\n+    {\n         self.map.clear()\n     }\n \n@@ -467,7 +482,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.map.contains_key(value)\n@@ -491,7 +506,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         Recover::get(&self.map, value)\n@@ -515,7 +530,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_disjoint(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         self.intersection(other).next().is_none()\n     }\n \n@@ -537,7 +555,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_subset(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         // Same result as self.difference(other).next().is_none()\n         // but the code below is faster (hugely in some cases).\n         if self.len() > other.len() {\n@@ -613,7 +634,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.is_superset(&sub), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool {\n+    pub fn is_superset(&self, other: &BTreeSet<T>) -> bool\n+    where\n+        T: Ord,\n+    {\n         other.is_subset(self)\n     }\n \n@@ -636,7 +660,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(map.first(), Some(&1));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn first(&self) -> Option<&T> {\n+    pub fn first(&self) -> Option<&T>\n+    where\n+        T: Ord,\n+    {\n         self.map.first_key_value().map(|(k, _)| k)\n     }\n \n@@ -659,7 +686,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(map.last(), Some(&2));\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn last(&self) -> Option<&T> {\n+    pub fn last(&self) -> Option<&T>\n+    where\n+        T: Ord,\n+    {\n         self.map.last_key_value().map(|(k, _)| k)\n     }\n \n@@ -681,7 +711,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_first(&mut self) -> Option<T> {\n+    pub fn pop_first(&mut self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         self.map.pop_first().map(|kv| kv.0)\n     }\n \n@@ -703,7 +736,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(set.is_empty());\n     /// ```\n     #[unstable(feature = \"map_first_last\", issue = \"62924\")]\n-    pub fn pop_last(&mut self) -> Option<T> {\n+    pub fn pop_last(&mut self) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         self.map.pop_last().map(|kv| kv.0)\n     }\n \n@@ -728,7 +764,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: T) -> bool {\n+    pub fn insert(&mut self, value: T) -> bool\n+    where\n+        T: Ord,\n+    {\n         self.map.insert(value, ()).is_none()\n     }\n \n@@ -748,7 +787,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(set.get(&[][..]).unwrap().capacity(), 10);\n     /// ```\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n-    pub fn replace(&mut self, value: T) -> Option<T> {\n+    pub fn replace(&mut self, value: T) -> Option<T>\n+    where\n+        T: Ord,\n+    {\n         Recover::replace(&mut self.map, value)\n     }\n \n@@ -774,7 +816,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         self.map.remove(value).is_some()\n@@ -798,7 +840,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"set_recovery\", since = \"1.9.0\")]\n     pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n         Q: Ord,\n     {\n         Recover::take(&mut self.map, value)\n@@ -823,6 +865,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_retain\", issue = \"79025\")]\n     pub fn retain<F>(&mut self, mut f: F)\n     where\n+        T: Ord,\n         F: FnMut(&T) -> bool,\n     {\n         self.drain_filter(|v| !f(v));\n@@ -857,7 +900,10 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert!(a.contains(&5));\n     /// ```\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n-    pub fn append(&mut self, other: &mut Self) {\n+    pub fn append(&mut self, other: &mut Self)\n+    where\n+        T: Ord,\n+    {\n         self.map.append(&mut other.map);\n     }\n \n@@ -893,7 +939,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"btree_split_off\", since = \"1.11.0\")]\n     pub fn split_off<Q: ?Sized + Ord>(&mut self, key: &Q) -> Self\n     where\n-        T: Borrow<Q>,\n+        T: Borrow<Q> + Ord,\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n@@ -928,13 +974,12 @@ impl<T: Ord> BTreeSet<T> {\n     #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n     pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n     where\n+        T: Ord,\n         F: 'a + FnMut(&T) -> bool,\n     {\n         DrainFilter { pred, inner: self.map.drain_filter_inner() }\n     }\n-}\n \n-impl<T> BTreeSet<T> {\n     /// Gets an iterator that visits the values in the `BTreeSet` in ascending order.\n     ///\n     /// # Examples"}, {"sha": "79e469eb0db8b6e0878a261aa8dde2affba458c1", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -639,6 +639,26 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_ord_absence() {\n+    fn set<K>(set: BTreeSet<K>) {\n+        set.is_empty();\n+        set.len();\n+        set.iter();\n+        set.into_iter();\n+    }\n+\n+    fn set_debug<K: Debug>(set: BTreeSet<K>) {\n+        format!(\"{:?}\", set);\n+        format!(\"{:?}\", set.iter());\n+        format!(\"{:?}\", set.into_iter());\n+    }\n+\n+    fn set_clone<K: Clone>(mut set: BTreeSet<K>) {\n+        set.clone_from(&set.clone());\n+    }\n+}\n+\n #[test]\n fn test_append() {\n     let mut a = BTreeSet::new();"}, {"sha": "43301444e3e2c28ef1a88cd766e71a53ed8ac38b", "filename": "library/core/src/iter/adapters/peekable.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -265,7 +265,6 @@ impl<I: Iterator> Peekable<I> {\n     /// # Examples\n     /// Consume a number if it's equal to 0.\n     /// ```\n-    /// #![feature(peekable_next_if)]\n     /// let mut iter = (0..5).peekable();\n     /// // The first item of the iterator is 0; consume it.\n     /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n@@ -277,14 +276,13 @@ impl<I: Iterator> Peekable<I> {\n     ///\n     /// Consume any number less than 10.\n     /// ```\n-    /// #![feature(peekable_next_if)]\n     /// let mut iter = (1..20).peekable();\n     /// // Consume all numbers less than 10\n     /// while iter.next_if(|&x| x < 10).is_some() {}\n     /// // The next value returned will be 10\n     /// assert_eq!(iter.next(), Some(10));\n     /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    #[stable(feature = \"peekable_next_if\", since = \"1.51.0\")]\n     pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n         match self.next() {\n             Some(matched) if func(&matched) => Some(matched),\n@@ -302,7 +300,6 @@ impl<I: Iterator> Peekable<I> {\n     /// # Example\n     /// Consume a number if it's equal to 0.\n     /// ```\n-    /// #![feature(peekable_next_if)]\n     /// let mut iter = (0..5).peekable();\n     /// // The first item of the iterator is 0; consume it.\n     /// assert_eq!(iter.next_if_eq(&0), Some(0));\n@@ -311,7 +308,7 @@ impl<I: Iterator> Peekable<I> {\n     /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n     /// assert_eq!(iter.next(), Some(1));\n     /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    #[stable(feature = \"peekable_next_if\", since = \"1.51.0\")]\n     pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n     where\n         T: ?Sized,"}, {"sha": "3760f5c47948146598646c81886c6a81287e2942", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -172,11 +172,42 @@ use crate::ptr;\n ///\n /// ## Initializing a struct field-by-field\n ///\n-/// There is currently no supported way to create a raw pointer or reference\n-/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n-/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n-/// to its fields.\n+/// You can use `MaybeUninit<T>`, and the [`std::ptr::addr_of_mut`] macro, to initialize structs field by field:\n ///\n+/// ```rust\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr::addr_of_mut;\n+///\n+/// #[derive(Debug, PartialEq)]\n+/// pub struct Foo {\n+///     name: String,\n+///     list: Vec<u8>,\n+/// }\n+///\n+/// let foo = {\n+///     let mut uninit: MaybeUninit<Foo> = MaybeUninit::uninit();\n+///     let ptr = uninit.as_mut_ptr();\n+///\n+///     // Initializing the `name` field\n+///     unsafe { addr_of_mut!((*ptr).name).write(\"Bob\".to_string()); }\n+///\n+///     // Initializing the `list` field\n+///     // If there is a panic here, then the `String` in the `name` field leaks.\n+///     unsafe { addr_of_mut!((*ptr).list).write(vec![0, 1, 2]); }\n+///\n+///     // All the fields are initialized, so we call `assume_init` to get an initialized Foo.\n+///     unsafe { uninit.assume_init() }\n+/// };\n+///\n+/// assert_eq!(\n+///     foo,\n+///     Foo {\n+///         name: \"Bob\".to_string(),\n+///         list: vec![0, 1, 2]\n+///     }\n+/// );\n+/// ```\n+/// [`std::ptr::addr_of_mut`]: crate::ptr::addr_of_mut\n /// [ub]: ../../reference/behavior-considered-undefined.html\n ///\n /// # Layout"}, {"sha": "4dc86e0f5f40f4b767bbfa5f5d106c74a21a2d9f", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -65,7 +65,6 @@\n #![feature(unwrap_infallible)]\n #![feature(option_result_unwrap_unchecked)]\n #![feature(option_unwrap_none)]\n-#![feature(peekable_next_if)]\n #![feature(peekable_peek_mut)]\n #![feature(partition_point)]\n #![feature(once_cell)]"}, {"sha": "eecfd337cdf845027b08c59c5e51e2063527fc6e", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -296,7 +296,12 @@ fn run_test(\n         }\n     });\n     if let ErrorOutputType::HumanReadable(kind) = options.error_format {\n-        let (_, color_config) = kind.unzip();\n+        let (short, color_config) = kind.unzip();\n+\n+        if short {\n+            compiler.arg(\"--error-format\").arg(\"short\");\n+        }\n+\n         match color_config {\n             ColorConfig::Never => {\n                 compiler.arg(\"--color\").arg(\"never\");"}, {"sha": "18bc275572ff0752ca9f5ca92cd6f513bdfd98b6", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -9,7 +9,6 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n-#![feature(peekable_next_if)]\n #![feature(test)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]"}, {"sha": "be36ff50c7ef13316cf3a442fc3d70249a986911", "filename": "src/test/mir-opt/inline/inline-instruction-set.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Fmir-opt%2Finline%2Finline-instruction-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Fmir-opt%2Finline%2Finline-instruction-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-instruction-set.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -0,0 +1,54 @@\n+// Checks that only functions with the compatible instruction_set attributes are inlined.\n+//\n+// compile-flags: --target thumbv4t-none-eabi\n+// needs-llvm-components: arm\n+\n+#![crate_type = \"lib\"]\n+#![feature(rustc_attrs)]\n+#![feature(no_core, lang_items)]\n+#![feature(isa_attribute)]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+#[macro_export]\n+macro_rules! asm {\n+    (\"assembly template\",\n+        $(operands,)*\n+        $(options($(option),*))?\n+    ) => {\n+        /* compiler built-in */\n+    };\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+#[instruction_set(arm::a32)]\n+#[inline]\n+fn instruction_set_a32() {}\n+\n+#[instruction_set(arm::t32)]\n+#[inline]\n+fn instruction_set_t32() {}\n+\n+#[inline]\n+fn instruction_set_default() {}\n+\n+// EMIT_MIR inline_instruction_set.t32.Inline.diff\n+#[instruction_set(arm::t32)]\n+pub fn t32() {\n+    instruction_set_a32();\n+    instruction_set_t32();\n+    // The default instruction set is currently\n+    // conservatively assumed to be incompatible.\n+    instruction_set_default();\n+}\n+\n+// EMIT_MIR inline_instruction_set.default.Inline.diff\n+pub fn default() {\n+    instruction_set_a32();\n+    instruction_set_t32();\n+    instruction_set_default();\n+}"}, {"sha": "334cf5a08e2c5cb2a2283a4f2c9b05d08baa9ad5", "filename": "src/test/mir-opt/inline/inline_instruction_set.default.Inline.diff", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.default.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.default.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.default.Inline.diff?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -0,0 +1,45 @@\n+- // MIR for `default` before Inline\n++ // MIR for `default` after Inline\n+  \n+  fn default() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-instruction-set.rs:50:18: 50:18\n+      let _1: ();                          // in scope 0 at $DIR/inline-instruction-set.rs:51:5: 51:26\n+      let _2: ();                          // in scope 0 at $DIR/inline-instruction-set.rs:52:5: 52:26\n+      let _3: ();                          // in scope 0 at $DIR/inline-instruction-set.rs:53:5: 53:30\n++     scope 1 (inlined instruction_set_default) { // at $DIR/inline-instruction-set.rs:53:5: 53:30\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-instruction-set.rs:51:5: 51:26\n+          _1 = instruction_set_a32() -> bb1; // scope 0 at $DIR/inline-instruction-set.rs:51:5: 51:26\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-instruction-set.rs:51:5: 51:24\n+                                           // + literal: Const { ty: fn() {instruction_set_a32}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-instruction-set.rs:51:26: 51:27\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-instruction-set.rs:52:5: 52:26\n+          _2 = instruction_set_t32() -> bb2; // scope 0 at $DIR/inline-instruction-set.rs:52:5: 52:26\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-instruction-set.rs:52:5: 52:24\n+                                           // + literal: Const { ty: fn() {instruction_set_t32}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb2: {\n+          StorageDead(_2);                 // scope 0 at $DIR/inline-instruction-set.rs:52:26: 52:27\n+          StorageLive(_3);                 // scope 0 at $DIR/inline-instruction-set.rs:53:5: 53:30\n+-         _3 = instruction_set_default() -> bb3; // scope 0 at $DIR/inline-instruction-set.rs:53:5: 53:30\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-instruction-set.rs:53:5: 53:28\n+-                                          // + literal: Const { ty: fn() {instruction_set_default}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb3: {\n++         _3 = const ();                   // scope 1 at $DIR/inline-instruction-set.rs:53:5: 53:30\n+          StorageDead(_3);                 // scope 0 at $DIR/inline-instruction-set.rs:53:30: 53:31\n+          _0 = const ();                   // scope 0 at $DIR/inline-instruction-set.rs:50:18: 54:2\n+          return;                          // scope 0 at $DIR/inline-instruction-set.rs:54:2: 54:2\n+      }\n+  }\n+  "}, {"sha": "920b68c9daa1e44379fa09fc9e78f88699f032f6", "filename": "src/test/mir-opt/inline/inline_instruction_set.t32.Inline.diff", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.t32.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.t32.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_instruction_set.t32.Inline.diff?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -0,0 +1,47 @@\n+- // MIR for `t32` before Inline\n++ // MIR for `t32` after Inline\n+  \n+  fn t32() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/inline-instruction-set.rs:41:14: 41:14\n+      let _1: ();                          // in scope 0 at $DIR/inline-instruction-set.rs:42:5: 42:26\n+      let _2: ();                          // in scope 0 at $DIR/inline-instruction-set.rs:43:5: 43:26\n+      let _3: ();                          // in scope 0 at $DIR/inline-instruction-set.rs:46:5: 46:30\n++     scope 1 (inlined instruction_set_t32) { // at $DIR/inline-instruction-set.rs:43:5: 43:26\n++     }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/inline-instruction-set.rs:42:5: 42:26\n+          _1 = instruction_set_a32() -> bb1; // scope 0 at $DIR/inline-instruction-set.rs:42:5: 42:26\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-instruction-set.rs:42:5: 42:24\n+                                           // + literal: Const { ty: fn() {instruction_set_a32}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_1);                 // scope 0 at $DIR/inline-instruction-set.rs:42:26: 42:27\n+          StorageLive(_2);                 // scope 0 at $DIR/inline-instruction-set.rs:43:5: 43:26\n+-         _2 = instruction_set_t32() -> bb2; // scope 0 at $DIR/inline-instruction-set.rs:43:5: 43:26\n+-                                          // mir::Constant\n+-                                          // + span: $DIR/inline-instruction-set.rs:43:5: 43:24\n+-                                          // + literal: Const { ty: fn() {instruction_set_t32}, val: Value(Scalar(<ZST>)) }\n+-     }\n+- \n+-     bb2: {\n++         _2 = const ();                   // scope 1 at $DIR/inline-instruction-set.rs:43:5: 43:26\n+          StorageDead(_2);                 // scope 0 at $DIR/inline-instruction-set.rs:43:26: 43:27\n+          StorageLive(_3);                 // scope 0 at $DIR/inline-instruction-set.rs:46:5: 46:30\n+-         _3 = instruction_set_default() -> bb3; // scope 0 at $DIR/inline-instruction-set.rs:46:5: 46:30\n++         _3 = instruction_set_default() -> bb2; // scope 0 at $DIR/inline-instruction-set.rs:46:5: 46:30\n+                                           // mir::Constant\n+                                           // + span: $DIR/inline-instruction-set.rs:46:5: 46:28\n+                                           // + literal: Const { ty: fn() {instruction_set_default}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+-     bb3: {\n++     bb2: {\n+          StorageDead(_3);                 // scope 0 at $DIR/inline-instruction-set.rs:46:30: 46:31\n+          _0 = const ();                   // scope 0 at $DIR/inline-instruction-set.rs:41:14: 47:2\n+          return;                          // scope 0 at $DIR/inline-instruction-set.rs:47:2: 47:2\n+      }\n+  }\n+  "}, {"sha": "27a21a313bc552b9b27bcebd21d54b79c188fbb3", "filename": "src/test/rustdoc-ui/issue-81662-shortness.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Frustdoc-ui%2Fissue-81662-shortness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Frustdoc-ui%2Fissue-81662-shortness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-81662-shortness.rs?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags:--test --error-format=short\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// normalize-stdout-test \"finished in \\d+\\.\\d+s\" -> \"finished in $$TIME\"\n+// failure-status: 101\n+\n+/// ```rust\n+/// foo();\n+/// ```\n+//~^^ ERROR cannot find function `foo` in this scope\n+fn foo() {\n+    println!(\"Hello, world!\");\n+}"}, {"sha": "748113be3a26d14d94a8d5f96b26b6750677ccd8", "filename": "src/test/rustdoc-ui/issue-81662-shortness.stdout", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Frustdoc-ui%2Fissue-81662-shortness.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cfba499271ba53190a1d3647ff8f7202ec9ed6f5/src%2Ftest%2Frustdoc-ui%2Fissue-81662-shortness.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-81662-shortness.stdout?ref=cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "patch": "@@ -0,0 +1,16 @@\n+\n+running 1 test\n+test $DIR/issue-81662-shortness.rs - foo (line 6) ... FAILED\n+\n+failures:\n+\n+---- $DIR/issue-81662-shortness.rs - foo (line 6) stdout ----\n+$DIR/issue-81662-shortness.rs:7:1: error[E0425]: cannot find function `foo` in this scope\n+error: aborting due to previous error\n+Couldn't compile the test.\n+\n+failures:\n+    $DIR/issue-81662-shortness.rs - foo (line 6)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in $TIME\n+"}]}