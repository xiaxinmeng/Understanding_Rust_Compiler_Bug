{"sha": "8714e6bce6b04482723f0b735879533c82c114fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTRlNmJjZTZiMDQ0ODI3MjNmMGI3MzU4Nzk1MzNjODJjMTE0ZmE=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-08-28T15:03:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T12:11:59Z"}, "message": "Traitification of common.rs methods", "tree": {"sha": "1c30b12dc5fa7bd6a37092af6ce87b77faa880e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c30b12dc5fa7bd6a37092af6ce87b77faa880e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8714e6bce6b04482723f0b735879533c82c114fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8714e6bce6b04482723f0b735879533c82c114fa", "html_url": "https://github.com/rust-lang/rust/commit/8714e6bce6b04482723f0b735879533c82c114fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8714e6bce6b04482723f0b735879533c82c114fa/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3889c2dcfb2968226bad79b4c04b987e031f9c0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3889c2dcfb2968226bad79b4c04b987e031f9c0d", "html_url": "https://github.com/rust-lang/rust/commit/3889c2dcfb2968226bad79b4c04b987e031f9c0d"}], "stats": {"total": 883, "additions": 492, "deletions": 391}, "files": [{"sha": "061371d08030b6cf2abc93399c1d8cb88faa932a", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -11,15 +11,14 @@\n use llvm::{self, AttributePlace};\n use base;\n use builder::{Builder, MemFlags};\n-use common::C_usize;\n use context::CodegenCx;\n use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n@@ -245,7 +244,7 @@ impl ArgTypeExt<'ll, 'tcx> for ArgType<'tcx, Ty<'tcx>> {\n                                   self.layout.align,\n                                   bx.pointercast(llscratch, Type::i8p(cx)),\n                                   scratch_align,\n-                                  C_usize(cx, self.layout.size.bytes()),\n+                                  CodegenCx::c_usize(cx, self.layout.size.bytes()),\n                                   MemFlags::empty());\n \n                 bx.lifetime_end(llscratch, scratch_size);"}, {"sha": "5ba4b47e00840c81d20fdeea15ec90dac022f6df", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -9,14 +9,14 @@\n // except according to those terms.\n \n use llvm;\n-use common::*;\n+use context::CodegenCx;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use builder::Builder;\n use value::Value;\n \n use rustc::hir;\n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use mir::place::PlaceRef;\n use mir::operand::OperandValue;\n@@ -111,7 +111,7 @@ pub fn codegen_inline_asm(\n         let kind = llvm::LLVMGetMDKindIDInContext(bx.cx.llcx,\n             key.as_ptr() as *const c_char, key.len() as c_uint);\n \n-        let val: &'ll Value = C_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n+        let val: &'ll Value = CodegenCx::c_i32(bx.cx, ia.ctxt.outer().as_u32() as i32);\n \n         llvm::LLVMSetMetadata(r, kind,\n             llvm::LLVMMDNodeInContext(bx.cx.llcx, &val, 1));"}, {"sha": "a7f0b8854222e98e95f1c4a4bb091010ccd2c782", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -740,7 +740,7 @@ fn link_natively(sess: &Session,\n     // with some thread pool working in the background. It seems that no one\n     // currently knows a fix for this so in the meantime we're left with this...\n     info!(\"{:?}\", &cmd);\n-    let retry_on_segfault = env::var(\"RUSTC_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n+    let retry_on_segfault = env::var(\"RUSTc_RETRY_LINKER_ON_SEGFAULT\").is_ok();\n     let mut prog;\n     let mut i = 0;\n     loop {"}, {"sha": "47a5bc25fd820b750421205c41be6c9c9bce9d50", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -45,8 +45,8 @@ use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n use type_::Type;\n-use context::{is_pie_binary, get_reloc_model};\n-use common::{C_bytes_in_context, val_ty};\n+use context::{is_pie_binary, get_reloc_model, CodegenCx};\n+use interfaces::CommonMethods;\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n \n@@ -884,10 +884,10 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n                         llcx: &llvm::Context,\n                         llmod: &llvm::Module,\n                         bitcode: Option<&[u8]>) {\n-    let llconst = C_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n+    let llconst = CodegenCx::c_bytes_in_context(llcx, bitcode.unwrap_or(&[]));\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst),\n+        CodegenCx::val_ty(llconst),\n         \"rustc.embedded.module\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -904,10 +904,10 @@ unsafe fn embed_bitcode(cgcx: &CodegenContext,\n     llvm::LLVMRustSetLinkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::LLVMSetGlobalConstant(llglobal, llvm::True);\n \n-    let llconst = C_bytes_in_context(llcx, &[]);\n+    let llconst = CodegenCx::c_bytes_in_context(llcx, &[]);\n     let llglobal = llvm::LLVMAddGlobal(\n         llmod,\n-        val_ty(llconst),\n+        CodegenCx::val_ty(llconst),\n         \"rustc.embedded.cmdline\\0\".as_ptr() as *const _,\n     );\n     llvm::LLVMSetInitializer(llglobal, llconst);"}, {"sha": "161b78c910eaeadeff8b4845bfc528a821607d6a", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -53,9 +53,8 @@ use mir::place::PlaceRef;\n use attributes;\n use builder::{Builder, MemFlags};\n use callee;\n-use common::{C_bool, C_bytes_in_context, C_usize};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n-use common::{C_struct_in_context, C_array, val_ty, IntPredicate, RealPredicate};\n+use common::{IntPredicate, RealPredicate};\n use consts;\n use context::CodegenCx;\n use debuginfo;\n@@ -75,7 +74,7 @@ use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use std::any::Any;\n use std::cmp;\n@@ -199,7 +198,7 @@ pub fn unsized_info(\n     let (source, target) = cx.tcx.struct_lockstep_tails(source, target);\n     match (&source.sty, &target.sty) {\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n-            C_usize(cx, len.unwrap_usize(cx.tcx))\n+            CodegenCx::c_usize(cx, len.unwrap_usize(cx.tcx))\n         }\n         (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n             // For now, upcasts are limited to changes in marker\n@@ -351,8 +350,8 @@ fn cast_shift_rhs<'ll, F, G>(op: hir::BinOpKind,\n {\n     // Shifts may have any size int on the rhs\n     if op.is_shift() {\n-        let mut rhs_llty = val_ty(rhs);\n-        let mut lhs_llty = val_ty(lhs);\n+        let mut rhs_llty = CodegenCx::val_ty(rhs);\n+        let mut lhs_llty = CodegenCx::val_ty(lhs);\n         if rhs_llty.kind() == TypeKind::Vector {\n             rhs_llty = rhs_llty.element_type()\n         }\n@@ -393,7 +392,7 @@ pub fn from_immediate<'a, 'll: 'a, 'tcx: 'll>(\n     bx: &Builder<'_ ,'ll, '_, &'ll Value>,\n     val: &'ll Value\n ) -> &'ll Value {\n-    if val_ty(val) == Type::i1(bx.cx()) {\n+    if CodegenCx::val_ty(val) == Type::i1(bx.cx()) {\n         bx.zext(val, Type::i8(bx.cx()))\n     } else {\n         val\n@@ -434,7 +433,7 @@ pub fn call_memcpy<'a, 'll: 'a, 'tcx: 'll>(\n     if flags.contains(MemFlags::NONTEMPORAL) {\n         // HACK(nox): This is inefficient but there is no nontemporal memcpy.\n         let val = bx.load(src, src_align);\n-        let ptr = bx.pointercast(dst, val_ty(val).ptr_to());\n+        let ptr = bx.pointercast(dst, CodegenCx::val_ty(val).ptr_to());\n         bx.store_with_flags(val, ptr, dst_align, flags);\n         return;\n     }\n@@ -460,7 +459,7 @@ pub fn memcpy_ty<'a, 'll: 'a, 'tcx: 'll>(\n         return;\n     }\n \n-    call_memcpy(bx, dst, dst_align, src, src_align, C_usize(bx.cx(), size), flags);\n+    call_memcpy(bx, dst, dst_align, src, src_align, CodegenCx::c_usize(bx.cx(), size), flags);\n }\n \n pub fn call_memset(\n@@ -474,7 +473,7 @@ pub fn call_memset(\n     let ptr_width = &bx.cx.sess().target.target.target_pointer_width;\n     let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n     let llintrinsicfn = bx.cx.get_intrinsic(&intrinsic_key);\n-    let volatile = C_bool(bx.cx, volatile);\n+    let volatile = CodegenCx::c_bool(bx.cx, volatile);\n     bx.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n@@ -649,12 +648,12 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     DeflateEncoder::new(&mut compressed, Compression::fast())\n         .write_all(&metadata.raw_data).unwrap();\n \n-    let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n-    let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);\n+    let llmeta = CodegenCx::c_bytes_in_context(metadata_llcx, &compressed);\n+    let llconst = CodegenCx::c_struct_in_context(metadata_llcx, &[llmeta], false);\n     let name = exported_symbols::metadata_symbol_name(tcx);\n     let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n-        llvm::LLVMAddGlobal(metadata_llmod, val_ty(llconst), buf.as_ptr())\n+        llvm::LLVMAddGlobal(metadata_llmod, CodegenCx::val_ty(llconst), buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n@@ -1140,7 +1139,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw.borrow().iter() {\n                 unsafe {\n-                    let bitcast = llvm::LLVMConstPointerCast(new_g, val_ty(old_g));\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, CodegenCx::val_ty(old_g));\n                     llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n                     llvm::LLVMDeleteGlobal(old_g);\n                 }\n@@ -1151,11 +1150,11 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !cx.used_statics.borrow().is_empty() {\n                 let name = const_cstr!(\"llvm.used\");\n                 let section = const_cstr!(\"llvm.metadata\");\n-                let array = C_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n+                let array = CodegenCx::c_array(Type::i8(&cx).ptr_to(), &*cx.used_statics.borrow());\n \n                 unsafe {\n                     let g = llvm::LLVMAddGlobal(cx.llmod,\n-                                                val_ty(array),\n+                                                CodegenCx::val_ty(array),\n                                                 name.as_ptr());\n                     llvm::LLVMSetInitializer(g, array);\n                     llvm::LLVMRustSetLinkage(g, llvm::Linkage::AppendingLinkage);"}, {"sha": "b994a745e3fcb386dc9e075645c5c50dcbcba46c", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -11,14 +11,15 @@\n use llvm::{AtomicRmwBinOp, AtomicOrdering, SynchronizationScope, AsmDialect};\n use llvm::{self, False, OperandBundleDef, BasicBlock};\n use common::{self, *};\n+use context::CodegenCx;\n use type_;\n use value::Value;\n use libc::{c_uint, c_char};\n use rustc::ty::TyCtxt;\n use rustc::ty::layout::{Align, Size};\n use rustc::session::{config, Session};\n use rustc_data_structures::small_c_str::SmallCStr;\n-use interfaces::{BuilderMethods, Backend};\n+use interfaces::{BuilderMethods, Backend, CommonMethods};\n use syntax;\n \n use std::borrow::Cow;\n@@ -59,6 +60,7 @@ impl Backend for Builder<'a, 'll, 'tcx>  {\n         type Value = &'ll Value;\n         type BasicBlock = &'ll BasicBlock;\n         type Type = &'ll type_::Type;\n+        type Context = &'ll llvm::Context;\n }\n \n impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n@@ -525,10 +527,10 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n \n         unsafe {\n-            let llty = val_ty(load);\n+            let llty = CodegenCx::val_ty(load);\n             let v = [\n-                C_uint_big(llty, range.start),\n-                C_uint_big(llty, range.end)\n+                CodegenCx::c_uint_big(llty, range.start),\n+                CodegenCx::c_uint_big(llty, range.end)\n             ];\n \n             llvm::LLVMSetMetadata(load, llvm::MD_range as c_uint,\n@@ -575,7 +577,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 // *always* point to a metadata value of the integer 1.\n                 //\n                 // [1]: http://llvm.org/docs/LangRef.html#store-instruction\n-                let one = C_i32(self.cx, 1);\n+                let one = CodegenCx::c_i32(self.cx, 1);\n                 let node = llvm::LLVMMDNodeInContext(self.cx.llcx, &one, 1);\n                 llvm::LLVMSetMetadata(store, llvm::MD_nontemporal as c_uint, node);\n             }\n@@ -758,7 +760,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n         let argtys = inputs.iter().map(|v| {\n             debug!(\"Asm Input Type: {:?}\", *v);\n-            val_ty(*v)\n+            CodegenCx::val_ty(*v)\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {:?}\", output);\n@@ -857,11 +859,11 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn vector_splat(&self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n-            let elt_ty = val_ty(elt);\n+            let elt_ty = CodegenCx::val_ty(elt);\n             let undef = llvm::LLVMGetUndef(type_::Type::vector(elt_ty, num_elts as u64));\n-            let vec = self.insert_element(undef, elt, C_i32(self.cx, 0));\n+            let vec = self.insert_element(undef, elt, CodegenCx::c_i32(self.cx, 0));\n             let vec_i32_ty = type_::Type::vector(type_::Type::i32(self.cx), num_elts as u64);\n-            self.shuffle_vector(vec, undef, C_null(vec_i32_ty))\n+            self.shuffle_vector(vec, undef, CodegenCx::c_null(vec_i32_ty))\n         }\n     }\n \n@@ -1137,8 +1139,8 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn check_store<'b>(&self,\n                        val: &'ll Value,\n                        ptr: &'ll Value) -> &'ll Value {\n-        let dest_ptr_ty = val_ty(ptr);\n-        let stored_ty = val_ty(val);\n+        let dest_ptr_ty = CodegenCx::val_ty(ptr);\n+        let stored_ty = CodegenCx::val_ty(val);\n         let stored_ptr_ty = stored_ty.ptr_to();\n \n         assert_eq!(dest_ptr_ty.kind(), llvm::TypeKind::Pointer);\n@@ -1158,7 +1160,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n                       typ: &str,\n                       llfn: &'ll Value,\n                       args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n-        let mut fn_ty = val_ty(llfn);\n+        let mut fn_ty = CodegenCx::val_ty(llfn);\n         // Strip off pointers\n         while fn_ty.kind() == llvm::TypeKind::Pointer {\n             fn_ty = fn_ty.element_type();\n@@ -1170,7 +1172,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let param_tys = fn_ty.func_params();\n \n         let all_args_match = param_tys.iter()\n-            .zip(args.iter().map(|&v| val_ty(v)))\n+            .zip(args.iter().map(|&v| CodegenCx::val_ty(v)))\n             .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n \n         if all_args_match {\n@@ -1181,7 +1183,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n             .zip(args.iter())\n             .enumerate()\n             .map(|(i, (expected_ty, &actual_val))| {\n-                let actual_ty = val_ty(actual_val);\n+                let actual_ty = CodegenCx::val_ty(actual_val);\n                 if expected_ty != actual_ty {\n                     debug!(\"Type mismatch in function call of {:?}. \\\n                             Expected {:?} for param {}, got {:?}; injecting bitcast\",\n@@ -1225,7 +1227,7 @@ impl BuilderMethods<'a, 'll, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let lifetime_intrinsic = self.cx.get_intrinsic(intrinsic);\n \n         let ptr = self.pointercast(ptr, type_::Type::i8p(self.cx));\n-        self.call(lifetime_intrinsic, &[C_u64(self.cx, size), ptr], None);\n+        self.call(lifetime_intrinsic, &[CodegenCx::c_u64(self.cx, size), ptr], None);\n     }\n \n     fn call(&self, llfn: &'ll Value, args: &[&'ll Value],"}, {"sha": "ce3743bb8cb6b725e8f984d0f771fb95dbab3887", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -15,13 +15,14 @@\n //! closure.\n \n use attributes;\n-use common::{self, CodegenCx};\n+use common::{CodegenCx};\n use consts;\n use declare;\n use llvm;\n use monomorphize::Instance;\n use type_of::LayoutLlvmExt;\n use value::Value;\n+use interfaces::CommonMethods;\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TypeFoldable};\n@@ -83,7 +84,7 @@ pub fn get_fn(\n         // This can occur on either a crate-local or crate-external\n         // reference. It also occurs when testing libcore and in some\n         // other weird situations. Annoying.\n-        if common::val_ty(llfn) != llptrty {\n+        if CodegenCx::val_ty(llfn) != llptrty {\n             debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n             consts::ptrcast(llfn, llptrty)\n         } else {\n@@ -92,7 +93,7 @@ pub fn get_fn(\n         }\n     } else {\n         let llfn = declare::declare_fn(cx, &sym, sig);\n-        assert_eq!(common::val_ty(llfn), llptrty);\n+        assert_eq!(CodegenCx::val_ty(llfn), llptrty);\n         debug!(\"get_fn: not casting pointer!\");\n \n         if instance.def.is_inline(tcx) {"}, {"sha": "0736714240b3ab8c9154e1b75f7032489349a55e", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 184, "deletions": 167, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -13,7 +13,7 @@\n //! Code that is useful in various codegen modules.\n \n use llvm::{self, TypeKind};\n-use llvm::{True, False, Bool};\n+use llvm::{True, False, Bool, BasicBlock};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use abi;\n@@ -24,6 +24,7 @@ use declare;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n+use interfaces::{Backend, CommonMethods};\n \n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{HasDataLayout, LayoutOf};\n@@ -192,225 +193,241 @@ impl Funclet<'ll> {\n     }\n }\n \n-pub fn val_ty(v: &'ll Value) -> &'ll Type {\n-    unsafe {\n-        llvm::LLVMTypeOf(v)\n-    }\n+impl Backend for CodegenCx<'ll, 'tcx, &'ll Value> {\n+    type Value = &'ll Value;\n+    type BasicBlock = &'ll BasicBlock;\n+    type Type = &'ll Type;\n+    type Context = &'ll llvm::Context;\n }\n \n-// LLVM constant constructors.\n-pub fn C_null(t: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstNull(t)\n+impl<'ll, 'tcx : 'll> CommonMethods for CodegenCx<'ll, 'tcx, &'ll Value> {\n+    fn val_ty(v: &'ll Value) -> &'ll Type {\n+        unsafe {\n+            llvm::LLVMTypeOf(v)\n+        }\n     }\n-}\n \n-pub fn C_undef(t: &'ll Type) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMGetUndef(t)\n+    // LLVM constant constructors.\n+    fn c_null(t: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstNull(t)\n+        }\n     }\n-}\n \n-pub fn C_int(t: &'ll Type, i: i64) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstInt(t, i as u64, True)\n+    fn c_undef(t: &'ll Type) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMGetUndef(t)\n+        }\n     }\n-}\n \n-pub fn C_uint(t: &'ll Type, i: u64) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstInt(t, i, False)\n+    fn c_int(t: &'ll Type, i: i64) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstInt(t, i as u64, True)\n+        }\n     }\n-}\n \n-pub fn C_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n-    unsafe {\n-        let words = [u as u64, (u >> 64) as u64];\n-        llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n+    fn c_uint(t: &'ll Type, i: u64) -> &'ll Value {\n+        unsafe {\n+            llvm::LLVMConstInt(t, i, False)\n+        }\n     }\n-}\n \n-pub fn C_bool(cx: &CodegenCx<'ll, '_>, val: bool) -> &'ll Value {\n-    C_uint(Type::i1(cx), val as u64)\n-}\n-\n-pub fn C_i32(cx: &CodegenCx<'ll, '_>, i: i32) -> &'ll Value {\n-    C_int(Type::i32(cx), i as i64)\n-}\n-\n-pub fn C_u32(cx: &CodegenCx<'ll, '_>, i: u32) -> &'ll Value {\n-    C_uint(Type::i32(cx), i as u64)\n-}\n-\n-pub fn C_u64(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n-    C_uint(Type::i64(cx), i)\n-}\n+    fn c_uint_big(t: &'ll Type, u: u128) -> &'ll Value {\n+        unsafe {\n+            let words = [u as u64, (u >> 64) as u64];\n+            llvm::LLVMConstIntOfArbitraryPrecision(t, 2, words.as_ptr())\n+        }\n+    }\n \n-pub fn C_usize(cx: &CodegenCx<'ll, '_>, i: u64) -> &'ll Value {\n-    let bit_size = cx.data_layout().pointer_size.bits();\n-    if bit_size < 64 {\n-        // make sure it doesn't overflow\n-        assert!(i < (1<<bit_size));\n+    fn c_bool(&self, val: bool) -> &'ll Value {\n+        Self::c_uint(Type::i1(&self), val as u64)\n     }\n \n-    C_uint(cx.isize_ty, i)\n-}\n+    fn c_i32(&self, i: i32) -> &'ll Value {\n+        Self::c_int(Type::i32(&self), i as i64)\n+    }\n \n-pub fn C_u8(cx: &CodegenCx<'ll, '_>, i: u8) -> &'ll Value {\n-    C_uint(Type::i8(cx), i as u64)\n-}\n+    fn c_u32(&self, i: u32) -> &'ll Value {\n+        Self::c_uint(Type::i32(&self), i as u64)\n+    }\n \n+    fn c_u64(&self, i: u64) -> &'ll Value {\n+        Self::c_uint(Type::i64(&self), i)\n+    }\n \n-// This is a 'c-like' raw string, which differs from\n-// our boxed-and-length-annotated strings.\n-pub fn C_cstr(\n-    cx: &CodegenCx<'ll, '_>,\n-    s: LocalInternedString,\n-    null_terminated: bool,\n-) -> &'ll Value {\n-    unsafe {\n-        if let Some(&llval) = cx.const_cstr_cache.borrow().get(&s) {\n-            return llval;\n+    fn c_usize(&self, i: u64) -> &'ll Value {\n+        let bit_size = self.data_layout().pointer_size.bits();\n+        if bit_size < 64 {\n+            // make sure it doesn't overflow\n+            assert!(i < (1<<bit_size));\n         }\n \n-        let sc = llvm::LLVMConstStringInContext(cx.llcx,\n-                                                s.as_ptr() as *const c_char,\n-                                                s.len() as c_uint,\n-                                                !null_terminated as Bool);\n-        let sym = cx.generate_local_symbol_name(\"str\");\n-        let g = declare::define_global(cx, &sym[..], val_ty(sc)).unwrap_or_else(||{\n-            bug!(\"symbol `{}` is already defined\", sym);\n-        });\n-        llvm::LLVMSetInitializer(g, sc);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n-\n-        cx.const_cstr_cache.borrow_mut().insert(s, g);\n-        g\n+        Self::c_uint(&self.isize_ty, i)\n     }\n-}\n \n-// NB: Do not use `do_spill_noroot` to make this into a constant string, or\n-// you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_str_slice(cx: &CodegenCx<'ll, '_>, s: LocalInternedString) -> &'ll Value {\n-    let len = s.len();\n-    let cs = consts::ptrcast(C_cstr(cx, s, false),\n-        cx.layout_of(cx.tcx.mk_str()).llvm_type(cx).ptr_to());\n-    C_fat_ptr(cx, cs, C_usize(cx, len as u64))\n-}\n+    fn c_u8(&self, i: u8) -> &'ll Value {\n+        Self::c_uint(Type::i8(&self), i as u64)\n+    }\n \n-pub fn C_fat_ptr(cx: &CodegenCx<'ll, '_>, ptr: &'ll Value, meta: &'ll Value) -> &'ll Value {\n-    assert_eq!(abi::FAT_PTR_ADDR, 0);\n-    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-    C_struct(cx, &[ptr, meta], false)\n-}\n \n-pub fn C_struct(cx: &CodegenCx<'ll, '_>, elts: &[&'ll Value], packed: bool) -> &'ll Value {\n-    C_struct_in_context(cx.llcx, elts, packed)\n-}\n+    // This is a 'c-like' raw string, which differs from\n+    // our boxed-and-length-annotated strings.\n+    fn c_cstr(\n+        &self,\n+        s: LocalInternedString,\n+        null_terminated: bool,\n+    ) -> &'ll Value {\n+        unsafe {\n+            if let Some(&llval) = &self.const_cstr_cache.borrow().get(&s) {\n+                return llval;\n+            }\n \n-pub fn C_struct_in_context(\n-    llcx: &'ll llvm::Context,\n-    elts: &[&'ll Value],\n-    packed: bool,\n-) -> &'ll Value {\n-    unsafe {\n-        llvm::LLVMConstStructInContext(llcx,\n-                                       elts.as_ptr(), elts.len() as c_uint,\n-                                       packed as Bool)\n+            let sc = llvm::LLVMConstStringInContext(&self.llcx,\n+                                                    s.as_ptr() as *const c_char,\n+                                                    s.len() as c_uint,\n+                                                    !null_terminated as Bool);\n+            let sym = &self.generate_local_symbol_name(\"str\");\n+            let g = declare::define_global(&self, &sym[..], Self::val_ty(sc)).unwrap_or_else(||{\n+                bug!(\"symbol `{}` is already defined\", sym);\n+            });\n+            llvm::LLVMSetInitializer(g, sc);\n+            llvm::LLVMSetGlobalConstant(g, True);\n+            llvm::LLVMRustSetLinkage(g, llvm::Linkage::InternalLinkage);\n+\n+            &self.const_cstr_cache.borrow_mut().insert(s, g);\n+            g\n+        }\n     }\n-}\n \n-pub fn C_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n-    unsafe {\n-        return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n+    // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n+    // you will be kicked off fast isel. See issue #4352 for an example of this.\n+    fn c_str_slice(&self, s: LocalInternedString) -> &'ll Value {\n+        let len = s.len();\n+        let cs = consts::ptrcast(&self.c_cstr(s, false),\n+            &self.layout_of(&self.tcx.mk_str()).llvm_type(&self).ptr_to());\n+        &self.c_fat_ptr(cs, &self.c_usize(len as u64))\n     }\n-}\n \n-pub fn C_vector(elts: &[&'ll Value]) -> &'ll Value {\n-    unsafe {\n-        return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+    fn c_fat_ptr(\n+        &self,\n+        ptr: &'ll Value,\n+        meta: &'ll Value\n+    ) -> &'ll Value {\n+        assert_eq!(abi::FAT_PTR_ADDR, 0);\n+        assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+        &self.c_struct(&[ptr, meta], false)\n     }\n-}\n \n-pub fn C_bytes(cx: &CodegenCx<'ll, '_>, bytes: &[u8]) -> &'ll Value {\n-    C_bytes_in_context(cx.llcx, bytes)\n-}\n+    fn c_struct(\n+        &self,\n+        elts: &[&'ll Value],\n+        packed: bool\n+    ) -> &'ll Value {\n+        Self::c_struct_in_context(&self.llcx, elts, packed)\n+    }\n \n-pub fn C_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n-    unsafe {\n-        let ptr = bytes.as_ptr() as *const c_char;\n-        return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n+    fn c_struct_in_context(\n+        llcx: &'a llvm::Context,\n+        elts: &[&'a Value],\n+        packed: bool,\n+    ) -> &'a Value {\n+        unsafe {\n+            llvm::LLVMConstStructInContext(llcx,\n+                                           elts.as_ptr(), elts.len() as c_uint,\n+                                           packed as Bool)\n+        }\n     }\n-}\n \n-pub fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n-    unsafe {\n-        assert_eq!(idx as c_uint as u64, idx);\n-        let us = &[idx as c_uint];\n-        let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+    fn c_array(ty: &'ll Type, elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            return llvm::LLVMConstArray(ty, elts.as_ptr(), elts.len() as c_uint);\n+        }\n+    }\n \n-        debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n-               v, idx, r);\n+    fn c_vector(elts: &[&'ll Value]) -> &'ll Value {\n+        unsafe {\n+            return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+        }\n+    }\n \n-        r\n+    fn c_bytes(&self, bytes: &[u8]) -> &'ll Value {\n+        Self::c_bytes_in_context(&self.llcx, bytes)\n     }\n-}\n \n-pub fn const_get_real(v: &'ll Value) -> Option<(f64, bool)> {\n-    unsafe {\n-        if is_const_real(v) {\n-            let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n-            let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n-            let loses_info = if loses_info == 1 { true } else { false };\n-            Some((r, loses_info))\n-        } else {\n-            None\n+    fn c_bytes_in_context(llcx: &'ll llvm::Context, bytes: &[u8]) -> &'ll Value {\n+        unsafe {\n+            let ptr = bytes.as_ptr() as *const c_char;\n+            return llvm::LLVMConstStringInContext(llcx, ptr, bytes.len() as c_uint, True);\n         }\n     }\n-}\n \n-pub fn const_to_uint(v: &'ll Value) -> u64 {\n-    unsafe {\n-        llvm::LLVMConstIntGetZExtValue(v)\n+    fn const_get_elt(v: &'ll Value, idx: u64) -> &'ll Value {\n+        unsafe {\n+            assert_eq!(idx as c_uint as u64, idx);\n+            let us = &[idx as c_uint];\n+            let r = llvm::LLVMConstExtractValue(v, us.as_ptr(), us.len() as c_uint);\n+\n+            debug!(\"const_get_elt(v={:?}, idx={}, r={:?})\",\n+                   v, idx, r);\n+\n+            r\n+        }\n     }\n-}\n \n-pub fn is_const_integral(v: &'ll Value) -> bool {\n-    unsafe {\n-        llvm::LLVMIsAConstantInt(v).is_some()\n+    fn const_get_real(v: &'ll Value) -> Option<(f64, bool)> {\n+        unsafe {\n+            if Self::is_const_real(v) {\n+                let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n+                let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info);\n+                let loses_info = if loses_info == 1 { true } else { false };\n+                Some((r, loses_info))\n+            } else {\n+                None\n+            }\n+        }\n     }\n-}\n \n-pub fn is_const_real(v: &'ll Value) -> bool {\n-    unsafe {\n-        llvm::LLVMIsAConstantFP(v).is_some()\n+    fn const_to_uint(v: &'ll Value) -> u64 {\n+        unsafe {\n+            llvm::LLVMConstIntGetZExtValue(v)\n+        }\n     }\n-}\n \n+    fn is_const_integral(v: &'ll Value) -> bool {\n+        unsafe {\n+            llvm::LLVMIsAConstantInt(v).is_some()\n+        }\n+    }\n \n-#[inline]\n-fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n-    ((hi as u128) << 64) | (lo as u128)\n-}\n+    fn is_const_real(v: &'ll Value) -> bool {\n+        unsafe {\n+            llvm::LLVMIsAConstantFP(v).is_some()\n+        }\n+    }\n \n-pub fn const_to_opt_u128(v: &'ll Value, sign_ext: bool) -> Option<u128> {\n-    unsafe {\n-        if is_const_integral(v) {\n-            let (mut lo, mut hi) = (0u64, 0u64);\n-            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n-                                                       &mut hi, &mut lo);\n-            if success {\n-                Some(hi_lo_to_u128(lo, hi))\n+    fn const_to_opt_u128(v: &'ll Value, sign_ext: bool) -> Option<u128> {\n+        unsafe {\n+            if Self::is_const_integral(v) {\n+                let (mut lo, mut hi) = (0u64, 0u64);\n+                let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                           &mut hi, &mut lo);\n+                if success {\n+                    Some(hi_lo_to_u128(lo, hi))\n+                } else {\n+                    None\n+                }\n             } else {\n                 None\n             }\n-        } else {\n-            None\n         }\n     }\n }\n \n+#[inline]\n+fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n+    ((hi as u128) << 64) | (lo as u128)\n+}\n+\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,\n@@ -456,7 +473,7 @@ pub fn build_unchecked_rshift(\n }\n \n fn shift_mask_rhs(bx: &Builder<'a, 'll, 'tcx>, rhs: &'ll Value) -> &'ll Value {\n-    let rhs_llty = val_ty(rhs);\n+    let rhs_llty = CodegenCx::val_ty(rhs);\n     bx.and(rhs, shift_mask_val(bx, rhs_llty, rhs_llty, false))\n }\n \n@@ -472,9 +489,9 @@ pub fn shift_mask_val(\n             // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n             let val = llty.int_width() - 1;\n             if invert {\n-                C_int(mask_llty, !val as i64)\n+                CodegenCx::c_int(mask_llty, !val as i64)\n             } else {\n-                C_uint(mask_llty, val)\n+                CodegenCx::c_uint(mask_llty, val)\n             }\n         },\n         TypeKind::Vector => {"}, {"sha": "eb43aa012aad91bb71cf0d682d700082800e887a", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -15,7 +15,7 @@ use rustc::hir::Node;\n use debuginfo;\n use base;\n use monomorphize::MonoItem;\n-use common::{CodegenCx, val_ty};\n+use common::CodegenCx;\n use declare;\n use monomorphize::Instance;\n use syntax_pos::Span;\n@@ -24,6 +24,7 @@ use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n use rustc::ty::{self, Ty};\n+use interfaces::CommonMethods;\n \n use rustc::ty::layout::{Align, LayoutOf};\n \n@@ -72,13 +73,14 @@ pub fn addr_of_mut(\n         let gv = match kind {\n             Some(kind) if !cx.tcx.sess.fewer_names() => {\n                 let name = cx.generate_local_symbol_name(kind);\n-                let gv = declare::define_global(cx, &name[..], val_ty(cv)).unwrap_or_else(||{\n-                    bug!(\"symbol `{}` is already defined\", name);\n+                let gv = declare::define_global(cx, &name[..],\n+                    CodegenCx::val_ty(cv)).unwrap_or_else(||{\n+                        bug!(\"symbol `{}` is already defined\", name);\n                 });\n                 llvm::LLVMRustSetLinkage(gv, llvm::Linkage::PrivateLinkage);\n                 gv\n             },\n-            _ => declare::define_private_global(cx, val_ty(cv)),\n+            _ => declare::define_private_global(cx, CodegenCx::val_ty(cv)),\n         };\n         llvm::LLVMSetInitializer(gv, cv);\n         set_global_alignment(cx, gv, align);\n@@ -310,7 +312,7 @@ pub fn codegen_static<'a, 'tcx>(\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n-        let mut val_llty = val_ty(v);\n+        let mut val_llty = CodegenCx::val_ty(v);\n         let v = if val_llty == Type::i1(cx) {\n             val_llty = Type::i8(cx);\n             llvm::LLVMConstZExt(v, val_llty)"}, {"sha": "252650e52ba9122668b1b39d0c95c17bf48bbe4c", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -12,13 +12,13 @@\n \n use llvm;\n \n-use common::{C_bytes, CodegenCx, C_i32};\n+use common::CodegenCx;\n use builder::Builder;\n use declare;\n use rustc::session::config::DebugInfo;\n use type_::Type;\n use value::Value;\n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use syntax::attr;\n \n@@ -30,7 +30,7 @@ pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &Builder) {\n         let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx.cx);\n         // Load just the first byte as that's all that's necessary to force\n         // LLVM to keep around the reference to the global.\n-        let indices = [C_i32(bx.cx, 0), C_i32(bx.cx, 0)];\n+        let indices = [CodegenCx::c_i32(bx.cx, 0), CodegenCx::c_i32(bx.cx, 0)];\n         let element = bx.inbounds_gep(gdb_debug_scripts_section, &indices);\n         let volative_load_instruction = bx.volatile_load(element);\n         unsafe {\n@@ -64,7 +64,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n                 bug!(\"symbol `{}` is already defined\", section_var_name)\n             });\n             llvm::LLVMSetSection(section_var, section_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(section_var, C_bytes(cx, section_contents));\n+            llvm::LLVMSetInitializer(section_var, CodegenCx::c_bytes(cx, section_contents));\n             llvm::LLVMSetGlobalConstant(section_var, llvm::True);\n             llvm::LLVMSetUnnamedAddr(section_var, llvm::True);\n             llvm::LLVMRustSetLinkage(section_var, llvm::Linkage::LinkOnceODRLinkage);"}, {"sha": "e0bada7e8860a9457772761570b687bf6431d0c6", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -18,6 +18,7 @@ use super::namespace::mangled_name_of_instance;\n use super::type_names::compute_debuginfo_type_name;\n use super::{CrateDebugContext};\n use abi;\n+use interfaces::CommonMethods;\n use value::Value;\n \n use llvm;\n@@ -32,7 +33,7 @@ use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ich::NodeIdHashingMode;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc::ty::Instance;\n-use common::{CodegenCx, C_u64};\n+use common::CodegenCx;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, Align, HasDataLayout, Integer, IntegerExt, LayoutOf,\n                         PrimitiveExt, Size, TyLayout};\n@@ -1810,7 +1811,7 @@ fn set_members_of_composite_type(cx: &CodegenCx<'ll, '_>,\n                     member_description.offset.bits(),\n                     match member_description.discriminant {\n                         None => None,\n-                        Some(value) => Some(C_u64(cx, value)),\n+                        Some(value) => Some(cx.c_u64(value)),\n                     },\n                     member_description.flags,\n                     member_description.type_metadata))"}, {"sha": "2846742cb59481e227908b6e0f4abc7c3ae8f83f", "filename": "src/librustc_codegen_llvm/glue.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fglue.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -16,11 +16,12 @@ use std;\n \n use builder::Builder;\n use common::*;\n+use context::CodegenCx;\n use meth;\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n use value::Value;\n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n pub fn size_and_align_of_dst(\n     bx: &Builder<'_, 'll, 'tcx>,\n@@ -33,8 +34,8 @@ pub fn size_and_align_of_dst(\n         let (size, align) = bx.cx.size_and_align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {:?} align: {:?}\",\n                t, info, size, align);\n-        let size = C_usize(bx.cx, size.bytes());\n-        let align = C_usize(bx.cx, align.abi());\n+        let size = CodegenCx::c_usize(bx.cx, size.bytes());\n+        let align = CodegenCx::c_usize(bx.cx, align.abi());\n         return (size, align);\n     }\n     match t.sty {\n@@ -48,8 +49,8 @@ pub fn size_and_align_of_dst(\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let (size, align) = bx.cx.size_and_align_of(unit);\n-            (bx.mul(info.unwrap(), C_usize(bx.cx, size.bytes())),\n-             C_usize(bx.cx, align.abi()))\n+            (bx.mul(info.unwrap(), CodegenCx::c_usize(bx.cx, size.bytes())),\n+             CodegenCx::c_usize(bx.cx, align.abi()))\n         }\n         _ => {\n             let cx = bx.cx;\n@@ -65,8 +66,8 @@ pub fn size_and_align_of_dst(\n             let sized_align = layout.align.abi();\n             debug!(\"DST {} statically sized prefix size: {} align: {}\",\n                    t, sized_size, sized_align);\n-            let sized_size = C_usize(cx, sized_size);\n-            let sized_align = C_usize(cx, sized_align);\n+            let sized_size = CodegenCx::c_usize(cx, sized_size);\n+            let sized_align = CodegenCx::c_usize(cx, sized_align);\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n@@ -92,12 +93,12 @@ pub fn size_and_align_of_dst(\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = match (const_to_opt_u128(sized_align, false),\n-                               const_to_opt_u128(unsized_align, false)) {\n+            let align = match (CodegenCx::const_to_opt_u128(sized_align, false),\n+                               CodegenCx::const_to_opt_u128(unsized_align, false)) {\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n+                    CodegenCx::c_usize(cx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bx.select(bx.icmp(IntPredicate::IntUGT, sized_align, unsized_align),\n                                sized_align,\n@@ -115,7 +116,7 @@ pub fn size_and_align_of_dst(\n             //\n             //   `(size + (align-1)) & -align`\n \n-            let addend = bx.sub(align, C_usize(bx.cx, 1));\n+            let addend = bx.sub(align, CodegenCx::c_usize(bx.cx, 1));\n             let size = bx.and(bx.add(size, addend), bx.neg(align));\n \n             (size, align)"}, {"sha": "648ae15eb3fa06fbdc3da37046af6c9691ad4d7a", "filename": "src/librustc_codegen_llvm/interfaces/backend.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fbackend.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -12,4 +12,5 @@ pub trait Backend {\n     type Value;\n     type BasicBlock;\n     type Type;\n+    type Context;\n }"}, {"sha": "c43e3b7504a128a82990820ce6684ba7e510f35f", "filename": "src/librustc_codegen_llvm/interfaces/common.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fcommon.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::Backend;\n+use syntax::symbol::LocalInternedString;\n+\n+pub trait CommonMethods : Backend {\n+    fn val_ty(v: Self::Value) -> Self::Type;\n+\n+    // Constant constructors\n+    fn c_null(t: Self::Type) -> Self::Value;\n+    fn c_undef(t: Self::Type) -> Self::Value;\n+    fn c_int(t: Self::Type, i: i64) -> Self::Value;\n+    fn c_uint(t: Self::Type, i: u64) -> Self::Value;\n+    fn c_uint_big(t: Self::Type, u: u128) -> Self::Value;\n+    fn c_bool(&self, val: bool) -> Self::Value;\n+    fn c_i32(&self, i: i32) -> Self::Value;\n+    fn c_u32(&self, i: u32) -> Self::Value;\n+    fn c_u64(&self, i: u64) -> Self::Value;\n+    fn c_usize(&self, i: u64) -> Self::Value;\n+    fn c_u8(&self, i: u8) -> Self::Value;\n+    fn c_cstr(\n+        &self,\n+        s: LocalInternedString,\n+        null_terminated: bool,\n+    ) -> Self::Value;\n+    fn c_str_slice(&self, s: LocalInternedString) -> Self::Value;\n+    fn c_fat_ptr(\n+        &self,\n+        ptr: Self::Value,\n+        meta: Self::Value\n+    ) -> Self::Value;\n+    fn c_struct(\n+        &self,\n+        elts: &[Self::Value],\n+        packed: bool\n+    ) -> Self::Value;\n+    fn c_struct_in_context(\n+        llcx: Self::Context,\n+        elts: &[Self::Value],\n+        packed: bool,\n+    ) -> Self::Value;\n+    fn c_array(ty: Self::Type, elts: &[Self::Value]) -> Self::Value;\n+    fn c_vector(elts: &[Self::Value]) -> Self::Value;\n+    fn c_bytes(&self, bytes: &[u8]) -> Self::Value;\n+    fn c_bytes_in_context(llcx: Self::Context, bytes: &[u8]) -> Self::Value;\n+\n+    fn const_get_elt(v: Self::Value, idx: u64) -> Self::Value;\n+    fn const_get_real(v: Self::Value) -> Option<(f64, bool)>;\n+    fn const_to_uint(v: Self::Value) -> u64;\n+    fn is_const_integral(v: Self::Value) -> bool;\n+    fn is_const_real(v: Self::Value) -> bool;\n+    fn const_to_opt_u128(v: Self::Value, sign_ext: bool) -> Option<u128>;\n+}"}, {"sha": "77db6393f6c1eefb1da4157b0a2bc77c81594b24", "filename": "src/librustc_codegen_llvm/interfaces/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Finterfaces%2Fmod.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -10,6 +10,8 @@\n \n mod builder;\n mod backend;\n+mod common;\n \n pub use self::builder::BuilderMethods;\n pub use self::backend::Backend;\n+pub use self::common::CommonMethods;"}, {"sha": "cb2f3cabf7c4adbc0c3f834a9dc5bdac1782150b", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -19,6 +19,7 @@ use mir::place::PlaceRef;\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n use common::*;\n+use context::CodegenCx;\n use declare;\n use glue;\n use type_::Type;\n@@ -31,7 +32,7 @@ use syntax::symbol::Symbol;\n use builder::Builder;\n use value::Value;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use rustc::session::Session;\n use syntax_pos::Span;\n@@ -126,11 +127,11 @@ pub fn codegen_intrinsic_call(\n         },\n         \"likely\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), C_bool(cx, true)], None)\n+            bx.call(expect, &[args[0].immediate(), CodegenCx::c_bool(cx, true)], None)\n         }\n         \"unlikely\" => {\n             let expect = cx.get_intrinsic(&(\"llvm.expect.i1\"));\n-            bx.call(expect, &[args[0].immediate(), C_bool(cx, false)], None)\n+            bx.call(expect, &[args[0].immediate(), CodegenCx::c_bool(cx, false)], None)\n         }\n         \"try\" => {\n             try_intrinsic(bx, cx,\n@@ -146,7 +147,7 @@ pub fn codegen_intrinsic_call(\n         }\n         \"size_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(cx, cx.size_of(tp_ty).bytes())\n+            CodegenCx::c_usize(cx, cx.size_of(tp_ty).bytes())\n         }\n         \"size_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -155,12 +156,12 @@ pub fn codegen_intrinsic_call(\n                     glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llsize\n             } else {\n-                C_usize(cx, cx.size_of(tp_ty).bytes())\n+                CodegenCx::c_usize(cx, cx.size_of(tp_ty).bytes())\n             }\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(cx, cx.align_of(tp_ty).abi())\n+            CodegenCx::c_usize(cx, cx.align_of(tp_ty).abi())\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -169,20 +170,20 @@ pub fn codegen_intrinsic_call(\n                     glue::size_and_align_of_dst(bx, tp_ty, Some(meta));\n                 llalign\n             } else {\n-                C_usize(cx, cx.align_of(tp_ty).abi())\n+                CodegenCx::c_usize(cx, cx.align_of(tp_ty).abi())\n             }\n         }\n         \"pref_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_usize(cx, cx.align_of(tp_ty).pref())\n+            CodegenCx::c_usize(cx, cx.align_of(tp_ty).pref())\n         }\n         \"type_name\" => {\n             let tp_ty = substs.type_at(0);\n             let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n-            C_str_slice(cx, ty_name)\n+            CodegenCx::c_str_slice(cx, ty_name)\n         }\n         \"type_id\" => {\n-            C_u64(cx, cx.tcx.type_id_hash(substs.type_at(0)))\n+            CodegenCx::c_u64(cx, cx.tcx.type_id_hash(substs.type_at(0)))\n         }\n         \"init\" => {\n             let ty = substs.type_at(0);\n@@ -191,7 +192,14 @@ pub fn codegen_intrinsic_call(\n                 // If we store a zero constant, LLVM will drown in vreg allocation for large data\n                 // structures, and the generated code will be awful. (A telltale sign of this is\n                 // large quantities of `mov [byte ptr foo],0` in the generated code.)\n-                memset_intrinsic(bx, false, ty, llresult, C_u8(cx, 0), C_usize(cx, 1));\n+                memset_intrinsic(\n+                    bx,\n+                    false,\n+                    ty,\n+                    llresult,\n+                    CodegenCx::c_u8(cx, 0),\n+                    CodegenCx::c_usize(cx, 1)\n+                );\n             }\n             return;\n         }\n@@ -202,7 +210,7 @@ pub fn codegen_intrinsic_call(\n         \"needs_drop\" => {\n             let tp_ty = substs.type_at(0);\n \n-            C_bool(cx, bx.cx.type_needs_drop(tp_ty))\n+            CodegenCx::c_bool(cx, bx.cx.type_needs_drop(tp_ty))\n         }\n         \"offset\" => {\n             let ptr = args[0].immediate();\n@@ -279,9 +287,9 @@ pub fn codegen_intrinsic_call(\n             };\n             bx.call(expect, &[\n                 args[0].immediate(),\n-                C_i32(cx, rw),\n+                CodegenCx::c_i32(cx, rw),\n                 args[1].immediate(),\n-                C_i32(cx, cache_type)\n+                CodegenCx::c_i32(cx, cache_type)\n             ], None)\n         },\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n@@ -294,12 +302,12 @@ pub fn codegen_intrinsic_call(\n                 Some((width, signed)) =>\n                     match name {\n                         \"ctlz\" | \"cttz\" => {\n-                            let y = C_bool(bx.cx, false);\n+                            let y = CodegenCx::c_bool(bx.cx, false);\n                             let llfn = cx.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n                         }\n                         \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n-                            let y = C_bool(bx.cx, true);\n+                            let y = CodegenCx::c_bool(bx.cx, true);\n                             let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n                             let llfn = cx.get_intrinsic(llvm_name);\n                             bx.call(llfn, &[args[0].immediate(), y], None)\n@@ -380,7 +388,7 @@ pub fn codegen_intrinsic_call(\n                             } else {\n                                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n-                                let width = C_uint(Type::ix(cx, width), width);\n+                                let width = CodegenCx::c_uint(Type::ix(cx, width), width);\n                                 let shift = bx.urem(raw_shift, width);\n                                 let inv_shift = bx.urem(bx.sub(width, raw_shift), width);\n                                 let shift1 = bx.shl(val, if is_left { shift } else { inv_shift });\n@@ -717,7 +725,7 @@ fn copy_intrinsic(\n ) -> &'ll Value {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n-    let size = C_usize(cx, size.bytes());\n+    let size = CodegenCx::c_usize(cx, size.bytes());\n     let align = align.abi();\n     let dst_ptr = bx.pointercast(dst, Type::i8p(cx));\n     let src_ptr = bx.pointercast(src, Type::i8p(cx));\n@@ -738,8 +746,8 @@ fn memset_intrinsic(\n ) -> &'ll Value {\n     let cx = bx.cx;\n     let (size, align) = cx.size_and_align_of(ty);\n-    let size = C_usize(cx, size.bytes());\n-    let align = C_i32(cx, align.abi() as i32);\n+    let size = CodegenCx::c_usize(cx, size.bytes());\n+    let align = CodegenCx::c_i32(cx, align.abi() as i32);\n     let dst = bx.pointercast(dst, Type::i8p(cx));\n     call_memset(bx, dst, val, bx.mul(size, count), align, volatile)\n }\n@@ -755,7 +763,7 @@ fn try_intrinsic(\n     if bx.sess().no_landing_pads() {\n         bx.call(func, &[data], None);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        bx.store(C_null(Type::i8p(&bx.cx)), dest, ptr_align);\n+        bx.store(CodegenCx::c_null(Type::i8p(&bx.cx)), dest, ptr_align);\n     } else if wants_msvc_seh(bx.sess()) {\n         codegen_msvc_try(bx, cx, func, data, local_ptr, dest);\n     } else {\n@@ -836,7 +844,7 @@ fn codegen_msvc_try(\n         let slot = bx.alloca(i64p, \"slot\", ptr_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n-        normal.ret(C_i32(cx, 0));\n+        normal.ret(CodegenCx::c_i32(cx, 0));\n \n         let cs = catchswitch.catch_switch(None, None, 1);\n         catchswitch.add_handler(cs, catchpad.llbb());\n@@ -846,19 +854,19 @@ fn codegen_msvc_try(\n             Some(did) => ::consts::get_static(cx, did),\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n-        let tok = catchpad.catch_pad(cs, &[tydesc, C_i32(cx, 0), slot]);\n+        let tok = catchpad.catch_pad(cs, &[tydesc, CodegenCx::c_i32(cx, 0), slot]);\n         let addr = catchpad.load(slot, ptr_align);\n \n         let i64_align = bx.tcx().data_layout.i64_align;\n         let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = C_i32(cx, 1);\n+        let val1 = CodegenCx::c_i32(cx, 1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]), i64_align);\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n         catchpad.store(arg1, local_ptr, i64_align);\n         catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), i64_align);\n         catchpad.catch_ret(tok, caught.llbb());\n \n-        caught.ret(C_i32(cx, 1));\n+        caught.ret(CodegenCx::c_i32(cx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -914,7 +922,7 @@ fn codegen_gnu_try(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let local_ptr = llvm::get_param(bx.llfn(), 2);\n         bx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n-        then.ret(C_i32(cx, 0));\n+        then.ret(CodegenCx::c_i32(cx, 0));\n \n         // Type indicator for the exception being thrown.\n         //\n@@ -924,11 +932,11 @@ fn codegen_gnu_try(\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(cx, &[Type::i8p(cx), Type::i32(cx)], false);\n         let vals = catch.landing_pad(lpad_ty, bx.cx.eh_personality(), 1);\n-        catch.add_clause(vals, C_null(Type::i8p(cx)));\n+        catch.add_clause(vals, CodegenCx::c_null(Type::i8p(cx)));\n         let ptr = catch.extract_value(vals, 0);\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n         catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(cx).ptr_to()), ptr_align);\n-        catch.ret(C_i32(cx, 1));\n+        catch.ret(CodegenCx::c_i32(cx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n@@ -1106,8 +1114,8 @@ fn generic_simd_intrinsic(\n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n-                let val = const_get_elt(vector, i as u64);\n-                match const_to_opt_u128(val, true) {\n+                let val = CodegenCx::const_get_elt(vector, i as u64);\n+                match CodegenCx::const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None\n@@ -1117,18 +1125,18 @@ fn generic_simd_intrinsic(\n                                     arg_idx, total_len);\n                         None\n                     }\n-                    Some(idx) => Some(C_i32(bx.cx, idx as i32)),\n+                    Some(idx) => Some(CodegenCx::c_i32(bx.cx, idx as i32)),\n                 }\n             })\n             .collect();\n         let indices = match indices {\n             Some(i) => i,\n-            None => return Ok(C_null(llret_ty))\n+            None => return Ok(CodegenCx::c_null(llret_ty))\n         };\n \n         return Ok(bx.shuffle_vector(args[0].immediate(),\n                                     args[1].immediate(),\n-                                    C_vector(&indices)))\n+                                    CodegenCx::c_vector(&indices)))\n     }\n \n     if name == \"simd_insert\" {\n@@ -1379,7 +1387,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = Type::i32(bx.cx);\n-        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+        let alignment = CodegenCx::c_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1479,7 +1487,7 @@ fn generic_simd_intrinsic(\n \n         // Alignment of T, must be a constant integer value:\n         let alignment_ty = Type::i32(bx.cx);\n-        let alignment = C_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n+        let alignment = CodegenCx::c_i32(bx.cx, bx.cx.align_of(in_elem).abi() as i32);\n \n         // Truncate the mask vector to a vector of i1s:\n         let (mask, mask_ty) = {\n@@ -1541,7 +1549,7 @@ fn generic_simd_intrinsic(\n                             //   code is generated\n                             // * if the accumulator of the fmul isn't 1, incorrect\n                             //   code is generated\n-                            match const_get_real(acc) {\n+                            match CodegenCx::const_get_real(acc) {\n                                 None => return_error!(\"accumulator of {} is not a constant\", $name),\n                                 Some((v, loses_info)) => {\n                                     if $name.contains(\"mul\") && v != 1.0_f64 {\n@@ -1557,8 +1565,8 @@ fn generic_simd_intrinsic(\n                         } else {\n                             // unordered arithmetic reductions do not:\n                             match f.bit_width() {\n-                                32 => C_undef(Type::f32(bx.cx)),\n-                                64 => C_undef(Type::f64(bx.cx)),\n+                                32 => CodegenCx::c_undef(Type::f32(bx.cx)),\n+                                64 => CodegenCx::c_undef(Type::f64(bx.cx)),\n                                 v => {\n                                     return_error!(r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,"}, {"sha": "e35daee0a70e825f59f0f607da40f288569d87ff", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -215,7 +215,7 @@ pub enum TypeKind {\n     Double = 3,\n     X86_FP80 = 4,\n     FP128 = 5,\n-    PPC_FP128 = 6,\n+    PPc_FP128 = 6,\n     Label = 7,\n     Integer = 8,\n     Function = 9,"}, {"sha": "90f24836426a2c10f2b797ee63a21cb38d0766e4", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -10,14 +10,14 @@\n \n use abi::{FnType, FnTypeExt};\n use callee;\n-use common::*;\n+use context::CodegenCx;\n use builder::Builder;\n use consts;\n use monomorphize;\n use type_::Type;\n use value::Value;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use rustc::ty::{self, Ty};\n use rustc::ty::layout::HasDataLayout;\n@@ -43,7 +43,10 @@ impl<'a, 'tcx> VirtualIndex {\n \n         let llvtable = bx.pointercast(llvtable, fn_ty.ptr_to_llvm_type(bx.cx).ptr_to());\n         let ptr_align = bx.tcx().data_layout.pointer_align;\n-        let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), ptr_align);\n+        let ptr = bx.load(\n+            bx.inbounds_gep(llvtable, &[CodegenCx::c_usize(bx.cx, self.0)]),\n+            ptr_align\n+        );\n         bx.nonnull_metadata(ptr);\n         // Vtable loads are invariant\n         bx.set_invariant_load(ptr);\n@@ -60,7 +63,10 @@ impl<'a, 'tcx> VirtualIndex {\n \n         let llvtable = bx.pointercast(llvtable, Type::isize(bx.cx).ptr_to());\n         let usize_align = bx.tcx().data_layout.pointer_align;\n-        let ptr = bx.load(bx.inbounds_gep(llvtable, &[C_usize(bx.cx, self.0)]), usize_align);\n+        let ptr = bx.load(\n+            bx.inbounds_gep(llvtable, &[CodegenCx::c_usize(bx.cx, self.0)]),\n+            usize_align\n+        );\n         // Vtable loads are invariant\n         bx.set_invariant_load(ptr);\n         ptr\n@@ -90,7 +96,7 @@ pub fn get_vtable(\n     }\n \n     // Not in the cache. Build it.\n-    let nullptr = C_null(Type::i8p(cx));\n+    let nullptr = CodegenCx::c_null(Type::i8p(cx));\n \n     let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n     let methods = methods.iter().cloned().map(|opt_mth| {\n@@ -106,11 +112,11 @@ pub fn get_vtable(\n     // /////////////////////////////////////////////////////////////////////////////////////////////\n     let components: Vec<_> = [\n         callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n-        C_usize(cx, size.bytes()),\n-        C_usize(cx, align.abi())\n+        CodegenCx::c_usize(cx, size.bytes()),\n+        CodegenCx::c_usize(cx, align.abi())\n     ].iter().cloned().chain(methods).collect();\n \n-    let vtable_const = C_struct(cx, &components, false);\n+    let vtable_const = CodegenCx::c_struct(cx, &components, false);\n     let align = cx.data_layout().pointer_align;\n     let vtable = consts::addr_of(cx, vtable_const, align, Some(\"vtable\"));\n "}, {"sha": "d9a9cdebd661765d92457cd701399076b2a3b151", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -18,15 +18,16 @@ use abi::{Abi, ArgType, ArgTypeExt, FnType, FnTypeExt, LlvmType, PassMode};\n use base;\n use callee;\n use builder::{Builder, MemFlags};\n-use common::{self, C_bool, C_str_slice, C_struct, C_u32, C_uint_big, C_undef, IntPredicate};\n+use common::{self, IntPredicate};\n+use context::CodegenCx;\n use consts;\n use meth;\n use monomorphize;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use syntax::symbol::Symbol;\n use syntax_pos::Pos;\n@@ -171,7 +172,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     slot.storage_dead(&bx);\n \n                     if !bx.sess().target.target.options.custom_unwind_resume {\n-                        let mut lp = C_undef(self.landing_pad_type());\n+                        let mut lp = CodegenCx::c_undef(self.landing_pad_type());\n                         lp = bx.insert_value(lp, lp0, 0);\n                         lp = bx.insert_value(lp, lp1, 1);\n                         bx.resume(lp);\n@@ -209,7 +210,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         }\n                     } else {\n                         let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n-                        let llval = C_uint_big(switch_llty, values[0]);\n+                        let llval = CodegenCx::c_uint_big(switch_llty, values[0]);\n                         let cmp = bx.icmp(IntPredicate::IntEQ, discr.immediate(), llval);\n                         bx.cond_br(cmp, lltrue, llfalse);\n                     }\n@@ -220,7 +221,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                            values.len());\n                     let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n                     for (&value, target) in values.iter().zip(targets) {\n-                        let llval = C_uint_big(switch_llty, value);\n+                        let llval = CodegenCx::c_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);\n                         bx.add_case(switch, llval, llbb)\n                     }\n@@ -323,7 +324,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond = self.codegen_operand(&bx, cond).immediate();\n-                let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n+                let mut const_cond = CodegenCx::const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n                 // with #[rustc_inherit_overflow_checks] and inlined from\n@@ -346,7 +347,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n                 // Pass the condition through llvm.expect for branch hinting.\n                 let expect = bx.cx.get_intrinsic(&\"llvm.expect.i1\");\n-                let cond = bx.call(expect, &[cond, C_bool(bx.cx, expected)], None);\n+                let cond = bx.call(expect, &[cond, CodegenCx::c_bool(bx.cx, expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, target);\n@@ -364,9 +365,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // Get the location information.\n                 let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                 let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                let filename = C_str_slice(bx.cx, filename);\n-                let line = C_u32(bx.cx, loc.line as u32);\n-                let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                let filename = CodegenCx::c_str_slice(bx.cx, filename);\n+                let line = CodegenCx::c_u32(bx.cx, loc.line as u32);\n+                let col = CodegenCx::c_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n                 let align = tcx.data_layout.aggregate_align\n                     .max(tcx.data_layout.i32_align)\n                     .max(tcx.data_layout.pointer_align);\n@@ -377,7 +378,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let len = self.codegen_operand(&mut bx, len).immediate();\n                         let index = self.codegen_operand(&mut bx, index).immediate();\n \n-                        let file_line_col = C_struct(bx.cx, &[filename, line, col], false);\n+                        let file_line_col = CodegenCx::c_struct(bx.cx,\n+                             &[filename, line, col], false);\n                         let file_line_col = consts::addr_of(bx.cx,\n                                                             file_line_col,\n                                                             align,\n@@ -388,10 +390,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     _ => {\n                         let str = msg.description();\n                         let msg_str = Symbol::intern(str).as_str();\n-                        let msg_str = C_str_slice(bx.cx, msg_str);\n-                        let msg_file_line_col = C_struct(bx.cx,\n-                                                         &[msg_str, filename, line, col],\n-                                                         false);\n+                        let msg_str = CodegenCx::c_str_slice(bx.cx, msg_str);\n+                        let msg_file_line_col = CodegenCx::c_struct(\n+                            bx.cx,\n+                            &[msg_str, filename, line, col],\n+                            false\n+                        );\n                         let msg_file_line_col = consts::addr_of(bx.cx,\n                                                                 msg_file_line_col,\n                                                                 align,\n@@ -497,9 +501,9 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 {\n                     let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n                     let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = C_str_slice(bx.cx, filename);\n-                    let line = C_u32(bx.cx, loc.line as u32);\n-                    let col = C_u32(bx.cx, loc.col.to_usize() as u32 + 1);\n+                    let filename = bx.cx.c_str_slice(filename);\n+                    let line = bx.cx.c_u32(loc.line as u32);\n+                    let col = bx.cx.c_u32(loc.col.to_usize() as u32 + 1);\n                     let align = tcx.data_layout.aggregate_align\n                         .max(tcx.data_layout.i32_align)\n                         .max(tcx.data_layout.pointer_align);\n@@ -510,10 +514,11 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n                     );\n                     let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = C_str_slice(bx.cx, msg_str);\n-                    let msg_file_line_col = C_struct(bx.cx,\n-                                                     &[msg_str, filename, line, col],\n-                                                     false);\n+                    let msg_str = bx.cx.c_str_slice(msg_str);\n+                    let msg_file_line_col = bx.cx.c_struct(\n+                        &[msg_str, filename, line, col],\n+                        false,\n+                    );\n                     let msg_file_line_col = consts::addr_of(bx.cx,\n                                                             msg_file_line_col,\n                                                             align,\n@@ -558,7 +563,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     let dest = match ret_dest {\n                         _ if fn_ty.ret.is_indirect() => llargs[0],\n                         ReturnDest::Nothing => {\n-                            C_undef(fn_ty.ret.memory_ty(bx.cx).ptr_to())\n+                            CodegenCx::c_undef(fn_ty.ret.memory_ty(bx.cx).ptr_to())\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => dst.llval,\n@@ -739,7 +744,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                       arg: &ArgType<'tcx, Ty<'tcx>>) {\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n-            llargs.push(C_undef(ty.llvm_type(bx.cx)));\n+            llargs.push(CodegenCx::c_undef(ty.llvm_type(bx.cx)));\n         }\n \n         if arg.is_ignore() {"}, {"sha": "ed1ef2db681a50ad8422b72f189ffce746115b25", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -19,14 +19,13 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, HasDataLayout, LayoutOf, Size};\n use builder::Builder;\n use common::{CodegenCx};\n-use common::{C_bytes, C_struct, C_uint_big, C_undef, C_usize};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use value::Value;\n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use super::super::callee;\n use super::FunctionCx;\n@@ -41,11 +40,11 @@ pub fn scalar_to_llvm(\n     match cv {\n         Scalar::Bits { size: 0, .. } => {\n             assert_eq!(0, layout.value.size(cx).bytes());\n-            C_undef(Type::ix(cx, 0))\n+            CodegenCx::c_undef(Type::ix(cx, 0))\n         },\n         Scalar::Bits { bits, size } => {\n             assert_eq!(size as u64, layout.value.size(cx).bytes());\n-            let llval = C_uint_big(Type::ix(cx, bitsize), bits);\n+            let llval = CodegenCx::c_uint_big(Type::ix(cx, bitsize), bits);\n             if layout.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n             } else {\n@@ -74,7 +73,7 @@ pub fn scalar_to_llvm(\n             };\n             let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n                 consts::bitcast(base_addr, Type::i8p(cx)),\n-                &C_usize(cx, ptr.offset.bytes()),\n+                &CodegenCx::c_usize(cx, ptr.offset.bytes()),\n                 1,\n             ) };\n             if layout.value != layout::Pointer {\n@@ -97,7 +96,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            llvals.push(C_bytes(cx, &alloc.bytes[next_offset..offset]));\n+            llvals.push(CodegenCx::c_bytes(cx, &alloc.bytes[next_offset..offset]));\n         }\n         let ptr_offset = read_target_uint(\n             dl.endian,\n@@ -115,10 +114,10 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         next_offset = offset + pointer_size;\n     }\n     if alloc.bytes.len() >= next_offset {\n-        llvals.push(C_bytes(cx, &alloc.bytes[next_offset ..]));\n+        llvals.push(CodegenCx::c_bytes(cx, &alloc.bytes[next_offset ..]));\n     }\n \n-    C_struct(cx, &llvals, true)\n+    CodegenCx::c_struct(cx, &llvals, true)\n }\n \n pub fn codegen_static_initializer(\n@@ -208,7 +207,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         bug!(\"simd shuffle field {:?}\", field)\n                     }\n                 }).collect();\n-                let llval = C_struct(bx.cx, &values?, false);\n+                let llval = CodegenCx::c_struct(bx.cx, &values?, false);\n                 Ok((llval, c.ty))\n             })\n             .unwrap_or_else(|_| {\n@@ -219,7 +218,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(&ty);\n                 let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n-                (C_undef(llty), ty)\n+                (CodegenCx::c_undef(llty), ty)\n             })\n     }\n }"}, {"sha": "e3546688e2bccb47a9b748156cc2d38f0c4249e6", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use common::{C_i32, C_null};\n use libc::c_uint;\n use llvm::{self, BasicBlock};\n use llvm::debuginfo::DIScope;\n@@ -26,7 +25,7 @@ use monomorphize::Instance;\n use abi::{ArgTypeExt, FnType, FnTypeExt, PassMode};\n use type_::Type;\n use value::Value;\n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -421,8 +420,8 @@ fn create_funclets(\n                 // C++ personality function, but `catch (...)` has no type so\n                 // it's null. The 64 here is actually a bitfield which\n                 // represents that this is a catch-all block.\n-                let null = C_null(Type::i8p(bx.cx));\n-                let sixty_four = C_i32(bx.cx, 64);\n+                let null = CodegenCx::c_null(Type::i8p(bx.cx));\n+                let sixty_four = CodegenCx::c_i32(bx.cx, 64);\n                 cleanup = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n                 cp_bx.br(llbb);\n             }"}, {"sha": "9e88c60d2f22dc3f8f7d4297af954975e4a293f4", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -14,14 +14,14 @@ use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n \n use base;\n-use common::{CodegenCx, C_undef, C_usize};\n+use common::CodegenCx;\n use builder::{Builder, MemFlags};\n use value::Value;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use glue;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use std::fmt;\n \n@@ -73,7 +73,7 @@ impl OperandRef<'tcx, &'ll Value> {\n                    layout: TyLayout<'tcx>) -> OperandRef<'tcx, &'ll Value> {\n         assert!(layout.is_zst());\n         OperandRef {\n-            val: OperandValue::Immediate(C_undef(layout.immediate_llvm_type(cx))),\n+            val: OperandValue::Immediate(CodegenCx::c_undef(layout.immediate_llvm_type(cx))),\n             layout\n         }\n     }\n@@ -167,7 +167,7 @@ impl OperandRef<'tcx, &'ll Value> {\n             debug!(\"Operand::immediate_or_packed_pair: packing {:?} into {:?}\",\n                    self, llty);\n             // Reconstruct the immediate aggregate.\n-            let mut llpair = C_undef(llty);\n+            let mut llpair = CodegenCx::c_undef(llty);\n             llpair = bx.insert_value(llpair, base::from_immediate(bx, a), 0);\n             llpair = bx.insert_value(llpair, base::from_immediate(bx, b), 1);\n             llpair\n@@ -232,7 +232,7 @@ impl OperandRef<'tcx, &'ll Value> {\n             // `#[repr(simd)]` types are also immediate.\n             (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n-                    bx.extract_element(llval, C_usize(bx.cx, i as u64)))\n+                    bx.extract_element(llval, CodegenCx::c_usize(bx.cx, i as u64)))\n             }\n \n             _ => bug!(\"OperandRef::extract_field({:?}): not applicable\", self)\n@@ -463,7 +463,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // We've errored, so we don't have to produce working code.\n                         let layout = bx.cx.layout_of(ty);\n                         PlaceRef::new_sized(\n-                            C_undef(layout.llvm_type(bx.cx).ptr_to()),\n+                            CodegenCx::c_undef(layout.llvm_type(bx.cx).ptr_to()),\n                             layout,\n                             layout.align,\n                         ).load(bx)"}, {"sha": "1360c0307b31054eb040def5e5a2917cdbdea1d3", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -15,15 +15,15 @@ use rustc::mir;\n use rustc::mir::tcx::PlaceTy;\n use base;\n use builder::Builder;\n-use common::{CodegenCx, C_undef, C_usize, C_u8, C_u32, C_uint, C_null, C_uint_big, IntPredicate};\n+use common::{CodegenCx, IntPredicate};\n use consts;\n use type_of::LayoutLlvmExt;\n use type_::Type;\n use value::Value;\n use glue;\n use mir::constant::const_alloc_to_llvm;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n@@ -69,7 +69,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         let llval = unsafe { LLVMConstInBoundsGEP(\n             consts::bitcast(base_addr, Type::i8p(bx.cx)),\n-            &C_usize(bx.cx, offset.bytes()),\n+            &CodegenCx::c_usize(bx.cx, offset.bytes()),\n             1,\n         )};\n         let llval = consts::bitcast(llval, layout.llvm_type(bx.cx).ptr_to());\n@@ -103,7 +103,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 assert_eq!(count, 0);\n                 self.llextra.unwrap()\n             } else {\n-                C_usize(cx, count)\n+                CodegenCx::c_usize(cx, count)\n             }\n         } else {\n             bug!(\"unexpected layout `{:#?}` in PlaceRef::len\", self.layout)\n@@ -248,7 +248,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n \n         let meta = self.llextra;\n \n-        let unaligned_offset = C_usize(cx, offset.bytes());\n+        let unaligned_offset = CodegenCx::c_usize(cx, offset.bytes());\n \n         // Get the alignment of the field\n         let (_, unsized_align) = glue::size_and_align_of_dst(bx, field.ty, meta);\n@@ -259,7 +259,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bx.sub(unsized_align, C_usize(cx, 1u64));\n+        let align_sub_1 = bx.sub(unsized_align, CodegenCx::c_usize(cx, 1u64));\n         let offset = bx.and(bx.add(unaligned_offset, align_sub_1),\n         bx.neg(unsized_align));\n \n@@ -289,14 +289,14 @@ impl PlaceRef<'tcx, &'ll Value> {\n     ) -> &'ll Value {\n         let cast_to = bx.cx.layout_of(cast_to).immediate_llvm_type(bx.cx);\n         if self.layout.abi.is_uninhabited() {\n-            return C_undef(cast_to);\n+            return CodegenCx::c_undef(cast_to);\n         }\n         match self.layout.variants {\n             layout::Variants::Single { index } => {\n                 let discr_val = self.layout.ty.ty_adt_def().map_or(\n                     index.as_u32() as u128,\n                     |def| def.discriminant_for_variant(bx.cx.tcx, index).val);\n-                return C_uint_big(cast_to, discr_val);\n+                return CodegenCx::c_uint_big(cast_to, discr_val);\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n@@ -327,22 +327,23 @@ impl PlaceRef<'tcx, &'ll Value> {\n                 if niche_variants.start() == niche_variants.end() {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n-                        // HACK(eddyb) Using `C_null` as it works on all types.\n-                        C_null(niche_llty)\n+                        // HACK(eddyb) Using `c_null` as it works on all types.\n+                        CodegenCx::c_null(niche_llty)\n                     } else {\n-                        C_uint_big(niche_llty, niche_start)\n+                        CodegenCx::c_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(IntPredicate::IntEQ, lldiscr, niche_llval),\n-                        C_uint(cast_to, niche_variants.start().as_u32() as u64),\n-                        C_uint(cast_to, dataful_variant.as_u32() as u64))\n+                        CodegenCx::c_uint(cast_to, niche_variants.start().as_u32() as u64),\n+                        CodegenCx::c_uint(cast_to, dataful_variant.as_u32() as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n                     let delta = niche_start.wrapping_sub(niche_variants.start().as_u32() as u128);\n-                    let lldiscr = bx.sub(lldiscr, C_uint_big(niche_llty, delta));\n-                    let lldiscr_max = C_uint(niche_llty, niche_variants.end().as_u32() as u64);\n+                    let lldiscr = bx.sub(lldiscr, CodegenCx::c_uint_big(niche_llty, delta));\n+                    let lldiscr_max =\n+                        CodegenCx::c_uint(niche_llty, niche_variants.end().as_u32() as u64);\n                     bx.select(bx.icmp(IntPredicate::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n-                        C_uint(cast_to, dataful_variant.as_u32() as u64))\n+                        CodegenCx::c_uint(cast_to, dataful_variant.as_u32() as u64))\n                 }\n             }\n         }\n@@ -364,7 +365,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n                     .discriminant_for_variant(bx.tcx(), variant_index)\n                     .val;\n                 bx.store(\n-                    C_uint_big(ptr.layout.llvm_type(bx.cx), to),\n+                    CodegenCx::c_uint_big(ptr.layout.llvm_type(bx.cx), to),\n                     ptr.llval,\n                     ptr.align);\n             }\n@@ -380,10 +381,10 @@ impl PlaceRef<'tcx, &'ll Value> {\n                         // Issue #34427: As workaround for LLVM bug on ARM,\n                         // use memset of 0 before assigning niche value.\n                         let llptr = bx.pointercast(self.llval, Type::i8(bx.cx).ptr_to());\n-                        let fill_byte = C_u8(bx.cx, 0);\n+                        let fill_byte = CodegenCx::c_u8(bx.cx, 0);\n                         let (size, align) = self.layout.size_and_align();\n-                        let size = C_usize(bx.cx, size.bytes());\n-                        let align = C_u32(bx.cx, align.abi() as u32);\n+                        let size = CodegenCx::c_usize(bx.cx, size.bytes());\n+                        let align = CodegenCx::c_u32(bx.cx, align.abi() as u32);\n                         base::call_memset(bx, llptr, fill_byte, size, align, false);\n                     }\n \n@@ -394,10 +395,10 @@ impl PlaceRef<'tcx, &'ll Value> {\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {\n-                        // HACK(eddyb) Using `C_null` as it works on all types.\n-                        C_null(niche_llty)\n+                        // HACK(eddyb) Using `c_null` as it works on all types.\n+                        CodegenCx::c_null(niche_llty)\n                     } else {\n-                        C_uint_big(niche_llty, niche_value)\n+                        CodegenCx::c_uint_big(niche_llty, niche_value)\n                     };\n                     OperandValue::Immediate(niche_llval).store(bx, niche);\n                 }\n@@ -408,7 +409,7 @@ impl PlaceRef<'tcx, &'ll Value> {\n     pub fn project_index(&self, bx: &Builder<'a, 'll, 'tcx>, llindex: &'ll Value)\n                          -> PlaceRef<'tcx, &'ll Value> {\n         PlaceRef {\n-            llval: bx.inbounds_gep(self.llval, &[C_usize(bx.cx, 0), llindex]),\n+            llval: bx.inbounds_gep(self.llval, &[CodegenCx::c_usize(bx.cx, 0), llindex]),\n             llextra: None,\n             layout: self.layout.field(bx.cx, 0),\n             align: self.align\n@@ -483,7 +484,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         // so we generate an abort\n                         let fnname = bx.cx.get_intrinsic(&(\"llvm.trap\"));\n                         bx.call(fnname, &[], None);\n-                        let llval = C_undef(layout.llvm_type(bx.cx).ptr_to());\n+                        let llval = CodegenCx::c_undef(layout.llvm_type(bx.cx).ptr_to());\n                         PlaceRef::new_sized(llval, layout, layout.align)\n                     }\n                 }\n@@ -516,28 +517,28 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: false,\n                                                          min_length: _ } => {\n-                        let lloffset = C_usize(bx.cx, offset as u64);\n+                        let lloffset = CodegenCx::c_usize(bx.cx, offset as u64);\n                         cg_base.project_index(bx, lloffset)\n                     }\n                     mir::ProjectionElem::ConstantIndex { offset,\n                                                          from_end: true,\n                                                          min_length: _ } => {\n-                        let lloffset = C_usize(bx.cx, offset as u64);\n+                        let lloffset = CodegenCx::c_usize(bx.cx, offset as u64);\n                         let lllen = cg_base.len(bx.cx);\n                         let llindex = bx.sub(lllen, lloffset);\n                         cg_base.project_index(bx, llindex)\n                     }\n                     mir::ProjectionElem::Subslice { from, to } => {\n                         let mut subslice = cg_base.project_index(bx,\n-                            C_usize(bx.cx, from as u64));\n+                            CodegenCx::c_usize(bx.cx, from as u64));\n                         let projected_ty = PlaceTy::Ty { ty: cg_base.layout.ty }\n                             .projection_ty(tcx, &projection.elem)\n                             .to_ty(bx.tcx());\n                         subslice.layout = bx.cx.layout_of(self.monomorphize(&projected_ty));\n \n                         if subslice.layout.is_unsized() {\n                             subslice.llextra = Some(bx.sub(cg_base.llextra.unwrap(),\n-                                C_usize(bx.cx, (from as u64) + (to as u64))));\n+                                CodegenCx::c_usize(bx.cx, (from as u64) + (to as u64))));\n                         }\n \n                         // Cast the place pointer type to the new"}, {"sha": "38557f026066bb6da7ccad6e4f1de6a4c8deaa4f", "filename": "src/librustc_codegen_llvm/mir/rvalue.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Frvalue.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -19,18 +19,15 @@ use std::{u128, i128};\n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty};\n-use common::{\n-    C_bool, C_u8, C_i32, C_u32, C_u64, C_undef, C_null, C_usize,\n-    C_uint, C_uint_big, IntPredicate, RealPredicate\n-};\n+use common::{self, IntPredicate, RealPredicate};\n+use context::CodegenCx;\n use consts;\n use monomorphize;\n use type_::Type;\n use type_of::LayoutLlvmExt;\n use value::Value;\n \n-use interfaces::BuilderMethods;\n+use interfaces::{BuilderMethods, CommonMethods};\n \n use super::{FunctionCx, LocalRef};\n use super::operand::{OperandRef, OperandValue};\n@@ -106,44 +103,44 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                     return bx;\n                 }\n \n-                let start = dest.project_index(&bx, C_usize(bx.cx, 0)).llval;\n+                let start = dest.project_index(&bx, CodegenCx::c_usize(bx.cx, 0)).llval;\n \n                 if let OperandValue::Immediate(v) = cg_elem.val {\n-                    let align = C_i32(bx.cx, dest.align.abi() as i32);\n-                    let size = C_usize(bx.cx, dest.layout.size.bytes());\n+                    let align = CodegenCx::c_i32(bx.cx, dest.align.abi() as i32);\n+                    let size = CodegenCx::c_usize(bx.cx, dest.layout.size.bytes());\n \n                     // Use llvm.memset.p0i8.* to initialize all zero arrays\n-                    if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n-                        let fill = C_u8(bx.cx, 0);\n+                    if CodegenCx::is_const_integral(v) && CodegenCx::const_to_uint(v) == 0 {\n+                        let fill = CodegenCx::c_u8(bx.cx, 0);\n                         base::call_memset(&bx, start, fill, size, align, false);\n                         return bx;\n                     }\n \n                     // Use llvm.memset.p0i8.* to initialize byte arrays\n                     let v = base::from_immediate(&bx, v);\n-                    if common::val_ty(v) == Type::i8(bx.cx) {\n+                    if CodegenCx::val_ty(v) == Type::i8(bx.cx) {\n                         base::call_memset(&bx, start, v, size, align, false);\n                         return bx;\n                     }\n                 }\n \n-                let count = C_usize(bx.cx, count);\n+                let count = CodegenCx::c_usize(bx.cx, count);\n                 let end = dest.project_index(&bx, count).llval;\n \n                 let header_bx = bx.build_sibling_block(\"repeat_loop_header\");\n                 let body_bx = bx.build_sibling_block(\"repeat_loop_body\");\n                 let next_bx = bx.build_sibling_block(\"repeat_loop_next\");\n \n                 bx.br(header_bx.llbb());\n-                let current = header_bx.phi(common::val_ty(start), &[start], &[bx.llbb()]);\n+                let current = header_bx.phi(CodegenCx::val_ty(start), &[start], &[bx.llbb()]);\n \n                 let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n                 header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n \n                 cg_elem.val.store(&body_bx,\n                     PlaceRef::new_sized(current, cg_elem.layout, dest.align));\n \n-                let next = body_bx.inbounds_gep(current, &[C_usize(bx.cx, 1)]);\n+                let next = body_bx.inbounds_gep(current, &[CodegenCx::c_usize(bx.cx, 1)]);\n                 body_bx.br(header_bx.llbb());\n                 header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n \n@@ -296,7 +293,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                         let ll_t_out = cast.immediate_llvm_type(bx.cx);\n                         if operand.layout.abi.is_uninhabited() {\n                             return (bx, OperandRef {\n-                                val: OperandValue::Immediate(C_undef(ll_t_out)),\n+                                val: OperandValue::Immediate(CodegenCx::c_undef(ll_t_out)),\n                                 layout: cast,\n                             });\n                         }\n@@ -310,7 +307,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     let discr_val = def\n                                         .discriminant_for_variant(bx.cx.tcx, index)\n                                         .val;\n-                                    let discr = C_uint_big(ll_t_out, discr_val);\n+                                    let discr = CodegenCx::c_uint_big(ll_t_out, discr_val);\n                                     return (bx, OperandRef {\n                                         val: OperandValue::Immediate(discr),\n                                         layout: cast,\n@@ -341,7 +338,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                                     base::call_assume(&bx, bx.icmp(\n                                         IntPredicate::IntULE,\n                                         llval,\n-                                        C_uint_big(ll_t_in, *scalar.valid_range.end())\n+                                        CodegenCx::c_uint_big(ll_t_in, *scalar.valid_range.end())\n                                     ));\n                                 }\n                             }\n@@ -492,7 +489,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n \n             mir::Rvalue::NullaryOp(mir::NullOp::SizeOf, ty) => {\n                 assert!(bx.cx.type_is_sized(ty));\n-                let val = C_usize(bx.cx, bx.cx.size_of(ty).bytes());\n+                let val = CodegenCx::c_usize(bx.cx, bx.cx.size_of(ty).bytes());\n                 let tcx = bx.tcx();\n                 (bx, OperandRef {\n                     val: OperandValue::Immediate(val),\n@@ -503,8 +500,8 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::Rvalue::NullaryOp(mir::NullOp::Box, content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let (size, align) = bx.cx.size_and_align_of(content_ty);\n-                let llsize = C_usize(bx.cx, size.bytes());\n-                let llalign = C_usize(bx.cx, align.abi());\n+                let llsize = CodegenCx::c_usize(bx.cx, size.bytes());\n+                let llalign = CodegenCx::c_usize(bx.cx, align.abi());\n                 let box_layout = bx.cx.layout_of(bx.tcx().mk_box(content_ty));\n                 let llty_ptr = box_layout.llvm_type(bx.cx);\n \n@@ -551,7 +548,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx.tcx);\n-                    return common::C_usize(bx.cx, n);\n+                    return CodegenCx::c_usize(bx.cx, n);\n                 }\n             }\n         }\n@@ -609,7 +606,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n             mir::BinOp::Shr => common::build_unchecked_rshift(bx, input_ty, lhs, rhs),\n             mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt |\n             mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => if is_unit {\n-                C_bool(bx.cx, match op {\n+                CodegenCx::c_bool(bx.cx, match op {\n                     mir::BinOp::Ne | mir::BinOp::Lt | mir::BinOp::Gt => false,\n                     mir::BinOp::Eq | mir::BinOp::Le | mir::BinOp::Ge => true,\n                     _ => unreachable!()\n@@ -688,7 +685,7 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n         // while the current crate doesn't use overflow checks.\n         if !bx.cx.check_overflow {\n             let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-            return OperandValue::Pair(val, C_bool(bx.cx, false));\n+            return OperandValue::Pair(val, CodegenCx::c_bool(bx.cx, false));\n         }\n \n         let (val, of) = match op {\n@@ -707,12 +704,12 @@ impl FunctionCx<'a, 'll, 'tcx, &'ll Value> {\n                  bx.extract_value(res, 1))\n             }\n             mir::BinOp::Shl | mir::BinOp::Shr => {\n-                let lhs_llty = val_ty(lhs);\n-                let rhs_llty = val_ty(rhs);\n+                let lhs_llty = CodegenCx::val_ty(lhs);\n+                let rhs_llty = CodegenCx::val_ty(rhs);\n                 let invert_mask = common::shift_mask_val(&bx, lhs_llty, rhs_llty, true);\n                 let outer_bits = bx.and(rhs, invert_mask);\n \n-                let of = bx.icmp(IntPredicate::IntNE, outer_bits, C_null(rhs_llty));\n+                let of = bx.icmp(IntPredicate::IntNE, outer_bits, CodegenCx::c_null(rhs_llty));\n                 let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n \n                 (val, of)\n@@ -839,9 +836,9 @@ fn cast_int_to_float(bx: &Builder<'_, 'll, '_>,\n         use rustc_apfloat::Float;\n         const MAX_F32_PLUS_HALF_ULP: u128 = ((1 << (Single::PRECISION + 1)) - 1)\n                                             << (Single::MAX_EXP - Single::PRECISION as i16);\n-        let max = C_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n+        let max = CodegenCx::c_uint_big(int_ty, MAX_F32_PLUS_HALF_ULP);\n         let overflow = bx.icmp(IntPredicate::IntUGE, x, max);\n-        let infinity_bits = C_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity_bits = CodegenCx::c_u32(bx.cx, ieee::Single::INFINITY.to_bits() as u32);\n         let infinity = consts::bitcast(infinity_bits, float_ty);\n         bx.select(overflow, infinity, bx.uitofp(x, float_ty))\n     } else {\n@@ -910,8 +907,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     }\n     let float_bits_to_llval = |bits| {\n         let bits_llval = match float_ty.float_width() {\n-            32 => C_u32(bx.cx, bits as u32),\n-            64 => C_u64(bx.cx, bits as u64),\n+            32 => CodegenCx::c_u32(bx.cx, bits as u32),\n+            64 => CodegenCx::c_u64(bx.cx, bits as u64),\n             n => bug!(\"unsupported float width {}\", n),\n         };\n         consts::bitcast(bits_llval, float_ty)\n@@ -966,8 +963,8 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // performed is ultimately up to the backend, but at least x86 does perform them.\n     let less_or_nan = bx.fcmp(RealPredicate::RealULT, x, f_min);\n     let greater = bx.fcmp(RealPredicate::RealOGT, x, f_max);\n-    let int_max = C_uint_big(int_ty, int_max(signed, int_ty));\n-    let int_min = C_uint_big(int_ty, int_min(signed, int_ty) as u128);\n+    let int_max = CodegenCx::c_uint_big(int_ty, int_max(signed, int_ty));\n+    let int_min = CodegenCx::c_uint_big(int_ty, int_min(signed, int_ty) as u128);\n     let s0 = bx.select(less_or_nan, int_min, fptosui_result);\n     let s1 = bx.select(greater, int_max, s0);\n \n@@ -976,7 +973,7 @@ fn cast_float_to_int(bx: &Builder<'_, 'll, '_>,\n     // Therefore we only need to execute this step for signed integer types.\n     if signed {\n         // LLVM has no isNaN predicate, so we use (x == x) instead\n-        bx.select(bx.fcmp(RealPredicate::RealOEQ, x, x), s1, C_uint(int_ty, 0))\n+        bx.select(bx.fcmp(RealPredicate::RealOEQ, x, x), s1, CodegenCx::c_uint(int_ty, 0))\n     } else {\n         s1\n     }"}, {"sha": "e78cf5dfa8d2c125bba9972529a3e51201f40ac7", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8714e6bce6b04482723f0b735879533c82c114fa/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=8714e6bce6b04482723f0b735879533c82c114fa", "patch": "@@ -324,7 +324,7 @@ impl Type {\n             TypeKind::Float => 32,\n             TypeKind::Double => 64,\n             TypeKind::X86_FP80 => 80,\n-            TypeKind::FP128 | TypeKind::PPC_FP128 => 128,\n+            TypeKind::FP128 | TypeKind::PPc_FP128 => 128,\n             _ => bug!(\"llvm_float_width called on a non-float type\")\n         }\n     }"}]}