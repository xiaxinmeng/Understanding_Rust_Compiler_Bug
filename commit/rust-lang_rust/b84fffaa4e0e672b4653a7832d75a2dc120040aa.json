{"sha": "b84fffaa4e0e672b4653a7832d75a2dc120040aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NGZmZmFhNGUwZTY3MmI0NjUzYTc4MzJkNzVhMmRjMTIwMDQwYWE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-16T23:55:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-06-16T23:55:46Z"}, "message": "Reformat a bunch of recent churn.", "tree": {"sha": "ad8e6854d11f6627b7afc9b8d14f525580beff55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad8e6854d11f6627b7afc9b8d14f525580beff55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b84fffaa4e0e672b4653a7832d75a2dc120040aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b84fffaa4e0e672b4653a7832d75a2dc120040aa", "html_url": "https://github.com/rust-lang/rust/commit/b84fffaa4e0e672b4653a7832d75a2dc120040aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b84fffaa4e0e672b4653a7832d75a2dc120040aa/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb9969f54699924e4373f6c447aaeb4dd041b0dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb9969f54699924e4373f6c447aaeb4dd041b0dd", "html_url": "https://github.com/rust-lang/rust/commit/eb9969f54699924e4373f6c447aaeb4dd041b0dd"}], "stats": {"total": 945, "additions": 473, "deletions": 472}, "files": [{"sha": "31eb4c72fcc9766a5d73326f6c053fbcf35fac6b", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -90,9 +90,10 @@ const int obj_body_elt_fields = 2;\n \n const int obj_body_elt_with_obj = 3;\n \n- /* The base object to which an anonymous\n-  * object is attached */\n- const int fn_field_code = 0;\n+\n+/* The base object to which an anonymous\n+ * object is attached */\n+const int fn_field_code = 0;\n \n const int fn_field_box = 1;\n "}, {"sha": "7bb3f0c7fa62a5af9dee9c0baa0f43ace188f75d", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -175,6 +175,7 @@ mod write {\n             } else {\n                 // If we aren't saving temps then just output the file\n                 // type corresponding to the '-c' or '-S' flag used\n+\n                 auto triple = x86::get_target_triple();\n                 llvm::LLVMRustWriteOutputFile(pm.llpm, llmod,\n                                               str::buf(triple),"}, {"sha": "6a0872734ff067a4a8057c278989df362f0aabe9", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -16,11 +16,9 @@ fn get_meta_sect_name() -> str {\n \n fn get_data_layout() -> str {\n     if (str::eq(target_os(), \"macos\")) {\n-        ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\"\n-            + \"-i32:32:32-i64:32:64\"\n-            + \"-f32:32:32-f64:32:64-v64:64:64\"\n-            + \"-v128:128:128-a0:0:64-f80:128:128\"\n-            + \"-n8:16:32\";\n+        ret \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" + \"-i32:32:32-i64:32:64\" +\n+                \"-f32:32:32-f64:32:64-v64:64:64\" +\n+                \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\";\n     }\n     if (str::eq(target_os(), \"win32\")) {\n         ret \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\";"}, {"sha": "a9e3748e1b50e568840ce35e071e655760debc3b", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -239,7 +239,7 @@ fn build_session_options(str binary, getopts::match match) ->\n                 case (\"3\") { 3u }\n                 case (_) {\n                     log_err \"error: optimization level needs \" +\n-                        \"to be between 0-3\";\n+                                \"to be between 0-3\";\n                     fail\n                 }\n             }\n@@ -399,13 +399,11 @@ fn main(vec[str] args) {\n         let str prog = \"gcc\";\n         // The invocations of gcc share some flags across platforms\n \n-        let vec[str] common_args = [stage, \"-Lrt\", \"-lrustrt\",\n-         \"-fno-strict-aliasing\", \"-fPIC\", \"-Wall\",\n-         \"-fno-rtti\", \"-fno-exceptions\", \"-g\", glu, \"-o\",\n-         saved_out_filename, saved_out_filename + \".o\"];\n-\n-       auto shared_cmd;\n-\n+        let vec[str] common_args =\n+            [stage, \"-Lrt\", \"-lrustrt\", \"-fno-strict-aliasing\", \"-fPIC\",\n+             \"-Wall\", \"-fno-rtti\", \"-fno-exceptions\", \"-g\", glu, \"-o\",\n+             saved_out_filename, saved_out_filename + \".o\"];\n+        auto shared_cmd;\n         alt (sess.get_targ_cfg().os) {\n             case (session::os_win32) {\n                 shared_cmd = \"-shared\";\n@@ -421,12 +419,12 @@ fn main(vec[str] args) {\n             }\n         }\n         if (sopts.shared) {\n-           gcc_args += [shared_cmd];\n+            gcc_args += [shared_cmd];\n         } else {\n-           gcc_args += [\"-Lrustllvm\", \"-lrustllvm\", \"-lstd\", \"-lm\", main];\n+            gcc_args += [\"-Lrustllvm\", \"-lrustllvm\", \"-lstd\", \"-lm\", main];\n         }\n-\n         // We run 'gcc' here\n+\n         run::run_program(prog, gcc_args);\n         // Clean up on Darwin\n "}, {"sha": "303c8b2909cf7130aa98d15c717ab11a0baf64e6", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -245,13 +245,16 @@ tag expr_ {\n     expr_alt(@expr, vec[arm], ann);\n     expr_fn(_fn, ann);\n     expr_block(block, ann);\n-    expr_move(@expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_swap(@expr /* TODO: @expr|is_lval */,\n-              @expr /* TODO: @expr|is_lval */, ann);\n-    expr_assign_op(binop, @expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_send(@expr /* TODO: @expr|is_lval */, @expr, ann);\n-    expr_recv(@expr /* TODO: @expr|is_lval */, @expr, ann);\n+    /*\n+     * FIXME: many of these @exprs should be constrained with\n+     * is_lval once we have constrained types working.\n+     */\n+    expr_move(@expr, @expr, ann);\n+    expr_assign(@expr,@expr, ann);\n+    expr_swap(@expr, @expr, ann);\n+    expr_assign_op(binop, @expr, @expr, ann);\n+    expr_send(@expr, @expr, ann);\n+    expr_recv(@expr, @expr, ann);\n     expr_field(@expr, ident, ann);\n     expr_index(@expr, @expr, ann);\n     expr_path(path, ann);\n@@ -366,16 +369,14 @@ type constr_arg = constr_arg_general[uint];\n \n type constr_arg_general[T] = spanned[constr_arg_general_[T]];\n \n-type constr_ = rec(path path,\n-                   vec[@constr_arg_general[uint]] args,\n-                   ann ann);\n+type constr_ = rec(path path, vec[@constr_arg_general[uint]] args, ann ann);\n \n type constr = spanned[constr_];\n \n+\n /* The parser generates ast::constrs; resolve generates\n  a mapping from each function to a list of ty::constr_defs,\n  corresponding to these. */\n-\n type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n \n type fn_decl =\n@@ -464,12 +465,14 @@ tag attr_style { attr_outer; attr_inner; }\n \n type attribute_ = rec(attr_style style, meta_item value);\n \n-type item = rec(ident ident,\n-                vec[attribute] attrs,\n-                def_id id, // For objs, this is the type def_id\n-                ann ann,\n-                item_ node,\n-                span span);\n+type item =\n+    rec(ident ident,\n+        vec[attribute] attrs,\n+        def_id id, // For objs, this is the type def_id\n+\n+        ann ann,\n+        item_ node,\n+        span span);\n \n tag item_ {\n     item_const(@ty, @expr);\n@@ -478,7 +481,9 @@ tag item_ {\n     item_native_mod(native_mod);\n     item_ty(@ty, vec[ty_param]);\n     item_tag(vec[variant], vec[ty_param]);\n-    item_obj(_obj, vec[ty_param], def_id /* constructor id */);\n+    item_obj(_obj, vec[ty_param], def_id);\n+    /* constructor id */\n+\n }\n \n type native_item = spanned[native_item_];\n@@ -521,9 +526,9 @@ fn is_exported(ident i, _mod m) -> bool {\n             case (_) {/* fall through */ }\n         }\n     }\n-\n     // If there are no declared exports then \n     // everything not imported is exported\n+\n     ret count == 0u && !nonlocal;\n }\n "}, {"sha": "09f90befa129d0d7b4684e0c288cfb517692f09e", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -478,8 +478,7 @@ fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n \n fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n     auto b = str::buf(filename);\n-    auto mb =\n-        llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n+    auto mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n     if (mb as int == 0) { ret option::none[vec[u8]]; }\n     auto of = mk_object_file(mb);\n     auto si = mk_section_iter(of.llof);"}, {"sha": "9c1fad981aeab38eda8d495a24aa3998f22cb1b3", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -294,17 +294,19 @@ fn eval_crate_directive(ctx cx, env e, @ast::crate_directive cdir, str prefix,\n             cx.p.set_def(next_id._1);\n             cx.chpos = p0.get_chpos();\n             cx.next_ann = p0.next_ann_num();\n-            auto i = front::parser::mk_item(cx.p, cdir.span.lo, cdir.span.hi,\n-                                            id, ast::item_mod(m0), []);\n+            auto i =\n+                front::parser::mk_item(cx.p, cdir.span.lo, cdir.span.hi, id,\n+                                       ast::item_mod(m0), []);\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n             auto path = id;\n             alt (dir_opt) { case (some(?d)) { path = d; } case (none) { } }\n             auto full_path = prefix + std::fs::path_sep() + path;\n             auto m0 = eval_crate_directives_to_mod(cx, e, cdirs, full_path);\n-            auto i = front::parser::mk_item\n-                (cx.p, cdir.span.lo, cdir.span.hi, id, ast::item_mod(m0), []);\n+            auto i =\n+                front::parser::mk_item(cx.p, cdir.span.lo, cdir.span.hi, id,\n+                                       ast::item_mod(m0), []);\n             vec::push[@ast::item](items, i);\n         }\n         case (ast::cdir_view_item(?vi)) {"}, {"sha": "9ae3afad0c6e3b072d95bedc6d46ccca969fde70", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -281,7 +281,7 @@ fn scan_number(char c, &reader rdr) -> token::token {\n                 rdr.bump();\n                 ret token::LIT_MACH_FLOAT(util::common::ty_f64,\n                                           intern(*rdr.get_interner(),\n-                                                           float_str));\n+                                                 float_str));\n                 /* FIXME: if this is out of range for either a 32-bit or\n                    64-bit float, it won't be noticed till the back-end */\n "}, {"sha": "f33617ac42e13951d39b1ecb0ce8e302792bed79", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -34,12 +34,12 @@ type scope = vec[restrict];\n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n type ctx =\n-    rec(@ty::ctxt tcx,\n-        std::map::hashmap[def_num, local_info] local_map);\n+    rec(@ty::ctxt tcx, std::map::hashmap[def_num, local_info] local_map);\n \n fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n     auto cx =\n         @rec(tcx=tcx,\n+\n              // Stores information about object fields and function\n              // arguments that's otherwise not easily available.\n              local_map=util::common::new_int_hash());\n@@ -93,8 +93,8 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                     auto root = expr_root(*cx, ex, false);\n                     if (mut_field(root.ds)) {\n                         cx.tcx.sess.span_err(ex.span,\n-                                             \"result of put must be\"\n-                                             + \" immutably rooted\");\n+                                             \"result of put must be\" +\n+                                                 \" immutably rooted\");\n                     }\n                     visit_expr(cx, ex, sc, v);\n                 }\n@@ -129,7 +129,6 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n    rec(vec[def_num] root_vars, vec[ty::t] unsafe_ts) {\n     auto fty = ty::expr_ty(*cx.tcx, f);\n     auto arg_ts = fty_args(cx, fty);\n-\n     let vec[def_num] roots = [];\n     let vec[tup(uint, def_num)] mut_roots = [];\n     let vec[ty::t] unsafe_ts = [];\n@@ -146,7 +145,8 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n                     }\n                     case (_) {\n                         if (!mut_field(root.ds)) {\n-                            auto m = \"passing a temporary value or \\\n+                            auto m =\n+                                \"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n                             cx.tcx.sess.span_err(arg.span, m);\n                         }\n@@ -171,10 +171,10 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n                 if (def_is_local(cx.tcx.def_map.get(ann.id), true)) {\n-                    cx.tcx.sess.span_err\n-                        (f.span, #fmt(\"function may alias with argument \\\n-                         %u, which is not immutably rooted\",\n-                         unsafe_t_offsets.(0)));\n+                    cx.tcx.sess.span_err(f.span,\n+                                         #fmt(\"function may alias with \\\n+                         argument %u, which is not immutably rooted\",\n+                                              unsafe_t_offsets.(0)));\n                 }\n             }\n             case (_) { }\n@@ -218,9 +218,10 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n \n fn check_tail_call(&ctx cx, &@ast::expr call) {\n     auto args;\n-    auto f = alt (call.node) {\n-        case (ast::expr_call(?f, ?args_, _)) { args = args_; f }\n-    };\n+    auto f =\n+        alt (call.node) {\n+            case (ast::expr_call(?f, ?args_, _)) { args = args_; f }\n+        };\n     auto i = 0u;\n     for (ty::arg arg_t in fty_args(cx, ty::expr_ty(*cx.tcx, f))) {\n         if (arg_t.mode != ty::mo_val) {\n@@ -233,30 +234,28 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n                     alt (cx.local_map.find(dnum)) {\n                         case (some(arg(ast::alias(?mut)))) {\n                             if (mut_a && !mut) {\n-                                cx.tcx.sess.span_warn\n-                                    (args.(i).span, \"passing an immutable \\\n+                                cx.tcx.sess.span_warn(args.(i).span,\n+                                                      \"passing an immutable \\\n                                      alias by mutable alias\");\n                             }\n                         }\n-                        case (_) {\n-                            ok = !def_is_local(def, false);\n-                        }\n+                        case (_) { ok = !def_is_local(def, false); }\n                     }\n                 }\n                 case (_) { ok = false; }\n             }\n             if (!ok) {\n-                cx.tcx.sess.span_warn\n-                    (args.(i).span, \"can not pass a local value by alias to \\\n-                                     a tail call\");\n+                cx.tcx.sess.span_warn(args.(i).span,\n+                                      \"can not pass a local value by \\\n+                                     alias to a tail call\");\n             }\n         }\n         i += 1u;\n     }\n }\n \n-fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms,\n-             &scope sc, &vt[scope] v) {\n+fn check_alt(&ctx cx, &@ast::expr input, &vec[ast::arm] arms, &scope sc,\n+             &vt[scope] v) {\n     visit::visit_expr(input, sc, v);\n     auto root = expr_root(cx, input, true);\n     auto roots =\n@@ -630,21 +629,20 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n \n fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n     ret alt (d) {\n-        case (ast::def_local(_)) { true }\n-        case (ast::def_arg(_)) { true }\n-        case (ast::def_obj_field(_)) { objfields_count }\n-        case (ast::def_binding(_)) { true }\n-        case (_) { false }\n-    };\n+            case (ast::def_local(_)) { true }\n+            case (ast::def_arg(_)) { true }\n+            case (ast::def_obj_field(_)) { objfields_count }\n+            case (ast::def_binding(_)) { true }\n+            case (_) { false }\n+        };\n }\n \n fn fty_args(&ctx cx, ty::t fty) -> vec[ty::arg] {\n     ret alt (ty::struct(*cx.tcx, fty)) {\n-        case (ty::ty_fn(_, ?args, _, _, _)) { args }\n-        case (ty::ty_native_fn(_, ?args, _)) { args }\n-    };\n+            case (ty::ty_fn(_, ?args, _, _, _)) { args }\n+            case (ty::ty_native_fn(_, ?args, _)) { args }\n+        };\n }\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "25973458e5c1d176044e4b5328c80fcfd5105e72", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -557,8 +557,8 @@ fn encode_info_for_item(@trans::crate_ctxt cx, &ebml::writer ebml_w,\n                 encode_variant_id(ebml_w, v.node.id);\n             }\n             ebml::end_tag(ebml_w);\n-            encode_tag_variant_info(cx, ebml_w, item.id, variants,\n-                                    index, tps);\n+            encode_tag_variant_info(cx, ebml_w, item.id, variants, index,\n+                                    tps);\n         }\n         case (ast::item_obj(_, ?tps, ?ctor_id)) {\n             ebml::start_tag(ebml_w, tag_items_data_item);"}, {"sha": "ff0db43357b044c1455c714704077ddb8378bb1f", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 34, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -120,18 +120,19 @@ type env =\n         ext_hash ext_cache,\n         session sess);\n \n+\n // Used to distinguish between lookups from outside and from inside modules,\n // since export restrictions should only be applied for the former.\n tag dir { inside; outside; }\n \n tag namespace { ns_value; ns_type; ns_module; }\n \n-fn resolve_crate(session sess, @ast::crate crate)\n-    -> tup(def_map, constr_table) {\n+fn resolve_crate(session sess, @ast::crate crate) ->\n+   tup(def_map, constr_table) {\n     auto e =\n         @rec(crate_map=new_uint_hash[ast::crate_num](),\n              def_map=new_uint_hash[def](),\n-             fn_constrs = new_def_hash[vec[ty::constr_def]](),\n+             fn_constrs=new_def_hash[vec[ty::constr_def]](),\n              ast_map=new_def_hash[@ast::item](),\n              imports=new_int_hash[import_state](),\n              mod_map=new_int_hash[@indexed_mod](),\n@@ -198,9 +199,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n                 e.ast_map.insert(i.id, i);\n                 e.ast_map.insert(ctor_id, i);\n             }\n-            case (_) {\n-                e.ast_map.insert(i.id, i);\n-            }\n+            case (_) { e.ast_map.insert(i.id, i); }\n         }\n     }\n     // Next, assemble the links for globbed imports.\n@@ -260,9 +259,8 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_arm=bind walk_arm(e, _, _, _),\n              visit_expr=bind walk_expr(e, _, _, _),\n              visit_ty=bind walk_ty(e, _, _, _),\n-             visit_constr = bind walk_constr(e, _, _, _),\n-             visit_fn=bind visit_fn_with_scope\n-                        (e, _, _, _, _, _, _, _, _)\n+             visit_constr=bind walk_constr(e, _, _, _),\n+             visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n@@ -277,7 +275,6 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n-\n     fn walk_ty(@env e, &@ast::ty t, &scopes sc, &vt[scopes] v) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n@@ -290,13 +287,12 @@ fn resolve_names(&@env e, &@ast::crate c) {\n             case (_) { }\n         }\n     }\n-\n     fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        auto new_def = lookup_path_strict(*e, sc, c.span,\n-                                          c.node.path.node.idents, ns_value);\n+        auto new_def =\n+            lookup_path_strict(*e, sc, c.span, c.node.path.node.idents,\n+                               ns_value);\n         e.def_map.insert(c.node.ann.id, new_def);\n     }\n-\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         walk_pat(*e, sc, a.pat);\n         visit_arm_with_scope(a, sc, v);\n@@ -340,11 +336,12 @@ fn visit_fn_with_scope(&@env e, &ast::_fn f, &vec[ast::ty_param] tp, &span sp,\n                        &vt[scopes] v) {\n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n+\n     for (@ast::constr c in f.decl.constraints) {\n-        resolve_constr(e, d_id, c, sc, v); \n+        resolve_constr(e, d_id, c, sc, v);\n     }\n-    visit::visit_fn(f, tp, sp, name, d_id, a,\n-                    cons(scope_fn(f.decl, tp), @sc), v);\n+    visit::visit_fn(f, tp, sp, name, d_id, a, cons(scope_fn(f.decl, tp), @sc),\n+                    v);\n }\n \n fn visit_block_with_scope(&ast::block b, &scopes sc, &vt[scopes] v) {\n@@ -393,36 +390,32 @@ fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n \n fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n                   &vt[scopes] v) {\n-    let def new_def = lookup_path_strict(*e, sc, c.span,\n-                                         c.node.path.node.idents,\n-                                         ns_value);\n+    let def new_def =\n+        lookup_path_strict(*e, sc, c.span, c.node.path.node.idents, ns_value);\n     alt (new_def) {\n         case (ast::def_fn(?pred_id)) {\n-            let ty::constr_general[uint] c_ = rec(path=c.node.path,\n-                                                  args=c.node.args,\n-                                                  id=pred_id);\n+            let ty::constr_general[uint] c_ =\n+                rec(path=c.node.path, args=c.node.args, id=pred_id);\n             let ty::constr_def new_constr = respan(c.span, c_);\n             add_constr(e, d_id, new_constr);\n         }\n         case (_) {\n-            e.sess.span_err(c.span, \"Non-predicate in constraint: \"\n-                            + ty::path_to_str(c.node.path));\n+            e.sess.span_err(c.span,\n+                            \"Non-predicate in constraint: \" +\n+                                ty::path_to_str(c.node.path));\n         }\n     }\n }\n \n fn add_constr(&@env e, &def_id d_id, &ty::constr_def c) {\n     e.fn_constrs.insert(d_id,\n-       alt (e.fn_constrs.find(d_id)) {\n-          case (none) {\n-              [c]\n-          }\n-          case (some(?cs)) {\n-              cs + [c]\n-          }\n-       });\n+                        alt (e.fn_constrs.find(d_id)) {\n+                            case (none) { [c] }\n+                            case (some(?cs)) { cs + [c] }\n+                        });\n }\n \n+\n // Import resolution\n fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n     auto defid;\n@@ -701,7 +694,7 @@ fn lookup_in_block(&ident id, &ast::block_ b, namespace ns) ->\n                                 } else if (ns == ns_value) {\n                                     for (ast::variant v in variants) {\n                                         if (str::eq(v.node.name, id)) {\n-                                            auto i =  v.node.id;\n+                                            auto i = v.node.id;\n                                             ret some(ast::def_variant(it.id,\n                                                                       i));\n                                         }"}, {"sha": "f3e42e1e29442121e0d4249ab4c522d2261dad0c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 251, "deletions": 228, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -113,6 +113,7 @@ type stats =\n         mutable uint n_null_glues,\n         mutable uint n_real_glues);\n \n+\n // Crate context.  Every crate we compile has one of these.\n type crate_ctxt =\n     rec(session::session sess,\n@@ -437,9 +438,10 @@ fn T_task(&type_names tn) -> TypeRef {\n                    T_int(), // Runtime SP\n                    T_int(), // Rust SP\n                    T_int(), // GC chain\n-                   T_int(), // Domain pointer\n-                    // Crate cache pointer\n-                  T_int()]);\n+\n+                  T_int(), // Domain pointer\n+                           // Crate cache pointer\n+                            T_int()]);\n     tn.associate(s, t);\n     ret t;\n }\n@@ -514,9 +516,10 @@ fn T_vec(TypeRef t) -> TypeRef {\n     ret T_struct([T_int(), // Refcount\n                    T_int(), // Alloc\n                    T_int(), // Fill\n-                   T_int(), // Pad\n-                    // Body elements\n-                  T_array(t, 0u)]);\n+\n+                  T_int(), // Pad\n+                           // Body elements\n+                            T_array(t, 0u)]);\n }\n \n fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_vec(T_int())); }\n@@ -1627,6 +1630,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n     if (escapes) {\n         auto tydescs =\n             alloca(bcx, /* for root*/\n+\n                    T_array(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)),\n                            1u + n_params));\n         auto i = 0;\n@@ -2168,21 +2172,22 @@ fn make_cmp_glue(&@block_ctxt cx, ValueRef lhs0, ValueRef rhs0, &ty::t t,\n             auto rhs_fill;\n             auto bcx;\n             if (ty::sequence_is_interior(cx.fcx.lcx.ccx.tcx, t)) {\n-                auto lad = ivec::get_len_and_data(scx, lhs,\n-                        ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t));\n+                auto st = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n+                auto lad =\n+                    ivec::get_len_and_data(scx, lhs, st);\n                 bcx = lad._2;\n                 lhs_fill = lad._0;\n-                lad = ivec::get_len_and_data(bcx, rhs,\n-                        ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t));\n+                lad =\n+                    ivec::get_len_and_data(bcx, rhs, st);\n                 bcx = lad._2;\n                 rhs_fill = lad._0;\n             } else {\n                 lhs_fill = vec_fill(scx, lhs);\n                 rhs_fill = vec_fill(scx, rhs);\n                 bcx = scx;\n             }\n-\n-            r = compare_numerical_values(bcx, lhs_fill, rhs_fill,\n+            r =\n+                compare_numerical_values(bcx, lhs_fill, rhs_fill,\n                                          unsigned_int, llop);\n             r.bcx.build.Store(r.val, flag);\n         } else {\n@@ -2435,7 +2440,7 @@ fn get_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n     auto heap_len =\n         {\n             auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-            auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr,v);\n+            auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr, v);\n             nonzero_len_cx.build.Load(m)\n         };\n     auto heap_elem =\n@@ -2502,12 +2507,10 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n         auto rslt = size_of(bcx, unit_ty);\n         auto unit_sz = rslt.val;\n         bcx = rslt.bcx;\n-\n         auto a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n         auto a_len = a_len_and_data._0;\n         auto a_elem = a_len_and_data._1;\n         bcx = a_len_and_data._2;\n-\n         auto b_len_and_data = ivec::get_len_and_data(bcx, bv, unit_ty);\n         auto b_len = b_len_and_data._0;\n         auto b_elem = b_len_and_data._1;\n@@ -2608,8 +2611,8 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                                 variant_cx = rslt.bcx;\n                                 auto tcx = cx.fcx.lcx.ccx.tcx;\n                                 auto ty_subst =\n-                                    ty::substitute_type_params(tcx,\n-                                                               tps, a.ty);\n+                                    ty::substitute_type_params(tcx, tps,\n+                                                               a.ty);\n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx, llfldp_a,\n                                                       ty_subst);\n@@ -2664,11 +2667,14 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n \n // Iterates through a pointer range, until the src* hits the src_lim*.\n fn iter_sequence_raw(@block_ctxt cx, ValueRef dst,\n-                      // elt*\n+\n+                         // elt*\n                          ValueRef src,\n-                      // elt*\n+\n+                         // elt*\n                          ValueRef src_lim,\n-                      // elt*\n+\n+                         // elt*\n                          ValueRef elt_sz, &val_pair_fn f) -> result {\n     auto bcx = cx;\n     let ValueRef dst_int = vp2i(bcx, dst);\n@@ -2696,7 +2702,8 @@ fn iter_sequence_raw(@block_ctxt cx, ValueRef dst,\n }\n \n fn iter_sequence_inner(&@block_ctxt cx, ValueRef src,\n-                        // elt*\n+\n+                           // elt*\n                            ValueRef src_lim,\n                        & // elt*\n                            ty::t elt_ty, &val_and_ty_fn f) -> result {\n@@ -3043,7 +3050,7 @@ fn move_val(@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n             ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, cx.build.Store(src, dst));\n     } else if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t) ||\n-                    ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n+                   ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n         ret res(cx, C_nil());\n     } else if (ty::type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n         if (action == DROP_EXISTING) {\n@@ -3231,31 +3238,37 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n                             llelt_tydesc.val, dst, src, skip_null]));\n }\n \n-\n mod ivec {\n+\n     // Returns the length of an interior vector and a pointer to its first\n     // element, in that order.\n     fn get_len_and_data(&@block_ctxt bcx, ValueRef v, ty::t unit_ty) ->\n-            tup(ValueRef, ValueRef, @block_ctxt) {\n+       tup(ValueRef, ValueRef, @block_ctxt) {\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n         auto stack_len =\n-            bcx.build.Load(bcx.build.InBoundsGEP(v,\n-                [C_int(0), C_uint(abi::ivec_elt_len)]));\n+            {\n+                auto p = bcx.build.InBoundsGEP(v,\n+                                               [C_int(0),\n+                                                C_uint(abi::ivec_elt_len)]);\n+                bcx.build.Load(p)\n+            };\n         auto stack_elem =\n             bcx.build.InBoundsGEP(v,\n-                [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n-        auto on_heap = bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len,\n-                                      C_int(0));\n+                                  [C_int(0), C_uint(abi::ivec_elt_elems),\n+                                   C_int(0)]);\n+        auto on_heap =\n+            bcx.build.ICmp(lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n         auto on_heap_cx = new_sub_block_ctxt(bcx, \"on_heap\");\n         auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n         bcx.build.CondBr(on_heap, on_heap_cx.llbb, next_cx.llbb);\n         auto heap_stub =\n             on_heap_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n-        auto heap_ptr = {\n-            auto v = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-            on_heap_cx.build.Load(on_heap_cx.build.InBoundsGEP(heap_stub, v))\n-        };\n-\n+        auto heap_ptr =\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+                on_heap_cx.build.Load(on_heap_cx.build.InBoundsGEP(heap_stub,\n+                                                                   v))\n+            };\n         // Check whether the heap pointer is null. If it is, the vector length\n         // is truly zero.\n \n@@ -3276,27 +3289,31 @@ mod ivec {\n         zero_len_cx.build.Br(next_cx.llbb);\n         // If we're here, then we actually have a heapified vector.\n \n-        auto heap_len = {\n-            auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-            auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr, v);\n-            nonzero_len_cx.build.Load(m)\n-        };\n+        auto heap_len =\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n+                auto m = nonzero_len_cx.build.InBoundsGEP(heap_ptr, v);\n+                nonzero_len_cx.build.Load(m)\n+            };\n         auto heap_elem =\n-            nonzero_len_cx.build.InBoundsGEP(heap_ptr,\n-                [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n+                          C_int(0)];\n+                nonzero_len_cx.build.InBoundsGEP(heap_ptr,v)\n+            };\n         nonzero_len_cx.build.Br(next_cx.llbb);\n-\n         // Now we can figure out the length of `v` and get a pointer to its\n         // first element.\n \n         auto len =\n-            next_cx.build.Phi(T_int(),\n-                [stack_len, zero_len, heap_len],\n-                [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+            next_cx.build.Phi(T_int(), [stack_len, zero_len, heap_len],\n+                              [bcx.llbb, zero_len_cx.llbb,\n+                               nonzero_len_cx.llbb]);\n         auto elem =\n             next_cx.build.Phi(T_ptr(llunitty),\n-                [stack_elem, zero_elem, heap_elem],\n-                [bcx.llbb, zero_len_cx.llbb, nonzero_len_cx.llbb]);\n+                              [stack_elem, zero_elem, heap_elem],\n+                              [bcx.llbb, zero_len_cx.llbb,\n+                               nonzero_len_cx.llbb]);\n         ret tup(len, elem, next_cx);\n     }\n \n@@ -3327,9 +3344,9 @@ mod ivec {\n         // We're possibly on the heap, unless the vector is zero-length.\n \n         auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-\n-        auto stub_ptr = maybe_on_heap_cx.build.PointerCast(v,\n-            T_ptr(T_ivec_heap(llunitty)));\n+        auto stub_ptr =\n+            maybe_on_heap_cx.build.PointerCast(v,\n+                                               T_ptr(T_ivec_heap(llunitty)));\n         auto heap_ptr =\n             {\n                 auto m = maybe_on_heap_cx.build.InBoundsGEP(stub_ptr, stub_p);\n@@ -3341,8 +3358,8 @@ mod ivec {\n         auto on_heap_cx = new_sub_block_ctxt(cx, \"on_heap\");\n         maybe_on_heap_cx.build.CondBr(on_heap, on_heap_cx.llbb,\n                                       on_stack_cx.llbb);\n-\n         // We're definitely on the heap. Check whether we need to resize.\n+\n         auto heap_len_ptr =\n             on_heap_cx.build.InBoundsGEP(heap_ptr,\n                                          [C_int(0),\n@@ -3360,35 +3377,36 @@ mod ivec {\n         // Case (1): We're on the heap and don't need to resize.\n \n         auto heap_data_no_resize =\n-            heap_no_resize_cx.build.InBoundsGEP(heap_ptr,\n-                [C_int(0),\n-                 C_uint(abi::ivec_heap_elt_elems),\n-                 heap_len_unscaled]);\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n+                          heap_len_unscaled];\n+                heap_no_resize_cx.build.InBoundsGEP(heap_ptr,v)\n+            };\n         heap_no_resize_cx.build.Store(new_heap_len, heap_len_ptr);\n         heap_no_resize_cx.build.Br(next_cx.llbb);\n-\n         // Case (2): We're on the heap and need to resize. This path is rare,\n         // so we delegate to cold glue.\n \n         {\n-            auto p = heap_resize_cx.build.PointerCast(v,\n-                                                      T_ptr(T_opaque_ivec()));\n+            auto p =\n+                heap_resize_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n             heap_resize_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_resize,\n                                       [cx.fcx.lltaskptr, p, new_heap_len]);\n         }\n-\n-        auto heap_ptr_resize = {\n-            auto m = heap_resize_cx.build.InBoundsGEP(stub_ptr, stub_p);\n-            heap_resize_cx.build.Load(m)\n-        };\n+        auto heap_ptr_resize =\n+            {\n+                auto m = heap_resize_cx.build.InBoundsGEP(stub_ptr, stub_p);\n+                heap_resize_cx.build.Load(m)\n+            };\n         auto heap_data_resize =\n-            heap_resize_cx.build.InBoundsGEP(heap_ptr_resize,\n-                [C_int(0),\n-                 C_uint(abi::ivec_heap_elt_elems),\n-                 heap_len_unscaled]);\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n+                          heap_len_unscaled];\n+                heap_resize_cx.build.InBoundsGEP(heap_ptr_resize, v)\n+            };\n         heap_resize_cx.build.Br(next_cx.llbb);\n-\n         // We're on the stack. Check whether we need to spill to the heap.\n+\n         auto new_stack_len = on_stack_cx.build.Add(stack_len, len_needed);\n         auto stack_no_spill_needed =\n             on_stack_cx.build.ICmp(lib::llvm::LLVMIntULE, new_stack_len,\n@@ -3398,43 +3416,46 @@ mod ivec {\n         auto stack_no_spill_cx = new_sub_block_ctxt(cx, \"stack_no_spill\");\n         auto stack_spill_cx = new_sub_block_ctxt(cx, \"stack_spill\");\n         on_stack_cx.build.CondBr(stack_no_spill_needed,\n-                                 stack_no_spill_cx.llbb,\n-                                 stack_spill_cx.llbb);\n-\n+                                 stack_no_spill_cx.llbb, stack_spill_cx.llbb);\n         // Case (3): We're on the stack and don't need to spill.\n+\n         auto stack_data_no_spill =\n             stack_no_spill_cx.build.InBoundsGEP(v,\n                                                 [C_int(0),\n                                                  C_uint(abi::ivec_elt_elems),\n                                                  stack_len_unscaled]);\n         stack_no_spill_cx.build.Store(new_stack_len, stack_len_ptr);\n         stack_no_spill_cx.build.Br(next_cx.llbb);\n-\n         // Case (4): We're on the stack and need to spill. Like case (2), this\n         // path is rare, so we delegate to cold glue.\n+\n         {\n-            auto p = stack_spill_cx.build.PointerCast(v,\n-                T_ptr(T_opaque_ivec()));\n+            auto p =\n+                stack_spill_cx.build.PointerCast(v, T_ptr(T_opaque_ivec()));\n             stack_spill_cx.build.Call(cx.fcx.lcx.ccx.upcalls.ivec_spill,\n                                       [cx.fcx.lltaskptr, p, new_stack_len]);\n         }\n-\n         auto spill_stub =\n             stack_spill_cx.build.PointerCast(v, T_ptr(T_ivec_heap(llunitty)));\n         auto heap_ptr_spill =\n-            stack_spill_cx.build.Load(\n-                stack_spill_cx.build.InBoundsGEP(spill_stub, stub_p));\n+            {\n+                auto p = stack_spill_cx.build.InBoundsGEP(spill_stub, stub_p);\n+                stack_spill_cx.build.Load(p)\n+            };\n         auto heap_len_ptr_spill =\n-            stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n-                [C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n+                stack_spill_cx.build.InBoundsGEP(heap_ptr_spill, v)\n+            };\n         auto heap_data_spill =\n-            stack_spill_cx.build.InBoundsGEP(heap_ptr_spill,\n-                [C_int(0),\n-                 C_uint(abi::ivec_heap_elt_elems),\n-                 stack_len_unscaled]);\n+            {\n+                auto v = [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n+                          stack_len_unscaled];\n+                stack_spill_cx.build.InBoundsGEP(heap_ptr_spill, v)\n+            };\n         stack_spill_cx.build.Br(next_cx.llbb);\n-\n         // Phi together the different data pointers to get the result.\n+\n         auto data_ptr =\n             next_cx.build.Phi(T_ptr(llunitty),\n                               [heap_data_no_resize, heap_data_resize,\n@@ -3443,7 +3464,6 @@ mod ivec {\n                                stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n         ret res(next_cx, data_ptr);\n     }\n-\n     fn trans_append(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n        result {\n         auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n@@ -3468,45 +3488,41 @@ mod ivec {\n         rslt = get_tydesc(bcx, unit_ty, false, no_tydesc_info);\n         auto unit_tydesc = rslt.val;\n         bcx = rslt.bcx;\n-\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n-\n         auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n         auto rhs_len = rhs_len_and_data._0;\n         auto rhs_data = rhs_len_and_data._1;\n-\n         bcx = rhs_len_and_data._2;\n         rslt = reserve_space(bcx, llunitty, lhs, rhs_len);\n         auto lhs_data = rslt.val;\n         bcx = rslt.bcx;\n-\n         // Work out the end pointer.\n+\n         auto lhs_unscaled_idx = bcx.build.UDiv(rhs_len, llsize_of(llunitty));\n         auto lhs_end = bcx.build.InBoundsGEP(lhs_data, [lhs_unscaled_idx]);\n-\n         // Now emit the copy loop.\n+\n         auto dest_ptr = alloca(bcx, T_ptr(llunitty));\n         bcx.build.Store(lhs_data, dest_ptr);\n         auto src_ptr = alloca(bcx, T_ptr(llunitty));\n         bcx.build.Store(rhs_data, src_ptr);\n-        auto copy_loop_header_cx = new_sub_block_ctxt(bcx,\n-                                                      \"copy_loop_header\");\n+        auto copy_loop_header_cx =\n+            new_sub_block_ctxt(bcx, \"copy_loop_header\");\n         bcx.build.Br(copy_loop_header_cx.llbb);\n         auto copy_dest_ptr = copy_loop_header_cx.build.Load(dest_ptr);\n         auto not_yet_at_end =\n             copy_loop_header_cx.build.ICmp(lib::llvm::LLVMIntNE,\n-                                           copy_dest_ptr,\n-                                           lhs_end);\n+                                           copy_dest_ptr, lhs_end);\n         auto copy_loop_body_cx = new_sub_block_ctxt(bcx, \"copy_loop_body\");\n         auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n         copy_loop_header_cx.build.CondBr(not_yet_at_end,\n                                          copy_loop_body_cx.llbb,\n                                          next_cx.llbb);\n         auto copy_src_ptr = copy_loop_body_cx.build.Load(src_ptr);\n-        rslt = copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr,\n-                        t);\n+        rslt =\n+            copy_val(copy_loop_body_cx, INIT, copy_dest_ptr, copy_src_ptr, t);\n         auto post_copy_cx = rslt.bcx;\n         // Increment both pointers.\n \n@@ -3519,175 +3535,192 @@ mod ivec {\n         post_copy_cx.build.Br(copy_loop_header_cx.llbb);\n         ret res(next_cx, C_nil());\n     }\n-\n     fn alloc(&@block_ctxt bcx, ty::t unit_ty, ValueRef llalen) -> ValueRef {\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n         if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n-            auto llarraysz = bcx.build.Add(llsize_of(T_opaque_ivec()),\n-                                           llalen);\n+            auto llarraysz =\n+                bcx.build.Add(llsize_of(T_opaque_ivec()), llalen);\n             auto llvecptr = array_alloca(bcx, T_i8(), llarraysz);\n             ret bcx.build.PointerCast(llvecptr, T_ptr(T_opaque_ivec()));\n         }\n-\n         ret alloca(bcx, T_ivec(llunitty));\n     }\n-\n-    fn trans_add(&@block_ctxt cx, ty::t vec_ty, ValueRef lhs, ValueRef rhs)\n-            -> result {\n+    fn trans_add(&@block_ctxt cx, ty::t vec_ty, ValueRef lhs, ValueRef rhs) ->\n+       result {\n         auto bcx = cx;\n-\n         auto unit_ty = ty::sequence_element_type(bcx.fcx.lcx.ccx.tcx, vec_ty);\n-\n         auto rslt = size_of(bcx, unit_ty);\n         auto unit_sz = rslt.val;\n-\n-        auto llalen = bcx.build.Mul(unit_sz,\n-                                    C_uint(abi::ivec_default_length));\n+        auto llalen =\n+            bcx.build.Mul(unit_sz, C_uint(abi::ivec_default_length));\n         auto llvecptr = alloc(bcx, unit_ty, llalen);\n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n         auto llheappartty = T_ivec_heap_part(llunitty);\n-\n         auto lhs_len_and_data = get_len_and_data(bcx, lhs, unit_ty);\n         auto lhs_len = lhs_len_and_data._0;\n         auto lhs_data = lhs_len_and_data._1;\n         bcx = lhs_len_and_data._2;\n-\n         auto rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n         auto rhs_len = rhs_len_and_data._0;\n         auto rhs_data = rhs_len_and_data._1;\n         bcx = rhs_len_and_data._2;\n-\n         auto lllen = bcx.build.Add(lhs_len, rhs_len);\n-\n         // We have three cases to handle here:\n         // (1) Length is zero ([] + []).\n         // (2) Copy onto stack.\n         // (3) Allocate on heap and copy there.\n \n-        auto len_is_zero = bcx.build.ICmp(lib::llvm::LLVMIntEQ, lllen,\n-                                          C_int(0));\n+        auto len_is_zero =\n+            bcx.build.ICmp(lib::llvm::LLVMIntEQ, lllen, C_int(0));\n         auto zero_len_cx = new_sub_block_ctxt(bcx, \"zero_len\");\n         auto nonzero_len_cx = new_sub_block_ctxt(bcx, \"nonzero_len\");\n         bcx.build.CondBr(len_is_zero, zero_len_cx.llbb, nonzero_len_cx.llbb);\n-\n         // Case (1): Length is zero.\n-        auto stub_ptr_zero = zero_len_cx.build.PointerCast(llvecptr,\n-            T_ptr(T_ivec_heap(llunitty)));\n-        zero_len_cx.build.Store(C_int(0), zero_len_cx.build.InBoundsGEP(\n-            stub_ptr_zero, [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)]));\n-        zero_len_cx.build.Store(llalen, zero_len_cx.build.InBoundsGEP(\n-            stub_ptr_zero, [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n+\n+        auto stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n+        auto stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n+        auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n+\n+        auto vec_l = [C_int(0), C_uint(abi::ivec_elt_len)];\n+        auto vec_a = [C_int(0), C_uint(abi::ivec_elt_alen)];\n+\n+        auto stub_ptr_zero =\n+            zero_len_cx.build.PointerCast(llvecptr,\n+                                          T_ptr(T_ivec_heap(llunitty)));\n+        zero_len_cx.build.Store(C_int(0),\n+                                zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+                                                              stub_z));\n+        zero_len_cx.build.Store(llalen,\n+                                zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+                                                              stub_a));\n         zero_len_cx.build.Store(C_null(T_ptr(llheappartty)),\n-            zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n-                [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n+                                zero_len_cx.build.InBoundsGEP(stub_ptr_zero,\n+                                                              stub_p));\n         auto next_cx = new_sub_block_ctxt(bcx, \"next\");\n         zero_len_cx.build.Br(next_cx.llbb);\n-\n         // Determine whether we need to spill to the heap.\n-        auto on_stack = nonzero_len_cx.build.ICmp(lib::llvm::LLVMIntULE,\n-                                                  lllen, llalen);\n+\n+        auto on_stack =\n+            nonzero_len_cx.build.ICmp(lib::llvm::LLVMIntULE, lllen, llalen);\n         auto stack_cx = new_sub_block_ctxt(bcx, \"stack\");\n         auto heap_cx = new_sub_block_ctxt(bcx, \"heap\");\n         nonzero_len_cx.build.CondBr(on_stack, stack_cx.llbb, heap_cx.llbb);\n-\n         // Case (2): Copy onto stack.\n-        stack_cx.build.Store(lllen, stack_cx.build.InBoundsGEP(llvecptr,\n-            [C_int(0), C_uint(abi::ivec_elt_len)]));\n-        stack_cx.build.Store(llalen, stack_cx.build.InBoundsGEP(llvecptr,\n-            [C_int(0), C_uint(abi::ivec_elt_alen)]));\n-        auto dest_ptr_stack = stack_cx.build.InBoundsGEP(llvecptr,\n-            [C_int(0), C_uint(abi::ivec_elt_elems), C_int(0)]);\n+\n+        stack_cx.build.Store(lllen,\n+                             stack_cx.build.InBoundsGEP(llvecptr, vec_l));\n+        stack_cx.build.Store(llalen,\n+                             stack_cx.build.InBoundsGEP(llvecptr, vec_a));\n+        auto dest_ptr_stack =\n+            stack_cx.build.InBoundsGEP(llvecptr,\n+                                       [C_int(0), C_uint(abi::ivec_elt_elems),\n+                                        C_int(0)]);\n         auto copy_cx = new_sub_block_ctxt(bcx, \"copy\");\n         stack_cx.build.Br(copy_cx.llbb);\n-\n         // Case (3): Allocate on heap and copy there.\n-        auto stub_ptr_heap = heap_cx.build.PointerCast(llvecptr,\n-            T_ptr(T_ivec_heap(llunitty)));\n-        heap_cx.build.Store(C_int(0), heap_cx.build.InBoundsGEP(\n-            stub_ptr_heap, [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)]));\n-        heap_cx.build.Store(lllen, heap_cx.build.InBoundsGEP(\n-            stub_ptr_heap, [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)]));\n \n+        auto stub_ptr_heap =\n+            heap_cx.build.PointerCast(llvecptr, T_ptr(T_ivec_heap(llunitty)));\n+        heap_cx.build.Store(C_int(0),\n+                            heap_cx.build.InBoundsGEP(stub_ptr_heap,\n+                                                      stub_z));\n+        heap_cx.build.Store(lllen,\n+                            heap_cx.build.InBoundsGEP(stub_ptr_heap,\n+                                                      stub_a));\n         auto heap_sz = heap_cx.build.Add(llsize_of(llheappartty), lllen);\n-\n         rslt = trans_raw_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n         auto heap_part = rslt.val;\n         heap_cx = rslt.bcx;\n-\n-        heap_cx.build.Store(heap_part, heap_cx.build.InBoundsGEP(\n-            stub_ptr_heap, [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]));\n-        heap_cx.build.Store(lllen, heap_cx.build.InBoundsGEP(heap_part,\n-            [C_int(0), C_uint(abi::ivec_heap_elt_len)]));\n-        auto dest_ptr_heap = heap_cx.build.InBoundsGEP(heap_part,\n-            [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)]);\n+        heap_cx.build.Store(heap_part,\n+                            heap_cx.build.InBoundsGEP(stub_ptr_heap,\n+                                                      stub_p));\n+        {\n+            auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n+            heap_cx.build.Store(lllen,\n+                                heap_cx.build.InBoundsGEP(heap_part,\n+                                                          v));\n+        }\n+        auto dest_ptr_heap =\n+            heap_cx.build.InBoundsGEP(heap_part,\n+                                      [C_int(0),\n+                                       C_uint(abi::ivec_heap_elt_elems),\n+                                       C_int(0)]);\n         heap_cx.build.Br(copy_cx.llbb);\n-\n         // Emit the copy loop.\n-        auto first_dest_ptr = copy_cx.build.Phi(T_ptr(llunitty),\n-            [dest_ptr_stack, dest_ptr_heap], [stack_cx.llbb, heap_cx.llbb]);\n \n+        auto first_dest_ptr =\n+            copy_cx.build.Phi(T_ptr(llunitty),\n+                              [dest_ptr_stack, dest_ptr_heap],\n+                              [stack_cx.llbb, heap_cx.llbb]);\n         auto lhs_len_unscaled = copy_cx.build.UDiv(lhs_len, unit_sz);\n-        auto lhs_end_ptr = copy_cx.build.InBoundsGEP(lhs_data,\n-                                                     [lhs_len_unscaled]);\n+        auto lhs_end_ptr =\n+            copy_cx.build.InBoundsGEP(lhs_data, [lhs_len_unscaled]);\n         auto rhs_len_unscaled = copy_cx.build.UDiv(rhs_len, unit_sz);\n-        auto rhs_end_ptr = copy_cx.build.InBoundsGEP(rhs_data,\n-                                                     [rhs_len_unscaled]);\n-\n+        auto rhs_end_ptr =\n+            copy_cx.build.InBoundsGEP(rhs_data, [rhs_len_unscaled]);\n         auto dest_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n         copy_cx.build.Store(first_dest_ptr, dest_ptr_ptr);\n         auto lhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n         copy_cx.build.Store(lhs_data, lhs_ptr_ptr);\n         auto rhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n         copy_cx.build.Store(rhs_data, rhs_ptr_ptr);\n-\n         auto lhs_copy_cx = new_sub_block_ctxt(bcx, \"lhs_copy\");\n         copy_cx.build.Br(lhs_copy_cx.llbb);\n-\n         // Copy in elements from the LHS.\n+\n         auto lhs_ptr = lhs_copy_cx.build.Load(lhs_ptr_ptr);\n-        auto not_at_end_lhs = lhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE,\n-                                                     lhs_ptr, lhs_end_ptr);\n+        auto not_at_end_lhs =\n+            lhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE, lhs_ptr,\n+                                   lhs_end_ptr);\n         auto lhs_do_copy_cx = new_sub_block_ctxt(bcx, \"lhs_do_copy\");\n         auto rhs_copy_cx = new_sub_block_ctxt(bcx, \"rhs_copy\");\n         lhs_copy_cx.build.CondBr(not_at_end_lhs, lhs_do_copy_cx.llbb,\n                                  rhs_copy_cx.llbb);\n-\n         auto dest_ptr_lhs_copy = lhs_do_copy_cx.build.Load(dest_ptr_ptr);\n         auto lhs_val = load_if_immediate(lhs_do_copy_cx, lhs_ptr, unit_ty);\n-        rslt = copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy, lhs_val,\n-                        unit_ty);\n+        rslt =\n+            copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy, lhs_val,\n+                     unit_ty);\n         lhs_do_copy_cx = rslt.bcx;\n-        lhs_do_copy_cx.build.Store(lhs_do_copy_cx.build.InBoundsGEP(\n-            dest_ptr_lhs_copy, [C_int(1)]), dest_ptr_ptr);\n-        lhs_do_copy_cx.build.Store(lhs_do_copy_cx.build.InBoundsGEP(\n-            lhs_ptr, [C_int(1)]), lhs_ptr_ptr);\n+        {\n+            auto d = lhs_do_copy_cx.build.InBoundsGEP(dest_ptr_lhs_copy,\n+                                                      [C_int(1)]);\n+            auto lhs = lhs_do_copy_cx.build.InBoundsGEP(lhs_ptr,\n+                                                        [C_int(1)]);\n+            lhs_do_copy_cx.build.Store(d, dest_ptr_ptr);\n+            lhs_do_copy_cx.build.Store(lhs, lhs_ptr_ptr);\n+        }\n         lhs_do_copy_cx.build.Br(lhs_copy_cx.llbb);\n-\n         // Copy in elements from the RHS.\n+\n         auto rhs_ptr = rhs_copy_cx.build.Load(rhs_ptr_ptr);\n-        auto not_at_end_rhs = rhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE,\n-                                                     rhs_ptr, rhs_end_ptr);\n+        auto not_at_end_rhs =\n+            rhs_copy_cx.build.ICmp(lib::llvm::LLVMIntNE, rhs_ptr,\n+                                   rhs_end_ptr);\n         auto rhs_do_copy_cx = new_sub_block_ctxt(bcx, \"rhs_do_copy\");\n         rhs_copy_cx.build.CondBr(not_at_end_rhs, rhs_do_copy_cx.llbb,\n                                  next_cx.llbb);\n-\n         auto dest_ptr_rhs_copy = rhs_do_copy_cx.build.Load(dest_ptr_ptr);\n         auto rhs_val = load_if_immediate(rhs_do_copy_cx, rhs_ptr, unit_ty);\n-        rslt = copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy, rhs_val,\n-                        unit_ty);\n+        rslt =\n+            copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy, rhs_val,\n+                     unit_ty);\n         rhs_do_copy_cx = rslt.bcx;\n-        rhs_do_copy_cx.build.Store(rhs_do_copy_cx.build.InBoundsGEP(\n-            dest_ptr_rhs_copy, [C_int(1)]), dest_ptr_ptr);\n-        rhs_do_copy_cx.build.Store(rhs_do_copy_cx.build.InBoundsGEP(\n-            rhs_ptr, [C_int(1)]), rhs_ptr_ptr);\n+        {\n+            auto d = rhs_do_copy_cx.build.InBoundsGEP(dest_ptr_rhs_copy,\n+                                                      [C_int(1)]);\n+            auto rhs = rhs_do_copy_cx.build.InBoundsGEP(rhs_ptr,\n+                                                        [C_int(1)]);\n+            rhs_do_copy_cx.build.Store(d, dest_ptr_ptr);\n+            rhs_do_copy_cx.build.Store(rhs, rhs_ptr_ptr);\n+        }\n         rhs_do_copy_cx.build.Br(rhs_copy_cx.llbb);\n-\n         // Finally done!\n+\n         ret res(next_cx, llvecptr);\n     }\n }\n \n-\n fn trans_vec_add(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n    result {\n     auto r = alloc_ty(cx, t);\n@@ -4715,9 +4748,9 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n                 case (_) {\n                     // Shouldn't happen.\n \n-                    cx.fcx.lcx.ccx.sess.bug(\"trans_lval called on \"\n-                                            + \"expr_self_method in a context\"\n-                                            + \"without llself\");\n+                    cx.fcx.lcx.ccx.sess.bug(\"trans_lval called on \" +\n+                                                \"expr_self_method in \" +\n+                                                \"a context without llself\");\n                 }\n             }\n         }\n@@ -5359,9 +5392,10 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, &ast::ann ann) ->\n     ret res(bcx, vec_val);\n }\n \n+\n // TODO: Move me to ivec::\n fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n-        result {\n+   result {\n     auto typ = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto unit_ty;\n     alt (ty::struct(bcx.fcx.lcx.ccx.tcx, typ)) {\n@@ -5396,17 +5430,13 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n     } else {\n         // Heap case.\n \n-\n         auto stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n         auto stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n         auto stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-\n         auto llstubty = T_ivec_heap(llunitty);\n         auto llstubptr = bcx.build.PointerCast(llvecptr, T_ptr(llstubty));\n-        bcx.build.Store(C_int(0),\n-                        bcx.build.InBoundsGEP(llstubptr, stub_z));\n-        bcx.build.Store(lllen,\n-                        bcx.build.InBoundsGEP(llstubptr, stub_a));\n+        bcx.build.Store(C_int(0), bcx.build.InBoundsGEP(llstubptr, stub_z));\n+        bcx.build.Store(lllen, bcx.build.InBoundsGEP(llstubptr, stub_a));\n         auto llheapty = T_ivec_heap_part(llunitty);\n         if (vec::len(args) == 0u) {\n             // Null heap pointer indicates a zero-length vector.\n@@ -5422,8 +5452,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, &ast::ann ann) ->\n             bcx.build.Store(llheapptr,\n                             bcx.build.InBoundsGEP(llstubptr, stub_p));\n             auto heap_l = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-            bcx.build.Store(lllen,\n-                            bcx.build.InBoundsGEP(llheapptr, heap_l));\n+            bcx.build.Store(lllen, bcx.build.InBoundsGEP(llheapptr, heap_l));\n             llfirsteltptr =\n                 bcx.build.InBoundsGEP(llheapptr,\n                                       [C_int(0),\n@@ -5601,14 +5630,15 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto rhs_res = trans_lval(lhs_res.res.bcx, src);\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n             auto tmp_res = alloc_ty(rhs_res.res.bcx, t);\n-\n             // Swap through a temporary.\n-            auto move1_res = memmove_ty(tmp_res.bcx, tmp_res.val,\n-                                        lhs_res.res.val, t);\n-            auto move2_res = memmove_ty(move1_res.bcx, lhs_res.res.val,\n-                                        rhs_res.res.val, t);\n-            auto move3_res = memmove_ty(move2_res.bcx, rhs_res.res.val,\n-                                        tmp_res.val, t);\n+\n+            auto move1_res =\n+                memmove_ty(tmp_res.bcx, tmp_res.val, lhs_res.res.val, t);\n+            auto move2_res =\n+                memmove_ty(move1_res.bcx, lhs_res.res.val, rhs_res.res.val,\n+                           t);\n+            auto move3_res =\n+                memmove_ty(move2_res.bcx, rhs_res.res.val, tmp_res.val, t);\n             ret res(move3_res.bcx, C_nil());\n         }\n         case (ast::expr_assign_op(?op, ?dst, ?src, _)) {\n@@ -6141,7 +6171,6 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n         mangle_internal_name_by_path_and_seq(cx.fcx.lcx.ccx, cx.fcx.lcx.path,\n                                              \"spawn_wrapper\");\n     auto llfndecl = decl_cdecl_fn(llmod, wrap_name, wrapper_fn_type);\n-\n     auto fcx = new_fn_ctxt(cx.fcx.lcx, cx.sp, llfndecl);\n     auto fbcx = new_top_block_ctxt(fcx);\n     // 3u to skip the three implicit args\n@@ -6270,21 +6299,20 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast::expr rhs, &ty::t unit_ty,\n // function and putting it in the generated code as an object item, we are\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n-fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj, \n+fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n                   &vec[ast::ty_param] ty_params, ast::def_id oid,\n                   &ast::ann ann) -> result {\n-\n     // Right now, we're assuming that anon objs don't take ty params, even\n     // though the AST supports it.  It's nonsensical to write an expression\n     // like \"obj[T](){ ... with ... }\", since T is never instantiated;\n     // nevertheless, such an expression will parse.  FIXME for the future:\n     // support typarams (issue #n).\n-    assert vec::len(ty_params) == 0u;\n \n+    assert (vec::len(ty_params) == 0u);\n     auto ccx = bcx.fcx.lcx.ccx;\n-\n     // If with_obj (the object being extended) exists, translate it, producing\n     // a result.\n+\n     let option::t[result] with_obj_val = none[result];\n     alt (anon_obj.with_obj) {\n         case (none) { }\n@@ -6296,41 +6324,38 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             with_obj_val = some[result](trans_expr(bcx, e));\n         }\n     }\n-\n     // FIXME (part of issue #417): all of the following code is copypasta from\n     // trans_obj for translating the anonymous wrapper object.  Eventually we\n     // should abstract this code out of trans_anon_obj and trans_obj.\n \n     auto self_ty = ty::ann_to_type(ccx.tcx, ann);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n-\n     // Allocate the object that we're going to return.  It's a two-word pair\n     // containing a vtable pointer and a body pointer.\n-    auto pair = alloca(bcx, llself_ty);\n \n+    auto pair = alloca(bcx, llself_ty);\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n+\n     auto pair_vtbl =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     auto pair_box =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n-\n     // Make a vtable for the outer object.  create_vtbl() wants an ast::_obj\n     // and all we have is an ast::anon_obj, so we need to roll our own.\n+\n     let vec[ast::obj_field] addtl_fields = [];\n     alt (anon_obj.fields) {\n         case (none) { }\n         case (some(?fields)) { addtl_fields = fields; }\n     }\n-    let ast::_obj wrapper_obj = rec(\n-        fields = addtl_fields,\n-        methods = anon_obj.methods,\n-        dtor = none[@ast::method]);\n-\n-    auto vtbl = create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, \n-                            ty_params);\n-\n+    let ast::_obj wrapper_obj =\n+        rec(fields=addtl_fields,\n+            methods=anon_obj.methods,\n+            dtor=none[@ast::method]);\n+    auto vtbl =\n+        create_vtbl(bcx.fcx.lcx, llself_ty, self_ty, wrapper_obj, ty_params);\n     bcx.build.Store(vtbl, pair_vtbl);\n     // FIXME (part of issue #417): This vtable needs to contain \"forwarding\n     // slots\" for the methods that exist in the with_obj, as well.  How do we\n@@ -6344,29 +6369,28 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // also have to fill in the with_obj field of this tuple.\n \n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n-    \n     alt (anon_obj.fields) {\n-        case (none) { \n+        case (none) {\n             // If the object we're translating has no fields or type\n             // parameters, there's not much to do.\n \n             // Store null into pair, if no args or typarams.\n-            bcx.build.Store(C_null(llbox_ty), pair_box);\n \n+            bcx.build.Store(C_null(llbox_ty), pair_box);\n         }\n-\n         case (some(?fields)) {\n             // For the moment let's pretend that there are no additional\n             // fields.\n-            bcx.fcx.lcx.ccx.sess.unimpl(\"anon objs don't support \"\n-                                        + \"adding fields yet\");\n \n+            bcx.fcx.lcx.ccx.sess.unimpl(\"anon objs don't support \" +\n+                                            \"adding fields yet\");\n             // FIXME (issue #417): drop these fields into the newly created\n             // object.\n+\n         }\n     }\n-\n     // Return the object we built.\n+\n     ret res(bcx, pair);\n }\n \n@@ -6824,8 +6848,8 @@ fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n     alt (ty::struct(ccx.tcx, t)) {\n         case (ty::ty_fn(_, _, ?ret_ty, _, _)) { ret ret_ty; }\n         case (_) {\n-            ccx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \"\n-                         + ty_to_str(ccx.tcx, t));\n+            ccx.sess.bug(\"ret_ty_of_fn_ty() called on non-function type: \" +\n+                             ty_to_str(ccx.tcx, t));\n         }\n     }\n }\n@@ -6976,10 +7000,10 @@ fn create_vtbl(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n         let str s = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n         let ValueRef llfn =\n             decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n-\n         // Every method on an object gets its def_id inserted into the\n         // crate-wide item_ids map, together with the ValueRef that points to\n         // where that method's definition will be in the executable.\n+\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n         cx.ccx.item_symbols.insert(m.node.id, s);\n         trans_fn(mcx, m.span, m.node.meth, llfn,\n@@ -7330,6 +7354,7 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n     }\n }\n \n+\n // Translate a module.  Doing this amounts to translating the items in the\n // module; there ends up being no artifact (aside from linkage names) of\n // separate modules in the compiled program.  That's because modules exist\n@@ -7587,9 +7612,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path,\n     finish_fn(fcx, lltop);\n }\n \n-fn item_path(&@ast::item item) -> vec[str] {\n-    ret [item.ident];\n-}\n+fn item_path(&@ast::item item) -> vec[str] { ret [item.ident]; }\n \n fn collect_native_item(@crate_ctxt ccx, &@ast::native_item i, &vec[str] pt,\n                        &vt[vec[str]] v) {"}, {"sha": "108d050757f5ad174e6cfff6b30d56843c9e0a27", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -11,23 +11,28 @@ import std::bitv;\n  */\n type precond = bitv::t;\n \n- /* 1 means \"this variable must be initialized\"\n-   0 means \"don't care about this variable\" */\n- type postcond = bitv::t;\n-\n- /* 1 means \"this variable is initialized\"\n-   0 means \"don't know about this variable */\n- type prestate = bitv::t;\n-\n- /* 1 means \"this variable is definitely initialized\"\n-   0 means \"don't know whether this variable is\n-   initialized\" */\n- type poststate = bitv::t;\n-\n- /* 1 means \"this variable is definitely initialized\"\n-   0 means \"don't know whether this variable is\n-   initialized\" */\n-  /* named thus so as not to confuse with prestate and poststate */\n+\n+/* 1 means \"this variable must be initialized\"\n+  0 means \"don't care about this variable\" */\n+type postcond = bitv::t;\n+\n+\n+/* 1 means \"this variable is initialized\"\n+  0 means \"don't know about this variable */\n+type prestate = bitv::t;\n+\n+\n+/* 1 means \"this variable is definitely initialized\"\n+  0 means \"don't know whether this variable is\n+  initialized\" */\n+type poststate = bitv::t;\n+\n+\n+/* 1 means \"this variable is definitely initialized\"\n+  0 means \"don't know whether this variable is\n+  initialized\" */\n+\n+/* named thus so as not to confuse with prestate and poststate */\n type pre_and_post = @rec(precond precondition, postcond postcondition);\n \n "}, {"sha": "91359eb82311aed0294c6f1e21b2b5c1833a6229", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -198,9 +198,10 @@ to represent predicate *arguments* however. This type\n Both types store an ident and span, for error-logging purposes.\n */\n type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n+\n type pred_desc = spanned[pred_desc_];\n-type constr_arg_use = constr_arg_general[ident];\n \n+type constr_arg_use = constr_arg_general[ident];\n \n tag constraint {\n     cinit(uint, span, ident);\n@@ -512,11 +513,10 @@ fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n // FIXME:\n // this probably doesn't handle name shadowing well (or at all)\n // variables should really always be id'd by def_id and not ident\n-\n fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, vec[@constr_arg_use] occ) ->\n    uint {\n-    log (\"match_args: looking at \" +\n-         pretty::ppaux::constr_args_to_str(std::util::id[str], occ));\n+    log \"match_args: looking at \" +\n+            pretty::ppaux::constr_args_to_str(std::util::id[str], occ);\n     for (pred_desc pd in occs) {\n         log \"match_args: candidate \" + pred_desc_to_str(pd);\n         if (ty::args_eq(str::eq, pd.node.args, occ)) { ret pd.node.bit_num; }\n@@ -589,13 +589,12 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n \n fn pred_desc_to_str(&pred_desc p) -> str {\n     ret \"<\" + uistr(p.node.bit_num) + \", \" +\n-         pretty::ppaux::constr_args_to_str(std::util::id[str], p.node.args)\n-         + \">\";\n+            pretty::ppaux::constr_args_to_str(std::util::id[str], p.node.args)\n+            + \">\";\n }\n \n-fn substitute_constr_args(&ty::ctxt cx,\n-                          &vec[@expr] actuals, &@ty::constr_def c)\n-    -> constr__ {\n+fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n+                          &@ty::constr_def c) -> constr__ {\n     let vec[@constr_arg_use] res = [];\n     for (@constr_arg a in c.node.args) {\n         res += [substitute_arg(cx, actuals, a)];"}, {"sha": "4a4c7c47490da8257a320bb0d3cc4ee4b3c00b3a", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -145,7 +145,8 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) {\n         if (!promises(fcx, { *post }, ret_c)) {\n             fcx.ccx.tcx.sess.span_err(f.body.span,\n                                       \"In non-returning function \" + fcx.name\n-                                      + \", some control paths may \\\n+                                          +\n+                                          \", some control paths may \\\n                                            return to the caller\");\n         }\n     }"}, {"sha": "9fcec2549f87c90224b19ad9222c750b96fd651d", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -102,6 +102,7 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n     alt (i.node) {\n         case (item_const(_, ?e)) {\n             // make a fake fcx\n+\n             auto fake_fcx =\n                 rec(enclosing=rec(constrs=@new_def_hash[constraint](),\n                                   num_constraints=0u,\n@@ -113,19 +114,18 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n         }\n         case (item_fn(?f, ?ps)) {\n             assert (ccx.fm.contains_key(i.id));\n-            auto fcx = rec(enclosing=ccx.fm.get(i.id), id=i.id,\n-                           name=i.ident, ccx=ccx);\n+            auto fcx =\n+                rec(enclosing=ccx.fm.get(i.id),\n+                    id=i.id,\n+                    name=i.ident,\n+                    ccx=ccx);\n             find_pre_post_fn(fcx, f);\n         }\n         case (item_mod(?m)) { find_pre_post_mod(m); }\n-        case (item_native_mod(?nm)) {\n-            find_pre_post_native_mod(nm);\n-        }\n+        case (item_native_mod(?nm)) { find_pre_post_native_mod(nm); }\n         case (item_ty(_, _)) { ret; }\n         case (item_tag(_, _)) { ret; }\n-        case (item_obj(?o, _, _)) {\n-            find_pre_post_obj(ccx, o);\n-        }\n+        case (item_obj(?o, _, _)) { find_pre_post_obj(ccx, o); }\n     }\n }\n \n@@ -254,15 +254,20 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             vec::push[@expr](args, operator);\n             find_pre_post_exprs(fcx, args, a);\n             /* see if the call has any constraints on its type */\n-            log(\"a function: \" );\n+\n+            log \"a function: \";\n             log_expr(*operator);\n             auto pp = expr_pp(fcx.ccx, e);\n-            for (@ty::constr_def c in \n-                     constraints_expr(fcx.ccx.tcx, operator)) {\n-                auto i = bit_num(fcx, rec(id=c.node.id,\n-                  c=substitute_constr_args(fcx.ccx.tcx, operands, c)));\n+            for (@ty::constr_def c in constraints_expr(fcx.ccx.tcx, operator))\n+                {\n+                auto i =\n+                    bit_num(fcx,\n+                            rec(id=c.node.id,\n+                                c=substitute_constr_args(fcx.ccx.tcx,\n+                                                         operands, c)));\n                 require(i, pp);\n             }\n+\n             /* if this is a failing call, its postcondition sets everything */\n             alt (controlflow_expr(fcx.ccx, operator)) {\n                 case (noreturn) { set_postcond_false(fcx.ccx, a); }\n@@ -340,6 +345,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         }\n         case (expr_swap(?lhs, ?rhs, ?a)) {\n             // Both sides must already be initialized\n+\n             find_pre_post_exprs(fcx, [lhs, rhs], a);\n         }\n         case (expr_assign(?lhs, ?rhs, ?a)) {"}, {"sha": "c6df8e71cc0dccc7c85746eda4e51ec96ebdac53", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -361,18 +361,17 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n         }\n         case (expr_swap(?lhs, ?rhs, ?a)) {\n             /* quite similar to binary -- should abstract this */\n+\n             changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n-            changed = find_pre_post_state_expr(fcx, pres, lhs)\n-                || changed;\n+            changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n             changed =\n-                find_pre_post_state_expr(fcx,\n-                                         expr_poststate(fcx.ccx, lhs),\n+                find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, lhs),\n                                          rhs) || changed;\n             changed =\n-                extend_poststate_ann(fcx.ccx, a,\n-                                     expr_poststate(fcx.ccx, rhs)) || changed;\n-        ret changed;\n-    }\n+                extend_poststate_ann(fcx.ccx, a, expr_poststate(fcx.ccx, rhs))\n+                    || changed;\n+            ret changed;\n+        }\n         case (expr_recv(?lhs, ?rhs, ?a)) {\n             extend_prestate_ann(fcx.ccx, a, pres);\n             alt (lhs.node) {\n@@ -502,8 +501,8 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n                     auto b_post = block_poststate(fcx.ccx, body);\n                     extend_poststate_ann(fcx.ccx, a,\n                                          intersect_postconds([e_post,\n-                                                              b_post]))\n-                    || changed\n+                                                              b_post])) ||\n+                        changed\n                 };\n             ret changed;\n         }"}, {"sha": "0433a76c616c90e2d1cf7d9facc5aebc8e03da71", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -20,7 +20,6 @@ import front::ast::controlflow;\n import front::creader;\n import middle::metadata;\n import util::common::*;\n-\n import util::data::interner;\n \n \n@@ -45,14 +44,14 @@ tag any_item {\n }\n \n type item_table = hashmap[ast::def_id, any_item];\n-type constr_table = hashmap[ast::def_id, vec[constr_def]]; \n+\n+type constr_table = hashmap[ast::def_id, vec[constr_def]];\n \n type mt = rec(t ty, ast::mutability mut);\n \n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-\n type creader_cache = hashmap[tup(int, uint, uint), ty::t];\n \n type ctxt =\n@@ -61,6 +60,7 @@ type ctxt =\n         resolve::def_map def_map,\n         node_type_table node_types,\n         item_table items, // Only contains type items\n+\n         constr_table fn_constrs,\n         type_cache tcache,\n         creader_cache rcache,\n@@ -69,12 +69,14 @@ type ctxt =\n \n type ty_ctxt = ctxt;\n \n- // Needed for disambiguation from unify::ctxt.\n- // Convert from method type to function type.  Pretty easy; we just drop\n- // 'ident'.\n- fn method_ty_to_fn_ty(&ctxt cx, method m) -> t {\n-     ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n- }\n+\n+// Needed for disambiguation from unify::ctxt.\n+// Convert from method type to function type.  Pretty easy; we just drop\n+// 'ident'.\n+fn method_ty_to_fn_ty(&ctxt cx, method m) -> t {\n+    ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n+}\n+\n \n // Never construct these manually. These are interned.\n //\n@@ -127,9 +129,10 @@ tag sty {\n }\n \n type constr_def = spanned[constr_general[uint]];\n-type constr_general[T] =  rec(path path,\n-                              vec[@constr_arg_general[T]] args,\n-                              def_id id);\n+\n+type constr_general[T] =\n+    rec(path path, vec[@constr_arg_general[T]] args, def_id id);\n+\n \n // Data structures used in type unification\n tag type_err {\n@@ -244,7 +247,6 @@ fn mk_rcache() -> creader_cache {\n }\n \n fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs) -> ctxt {\n-\n     let vec[mutable option::t[ty::ty_param_substs_opt_and_ty]] ntt_sub =\n         [mutable ];\n     let node_type_table ntt = @mutable ntt_sub;\n@@ -257,7 +259,7 @@ fn mk_ctxt(session::session s, resolve::def_map dm, constr_table cs) -> ctxt {\n             def_map=dm,\n             node_types=ntt,\n             items=items,\n-            fn_constrs = cs,\n+            fn_constrs=cs,\n             tcache=tcache,\n             rcache=mk_rcache(),\n             short_names_cache=map::mk_hashmap[ty::t,\n@@ -1113,7 +1115,7 @@ fn args_eq[T](fn(&T, &T) -> bool  eq, vec[@ast::constr_arg_general[T]] a,\n \n fn constr_eq(&@constr_def c, &@constr_def d) -> bool {\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n-             // FIXME: hack\n+            // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n@@ -1529,7 +1531,7 @@ fn expr_ann(&@ast::expr e) -> ast::ann {\n         case (ast::expr_block(_, ?a)) { ret a; }\n         case (ast::expr_move(_, _, ?a)) { ret a; }\n         case (ast::expr_assign(_, _, ?a)) { ret a; }\n-        case (ast::expr_swap(_,_,?a)) { ret a; }\n+        case (ast::expr_swap(_, _, ?a)) { ret a; }\n         case (ast::expr_assign_op(_, _, _, ?a)) { ret a; }\n         case (ast::expr_send(_, _, ?a)) { ret a; }\n         case (ast::expr_recv(_, _, ?a)) { ret a; }"}, {"sha": "f939fb59e3d35e7851594416695c045d7db0fe54", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -103,10 +103,7 @@ fn walk_item(&ast_visitor v, @ast::item i) {\n     if (!v.keep_going()) { ret; }\n     v.visit_item_pre(i);\n     alt (i.node) {\n-        case (ast::item_const(?t, ?e)) {\n-            walk_ty(v, t);\n-            walk_expr(v, e);\n-        }\n+        case (ast::item_const(?t, ?e)) { walk_ty(v, t); walk_expr(v, e); }\n         case (ast::item_fn(?f, _)) {\n             walk_fn(v, f, i.span, i.ident, i.id, i.ann);\n         }"}, {"sha": "61f502ac238e02cb5b04cd38f44a7efeb0a5dee6", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -208,9 +208,8 @@ obj printer(io::writer out,\n \n             mutable uint right, // index of right side of input stream\n \n-            mutable vec[mutable token]\n-                token, // ring-buffr stream goes through\n-\n+            mutable vec[mutable token] token,\n+             // ring-buffr stream goes through\n             mutable vec[mutable int] size, // ring-buffer of calculated sizes\n \n             mutable int left_total, // running size of stream \"...left\""}, {"sha": "d00b10596a1f858cea659124e429573f5f313fbd", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -20,7 +20,6 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n             };\n         ret s + ty_to_str(cx, input.ty);\n     }\n-\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  vec[arg] inputs, t output, ast::controlflow cf,\n                  &vec[@constr_def] constrs) -> str {\n@@ -92,18 +91,16 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-            s +=\n-                \"<tag#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n+\n+            s += \"<tag#\" + istr(id._0) + \":\" + istr(id._1) + \">\";\n             if (vec::len[t](tps) > 0u) {\n                 auto f = bind ty_to_str(cx, _);\n                 auto strs = vec::map[t, str](f, tps);\n                 s += \"[\" + str::connect(strs, \",\") + \"]\";\n             }\n         }\n         case (ty_fn(?proto, ?inputs, ?output, ?cf, ?constrs)) {\n-            s +=\n-                fn_to_str(cx, proto, none, inputs, output, cf,\n-                          constrs);\n+            s += fn_to_str(cx, proto, none, inputs, output, cf, constrs);\n         }\n         case (ty_native_fn(_, ?inputs, ?output)) {\n             s +=\n@@ -346,18 +343,16 @@ const uint default_columns = 78u;\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-\n fn uint_to_str(&uint i) -> str { ret uistr(i); }\n \n fn constr_to_str(&@constr_def c) -> str {\n-  ret path_to_str(c.node.path)\n-      + constr_args_to_str(uint_to_str, c.node.args);\n+    ret path_to_str(c.node.path) +\n+            constr_args_to_str(uint_to_str, c.node.args);\n }\n \n-\n fn ast_constr_to_str(&@front::ast::constr c) -> str {\n-  ret path_to_str(c.node.path)\n-      + constr_args_to_str(uint_to_str, c.node.args);\n+    ret path_to_str(c.node.path) +\n+            constr_args_to_str(uint_to_str, c.node.args);\n }\n \n fn constrs_str(&vec[@constr_def] constrs) -> str {\n@@ -371,21 +366,14 @@ fn constrs_str(&vec[@constr_def] constrs) -> str {\n }\n \n fn ast_constrs_str(&vec[@ast::constr] constrs) -> str {\n-  auto s = \"\";\n-  auto colon = true;\n-  for (@ast::constr c in constrs) {\n-    if (colon) {\n-      s += \" : \";\n-      colon = false;\n-    }\n-    else {\n-      s += \", \";\n+    auto s = \"\";\n+    auto colon = true;\n+    for (@ast::constr c in constrs) {\n+        if (colon) { s += \" : \"; colon = false; } else { s += \", \"; }\n+        s += ast_constr_to_str(c);\n     }\n-    s += ast_constr_to_str(c);\n-  }\n-  ret s;\n+    ret s;\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0af528d7e5f80961b0210dafb4c51b1dc62bf9a2", "filename": "src/lib/either.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -1,17 +1,15 @@\n+\n import option;\n import option::some;\n import option::none;\n \n-tag t[T, U] {\n-    left(T);\n-    right(U);\n-}\n+tag t[T, U] { left(T); right(U); }\n \n-type operator[T, U] = fn(&T) -> U;\n+type operator[T, U] = fn(&T) -> U ;\n \n-fn either[T, U, V](&operator[T, V] f_left,\n-                   &operator[U, V] f_right,\n-                   &t[T, U] value) -> V {\n+fn either[T, U,\n+          V](&operator[T, V] f_left, &operator[U, V] f_right, &t[T, U] value)\n+   -> V {\n     alt (value) {\n         case (left(?l)) { f_left(l) }\n         case (right(?r)) { f_right(r) }\n@@ -23,7 +21,7 @@ fn lefts[T, U](&vec[t[T, U]] eithers) -> vec[T] {\n     for (t[T, U] elt in eithers) {\n         alt (elt) {\n             case (left(?l)) { result += [l] }\n-            case (_) { /* fallthrough */ }\n+            case (_) {/* fallthrough */ }\n         }\n     }\n     ret result;\n@@ -34,7 +32,7 @@ fn rights[T, U](&vec[t[T, U]] eithers) -> vec[U] {\n     for (t[T, U] elt in eithers) {\n         alt (elt) {\n             case (right(?r)) { result += [r] }\n-            case (_) { /* fallthrough */ }\n+            case (_) {/* fallthrough */ }\n         }\n     }\n     ret result;\n@@ -51,7 +49,6 @@ fn partition[T, U](&vec[t[T, U]] eithers) -> tup(vec[T], vec[U]) {\n     }\n     ret tup(lefts, rights);\n }\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "8d5cd3a4c7bca967404ae6c0a9d8dbd04b9cac56", "filename": "src/lib/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -33,7 +33,8 @@ fn basename(path p) -> path {\n fn connect(path pre, path post) -> path {\n     auto len = str::byte_len(pre);\n     ret if (pre.(len - 1u) == os_fs::path_sep as u8) {\n-             // Trailing '/'?\n+\n+            // Trailing '/'?\n             pre + post\n         } else { pre + path_sep() + post };\n }"}, {"sha": "bcd440f1aa635b33dc8f08abe6fd783bcb8a399a", "filename": "src/lib/list.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -23,10 +23,7 @@ fn foldl[T, U](&list[T] ls_, &U u, fn(&T, &U) -> U  f) -> U {\n     auto ls = ls_;\n     while (true) {\n         alt (ls) {\n-            case (cons(?hd, ?tl)) {\n-                accum = f(hd, accum);\n-                ls = *tl;\n-            }\n+            case (cons(?hd, ?tl)) { accum = f(hd, accum); ls = *tl; }\n             case (nil) { break; }\n         }\n     }\n@@ -54,16 +51,13 @@ fn has[T](&list[T] ls_, &T elt) -> bool {\n     while (true) {\n         alt (ls) {\n             case (cons(?hd, ?tl)) {\n-                if (elt == hd) {\n-                    ret true;\n-                } else {\n-                    ls = *tl;\n-                }\n+                if (elt == hd) { ret true; } else { ls = *tl; }\n             }\n             case (nil) { ret false; }\n         }\n     }\n     ret false; // Typestate checker doesn't understand infinite loops\n+\n }\n \n fn length[T](&list[T] ls) -> uint {"}, {"sha": "a4e723bac4f0dc4b4bb1257e18e7cccd13efb061", "filename": "src/lib/term.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fterm.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -48,17 +48,11 @@ fn reset(io::buf_writer writer) {\n }\n \n fn color_supported() -> bool {\n-    auto supported_terms = [\"xterm-color\",\n-                            \"xterm\",\n-                            \"screen-bce\"];\n+    auto supported_terms = [\"xterm-color\", \"xterm\", \"screen-bce\"];\n     ret alt (generic_os::getenv(\"TERM\")) {\n-        case (option::some(?env)) {\n-            vec::member(env, supported_terms)\n-        }\n-        case (option::none) {\n-            false\n-        }\n-    };\n+            case (option::some(?env)) { vec::member(env, supported_terms) }\n+            case (option::none) { false }\n+        };\n }\n \n fn set_color(io::buf_writer writer, u8 first_char, u8 color) {"}, {"sha": "19bd5923630e7e2ed76aa891674d7c68ae7f4e61", "filename": "src/lib/util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b84fffaa4e0e672b4653a7832d75a2dc120040aa/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=b84fffaa4e0e672b4653a7832d75a2dc120040aa", "patch": "@@ -7,7 +7,8 @@ fn id[T](&T x) -> T { ret x; }\n  * the constraint once fixed. */\n type rational = rec(int num, int den);\n \n- // : int::positive(*.den);\n+\n+// : int::positive(*.den);\n fn rational_leq(&rational x, &rational y) -> bool {\n     // NB: Uses the fact that rationals have positive denominators WLOG:\n "}]}