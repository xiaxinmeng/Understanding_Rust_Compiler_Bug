{"sha": "1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "node_id": "C_kwDOAAsO6NoAKDFjMWE2MGYwYTNkYzM2ZjEzYmEwYzY0MmU5YmI0YTc4ZTIxNDJmNzQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-14T16:40:15Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-16T16:41:07Z"}, "message": "interpret: convert_tag_add_extra, init_allocation_extra: allow tagger to raise errors", "tree": {"sha": "88eb8eae80b66cbf709696036b1ad8b86f24c700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88eb8eae80b66cbf709696036b1ad8b86f24c700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "html_url": "https://github.com/rust-lang/rust/commit/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "872503d918b2c3266d828f85e42951df74f5e303", "url": "https://api.github.com/repos/rust-lang/rust/commits/872503d918b2c3266d828f85e42951df74f5e303", "html_url": "https://github.com/rust-lang/rust/commit/872503d918b2c3266d828f85e42951df74f5e303"}], "stats": {"total": 38, "additions": 21, "deletions": 17}, "files": [{"sha": "c18ac84171d694cb519e9128f453cb79cd69709e", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "patch": "@@ -334,12 +334,14 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n+    ///\n+    /// This must only fail if `alloc` contains relocations.\n     fn init_allocation_extra<'b>(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n     /// Hook for performing extra checks on a memory read access.\n     ///\n@@ -485,9 +487,9 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> Cow<'b, Allocation<Self::PointerTag>> {\n+    ) -> InterpResult<$tcx, Cow<'b, Allocation<Self::PointerTag>>> {\n         // We do not use a tag so we can just cheaply forward the allocation\n-        alloc\n+        Ok(alloc)\n     }\n \n     fn extern_static_base_pointer("}, {"sha": "d46f2f38d3a6547034c289b271c716216f8a0d52", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "patch": "@@ -199,7 +199,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        Ok(self.allocate_raw_ptr(alloc, kind))\n+        // We can `unwrap` since `alloc` contains no pointers.\n+        Ok(self.allocate_raw_ptr(alloc, kind).unwrap())\n     }\n \n     pub fn allocate_bytes_ptr(\n@@ -210,23 +211,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         mutability: Mutability,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        self.allocate_raw_ptr(alloc, kind)\n+        // We can `unwrap` since `alloc` contains no pointers.\n+        self.allocate_raw_ptr(alloc, kind).unwrap()\n     }\n \n+    /// This can fail only of `alloc` contains relocations.\n     pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n-    ) -> Pointer<M::PointerTag> {\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         let id = self.tcx.reserve_alloc_id();\n         debug_assert_ne!(\n             Some(kind),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n             \"dynamically allocating global memory\"\n         );\n-        let alloc = M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind));\n+        let alloc = M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind))?;\n         self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        M::tag_alloc_base_pointer(self, Pointer::from(id))\n+        Ok(M::tag_alloc_base_pointer(self, Pointer::from(id)))\n     }\n \n     pub fn reallocate_ptr(\n@@ -510,13 +513,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         M::before_access_global(*self.tcx, &self.machine, id, alloc, def_id, is_write)?;\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n-        let alloc = M::init_allocation_extra(\n+        M::init_allocation_extra(\n             self,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             Cow::Borrowed(alloc.inner()),\n             M::GLOBAL_KIND.map(MemoryKind::Machine),\n-        );\n-        Ok(alloc)\n+        )\n     }\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks."}, {"sha": "0893dd897e61250bafbd9a8a122e26c7be94fc42", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=1c1a60f0a3dc36f13ba0c642e9bb4a78e2142f74", "patch": "@@ -201,12 +201,12 @@ impl<Tag> Allocation<Tag> {\n \n impl Allocation {\n     /// Convert Tag and add Extra fields\n-    pub fn convert_tag_add_extra<Tag, Extra>(\n+    pub fn convert_tag_add_extra<Tag, Extra, Err>(\n         self,\n         cx: &impl HasDataLayout,\n         extra: Extra,\n-        mut tagger: impl FnMut(Pointer<AllocId>) -> Pointer<Tag>,\n-    ) -> Allocation<Tag, Extra> {\n+        mut tagger: impl FnMut(Pointer<AllocId>) -> Result<Pointer<Tag>, Err>,\n+    ) -> Result<Allocation<Tag, Extra>, Err> {\n         // Compute new pointer tags, which also adjusts the bytes.\n         let mut bytes = self.bytes;\n         let mut new_relocations = Vec::with_capacity(self.relocations.0.len());\n@@ -217,19 +217,19 @@ impl Allocation {\n             let ptr_bytes = &mut bytes[idx..idx + ptr_size];\n             let bits = read_target_uint(endian, ptr_bytes).unwrap();\n             let (ptr_tag, ptr_offset) =\n-                tagger(Pointer::new(alloc_id, Size::from_bytes(bits))).into_parts();\n+                tagger(Pointer::new(alloc_id, Size::from_bytes(bits)))?.into_parts();\n             write_target_uint(endian, ptr_bytes, ptr_offset.bytes().into()).unwrap();\n             new_relocations.push((offset, ptr_tag));\n         }\n         // Create allocation.\n-        Allocation {\n+        Ok(Allocation {\n             bytes,\n             relocations: Relocations::from_presorted(new_relocations),\n             init_mask: self.init_mask,\n             align: self.align,\n             mutability: self.mutability,\n             extra,\n-        }\n+        })\n     }\n }\n "}]}