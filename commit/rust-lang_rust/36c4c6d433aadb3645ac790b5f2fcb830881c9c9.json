{"sha": "36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YzRjNmQ0MzNhYWRiMzY0NWFjNzkwYjVmMmZjYjgzMDg4MWM5Yzk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:47Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-14T09:57:47Z"}, "message": "Rollup merge of #33544 - dotdash:baby_dont_break_me_no_more, r=Aatch\n\nOnly break critical edges where actually needed\n\nCurrently, to prepare for MIR trans, we break _all_ critical edges,\nalthough we only actually need to do this for edges originating from a\ncall that gets translated to an invoke instruction in LLVM.\n\nThis has the unfortunate effect of undoing a bunch of the things that\nSimplifyCfg has done. A particularly bad case arises when you have a\nC-like enum with N variants and a derived PartialEq implementation.\n\nIn that case, the match on the (&lhs, &rhs) tuple gets translated into\nnested matches with N arms each and a basic block each, resulting in N\u00b2\nbasic blocks. SimplifyCfg reduces that to roughly 2*N basic blocks, but\nbreaking the critical edges means that we go back to N\u00b2.\n\nIn nickel.rs, there is such an enum with roughly N=800. So we get about\n640K basic blocks or 2.5M lines of LLVM IR. LLVM takes a while to\nreduce that to the final \"disr_a == disr_b\".\n\nSo before this patch, we had 2.5M lines of IR with 640K basic blocks,\nwhich took about about 3.6s in LLVM to get optimized and translated.\nAfter this patch, we get about 650K lines with about 1.6K basic blocks\nand spent a little less than 0.2s in LLVM.\n\ncc #33111\n\nr? @Aatch", "tree": {"sha": "83bbac84f5300cdded068bb6aaf9894dba900867", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83bbac84f5300cdded068bb6aaf9894dba900867"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "html_url": "https://github.com/rust-lang/rust/commit/36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "html_url": "https://github.com/rust-lang/rust/commit/d3ec9d43cf948813fa5aab3dfacf97035ee90d16"}, {"sha": "00f6513259c12af733d22398b1ea77cff67b7beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/00f6513259c12af733d22398b1ea77cff67b7beb", "html_url": "https://github.com/rust-lang/rust/commit/00f6513259c12af733d22398b1ea77cff67b7beb"}], "stats": {"total": 232, "additions": 113, "deletions": 119}, "files": [{"sha": "46356add8c682db1dee3ad011bd10d42e11cfcf1", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "patch": "@@ -1036,7 +1036,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n         passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n-        passes.push_pass(box mir::transform::break_critical_edges::BreakCriticalEdges);\n+        passes.push_pass(box mir::transform::break_cleanup_edges::BreakCleanupEdges);\n         passes.run_passes(tcx, &mut mir_map);\n     });\n "}, {"sha": "0eb6223a71e54af5d64aed9cf8b11fc7e1ffda1e", "filename": "src/librustc_mir/transform/break_cleanup_edges.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/src%2Flibrustc_mir%2Ftransform%2Fbreak_cleanup_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/src%2Flibrustc_mir%2Ftransform%2Fbreak_cleanup_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_cleanup_edges.rs?ref=36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+\n+use rustc_data_structures::bitvec::BitVector;\n+\n+use pretty;\n+\n+use traversal;\n+\n+pub struct BreakCleanupEdges;\n+\n+/**\n+ * Breaks outgoing critical edges for call terminators in the MIR.\n+ *\n+ * Critical edges are edges that are neither the only edge leaving a\n+ * block, nor the only edge entering one.\n+ *\n+ * When you want something to happen \"along\" an edge, you can either\n+ * do at the end of the predecessor block, or at the start of the\n+ * successor block. Critical edges have to be broken in order to prevent\n+ * \"edge actions\" from affecting other edges. We need this for calls that are\n+ * translated to LLVM invoke instructions, because invoke is a block terminator\n+ * in LLVM so we can't insert any code to handle the call's result into the\n+ * block that performs the call.\n+ *\n+ * This function will break those edges by inserting new blocks along them.\n+ *\n+ * NOTE: Simplify CFG will happily undo most of the work this pass does.\n+ *\n+ */\n+\n+impl<'tcx> MirPass<'tcx> for BreakCleanupEdges {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+        let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+\n+        // Build the precedecessor map for the MIR\n+        for (_, data) in traversal::preorder(mir) {\n+            if let Some(ref term) = data.terminator {\n+                for &tgt in term.successors().iter() {\n+                    pred_count[tgt.index()] += 1;\n+                }\n+            }\n+        }\n+\n+        let cleanup_map : BitVector = mir.basic_blocks\n+            .iter().map(|bb| bb.is_cleanup).collect();\n+\n+        // We need a place to store the new blocks generated\n+        let mut new_blocks = Vec::new();\n+\n+        let bbs = mir.all_basic_blocks();\n+        let cur_len = mir.basic_blocks.len();\n+\n+        for &bb in &bbs {\n+            let data = mir.basic_block_data_mut(bb);\n+\n+            if let Some(ref mut term) = data.terminator {\n+                if term_is_invoke(term) {\n+                    let term_span = term.span;\n+                    let term_scope = term.scope;\n+                    let succs = term.successors_mut();\n+                    for tgt in succs {\n+                        let num_preds = pred_count[tgt.index()];\n+                        if num_preds > 1 {\n+                            // It's a critical edge, break it\n+                            let goto = Terminator {\n+                                span: term_span,\n+                                scope: term_scope,\n+                                kind: TerminatorKind::Goto { target: *tgt }\n+                            };\n+                            let mut data = BasicBlockData::new(Some(goto));\n+                            data.is_cleanup = cleanup_map.contains(tgt.index());\n+\n+                            // Get the index it will be when inserted into the MIR\n+                            let idx = cur_len + new_blocks.len();\n+                            new_blocks.push(data);\n+                            *tgt = BasicBlock::new(idx);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        pretty::dump_mir(tcx, \"break_cleanup_edges\", &0, src, mir, None);\n+        debug!(\"Broke {} N edges\", new_blocks.len());\n+\n+        mir.basic_blocks.extend_from_slice(&new_blocks);\n+    }\n+}\n+\n+impl Pass for BreakCleanupEdges {}\n+\n+// Returns true if the terminator is a call that would use an invoke in LLVM.\n+fn term_is_invoke(term: &Terminator) -> bool {\n+    match term.kind {\n+        TerminatorKind::Call { cleanup: Some(_), .. } |\n+        TerminatorKind::Drop { unwind: Some(_), .. } => true,\n+        _ => false\n+    }\n+}"}, {"sha": "a6af30b7eec08e6cb83a0f9e497d3572242ec682", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec9d43cf948813fa5aab3dfacf97035ee90d16/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec9d43cf948813fa5aab3dfacf97035ee90d16/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "patch": "@@ -1,117 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n-\n-use rustc_data_structures::bitvec::BitVector;\n-\n-use traversal;\n-\n-pub struct BreakCriticalEdges;\n-\n-/**\n- * Breaks critical edges in the MIR.\n- *\n- * Critical edges are edges that are neither the only edge leaving a\n- * block, nor the only edge entering one.\n- *\n- * When you want something to happen \"along\" an edge, you can either\n- * do at the end of the predecessor block, or at the start of the\n- * successor block. Critical edges have to be broken in order to prevent\n- * \"edge actions\" from affecting other edges.\n- *\n- * This function will break those edges by inserting new blocks along them.\n- *\n- * A special case is Drop and Call terminators with unwind/cleanup successors,\n- * They use `invoke` in LLVM, which terminates a block, meaning that code cannot\n- * be inserted after them, so even if an edge is the only edge leaving a block\n- * like that, we still insert blocks if the edge is one of many entering the\n- * target.\n- *\n- * NOTE: Simplify CFG will happily undo most of the work this pass does.\n- *\n- */\n-\n-impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n-        break_critical_edges(mir);\n-    }\n-}\n-\n-impl Pass for BreakCriticalEdges {}\n-\n-fn break_critical_edges(mir: &mut Mir) {\n-    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n-\n-    // Build the precedecessor map for the MIR\n-    for (_, data) in traversal::preorder(mir) {\n-        if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors().iter() {\n-                pred_count[tgt.index()] += 1;\n-            }\n-        }\n-    }\n-\n-    let cleanup_map : BitVector = mir.basic_blocks\n-        .iter().map(|bb| bb.is_cleanup).collect();\n-\n-    // We need a place to store the new blocks generated\n-    let mut new_blocks = Vec::new();\n-\n-    let bbs = mir.all_basic_blocks();\n-    let cur_len = mir.basic_blocks.len();\n-\n-    for &bb in &bbs {\n-        let data = mir.basic_block_data_mut(bb);\n-\n-        if let Some(ref mut term) = data.terminator {\n-            let is_invoke = term_is_invoke(term);\n-            let term_span = term.span;\n-            let term_scope = term.scope;\n-            let succs = term.successors_mut();\n-            if succs.len() > 1 || (succs.len() > 0 && is_invoke) {\n-                for tgt in succs {\n-                    let num_preds = pred_count[tgt.index()];\n-                    if num_preds > 1 {\n-                        // It's a critical edge, break it\n-                        let goto = Terminator {\n-                            span: term_span,\n-                            scope: term_scope,\n-                            kind: TerminatorKind::Goto { target: *tgt }\n-                        };\n-                        let mut data = BasicBlockData::new(Some(goto));\n-                        data.is_cleanup = cleanup_map.contains(tgt.index());\n-\n-                        // Get the index it will be when inserted into the MIR\n-                        let idx = cur_len + new_blocks.len();\n-                        new_blocks.push(data);\n-                        *tgt = BasicBlock::new(idx);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    debug!(\"Broke {} N edges\", new_blocks.len());\n-\n-    mir.basic_blocks.extend_from_slice(&new_blocks);\n-}\n-\n-// Returns true if the terminator would use an invoke in LLVM.\n-fn term_is_invoke(term: &Terminator) -> bool {\n-    match term.kind {\n-        TerminatorKind::Call { cleanup: Some(_), .. } |\n-        TerminatorKind::Drop { unwind: Some(_), .. } => true,\n-        _ => false\n-    }\n-}"}, {"sha": "0dcb7ef84d01df4bca25c8bf469c2589a93dc4f0", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36c4c6d433aadb3645ac790b5f2fcb830881c9c9/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=36c4c6d433aadb3645ac790b5f2fcb830881c9c9", "patch": "@@ -13,6 +13,6 @@ pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n-pub mod break_critical_edges;\n+pub mod break_cleanup_edges;\n pub mod promote_consts;\n pub mod qualify_consts;"}]}