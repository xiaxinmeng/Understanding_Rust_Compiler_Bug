{"sha": "ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "node_id": "C_kwDOAAsO6NoAKGVjZjNjZmY0YTZjN2MwNmQxZmUzMGU2MzZkNjkyMjdhYjYzMTBlYmI", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-09T10:58:52Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-09T10:58:52Z"}, "message": "Replace expressions with errors in them", "tree": {"sha": "49e23a4551b4247bb67423ee3a869606ec85e0c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49e23a4551b4247bb67423ee3a869606ec85e0c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "html_url": "https://github.com/rust-lang/rust/commit/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30287e6051f82085d62d38f26f42a53fa48b434c", "url": "https://api.github.com/repos/rust-lang/rust/commits/30287e6051f82085d62d38f26f42a53fa48b434c", "html_url": "https://github.com/rust-lang/rust/commit/30287e6051f82085d62d38f26f42a53fa48b434c"}], "stats": {"total": 117, "additions": 84, "deletions": 33}, "files": [{"sha": "1a7d9aa8411263ed4004ce40636e6a3a0b2284ce", "filename": "crates/hir_def/src/macro_expansion_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -186,7 +186,7 @@ pub fn identity_when_valid(_attr: TokenStream, item: TokenStream) -> TokenStream\n         let range: Range<usize> = range.into();\n \n         if show_token_ids {\n-            if let Some((tree, map)) = arg.as_deref() {\n+            if let Some((tree, map, _)) = arg.as_deref() {\n                 let tt_range = call.token_tree().unwrap().syntax().text_range();\n                 let mut ranges = Vec::new();\n                 extract_id_ranges(&mut ranges, &map, &tree);"}, {"sha": "eea02898d2c7f54004e60c9898bd9fc44da97ca1", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -108,7 +108,10 @@ pub trait AstDatabase: SourceDatabase {\n \n     /// Lowers syntactic macro call to a token tree representation.\n     #[salsa::transparent]\n-    fn macro_arg(&self, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>>;\n+    fn macro_arg(\n+        &self,\n+        id: MacroCallId,\n+    ) -> Option<Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupMap)>>;\n     /// Extracts syntax node, corresponding to a macro call. That's a firewall\n     /// query, only typing in the macro call itself changes the returned\n     /// subtree.\n@@ -291,29 +294,27 @@ fn parse_macro_expansion(\n     }\n }\n \n-fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree, mbe::TokenMap)>> {\n+fn macro_arg(\n+    db: &dyn AstDatabase,\n+    id: MacroCallId,\n+) -> Option<Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupMap)>> {\n     let arg = db.macro_arg_text(id)?;\n     let loc = db.lookup_intern_macro_call(id);\n \n     let node = SyntaxNode::new_root(arg);\n-    eprintln!(\"input text:\\n{node}\");\n-    eprintln!(\"input syntax:\\n{node:#?}\");\n     let censor = censor_for_macro_input(&loc, &node);\n     // TODO only fixup for attribute macro input\n     let mut fixups = fixup::fixup_syntax(&node);\n     fixups.replace.extend(censor.into_iter().map(|node| (node, Vec::new())));\n-    eprintln!(\"fixups: {fixups:?}\");\n     let (mut tt, tmap) =\n         mbe::syntax_node_to_token_tree_censored(&node, fixups.replace, fixups.append);\n \n-    eprintln!(\"fixed-up input: {}\", tt);\n-\n     if loc.def.is_proc_macro() {\n         // proc macros expect their inputs without parentheses, MBEs expect it with them included\n         tt.delimiter = None;\n     }\n \n-    Some(Arc::new((tt, tmap)))\n+    Some(Arc::new((tt, tmap, fixups.map)))\n }\n \n fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<SyntaxNode> {\n@@ -433,7 +434,6 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n     let ExpandResult { value: mut tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n-    // XXX: Make ExpandResult a real error and use .map_err instead?\n     if TOKEN_LIMIT.check(count).is_err() {\n         return ExpandResult::str_err(format!(\n             \"macro invocation exceeds token limit: produced {} tokens, limit is {}\",\n@@ -442,7 +442,7 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n         ));\n     }\n \n-    fixup::reverse_fixups(&mut tt, &macro_arg.1);\n+    fixup::reverse_fixups(&mut tt, &macro_arg.1, &macro_arg.2);\n \n     ExpandResult { value: Some(Arc::new(tt)), err }\n }"}, {"sha": "c98d20e4561ddd3af3d61f11348668a4521ca5df", "filename": "crates/hir_expand/src/fixup.rs", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Ffixup.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -10,21 +10,39 @@ use tt::Subtree;\n pub struct SyntaxFixups {\n     pub append: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n     pub replace: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+    pub map: SyntaxFixupMap,\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub struct SyntaxFixupMap {\n+    original: Vec<(Subtree, TokenMap)>,\n+}\n+\n+const EMPTY_ID: SyntheticTokenId = SyntheticTokenId(!0);\n+\n pub fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n     let mut append = FxHashMap::default();\n     let mut replace = FxHashMap::default();\n     let mut preorder = node.preorder();\n-    let empty_id = SyntheticTokenId(0);\n+    let mut original = Vec::new();\n     while let Some(event) = preorder.next() {\n         let node = match event {\n             syntax::WalkEvent::Enter(node) => node,\n             syntax::WalkEvent::Leave(_) => continue,\n         };\n-        if node.kind() == SyntaxKind::ERROR {\n-            // TODO this might not be helpful\n-            replace.insert(node, Vec::new());\n+        if can_handle_error(&node) && has_error_to_handle(&node) {\n+            // the node contains an error node, we have to completely replace it by something valid\n+            let original_tree = mbe::syntax_node_to_token_tree(&node);\n+            // TODO handle token ids / token map\n+            let idx = original.len() as u32;\n+            original.push(original_tree);\n+            let replacement = SyntheticToken {\n+                kind: SyntaxKind::IDENT,\n+                text: \"__ra_fixup\".into(),\n+                range: node.text_range(),\n+                id: SyntheticTokenId(idx),\n+            };\n+            replace.insert(node.clone(), vec![replacement]);\n             preorder.skip_subtree();\n             continue;\n         }\n@@ -39,7 +57,7 @@ pub fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n                                 kind: SyntaxKind::IDENT,\n                                 text: \"__ra_fixup\".into(),\n                                 range: end_range,\n-                                id: empty_id,\n+                                id: EMPTY_ID,\n                             },\n                         ]);\n                     }\n@@ -51,7 +69,7 @@ pub fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n                                 kind: SyntaxKind::SEMICOLON,\n                                 text: \";\".into(),\n                                 range: end_range,\n-                                id: empty_id,\n+                                id: EMPTY_ID,\n                             },\n                         ]);\n                     }\n@@ -60,18 +78,37 @@ pub fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n             }\n         }\n     }\n-    SyntaxFixups { append, replace }\n+    SyntaxFixups { append, replace, map: SyntaxFixupMap { original } }\n+}\n+\n+fn has_error(node: &SyntaxNode) -> bool {\n+    node.children().any(|c| c.kind() == SyntaxKind::ERROR)\n+}\n+\n+fn can_handle_error(node: &SyntaxNode) -> bool {\n+    ast::Expr::can_cast(node.kind())\n+}\n+\n+fn has_error_to_handle(node: &SyntaxNode) -> bool {\n+    has_error(node) || node.children().any(|c| !can_handle_error(&c) && has_error_to_handle(&c))\n }\n \n-pub fn reverse_fixups(tt: &mut Subtree, token_map: &TokenMap) {\n-    eprintln!(\"token_map: {:?}\", token_map);\n+pub fn reverse_fixups(tt: &mut Subtree, token_map: &TokenMap, fixup_map: &SyntaxFixupMap) {\n     tt.token_trees.retain(|tt| match tt {\n-        tt::TokenTree::Leaf(leaf) => token_map.synthetic_token_id(leaf.id()).is_none(),\n+        tt::TokenTree::Leaf(leaf) => {\n+            token_map.synthetic_token_id(leaf.id()).is_none()\n+                || token_map.synthetic_token_id(leaf.id()) != Some(EMPTY_ID)\n+        }\n         _ => true,\n     });\n     tt.token_trees.iter_mut().for_each(|tt| match tt {\n-        tt::TokenTree::Subtree(tt) => reverse_fixups(tt, token_map),\n-        _ => {}\n+        tt::TokenTree::Subtree(tt) => reverse_fixups(tt, token_map, fixup_map),\n+        tt::TokenTree::Leaf(leaf) => {\n+            if let Some(id) = token_map.synthetic_token_id(leaf.id()) {\n+                let (original, _original_tmap) = &fixup_map.original[id.0 as usize];\n+                *tt = tt::TokenTree::Subtree(original.clone());\n+            }\n+        }\n     });\n }\n \n@@ -84,6 +121,7 @@ mod tests {\n     #[track_caller]\n     fn check(ra_fixture: &str, mut expect: Expect) {\n         let parsed = syntax::SourceFile::parse(ra_fixture);\n+        eprintln!(\"parse: {:#?}\", parsed.syntax_node());\n         let fixups = super::fixup_syntax(&parsed.syntax_node());\n         let (mut tt, tmap) = mbe::syntax_node_to_token_tree_censored(\n             &parsed.syntax_node(),\n@@ -106,7 +144,7 @@ mod tests {\n             parse.syntax_node()\n         );\n \n-        reverse_fixups(&mut tt, &tmap);\n+        reverse_fixups(&mut tt, &tmap, &fixups.map);\n \n         // the fixed-up + reversed version should be equivalent to the original input\n         // (but token IDs don't matter)\n@@ -169,6 +207,20 @@ fn foo() {\n \"#,\n             expect![[r#\"\n fn foo () {a . b ; bar () ;}\n+\"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn extraneous_comma() {\n+        check(\n+            r#\"\n+fn foo() {\n+    bar(,);\n+}\n+\"#,\n+            expect![[r#\"\n+fn foo () {__ra_fixup ;}\n \"#]],\n         )\n     }"}, {"sha": "0ac5ee8306467619b45318b2da66c537fb5b9723", "filename": "crates/hir_expand/src/hygiene.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -15,6 +15,7 @@ use syntax::{\n \n use crate::{\n     db::{self, AstDatabase},\n+    fixup,\n     name::{AsName, Name},\n     HirFileId, HirFileIdRepr, InFile, MacroCallKind, MacroCallLoc, MacroDefKind, MacroFile,\n };\n@@ -127,7 +128,7 @@ struct HygieneInfo {\n     attr_input_or_mac_def_start: Option<InFile<TextSize>>,\n \n     macro_def: Arc<TokenExpander>,\n-    macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    macro_arg: Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupMap)>,\n     macro_arg_shift: mbe::Shift,\n     exp_map: Arc<mbe::TokenMap>,\n }"}, {"sha": "6ec507d00f3753d78578599afb72d19136b634c8", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -427,7 +427,7 @@ pub struct ExpansionInfo {\n     attr_input_or_mac_def: Option<InFile<ast::TokenTree>>,\n \n     macro_def: Arc<TokenExpander>,\n-    macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    macro_arg: Arc<(tt::Subtree, mbe::TokenMap, fixup::SyntaxFixupMap)>,\n     /// A shift built from `macro_arg`'s subtree, relevant for attributes as the item is the macro arg\n     /// and as such we need to shift tokens if they are part of an attributes input instead of their item.\n     macro_arg_shift: mbe::Shift,"}, {"sha": "da7fdb74ee832f820cf84e99954b23b52fddfa53", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -30,8 +30,8 @@ pub fn syntax_node_to_token_tree_censored(\n     let mut c = Convertor::new(node, global_offset, replace, append);\n     let subtree = convert_tokens(&mut c);\n     c.id_alloc.map.shrink_to_fit();\n-    always!(c.replace.is_empty());\n-    always!(c.append.is_empty());\n+    always!(c.replace.is_empty(), \"replace: {:?}\", c.replace);\n+    always!(c.append.is_empty(), \"append: {:?}\", c.append);\n     (subtree, c.id_alloc.map)\n }\n \n@@ -539,7 +539,6 @@ impl Convertor {\n                 WalkEvent::Enter(ele) => ele,\n                 WalkEvent::Leave(SyntaxElement::Node(node)) => {\n                     if let Some(mut v) = append.remove(&node) {\n-                        eprintln!(\"after {:?}, appending {:?}\", node, v);\n                         if !v.is_empty() {\n                             v.reverse();\n                             return (None, v);\n@@ -554,7 +553,6 @@ impl Convertor {\n                 SyntaxElement::Node(node) => {\n                     if let Some(mut v) = replace.remove(&node) {\n                         preorder.skip_subtree();\n-                        eprintln!(\"replacing {:?} by {:?}\", node, v);\n                         if !v.is_empty() {\n                             v.reverse();\n                             return (None, v);\n@@ -640,8 +638,8 @@ impl TokenConvertor for Convertor {\n                 self.current = new_current;\n                 self.current_synthetic = new_synth;\n             }\n-            // TODO fix range?\n-            return Some((SynToken::Synthetic(synth_token), self.range));\n+            let range = synth_token.range;\n+            return Some((SynToken::Synthetic(synth_token), range));\n         }\n \n         let curr = self.current.clone()?;\n@@ -675,7 +673,6 @@ impl TokenConvertor for Convertor {\n         }\n \n         if let Some(synth_token) = self.current_synthetic.last() {\n-            // TODO fix range?\n             return Some(SynToken::Synthetic(synth_token.clone()));\n         }\n "}, {"sha": "c923e7a69a1bcf8f18d4d3a9a7eba6fb7bb6612d", "filename": "crates/mbe/src/token_map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fmbe%2Fsrc%2Ftoken_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb/crates%2Fmbe%2Fsrc%2Ftoken_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftoken_map.rs?ref=ecf3cff4a6c7c06d1fe30e636d69227ab6310ebb", "patch": "@@ -74,6 +74,7 @@ impl TokenMap {\n \n     pub(crate) fn shrink_to_fit(&mut self) {\n         self.entries.shrink_to_fit();\n+        self.synthetic_entries.shrink_to_fit();\n     }\n \n     pub(crate) fn insert(&mut self, token_id: tt::TokenId, relative_range: TextRange) {"}]}