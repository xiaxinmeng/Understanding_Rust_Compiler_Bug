{"sha": "cdae9bab588880339b260c46f468294a76e554b1", "node_id": "C_kwDOAAsO6NoAKGNkYWU5YmFiNTg4ODgwMzM5YjI2MGM0NmY0NjgyOTRhNzZlNTU0YjE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-26T14:51:03Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-11-27T18:53:00Z"}, "message": "Introduce CargoProject type and use it where possible", "tree": {"sha": "5517ebf50babcc7e47c8d54ccea51acadb172f6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5517ebf50babcc7e47c8d54ccea51acadb172f6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdae9bab588880339b260c46f468294a76e554b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdae9bab588880339b260c46f468294a76e554b1", "html_url": "https://github.com/rust-lang/rust/commit/cdae9bab588880339b260c46f468294a76e554b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdae9bab588880339b260c46f468294a76e554b1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24ebf425ae3b9c3f95d5b8f239d18a2d7e66b540", "url": "https://api.github.com/repos/rust-lang/rust/commits/24ebf425ae3b9c3f95d5b8f239d18a2d7e66b540", "html_url": "https://github.com/rust-lang/rust/commit/24ebf425ae3b9c3f95d5b8f239d18a2d7e66b540"}], "stats": {"total": 755, "additions": 456, "deletions": 299}, "files": [{"sha": "8949f9f7e7d9a0d9ada361719e81202f9829eccf", "filename": "build_system/abi_cafe.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fabi_cafe.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -1,12 +1,16 @@\n-use std::env;\n use std::path::Path;\n \n use super::build_sysroot;\n use super::config;\n-use super::prepare;\n-use super::utils::{cargo_command, spawn_and_wait};\n+use super::prepare::GitRepo;\n+use super::utils::{spawn_and_wait, CargoProject, Compiler};\n use super::SysrootKind;\n \n+pub(crate) static ABI_CAFE_REPO: GitRepo =\n+    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n+\n+static ABI_CAFE: CargoProject = CargoProject::git(&ABI_CAFE_REPO, \".\");\n+\n pub(crate) fn run(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n@@ -36,17 +40,16 @@ pub(crate) fn run(\n     );\n \n     eprintln!(\"Running abi-cafe\");\n-    let abi_cafe_path = prepare::ABI_CAFE.source_dir();\n-    env::set_current_dir(abi_cafe_path.clone()).unwrap();\n \n     let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n \n-    let mut cmd = cargo_command(\"cargo\", \"run\", Some(target_triple), &abi_cafe_path);\n+    let mut cmd = ABI_CAFE.run(&Compiler::host());\n     cmd.arg(\"--\");\n     cmd.arg(\"--pairs\");\n     cmd.args(pairs);\n     cmd.arg(\"--add-rustc-codegen-backend\");\n     cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib.display()));\n+    cmd.current_dir(ABI_CAFE.source_dir());\n \n     spawn_and_wait(cmd);\n }"}, {"sha": "48648830a9f58b04745444bc4de800e6754a1c51", "filename": "build_system/build_backend.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_backend.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -2,15 +2,16 @@ use std::env;\n use std::path::PathBuf;\n \n use super::rustc_info::get_file_name;\n-use super::utils::{cargo_command, is_ci};\n+use super::utils::{is_ci, CargoProject, Compiler};\n+\n+static CG_CLIF: CargoProject = CargoProject::local(\".\");\n \n pub(crate) fn build_backend(\n     channel: &str,\n     host_triple: &str,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let source_dir = std::env::current_dir().unwrap();\n-    let mut cmd = cargo_command(\"cargo\", \"build\", Some(host_triple), &source_dir);\n+    let mut cmd = CG_CLIF.build(&Compiler::host());\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -41,7 +42,8 @@ pub(crate) fn build_backend(\n     eprintln!(\"[BUILD] rustc_codegen_cranelift\");\n     super::utils::spawn_and_wait(cmd);\n \n-    source_dir\n+    CG_CLIF\n+        .source_dir()\n         .join(\"target\")\n         .join(host_triple)\n         .join(channel)"}, {"sha": "731b94472ab5fbf52a21ca5ab5c4e9c61755be98", "filename": "build_system/build_sysroot.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fbuild_sysroot.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -3,7 +3,7 @@ use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{cargo_command, spawn_and_wait, try_hard_link};\n+use super::utils::{spawn_and_wait, try_hard_link, CargoProject, Compiler};\n use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n@@ -149,6 +149,8 @@ pub(crate) fn build_sysroot(\n     }\n }\n \n+static STANDARD_LIBRARY: CargoProject = CargoProject::local(\"build_sysroot\");\n+\n fn build_clif_sysroot_for_triple(\n     channel: &str,\n     target_dir: &Path,\n@@ -185,19 +187,22 @@ fn build_clif_sysroot_for_triple(\n     }\n \n     // Build sysroot\n-    let mut build_cmd = cargo_command(\"cargo\", \"build\", Some(triple), Path::new(\"build_sysroot\"));\n     let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n     rustflags.push_str(&format!(\" --sysroot={}\", target_dir.to_str().unwrap()));\n     if channel == \"release\" {\n-        build_cmd.arg(\"--release\");\n         rustflags.push_str(\" -Zmir-opt-level=3\");\n     }\n     if let Some(linker) = linker {\n         use std::fmt::Write;\n         write!(rustflags, \" -Clinker={}\", linker).unwrap();\n     }\n-    build_cmd.env(\"RUSTFLAGS\", rustflags);\n+    let mut compiler = Compiler::with_triple(triple.to_owned());\n+    compiler.rustflags = rustflags;\n+    let mut build_cmd = STANDARD_LIBRARY.build(&compiler);\n+    if channel == \"release\" {\n+        build_cmd.arg(\"--release\");\n+    }\n     build_cmd.env(\"__CARGO_DEFAULT_LIB_METADATA\", \"cg_clif\");\n     spawn_and_wait(build_cmd);\n "}, {"sha": "b06d42af14722f1094e739a3758f622e327e180d", "filename": "build_system/prepare.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Fprepare.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -5,30 +5,7 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{cargo_command, copy_dir_recursively, spawn_and_wait};\n-\n-pub(crate) const ABI_CAFE: GitRepo =\n-    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n-\n-pub(crate) const RAND: GitRepo =\n-    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n-\n-pub(crate) const REGEX: GitRepo =\n-    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n-\n-pub(crate) const PORTABLE_SIMD: GitRepo = GitRepo::github(\n-    \"rust-lang\",\n-    \"portable-simd\",\n-    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n-    \"portable-simd\",\n-);\n-\n-pub(crate) const SIMPLE_RAYTRACER: GitRepo = GitRepo::github(\n-    \"ebobby\",\n-    \"simple-raytracer\",\n-    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    \"<none>\",\n-);\n+use super::utils::{copy_dir_recursively, spawn_and_wait, Compiler};\n \n pub(crate) fn prepare() {\n     if Path::new(\"download\").exists() {\n@@ -42,22 +19,25 @@ pub(crate) fn prepare() {\n     eprintln!(\"[INSTALL] hyperfine\");\n     Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n \n-    ABI_CAFE.fetch();\n-    RAND.fetch();\n-    REGEX.fetch();\n-    PORTABLE_SIMD.fetch();\n-    SIMPLE_RAYTRACER.fetch();\n+    super::abi_cafe::ABI_CAFE_REPO.fetch();\n+    super::tests::RAND_REPO.fetch();\n+    super::tests::REGEX_REPO.fetch();\n+    super::tests::PORTABLE_SIMD_REPO.fetch();\n+    super::tests::SIMPLE_RAYTRACER_REPO.fetch();\n \n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let build_cmd = cargo_command(\"cargo\", \"build\", None, &SIMPLE_RAYTRACER.source_dir());\n+    let host_compiler = Compiler::host();\n+    let build_cmd = super::tests::SIMPLE_RAYTRACER.build(&host_compiler);\n     spawn_and_wait(build_cmd);\n     fs::copy(\n-        SIMPLE_RAYTRACER\n-            .source_dir()\n-            .join(\"target\")\n+        super::tests::SIMPLE_RAYTRACER\n+            .target_dir()\n+            .join(&host_compiler.triple)\n             .join(\"debug\")\n             .join(get_file_name(\"main\", \"bin\")),\n-        SIMPLE_RAYTRACER.source_dir().join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+        super::tests::SIMPLE_RAYTRACER_REPO\n+            .source_dir()\n+            .join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }\n@@ -100,7 +80,7 @@ enum GitRepoUrl {\n }\n \n impl GitRepo {\n-    const fn github(\n+    pub(crate) const fn github(\n         user: &'static str,\n         repo: &'static str,\n         rev: &'static str,"}, {"sha": "8e5ab688e131b35325af4fb83a3387b8c6228449", "filename": "build_system/rustc_info.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Frustc_info.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -23,6 +23,16 @@ pub(crate) fn get_host_triple() -> String {\n         .to_owned()\n }\n \n+pub(crate) fn get_cargo_path() -> PathBuf {\n+    let cargo_path = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"which\", \"cargo\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    Path::new(String::from_utf8(cargo_path).unwrap().trim()).to_owned()\n+}\n+\n pub(crate) fn get_rustc_path() -> PathBuf {\n     let rustc_path = Command::new(\"rustup\")\n         .stderr(Stdio::inherit())\n@@ -33,6 +43,16 @@ pub(crate) fn get_rustc_path() -> PathBuf {\n     Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n }\n \n+pub(crate) fn get_rustdoc_path() -> PathBuf {\n+    let rustc_path = Command::new(\"rustup\")\n+        .stderr(Stdio::inherit())\n+        .args(&[\"which\", \"rustdoc\"])\n+        .output()\n+        .unwrap()\n+        .stdout;\n+    Path::new(String::from_utf8(rustc_path).unwrap().trim()).to_owned()\n+}\n+\n pub(crate) fn get_default_sysroot() -> PathBuf {\n     let default_sysroot = Command::new(\"rustc\")\n         .stderr(Stdio::inherit())"}, {"sha": "b1c5c64883990934b35dd1848245b4da6e0eab02", "filename": "build_system/tests.rs", "status": "modified", "additions": 255, "deletions": 229, "changes": 484, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Ftests.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -1,8 +1,12 @@\n+use crate::build_system::rustc_info::get_cargo_path;\n+\n use super::build_sysroot;\n use super::config;\n-use super::prepare;\n+use super::prepare::GitRepo;\n use super::rustc_info::get_wrapper_file_name;\n-use super::utils::{cargo_command, hyperfine_command, spawn_and_wait, spawn_and_wait_with_input};\n+use super::utils::{\n+    hyperfine_command, spawn_and_wait, spawn_and_wait_with_input, CargoProject, Compiler,\n+};\n use super::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n@@ -30,7 +34,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib,dylib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"build.example\", &|runner| {\n@@ -39,7 +43,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"jit.mini_core_hello_world\", &|runner| {\n@@ -51,7 +55,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--cfg\",\n             \"jit\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n         spawn_and_wait(jit_cmd);\n@@ -65,7 +69,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"--cfg\",\n             \"jit\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         jit_cmd.env(\"CG_CLIF_JIT_ARGS\", \"abc bcd\");\n         spawn_and_wait(jit_cmd);\n@@ -79,7 +83,7 @@ const NO_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-g\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"mini_core_hello_world\", [\"abc\", \"bcd\"]);\n     }),\n@@ -94,7 +98,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"arbitrary_self_types_pointers_and_wrappers\", []);\n     }),\n@@ -106,7 +110,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"issue_91827_extern_types\", []);\n     }),\n@@ -116,7 +120,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"lib\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"aot.alloc_example\", &|runner| {\n@@ -125,7 +129,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"alloc_example\", []);\n     }),\n@@ -136,7 +140,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"-Cprefer-dynamic\",\n             \"example/std_example.rs\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n \n         eprintln!(\"[JIT-lazy] std_example\");\n@@ -146,7 +150,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"-Cprefer-dynamic\",\n             \"example/std_example.rs\",\n             \"--target\",\n-            &runner.host_triple,\n+            &runner.target_compiler.triple,\n         ]);\n     }),\n     TestCase::new(\"aot.std_example\", &|runner| {\n@@ -155,7 +159,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"std_example\", [\"arg\"]);\n     }),\n@@ -167,7 +171,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"dst_field_align\", []);\n     }),\n@@ -178,7 +182,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"subslice-patterns-const-eval\", []);\n     }),\n@@ -189,7 +193,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"track-caller-attribute\", []);\n     }),\n@@ -200,7 +204,7 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"bin\",\n             \"-Cpanic=abort\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"float-minmax-pass\", []);\n     }),\n@@ -210,181 +214,218 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n             \"--crate-type\",\n             \"bin\",\n             \"--target\",\n-            &runner.target_triple,\n+            &runner.target_compiler.triple,\n         ]);\n         runner.run_out_command(\"mod_bench\", []);\n     }),\n ];\n \n-const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n-    TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        runner.in_dir(prepare::RAND.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n+pub(crate) static RAND_REPO: GitRepo =\n+    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n \n-            if runner.host_triple == runner.target_triple {\n-                eprintln!(\"[TEST] rust-random/rand\");\n-                runner.run_cargo(\"test\", [\"--workspace\"]);\n-            } else {\n-                eprintln!(\"[AOT] rust-random/rand\");\n-                runner.run_cargo(\"build\", [\"--workspace\", \"--tests\"]);\n-            }\n-        });\n-    }),\n-    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        runner.in_dir(prepare::SIMPLE_RAYTRACER.source_dir(), |runner| {\n-            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n+static RAND: CargoProject = CargoProject::git(&RAND_REPO, \".\");\n \n-            if runner.host_triple == runner.target_triple {\n-                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-                let prepare = runner.cargo_command(\"clean\", []);\n+pub(crate) static REGEX_REPO: GitRepo =\n+    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n \n-                let llvm_build_cmd = cargo_command(\"cargo\", \"build\", None, Path::new(\".\"));\n+static REGEX: CargoProject = CargoProject::git(&REGEX_REPO, \".\");\n \n-                let cargo_clif = runner\n-                    .root_dir\n-                    .clone()\n-                    .join(\"build\")\n-                    .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-                let clif_build_cmd = cargo_command(cargo_clif, \"build\", None, Path::new(\".\"));\n+pub(crate) static PORTABLE_SIMD_REPO: GitRepo = GitRepo::github(\n+    \"rust-lang\",\n+    \"portable-simd\",\n+    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"portable-simd\",\n+);\n \n-                let bench_compile =\n-                    hyperfine_command(1, run_runs, Some(prepare), llvm_build_cmd, clif_build_cmd);\n+static PORTABLE_SIMD: CargoProject = CargoProject::git(&PORTABLE_SIMD_REPO, \".\");\n \n-                spawn_and_wait(bench_compile);\n+pub(crate) static SIMPLE_RAYTRACER_REPO: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n \n-                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n-                fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n-                    .unwrap();\n+pub(crate) static SIMPLE_RAYTRACER: CargoProject = CargoProject::git(&SIMPLE_RAYTRACER_REPO, \".\");\n \n-                let bench_run = hyperfine_command(\n-                    0,\n-                    run_runs,\n-                    None,\n-                    Command::new(\"./raytracer_cg_llvm\"),\n-                    Command::new(\"./raytracer_cg_clif\"),\n-                );\n-                spawn_and_wait(bench_run);\n-            } else {\n-                runner.run_cargo(\"clean\", []);\n-                eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n-                eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-                runner.run_cargo(\"build\", []);\n-                eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n-            }\n-        });\n+static LIBCORE_TESTS: CargoProject =\n+    CargoProject::local(\"build_sysroot/sysroot_src/library/core/tests\");\n+\n+const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n+    TestCase::new(\"test.rust-random/rand\", &|runner| {\n+        spawn_and_wait(RAND.clean(&runner.target_compiler.cargo));\n+\n+        if runner.is_native {\n+            eprintln!(\"[TEST] rust-random/rand\");\n+            let mut test_cmd = RAND.test(&runner.target_compiler);\n+            test_cmd.arg(\"--workspace\");\n+            spawn_and_wait(test_cmd);\n+        } else {\n+            eprintln!(\"[AOT] rust-random/rand\");\n+            let mut build_cmd = RAND.build(&runner.target_compiler);\n+            build_cmd.arg(\"--workspace\").arg(\"--tests\");\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n-    TestCase::new(\"test.libcore\", &|runner| {\n-        runner.in_dir(\n-            std::env::current_dir()\n+    TestCase::new(\"bench.simple-raytracer\", &|runner| {\n+        let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n+\n+        if runner.is_native {\n+            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n+            let cargo_clif = env::current_dir()\n                 .unwrap()\n-                .join(\"build_sysroot\")\n-                .join(\"sysroot_src\")\n-                .join(\"library\")\n-                .join(\"core\")\n-                .join(\"tests\"),\n-            |runner| {\n-                runner.run_cargo(\"clean\", []);\n-\n-                if runner.host_triple == runner.target_triple {\n-                    runner.run_cargo(\"test\", []);\n-                } else {\n-                    eprintln!(\"Cross-Compiling: Not running tests\");\n-                    runner.run_cargo(\"build\", [\"--tests\"]);\n-                }\n-            },\n-        );\n+                .join(\"build\")\n+                .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+            let source_dir = SIMPLE_RAYTRACER.source_dir();\n+            let manifest_path = SIMPLE_RAYTRACER.manifest_path();\n+            let target_dir = SIMPLE_RAYTRACER.target_dir();\n+\n+            let clean_cmd = format!(\n+                \"cargo clean --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+            let llvm_build_cmd = format!(\n+                \"cargo build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+            let clif_build_cmd = format!(\n+                \"{cargo_clif} build --manifest-path {manifest_path} --target-dir {target_dir}\",\n+                cargo_clif = cargo_clif.display(),\n+                manifest_path = manifest_path.display(),\n+                target_dir = target_dir.display(),\n+            );\n+\n+            let bench_compile =\n+                hyperfine_command(1, run_runs, Some(&clean_cmd), &llvm_build_cmd, &clif_build_cmd);\n+\n+            spawn_and_wait(bench_compile);\n+\n+            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n+            fs::copy(target_dir.join(\"debug\").join(\"main\"), source_dir.join(\"raytracer_cg_clif\"))\n+                .unwrap();\n+\n+            let mut bench_run = hyperfine_command(\n+                0,\n+                run_runs,\n+                None,\n+                &source_dir.join(\"raytracer_cg_llvm\").display().to_string(),\n+                &source_dir.join(\"raytracer_cg_clif\").display().to_string(),\n+            );\n+            bench_run.current_dir(SIMPLE_RAYTRACER.source_dir());\n+            spawn_and_wait(bench_run);\n+        } else {\n+            spawn_and_wait(SIMPLE_RAYTRACER.clean(&runner.target_compiler.cargo));\n+            eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n+            eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n+            spawn_and_wait(SIMPLE_RAYTRACER.build(&runner.target_compiler));\n+            eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n+        }\n+    }),\n+    TestCase::new(\"test.libcore\", &|runner| {\n+        spawn_and_wait(LIBCORE_TESTS.clean(&runner.host_compiler.cargo));\n+\n+        if runner.is_native {\n+            spawn_and_wait(LIBCORE_TESTS.test(&runner.target_compiler));\n+        } else {\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n+            let mut build_cmd = LIBCORE_TESTS.build(&runner.target_compiler);\n+            build_cmd.arg(\"--tests\");\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n+        spawn_and_wait(REGEX.clean(&runner.target_compiler.cargo));\n \n-            // newer aho_corasick versions throw a deprecation warning\n-            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n+        // newer aho_corasick versions throw a deprecation warning\n+        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n \n-            let mut build_cmd = runner.cargo_command(\"build\", [\"--example\", \"shootout-regex-dna\"]);\n-            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n-            spawn_and_wait(build_cmd);\n+        let mut build_cmd = REGEX.build(&runner.target_compiler);\n+        build_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n+        build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+        spawn_and_wait(build_cmd);\n+\n+        if runner.is_native {\n+            let mut run_cmd = REGEX.run(&runner.target_compiler);\n+            run_cmd.arg(\"--example\").arg(\"shootout-regex-dna\");\n+            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n-            if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command(\"run\", [\"--example\", \"shootout-regex-dna\"]);\n-                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n-\n-                let input =\n-                    fs::read_to_string(PathBuf::from(\"examples/regexdna-input.txt\")).unwrap();\n-                let expected_path = PathBuf::from(\"examples/regexdna-output.txt\");\n-                let expected = fs::read_to_string(&expected_path).unwrap();\n-\n-                let output = spawn_and_wait_with_input(run_cmd, input);\n-                // Make sure `[codegen mono items] start` doesn't poison the diff\n-                let output = output\n-                    .lines()\n-                    .filter(|line| !line.contains(\"codegen mono items\"))\n-                    .chain(Some(\"\")) // This just adds the trailing newline\n-                    .collect::<Vec<&str>>()\n-                    .join(\"\\r\\n\");\n-\n-                let output_matches = expected.lines().eq(output.lines());\n-                if !output_matches {\n-                    let res_path = PathBuf::from(\"res.txt\");\n-                    fs::write(&res_path, &output).unwrap();\n-\n-                    if cfg!(windows) {\n-                        println!(\"Output files don't match!\");\n-                        println!(\"Expected Output:\\n{}\", expected);\n-                        println!(\"Actual Output:\\n{}\", output);\n-                    } else {\n-                        let mut diff = Command::new(\"diff\");\n-                        diff.arg(\"-u\");\n-                        diff.arg(res_path);\n-                        diff.arg(expected_path);\n-                        spawn_and_wait(diff);\n-                    }\n-\n-                    std::process::exit(1);\n+            let input =\n+                fs::read_to_string(REGEX.source_dir().join(\"examples\").join(\"regexdna-input.txt\"))\n+                    .unwrap();\n+            let expected_path = REGEX.source_dir().join(\"examples\").join(\"regexdna-output.txt\");\n+            let expected = fs::read_to_string(&expected_path).unwrap();\n+\n+            let output = spawn_and_wait_with_input(run_cmd, input);\n+            // Make sure `[codegen mono items] start` doesn't poison the diff\n+            let output = output\n+                .lines()\n+                .filter(|line| !line.contains(\"codegen mono items\"))\n+                .chain(Some(\"\")) // This just adds the trailing newline\n+                .collect::<Vec<&str>>()\n+                .join(\"\\r\\n\");\n+\n+            let output_matches = expected.lines().eq(output.lines());\n+            if !output_matches {\n+                let res_path = REGEX.source_dir().join(\"res.txt\");\n+                fs::write(&res_path, &output).unwrap();\n+\n+                if cfg!(windows) {\n+                    println!(\"Output files don't match!\");\n+                    println!(\"Expected Output:\\n{}\", expected);\n+                    println!(\"Actual Output:\\n{}\", output);\n+                } else {\n+                    let mut diff = Command::new(\"diff\");\n+                    diff.arg(\"-u\");\n+                    diff.arg(res_path);\n+                    diff.arg(expected_path);\n+                    spawn_and_wait(diff);\n                 }\n+\n+                std::process::exit(1);\n             }\n-        });\n+        }\n     }),\n     TestCase::new(\"test.regex\", &|runner| {\n-        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-\n-            // newer aho_corasick versions throw a deprecation warning\n-            let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n-\n-            if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command(\n-                    \"test\",\n-                    [\n-                        \"--tests\",\n-                        \"--\",\n-                        \"--exclude-should-panic\",\n-                        \"--test-threads\",\n-                        \"1\",\n-                        \"-Zunstable-options\",\n-                        \"-q\",\n-                    ],\n-                );\n-                run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n-                spawn_and_wait(run_cmd);\n-            } else {\n-                eprintln!(\"Cross-Compiling: Not running tests\");\n-                let mut build_cmd =\n-                    runner.cargo_command(\"build\", [\"--tests\", \"--target\", &runner.target_triple]);\n-                build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n-                spawn_and_wait(build_cmd);\n-            }\n-        });\n+        spawn_and_wait(REGEX.clean(&runner.host_compiler.cargo));\n+\n+        // newer aho_corasick versions throw a deprecation warning\n+        let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.target_compiler.rustflags);\n+\n+        if runner.is_native {\n+            let mut run_cmd = REGEX.test(&runner.target_compiler);\n+            run_cmd.args([\n+                \"--tests\",\n+                \"--\",\n+                \"--exclude-should-panic\",\n+                \"--test-threads\",\n+                \"1\",\n+                \"-Zunstable-options\",\n+                \"-q\",\n+            ]);\n+            run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n+            spawn_and_wait(run_cmd);\n+        } else {\n+            eprintln!(\"Cross-Compiling: Not running tests\");\n+            let mut build_cmd = REGEX.build(&runner.target_compiler);\n+            build_cmd.arg(\"--tests\");\n+            build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n+            spawn_and_wait(build_cmd);\n+        }\n     }),\n     TestCase::new(\"test.portable-simd\", &|runner| {\n-        runner.in_dir(prepare::PORTABLE_SIMD.source_dir(), |runner| {\n-            runner.run_cargo(\"clean\", []);\n-            runner.run_cargo(\"build\", [\"--all-targets\", \"--target\", &runner.target_triple]);\n+        spawn_and_wait(PORTABLE_SIMD.clean(&runner.host_compiler.cargo));\n \n-            if runner.host_triple == runner.target_triple {\n-                runner.run_cargo(\"test\", [\"-q\"]);\n-            }\n-        });\n+        let mut build_cmd = PORTABLE_SIMD.build(&runner.target_compiler);\n+        build_cmd.arg(\"--all-targets\");\n+        spawn_and_wait(build_cmd);\n+\n+        if runner.is_native {\n+            let mut test_cmd = PORTABLE_SIMD.test(&runner.target_compiler);\n+            test_cmd.arg(\"-q\");\n+            spawn_and_wait(test_cmd);\n+        }\n     }),\n ];\n \n@@ -442,13 +483,11 @@ pub(crate) fn run_tests(\n }\n \n struct TestRunner {\n-    root_dir: PathBuf,\n     out_dir: PathBuf,\n+    is_native: bool,\n     jit_supported: bool,\n-    rust_flags: String,\n-    run_wrapper: Vec<String>,\n-    host_triple: String,\n-    target_triple: String,\n+    host_compiler: Compiler,\n+    target_compiler: Compiler,\n }\n \n impl TestRunner {\n@@ -463,19 +502,31 @@ impl TestRunner {\n         let jit_supported =\n             target_triple.contains(\"x86_64\") && is_native && !host_triple.contains(\"windows\");\n \n-        let mut rust_flags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n-        let mut run_wrapper = Vec::new();\n+        let mut rustc_clif = root_dir.clone();\n+        rustc_clif.push(\"build\");\n+        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n+\n+        let mut rustdoc_clif = root_dir.clone();\n+        rustdoc_clif.push(\"build\");\n+        rustdoc_clif.push(get_wrapper_file_name(\"rustdoc-clif\", \"bin\"));\n+\n+        let mut rustflags = env::var(\"RUSTFLAGS\").ok().unwrap_or(\"\".to_string());\n+        let mut runner = vec![];\n \n         if !is_native {\n             match target_triple.as_str() {\n                 \"aarch64-unknown-linux-gnu\" => {\n                     // We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n-                    rust_flags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rust_flags);\n-                    run_wrapper = vec![\"qemu-aarch64\", \"-L\", \"/usr/aarch64-linux-gnu\"];\n+                    rustflags = format!(\"-Clinker=aarch64-linux-gnu-gcc{}\", rustflags);\n+                    runner = vec![\n+                        \"qemu-aarch64\".to_owned(),\n+                        \"-L\".to_owned(),\n+                        \"/usr/aarch64-linux-gnu\".to_owned(),\n+                    ];\n                 }\n                 \"x86_64-pc-windows-gnu\" => {\n                     // We are cross-compiling for Windows. Run tests in wine.\n-                    run_wrapper = vec![\"wine\"];\n+                    runner = vec![\"wine\".to_owned()];\n                 }\n                 _ => {\n                     println!(\"Unknown non-native platform\");\n@@ -484,19 +535,31 @@ impl TestRunner {\n         }\n \n         // FIXME fix `#[linkage = \"extern_weak\"]` without this\n-        if host_triple.contains(\"darwin\") {\n-            rust_flags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rust_flags);\n+        if target_triple.contains(\"darwin\") {\n+            rustflags = format!(\"{} -Clink-arg=-undefined -Clink-arg=dynamic_lookup\", rustflags);\n         }\n \n-        Self {\n-            root_dir,\n-            out_dir,\n-            jit_supported,\n-            rust_flags,\n-            run_wrapper: run_wrapper.iter().map(|s| s.to_string()).collect(),\n-            host_triple,\n-            target_triple,\n-        }\n+        let host_compiler = Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: rustc_clif.clone(),\n+            rustdoc: rustdoc_clif.clone(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: host_triple,\n+            runner: vec![],\n+        };\n+\n+        let target_compiler = Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: rustc_clif.clone(),\n+            rustdoc: rustdoc_clif.clone(),\n+            rustflags: rustflags.clone(),\n+            rustdocflags: rustflags,\n+            triple: target_triple,\n+            runner,\n+        };\n+\n+        Self { out_dir, is_native, jit_supported, host_compiler, target_compiler }\n     }\n \n     pub fn run_testsuite(&self, tests: &[TestCase]) {\n@@ -516,25 +579,14 @@ impl TestRunner {\n         }\n     }\n \n-    fn in_dir(&self, new: impl AsRef<Path>, callback: impl FnOnce(&TestRunner)) {\n-        let current = env::current_dir().unwrap();\n-\n-        env::set_current_dir(new).unwrap();\n-        callback(self);\n-        env::set_current_dir(current).unwrap();\n-    }\n-\n+    #[must_use]\n     fn rustc_command<I, S>(&self, args: I) -> Command\n     where\n         I: IntoIterator<Item = S>,\n         S: AsRef<OsStr>,\n     {\n-        let mut rustc_clif = self.root_dir.clone();\n-        rustc_clif.push(\"build\");\n-        rustc_clif.push(get_wrapper_file_name(\"rustc-clif\", \"bin\"));\n-\n-        let mut cmd = Command::new(rustc_clif);\n-        cmd.args(self.rust_flags.split_whitespace());\n+        let mut cmd = Command::new(&self.target_compiler.rustc);\n+        cmd.args(self.target_compiler.rustflags.split_whitespace());\n         cmd.arg(\"-L\");\n         cmd.arg(format!(\"crate={}\", self.out_dir.display()));\n         cmd.arg(\"--out-dir\");\n@@ -559,8 +611,8 @@ impl TestRunner {\n         let mut full_cmd = vec![];\n \n         // Prepend the RUN_WRAPPER's\n-        if !self.run_wrapper.is_empty() {\n-            full_cmd.extend(self.run_wrapper.iter().cloned());\n+        if !self.target_compiler.runner.is_empty() {\n+            full_cmd.extend(self.target_compiler.runner.iter().cloned());\n         }\n \n         full_cmd.push({\n@@ -581,30 +633,4 @@ impl TestRunner {\n \n         spawn_and_wait(cmd);\n     }\n-\n-    fn cargo_command<'a, I>(&self, subcommand: &str, args: I) -> Command\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n-        let mut cargo_clif = self.root_dir.clone();\n-        cargo_clif.push(\"build\");\n-        cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n-\n-        let mut cmd = cargo_command(\n-            cargo_clif,\n-            subcommand,\n-            if subcommand == \"clean\" { None } else { Some(&self.target_triple) },\n-            Path::new(\".\"),\n-        );\n-        cmd.args(args);\n-        cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n-        cmd\n-    }\n-\n-    fn run_cargo<'a, I>(&self, subcommand: &str, args: I)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-    {\n-        spawn_and_wait(self.cargo_command(subcommand, args));\n-    }\n }"}, {"sha": "75869f38118ca6e6dcc768c0b495b8049adcf3a5", "filename": "build_system/utils.rs", "status": "modified", "additions": 142, "deletions": 21, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdae9bab588880339b260c46f468294a76e554b1/build_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_system%2Futils.rs?ref=cdae9bab588880339b260c46f468294a76e554b1", "patch": "@@ -1,35 +1,156 @@\n use std::env;\n use std::fs;\n use std::io::Write;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::{self, Command, Stdio};\n \n-pub(crate) fn cargo_command(\n-    cargo: impl AsRef<Path>,\n-    subcommand: &str,\n-    triple: Option<&str>,\n-    source_dir: &Path,\n-) -> Command {\n-    let mut cmd = Command::new(cargo.as_ref());\n-    cmd.arg(subcommand)\n-        .arg(\"--manifest-path\")\n-        .arg(source_dir.join(\"Cargo.toml\"))\n-        .arg(\"--target-dir\")\n-        .arg(source_dir.join(\"target\"));\n+use super::prepare::GitRepo;\n+use super::rustc_info::{get_cargo_path, get_host_triple, get_rustc_path, get_rustdoc_path};\n+\n+pub(crate) struct Compiler {\n+    pub(crate) cargo: PathBuf,\n+    pub(crate) rustc: PathBuf,\n+    pub(crate) rustdoc: PathBuf,\n+    pub(crate) rustflags: String,\n+    pub(crate) rustdocflags: String,\n+    pub(crate) triple: String,\n+    pub(crate) runner: Vec<String>,\n+}\n+\n+impl Compiler {\n+    pub(crate) fn host() -> Compiler {\n+        Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: get_rustc_path(),\n+            rustdoc: get_rustdoc_path(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple: get_host_triple(),\n+            runner: vec![],\n+        }\n+    }\n+\n+    pub(crate) fn with_triple(triple: String) -> Compiler {\n+        Compiler {\n+            cargo: get_cargo_path(),\n+            rustc: get_rustc_path(),\n+            rustdoc: get_rustdoc_path(),\n+            rustflags: String::new(),\n+            rustdocflags: String::new(),\n+            triple,\n+            runner: vec![],\n+        }\n+    }\n+}\n+\n+enum CargoProjectSource {\n+    Local,\n+    GitRepo(&'static GitRepo),\n+}\n+\n+pub(crate) struct CargoProject {\n+    source: CargoProjectSource,\n+    path: &'static str,\n+}\n+\n+impl CargoProject {\n+    pub(crate) const fn local(path: &'static str) -> CargoProject {\n+        CargoProject { source: CargoProjectSource::Local, path }\n+    }\n+\n+    pub(crate) const fn git(git_repo: &'static GitRepo, path: &'static str) -> CargoProject {\n+        CargoProject { source: CargoProjectSource::GitRepo(git_repo), path }\n+    }\n+\n+    pub(crate) fn source_dir(&self) -> PathBuf {\n+        match self.source {\n+            CargoProjectSource::Local => std::env::current_dir().unwrap(),\n+            CargoProjectSource::GitRepo(git_repo) => git_repo.source_dir(),\n+        }\n+        .join(self.path)\n+    }\n+\n+    pub(crate) fn manifest_path(&self) -> PathBuf {\n+        self.source_dir().join(\"Cargo.toml\")\n+    }\n \n-    if let Some(triple) = triple {\n-        cmd.arg(\"--target\").arg(triple);\n+    pub(crate) fn target_dir(&self) -> PathBuf {\n+        match self.source {\n+            CargoProjectSource::Local => std::env::current_dir().unwrap(),\n+            CargoProjectSource::GitRepo(git_repo) => git_repo.source_dir(),\n+        }\n+        .join(self.path)\n+        .join(\"target\")\n+    }\n+\n+    fn base_cmd(&self, command: &str, cargo: &Path) -> Command {\n+        let mut cmd = Command::new(cargo);\n+\n+        cmd.arg(command)\n+            .arg(\"--manifest-path\")\n+            .arg(self.manifest_path())\n+            .arg(\"--target-dir\")\n+            .arg(self.target_dir());\n+\n+        cmd\n+    }\n+\n+    fn build_cmd(&self, command: &str, compiler: &Compiler) -> Command {\n+        let mut cmd = self.base_cmd(command, &compiler.cargo);\n+\n+        cmd.arg(\"--target\").arg(&compiler.triple);\n+\n+        cmd.env(\"RUSTC\", &compiler.rustc);\n+        cmd.env(\"RUSTDOC\", &compiler.rustdoc);\n+        cmd.env(\"RUSTFLAGS\", &compiler.rustflags);\n+        cmd.env(\"RUSTDOCFLAGS\", &compiler.rustdocflags);\n+        if !compiler.runner.is_empty() {\n+            cmd.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", compiler.triple.to_uppercase().replace('-', \"_\")),\n+                compiler.runner.join(\" \"),\n+            );\n+        }\n+\n+        cmd\n     }\n \n-    cmd\n+    #[must_use]\n+    pub(crate) fn fetch(&self, cargo: impl AsRef<Path>) -> Command {\n+        let mut cmd = Command::new(cargo.as_ref());\n+\n+        cmd.arg(\"fetch\").arg(\"--manifest-path\").arg(self.manifest_path());\n+\n+        cmd\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn clean(&self, cargo: &Path) -> Command {\n+        self.base_cmd(\"clean\", cargo)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn build(&self, compiler: &Compiler) -> Command {\n+        self.build_cmd(\"build\", compiler)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn test(&self, compiler: &Compiler) -> Command {\n+        self.build_cmd(\"test\", compiler)\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn run(&self, compiler: &Compiler) -> Command {\n+        self.build_cmd(\"run\", compiler)\n+    }\n }\n \n+#[must_use]\n pub(crate) fn hyperfine_command(\n     warmup: u64,\n     runs: u64,\n-    prepare: Option<Command>,\n-    a: Command,\n-    b: Command,\n+    prepare: Option<&str>,\n+    a: &str,\n+    b: &str,\n ) -> Command {\n     let mut bench = Command::new(\"hyperfine\");\n \n@@ -42,10 +163,10 @@ pub(crate) fn hyperfine_command(\n     }\n \n     if let Some(prepare) = prepare {\n-        bench.arg(\"--prepare\").arg(format!(\"{:?}\", prepare));\n+        bench.arg(\"--prepare\").arg(prepare);\n     }\n \n-    bench.arg(format!(\"{:?}\", a)).arg(format!(\"{:?}\", b));\n+    bench.arg(a).arg(b);\n \n     bench\n }"}]}