{"sha": "878aef79dcdf59d19bb8482202dc55e58ceb62ff", "node_id": "C_kwDOAAsO6NoAKDg3OGFlZjc5ZGNkZjU5ZDE5YmI4NDgyMjAyZGM1NWU1OGNlYjYyZmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-20T20:08:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-20T20:08:26Z"}, "message": "Auto merge of #100810 - matthiaskrgr:rollup-xep778s, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #97963 (net listen backlog set to negative on Linux.)\n - #99935 (Reenable disabled early syntax gates as future-incompatibility lints)\n - #100129 (add miri-test-libstd support to libstd)\n - #100500 (Ban references to `Self` in trait object substs for projection predicates too.)\n - #100636 (Revert \"Revert \"Allow dynamic linking for iOS/tvOS targets.\"\")\n - #100718 ([rustdoc] Fix item info display)\n - #100769 (Suggest adding a reference to a trait assoc item)\n - #100777 (elaborate how revisions work with FileCheck stuff in src/test/codegen)\n - #100796 (Refactor: remove unnecessary string searchings)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8132ee767300cedc76d54a4e3e4e3bb85b891bb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8132ee767300cedc76d54a4e3e4e3bb85b891bb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/878aef79dcdf59d19bb8482202dc55e58ceb62ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/878aef79dcdf59d19bb8482202dc55e58ceb62ff", "html_url": "https://github.com/rust-lang/rust/commit/878aef79dcdf59d19bb8482202dc55e58ceb62ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/878aef79dcdf59d19bb8482202dc55e58ceb62ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48853a361a5ff0e8215301c62f259a26eed7aa72", "url": "https://api.github.com/repos/rust-lang/rust/commits/48853a361a5ff0e8215301c62f259a26eed7aa72", "html_url": "https://github.com/rust-lang/rust/commit/48853a361a5ff0e8215301c62f259a26eed7aa72"}, {"sha": "d793cd266c3163ab5ef8a109098dc409ba690e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d793cd266c3163ab5ef8a109098dc409ba690e8e", "html_url": "https://github.com/rust-lang/rust/commit/d793cd266c3163ab5ef8a109098dc409ba690e8e"}], "stats": {"total": 904, "additions": 754, "deletions": 150}, "files": [{"sha": "68fca08101891e24bbe345afbcc6668612813da7", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -2,10 +2,10 @@ use rustc_ast as ast;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd, VariantData};\n-use rustc_errors::{struct_span_err, Applicability};\n+use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_feature::Features;\n use rustc_feature::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_feature::{Features, GateIssue};\n-use rustc_session::parse::{feature_err, feature_err_issue};\n+use rustc_session::parse::{feature_err, feature_warn};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n@@ -20,9 +20,7 @@ macro_rules! gate_feature_fn {\n         let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n-                .help(help)\n-                .emit();\n+            feature_err(&visitor.sess.parse_sess, name, span, explain).help(help).emit();\n         }\n     }};\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n@@ -31,8 +29,19 @@ macro_rules! gate_feature_fn {\n         let has_feature: bool = has_feature(visitor.features);\n         debug!(\"gate_feature(feature = {:?}, span = {:?}); has? {}\", name, span, has_feature);\n         if !has_feature && !span.allows_unstable($name) {\n-            feature_err_issue(&visitor.sess.parse_sess, name, span, GateIssue::Language, explain)\n-                .emit();\n+            feature_err(&visitor.sess.parse_sess, name, span, explain).emit();\n+        }\n+    }};\n+    (future_incompatible; $visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{\n+        let (visitor, has_feature, span, name, explain) =\n+            (&*$visitor, $has_feature, $span, $name, $explain);\n+        let has_feature: bool = has_feature(visitor.features);\n+        debug!(\n+            \"gate_feature(feature = {:?}, span = {:?}); has? {} (future_incompatible)\",\n+            name, span, has_feature\n+        );\n+        if !has_feature && !span.allows_unstable($name) {\n+            feature_warn(&visitor.sess.parse_sess, name, span, explain);\n         }\n     }};\n }\n@@ -44,6 +53,9 @@ macro_rules! gate_feature_post {\n     ($visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n         gate_feature_fn!($visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n     };\n+    (future_incompatible; $visitor: expr, $feature: ident, $span: expr, $explain: expr) => {\n+        gate_feature_fn!(future_incompatible; $visitor, |x: &Features| x.$feature, $span, sym::$feature, $explain)\n+    };\n }\n \n pub fn check_attribute(attr: &ast::Attribute, sess: &Session, features: &Features) {\n@@ -588,11 +600,10 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         {\n             // When we encounter a statement of the form `foo: Ty = val;`, this will emit a type\n             // ascription error, but the likely intention was to write a `let` statement. (#78907).\n-            feature_err_issue(\n+            feature_err(\n                 &self.sess.parse_sess,\n                 sym::type_ascription,\n                 lhs.span,\n-                GateIssue::Language,\n                 \"type ascription is experimental\",\n             ).span_suggestion_verbose(\n                 lhs.span.shrink_to_lo(),\n@@ -615,15 +626,22 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 );\n             }\n             ast::ExprKind::Type(..) => {\n-                // To avoid noise about type ascription in common syntax errors, only emit if it\n-                // is the *only* error.\n                 if self.sess.parse_sess.span_diagnostic.err_count() == 0 {\n+                    // To avoid noise about type ascription in common syntax errors,\n+                    // only emit if it is the *only* error.\n                     gate_feature_post!(\n                         &self,\n                         type_ascription,\n                         e.span,\n                         \"type ascription is experimental\"\n                     );\n+                } else {\n+                    // And if it isn't, cancel the early-pass warning.\n+                    self.sess\n+                        .parse_sess\n+                        .span_diagnostic\n+                        .steal_diagnostic(e.span, StashKey::EarlySyntaxWarning)\n+                        .map(|err| err.cancel());\n                 }\n             }\n             ast::ExprKind::TryBlock(_) => {\n@@ -789,14 +807,12 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded).\n+    // We emit an early future-incompatible warning for these.\n+    // New syntax gates should go above here to get a hard error gate.\n     macro_rules! gate_all {\n         ($gate:ident, $msg:literal) => {\n-            // FIXME(eddyb) do something more useful than always\n-            // disabling these uses of early feature-gatings.\n-            if false {\n-                for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n-                    gate_feature_post!(&visitor, $gate, *span, $msg);\n-                }\n+            for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n+                gate_feature_post!(future_incompatible; &visitor, $gate, *span, $msg);\n             }\n         };\n     }\n@@ -809,11 +825,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n     gate_all!(label_break_value, \"labels on blocks are unstable\");\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n-    // To avoid noise about type ascription in common syntax errors,\n-    // only emit if it is the *only* error. (Also check it last.)\n-    if sess.parse_sess.span_diagnostic.err_count() == 0 {\n-        gate_all!(type_ascription, \"type ascription is experimental\");\n-    }\n+    gate_all!(type_ascription, \"type ascription is experimental\");\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "18e84b70b1b10335262f514f3115db91274b2938", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -459,6 +459,7 @@ struct HandlerInner {\n pub enum StashKey {\n     ItemNoType,\n     UnderscoreForArrayLengths,\n+    EarlySyntaxWarning,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -626,19 +627,13 @@ impl Handler {\n     /// Stash a given diagnostic with the given `Span` and `StashKey` as the key for later stealing.\n     pub fn stash_diagnostic(&self, span: Span, key: StashKey, diag: Diagnostic) {\n         let mut inner = self.inner.borrow_mut();\n-        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n-        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n-        // See the PR for a discussion.\n-        inner.stashed_diagnostics.insert((span, key), diag);\n+        inner.stash((span, key), diag);\n     }\n \n     /// Steal a previously stashed diagnostic with the given `Span` and `StashKey` as the key.\n     pub fn steal_diagnostic(&self, span: Span, key: StashKey) -> Option<DiagnosticBuilder<'_, ()>> {\n-        self.inner\n-            .borrow_mut()\n-            .stashed_diagnostics\n-            .remove(&(span, key))\n-            .map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n+        let mut inner = self.inner.borrow_mut();\n+        inner.steal((span, key)).map(|diag| DiagnosticBuilder::new_diagnostic(self, diag))\n     }\n \n     /// Emit all stashed diagnostics.\n@@ -1106,13 +1101,31 @@ impl HandlerInner {\n \n     /// Emit all stashed diagnostics.\n     fn emit_stashed_diagnostics(&mut self) -> Option<ErrorGuaranteed> {\n+        let has_errors = self.has_errors();\n         let diags = self.stashed_diagnostics.drain(..).map(|x| x.1).collect::<Vec<_>>();\n         let mut reported = None;\n         for mut diag in diags {\n+            // Decrement the count tracking the stash; emitting will increment it.\n             if diag.is_error() {\n-                reported = Some(ErrorGuaranteed(()));\n+                if matches!(diag.level, Level::Error { lint: true }) {\n+                    self.lint_err_count -= 1;\n+                } else {\n+                    self.err_count -= 1;\n+                }\n+            } else {\n+                if diag.is_force_warn() {\n+                    self.warn_count -= 1;\n+                } else {\n+                    // Unless they're forced, don't flush stashed warnings when\n+                    // there are errors, to avoid causing warning overload. The\n+                    // stash would've been stolen already if it were important.\n+                    if has_errors {\n+                        continue;\n+                    }\n+                }\n             }\n-            self.emit_diagnostic(&mut diag);\n+            let reported_this = self.emit_diagnostic(&mut diag);\n+            reported = reported.or(reported_this);\n         }\n         reported\n     }\n@@ -1302,9 +1315,47 @@ impl HandlerInner {\n         }\n     }\n \n+    fn stash(&mut self, key: (Span, StashKey), diagnostic: Diagnostic) {\n+        // Track the diagnostic for counts, but don't panic-if-treat-err-as-bug\n+        // yet; that happens when we actually emit the diagnostic.\n+        if diagnostic.is_error() {\n+            if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                self.lint_err_count += 1;\n+            } else {\n+                self.err_count += 1;\n+            }\n+        } else {\n+            // Warnings are only automatically flushed if they're forced.\n+            if diagnostic.is_force_warn() {\n+                self.warn_count += 1;\n+            }\n+        }\n+\n+        // FIXME(Centril, #69537): Consider reintroducing panic on overwriting a stashed diagnostic\n+        // if/when we have a more robust macro-friendly replacement for `(span, key)` as a key.\n+        // See the PR for a discussion.\n+        self.stashed_diagnostics.insert(key, diagnostic);\n+    }\n+\n+    fn steal(&mut self, key: (Span, StashKey)) -> Option<Diagnostic> {\n+        let diagnostic = self.stashed_diagnostics.remove(&key)?;\n+        if diagnostic.is_error() {\n+            if matches!(diagnostic.level, Level::Error { lint: true }) {\n+                self.lint_err_count -= 1;\n+            } else {\n+                self.err_count -= 1;\n+            }\n+        } else {\n+            if diagnostic.is_force_warn() {\n+                self.warn_count -= 1;\n+            }\n+        }\n+        Some(diagnostic)\n+    }\n+\n     #[inline]\n     fn err_count(&self) -> usize {\n-        self.err_count + self.stashed_diagnostics.len()\n+        self.err_count\n     }\n \n     fn has_errors(&self) -> bool {"}, {"sha": "95e34da734d6ad9012212ad3ff4ae256dd17483a", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -3212,6 +3212,56 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `unstable_syntax_pre_expansion` lint detects the use of unstable\n+    /// syntax that is discarded during attribute expansion.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[cfg(FALSE)]\n+    /// macro foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The input to active attributes such as `#[cfg]` or procedural macro\n+    /// attributes is required to be valid syntax. Previously, the compiler only\n+    /// gated the use of unstable syntax features after resolving `#[cfg]` gates\n+    /// and expanding procedural macros.\n+    ///\n+    /// To avoid relying on unstable syntax, move the use of unstable syntax\n+    /// into a position where the compiler does not parse the syntax, such as a\n+    /// functionlike macro.\n+    ///\n+    /// ```rust\n+    /// # #![deny(unstable_syntax_pre_expansion)]\n+    ///\n+    /// macro_rules! identity {\n+    ///    ( $($tokens:tt)* ) => { $($tokens)* }\n+    /// }\n+    ///\n+    /// #[cfg(FALSE)]\n+    /// identity! {\n+    ///    macro foo() {}\n+    /// }\n+    /// ```\n+    ///\n+    /// This is a [future-incompatible] lint to transition this\n+    /// to a hard error in the future. See [issue #65860] for more details.\n+    ///\n+    /// [issue #65860]: https://github.com/rust-lang/rust/issues/65860\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    pub UNSTABLE_SYNTAX_PRE_EXPANSION,\n+    Warn,\n+    \"unstable syntax can change at any point in the future, causing a hard error!\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #65860 <https://github.com/rust-lang/rust/issues/65860>\",\n+    };\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -3280,6 +3330,7 @@ declare_lint_pass! {\n         POINTER_STRUCTURAL_MATCH,\n         NONTRIVIAL_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n+        UNSTABLE_SYNTAX_PRE_EXPANSION,\n         INLINE_NO_SANITIZE,\n         BAD_ASM_STYLE,\n         ASM_SUB_REGISTER,"}, {"sha": "9f0886cb2089c1b1b10a5dd013ed298ed94ea479", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -2,15 +2,17 @@\n //! It also serves as an input to the parser itself.\n \n use crate::config::CheckCfg;\n-use crate::lint::{BufferedEarlyLint, BuiltinLintDiagnostics, Lint, LintId};\n+use crate::lint::{\n+    builtin::UNSTABLE_SYNTAX_PRE_EXPANSION, BufferedEarlyLint, BuiltinLintDiagnostics, Lint, LintId,\n+};\n use crate::SessionDiagnostic;\n use rustc_ast::node_id::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n-    error_code, fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder,\n-    DiagnosticMessage, ErrorGuaranteed, MultiSpan,\n+    error_code, fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder, DiagnosticId,\n+    DiagnosticMessage, ErrorGuaranteed, MultiSpan, StashKey,\n };\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n use rustc_span::edition::Edition;\n@@ -101,11 +103,58 @@ pub fn feature_err_issue<'a>(\n     issue: GateIssue,\n     explain: &str,\n ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n+    let span = span.into();\n+\n+    // Cancel an earlier warning for this same error, if it exists.\n+    if let Some(span) = span.primary_span() {\n+        sess.span_diagnostic\n+            .steal_diagnostic(span, StashKey::EarlySyntaxWarning)\n+            .map(|err| err.cancel());\n+    }\n+\n     let mut err = sess.span_diagnostic.struct_span_err_with_code(span, explain, error_code!(E0658));\n     add_feature_diagnostics_for_issue(&mut err, sess, feature, issue);\n     err\n }\n \n+/// Construct a future incompatibility diagnostic for a feature gate.\n+///\n+/// This diagnostic is only a warning and *does not cause compilation to fail*.\n+pub fn feature_warn<'a>(sess: &'a ParseSess, feature: Symbol, span: Span, explain: &str) {\n+    feature_warn_issue(sess, feature, span, GateIssue::Language, explain);\n+}\n+\n+/// Construct a future incompatibility diagnostic for a feature gate.\n+///\n+/// This diagnostic is only a warning and *does not cause compilation to fail*.\n+///\n+/// This variant allows you to control whether it is a library or language feature.\n+/// Almost always, you want to use this for a language feature. If so, prefer `feature_warn`.\n+pub fn feature_warn_issue<'a>(\n+    sess: &'a ParseSess,\n+    feature: Symbol,\n+    span: Span,\n+    issue: GateIssue,\n+    explain: &str,\n+) {\n+    let mut err = sess.span_diagnostic.struct_span_warn(span, explain);\n+    add_feature_diagnostics_for_issue(&mut err, sess, feature, issue);\n+\n+    // Decorate this as a future-incompatibility lint as in rustc_middle::lint::struct_lint_level\n+    let lint = UNSTABLE_SYNTAX_PRE_EXPANSION;\n+    let future_incompatible = lint.future_incompatible.as_ref().unwrap();\n+    err.code(DiagnosticId::Lint {\n+        name: lint.name_lower(),\n+        has_future_breakage: false,\n+        is_force_warn: false,\n+    });\n+    err.warn(lint.desc);\n+    err.note(format!(\"for more information, see {}\", future_incompatible.reference));\n+\n+    // A later feature_err call can steal and cancel this warning.\n+    err.stash(span, StashKey::EarlySyntaxWarning);\n+}\n+\n /// Adds the diagnostics for a feature to an existing error.\n pub fn add_feature_diagnostics<'a>(err: &mut Diagnostic, sess: &'a ParseSess, feature: Symbol) {\n     add_feature_diagnostics_for_issue(err, sess, feature, GateIssue::Language);"}, {"sha": "49e302676a7b16d413fe42f959d090b20cec31a0", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -65,7 +65,6 @@ pub fn opts(os: &'static str, arch: Arch) -> TargetOptions {\n     TargetOptions {\n         abi: target_abi(arch).into(),\n         cpu: target_cpu(arch).into(),\n-        dynamic_linking: false,\n         link_env_remove: link_env_remove(arch),\n         has_thread_local: false,\n         ..super::apple_base::opts(os, target_arch_name(arch), target_abi(arch))"}, {"sha": "0d279069694a90ecf197a7ee03342a4c98e62415", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -671,7 +671,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         // It only make sense when suggesting dereferences for arguments\n-        let ObligationCauseCode::FunctionArgumentObligation { .. } = obligation.cause.code() else {\n+        let ObligationCauseCode::FunctionArgumentObligation { arg_hir_id, .. } = obligation.cause.code() else {\n             return false;\n         };\n         let param_env = obligation.param_env;\n@@ -702,19 +702,22 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n                 }) {\n                     if steps > 0 {\n-                        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                            // Don't care about `&mut` because `DerefMut` is used less\n-                            // often and user will not expect autoderef happens.\n-                            if src.starts_with('&') && !src.starts_with(\"&mut \") {\n-                                let derefs = \"*\".repeat(steps);\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"consider dereferencing here\",\n-                                    format!(\"&{}{}\", derefs, &src[1..]),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                                return true;\n-                            }\n+                        // Don't care about `&mut` because `DerefMut` is used less\n+                        // often and user will not expect autoderef happens.\n+                        if let Some(hir::Node::Expr(hir::Expr {\n+                            kind:\n+                                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, expr),\n+                            ..\n+                        })) = self.tcx.hir().find(*arg_hir_id)\n+                        {\n+                            let derefs = \"*\".repeat(steps);\n+                            err.span_suggestion_verbose(\n+                                expr.span.shrink_to_lo(),\n+                                \"consider dereferencing here\",\n+                                derefs,\n+                                Applicability::MachineApplicable,\n+                            );\n+                            return true;\n                         }\n                     }\n                 } else if real_trait_pred != trait_pred {\n@@ -882,6 +885,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             obligation.cause.code()\n         {\n             &parent_code\n+        } else if let ObligationCauseCode::ItemObligation(_) = obligation.cause.code() {\n+            obligation.cause.code()\n         } else if let ExpnKind::Desugaring(DesugaringKind::ForLoop) =\n             span.ctxt().outer_expn_data().kind\n         {\n@@ -930,10 +935,25 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.mk_trait_obligation_with_new_self_ty(param_env, trait_pred_and_new_ty);\n                     self.predicate_must_hold_modulo_regions(&obligation)\n                 };\n-                let imm_result = mk_result(trait_pred_and_imm_ref);\n-                let mut_result = mk_result(trait_pred_and_mut_ref);\n+                let imm_ref_self_ty_satisfies_pred = mk_result(trait_pred_and_imm_ref);\n+                let mut_ref_self_ty_satisfies_pred = mk_result(trait_pred_and_mut_ref);\n+\n+                let (ref_inner_ty_satisfies_pred, ref_inner_ty_mut) =\n+                if let ObligationCauseCode::ItemObligation(_) = obligation.cause.code()\n+                    && let ty::Ref(_, ty, mutability) = old_pred.self_ty().skip_binder().kind()\n+                {\n+                    (\n+                        mk_result(old_pred.map_bound(|trait_pred| (trait_pred, *ty))),\n+                        matches!(mutability, hir::Mutability::Mut),\n+                    )\n+                } else {\n+                    (false, false)\n+                };\n \n-                if imm_result || mut_result {\n+                if imm_ref_self_ty_satisfies_pred\n+                    || mut_ref_self_ty_satisfies_pred\n+                    || ref_inner_ty_satisfies_pred\n+                {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         // We have a very specific type of error, where just borrowing this argument\n                         // might solve the problem. In cases like this, the important part is the\n@@ -973,21 +993,22 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // }\n                             // ```\n \n-                            if imm_result && mut_result {\n+                            if imm_ref_self_ty_satisfies_pred && mut_ref_self_ty_satisfies_pred {\n                                 err.span_suggestions(\n                                     span.shrink_to_lo(),\n                                     \"consider borrowing here\",\n                                     [\"&\".to_string(), \"&mut \".to_string()].into_iter(),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             } else {\n+                                let is_mut = mut_ref_self_ty_satisfies_pred || ref_inner_ty_mut;\n                                 err.span_suggestion_verbose(\n                                     span.shrink_to_lo(),\n                                     &format!(\n                                         \"consider{} borrowing here\",\n-                                        if mut_result { \" mutably\" } else { \"\" }\n+                                        if is_mut { \" mutably\" } else { \"\" }\n                                     ),\n-                                    format!(\"&{}\", if mut_result { \"mut \" } else { \"\" }),\n+                                    format!(\"&{}\", if is_mut { \"mut \" } else { \"\" }),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n@@ -1001,7 +1022,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         if let ObligationCauseCode::ImplDerivedObligation(cause) = &*code {\n             try_borrowing(cause.derived.parent_trait_pred, &[])\n         } else if let ObligationCauseCode::BindingObligation(_, _)\n-        | ObligationCauseCode::ItemObligation(_) = code\n+        | ObligationCauseCode::ItemObligation(..) = code\n         {\n             try_borrowing(poly_trait_pred, &never_suggest_borrow)\n         } else {"}, {"sha": "5bb02bc246caf28bf5c05136bf6418a515747109", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -35,7 +35,7 @@ use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECT\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::astconv_object_safety_violations;\n@@ -1453,21 +1453,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .enumerate()\n                     .skip(1) // Remove `Self` for `ExistentialPredicate`.\n                     .map(|(index, arg)| {\n-                        if let ty::GenericArgKind::Type(ty) = arg.unpack() {\n-                            debug!(?ty);\n-                            if ty == dummy_self {\n-                                let param = &generics.params[index];\n-                                missing_type_params.push(param.name);\n-                                tcx.ty_error().into()\n-                            } else if ty.walk().any(|arg| arg == dummy_self.into()) {\n-                                references_self = true;\n-                                tcx.ty_error().into()\n-                            } else {\n-                                arg\n-                            }\n-                        } else {\n-                            arg\n+                        if arg == dummy_self.into() {\n+                            let param = &generics.params[index];\n+                            missing_type_params.push(param.name);\n+                            return tcx.ty_error().into();\n+                        } else if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                            references_self = true;\n+                            return tcx.ty_error().into();\n                         }\n+                        arg\n                     })\n                     .collect();\n                 let substs = tcx.intern_substs(&substs[..]);\n@@ -1506,13 +1500,34 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         });\n \n         let existential_projections = bounds.projection_bounds.iter().map(|(bound, _)| {\n-            bound.map_bound(|b| {\n-                if b.projection_ty.self_ty() != dummy_self {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\"trait_ref_to_existential called on {:?} with non-dummy Self\", b),\n-                    );\n+            bound.map_bound(|mut b| {\n+                assert_eq!(b.projection_ty.self_ty(), dummy_self);\n+\n+                // Like for trait refs, verify that `dummy_self` did not leak inside default type\n+                // parameters.\n+                let references_self = b.projection_ty.substs.iter().skip(1).any(|arg| {\n+                    if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                        return true;\n+                    }\n+                    false\n+                });\n+                if references_self {\n+                    tcx.sess\n+                        .delay_span_bug(span, \"trait object projection bounds reference `Self`\");\n+                    let substs: Vec<_> = b\n+                        .projection_ty\n+                        .substs\n+                        .iter()\n+                        .map(|arg| {\n+                            if arg.walk().any(|arg| arg == dummy_self.into()) {\n+                                return tcx.ty_error().into();\n+                            }\n+                            arg\n+                        })\n+                        .collect();\n+                    b.projection_ty.substs = tcx.intern_substs(&substs[..]);\n                 }\n+\n                 ty::ExistentialProjection::erase_self_ty(tcx, b)\n             })\n         });"}, {"sha": "62fd595572613ff86b61e3e8271d0c5e2e8ae1b3", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -56,10 +56,6 @@\n //! [`Rc`]: rc\n //! [`RefCell`]: core::cell\n \n-// To run liballoc tests without x.py without ending up with two copies of liballoc, Miri needs to be\n-// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n-// rustc itself never sets the feature, so this line has no affect there.\n-#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n #![doc(\n@@ -77,6 +73,10 @@\n ))]\n #![no_std]\n #![needs_allocator]\n+// To run liballoc tests without x.py without ending up with two copies of liballoc, Miri needs to be\n+// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n+// rustc itself never sets the feature, so this line has no affect there.\n+#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n //\n // Lints:\n #![deny(unsafe_op_in_unsafe_fn)]"}, {"sha": "0fae8953aa2c771532d10f90c79b795eb2ef1450", "filename": "library/alloc/src/sync/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -618,3 +618,22 @@ fn test_arc_cyclic_two_refs() {\n     assert_eq!(Arc::strong_count(&two_refs), 3);\n     assert_eq!(Arc::weak_count(&two_refs), 2);\n }\n+\n+/// Test for Arc::drop bug (https://github.com/rust-lang/rust/issues/55005)\n+#[test]\n+#[cfg(miri)] // relies on Stacked Borrows in Miri\n+fn arc_drop_dereferenceable_race() {\n+    // The bug seems to take up to 700 iterations to reproduce with most seeds (tested 0-9).\n+    for _ in 0..750 {\n+        let arc_1 = Arc::new(());\n+        let arc_2 = arc_1.clone();\n+        let thread = thread::spawn(|| drop(arc_2));\n+        // Spin a bit; makes the race more likely to appear\n+        let mut i = 0;\n+        while i < 256 {\n+            i += 1;\n+        }\n+        drop(arc_1);\n+        thread.join().unwrap();\n+    }\n+}"}, {"sha": "cb3032719fa64287bd56c757513bb8a0b0f64922", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -268,53 +268,56 @@ fn test_lots_of_insertions() {\n \n     // Try this a few times to make sure we never screw up the hashmap's\n     // internal state.\n-    for _ in 0..10 {\n+    let loops = if cfg!(miri) { 2 } else { 10 };\n+    for _ in 0..loops {\n         assert!(m.is_empty());\n \n-        for i in 1..1001 {\n+        let count = if cfg!(miri) { 101 } else { 1001 };\n+\n+        for i in 1..count {\n             assert!(m.insert(i, i).is_none());\n \n             for j in 1..=i {\n                 let r = m.get(&j);\n                 assert_eq!(r, Some(&j));\n             }\n \n-            for j in i + 1..1001 {\n+            for j in i + 1..count {\n                 let r = m.get(&j);\n                 assert_eq!(r, None);\n             }\n         }\n \n-        for i in 1001..2001 {\n+        for i in count..(2 * count) {\n             assert!(!m.contains_key(&i));\n         }\n \n         // remove forwards\n-        for i in 1..1001 {\n+        for i in 1..count {\n             assert!(m.remove(&i).is_some());\n \n             for j in 1..=i {\n                 assert!(!m.contains_key(&j));\n             }\n \n-            for j in i + 1..1001 {\n+            for j in i + 1..count {\n                 assert!(m.contains_key(&j));\n             }\n         }\n \n-        for i in 1..1001 {\n+        for i in 1..count {\n             assert!(!m.contains_key(&i));\n         }\n \n-        for i in 1..1001 {\n+        for i in 1..count {\n             assert!(m.insert(i, i).is_none());\n         }\n \n         // remove backwards\n-        for i in (1..1001).rev() {\n+        for i in (1..count).rev() {\n             assert!(m.remove(&i).is_some());\n \n-            for j in i..1001 {\n+            for j in i..count {\n                 assert!(!m.contains_key(&j));\n             }\n \n@@ -817,6 +820,7 @@ fn test_retain() {\n }\n \n #[test]\n+#[cfg_attr(miri, ignore)] // Miri does not support signalling OOM\n #[cfg_attr(target_os = \"android\", ignore)] // Android used in CI has a broken dlmalloc\n fn test_try_reserve() {\n     let mut empty_bytes: HashMap<u8, u8> = HashMap::new();"}, {"sha": "68a19eccc0e7c275073bebce3c84e0549317e7fd", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -94,7 +94,7 @@ fn read_to_end() {\n     assert_eq!(c.read_to_end(&mut v).unwrap(), 1);\n     assert_eq!(v, b\"1\");\n \n-    let cap = 1024 * 1024;\n+    let cap = if cfg!(miri) { 1024 } else { 1024 * 1024 };\n     let data = (0..cap).map(|i| (i / 3) as u8).collect::<Vec<_>>();\n     let mut v = Vec::new();\n     let (a, b) = data.split_at(data.len() / 2);\n@@ -309,6 +309,7 @@ fn chain_zero_length_read_is_not_eof() {\n \n #[bench]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_read_to_end(b: &mut test::Bencher) {\n     b.iter(|| {\n         let mut lr = repeat(1).take(10000000);"}, {"sha": "5029023121fc2c48d4fe348ce95b6c83e7cdd3bf", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -187,6 +187,7 @@\n //! [rust-discord]: https://discord.gg/rust-lang\n //! [array]: prim@array\n //! [slice]: prim@slice\n+\n #![cfg_attr(not(feature = \"restricted-std\"), stable(feature = \"rust1\", since = \"1.0.0\"))]\n #![cfg_attr(feature = \"restricted-std\", unstable(feature = \"restricted_std\", issue = \"none\"))]\n #![doc(\n@@ -201,25 +202,35 @@\n     no_global_oom_handling,\n     not(no_global_oom_handling)\n ))]\n+// To run libstd tests without x.py without ending up with two copies of libstd, Miri needs to be\n+// able to \"empty\" this crate. See <https://github.com/rust-lang/miri-test-libstd/issues/4>.\n+// rustc itself never sets the feature, so this line has no affect there.\n+#![cfg(any(not(feature = \"miri-test-libstd\"), test, doctest))]\n+// miri-test-libstd also prefers to make std use the sysroot versions of the dependencies.\n+#![cfg_attr(feature = \"miri-test-libstd\", feature(rustc_private))]\n // Don't link to std. We are std.\n #![no_std]\n+// Tell the compiler to link to either panic_abort or panic_unwind\n+#![needs_panic_runtime]\n+//\n+// Lints:\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n #![allow(explicit_outlives_requirements)]\n #![allow(unused_lifetimes)]\n-// Tell the compiler to link to either panic_abort or panic_unwind\n-#![needs_panic_runtime]\n+#![deny(rustc::existing_doc_keyword)]\n // Ensure that std can be linked against panic_abort despite compiled with `-C panic=unwind`\n #![deny(ffi_unwind_calls)]\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n+//\n+// Features:\n #![cfg_attr(test, feature(internal_output_capture, print_internals, update_panic_count, rt))]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n-#![deny(rustc::existing_doc_keyword)]\n //\n // Language features:\n #![feature(alloc_error_handler)]"}, {"sha": "3b2601e755a9706f478362b17a2bd4c6e453f772", "filename": "library/std/src/os/unix/net/listener.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -73,9 +73,13 @@ impl UnixListener {\n         unsafe {\n             let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n             let (addr, len) = sockaddr_un(path.as_ref())?;\n+            #[cfg(target_os = \"linux\")]\n+            const backlog: libc::c_int = -1;\n+            #[cfg(not(target_os = \"linux\"))]\n+            const backlog: libc::c_int = 128;\n \n             cvt(libc::bind(inner.as_inner().as_raw_fd(), &addr as *const _ as *const _, len as _))?;\n-            cvt(libc::listen(inner.as_inner().as_raw_fd(), 128))?;\n+            cvt(libc::listen(inner.as_inner().as_raw_fd(), backlog))?;\n \n             Ok(UnixListener(inner))\n         }\n@@ -109,12 +113,16 @@ impl UnixListener {\n     pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixListener> {\n         unsafe {\n             let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            #[cfg(target_os = \"linux\")]\n+            const backlog: libc::c_int = -1;\n+            #[cfg(not(target_os = \"linux\"))]\n+            const backlog: libc::c_int = 128;\n             cvt(libc::bind(\n                 inner.as_raw_fd(),\n                 &socket_addr.addr as *const _ as *const _,\n                 socket_addr.len as _,\n             ))?;\n-            cvt(libc::listen(inner.as_raw_fd(), 128))?;\n+            cvt(libc::listen(inner.as_raw_fd(), backlog))?;\n             Ok(UnixListener(inner))\n         }\n     }"}, {"sha": "dd307022c6d05ce5c55e81c84c642eb6056c8e54", "filename": "library/std/src/path/tests.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -1768,6 +1768,7 @@ fn test_windows_absolute() {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_cmp_fast_path_buf_sort(b: &mut test::Bencher) {\n     let prefix = \"my/home\";\n     let mut paths: Vec<_> =\n@@ -1781,6 +1782,7 @@ fn bench_path_cmp_fast_path_buf_sort(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_cmp_fast_path_long(b: &mut test::Bencher) {\n     let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n     let paths: Vec<_> =\n@@ -1799,6 +1801,7 @@ fn bench_path_cmp_fast_path_long(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_cmp_fast_path_short(b: &mut test::Bencher) {\n     let prefix = \"my/home\";\n     let paths: Vec<_> =\n@@ -1817,6 +1820,7 @@ fn bench_path_cmp_fast_path_short(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_hashset(b: &mut test::Bencher) {\n     let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n     let paths: Vec<_> =\n@@ -1835,6 +1839,7 @@ fn bench_path_hashset(b: &mut test::Bencher) {\n }\n \n #[bench]\n+#[cfg_attr(miri, ignore)] // Miri isn't fast...\n fn bench_path_hashset_miss(b: &mut test::Bencher) {\n     let prefix = \"/my/home/is/my/castle/and/my/castle/has/a/rusty/workbench/\";\n     let paths: Vec<_> ="}, {"sha": "34b2a9a98ac36fa523fc4435fc12db5a8fe99f23", "filename": "library/std/src/sync/mpsc/mpsc_queue/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmpsc_queue%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -13,7 +13,7 @@ fn test_full() {\n #[test]\n fn test() {\n     let nthreads = 8;\n-    let nmsgs = 1000;\n+    let nmsgs = if cfg!(miri) { 100 } else { 1000 };\n     let q = Queue::new();\n     match q.pop() {\n         Empty => {}"}, {"sha": "eb6d5c2cf66d8fc71a850d05646c1706916dfbbc", "filename": "library/std/src/sync/mpsc/spsc_queue/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fspsc_queue%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -77,12 +77,13 @@ fn stress() {\n     }\n \n     unsafe fn stress_bound(bound: usize) {\n+        let count = if cfg!(miri) { 1000 } else { 100000 };\n         let q = Arc::new(Queue::with_additions(bound, (), ()));\n \n         let (tx, rx) = channel();\n         let q2 = q.clone();\n         let _t = thread::spawn(move || {\n-            for _ in 0..100000 {\n+            for _ in 0..count {\n                 loop {\n                     match q2.pop() {\n                         Some(1) => break,\n@@ -93,7 +94,7 @@ fn stress() {\n             }\n             tx.send(()).unwrap();\n         });\n-        for _ in 0..100000 {\n+        for _ in 0..count {\n             q.push(1);\n         }\n         rx.recv().unwrap();"}, {"sha": "63c79436974d592cf6bb9a6a6f017e6dc5ea0fb5", "filename": "library/std/src/sync/mpsc/sync_tests.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fsync_tests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -113,23 +113,25 @@ fn chan_gone_concurrent() {\n \n #[test]\n fn stress() {\n+    let count = if cfg!(miri) { 100 } else { 10000 };\n     let (tx, rx) = sync_channel::<i32>(0);\n     thread::spawn(move || {\n-        for _ in 0..10000 {\n+        for _ in 0..count {\n             tx.send(1).unwrap();\n         }\n     });\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n }\n \n #[test]\n fn stress_recv_timeout_two_threads() {\n+    let count = if cfg!(miri) { 100 } else { 10000 };\n     let (tx, rx) = sync_channel::<i32>(0);\n \n     thread::spawn(move || {\n-        for _ in 0..10000 {\n+        for _ in 0..count {\n             tx.send(1).unwrap();\n         }\n     });\n@@ -146,12 +148,12 @@ fn stress_recv_timeout_two_threads() {\n         }\n     }\n \n-    assert_eq!(recv_count, 10000);\n+    assert_eq!(recv_count, count);\n }\n \n #[test]\n fn stress_recv_timeout_shared() {\n-    const AMT: u32 = 1000;\n+    const AMT: u32 = if cfg!(miri) { 100 } else { 1000 };\n     const NTHREADS: u32 = 8;\n     let (tx, rx) = sync_channel::<i32>(0);\n     let (dtx, drx) = sync_channel::<()>(0);\n@@ -191,7 +193,7 @@ fn stress_recv_timeout_shared() {\n \n #[test]\n fn stress_shared() {\n-    const AMT: u32 = 1000;\n+    const AMT: u32 = if cfg!(miri) { 100 } else { 1000 };\n     const NTHREADS: u32 = 8;\n     let (tx, rx) = sync_channel::<i32>(0);\n     let (dtx, drx) = sync_channel::<()>(0);\n@@ -438,12 +440,13 @@ fn stream_send_recv_stress() {\n \n #[test]\n fn recv_a_lot() {\n+    let count = if cfg!(miri) { 1000 } else { 10000 };\n     // Regression test that we don't run out of stack in scheduler context\n-    let (tx, rx) = sync_channel(10000);\n-    for _ in 0..10000 {\n+    let (tx, rx) = sync_channel(count);\n+    for _ in 0..count {\n         tx.send(()).unwrap();\n     }\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         rx.recv().unwrap();\n     }\n }"}, {"sha": "f6d0796f604fa9c2a4aa3ad65a202fa9d491a932", "filename": "library/std/src/sync/mpsc/tests.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -120,21 +120,22 @@ fn chan_gone_concurrent() {\n \n #[test]\n fn stress() {\n+    let count = if cfg!(miri) { 100 } else { 10000 };\n     let (tx, rx) = channel::<i32>();\n     let t = thread::spawn(move || {\n-        for _ in 0..10000 {\n+        for _ in 0..count {\n             tx.send(1).unwrap();\n         }\n     });\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n     t.join().ok().expect(\"thread panicked\");\n }\n \n #[test]\n fn stress_shared() {\n-    const AMT: u32 = 10000;\n+    const AMT: u32 = if cfg!(miri) { 100 } else { 10000 };\n     const NTHREADS: u32 = 8;\n     let (tx, rx) = channel::<i32>();\n \n@@ -504,12 +505,13 @@ fn very_long_recv_timeout_wont_panic() {\n \n #[test]\n fn recv_a_lot() {\n+    let count = if cfg!(miri) { 1000 } else { 10000 };\n     // Regression test that we don't run out of stack in scheduler context\n     let (tx, rx) = channel();\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         tx.send(()).unwrap();\n     }\n-    for _ in 0..10000 {\n+    for _ in 0..count {\n         rx.recv().unwrap();\n     }\n }"}, {"sha": "b5b3ad9898edbd0e8cbfb43ffb74f8afd92c1be8", "filename": "library/std/src/sync/rwlock/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Frwlock%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -19,7 +19,7 @@ fn smoke() {\n #[test]\n fn frob() {\n     const N: u32 = 10;\n-    const M: usize = 1000;\n+    const M: usize = if cfg!(miri) { 100 } else { 1000 };\n \n     let r = Arc::new(RwLock::new(()));\n "}, {"sha": "f38d2fd3d704e142c2cf25c2e30aafeb13e2ddf3", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -829,6 +829,7 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     )))]\n+    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n     }\n@@ -840,6 +841,7 @@ impl DirEntry {\n         target_os = \"fuchsia\",\n         target_os = \"redox\"\n     ))]\n+    #[cfg_attr(miri, allow(unused))]\n     fn name_cstr(&self) -> &CStr {\n         &self.name\n     }"}, {"sha": "130e47c8d44f09e0e8434089875124bf886c4fa9", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -329,3 +329,22 @@ fn test_scoped_threads_nll() {\n     let x = 42_u8;\n     foo(&x);\n }\n+\n+// Regression test for https://github.com/rust-lang/rust/issues/98498.\n+#[test]\n+#[cfg(miri)] // relies on Miri's data race detector\n+fn scope_join_race() {\n+    for _ in 0..100 {\n+        let a_bool = AtomicBool::new(false);\n+\n+        thread::scope(|s| {\n+            for _ in 0..5 {\n+                s.spawn(|| a_bool.load(Ordering::Relaxed));\n+            }\n+\n+            for _ in 0..5 {\n+                s.spawn(|| a_bool.load(Ordering::Relaxed));\n+            }\n+        });\n+    }\n+}"}, {"sha": "6229556c85fee926f0535f3d3867c9b99b808bf3", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -31,7 +31,8 @@ fn instant_monotonic_concurrent() -> crate::thread::Result<()> {\n         .map(|_| {\n             crate::thread::spawn(|| {\n                 let mut old = Instant::now();\n-                for _ in 0..5_000_000 {\n+                let count = if cfg!(miri) { 1_000 } else { 5_000_000 };\n+                for _ in 0..count {\n                     let new = Instant::now();\n                     assert!(new >= old);\n                     old = new;"}, {"sha": "2b66ab22475d4595c51712d9afa5573f8f20e29d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -569,7 +569,10 @@ fn short_item_info(\n             message.push_str(&format!(\": {}\", html.into_string()));\n         }\n         extra_info.push(format!(\n-            \"<div class=\\\"stab deprecated\\\"><span class=\\\"emoji\\\">\ud83d\udc4e</span> {}</div>\",\n+            \"<div class=\\\"stab deprecated\\\">\\\n+                 <span class=\\\"emoji\\\">\ud83d\udc4e</span>\\\n+                 <span>{}</span>\\\n+             </div>\",\n             message,\n         ));\n     }\n@@ -582,8 +585,9 @@ fn short_item_info(\n         .filter(|stab| stab.feature != sym::rustc_private)\n         .map(|stab| (stab.level, stab.feature))\n     {\n-        let mut message =\n-            \"<span class=\\\"emoji\\\">\ud83d\udd2c</span> This is a nightly-only experimental API.\".to_owned();\n+        let mut message = \"<span class=\\\"emoji\\\">\ud83d\udd2c</span>\\\n+             <span>This is a nightly-only experimental API.\"\n+            .to_owned();\n \n         let mut feature = format!(\"<code>{}</code>\", Escape(feature.as_str()));\n         if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, issue) {\n@@ -594,7 +598,7 @@ fn short_item_info(\n             ));\n         }\n \n-        message.push_str(&format!(\" ({})\", feature));\n+        message.push_str(&format!(\" ({})</span>\", feature));\n \n         extra_info.push(format!(\"<div class=\\\"stab unstable\\\">{}</div>\", message));\n     }"}, {"sha": "b1fa5e7d86de692f821f45762e1d9ab62b91a383", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -1164,6 +1164,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \n .stab .emoji {\n \tfont-size: 1.25rem;\n+\tmargin-right: 0.3rem;\n }\n \n /* Black one-pixel outline around emoji shapes */"}, {"sha": "8f2daaafcc77a8cb71a68ad2a4f0a0cadea72f55", "filename": "src/test/codegen/README.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fcodegen%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fcodegen%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2FREADME.md?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -1,2 +1,24 @@\n The files here use the LLVM FileCheck framework, documented at\n <https://llvm.org/docs/CommandGuide/FileCheck.html>.\n+\n+One extension worth noting is the use of revisions as custom prefixes for\n+FileCheck. If your codegen test has different behavior based on the chosen\n+target or different compiler flags that you want to exercise, you can use a\n+revisions annotation, like so:\n+\n+```rust\n+// revisions: aaa bbb\n+// [bbb] compile-flags: --flags-for-bbb\n+```\n+\n+After specifying those variations, you can write different expected, or\n+explicitly *unexpected* output by using `<prefix>-SAME:` and `<prefix>-NOT:`,\n+like so:\n+\n+```rust\n+// CHECK: expected code\n+// aaa-SAME: emitted-only-for-aaa\n+// aaa-NOT:                        emitted-only-for-bbb\n+// bbb-NOT:  emitted-only-for-aaa\n+// bbb-SAME:                       emitted-only-for-bbb\n+```"}, {"sha": "8d2c27cf3d77dc4f40cc75fc9f98cde9c0562cf7", "filename": "src/test/rustdoc/issue-32374.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Frustdoc%2Fissue-32374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Frustdoc%2Fissue-32374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-32374.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -8,20 +8,24 @@\n //      'Experimental'\n // @matches issue_32374/index.html '//*[@class=\"item-right docblock-short\"]/text()' 'Docs'\n \n-// @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]' \\\n-//      '\ud83d\udc4e Deprecated since 1.0.0: text'\n+// @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]/span' '\ud83d\udc4e'\n+// @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]/span' \\\n+//      'Deprecated since 1.0.0: text'\n // @hasraw - '<code>test</code>&nbsp;<a href=\"https://issue_url/32374\">#32374</a>'\n+// @matches issue_32374/struct.T.html '//*[@class=\"stab unstable\"]' '\ud83d\udd2c'\n // @matches issue_32374/struct.T.html '//*[@class=\"stab unstable\"]' \\\n-//      '\ud83d\udd2c This is a nightly-only experimental API. \\(test\\s#32374\\)$'\n+//     'This is a nightly-only experimental API. \\(test\\s#32374\\)$'\n /// Docs\n #[deprecated(since = \"1.0.0\", note = \"text\")]\n #[unstable(feature = \"test\", issue = \"32374\")]\n pub struct T;\n \n+// @has issue_32374/struct.U.html '//*[@class=\"stab deprecated\"]' '\ud83d\udc4e'\n // @has issue_32374/struct.U.html '//*[@class=\"stab deprecated\"]' \\\n-//      '\ud83d\udc4e Deprecated since 1.0.0: deprecated'\n+//     'Deprecated since 1.0.0: deprecated'\n+// @has issue_32374/struct.U.html '//*[@class=\"stab unstable\"]' '\ud83d\udd2c'\n // @has issue_32374/struct.U.html '//*[@class=\"stab unstable\"]' \\\n-//      '\ud83d\udd2c This is a nightly-only experimental API. (test #32374)'\n+//     'This is a nightly-only experimental API. (test #32374)'\n #[deprecated(since = \"1.0.0\", note = \"deprecated\")]\n #[unstable(feature = \"test\", issue = \"32374\", reason = \"unstable\")]\n pub struct U;"}, {"sha": "49f1cba7151efb1f35e476c697727251b19c49b7", "filename": "src/test/ui/feature-gates/soft-syntax-gates-with-errors.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-with-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-with-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-with-errors.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,30 @@\n+// check-fail\n+// This file is used to test the behavior of the early-pass syntax warnings.\n+// If macro syntax is stabilized, replace with a different unstable syntax.\n+\n+macro a() {}\n+//~^ ERROR: `macro` is experimental\n+\n+#[cfg(FALSE)]\n+macro b() {}\n+\n+macro_rules! identity {\n+    ($($x:tt)*) => ($($x)*);\n+}\n+\n+identity! {\n+    macro c() {}\n+    //~^ ERROR: `macro` is experimental\n+}\n+\n+#[cfg(FALSE)]\n+identity! {\n+    macro d() {} // No error\n+}\n+\n+identity! {\n+    #[cfg(FALSE)]\n+    macro e() {}\n+}\n+\n+fn main() {}"}, {"sha": "49550d811ba5201a426450cc4e572ab603dbf219", "filename": "src/test/ui/feature-gates/soft-syntax-gates-with-errors.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-with-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-with-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-with-errors.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: `macro` is experimental\n+  --> $DIR/soft-syntax-gates-with-errors.rs:5:1\n+   |\n+LL | macro a() {}\n+   | ^^^^^^^^^^^^\n+   |\n+   = note: see issue #39412 <https://github.com/rust-lang/rust/issues/39412> for more information\n+   = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n+\n+error[E0658]: `macro` is experimental\n+  --> $DIR/soft-syntax-gates-with-errors.rs:16:5\n+   |\n+LL |     macro c() {}\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: see issue #39412 <https://github.com/rust-lang/rust/issues/39412> for more information\n+   = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ca4ad2320f657401255f3e751ed6fd4f842e4296", "filename": "src/test/ui/feature-gates/soft-syntax-gates-without-errors.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-without-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-without-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-without-errors.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// This file is used to test the behavior of the early-pass syntax warnings.\n+// If macro syntax is stabilized, replace with a different unstable syntax.\n+\n+#[cfg(FALSE)]\n+macro b() {}\n+//~^ WARN: `macro` is experimental\n+//~| WARN: unstable syntax\n+\n+macro_rules! identity {\n+    ($($x:tt)*) => ($($x)*);\n+}\n+\n+#[cfg(FALSE)]\n+identity! {\n+    macro d() {} // No error\n+}\n+\n+identity! {\n+    #[cfg(FALSE)]\n+    macro e() {}\n+    //~^ WARN: `macro` is experimental\n+    //~| WARN: unstable syntax\n+}\n+\n+fn main() {}"}, {"sha": "3d9c22e548710a16102fd9609c5865a871de23e9", "filename": "src/test/ui/feature-gates/soft-syntax-gates-without-errors.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-without-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-without-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fsoft-syntax-gates-without-errors.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,24 @@\n+warning: `macro` is experimental\n+  --> $DIR/soft-syntax-gates-without-errors.rs:6:1\n+   |\n+LL | macro b() {}\n+   | ^^^^^^^^^^^^\n+   |\n+   = note: see issue #39412 <https://github.com/rust-lang/rust/issues/39412> for more information\n+   = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: `macro` is experimental\n+  --> $DIR/soft-syntax-gates-without-errors.rs:21:5\n+   |\n+LL |     macro e() {}\n+   |     ^^^^^^^^^^^^\n+   |\n+   = note: see issue #39412 <https://github.com/rust-lang/rust/issues/39412> for more information\n+   = help: add `#![feature(decl_macro)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "082c1abb8f2f4098571b5c7099d465aeb00021e9", "filename": "src/test/ui/macros/stringify.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fstringify.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -3,11 +3,18 @@\n // compile-flags: --test\n \n #![feature(async_closure)]\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n #![feature(const_trait_impl)]\n+#![feature(decl_macro)]\n #![feature(generators)]\n #![feature(half_open_range_patterns)]\n+#![feature(label_break_value)]\n #![feature(more_qualified_paths)]\n #![feature(raw_ref_op)]\n+#![feature(trait_alias)]\n+#![feature(try_blocks)]\n+#![feature(type_ascription)]\n #![deny(unused_macros)]\n \n macro_rules! stringify_block {"}, {"sha": "dda5c0bb59d2330ba8dca0829503180b0734764b", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -7,7 +7,7 @@ fn main() {}\n \n // Test the `pat` macro fragment parser:\n macro_rules! accept_pat {\n-    ($p:pat) => {}\n+    ($p:pat) => {};\n }\n \n accept_pat!((p | q));\n@@ -21,28 +21,28 @@ accept_pat!([p | q]);\n #[cfg(FALSE)]\n fn or_patterns() {\n     // Top level of `let`:\n-    let (| A | B);\n+    let (A | B);\n     let (A | B);\n     let (A | B): u8;\n     let (A | B) = 0;\n     let (A | B): u8 = 0;\n \n     // Top level of `for`:\n-    for | A | B in 0 {}\n+    for A | B in 0 {}\n     for A | B in 0 {}\n \n     // Top level of `while`:\n-    while let | A | B = 0 {}\n+    while let A | B = 0 {}\n     while let A | B = 0 {}\n \n     // Top level of `if`:\n-    if let | A | B = 0 {}\n+    if let A | B = 0 {}\n     if let A | B = 0 {}\n \n     // Top level of `match` arms:\n     match 0 {\n-        | A | B => {},\n-        A | B => {},\n+        A | B => {}\n+        A | B => {}\n     }\n \n     // Functions:\n@@ -68,6 +68,8 @@ fn or_patterns() {\n \n     // These bind as `(prefix p) | q` as opposed to `prefix (p | q)`:\n     let (box 0 | 1); // Unstable; we *can* change the precedence if we want.\n+                     //~^ WARN box pattern syntax is experimental\n+                     //~| WARN unstable syntax\n     let (&0 | 1);\n     let (&mut 0 | 1);\n     let (x @ 0 | 1);"}, {"sha": "c43fe192a73b86fa7075da79bba804ede79306a9", "filename": "src/test/ui/or-patterns/or-patterns-syntactic-pass.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-patterns-syntactic-pass.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,13 @@\n+warning: box pattern syntax is experimental\n+  --> $DIR/or-patterns-syntactic-pass.rs:70:10\n+   |\n+LL |     let (box 0 | 1); // Unstable; we *can* change the precedence if we want.\n+   |          ^^^^^\n+   |\n+   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n+   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: 1 warning emitted\n+"}, {"sha": "d8346653c25aa01ac3d3e6f039a700bda678dec2", "filename": "src/test/ui/parser/constraints-before-generic-args-syntactic-pass.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -3,7 +3,11 @@\n #[cfg(FALSE)]\n fn syntax() {\n     foo::<T = u8, T: Ord, String>();\n+    //~^ WARN associated type bounds are unstable\n+    //~| WARN unstable syntax\n     foo::<T = u8, 'a, T: Ord>();\n+    //~^ WARN associated type bounds are unstable\n+    //~| WARN unstable syntax\n }\n \n fn main() {}"}, {"sha": "7e843c7f4d006d2acbd5111cd579dbac70f530b4", "filename": "src/test/ui/parser/constraints-before-generic-args-syntactic-pass.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fconstraints-before-generic-args-syntactic-pass.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,24 @@\n+warning: associated type bounds are unstable\n+  --> $DIR/constraints-before-generic-args-syntactic-pass.rs:5:19\n+   |\n+LL |     foo::<T = u8, T: Ord, String>();\n+   |                   ^^^^^^\n+   |\n+   = note: see issue #52662 <https://github.com/rust-lang/rust/issues/52662> for more information\n+   = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: associated type bounds are unstable\n+  --> $DIR/constraints-before-generic-args-syntactic-pass.rs:8:23\n+   |\n+LL |     foo::<T = u8, 'a, T: Ord>();\n+   |                       ^^^^^^\n+   |\n+   = note: see issue #52662 <https://github.com/rust-lang/rust/issues/52662> for more information\n+   = help: add `#![feature(associated_type_bounds)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "4da5a2db76743ddaa01cf60729afc219d57e658a", "filename": "src/test/ui/pattern/rest-pat-syntactic.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -19,6 +19,8 @@ fn rest_patterns() {\n \n     // Box patterns:\n     let box ..;\n+    //~^ WARN box pattern syntax is experimental\n+    //~| WARN unstable syntax\n \n     // In or-patterns:\n     match x {\n@@ -57,7 +59,7 @@ fn rest_patterns() {\n         .. |\n         [\n             (\n-                box ..,\n+                box .., //~ WARN box pattern syntax is experimental\n                 &(..),\n                 &mut ..,\n                 x @ ..\n@@ -67,4 +69,5 @@ fn rest_patterns() {\n         ref mut x @ ..\n         => {}\n     }\n+    //~| WARN unstable syntax\n }"}, {"sha": "37019b7d5ba7a2e93c3a8680d8b0c7775baca893", "filename": "src/test/ui/pattern/rest-pat-syntactic.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Frest-pat-syntactic.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,24 @@\n+warning: box pattern syntax is experimental\n+  --> $DIR/rest-pat-syntactic.rs:21:9\n+   |\n+LL |     let box ..;\n+   |         ^^^^^^\n+   |\n+   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n+   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: box pattern syntax is experimental\n+  --> $DIR/rest-pat-syntactic.rs:62:17\n+   |\n+LL |                 box ..,\n+   |                 ^^^^^^\n+   |\n+   = note: see issue #29641 <https://github.com/rust-lang/rust/issues/29641> for more information\n+   = help: add `#![feature(box_patterns)]` to the crate attributes to enable\n+   = warning: unstable syntax can change at any point in the future, causing a hard error!\n+   = note: for more information, see issue #65860 <https://github.com/rust-lang/rust/issues/65860>\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "31ac556b9447c857a6d928617f1074ac9c842faa", "filename": "src/test/ui/suggestions/many-type-ascription.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fmany-type-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fmany-type-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmany-type-ascription.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let _ = 0: i32; //~ ERROR: type ascription is experimental\n+    let _ = 0: i32; // (error only emitted once)\n+}"}, {"sha": "3706bbae9df9fbd3e38b18efc3908be43b372fbf", "filename": "src/test/ui/suggestions/many-type-ascription.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmany-type-ascription.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: type ascription is experimental\n+  --> $DIR/many-type-ascription.rs:2:13\n+   |\n+LL |     let _ = 0: i32;\n+   |             ^^^^^^\n+   |\n+   = note: see issue #23416 <https://github.com/rust-lang/rust/issues/23416> for more information\n+   = help: add `#![feature(type_ascription)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e9b8a9caa484a6be3c8e9f0ca772725ded05f9bc", "filename": "src/test/ui/suggestions/suggest-adding-reference-to-trait-assoc-item.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.fixed?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+\n+fn foo(foo: &mut usize) {\n+    todo!()\n+}\n+\n+fn bar(bar: &usize) {\n+    todo!()\n+}\n+\n+fn main() {\n+    foo(&mut Default::default()); //~ the trait bound `&mut usize: Default` is not satisfied\n+    bar(&Default::default()); //~ the trait bound `&usize: Default` is not satisfied\n+}"}, {"sha": "5fae21cccef23da3db1d02e7c4fec5d09abfb179", "filename": "src/test/ui/suggestions/suggest-adding-reference-to-trait-assoc-item.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+#![allow(unused_variables)]\n+\n+fn foo(foo: &mut usize) {\n+    todo!()\n+}\n+\n+fn bar(bar: &usize) {\n+    todo!()\n+}\n+\n+fn main() {\n+    foo(Default::default()); //~ the trait bound `&mut usize: Default` is not satisfied\n+    bar(Default::default()); //~ the trait bound `&usize: Default` is not satisfied\n+}"}, {"sha": "b930d22a3915eb39298983424be06de67f585d4a", "filename": "src/test/ui/suggestions/suggest-adding-reference-to-trait-assoc-item.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-adding-reference-to-trait-assoc-item.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,25 @@\n+error[E0277]: the trait bound `&mut usize: Default` is not satisfied\n+  --> $DIR/suggest-adding-reference-to-trait-assoc-item.rs:13:9\n+   |\n+LL |     foo(Default::default());\n+   |         ^^^^^^^^^^^^^^^^ expected an implementor of trait `Default`\n+   |\n+help: consider mutably borrowing here\n+   |\n+LL |     foo(&mut Default::default());\n+   |         ++++\n+\n+error[E0277]: the trait bound `&usize: Default` is not satisfied\n+  --> $DIR/suggest-adding-reference-to-trait-assoc-item.rs:14:9\n+   |\n+LL |     bar(Default::default());\n+   |         ^^^^^^^^^^^^^^^^ expected an implementor of trait `Default`\n+   |\n+help: consider borrowing here\n+   |\n+LL |     bar(&Default::default());\n+   |         +\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "99ab2f3c858b9c6ec6aede6a352778ecc2dbdf1a", "filename": "src/test/ui/suggestions/type-ascription-and-other-error.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-and-other-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-and-other-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-and-other-error.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    not rust; //~ ERROR\n+    let _ = 0: i32; // (error hidden by existing error)\n+    #[cfg(FALSE)]\n+    let _ = 0: i32; // (warning hidden by existing error)\n+}"}, {"sha": "eadf634bb14fd0bd24bed98fc998099474ba48e0", "filename": "src/test/ui/suggestions/type-ascription-and-other-error.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-and-other-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-and-other-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-and-other-error.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,8 @@\n+error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found `rust`\n+  --> $DIR/type-ascription-and-other-error.rs:2:9\n+   |\n+LL |     not rust;\n+   |         ^^^^ expected one of 8 possible tokens\n+\n+error: aborting due to previous error\n+"}, {"sha": "b0de8ccd67847b23018d456d434a35d18de5ad23", "filename": "src/test/ui/traits/alias/self-in-const-generics.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-const-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-const-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-const-generics.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,12 @@\n+#![allow(incomplete_features)]\n+#![feature(generic_const_exprs)]\n+#![feature(trait_alias)]\n+\n+trait Bar<const N: usize> {}\n+\n+trait BB = Bar<{ 2 + 1 }>;\n+\n+fn foo(x: &dyn BB) {}\n+//~^ ERROR the trait alias `BB` cannot be made into an object [E0038]\n+\n+fn main() {}"}, {"sha": "61cc217cfbce60f8d51f1d0ce33fd48d7b6ccaa6", "filename": "src/test/ui/traits/alias/self-in-const-generics.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-const-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-const-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-const-generics.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -0,0 +1,11 @@\n+error[E0038]: the trait alias `BB` cannot be made into an object\n+  --> $DIR/self-in-const-generics.rs:9:16\n+   |\n+LL | fn foo(x: &dyn BB) {}\n+   |                ^^\n+   |\n+   = note: it cannot use `Self` as a type parameter in a supertrait or `where`-clause\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "0bb6335f91e4b249e61f280413d23a7284fa22d6", "filename": "src/test/ui/traits/alias/self-in-generics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-generics.rs?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -1,3 +1,10 @@\n+// astconv uses `FreshTy(0)` as a dummy `Self` type when instanciating trait objects.\n+// This `FreshTy(0)` can leak into substs, causing ICEs in several places.\n+// Using `save-analysis` triggers type-checking `f` that would be normally skipped\n+// as `type_of` emitted an error.\n+//\n+// compile-flags: -Zsave-analysis\n+\n #![feature(trait_alias)]\n \n pub trait SelfInput = Fn(&mut Self);"}, {"sha": "110d60e6e9116127e6f49e82e756d5ab51e53790", "filename": "src/test/ui/traits/alias/self-in-generics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fself-in-generics.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -1,5 +1,5 @@\n error[E0038]: the trait alias `SelfInput` cannot be made into an object\n-  --> $DIR/self-in-generics.rs:5:19\n+  --> $DIR/self-in-generics.rs:12:19\n    |\n LL | pub fn f(_f: &dyn SelfInput) {}\n    |                   ^^^^^^^^^"}, {"sha": "eb2b88059d485e0059be5f736f5e26b96911421f", "filename": "src/test/ui/traits/suggest-deferences/issue-39029.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -2,10 +2,8 @@ error[E0277]: the trait bound `NoToSocketAddrs: ToSocketAddrs` is not satisfied\n   --> $DIR/issue-39029.rs:16:37\n    |\n LL |     let _errors = TcpListener::bind(&bad);\n-   |                   ----------------- ^^^^\n-   |                   |                 |\n-   |                   |                 the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n-   |                   |                 help: consider dereferencing here: `&*bad`\n+   |                   ----------------- ^^^^ the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n+   |                   |\n    |                   required by a bound introduced by this call\n    |\n    = note: required for `&NoToSocketAddrs` to implement `ToSocketAddrs`\n@@ -14,6 +12,10 @@ note: required by a bound in `TcpListener::bind`\n    |\n LL |     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {\n    |                    ^^^^^^^^^^^^^ required by this bound in `TcpListener::bind`\n+help: consider dereferencing here\n+   |\n+LL |     let _errors = TcpListener::bind(&*bad);\n+   |                                      +\n \n error: aborting due to previous error\n "}, {"sha": "e47ae0b65af0e62e07b084173955bb60dd9c3660", "filename": "src/test/ui/traits/suggest-deferences/issue-62530.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-62530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-62530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-62530.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -2,17 +2,19 @@ error[E0277]: the trait bound `&String: SomeTrait` is not satisfied\n   --> $DIR/issue-62530.rs:13:26\n    |\n LL |     takes_type_parameter(&string);  // Error\n-   |     -------------------- ^^^^^^^\n-   |     |                    |\n-   |     |                    the trait `SomeTrait` is not implemented for `&String`\n-   |     |                    help: consider dereferencing here: `&*string`\n+   |     -------------------- ^^^^^^^ the trait `SomeTrait` is not implemented for `&String`\n+   |     |\n    |     required by a bound introduced by this call\n    |\n note: required by a bound in `takes_type_parameter`\n   --> $DIR/issue-62530.rs:4:44\n    |\n LL | fn takes_type_parameter<T>(_x: T) where T: SomeTrait {}\n    |                                            ^^^^^^^^^ required by this bound in `takes_type_parameter`\n+help: consider dereferencing here\n+   |\n+LL |     takes_type_parameter(&*string);  // Error\n+   |                           +\n \n error: aborting due to previous error\n "}, {"sha": "6a4d4b8d5212f0aa472934f06f78f85e4639cdb0", "filename": "src/test/ui/traits/suggest-deferences/multiple-0.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/878aef79dcdf59d19bb8482202dc55e58ceb62ff/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-0.stderr?ref=878aef79dcdf59d19bb8482202dc55e58ceb62ff", "patch": "@@ -2,17 +2,19 @@ error[E0277]: the trait bound `&Baz: Happy` is not satisfied\n   --> $DIR/multiple-0.rs:34:9\n    |\n LL |     foo(&baz);\n-   |     --- ^^^^\n-   |     |   |\n-   |     |   the trait `Happy` is not implemented for `&Baz`\n-   |     |   help: consider dereferencing here: `&***baz`\n+   |     --- ^^^^ the trait `Happy` is not implemented for `&Baz`\n+   |     |\n    |     required by a bound introduced by this call\n    |\n note: required by a bound in `foo`\n   --> $DIR/multiple-0.rs:30:26\n    |\n LL | fn foo<T>(_: T) where T: Happy {}\n    |                          ^^^^^ required by this bound in `foo`\n+help: consider dereferencing here\n+   |\n+LL |     foo(&***baz);\n+   |          +++\n \n error: aborting due to previous error\n "}]}