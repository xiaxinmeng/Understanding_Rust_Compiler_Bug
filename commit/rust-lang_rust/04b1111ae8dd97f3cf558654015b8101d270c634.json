{"sha": "04b1111ae8dd97f3cf558654015b8101d270c634", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YjExMTFhZThkZDk3ZjNjZjU1ODY1NDAxNWI4MTAxZDI3MGM2MzQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T01:49:15Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-16T01:52:47Z"}, "message": "Name index variables consistently.\n\nThose with type `usize` are now called `i`, those with type `NodeIndex`\nare called `index`.", "tree": {"sha": "862eaf82b4ece5f299fd0bbd9df88461c46035b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/862eaf82b4ece5f299fd0bbd9df88461c46035b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b1111ae8dd97f3cf558654015b8101d270c634", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b1111ae8dd97f3cf558654015b8101d270c634", "html_url": "https://github.com/rust-lang/rust/commit/04b1111ae8dd97f3cf558654015b8101d270c634", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b1111ae8dd97f3cf558654015b8101d270c634/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca3766e2e58f462a20922e42c821a37eaf0e13db", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3766e2e58f462a20922e42c821a37eaf0e13db", "html_url": "https://github.com/rust-lang/rust/commit/ca3766e2e58f462a20922e42c821a37eaf0e13db"}], "stats": {"total": 97, "additions": 47, "deletions": 50}, "files": [{"sha": "7ef1953e2d812eb75c3c7b54df9270001c5e4558", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 47, "deletions": 50, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/04b1111ae8dd97f3cf558654015b8101d270c634/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b1111ae8dd97f3cf558654015b8101d270c634/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=04b1111ae8dd97f3cf558654015b8101d270c634", "patch": "@@ -295,14 +295,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n                        obligation, parent, o.get());\n                 let node = &mut self.nodes[o.get().get()];\n-                if let Some(parent) = parent {\n+                if let Some(parent_index) = parent {\n                     // If the node is already in `waiting_cache`, it's already\n                     // been marked with a parent. (It's possible that parent\n                     // has been cleared by `apply_rewrites`, though.) So just\n                     // dump `parent` into `node.dependents`... unless it's\n                     // already in `node.dependents` or `node.parent`.\n-                    if !node.dependents.contains(&parent) && Some(parent) != node.parent {\n-                        node.dependents.push(parent);\n+                    if !node.dependents.contains(&parent_index) &&\n+                       Some(parent_index) != node.parent {\n+                        node.dependents.push(parent_index);\n                     }\n                 }\n                 if let NodeState::Error = node.state.get() {\n@@ -316,9 +317,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                        obligation, parent, self.nodes.len());\n \n                 let obligation_tree_id = match parent {\n-                    Some(p) => {\n-                        let parent_node = &self.nodes[p.get()];\n-                        parent_node.obligation_tree_id\n+                    Some(parent_index) => {\n+                        self.nodes[parent_index.get()].obligation_tree_id\n                     }\n                     None => self.obligation_tree_id_generator.next().unwrap()\n                 };\n@@ -346,9 +346,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for index in 0..self.nodes.len() {\n-            if let NodeState::Pending = self.nodes[index].state.get() {\n-                let backtrace = self.error_at(index);\n+        for i in 0..self.nodes.len() {\n+            if let NodeState::Pending = self.nodes[i].state.get() {\n+                let backtrace = self.error_at(i);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace,\n@@ -393,16 +393,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        for index in 0..self.nodes.len() {\n-            debug!(\"process_obligations: node {} == {:?}\", index, self.nodes[index]);\n+        for i in 0..self.nodes.len() {\n+            debug!(\"process_obligations: node {} == {:?}\", i, self.nodes[i]);\n \n-            let result = match self.nodes[index] {\n+            let result = match self.nodes[i] {\n                 Node { ref state, ref mut obligation, .. } if state.get() == NodeState::Pending =>\n                     processor.process_obligation(obligation),\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n+            debug!(\"process_obligations: node {} got result {:?}\", i, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -411,23 +411,23 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n                     stalled = false;\n-                    self.nodes[index].state.set(NodeState::Success);\n+                    self.nodes[i].state.set(NodeState::Success);\n \n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(NodeIndex::new(index))\n+                            Some(NodeIndex::new(i))\n                         );\n                         if let Err(()) = st {\n                             // error already reported - propagate it\n                             // to our node.\n-                            self.error_at(index);\n+                            self.error_at(i);\n                         }\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n                     stalled = false;\n-                    let backtrace = self.error_at(index);\n+                    let backtrace = self.error_at(i);\n                     errors.push(Error {\n                         error: err,\n                         backtrace,\n@@ -473,15 +473,15 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         debug!(\"process_cycles()\");\n \n-        for index in 0..self.nodes.len() {\n+        for i in 0..self.nodes.len() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n-            let state = self.nodes[index].state.get();\n+            let state = self.nodes[i].state.get();\n             match state {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n-                _ => self.find_cycles_from_node(&mut stack, processor, index),\n+                _ => self.find_cycles_from_node(&mut stack, processor, i),\n             }\n         }\n \n@@ -491,24 +491,22 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.scratch = Some(stack);\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>,\n-                                processor: &mut P, index: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, i: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let node = &self.nodes[index];\n+        let node = &self.nodes[i];\n         let state = node.state.get();\n         match state {\n             NodeState::OnDfsStack => {\n-                let index =\n-                    stack.iter().rposition(|n| *n == index).unwrap();\n-                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n+                let i = stack.iter().rposition(|n| *n == i).unwrap();\n+                processor.process_backedge(stack[i..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n-                stack.push(index);\n-                for dependent in node.parent.iter().chain(node.dependents.iter()) {\n-                    self.find_cycles_from_node(stack, processor, dependent.get());\n+                stack.push(i);\n+                for index in node.parent.iter().chain(node.dependents.iter()) {\n+                    self.find_cycles_from_node(stack, processor, index.get());\n                 }\n                 stack.pop();\n                 node.state.set(NodeState::Done);\n@@ -525,33 +523,32 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&mut self, p: usize) -> Vec<O> {\n+    fn error_at(&mut self, mut i: usize) -> Vec<O> {\n         let mut error_stack = self.scratch.take().unwrap();\n         let mut trace = vec![];\n \n-        let mut n = p;\n         loop {\n-            self.nodes[n].state.set(NodeState::Error);\n-            trace.push(self.nodes[n].obligation.clone());\n-            error_stack.extend(self.nodes[n].dependents.iter().map(|x| x.get()));\n+            let node = &self.nodes[i];\n+            node.state.set(NodeState::Error);\n+            trace.push(node.obligation.clone());\n+            error_stack.extend(node.dependents.iter().map(|index| index.get()));\n \n-            // loop to the parent\n-            match self.nodes[n].parent {\n-                Some(q) => n = q.get(),\n+            // Loop to the parent.\n+            match node.parent {\n+                Some(parent_index) => i = parent_index.get(),\n                 None => break\n             }\n         }\n \n         while let Some(i) = error_stack.pop() {\n-            match self.nodes[i].state.get() {\n+            let node = &self.nodes[i];\n+            match node.state.get() {\n                 NodeState::Error => continue,\n                 _ => self.nodes[i].state.set(NodeState::Error),\n             }\n \n-            let node = &self.nodes[i];\n-\n             error_stack.extend(\n-                node.parent.iter().chain(node.dependents.iter()).map(|x| x.get())\n+                node.parent.iter().chain(node.dependents.iter()).map(|index| index.get())\n             );\n         }\n \n@@ -689,34 +686,34 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &mut self.nodes {\n             if let Some(index) = node.parent {\n-                let new_index = node_rewrites[index.get()];\n-                if new_index >= nodes_len {\n+                let new_i = node_rewrites[index.get()];\n+                if new_i >= nodes_len {\n                     // parent dead due to error\n                     node.parent = None;\n                 } else {\n-                    node.parent = Some(NodeIndex::new(new_index));\n+                    node.parent = Some(NodeIndex::new(new_i));\n                 }\n             }\n \n             let mut i = 0;\n             while i < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[i].get()];\n-                if new_index >= nodes_len {\n+                let new_i = node_rewrites[node.dependents[i].get()];\n+                if new_i >= nodes_len {\n                     node.dependents.swap_remove(i);\n                 } else {\n-                    node.dependents[i] = NodeIndex::new(new_index);\n+                    node.dependents[i] = NodeIndex::new(new_i);\n                     i += 1;\n                 }\n             }\n         }\n \n         let mut kill_list = vec![];\n         for (predicate, index) in &mut self.waiting_cache {\n-            let new_index = node_rewrites[index.get()];\n-            if new_index >= nodes_len {\n+            let new_i = node_rewrites[index.get()];\n+            if new_i >= nodes_len {\n                 kill_list.push(predicate.clone());\n             } else {\n-                *index = NodeIndex::new(new_index);\n+                *index = NodeIndex::new(new_i);\n             }\n         }\n "}]}