{"sha": "e48670c34a3f5ab3fe9defcc61861999f3f14e93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ODY3MGMzNGEzZjVhYjNmZTlkZWZjYzYxODYxOTk5ZjNmMTRlOTM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2021-01-13T02:37:32Z"}, "committer": {"name": "Ryan Levick", "email": "me@ryanlevick.com", "date": "2021-03-03T10:22:56Z"}, "message": "Increase accuracy of lint trigger", "tree": {"sha": "a082d55e96c082b3bf163f7aaecd56c6b4b077bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a082d55e96c082b3bf163f7aaecd56c6b4b077bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e48670c34a3f5ab3fe9defcc61861999f3f14e93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e48670c34a3f5ab3fe9defcc61861999f3f14e93", "html_url": "https://github.com/rust-lang/rust/commit/e48670c34a3f5ab3fe9defcc61861999f3f14e93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e48670c34a3f5ab3fe9defcc61861999f3f14e93/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rylev", "id": 1327285, "node_id": "MDQ6VXNlcjEzMjcyODU=", "avatar_url": "https://avatars.githubusercontent.com/u/1327285?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rylev", "html_url": "https://github.com/rylev", "followers_url": "https://api.github.com/users/rylev/followers", "following_url": "https://api.github.com/users/rylev/following{/other_user}", "gists_url": "https://api.github.com/users/rylev/gists{/gist_id}", "starred_url": "https://api.github.com/users/rylev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rylev/subscriptions", "organizations_url": "https://api.github.com/users/rylev/orgs", "repos_url": "https://api.github.com/users/rylev/repos", "events_url": "https://api.github.com/users/rylev/events{/privacy}", "received_events_url": "https://api.github.com/users/rylev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49f32e0c8e78948210654299a8c19b2e0f0cbfa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/49f32e0c8e78948210654299a8c19b2e0f0cbfa9", "html_url": "https://github.com/rust-lang/rust/commit/49f32e0c8e78948210654299a8c19b2e0f0cbfa9"}], "stats": {"total": 71, "additions": 43, "deletions": 28}, "files": [{"sha": "04d87dc959273e6cccdec92b00915215a3915ccc", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e48670c34a3f5ab3fe9defcc61861999f3f14e93/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48670c34a3f5ab3fe9defcc61861999f3f14e93/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=e48670c34a3f5ab3fe9defcc61861999f3f14e93", "patch": "@@ -62,33 +62,45 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n                         // Resolve the trait method instance\n                         if let Ok(Some(i)) = ty::Instance::resolve(cx.tcx, param_env, did, substs) {\n                             // Check that it implements the noop diagnostic\n-                            if [\n-                                sym::noop_method_borrow,\n-                                sym::noop_method_clone,\n-                                sym::noop_method_deref,\n+                            for (s, peel_ref) in [\n+                                (sym::noop_method_borrow, true),\n+                                (sym::noop_method_clone, false),\n+                                (sym::noop_method_deref, true),\n                             ]\n                             .iter()\n-                            .any(|s| cx.tcx.is_diagnostic_item(*s, i.def_id()))\n                             {\n-                                let method = &call.ident.name;\n-                                let receiver = &elements[0];\n-                                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n-                                let expr_span = expr.span;\n-                                let note = format!(\n-                                    \"the type `{:?}` which `{}` is being called on is the same as the type returned from `{}`, \\\n-                                        so the method call does not do anything and can be removed.\",\n-                                    receiver_ty, method, method\n-                                );\n-\n-                                let span = expr_span.with_lo(receiver.span.hi());\n-                                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+                                if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n                                     let method = &call.ident.name;\n-                                    let message = format!(\"call to `.{}()` on a reference in this situation does nothing\", &method);\n-                                    lint.build(&message)\n-                                        .span_label(span, \"unnecessary method call\")\n-                                        .note(&note)\n-                                        .emit()\n-                                });\n+                                    let receiver = &elements[0];\n+                                    let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+                                    let receiver_ty = match receiver_ty.kind() {\n+                                        // Remove one borrow from the receiver as all the trait methods\n+                                        // we care about here have a `&self` receiver.\n+                                        ty::Ref(_, ty, _) if *peel_ref => ty,\n+                                        _ => receiver_ty,\n+                                    };\n+                                    let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n+                                    if receiver_ty != expr_ty {\n+                                        return;\n+                                    }\n+                                    let expr_span = expr.span;\n+                                    let note = format!(\n+                                        \"the type `{:?}` which `{}` is being called on is the same as \\\n+                                        the type returned from `{}`, so the method call does not do \\\n+                                        anything and can be removed\",\n+                                        receiver_ty, method, method,\n+                                    );\n+\n+                                    let span = expr_span.with_lo(receiver.span.hi());\n+                                    cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+                                        let method = &call.ident.name;\n+                                        let message = format!(\"call to `.{}()` on a reference in this situation does nothing\", &method);\n+                                        lint.build(&message)\n+                                            .span_label(span, \"unnecessary method call\")\n+                                            .note(&note)\n+                                            .emit()\n+                                     });\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "70363a191e9e9e8c9e4364ea04da0eef36ca02f3", "filename": "src/test/ui/lint/noop-method-call.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e48670c34a3f5ab3fe9defcc61861999f3f14e93/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48670c34a3f5ab3fe9defcc61861999f3f14e93/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.rs?ref=e48670c34a3f5ab3fe9defcc61861999f3f14e93", "patch": "@@ -37,6 +37,9 @@ fn main() {\n     let a = &&Foo(1u32);\n     let borrowed: &Foo<u32> = a.borrow();\n     //~^ WARNING call to `.borrow()` on a reference in this situation does nothing\n+\n+    let xs = [\"a\", \"b\", \"c\"];\n+    let _v: Vec<&str> = xs.iter().map(|x| x.clone()).collect(); // ok, but could use `*x` instead\n }\n \n fn generic<T>(foo: &Foo<T>) {"}, {"sha": "316c47975e6de86dd266f2e8228ee580ac9040c7", "filename": "src/test/ui/lint/noop-method-call.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e48670c34a3f5ab3fe9defcc61861999f3f14e93/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e48670c34a3f5ab3fe9defcc61861999f3f14e93/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fnoop-method-call.stderr?ref=e48670c34a3f5ab3fe9defcc61861999f3f14e93", "patch": "@@ -5,31 +5,31 @@ LL |     let foo_clone: &Foo<u32> = foo.clone();\n    |                                   ^^^^^^^^ unnecessary method call\n    |\n    = note: `#[warn(noop_method_call)]` on by default\n-   = note: the type `&Foo<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed.\n+   = note: the type `&Foo<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed\n \n warning: call to `.deref()` on a reference in this situation does nothing\n   --> $DIR/noop-method-call.rs:31:44\n    |\n LL |     let derefed: &DerefExample<u32> = deref.deref();\n    |                                            ^^^^^^^^ unnecessary method call\n    |\n-   = note: the type `&&DerefExample<u32>` which `deref` is being called on is the same as the type returned from `deref`, so the method call does not do anything and can be removed.\n+   = note: the type `&DerefExample<u32>` which `deref` is being called on is the same as the type returned from `deref`, so the method call does not do anything and can be removed\n \n warning: call to `.borrow()` on a reference in this situation does nothing\n   --> $DIR/noop-method-call.rs:38:32\n    |\n LL |     let borrowed: &Foo<u32> = a.borrow();\n    |                                ^^^^^^^^^ unnecessary method call\n    |\n-   = note: the type `&&Foo<u32>` which `borrow` is being called on is the same as the type returned from `borrow`, so the method call does not do anything and can be removed.\n+   = note: the type `&Foo<u32>` which `borrow` is being called on is the same as the type returned from `borrow`, so the method call does not do anything and can be removed\n \n warning: call to `.clone()` on a reference in this situation does nothing\n-  --> $DIR/noop-method-call.rs:47:8\n+  --> $DIR/noop-method-call.rs:50:8\n    |\n LL |     foo.clone();\n    |        ^^^^^^^^ unnecessary method call\n    |\n-   = note: the type `&Foo<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed.\n+   = note: the type `&Foo<u32>` which `clone` is being called on is the same as the type returned from `clone`, so the method call does not do anything and can be removed\n \n warning: 4 warnings emitted\n "}]}