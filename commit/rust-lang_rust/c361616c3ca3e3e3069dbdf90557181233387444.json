{"sha": "c361616c3ca3e3e3069dbdf90557181233387444", "node_id": "C_kwDOAAsO6NoAKGMzNjE2MTZjM2NhM2UzZTMwNjlkYmRmOTA1NTcxODEyMzMzODc0NDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-04T03:37:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-04T03:37:21Z"}, "message": "Auto merge of #106432 - compiler-errors:rollup-lzj0lnp, r=compiler-errors\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104748 (Ensure `lld` is supported with `download-ci-llvm`)\n - #105541 (Simplify some iterator combinators)\n - #106045 (default OOM handler: use non-unwinding panic, to match std handler)\n - #106157 (Don't trim path for `unsafe_op_in_unsafe_fn` lints)\n - #106353 (Reduce spans for `unsafe impl` errors)\n - #106381 (Jsondoclint: Add `--verbose` and `--json-output` options)\n - #106411 (rustdoc: remove legacy font-feature-settings CSS)\n - #106414 (Add cuviper to the review rotation for libs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f2349c433d136fec3ba910e30a55ddcac032894c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2349c433d136fec3ba910e30a55ddcac032894c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c361616c3ca3e3e3069dbdf90557181233387444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c361616c3ca3e3e3069dbdf90557181233387444", "html_url": "https://github.com/rust-lang/rust/commit/c361616c3ca3e3e3069dbdf90557181233387444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c361616c3ca3e3e3069dbdf90557181233387444/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbe82928729c29ea953c95defb81b302dd704fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbe82928729c29ea953c95defb81b302dd704fae", "html_url": "https://github.com/rust-lang/rust/commit/fbe82928729c29ea953c95defb81b302dd704fae"}, {"sha": "1a984435df11fbc69f1f99165a77c6e96357c908", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a984435df11fbc69f1f99165a77c6e96357c908", "html_url": "https://github.com/rust-lang/rust/commit/1a984435df11fbc69f1f99165a77c6e96357c908"}], "stats": {"total": 630, "additions": 328, "deletions": 302}, "files": [{"sha": "117295014e6b85d25f7c1f128188abdc7d76f6c5", "filename": "Cargo.lock", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -597,7 +597,7 @@ checksum = \"23b71c3ce99b7611011217b366d923f1d0a7e07a92bb2dbf1e84508c673ca3bd\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n- \"clap_derive\",\n+ \"clap_derive 3.2.18\",\n  \"clap_lex 0.2.2\",\n  \"indexmap\",\n  \"once_cell\",\n@@ -614,7 +614,9 @@ checksum = \"6bf8832993da70a4c6d13c581f4463c2bdda27b9bf1c5498dc4365543abe6d6f\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n+ \"clap_derive 4.0.13\",\n  \"clap_lex 0.3.0\",\n+ \"once_cell\",\n  \"strsim\",\n  \"termcolor\",\n ]\n@@ -641,6 +643,19 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"clap_derive\"\n+version = \"4.0.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c42f169caba89a7d512b5418b09864543eeb4d497416c917d7137863bd2076ad\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"clap_lex\"\n version = \"0.2.2\"\n@@ -2097,8 +2112,10 @@ name = \"jsondoclint\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n+ \"clap 4.0.15\",\n  \"fs-err\",\n  \"rustdoc-json-types\",\n+ \"serde\",\n  \"serde_json\",\n ]\n "}, {"sha": "50cd13a2ccc8a462b28d35faddb94998e00efa93", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -527,26 +527,21 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // that are *partially* initialized by assigning to a field of an uninitialized\n             // binding. We differentiate between them for more accurate wording here.\n             \"isn't fully initialized\"\n-        } else if spans\n-            .iter()\n-            .filter(|i| {\n-                // We filter these to avoid misleading wording in cases like the following,\n-                // where `x` has an `init`, but it is in the same place we're looking at:\n-                // ```\n-                // let x;\n-                // x += 1;\n-                // ```\n-                !i.contains(span)\n-                    // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n-                        && !visitor\n-                            .errors\n-                            .iter()\n-                            .map(|(sp, _)| *sp)\n-                            .any(|sp| span < sp && !sp.contains(span))\n-            })\n-            .count()\n-            == 0\n-        {\n+        } else if !spans.iter().any(|i| {\n+            // We filter these to avoid misleading wording in cases like the following,\n+            // where `x` has an `init`, but it is in the same place we're looking at:\n+            // ```\n+            // let x;\n+            // x += 1;\n+            // ```\n+            !i.contains(span)\n+            // We filter these to avoid incorrect main message on `match-cfg-fake-edges.rs`\n+            && !visitor\n+                .errors\n+                .iter()\n+                .map(|(sp, _)| *sp)\n+                .any(|sp| span < sp && !sp.contains(span))\n+        }) {\n             show_assign_sugg = true;\n             \"isn't initialized\"\n         } else {"}, {"sha": "567a9814fccbf3dd712e61d39df4d198de855453", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -4,9 +4,9 @@\n \n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n+use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{self as hir, Item, ItemKind, Node};\n use rustc_infer::infer::{\n     error_reporting::nice_region_error::{\n         self, find_anon_type, find_param_with_region, suggest_adding_lifetime_params,\n@@ -291,71 +291,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlives_suggestion.add_suggestion(self);\n     }\n \n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n-        def_id: DefId,\n-        trait_objects: &FxIndexSet<DefId>,\n-    ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.infcx.tcx;\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n-                {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n-                }\n-            }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .next()\n-                        {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n-                    }\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -850,7 +785,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         visitor.visit_ty(param.param_ty);\n \n         let Some((ident, self_ty)) =\n-            self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &visitor.0) else {return};\n+            NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &visitor.0) else { return; };\n \n         self.suggest_constrain_dyn_trait_in_impl(diag, &visitor.0, ident, self_ty);\n     }"}, {"sha": "a92242b2615c1f66b1cfb438c61a0bbf48ad0e97", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1244,7 +1244,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().any(|value| *value == gcc_func) {\n             self.function_call(func, args, funclet)\n         }\n         else {"}, {"sha": "4424b31c0542c65777d80571ebc85cafbdd1c925", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -253,7 +253,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n-        debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n+        debug_assert!(self.functions.borrow().values().any(|value| *value == function),\n             \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }"}, {"sha": "70cc15b2f8c543268f926a32ff79ea330acce294", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -21,7 +21,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             (Unsafety::Normal, None, Unsafety::Unsafe, hir::ImplPolarity::Positive) => {\n                 struct_span_err!(\n                     tcx.sess,\n-                    item.span,\n+                    tcx.def_span(def_id),\n                     E0199,\n                     \"implementing the trait `{}` is not unsafe\",\n                     trait_ref.print_only_trait_path()\n@@ -38,7 +38,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                 struct_span_err!(\n                     tcx.sess,\n-                    item.span,\n+                    tcx.def_span(def_id),\n                     E0200,\n                     \"the trait `{}` requires an `unsafe impl` declaration\",\n                     trait_ref.print_only_trait_path()\n@@ -61,7 +61,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             (Unsafety::Normal, Some(attr_name), Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                 struct_span_err!(\n                     tcx.sess,\n-                    item.span,\n+                    tcx.def_span(def_id),\n                     E0569,\n                     \"requires an `unsafe impl` declaration due to `#[{}]` attribute\",\n                     attr_name"}, {"sha": "cecf3d3f1e0644c2656924a4e4aa10cf13f9a7bc", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -240,10 +240,8 @@ fn typeck_with_fallback<'tcx>(\n                         }),\n                         Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n                         | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty = asm\n-                                .operands\n-                                .iter()\n-                                .filter_map(|(op, _op_sp)| match op {\n+                            let operand_ty =\n+                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n                                     hir::InlineAsmOperand::Const { anon_const }\n                                         if anon_const.hir_id == id =>\n                                     {\n@@ -259,8 +257,7 @@ fn typeck_with_fallback<'tcx>(\n                                         }))\n                                     }\n                                     _ => None,\n-                                })\n-                                .next();\n+                                });\n                             operand_ty.unwrap_or_else(fallback)\n                         }\n                         _ => fallback(),"}, {"sha": "3d6c2119bea333e568dbd49f026bd343f1bdb32c", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -341,8 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Find an identifier with which this trait was imported (note that `_` doesn't count).\n         let any_id = import_items\n             .iter()\n-            .filter_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None })\n-            .next();\n+            .find_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None });\n         if let Some(any_id) = any_id {\n             if any_id.name == Empty {\n                 // Glob import, so just use its name."}, {"sha": "2daf1979ee5e69d51642a7588f38aa29d6a12272", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1111,7 +1111,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // a raw pointer\n                 !step.self_ty.references_error() && !step.from_unsafe_deref\n             })\n-            .flat_map(|step| {\n+            .find_map(|step| {\n                 let InferOk { value: self_ty, obligations: _ } = self\n                     .fcx\n                     .probe_instantiate_query_response(\n@@ -1147,7 +1147,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         })\n                     })\n             })\n-            .next()\n     }\n \n     /// For each type `T` in the step list, this attempts to find a method where"}, {"sha": "b04ef55a994ea61dbdcf7c36c98d48b55462f245", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -257,9 +257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.tcx\n                             .inherent_impls(adt_def.did())\n                             .iter()\n-                            .filter_map(|def_id| self.associated_value(*def_id, item_name))\n-                            .count()\n-                            >= 1\n+                            .any(|def_id| self.associated_value(*def_id, item_name).is_some())\n                     } else {\n                         false\n                     }"}, {"sha": "d9cdfa9dd4fc9973151c55ecbf98837c65cfbe1e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 57, "deletions": 82, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             let mut v = TraitObjectVisitor(FxIndexSet::default());\n             v.visit_ty(param.param_ty);\n             if let Some((ident, self_ty)) =\n-                self.get_impl_ident_and_self_ty_from_trait(item_def_id, &v.0)\n+                NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, item_def_id, &v.0)\n                 && self.suggest_constrain_dyn_trait_in_impl(&mut err, &v.0, ident, self_ty)\n             {\n                 override_error_code = Some(ident.name);\n@@ -309,19 +309,12 @@ pub fn suggest_new_region_bound(\n                 let did = item_id.owner_id.to_def_id();\n                 let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n \n-                if let Some(span) = opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime {\n-                            res: LifetimeName::Static,\n-                            ident,\n-                            ..\n-                        }) => Some(ident.span),\n-                        _ => None,\n-                    })\n-                    .next()\n-                {\n+                if let Some(span) = opaque.bounds.iter().find_map(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime {\n+                        res: LifetimeName::Static, ident, ..\n+                    }) => Some(ident.span),\n+                    _ => None,\n+                }) {\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n@@ -338,20 +331,14 @@ pub fn suggest_new_region_bound(\n                             Applicability::MaybeIncorrect,\n                         );\n                     }\n-                } else if opaque\n-                    .bounds\n-                    .iter()\n-                    .filter_map(|arg| match arg {\n-                        GenericBound::Outlives(Lifetime { ident, .. })\n-                            if ident.name.to_string() == lifetime_name =>\n-                        {\n-                            Some(ident.span)\n-                        }\n-                        _ => None,\n-                    })\n-                    .next()\n-                    .is_some()\n-                {\n+                } else if opaque.bounds.iter().any(|arg| match arg {\n+                    GenericBound::Outlives(Lifetime { ident, .. })\n+                        if ident.name.to_string() == lifetime_name =>\n+                    {\n+                        true\n+                    }\n+                    _ => false,\n+                }) {\n                 } else {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n@@ -403,66 +390,54 @@ pub fn suggest_new_region_bound(\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    fn get_impl_ident_and_self_ty_from_trait(\n-        &self,\n+    pub fn get_impl_ident_and_self_ty_from_trait(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         trait_objects: &FxIndexSet<DefId>,\n     ) -> Option<(Ident, &'tcx hir::Ty<'tcx>)> {\n-        let tcx = self.tcx();\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+        match tcx.hir().get_if_local(def_id)? {\n+            Node::ImplItem(impl_item) => {\n+                let impl_did = tcx.hir().get_parent_item(impl_item.hir_id());\n+                if let hir::OwnerNode::Item(Item {\n+                    kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                    ..\n+                }) = tcx.hir().owner(impl_did)\n                 {\n-                    Some(Node::Item(Item {\n-                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                        ..\n-                    })) => Some((impl_item.ident, self_ty)),\n-                    _ => None,\n+                    Some((impl_item.ident, self_ty))\n+                } else {\n+                    None\n                 }\n             }\n-            Some(Node::TraitItem(trait_item)) => {\n-                let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did.def_id) {\n-                    Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n-                        // The method being called is defined in the `trait`, but the `'static`\n-                        // obligation comes from the `impl`. Find that `impl` so that we can point\n-                        // at it in the suggestion.\n-                        let trait_did = trait_did.to_def_id();\n-                        match tcx\n-                            .hir()\n-                            .trait_impls(trait_did)\n-                            .iter()\n-                            .filter_map(|&impl_did| {\n-                                match tcx.hir().get_if_local(impl_did.to_def_id()) {\n-                                    Some(Node::Item(Item {\n-                                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n-                                        ..\n-                                    })) if trait_objects.iter().all(|did| {\n-                                        // FIXME: we should check `self_ty` against the receiver\n-                                        // type in the `UnifyReceiver` context, but for now, use\n-                                        // this imperfect proxy. This will fail if there are\n-                                        // multiple `impl`s for the same trait like\n-                                        // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n-                                        // In that case, only the first one will get suggestions.\n-                                        let mut traits = vec![];\n-                                        let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n-                                        hir_v.visit_ty(self_ty);\n-                                        !traits.is_empty()\n-                                    }) =>\n-                                    {\n-                                        Some(self_ty)\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                            .next()\n-                        {\n-                            Some(self_ty) => Some((trait_item.ident, self_ty)),\n-                            _ => None,\n-                        }\n+            Node::TraitItem(trait_item) => {\n+                let trait_id = tcx.hir().get_parent_item(trait_item.hir_id());\n+                debug_assert_eq!(tcx.def_kind(trait_id.def_id), hir::def::DefKind::Trait);\n+                // The method being called is defined in the `trait`, but the `'static`\n+                // obligation comes from the `impl`. Find that `impl` so that we can point\n+                // at it in the suggestion.\n+                let trait_did = trait_id.to_def_id();\n+                tcx.hir().trait_impls(trait_did).iter().find_map(|&impl_did| {\n+                    if let Node::Item(Item {\n+                        kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n+                        ..\n+                    }) = tcx.hir().find_by_def_id(impl_did)?\n+                        && trait_objects.iter().all(|did| {\n+                            // FIXME: we should check `self_ty` against the receiver\n+                            // type in the `UnifyReceiver` context, but for now, use\n+                            // this imperfect proxy. This will fail if there are\n+                            // multiple `impl`s for the same trait like\n+                            // `impl Foo for Box<dyn Bar>` and `impl Foo for dyn Bar`.\n+                            // In that case, only the first one will get suggestions.\n+                            let mut traits = vec![];\n+                            let mut hir_v = HirTraitObjectVisitor(&mut traits, *did);\n+                            hir_v.visit_ty(self_ty);\n+                            !traits.is_empty()\n+                        })\n+                    {\n+                        Some((trait_item.ident, *self_ty))\n+                    } else {\n+                        None\n                     }\n-                    _ => None,\n-                }\n+                })\n             }\n             _ => None,\n         }\n@@ -493,7 +468,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         // Get the `Ident` of the method being called and the corresponding `impl` (to point at\n         // `Bar` in `impl Foo for dyn Bar {}` and the definition of the method being called).\n-        let Some((ident, self_ty)) = self.get_impl_ident_and_self_ty_from_trait(instance.def_id(), &v.0) else {\n+        let Some((ident, self_ty)) = NiceRegionError::get_impl_ident_and_self_ty_from_trait(tcx, instance.def_id(), &v.0) else {\n             return false;\n         };\n "}, {"sha": "525079681ca5cec4eee3f16787df9760519508df", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         cx.tcx,\n                         cx.tcx.explicit_item_bounds(def).iter().cloned(),\n                     )\n-                    .filter_map(|obligation| {\n+                    .find_map(|obligation| {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Clause(ty::Clause::Trait(\n                             ref poly_trait_predicate,\n@@ -270,22 +270,17 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                         }\n                     })\n                     .map(|inner| MustUsePath::Opaque(Box::new(inner)))\n-                    .next()\n                 }\n-                ty::Dynamic(binders, _, _) => binders\n-                    .iter()\n-                    .filter_map(|predicate| {\n-                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n-                            predicate.skip_binder()\n-                        {\n-                            let def_id = trait_ref.def_id;\n-                            is_def_must_use(cx, def_id, span)\n-                        } else {\n-                            None\n-                        }\n-                        .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n-                    })\n-                    .next(),\n+                ty::Dynamic(binders, _, _) => binders.iter().find_map(|predicate| {\n+                    if let ty::ExistentialPredicate::Trait(ref trait_ref) = predicate.skip_binder()\n+                    {\n+                        let def_id = trait_ref.def_id;\n+                        is_def_must_use(cx, def_id, span)\n+                            .map(|inner| MustUsePath::TraitObject(Box::new(inner)))\n+                    } else {\n+                        None\n+                    }\n+                }),\n                 ty::Tuple(tys) => {\n                     let elem_exprs = if let hir::ExprKind::Tup(elem_exprs) = expr.kind {\n                         debug_assert_eq!(elem_exprs.len(), tys.len());"}, {"sha": "bd0c08a53c4f20eb2ce5b6a15a561091ce83d0a6", "filename": "compiler/rustc_macros/src/symbols/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fsymbols%2Ftests.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -16,14 +16,13 @@ fn test_symbols() {\n     let m: &syn::ItemMacro = file\n         .items\n         .iter()\n-        .filter_map(|i| {\n+        .find_map(|i| {\n             if let syn::Item::Macro(m) = i {\n                 if m.mac.path == symbols_path { Some(m) } else { None }\n             } else {\n                 None\n             }\n         })\n-        .next()\n         .expect(\"did not find `symbols!` macro invocation.\");\n \n     let body_tokens = m.mac.tokens.clone();"}, {"sha": "03a7f2d70faebb1127bcf952ce28cab88b633923", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -5,6 +5,7 @@ use rustc_middle::thir::visit::{self, Visitor};\n use rustc_hir as hir;\n use rustc_middle::mir::BorrowKind;\n use rustc_middle::thir::*;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n use rustc_session::lint::builtin::{UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n use rustc_session::lint::Level;\n@@ -524,17 +525,19 @@ impl UnsafeOpKind {\n         hir_id: hir::HirId,\n         span: Span,\n     ) {\n+        // FIXME: ideally we would want to trim the def paths, but this is not\n+        // feasible with the current lint emission API (see issue #106126).\n         match self {\n-            CallToUnsafeFunction(did) if did.is_some() => tcx.emit_spanned_lint(\n+            CallToUnsafeFunction(Some(did)) => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 hir_id,\n                 span,\n                 UnsafeOpInUnsafeFnCallToUnsafeFunctionRequiresUnsafe {\n                     span,\n-                    function: &tcx.def_path_str(did.unwrap()),\n+                    function: &with_no_trimmed_paths!(tcx.def_path_str(*did)),\n                 },\n             ),\n-            CallToUnsafeFunction(..) => tcx.emit_spanned_lint(\n+            CallToUnsafeFunction(None) => tcx.emit_spanned_lint(\n                 UNSAFE_OP_IN_UNSAFE_FN,\n                 hir_id,\n                 span,\n@@ -594,7 +597,7 @@ impl UnsafeOpKind {\n                 span,\n                 UnsafeOpInUnsafeFnCallToFunctionWithRequiresUnsafe {\n                     span,\n-                    function: &tcx.def_path_str(*did),\n+                    function: &with_no_trimmed_paths!(tcx.def_path_str(*did)),\n                 },\n             ),\n         }\n@@ -607,24 +610,24 @@ impl UnsafeOpKind {\n         unsafe_op_in_unsafe_fn_allowed: bool,\n     ) {\n         match self {\n-            CallToUnsafeFunction(did) if did.is_some() && unsafe_op_in_unsafe_fn_allowed => {\n+            CallToUnsafeFunction(Some(did)) if unsafe_op_in_unsafe_fn_allowed => {\n                 tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeUnsafeOpInUnsafeFnAllowed {\n                     span,\n-                    function: &tcx.def_path_str(did.unwrap()),\n+                    function: &tcx.def_path_str(*did),\n                 });\n             }\n-            CallToUnsafeFunction(did) if did.is_some() => {\n+            CallToUnsafeFunction(Some(did)) => {\n                 tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafe {\n                     span,\n-                    function: &tcx.def_path_str(did.unwrap()),\n+                    function: &tcx.def_path_str(*did),\n                 });\n             }\n-            CallToUnsafeFunction(..) if unsafe_op_in_unsafe_fn_allowed => {\n+            CallToUnsafeFunction(None) if unsafe_op_in_unsafe_fn_allowed => {\n                 tcx.sess.emit_err(\n                     CallToUnsafeFunctionRequiresUnsafeNamelessUnsafeOpInUnsafeFnAllowed { span },\n                 );\n             }\n-            CallToUnsafeFunction(..) => {\n+            CallToUnsafeFunction(None) => {\n                 tcx.sess.emit_err(CallToUnsafeFunctionRequiresUnsafeNameless { span });\n             }\n             UseOfInlineAssembly if unsafe_op_in_unsafe_fn_allowed => {"}, {"sha": "e41fe325b811cb42cf118565782a00e1f75df0eb", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -820,13 +820,12 @@ impl<'a> Resolver<'a> {\n             // binding if it exists. What we really want here is having two separate scopes in\n             // a module - one for non-globs and one for globs, but until that's done use this\n             // hack to avoid inconsistent resolution ICEs during import validation.\n-            let binding = [resolution.binding, resolution.shadowed_glob]\n-                .into_iter()\n-                .filter_map(|binding| match (binding, ignore_binding) {\n+            let binding = [resolution.binding, resolution.shadowed_glob].into_iter().find_map(\n+                |binding| match (binding, ignore_binding) {\n                     (Some(binding), Some(ignored)) if ptr::eq(binding, ignored) => None,\n                     _ => binding,\n-                })\n-                .next();\n+                },\n+            );\n             let Some(binding) = binding else {\n                 return Err((Determined, Weak::No));\n             };"}, {"sha": "fe6de1cf879b2e2395173f1d4e5d3c80ea2a1fe9", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -402,7 +402,20 @@ pub mod __alloc_error_handler {\n     // `#[alloc_error_handler]`.\n     #[rustc_std_internal_symbol]\n     pub unsafe fn __rdl_oom(size: usize, _align: usize) -> ! {\n-        panic!(\"memory allocation of {size} bytes failed\")\n+        extern \"Rust\" {\n+            // This symbol is emitted by rustc next to __rust_alloc_error_handler.\n+            // Its value depends on the -Zoom={panic,abort} compiler option.\n+            static __rust_alloc_error_handler_should_panic: u8;\n+        }\n+\n+        #[allow(unused_unsafe)]\n+        if unsafe { __rust_alloc_error_handler_should_panic != 0 } {\n+            panic!(\"memory allocation of {size} bytes failed\")\n+        } else {\n+            core::panicking::panic_nounwind_fmt(format_args!(\n+                \"memory allocation of {size} bytes failed\"\n+            ))\n+        }\n     }\n }\n "}, {"sha": "bb1a85eb2203bee7266dd89e51339106cca94299", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -110,6 +110,7 @@\n #![feature(const_maybe_uninit_as_mut_ptr)]\n #![feature(const_refs_to_cell)]\n #![feature(core_intrinsics)]\n+#![feature(core_panic)]\n #![feature(const_eval_select)]\n #![feature(const_pin)]\n #![feature(const_waker)]"}, {"sha": "48e90e6d794005e7b9bde41b4ac440a93ade37f5", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -64,13 +64,17 @@ pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     unsafe { panic_impl(&pi) }\n }\n \n-/// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n-/// (No `fmt` variant as a `fmt::Arguments` needs more space to be passed.)\n+/// Like `panic_fmt`, but for non-unwinding panics.\n+///\n+/// Has to be a separate function so that it can carry the `rustc_nounwind` attribute.\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n #[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n-#[cfg_attr(not(bootstrap), lang = \"panic_nounwind\")] // needed by codegen for non-unwinding panics\n+#[track_caller]\n+// This attribute has the key side-effect that if the panic handler ignores `can_unwind`\n+// and unwinds anyway, we will hit the \"unwinding out of nounwind function\" guard,\n+// which causes a \"panic in a function that cannot unwind\".\n #[rustc_nounwind]\n-pub fn panic_nounwind(msg: &'static str) -> ! {\n+pub fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>) -> ! {\n     if cfg!(feature = \"panic_immediate_abort\") {\n         super::intrinsics::abort()\n     }\n@@ -83,8 +87,6 @@ pub fn panic_nounwind(msg: &'static str) -> ! {\n     }\n \n     // PanicInfo with the `can_unwind` flag set to false forces an abort.\n-    let pieces = [msg];\n-    let fmt = fmt::Arguments::new_v1(&pieces, &[]);\n     let pi = PanicInfo::internal_constructor(Some(&fmt), Location::caller(), false);\n \n     // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n@@ -112,6 +114,15 @@ pub const fn panic(expr: &'static str) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n }\n \n+/// Like `panic`, but without unwinding and track_caller to reduce the impact on codesize.\n+#[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never), cold)]\n+#[cfg_attr(feature = \"panic_immediate_abort\", inline)]\n+#[cfg_attr(not(bootstrap), lang = \"panic_nounwind\")] // needed by codegen for non-unwinding panics\n+#[rustc_nounwind]\n+pub fn panic_nounwind(expr: &'static str) -> ! {\n+    panic_nounwind_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n+}\n+\n #[inline]\n #[track_caller]\n #[rustc_diagnostic_item = \"panic_str\"]"}, {"sha": "c5a5991cc81c47d340a3b7b113c56339671acd7e", "filename": "library/std/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/library%2Fstd%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/library%2Fstd%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Falloc.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -338,7 +338,7 @@ fn default_alloc_error_hook(layout: Layout) {\n \n     #[allow(unused_unsafe)]\n     if unsafe { __rust_alloc_error_handler_should_panic != 0 } {\n-        panic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n+        panic!(\"memory allocation of {} bytes failed\", layout.size());\n     } else {\n         rtprintpanic!(\"memory allocation of {} bytes failed\\n\", layout.size());\n     }"}, {"sha": "68215790bed177e3fdd3b4376da622b612bc689a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -2067,6 +2067,9 @@ impl Step for RustDev {\n \n         builder.ensure(crate::native::Llvm { target });\n \n+        // We want to package `lld` to use it with `download-ci-llvm`.\n+        builder.ensure(crate::native::Lld { target });\n+\n         let src_bindir = builder.llvm_out(target).join(\"bin\");\n         // If updating this list, you likely want to change\n         // src/bootstrap/download-ci-llvm-stamp as well, otherwise local users"}, {"sha": "94630e40f3c4ca5a68e3bd5e149fa190fd265b15", "filename": "src/bootstrap/download-ci-llvm-stamp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload-ci-llvm-stamp?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1,4 +1,4 @@\n Change this file to make users of the `download-ci-llvm` configuration download\n a new version of LLVM from CI, even if the LLVM submodule hasn\u2019t changed.\n \n-Last change is for: https://github.com/rust-lang/rust/pull/102790\n+Last change is for: https://github.com/rust-lang/rust/pull/104748"}, {"sha": "781a738a81196877582a4b34daa4f43d109bdf8a", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -63,13 +63,13 @@ impl LdFlags {\n     }\n }\n \n-// This returns whether we've already previously built LLVM.\n-//\n-// It's used to avoid busting caches during x.py check -- if we've already built\n-// LLVM, it's fine for us to not try to avoid doing so.\n-//\n-// This will return the llvm-config if it can get it (but it will not build it\n-// if not).\n+/// This returns whether we've already previously built LLVM.\n+///\n+/// It's used to avoid busting caches during x.py check -- if we've already built\n+/// LLVM, it's fine for us to not try to avoid doing so.\n+///\n+/// This will return the llvm-config if it can get it (but it will not build it\n+/// if not).\n pub fn prebuilt_llvm_config(\n     builder: &Builder<'_>,\n     target: TargetSelection,\n@@ -823,8 +823,21 @@ impl Step for Lld {\n         }\n         let target = self.target;\n \n-        let LlvmResult { llvm_config, llvm_cmake_dir } =\n-            builder.ensure(Llvm { target: self.target });\n+        let LlvmResult { llvm_config, llvm_cmake_dir } = builder.ensure(Llvm { target });\n+\n+        // The `dist` step packages LLD next to LLVM's binaries for download-ci-llvm. The root path\n+        // we usually expect here is `./build/$triple/ci-llvm/`, with the binaries in its `bin`\n+        // subfolder. We check if that's the case, and if LLD's binary already exists there next to\n+        // `llvm-config`: if so, we can use it instead of building LLVM/LLD from source.\n+        let ci_llvm_bin = llvm_config.parent().unwrap();\n+        if ci_llvm_bin.is_dir() && ci_llvm_bin.file_name().unwrap() == \"bin\" {\n+            let lld_path = ci_llvm_bin.join(exe(\"lld\", target));\n+            if lld_path.exists() {\n+                // The following steps copying `lld` as `rust-lld` to the sysroot, expect it in the\n+                // `bin` subfolder of this step's out dir.\n+                return ci_llvm_bin.parent().unwrap().to_path_buf();\n+            }\n+        }\n \n         let out_dir = builder.lld_out(target);\n         let done_stamp = out_dir.join(\"lld-finished-building\");"}, {"sha": "afc369bc3fda6fb8d4765af5b8177964ad13124d", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -108,11 +108,7 @@ body {\n \t/* Then override it with `anywhere`, which is required to make non-Safari browsers break\n \t   more aggressively when we want them to. */\n \toverflow-wrap: anywhere;\n-\n-\t-webkit-font-feature-settings: \"kern\", \"liga\";\n-\t-moz-font-feature-settings: \"kern\", \"liga\";\n \tfont-feature-settings: \"kern\", \"liga\";\n-\n \tbackground-color: var(--main-background-color);\n \tcolor: var(--main-color);\n }"}, {"sha": "7be5b92a7def0fa8e25d6b3fdf4124da77a8b9b7", "filename": "src/test/ui/coherence/coherence-default-trait-impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-default-trait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-default-trait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-default-trait-impl.stderr?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -2,7 +2,7 @@ error[E0199]: implementing the trait `MySafeTrait` is not unsafe\n   --> $DIR/coherence-default-trait-impl.rs:8:1\n    |\n LL | unsafe impl MySafeTrait for Foo {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: remove `unsafe` from this trait implementation\n    |\n@@ -14,7 +14,7 @@ error[E0200]: the trait `MyUnsafeTrait` requires an `unsafe impl` declaration\n   --> $DIR/coherence-default-trait-impl.rs:13:1\n    |\n LL | impl MyUnsafeTrait for Foo {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the trait `MyUnsafeTrait` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\n help: add `unsafe` to this trait implementation"}, {"sha": "5cec2bcb0387210361ea9a9901b0ee1f44c8cdca", "filename": "src/test/ui/dropck/dropck-eyepatch-implies-unsafe-impl.stderr", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck-eyepatch-implies-unsafe-impl.stderr?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1,13 +1,8 @@\n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:21:1\n    |\n-LL | / impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n-LL | |\n-LL | |\n-LL | |     // (unsafe to access self.1  due to #[may_dangle] on A)\n-LL | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n-LL | | }\n-   | |_^\n+LL | impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the trait `Drop` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\n help: add `unsafe` to this trait implementation\n@@ -18,13 +13,8 @@ LL | unsafe impl<#[may_dangle] A, B: fmt::Debug> Drop for Pt<A, B> {\n error[E0569]: requires an `unsafe impl` declaration due to `#[may_dangle]` attribute\n   --> $DIR/dropck-eyepatch-implies-unsafe-impl.rs:27:1\n    |\n-LL | / impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n-LL | |\n-LL | |\n-LL | |     // (unsafe to access self.1 due to #[may_dangle] on 'a)\n-LL | |     fn drop(&mut self) { println!(\"drop {} {:?}\", self.0, self.2); }\n-LL | | }\n-   | |_^\n+LL | impl<#[may_dangle] 'a, 'b, B: fmt::Debug> Drop for Pr<'a, 'b, B> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the trait `Drop` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\n help: add `unsafe` to this trait implementation"}, {"sha": "68c308b15cc0868940017c27ffc69e380441deb8", "filename": "src/test/ui/error-codes/E0199.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ferror-codes%2FE0199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ferror-codes%2FE0199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0199.stderr?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -2,7 +2,7 @@ error[E0199]: implementing the trait `Bar` is not unsafe\n   --> $DIR/E0199.rs:6:1\n    |\n LL | unsafe impl Bar for Foo { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: remove `unsafe` from this trait implementation\n    |"}, {"sha": "c70a2d4f3d1f132ec1671bc51928152adcf44660", "filename": "src/test/ui/error-codes/E0200.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ferror-codes%2FE0200.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ferror-codes%2FE0200.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0200.stderr?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -2,7 +2,7 @@ error[E0200]: the trait `Bar` requires an `unsafe impl` declaration\n   --> $DIR/E0200.rs:5:1\n    |\n LL | impl Bar for Foo { }\n-   | ^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^\n    |\n    = note: the trait `Bar` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\n help: add `unsafe` to this trait implementation"}, {"sha": "0ca565787f6b6a5fb8a777c0e852b8ef4fe04ba9", "filename": "src/test/ui/traits/safety-trait-impl-cc.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ftraits%2Fsafety-trait-impl-cc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ftraits%2Fsafety-trait-impl-cc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsafety-trait-impl-cc.stderr?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1,12 +1,8 @@\n error[E0200]: the trait `Foo` requires an `unsafe impl` declaration\n   --> $DIR/safety-trait-impl-cc.rs:9:1\n    |\n-LL | / impl lib::Foo for Bar {\n-LL | |     fn foo(&self) -> isize {\n-LL | |         panic!();\n-LL | |     }\n-LL | | }\n-   | |_^\n+LL | impl lib::Foo for Bar {\n+   | ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the trait `Foo` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\n help: add `unsafe` to this trait implementation"}, {"sha": "e78e0e3a6baa48a9f1449763ad50952368913365", "filename": "src/test/ui/traits/safety-trait-impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ftraits%2Fsafety-trait-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Ftraits%2Fsafety-trait-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsafety-trait-impl.stderr?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -2,7 +2,7 @@ error[E0200]: the trait `UnsafeTrait` requires an `unsafe impl` declaration\n   --> $DIR/safety-trait-impl.rs:14:1\n    |\n LL | impl UnsafeTrait for u16 { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the trait `UnsafeTrait` enforces invariants that the compiler can't check. Review the trait documentation and make sure this implementation upholds those invariants before adding the `unsafe` keyword\n help: add `unsafe` to this trait implementation\n@@ -14,7 +14,7 @@ error[E0199]: implementing the trait `SafeTrait` is not unsafe\n   --> $DIR/safety-trait-impl.rs:16:1\n    |\n LL | unsafe impl SafeTrait for u32 { }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: remove `unsafe` from this trait implementation\n    |"}, {"sha": "091a3edb756ada56f2667ee3dbf0c04e8e25d34c", "filename": "src/test/ui/unsafe/auxiliary/issue-106126.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Funsafe%2Fauxiliary%2Fissue-106126.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Funsafe%2Fauxiliary%2Fissue-106126.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Fauxiliary%2Fissue-106126.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -0,0 +1,9 @@\n+#[macro_export]\n+macro_rules! foo {\n+    () => {\n+        unsafe fn __unsf() {}\n+        unsafe fn __foo() {\n+            __unsf();\n+        }\n+    };\n+}"}, {"sha": "93f478ee358023ba68e1f8c08125e909144fda51", "filename": "src/test/ui/unsafe/issue-106126-good-path-bug.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Funsafe%2Fissue-106126-good-path-bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftest%2Fui%2Funsafe%2Fissue-106126-good-path-bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Fissue-106126-good-path-bug.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -0,0 +1,12 @@\n+// Regression test for #106126.\n+// check-pass\n+// aux-build:issue-106126.rs\n+\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n+#[macro_use]\n+extern crate issue_106126;\n+\n+foo!();\n+\n+fn main() {}"}, {"sha": "8990310a4f474073ad3233a3d5d99773c21c4458", "filename": "src/tools/jsondoclint/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2FCargo.toml?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -7,6 +7,8 @@ edition = \"2021\"\n \n [dependencies]\n anyhow = \"1.0.62\"\n+clap = { version = \"4.0.15\", features = [\"derive\"] }\n fs-err = \"2.8.1\"\n rustdoc-json-types = { version = \"0.1.0\", path = \"../../rustdoc-json-types\" }\n+serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0.85\""}, {"sha": "a183c4068ce85af48f175517fbd9ae56896ef1f2", "filename": "src/tools/jsondoclint/src/json_find.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fjson_find.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1,8 +1,9 @@\n use std::fmt::Write;\n \n+use serde::Serialize;\n use serde_json::Value;\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Serialize)]\n pub enum SelectorPart {\n     Field(String),\n     Index(usize),"}, {"sha": "05e938f4f7df4f906afcb73ac7cdb757c8c33c10", "filename": "src/tools/jsondoclint/src/main.rs", "status": "modified", "additions": 71, "deletions": 27, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fmain.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -1,59 +1,103 @@\n-use std::env;\n+use std::io::{BufWriter, Write};\n \n-use anyhow::{anyhow, bail, Result};\n+use anyhow::{bail, Result};\n+use clap::Parser;\n use fs_err as fs;\n use rustdoc_json_types::{Crate, Id, FORMAT_VERSION};\n+use serde::Serialize;\n use serde_json::Value;\n \n pub(crate) mod item_kind;\n mod json_find;\n mod validator;\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Serialize, Clone)]\n struct Error {\n     kind: ErrorKind,\n     id: Id,\n }\n \n-#[derive(Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq, Serialize, Clone)]\n enum ErrorKind {\n-    NotFound,\n+    NotFound(Vec<json_find::Selector>),\n     Custom(String),\n }\n \n+#[derive(Debug, Serialize)]\n+struct JsonOutput {\n+    path: String,\n+    errors: Vec<Error>,\n+}\n+\n+#[derive(Parser)]\n+struct Cli {\n+    /// The path to the json file to be linted\n+    path: String,\n+\n+    /// Show verbose output\n+    #[arg(long)]\n+    verbose: bool,\n+\n+    #[arg(long)]\n+    json_output: Option<String>,\n+}\n+\n fn main() -> Result<()> {\n-    let path = env::args().nth(1).ok_or_else(|| anyhow!(\"no path given\"))?;\n+    let Cli { path, verbose, json_output } = Cli::parse();\n+\n     let contents = fs::read_to_string(&path)?;\n     let krate: Crate = serde_json::from_str(&contents)?;\n     assert_eq!(krate.format_version, FORMAT_VERSION);\n \n-    let mut validator = validator::Validator::new(&krate);\n+    let krate_json: Value = serde_json::from_str(&contents)?;\n+\n+    let mut validator = validator::Validator::new(&krate, krate_json);\n     validator.check_crate();\n \n+    if let Some(json_output) = json_output {\n+        let output = JsonOutput { path: path.clone(), errors: validator.errs.clone() };\n+        let mut f = BufWriter::new(fs::File::create(json_output)?);\n+        serde_json::to_writer(&mut f, &output)?;\n+        f.flush()?;\n+    }\n+\n     if !validator.errs.is_empty() {\n         for err in validator.errs {\n             match err.kind {\n-                ErrorKind::NotFound => {\n-                    let krate_json: Value = serde_json::from_str(&contents)?;\n-\n-                    let sels =\n-                        json_find::find_selector(&krate_json, &Value::String(err.id.0.clone()));\n-                    match &sels[..] {\n-                        [] => unreachable!(\n-                            \"id must be in crate, or it wouldn't be reported as not found\"\n-                        ),\n-                        [sel] => eprintln!(\n-                            \"{} not in index or paths, but refered to at '{}'\",\n-                            err.id.0,\n-                            json_find::to_jsonpath(&sel)\n-                        ),\n-                        [sel, ..] => eprintln!(\n-                            \"{} not in index or paths, but refered to at '{}' and more\",\n-                            err.id.0,\n-                            json_find::to_jsonpath(&sel)\n-                        ),\n+                ErrorKind::NotFound(sels) => match &sels[..] {\n+                    [] => {\n+                        unreachable!(\n+                            \"id {:?} must be in crate, or it wouldn't be reported as not found\",\n+                            err.id\n+                        )\n+                    }\n+                    [sel] => eprintln!(\n+                        \"{} not in index or paths, but refered to at '{}'\",\n+                        err.id.0,\n+                        json_find::to_jsonpath(&sel)\n+                    ),\n+                    [sel, ..] => {\n+                        if verbose {\n+                            let sels = sels\n+                                .iter()\n+                                .map(json_find::to_jsonpath)\n+                                .map(|i| format!(\"'{i}'\"))\n+                                .collect::<Vec<_>>()\n+                                .join(\", \");\n+                            eprintln!(\n+                                \"{} not in index or paths, but refered to at {sels}\",\n+                                err.id.0\n+                            );\n+                        } else {\n+                            eprintln!(\n+                                \"{} not in index or paths, but refered to at '{}' and {} more\",\n+                                err.id.0,\n+                                json_find::to_jsonpath(&sel),\n+                                sels.len() - 1,\n+                            )\n+                        }\n                     }\n-                }\n+                },\n                 ErrorKind::Custom(msg) => eprintln!(\"{}: {}\", err.id.0, msg),\n             }\n         }"}, {"sha": "f1b9c1acbaec088097ccf45603b9b88557723001", "filename": "src/tools/jsondoclint/src/validator.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -7,8 +7,9 @@ use rustdoc_json_types::{\n     Primitive, ProcMacro, Static, Struct, StructKind, Term, Trait, TraitAlias, Type, TypeBinding,\n     TypeBindingKind, Typedef, Union, Variant, VariantKind, WherePredicate,\n };\n+use serde_json::Value;\n \n-use crate::{item_kind::Kind, Error, ErrorKind};\n+use crate::{item_kind::Kind, json_find, Error, ErrorKind};\n \n /// The Validator walks over the JSON tree, and ensures it is well formed.\n /// It is made of several parts.\n@@ -22,6 +23,7 @@ use crate::{item_kind::Kind, Error, ErrorKind};\n pub struct Validator<'a> {\n     pub(crate) errs: Vec<Error>,\n     krate: &'a Crate,\n+    krate_json: Value,\n     /// Worklist of Ids to check.\n     todo: HashSet<&'a Id>,\n     /// Ids that have already been visited, so don't need to be checked again.\n@@ -39,9 +41,10 @@ enum PathKind {\n }\n \n impl<'a> Validator<'a> {\n-    pub fn new(krate: &'a Crate) -> Self {\n+    pub fn new(krate: &'a Crate, krate_json: Value) -> Self {\n         Self {\n             krate,\n+            krate_json,\n             errs: Vec::new(),\n             seen_ids: HashSet::new(),\n             todo: HashSet::new(),\n@@ -373,7 +376,11 @@ impl<'a> Validator<'a> {\n         } else {\n             if !self.missing_ids.contains(id) {\n                 self.missing_ids.insert(id);\n-                self.fail(id, ErrorKind::NotFound)\n+\n+                let sels = json_find::find_selector(&self.krate_json, &Value::String(id.0.clone()));\n+                assert_ne!(sels.len(), 0);\n+\n+                self.fail(id, ErrorKind::NotFound(sels))\n             }\n         }\n     }"}, {"sha": "37b826153efb16dc09c67227adefebea4b206139", "filename": "src/tools/jsondoclint/src/validator/tests.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondoclint%2Fsrc%2Fvalidator%2Ftests.rs?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -2,11 +2,16 @@ use std::collections::HashMap;\n \n use rustdoc_json_types::{Crate, Item, Visibility};\n \n+use crate::json_find::SelectorPart;\n+\n use super::*;\n \n #[track_caller]\n fn check(krate: &Crate, errs: &[Error]) {\n-    let mut validator = Validator::new(krate);\n+    let krate_string = serde_json::to_string(krate).unwrap();\n+    let krate_json = serde_json::from_str(&krate_string).unwrap();\n+\n+    let mut validator = Validator::new(krate, krate_json);\n     validator.check_crate();\n \n     assert_eq!(errs, &validator.errs[..]);\n@@ -46,5 +51,16 @@ fn errors_on_missing_links() {\n         format_version: rustdoc_json_types::FORMAT_VERSION,\n     };\n \n-    check(&k, &[Error { kind: ErrorKind::NotFound, id: id(\"1\") }]);\n+    check(\n+        &k,\n+        &[Error {\n+            kind: ErrorKind::NotFound(vec![vec![\n+                SelectorPart::Field(\"index\".to_owned()),\n+                SelectorPart::Field(\"0\".to_owned()),\n+                SelectorPart::Field(\"links\".to_owned()),\n+                SelectorPart::Field(\"Not Found\".to_owned()),\n+            ]]),\n+            id: id(\"1\"),\n+        }],\n+    );\n }"}, {"sha": "58108dac496b65e0ce72e6da34bf6fc6df69cf6b", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c361616c3ca3e3e3069dbdf90557181233387444/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c361616c3ca3e3e3069dbdf90557181233387444/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=c361616c3ca3e3e3069dbdf90557181233387444", "patch": "@@ -479,6 +479,7 @@ compiler = [\n     \"compiler-team-contributors\",\n ]\n libs = [\n+    \"@cuviper\",\n     \"@joshtriplett\",\n     \"@Mark-Simulacrum\",\n     \"@m-ou-se\","}]}