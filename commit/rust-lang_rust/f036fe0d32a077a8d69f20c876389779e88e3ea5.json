{"sha": "f036fe0d32a077a8d69f20c876389779e88e3ea5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwMzZmZTBkMzJhMDc3YThkNjlmMjBjODc2Mzg5Nzc5ZTg4ZTNlYTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T14:20:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T14:20:13Z"}, "message": "refactor memory read API: provide only size-based, no type-based methods", "tree": {"sha": "15cbf758f7f5bec2939a94c45574c347b442b181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15cbf758f7f5bec2939a94c45574c347b442b181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f036fe0d32a077a8d69f20c876389779e88e3ea5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f036fe0d32a077a8d69f20c876389779e88e3ea5", "html_url": "https://github.com/rust-lang/rust/commit/f036fe0d32a077a8d69f20c876389779e88e3ea5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f036fe0d32a077a8d69f20c876389779e88e3ea5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85397286071c7971aded6b2c987aaa7f507d2312", "url": "https://api.github.com/repos/rust-lang/rust/commits/85397286071c7971aded6b2c987aaa7f507d2312", "html_url": "https://github.com/rust-lang/rust/commit/85397286071c7971aded6b2c987aaa7f507d2312"}], "stats": {"total": 348, "additions": 164, "deletions": 184}, "files": [{"sha": "2f45347d113c2cb0734370f845e2d58b603b92aa", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -10,6 +10,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         src_ty: Ty<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n+        trace!(\"Casting {:?}: {:?} to {:?}\", val, src_ty, dest_ty);\n         let src_kind = self.ty_to_primval_kind(src_ty)?;\n \n         match val {"}, {"sha": "1841e155405682328c423cd72c019f164c5deb54", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 108, "deletions": 35, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -998,16 +998,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 let ptr = self.force_allocation(lval)?.to_ptr()?;\n                 let discr_val = self.read_discriminant_value(ptr, ty)?;\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n+                    trace!(\"Read discriminant {}, valid discriminants {:?}\", discr_val, adt_def.discriminants(self.tcx).collect::<Vec<_>>());\n                     if adt_def.discriminants(self.tcx).all(|v| {\n                         discr_val != v.to_u128_unchecked()\n                     })\n                     {\n                         return err!(InvalidDiscriminant);\n                     }\n+                    self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n                 } else {\n                     bug!(\"rustc only generates Rvalue::Discriminant for enums\");\n                 }\n-                self.write_primval(dest, PrimVal::Bytes(discr_val), dest_ty)?;\n             }\n         }\n \n@@ -1295,6 +1296,96 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n     }\n \n+    pub fn read_discriminant_value(\n+        &self,\n+        adt_ptr: MemoryPointer,\n+        adt_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, u128> {\n+        use rustc::ty::layout::Layout::*;\n+        let adt_layout = self.type_layout(adt_ty)?;\n+        //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n+\n+        let discr_val = match *adt_layout {\n+            General { discr, .. } => {\n+                let discr_size = discr.size().bytes();\n+                self.memory.read_primval(adt_ptr, discr_size, false)?.to_bytes()?\n+            }\n+\n+            CEnum {\n+                discr,\n+                signed,\n+                ..\n+            } => {\n+                let discr_size = discr.size().bytes();\n+                self.memory.read_primval(adt_ptr, discr_size, signed)?.to_bytes()?\n+            }\n+\n+            RawNullablePointer { nndiscr, value } => {\n+                let discr_size = value.size(&self.tcx.data_layout).bytes();\n+                trace!(\"rawnullablepointer with size {}\", discr_size);\n+                self.read_nonnull_discriminant_value(\n+                    adt_ptr,\n+                    nndiscr as u128,\n+                    discr_size,\n+                )?\n+            }\n+\n+            StructWrappedNullablePointer {\n+                nndiscr,\n+                ref discrfield_source,\n+                ..\n+            } => {\n+                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n+                    adt_ty,\n+                    nndiscr,\n+                    discrfield_source,\n+                )?;\n+                let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n+                trace!(\"struct wrapped nullable pointer type: {}\", ty);\n+                // only the pointer part of a fat pointer is used for this space optimization\n+                let discr_size = self.type_size(ty)?.expect(\n+                    \"bad StructWrappedNullablePointer discrfield\",\n+                );\n+                self.read_maybe_aligned(!packed, |ectx| {\n+                    ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)\n+                })?\n+            }\n+\n+            // The discriminant_value intrinsic returns 0 for non-sum types.\n+            Array { .. } |\n+            FatPointer { .. } |\n+            Scalar { .. } |\n+            Univariant { .. } |\n+            Vector { .. } |\n+            UntaggedUnion { .. } => 0,\n+        };\n+\n+        Ok(discr_val)\n+    }\n+\n+    fn read_nonnull_discriminant_value(\n+        &self,\n+        ptr: MemoryPointer,\n+        nndiscr: u128,\n+        discr_size: u64,\n+    ) -> EvalResult<'tcx, u128> {\n+        trace!(\n+            \"read_nonnull_discriminant_value: {:?}, {}, {}\",\n+            ptr,\n+            nndiscr,\n+            discr_size\n+        );\n+        // We are only interested in 0 vs. non-0, the sign does not matter for this\n+        let null = match self.memory.read_primval(ptr, discr_size, false)? {\n+            PrimVal::Bytes(0) => true,\n+            PrimVal::Bytes(_) |\n+            PrimVal::Ptr(..) => false,\n+            PrimVal::Undef => return err!(ReadUndefBytes),\n+        };\n+        assert!(nndiscr == 0 || nndiscr == 1);\n+        Ok(if !null { nndiscr } else { 1 - nndiscr })\n+    }\n+\n     pub fn read_global_as_value(&self, gid: GlobalId) -> Value {\n         Value::ByRef(*self.globals.get(&gid).expect(\"global not cached\"))\n     }\n@@ -1676,18 +1767,19 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         ptr: MemoryPointer,\n         pointee_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n-        let p = self.memory.read_ptr(ptr)?;\n+        let ptr_size = self.memory.pointer_size();\n+        let p : Pointer = self.memory.read_ptr_sized_unsigned(ptr)?.into();\n         if self.type_is_sized(pointee_ty) {\n             Ok(p.to_value())\n         } else {\n             trace!(\"reading fat pointer extra of type {}\", pointee_ty);\n-            let extra = ptr.offset(self.memory.pointer_size(), self)?;\n+            let extra = ptr.offset(ptr_size, self)?;\n             match self.tcx.struct_tail(pointee_ty).sty {\n                 ty::TyDynamic(..) => Ok(p.to_value_with_vtable(\n-                    self.memory.read_ptr(extra)?.to_ptr()?,\n+                    self.memory.read_ptr_sized_unsigned(extra)?.to_ptr()?,\n                 )),\n                 ty::TySlice(..) | ty::TyStr => Ok(\n-                    p.to_value_with_len(self.memory.read_usize(extra)?),\n+                    p.to_value_with_len(self.memory.read_ptr_sized_unsigned(extra)?.to_bytes()? as u64),\n                 ),\n                 _ => bug!(\"unsized primval ptr read from {:?}\", pointee_ty),\n             }\n@@ -1697,10 +1789,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn try_read_value(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n         use syntax::ast::FloatTy;\n \n+        let ptr = ptr.to_ptr()?;\n         let val = match ty.sty {\n-            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr.to_ptr()?)?),\n+            ty::TyBool => PrimVal::from_bool(self.memory.read_bool(ptr)?),\n             ty::TyChar => {\n-                let c = self.memory.read_uint(ptr.to_ptr()?, 4)? as u32;\n+                let c = self.memory.read_primval(ptr, 4, false)?.to_bytes()? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n                     None => return err!(InvalidChar(c as u128)),\n@@ -1717,15 +1810,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n-                // if we transmute a ptr to an isize, reading it back into a primval shouldn't panic\n-                // Due to read_ptr ignoring the sign, we need to jump around some hoops\n-                match self.memory.read_int(ptr.to_ptr()?, size) {\n-                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) if size == self.memory.pointer_size() =>\n-                        // Reading as an int failed because we are seeing ptr bytes *and* we are actually reading at ptr size.\n-                        // Let's try again, reading a ptr this time.\n-                        self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n-                    other => PrimVal::from_i128(other?),\n-                }\n+                self.memory.read_primval(ptr, size, true)?\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1738,36 +1823,24 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n-                // if we transmute a ptr to an usize, reading it back into a primval shouldn't panic\n-                // for consistency's sake, we use the same code as above\n-                match self.memory.read_uint(ptr.to_ptr()?, size) {\n-                    Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. })\n-                        if size == self.memory.pointer_size() => {\n-                        self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval()\n-                    }\n-                    other => PrimVal::from_u128(other?),\n-                }\n+                self.memory.read_primval(ptr, size, false)?\n             }\n \n-            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr.to_ptr()?)?),\n-            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr.to_ptr()?)?),\n+            ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n+            ty::TyFloat(FloatTy::F64) => PrimVal::from_f64(self.memory.read_f64(ptr)?),\n \n-            ty::TyFnPtr(_) => self.memory.read_ptr(ptr.to_ptr()?)?.into_inner_primval(),\n+            ty::TyFnPtr(_) => self.memory.read_ptr_sized_unsigned(ptr)?,\n             ty::TyRef(_, ref tam) |\n-            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr.to_ptr()?, tam.ty).map(Some),\n+            ty::TyRawPtr(ref tam) => return self.read_ptr(ptr, tam.ty).map(Some),\n \n             ty::TyAdt(def, _) => {\n                 if def.is_box() {\n-                    return self.read_ptr(ptr.to_ptr()?, ty.boxed_ty()).map(Some);\n+                    return self.read_ptr(ptr, ty.boxed_ty()).map(Some);\n                 }\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes();\n-                    if signed {\n-                        PrimVal::from_i128(self.memory.read_int(ptr.to_ptr()?, size)?)\n-                    } else {\n-                        PrimVal::from_u128(self.memory.read_uint(ptr.to_ptr()?, size)?)\n-                    }\n+                    self.memory.read_primval(ptr, size, signed)?\n                 } else {\n                     return Ok(None);\n                 }"}, {"sha": "d24f469de405ec17bc0f4d3122ea277cfd9e7973", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -1171,24 +1171,39 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_ptr(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Pointer> {\n-        let size = self.pointer_size();\n+    pub fn read_primval(&self, ptr: MemoryPointer, size: u64, signed: bool) -> EvalResult<'tcx, PrimVal> {\n         self.check_relocation_edges(ptr, size)?; // Make sure we don't read part of a pointer as a pointer\n         let endianess = self.endianess();\n-        let bytes = self.get_bytes_unchecked(ptr, size, size)?;\n+        let bytes = self.get_bytes_unchecked(ptr, size, self.int_align(size)?)?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n             return Ok(PrimVal::Undef.into());\n         }\n-        let offset = read_target_uint(endianess, bytes).unwrap();\n-        assert_eq!(offset as u64 as u128, offset);\n-        let offset = offset as u64;\n-        let alloc = self.get(ptr.alloc_id)?;\n-        match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, offset)).into()),\n-            None => Ok(PrimVal::Bytes(offset as u128).into()),\n+        // Now we do the actual reading\n+        let bytes = if signed {\n+            read_target_int(endianess, bytes).unwrap() as u128\n+        } else {\n+            read_target_uint(endianess, bytes).unwrap()\n+        };\n+        // See if we got a pointer\n+        if size != self.pointer_size() {\n+            if self.relocations(ptr, size)?.count() != 0 {\n+                return err!(ReadPointerAsBytes);\n+            }\n+        } else {\n+            let alloc = self.get(ptr.alloc_id)?;\n+            match alloc.relocations.get(&ptr.offset) {\n+                Some(&alloc_id) => return Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, bytes as u64))),\n+                None => {},\n+            }\n         }\n+        // We don't. Just return the bytes.\n+        Ok(PrimVal::Bytes(bytes))\n+    }\n+\n+    pub fn read_ptr_sized_unsigned(&self, ptr: MemoryPointer) -> EvalResult<'tcx, PrimVal> {\n+        self.read_primval(ptr, self.pointer_size(), false)\n     }\n \n     pub fn write_ptr(&mut self, dest: MemoryPointer, ptr: MemoryPointer) -> EvalResult<'tcx> {\n@@ -1242,6 +1257,8 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     fn int_align(&self, size: u64) -> EvalResult<'tcx, u64> {\n+        // We assume pointer-sized integers have the same alignment as pointers.\n+        // We also assume singed and unsigned integers of the same size have the same alignment.\n         match size {\n             1 => Ok(self.layout.i8_align.abi()),\n             2 => Ok(self.layout.i16_align.abi()),\n@@ -1252,13 +1269,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn read_int(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, i128> {\n-        let align = self.int_align(size)?;\n-        self.get_bytes(ptr, size, align).map(|b| {\n-            read_target_int(self.endianess(), b).unwrap()\n-        })\n-    }\n-\n     pub fn write_int(&mut self, ptr: MemoryPointer, n: i128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n@@ -1267,13 +1277,6 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_uint(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, u128> {\n-        let align = self.int_align(size)?;\n-        self.get_bytes(ptr, size, align).map(|b| {\n-            read_target_uint(self.endianess(), b).unwrap()\n-        })\n-    }\n-\n     pub fn write_uint(&mut self, ptr: MemoryPointer, n: u128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n@@ -1282,19 +1285,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn read_isize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, i64> {\n-        self.read_int(ptr, self.pointer_size()).map(|i| i as i64)\n-    }\n-\n     pub fn write_isize(&mut self, ptr: MemoryPointer, n: i64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_int(ptr, n as i128, size)\n     }\n \n-    pub fn read_usize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, u64> {\n-        self.read_uint(ptr, self.pointer_size()).map(|i| i as u64)\n-    }\n-\n     pub fn write_usize(&mut self, ptr: MemoryPointer, n: u64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_uint(ptr, n as u128, size)\n@@ -1494,13 +1489,15 @@ fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u128\n         layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n+\n fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n     match endianess {\n         layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n         layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n     }\n }\n \n+\n ////////////////////////////////////////////////////////////////////////////////\n // Methods to access floats in the target endianess\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "bd6aabc3621695c9b124c77acb24af95eafab53b", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 7, "deletions": 102, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -1,12 +1,11 @@\n use rustc::mir;\n-use rustc::ty::{self, TypeVariants, Ty};\n+use rustc::ty::{self, TypeVariants};\n use rustc::ty::layout::Layout;\n use syntax::codemap::Span;\n use syntax::abi::Abi;\n \n-use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, eval_context, TyAndPacked,\n-            PtrAndAlign, Lvalue, MemoryPointer, PrimVal, Value, Machine, HasMemory, ValTy};\n-use super::eval_context::IntegerExt;\n+use super::{EvalResult, EvalContext, eval_context,\n+            PtrAndAlign, Lvalue, PrimVal, Value, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -395,10 +394,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let (ptr, vtable) = args[0].into_ptr_vtable_pair(&self.memory)?;\n-                let fn_ptr = self.memory.read_ptr(\n-                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n-                )?;\n-                let instance = self.memory.get_fn(fn_ptr.to_ptr()?)?;\n+                let fn_ptr = self.memory.read_ptr_sized_unsigned(\n+                    vtable.offset(ptr_size * (idx as u64 + 3), &self)?\n+                )?.to_ptr()?;\n+                let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n                 let ty = self.get_field_ty(args[0].ty, 0)?.ty; // TODO: packed flag is ignored\n                 args[0].ty = ty;\n@@ -408,98 +407,4 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n         }\n     }\n-\n-    pub fn read_discriminant_value(\n-        &self,\n-        adt_ptr: MemoryPointer,\n-        adt_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, u128> {\n-        use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty)?;\n-        //trace!(\"read_discriminant_value {:#?}\", adt_layout);\n-\n-        let discr_val = match *adt_layout {\n-            General { discr, .. } |\n-            CEnum {\n-                discr,\n-                signed: false,\n-                ..\n-            } => {\n-                let discr_size = discr.size().bytes();\n-                self.memory.read_uint(adt_ptr, discr_size)?\n-            }\n-\n-            CEnum {\n-                discr,\n-                signed: true,\n-                ..\n-            } => {\n-                let discr_size = discr.size().bytes();\n-                self.memory.read_int(adt_ptr, discr_size)? as u128\n-            }\n-\n-            RawNullablePointer { nndiscr, value } => {\n-                let discr_size = value.size(&self.tcx.data_layout).bytes();\n-                trace!(\"rawnullablepointer with size {}\", discr_size);\n-                self.read_nonnull_discriminant_value(\n-                    adt_ptr,\n-                    nndiscr as u128,\n-                    discr_size,\n-                )?\n-            }\n-\n-            StructWrappedNullablePointer {\n-                nndiscr,\n-                ref discrfield_source,\n-                ..\n-            } => {\n-                let (offset, TyAndPacked { ty, packed }) = self.nonnull_offset_and_ty(\n-                    adt_ty,\n-                    nndiscr,\n-                    discrfield_source,\n-                )?;\n-                let nonnull = adt_ptr.offset(offset.bytes(), &*self)?;\n-                trace!(\"struct wrapped nullable pointer type: {}\", ty);\n-                // only the pointer part of a fat pointer is used for this space optimization\n-                let discr_size = self.type_size(ty)?.expect(\n-                    \"bad StructWrappedNullablePointer discrfield\",\n-                );\n-                self.read_maybe_aligned(!packed, |ectx| {\n-                    ectx.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)\n-                })?\n-            }\n-\n-            // The discriminant_value intrinsic returns 0 for non-sum types.\n-            Array { .. } |\n-            FatPointer { .. } |\n-            Scalar { .. } |\n-            Univariant { .. } |\n-            Vector { .. } |\n-            UntaggedUnion { .. } => 0,\n-        };\n-\n-        Ok(discr_val)\n-    }\n-\n-    fn read_nonnull_discriminant_value(\n-        &self,\n-        ptr: MemoryPointer,\n-        nndiscr: u128,\n-        discr_size: u64,\n-    ) -> EvalResult<'tcx, u128> {\n-        trace!(\n-            \"read_nonnull_discriminant_value: {:?}, {}, {}\",\n-            ptr,\n-            nndiscr,\n-            discr_size\n-        );\n-        let not_null = match self.memory.read_uint(ptr, discr_size) {\n-            Ok(0) => false,\n-            Ok(_) |\n-            Err(EvalError { kind: EvalErrorKind::ReadPointerAsBytes, .. }) => true,\n-            Err(e) => return Err(e),\n-        };\n-        assert!(nndiscr == 0 || nndiscr == 1);\n-        Ok(if not_null { nndiscr } else { 1 - nndiscr })\n-    }\n }"}, {"sha": "284e9811c9fd3f46f5efe47d4f265a2d691b7ec3", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -105,10 +105,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         vtable: MemoryPointer,\n     ) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n-        let size = self.memory.read_usize(vtable.offset(pointer_size, self)?)?;\n-        let align = self.memory.read_usize(\n-            vtable.offset(pointer_size * 2, self)?,\n-        )?;\n+        let size = self.memory.read_ptr_sized_unsigned(vtable.offset(pointer_size, self)?)?.to_bytes()? as u64;\n+        let align = self.memory.read_ptr_sized_unsigned(\n+            vtable.offset(pointer_size * 2, self)?\n+        )?.to_bytes()? as u64;\n         Ok((size, align))\n     }\n "}, {"sha": "e052ec1e391cd30f1a69449602b5ebdf446d5319", "filename": "src/librustc_mir/interpret/value.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -176,13 +176,13 @@ impl<'a, 'tcx: 'a> Value {\n         mem: &Memory<'a, 'tcx, M>,\n     ) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n-        match *self {\n+        Ok(match *self {\n             ByRef(PtrAndAlign { ptr, aligned }) => {\n-                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?))\n+                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr_sized_unsigned(ptr.to_ptr()?))?\n             }\n             ByVal(ptr) |\n-            ByValPair(ptr, _) => Ok(ptr.into()),\n-        }\n+            ByValPair(ptr, _) => ptr,\n+        }.into())\n     }\n \n     pub(super) fn into_ptr_vtable_pair<M: Machine<'tcx>>(\n@@ -196,11 +196,11 @@ impl<'a, 'tcx: 'a> Value {\n                       aligned,\n                   }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                    let vtable = mem.read_ptr(\n+                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n+                    let vtable = mem.read_ptr_sized_unsigned(\n                         ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?,\n-                    )?;\n-                    Ok((ptr, vtable.to_ptr()?))\n+                    )?.to_ptr()?;\n+                    Ok((ptr, vtable))\n                 })\n             }\n \n@@ -222,10 +222,10 @@ impl<'a, 'tcx: 'a> Value {\n                       aligned,\n                   }) => {\n                 mem.read_maybe_aligned(aligned, |mem| {\n-                    let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                    let len = mem.read_usize(\n+                    let ptr = mem.read_ptr_sized_unsigned(ref_ptr.to_ptr()?)?.into();\n+                    let len = mem.read_ptr_sized_unsigned(\n                         ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?,\n-                    )?;\n+                    )?.to_bytes()? as u64;\n                     Ok((ptr, len))\n                 })\n             }"}, {"sha": "0964b1b32b5c4d416e9a419b02e29e36f600f142", "filename": "tests/run-pass-fullmir/integer-ops.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f036fe0d32a077a8d69f20c876389779e88e3ea5/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f036fe0d32a077a8d69f20c876389779e88e3ea5/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Finteger-ops.rs?ref=f036fe0d32a077a8d69f20c876389779e88e3ea5", "patch": "@@ -14,6 +14,10 @@\n use std::i32;\n \n pub fn main() {\n+    // This tests that do (not) do sign extension properly when loading integers\n+    assert_eq!(u32::max_value() as i64, 4294967295);\n+    assert_eq!(i32::min_value() as i64, -2147483648);\n+\n     assert_eq!(i8::min_value(), -128);\n \n     assert_eq!(i8::max_value(), 127);"}]}