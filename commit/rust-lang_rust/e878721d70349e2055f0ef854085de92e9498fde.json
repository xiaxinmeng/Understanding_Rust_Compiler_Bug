{"sha": "e878721d70349e2055f0ef854085de92e9498fde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4Nzg3MjFkNzAzNDllMjA1NWYwZWY4NTQwODVkZTkyZTk0OThmZGU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-20T06:19:56Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-22T21:42:02Z"}, "message": "libcore: Remove all uses of `~str` from `libcore`.\n\n[breaking-change]", "tree": {"sha": "35940d52f145bca81dcf73e5e7da7f3847ceb413", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35940d52f145bca81dcf73e5e7da7f3847ceb413"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e878721d70349e2055f0ef854085de92e9498fde", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e878721d70349e2055f0ef854085de92e9498fde", "html_url": "https://github.com/rust-lang/rust/commit/e878721d70349e2055f0ef854085de92e9498fde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e878721d70349e2055f0ef854085de92e9498fde/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5633d4641f7d63805e3c12c899f8401410bd825f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5633d4641f7d63805e3c12c899f8401410bd825f", "html_url": "https://github.com/rust-lang/rust/commit/5633d4641f7d63805e3c12c899f8401410bd825f"}], "stats": {"total": 1676, "additions": 876, "deletions": 800}, "files": [{"sha": "fa5d85111daf1ce3b028d463e33155f29b27ae8d", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -323,11 +323,15 @@ pub fn is_test(config: &Config, testfile: &Path) -> bool {\n     let mut valid = false;\n \n     for ext in valid_extensions.iter() {\n-        if name.ends_with(*ext) { valid = true; }\n+        if name.ends_with(ext.as_slice()) {\n+            valid = true;\n+        }\n     }\n \n     for pre in invalid_prefixes.iter() {\n-        if name.starts_with(*pre) { valid = false; }\n+        if name.starts_with(pre.as_slice()) {\n+            valid = false;\n+        }\n     }\n \n     return valid;"}, {"sha": "534e04ccb2daa2f22f38be990d93aa08b212610b", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -24,7 +24,7 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n     let mut rdr = BufferedReader::new(File::open(testfile).unwrap());\n \n     rdr.lines().enumerate().filter_map(|(line_no, ln)| {\n-        parse_expected(line_no + 1, ln.unwrap(), re)\n+        parse_expected(line_no + 1, ln.unwrap().as_slice(), re)\n     }).collect()\n }\n "}, {"sha": "2622cf0e5f1c5eb2503b733bad394db38ca3a862", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -15,7 +15,8 @@ use std::unstable::dynamic_lib::DynamicLibrary;\n \n fn target_env(lib_path: &str, prog: &str) -> Vec<(StrBuf, StrBuf)> {\n     let prog = if cfg!(windows) {prog.slice_to(prog.len() - 4)} else {prog};\n-    let aux_path = prog + \".libaux\";\n+    let mut aux_path = prog.to_strbuf();\n+    aux_path.push_str(\".libaux\");\n \n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child."}, {"sha": "c591c477563ee6e5f59f64c60e26120b5e540a27", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -351,7 +351,10 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                               cmds,\n                               \"quit\".to_strbuf()].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n-            dump_output_file(config, testfile, script_str, \"debugger.script\");\n+            dump_output_file(config,\n+                             testfile,\n+                             script_str.as_slice(),\n+                             \"debugger.script\");\n \n \n             procsrv::run(\"\",\n@@ -459,7 +462,10 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 \"quit\\n\".to_strbuf()\n             ].connect(\"\\n\");\n             debug!(\"script_str = {}\", script_str);\n-            dump_output_file(config, testfile, script_str, \"debugger.script\");\n+            dump_output_file(config,\n+                             testfile,\n+                             script_str.as_slice(),\n+                             \"debugger.script\");\n \n             // run debugger script with gdb\n             #[cfg(windows)]\n@@ -553,7 +559,10 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n \n     // Write the script into a file\n     debug!(\"script_str = {}\", script_str);\n-    dump_output_file(config, testfile, script_str.into_owned(), \"debugger.script\");\n+    dump_output_file(config,\n+                     testfile,\n+                     script_str.as_slice(),\n+                     \"debugger.script\");\n     let debugger_script = make_out_name(config, testfile, \"debugger.script\");\n \n     // Let LLDB execute the script via lldb_batchmode.py\n@@ -610,8 +619,8 @@ fn parse_debugger_commands(file_path: &Path, debugger_prefix: &str)\n                            -> DebuggerCommands {\n     use std::io::{BufferedReader, File};\n \n-    let command_directive = debugger_prefix + \"-command\";\n-    let check_directive = debugger_prefix + \"-check\";\n+    let command_directive = format!(\"{}-command\", debugger_prefix);\n+    let check_directive = format!(\"{}-check\", debugger_prefix);\n \n     let mut breakpoint_lines = vec!();\n     let mut commands = vec!();"}, {"sha": "99f7c229d4e36f1e1a17967a9992162af2a2811b", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -60,8 +60,8 @@ To return an Owned String (StrBuf) use the str helper function [`from_utf8_owned\n ~~~\n use std::str;\n \n-let x: Result<StrBuf,~[u8]> =\n-    str::from_utf8_owned(~[104u8,105u8]).map(|x| x.to_strbuf());\n+let x: Option<StrBuf> =\n+    str::from_utf8([ 104u8, 105u8 ]).map(|x| x.to_strbuf());\n let y: StrBuf = x.unwrap();\n ~~~\n "}, {"sha": "8376fc578dba20634d89a9232f9ce147bd069ca1", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -116,18 +116,18 @@ pub fn stats_print() {\n     }\n }\n \n+// The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+// allocations can point to this `static`. It would be incorrect to use a null\n+// pointer, due to enums assuming types like unique pointers are never null.\n+pub static mut EMPTY: uint = 12345;\n+\n /// The allocator for unique pointers.\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n-    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n-    // allocations can point to this `static`. It would be incorrect to use a null\n-    // pointer, due to enums assuming types like unique pointers are never null.\n-    static EMPTY: () = ();\n-\n     if size == 0 {\n-        &EMPTY as *() as *mut u8\n+        &EMPTY as *uint as *mut u8\n     } else {\n         allocate(size, align)\n     }"}, {"sha": "64d620358903e2864acd4ed5050722c9dacfac7e", "filename": "src/liballoc/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Fliballoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Fliballoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Futil.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -28,3 +28,20 @@ fn align_to(size: uint, align: uint) -> uint {\n     assert!(align != 0);\n     (size + align - 1) & !(align - 1)\n }\n+\n+// FIXME(#14344): When linking liballoc with libstd, this library will be linked\n+//                as an rlib (it only exists as an rlib). It turns out that an\n+//                optimized standard library doesn't actually use *any* symbols\n+//                from this library. Everything is inlined and optimized away.\n+//                This means that linkers will actually omit the object for this\n+//                file, even though it may be needed in the future.\n+//\n+//                To get around this for now, we define a dummy symbol which\n+//                will never get inlined so the stdlib can call it. The stdlib's\n+//                reference to this symbol will cause this library's object file\n+//                to get linked in to libstd successfully (the linker won't\n+//                optimize it out).\n+#[deprecated]\n+#[doc(hidden)]\n+pub fn make_stdlib_link_work() {}\n+"}, {"sha": "82cca507c4da75f2ab409505fda673f3e7b1cf5f", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -1330,7 +1330,7 @@ mod tests {\n     #[test]\n     fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n-        let str = \"10110110\".to_owned() + \"00000000\" + \"11111111\";\n+        let str = format!(\"{}{}{}\", \"10110110\", \"00000000\", \"11111111\");\n         assert_eq!(bitv.to_str(), str);\n     }\n "}, {"sha": "94ac344db3485e64993b489de63e25fcfdb97e62", "filename": "src/libcore/any.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -119,7 +119,7 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use realstd::owned::{Box, AnyOwnExt};\n-    use realstd::str::StrAllocating;\n+    use realstd::str::{Str, StrAllocating};\n \n     #[deriving(Eq, Show)]\n     struct Test;\n@@ -249,13 +249,17 @@ mod tests {\n         use realstd::to_str::ToStr;\n         let a = box 8u as Box<::realstd::any::Any>;\n         let b = box Test as Box<::realstd::any::Any>;\n-        assert_eq!(a.to_str(), \"Box<Any>\".to_owned());\n-        assert_eq!(b.to_str(), \"Box<Any>\".to_owned());\n+        let a_str = a.to_str();\n+        let b_str = b.to_str();\n+        assert_eq!(a_str.as_slice(), \"Box<Any>\");\n+        assert_eq!(b_str.as_slice(), \"Box<Any>\");\n \n         let a = &8u as &Any;\n         let b = &Test as &Any;\n-        assert_eq!(format!(\"{}\", a), \"&Any\".to_owned());\n-        assert_eq!(format!(\"{}\", b), \"&Any\".to_owned());\n+        let s = format!(\"{}\", a);\n+        assert_eq!(s.as_slice(), \"&Any\");\n+        let s = format!(\"{}\", b);\n+        assert_eq!(s.as_slice(), \"&Any\");\n     }\n }\n "}, {"sha": "ddfdbca196c66b3ffecf8d8cbc92191046dc9820", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -242,8 +242,10 @@ mod tests {\n \n     #[test]\n     fn test_to_str() {\n-        assert_eq!(false.to_str(), \"false\".to_owned());\n-        assert_eq!(true.to_str(), \"true\".to_owned());\n+        let s = false.to_str();\n+        assert_eq!(s.as_slice(), \"false\");\n+        let s = true.to_str();\n+        assert_eq!(s.as_slice(), \"true\");\n     }\n \n     #[test]"}, {"sha": "3ad2ebb9f0a284c7b9243151cbdcc0e84c52a694", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -404,12 +404,13 @@ mod test {\n     #[test]\n     fn cell_has_sensible_show() {\n         use str::StrSlice;\n+        use realstd::str::Str;\n \n         let x = Cell::new(\"foo bar\");\n-        assert!(format!(\"{}\", x).contains(x.get()));\n+        assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n \n         x.set(\"baz qux\");\n-        assert!(format!(\"{}\", x).contains(x.get()));\n+        assert!(format!(\"{}\", x).as_slice().contains(x.get()));\n     }\n \n     #[test]"}, {"sha": "f3942dfd753a45879384b7a1de0d1ded16962253", "filename": "src/libcore/char.rs", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -637,7 +637,7 @@ mod test {\n     use slice::ImmutableVector;\n     use option::{Some, None};\n     use realstd::strbuf::StrBuf;\n-    use realstd::str::StrAllocating;\n+    use realstd::str::{Str, StrAllocating};\n \n     #[test]\n     fn test_is_lowercase() {\n@@ -742,46 +742,65 @@ mod test {\n \n     #[test]\n     fn test_escape_default() {\n-        fn string(c: char) -> ~str {\n+        fn string(c: char) -> StrBuf {\n             let mut result = StrBuf::new();\n             escape_default(c, |c| { result.push_char(c); });\n-            return result.into_owned();\n+            return result;\n         }\n-        assert_eq!(string('\\n'), \"\\\\n\".to_owned());\n-        assert_eq!(string('\\r'), \"\\\\r\".to_owned());\n-        assert_eq!(string('\\''), \"\\\\'\".to_owned());\n-        assert_eq!(string('\"'), \"\\\\\\\"\".to_owned());\n-        assert_eq!(string(' '), \" \".to_owned());\n-        assert_eq!(string('a'), \"a\".to_owned());\n-        assert_eq!(string('~'), \"~\".to_owned());\n-        assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n-        assert_eq!(string('\\x1f'), \"\\\\x1f\".to_owned());\n-        assert_eq!(string('\\x7f'), \"\\\\x7f\".to_owned());\n-        assert_eq!(string('\\xff'), \"\\\\xff\".to_owned());\n-        assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n-        assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n+        let s = string('\\n');\n+        assert_eq!(s.as_slice(), \"\\\\n\");\n+        let s = string('\\r');\n+        assert_eq!(s.as_slice(), \"\\\\r\");\n+        let s = string('\\'');\n+        assert_eq!(s.as_slice(), \"\\\\'\");\n+        let s = string('\"');\n+        assert_eq!(s.as_slice(), \"\\\\\\\"\");\n+        let s = string(' ');\n+        assert_eq!(s.as_slice(), \" \");\n+        let s = string('a');\n+        assert_eq!(s.as_slice(), \"a\");\n+        let s = string('~');\n+        assert_eq!(s.as_slice(), \"~\");\n+        let s = string('\\x00');\n+        assert_eq!(s.as_slice(), \"\\\\x00\");\n+        let s = string('\\x1f');\n+        assert_eq!(s.as_slice(), \"\\\\x1f\");\n+        let s = string('\\x7f');\n+        assert_eq!(s.as_slice(), \"\\\\x7f\");\n+        let s = string('\\xff');\n+        assert_eq!(s.as_slice(), \"\\\\xff\");\n+        let s = string('\\u011b');\n+        assert_eq!(s.as_slice(), \"\\\\u011b\");\n+        let s = string('\\U0001d4b6');\n+        assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n     }\n \n     #[test]\n     fn test_escape_unicode() {\n-        fn string(c: char) -> ~str {\n+        fn string(c: char) -> StrBuf {\n             let mut result = StrBuf::new();\n             escape_unicode(c, |c| { result.push_char(c); });\n-            return result.into_owned();\n+            return result;\n         }\n-        assert_eq!(string('\\x00'), \"\\\\x00\".to_owned());\n-        assert_eq!(string('\\n'), \"\\\\x0a\".to_owned());\n-        assert_eq!(string(' '), \"\\\\x20\".to_owned());\n-        assert_eq!(string('a'), \"\\\\x61\".to_owned());\n-        assert_eq!(string('\\u011b'), \"\\\\u011b\".to_owned());\n-        assert_eq!(string('\\U0001d4b6'), \"\\\\U0001d4b6\".to_owned());\n+        let s = string('\\x00');\n+        assert_eq!(s.as_slice(), \"\\\\x00\");\n+        let s = string('\\n');\n+        assert_eq!(s.as_slice(), \"\\\\x0a\");\n+        let s = string(' ');\n+        assert_eq!(s.as_slice(), \"\\\\x20\");\n+        let s = string('a');\n+        assert_eq!(s.as_slice(), \"\\\\x61\");\n+        let s = string('\\u011b');\n+        assert_eq!(s.as_slice(), \"\\\\u011b\");\n+        let s = string('\\U0001d4b6');\n+        assert_eq!(s.as_slice(), \"\\\\U0001d4b6\");\n     }\n \n     #[test]\n     fn test_to_str() {\n         use realstd::to_str::ToStr;\n         let s = 't'.to_str();\n-        assert_eq!(s, \"t\".to_owned());\n+        assert_eq!(s.as_slice(), \"t\");\n     }\n \n     #[test]"}, {"sha": "bf1f3ee310ccd687e94bbfd978cab06c7763baaa", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -171,7 +171,7 @@ pub trait Ord: Eq {\n /// The equivalence relation. Two values may be equivalent even if they are\n /// of different types. The most common use case for this relation is\n /// container types; e.g. it is often desirable to be able to use `&str`\n-/// values to look up entries in a container with `~str` keys.\n+/// values to look up entries in a container with `StrBuf` keys.\n pub trait Equiv<T> {\n     /// Implement this function to decide equivalent values.\n     fn equiv(&self, other: &T) -> bool;"}, {"sha": "cc965bc6eed39a027c8cc0f5fe7f08ec21c27529", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -594,7 +594,7 @@ pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter) -> Result,\n }\n \n #[cfg(test)]\n-pub fn format(args: &Arguments) -> ~str {\n+pub fn format(args: &Arguments) -> ::realstd::strbuf::StrBuf {\n     use str;\n     use realstd::str::StrAllocating;\n     use realstd::io::MemWriter;\n@@ -613,7 +613,10 @@ pub fn format(args: &Arguments) -> ~str {\n \n     let mut i = MemWriter::new();\n     let _ = write(&mut i, args);\n-    str::from_utf8(i.get_ref()).unwrap().to_owned()\n+\n+    let mut result = ::realstd::strbuf::StrBuf::new();\n+    result.push_str(str::from_utf8(i.get_ref()).unwrap());\n+    result\n }\n \n /// When the compiler determines that the type of an argument *must* be a string\n@@ -761,7 +764,6 @@ macro_rules! delegate(($ty:ty to $other:ident) => {\n         }\n     }\n })\n-delegate!(~str to string)\n delegate!(&'a str to string)\n delegate!(bool to bool)\n delegate!(char to char)"}, {"sha": "75f67c3df65d706d66393c029064ea2cddb0b494", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 115, "deletions": 115, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -194,7 +194,7 @@ mod tests {\n     use fmt::radix;\n     use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n     use super::{GenericRadix, Radix};\n-    use realstd::str::StrAllocating;\n+    use realstd::str::{Str, StrAllocating};\n \n     #[test]\n     fn test_radix_base() {\n@@ -246,143 +246,143 @@ mod tests {\n         // Formatting integers should select the right implementation based off\n         // the type of the argument. Also, hex/octal/binary should be defined\n         // for integers, but they shouldn't emit the negative sign.\n-        assert_eq!(format!(\"{}\", 1i), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1i8), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1i16), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1i32), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1i64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:d}\", -1i), \"-1\".to_owned());\n-        assert_eq!(format!(\"{:d}\", -1i8), \"-1\".to_owned());\n-        assert_eq!(format!(\"{:d}\", -1i16), \"-1\".to_owned());\n-        assert_eq!(format!(\"{:d}\", -1i32), \"-1\".to_owned());\n-        assert_eq!(format!(\"{:d}\", -1i64), \"-1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1i), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1i8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1i16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1i32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1i64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1i), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1i8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1i16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1i32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1i64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1i), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1i8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1i16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1i32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1i64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1i), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1i8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1i16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1i32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1i64), \"1\".to_owned());\n-\n-        assert_eq!(format!(\"{}\", 1u), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1u8), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1u16), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1u32), \"1\".to_owned());\n-        assert_eq!(format!(\"{}\", 1u64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:u}\", 1u), \"1\".to_owned());\n-        assert_eq!(format!(\"{:u}\", 1u8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:u}\", 1u16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:u}\", 1u32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:u}\", 1u64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1u), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1u8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1u16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1u32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 1u64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1u), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1u8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1u16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1u32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 1u64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1u), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1u8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1u16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1u32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 1u64), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1u), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1u8), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1u16), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1u32), \"1\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 1u64), \"1\".to_owned());\n+        assert!(format!(\"{}\", 1i).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1i8).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1i16).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1i32).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1i64).as_slice() == \"1\");\n+        assert!(format!(\"{:d}\", -1i).as_slice() == \"-1\");\n+        assert!(format!(\"{:d}\", -1i8).as_slice() == \"-1\");\n+        assert!(format!(\"{:d}\", -1i16).as_slice() == \"-1\");\n+        assert!(format!(\"{:d}\", -1i32).as_slice() == \"-1\");\n+        assert!(format!(\"{:d}\", -1i64).as_slice() == \"-1\");\n+        assert!(format!(\"{:t}\", 1i).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1i8).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1i16).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1i32).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1i64).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1i).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1i8).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1i16).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1i32).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1i64).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1i).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1i8).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1i16).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1i32).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1i64).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1i).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1i8).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1i16).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1i32).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1i64).as_slice() == \"1\");\n+\n+        assert!(format!(\"{}\", 1u).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1u8).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1u16).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1u32).as_slice() == \"1\");\n+        assert!(format!(\"{}\", 1u64).as_slice() == \"1\");\n+        assert!(format!(\"{:u}\", 1u).as_slice() == \"1\");\n+        assert!(format!(\"{:u}\", 1u8).as_slice() == \"1\");\n+        assert!(format!(\"{:u}\", 1u16).as_slice() == \"1\");\n+        assert!(format!(\"{:u}\", 1u32).as_slice() == \"1\");\n+        assert!(format!(\"{:u}\", 1u64).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1u).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1u8).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1u16).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1u32).as_slice() == \"1\");\n+        assert!(format!(\"{:t}\", 1u64).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1u).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1u8).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1u16).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1u32).as_slice() == \"1\");\n+        assert!(format!(\"{:x}\", 1u64).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1u).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1u8).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1u16).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1u32).as_slice() == \"1\");\n+        assert!(format!(\"{:X}\", 1u64).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1u).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1u8).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1u16).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1u32).as_slice() == \"1\");\n+        assert!(format!(\"{:o}\", 1u64).as_slice() == \"1\");\n \n         // Test a larger number\n-        assert_eq!(format!(\"{:t}\", 55), \"110111\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 55), \"67\".to_owned());\n-        assert_eq!(format!(\"{:d}\", 55), \"55\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 55), \"37\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 55), \"37\".to_owned());\n+        assert!(format!(\"{:t}\", 55).as_slice() == \"110111\");\n+        assert!(format!(\"{:o}\", 55).as_slice() == \"67\");\n+        assert!(format!(\"{:d}\", 55).as_slice() == \"55\");\n+        assert!(format!(\"{:x}\", 55).as_slice() == \"37\");\n+        assert!(format!(\"{:X}\", 55).as_slice() == \"37\");\n     }\n \n     #[test]\n     fn test_format_int_zero() {\n-        assert_eq!(format!(\"{}\", 0i), \"0\".to_owned());\n-        assert_eq!(format!(\"{:d}\", 0i), \"0\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 0i), \"0\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 0i), \"0\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 0i), \"0\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 0i), \"0\".to_owned());\n-\n-        assert_eq!(format!(\"{}\", 0u), \"0\".to_owned());\n-        assert_eq!(format!(\"{:u}\", 0u), \"0\".to_owned());\n-        assert_eq!(format!(\"{:t}\", 0u), \"0\".to_owned());\n-        assert_eq!(format!(\"{:o}\", 0u), \"0\".to_owned());\n-        assert_eq!(format!(\"{:x}\", 0u), \"0\".to_owned());\n-        assert_eq!(format!(\"{:X}\", 0u), \"0\".to_owned());\n+        assert!(format!(\"{}\", 0i).as_slice() == \"0\");\n+        assert!(format!(\"{:d}\", 0i).as_slice() == \"0\");\n+        assert!(format!(\"{:t}\", 0i).as_slice() == \"0\");\n+        assert!(format!(\"{:o}\", 0i).as_slice() == \"0\");\n+        assert!(format!(\"{:x}\", 0i).as_slice() == \"0\");\n+        assert!(format!(\"{:X}\", 0i).as_slice() == \"0\");\n+\n+        assert!(format!(\"{}\", 0u).as_slice() == \"0\");\n+        assert!(format!(\"{:u}\", 0u).as_slice() == \"0\");\n+        assert!(format!(\"{:t}\", 0u).as_slice() == \"0\");\n+        assert!(format!(\"{:o}\", 0u).as_slice() == \"0\");\n+        assert!(format!(\"{:x}\", 0u).as_slice() == \"0\");\n+        assert!(format!(\"{:X}\", 0u).as_slice() == \"0\");\n     }\n \n     #[test]\n     fn test_format_int_flags() {\n-        assert_eq!(format!(\"{:3d}\", 1), \"  1\".to_owned());\n-        assert_eq!(format!(\"{:>3d}\", 1), \"  1\".to_owned());\n-        assert_eq!(format!(\"{:>+3d}\", 1), \" +1\".to_owned());\n-        assert_eq!(format!(\"{:<3d}\", 1), \"1  \".to_owned());\n-        assert_eq!(format!(\"{:#d}\", 1), \"1\".to_owned());\n-        assert_eq!(format!(\"{:#x}\", 10), \"0xa\".to_owned());\n-        assert_eq!(format!(\"{:#X}\", 10), \"0xA\".to_owned());\n-        assert_eq!(format!(\"{:#5x}\", 10), \"  0xa\".to_owned());\n-        assert_eq!(format!(\"{:#o}\", 10), \"0o12\".to_owned());\n-        assert_eq!(format!(\"{:08x}\", 10), \"0000000a\".to_owned());\n-        assert_eq!(format!(\"{:8x}\", 10), \"       a\".to_owned());\n-        assert_eq!(format!(\"{:<8x}\", 10), \"a       \".to_owned());\n-        assert_eq!(format!(\"{:>8x}\", 10), \"       a\".to_owned());\n-        assert_eq!(format!(\"{:#08x}\", 10), \"0x00000a\".to_owned());\n-        assert_eq!(format!(\"{:08d}\", -10), \"-0000010\".to_owned());\n-        assert_eq!(format!(\"{:x}\", -1u8), \"ff\".to_owned());\n-        assert_eq!(format!(\"{:X}\", -1u8), \"FF\".to_owned());\n-        assert_eq!(format!(\"{:t}\", -1u8), \"11111111\".to_owned());\n-        assert_eq!(format!(\"{:o}\", -1u8), \"377\".to_owned());\n-        assert_eq!(format!(\"{:#x}\", -1u8), \"0xff\".to_owned());\n-        assert_eq!(format!(\"{:#X}\", -1u8), \"0xFF\".to_owned());\n-        assert_eq!(format!(\"{:#t}\", -1u8), \"0b11111111\".to_owned());\n-        assert_eq!(format!(\"{:#o}\", -1u8), \"0o377\".to_owned());\n+        assert!(format!(\"{:3d}\", 1).as_slice() == \"  1\");\n+        assert!(format!(\"{:>3d}\", 1).as_slice() == \"  1\");\n+        assert!(format!(\"{:>+3d}\", 1).as_slice() == \" +1\");\n+        assert!(format!(\"{:<3d}\", 1).as_slice() == \"1  \");\n+        assert!(format!(\"{:#d}\", 1).as_slice() == \"1\");\n+        assert!(format!(\"{:#x}\", 10).as_slice() == \"0xa\");\n+        assert!(format!(\"{:#X}\", 10).as_slice() == \"0xA\");\n+        assert!(format!(\"{:#5x}\", 10).as_slice() == \"  0xa\");\n+        assert!(format!(\"{:#o}\", 10).as_slice() == \"0o12\");\n+        assert!(format!(\"{:08x}\", 10).as_slice() == \"0000000a\");\n+        assert!(format!(\"{:8x}\", 10).as_slice() == \"       a\");\n+        assert!(format!(\"{:<8x}\", 10).as_slice() == \"a       \");\n+        assert!(format!(\"{:>8x}\", 10).as_slice() == \"       a\");\n+        assert!(format!(\"{:#08x}\", 10).as_slice() == \"0x00000a\");\n+        assert!(format!(\"{:08d}\", -10).as_slice() == \"-0000010\");\n+        assert!(format!(\"{:x}\", -1u8).as_slice() == \"ff\");\n+        assert!(format!(\"{:X}\", -1u8).as_slice() == \"FF\");\n+        assert!(format!(\"{:t}\", -1u8).as_slice() == \"11111111\");\n+        assert!(format!(\"{:o}\", -1u8).as_slice() == \"377\");\n+        assert!(format!(\"{:#x}\", -1u8).as_slice() == \"0xff\");\n+        assert!(format!(\"{:#X}\", -1u8).as_slice() == \"0xFF\");\n+        assert!(format!(\"{:#t}\", -1u8).as_slice() == \"0b11111111\");\n+        assert!(format!(\"{:#o}\", -1u8).as_slice() == \"0o377\");\n     }\n \n     #[test]\n     fn test_format_int_sign_padding() {\n-        assert_eq!(format!(\"{:+5d}\", 1), \"   +1\".to_owned());\n-        assert_eq!(format!(\"{:+5d}\", -1), \"   -1\".to_owned());\n-        assert_eq!(format!(\"{:05d}\", 1), \"00001\".to_owned());\n-        assert_eq!(format!(\"{:05d}\", -1), \"-0001\".to_owned());\n-        assert_eq!(format!(\"{:+05d}\", 1), \"+0001\".to_owned());\n-        assert_eq!(format!(\"{:+05d}\", -1), \"-0001\".to_owned());\n+        assert!(format!(\"{:+5d}\", 1).as_slice() == \"   +1\");\n+        assert!(format!(\"{:+5d}\", -1).as_slice() == \"   -1\");\n+        assert!(format!(\"{:05d}\", 1).as_slice() == \"00001\");\n+        assert!(format!(\"{:05d}\", -1).as_slice() == \"-0001\");\n+        assert!(format!(\"{:+05d}\", 1).as_slice() == \"+0001\");\n+        assert!(format!(\"{:+05d}\", -1).as_slice() == \"-0001\");\n     }\n \n     #[test]\n     fn test_format_int_twos_complement() {\n         use {i8, i16, i32, i64};\n-        assert_eq!(format!(\"{}\", i8::MIN), \"-128\".to_owned());\n-        assert_eq!(format!(\"{}\", i16::MIN), \"-32768\".to_owned());\n-        assert_eq!(format!(\"{}\", i32::MIN), \"-2147483648\".to_owned());\n-        assert_eq!(format!(\"{}\", i64::MIN), \"-9223372036854775808\".to_owned());\n+        assert!(format!(\"{}\", i8::MIN).as_slice() == \"-128\");\n+        assert!(format!(\"{}\", i16::MIN).as_slice() == \"-32768\");\n+        assert!(format!(\"{}\", i32::MIN).as_slice() == \"-2147483648\");\n+        assert!(format!(\"{}\", i64::MIN).as_slice() == \"-9223372036854775808\");\n     }\n \n     #[test]\n     fn test_format_radix() {\n-        assert_eq!(format!(\"{:04}\", radix(3, 2)), \"0011\".to_owned());\n-        assert_eq!(format!(\"{}\", radix(55, 36)), \"1j\".to_owned());\n+        assert!(format!(\"{:04}\", radix(3, 2)).as_slice() == \"0011\");\n+        assert!(format!(\"{}\", radix(55, 36)).as_slice() == \"1j\");\n     }\n \n     #[test]"}, {"sha": "b72eebe85c587441ea81bf07b21a9e405b3037f1", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -469,6 +469,7 @@ mod tests {\n     use option::{Some,None};\n     use realstd::str::StrAllocating;\n     use realstd::owned::Box;\n+    use realstd::vec::Vec;\n     use raw;\n \n     #[test]\n@@ -568,7 +569,7 @@ mod tests {\n         }\n \n         unsafe {\n-            assert_eq!(box [76u8], transmute(\"L\".to_owned()));\n+            assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_owned()));\n         }\n     }\n }"}, {"sha": "adea8ac630e27b3dcfbb4859f4e6314e6854b251", "filename": "src/libcore/option.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -188,14 +188,14 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<~str>` into an `Option<int>`, preserving the original.\n+    /// Convert an `Option<StrBuf>` into an `Option<int>`, preserving the original.\n     /// The `map` method takes the `self` argument by value, consuming the original,\n     /// so this technique uses `as_ref` to first take an `Option` to a reference\n     /// to the value inside the original.\n     ///\n     /// ```\n-    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n-    /// // First, cast `Option<~str>` to `Option<&~str>` with `as_ref`,\n+    /// let num_as_str: Option<StrBuf> = Some(\"10\".to_strbuf());\n+    /// // First, cast `Option<StrBuf>` to `Option<&StrBuf>` with `as_ref`,\n     /// // then consume *that* with `map`, leaving `num_as_str` on the stack.\n     /// let num_as_int: Option<uint> = num_as_str.as_ref().map(|n| n.len());\n     /// println!(\"still can print num_as_str: {}\", num_as_str);\n@@ -278,10 +278,10 @@ impl<T> Option<T> {\n     ///\n     /// # Example\n     ///\n-    /// Convert an `Option<~str>` into an `Option<uint>`, consuming the original:\n+    /// Convert an `Option<StrBuf>` into an `Option<uint>`, consuming the original:\n     ///\n     /// ```\n-    /// let num_as_str: Option<~str> = Some(\"10\".to_owned());\n+    /// let num_as_str: Option<StrBuf> = Some(\"10\".to_strbuf());\n     /// // `Option::map` takes self *by value*, consuming `num_as_str`\n     /// let num_as_int: Option<uint> = num_as_str.map(|n| n.len());\n     /// ```\n@@ -596,9 +596,10 @@ pub fn collect<T, Iter: Iterator<Option<T>>, V: FromIterator<T>>(iter: Iter) ->\n #[cfg(test)]\n mod tests {\n     use realstd::vec::Vec;\n-    use realstd::str::StrAllocating;\n+    use realstd::strbuf::StrBuf;\n     use option::collect;\n     use prelude::*;\n+    use realstd::str::{Str, StrAllocating};\n     use iter::range;\n \n     use str::StrSlice;\n@@ -619,11 +620,11 @@ mod tests {\n \n     #[test]\n     fn test_get_str() {\n-        let x = \"test\".to_owned();\n-        let addr_x = x.as_ptr();\n+        let x = \"test\".to_strbuf();\n+        let addr_x = x.as_slice().as_ptr();\n         let opt = Some(x);\n         let y = opt.unwrap();\n-        let addr_y = y.as_ptr();\n+        let addr_y = y.as_slice().as_ptr();\n         assert_eq!(addr_x, addr_y);\n     }\n \n@@ -745,7 +746,8 @@ mod tests {\n     #[test]\n     fn test_unwrap() {\n         assert_eq!(Some(1).unwrap(), 1);\n-        assert_eq!(Some(\"hello\".to_owned()).unwrap(), \"hello\".to_owned());\n+        let s = Some(\"hello\".to_strbuf()).unwrap();\n+        assert_eq!(s.as_slice(), \"hello\");\n     }\n \n     #[test]\n@@ -758,7 +760,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_unwrap_fail2() {\n-        let x: Option<~str> = None;\n+        let x: Option<StrBuf> = None;\n         x.unwrap();\n     }\n "}, {"sha": "90b5b0d8753e432af7d80df6f21da82231681f97", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -486,6 +486,7 @@ pub mod ptr_tests {\n     use mem;\n     use libc;\n     use realstd::str;\n+    use realstd::str::Str;\n     use slice::{ImmutableVector, MutableVector};\n \n     #[test]\n@@ -660,7 +661,7 @@ pub mod ptr_tests {\n                     let expected = expected_arr[ctr].with_ref(|buf| {\n                             str::raw::from_c_str(buf)\n                         });\n-                    assert_eq!(actual, expected);\n+                    assert_eq!(actual.as_slice(), expected.as_slice());\n                     ctr += 1;\n                     iteration_count += 1;\n                 });\n@@ -693,7 +694,7 @@ pub mod ptr_tests {\n                     let expected = expected_arr[ctr].with_ref(|buf| {\n                         str::raw::from_c_str(buf)\n                     });\n-                    assert_eq!(actual, expected);\n+                    assert_eq!(actual.as_slice(), expected.as_slice());\n                     ctr += 1;\n                     iteration_count += 1;\n                 });"}, {"sha": "979eeb657b6a62609ac1d7e000a12e8b72129fe4", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -81,7 +81,6 @@ impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n impl<'a> Repr<Slice<u8>> for &'a str {}\n impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Vec<T>> for ~[T] {}\n-impl Repr<*String> for ~str {}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "98d1782f20f53e035f1ce14f2e9054f48734ea8e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -169,20 +169,24 @@\n //! ~~~\n //! use std::io::{File, Open, Write, IoError};\n //!\n-//! struct Info { name: ~str, age: int, rating: int }\n+//! struct Info {\n+//!     name: StrBuf,\n+//!     age: int,\n+//!     rating: int\n+//! }\n //!\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n //!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n //!     // Early return on error\n-//!     match file.write_line(format!(\"name: {}\", info.name)) {\n+//!     match file.write_line(format!(\"name: {}\", info.name).as_slice()) {\n //!         Ok(_) => (),\n //!         Err(e) => return Err(e)\n //!     }\n-//!     match file.write_line(format!(\"age: {}\", info.age)) {\n+//!     match file.write_line(format!(\"age: {}\", info.age).as_slice()) {\n //!         Ok(_) => (),\n //!         Err(e) => return Err(e)\n //!     }\n-//!     return file.write_line(format!(\"rating: {}\", info.rating));\n+//!     return file.write_line(format!(\"rating: {}\", info.rating).as_slice());\n //! }\n //! ~~~\n //!\n@@ -191,14 +195,18 @@\n //! ~~~\n //! use std::io::{File, Open, Write, IoError};\n //!\n-//! struct Info { name: ~str, age: int, rating: int }\n+//! struct Info {\n+//!     name: StrBuf,\n+//!     age: int,\n+//!     rating: int\n+//! }\n //!\n //! fn write_info(info: &Info) -> Result<(), IoError> {\n //!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n //!     // Early return on error\n-//!     try!(file.write_line(format!(\"name: {}\", info.name)));\n-//!     try!(file.write_line(format!(\"age: {}\", info.age)));\n-//!     try!(file.write_line(format!(\"rating: {}\", info.rating)));\n+//!     try!(file.write_line(format!(\"name: {}\", info.name).as_slice()));\n+//!     try!(file.write_line(format!(\"age: {}\", info.age).as_slice()));\n+//!     try!(file.write_line(format!(\"rating: {}\", info.rating).as_slice()));\n //!     return Ok(());\n //! }\n //! ~~~\n@@ -421,10 +429,10 @@ impl<T, E> Result<T, E> {\n     /// let mut sum = 0;\n     ///\n     /// while !reader.eof() {\n-    ///     let line: IoResult<~str> = reader.read_line();\n+    ///     let line: IoResult<StrBuf> = reader.read_line();\n     ///     // Convert the string line to a number using `map` and `from_str`\n     ///     let val: IoResult<int> = line.map(|line| {\n-    ///         from_str::<int>(line).unwrap_or(0)\n+    ///         from_str::<int>(line.as_slice()).unwrap_or(0)\n     ///     });\n     ///     // Add the value if there were no errors, otherwise add 0\n     ///     sum += val.ok().unwrap_or(0);\n@@ -629,69 +637,68 @@ pub fn fold_<T,E,Iter:Iterator<Result<T,E>>>(iterator: Iter) -> Result<(),E> {\n #[cfg(test)]\n mod tests {\n     use realstd::vec::Vec;\n-    use realstd::str::StrAllocating;\n+    use realstd::strbuf::StrBuf;\n \n     use result::{collect, fold, fold_};\n     use prelude::*;\n+    use realstd::str::{Str, StrAllocating};\n     use iter::range;\n \n-    pub fn op1() -> Result<int, ~str> { Ok(666) }\n-    pub fn op2() -> Result<int, ~str> { Err(\"sadface\".to_owned()) }\n+    pub fn op1() -> Result<int, &'static str> { Ok(666) }\n+    pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n \n     #[test]\n     pub fn test_and() {\n         assert_eq!(op1().and(Ok(667)).unwrap(), 667);\n-        assert_eq!(op1().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n+        assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n+                   \"bad\");\n \n-        assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\".to_owned());\n-        assert_eq!(op2().and(Err::<(), ~str>(\"bad\".to_owned())).unwrap_err(), \"sadface\".to_owned());\n+        assert_eq!(op2().and(Ok(667)).unwrap_err(), \"sadface\");\n+        assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n+                   \"sadface\");\n     }\n \n     #[test]\n     pub fn test_and_then() {\n-        assert_eq!(op1().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap(), 667);\n-        assert_eq!(op1().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n-                   \"bad\".to_owned());\n-\n-        assert_eq!(op2().and_then(|i| Ok::<int, ~str>(i + 1)).unwrap_err(),\n-                   \"sadface\".to_owned());\n-        assert_eq!(op2().and_then(|_| Err::<int, ~str>(\"bad\".to_owned())).unwrap_err(),\n-                   \"sadface\".to_owned());\n+        assert_eq!(op1().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap(), 667);\n+        assert_eq!(op1().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+                   \"bad\");\n+\n+        assert_eq!(op2().and_then(|i| Ok::<int, &'static str>(i + 1)).unwrap_err(),\n+                   \"sadface\");\n+        assert_eq!(op2().and_then(|_| Err::<int, &'static str>(\"bad\")).unwrap_err(),\n+                   \"sadface\");\n     }\n \n     #[test]\n     pub fn test_or() {\n         assert_eq!(op1().or(Ok(667)).unwrap(), 666);\n-        assert_eq!(op1().or(Err(\"bad\".to_owned())).unwrap(), 666);\n+        assert_eq!(op1().or(Err(\"bad\")).unwrap(), 666);\n \n         assert_eq!(op2().or(Ok(667)).unwrap(), 667);\n-        assert_eq!(op2().or(Err(\"bad\".to_owned())).unwrap_err(), \"bad\".to_owned());\n+        assert_eq!(op2().or(Err(\"bad\")).unwrap_err(), \"bad\");\n     }\n \n     #[test]\n     pub fn test_or_else() {\n-        assert_eq!(op1().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 666);\n-        assert_eq!(op1().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap(), 666);\n+        assert_eq!(op1().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 666);\n+        assert_eq!(op1().or_else(|e| Err::<int, &'static str>(e)).unwrap(), 666);\n \n-        assert_eq!(op2().or_else(|_| Ok::<int, ~str>(667)).unwrap(), 667);\n-        assert_eq!(op2().or_else(|e| Err::<int, ~str>(e + \"!\")).unwrap_err(),\n-                   \"sadface!\".to_owned());\n+        assert_eq!(op2().or_else(|_| Ok::<int, &'static str>(667)).unwrap(), 667);\n+        assert_eq!(op2().or_else(|e| Err::<int, &'static str>(e)).unwrap_err(),\n+                   \"sadface\");\n     }\n \n     #[test]\n     pub fn test_impl_map() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"),\n-                   Ok(\"ab\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map(|x| x + \"b\"),\n-                   Err(\"a\".to_owned()));\n+        assert!(Ok::<int, int>(1).map(|x| x + 1) == Ok(2));\n+        assert!(Err::<int, int>(1).map(|x| x + 1) == Err(1));\n     }\n \n     #[test]\n     pub fn test_impl_map_err() {\n-        assert_eq!(Ok::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"),\n-                   Ok(\"a\".to_owned()));\n-        assert_eq!(Err::<~str, ~str>(\"a\".to_owned()).map_err(|x| x + \"b\"),\n-                   Err(\"ab\".to_owned()));\n+        assert!(Ok::<int, int>(1).map_err(|x| x + 1) == Ok(1));\n+        assert!(Err::<int, int>(1).map_err(|x| x + 1) == Err(2));\n     }\n \n     #[test]\n@@ -736,34 +743,36 @@ mod tests {\n \n     #[test]\n     pub fn test_fmt_default() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let err: Result<int, ~str> = Err(\"Err\".to_owned());\n+        let ok: Result<int, &'static str> = Ok(100);\n+        let err: Result<int, &'static str> = Err(\"Err\");\n \n-        assert_eq!(format!(\"{}\", ok), \"Ok(100)\".to_owned());\n-        assert_eq!(format!(\"{}\", err), \"Err(Err)\".to_owned());\n+        let s = format!(\"{}\", ok);\n+        assert_eq!(s.as_slice(), \"Ok(100)\");\n+        let s = format!(\"{}\", err);\n+        assert_eq!(s.as_slice(), \"Err(Err)\");\n     }\n \n     #[test]\n     pub fn test_unwrap_or() {\n-        let ok: Result<int, ~str> = Ok(100);\n-        let ok_err: Result<int, ~str> = Err(\"Err\".to_owned());\n+        let ok: Result<int, &'static str> = Ok(100);\n+        let ok_err: Result<int, &'static str> = Err(\"Err\");\n \n         assert_eq!(ok.unwrap_or(50), 100);\n         assert_eq!(ok_err.unwrap_or(50), 50);\n     }\n \n     #[test]\n     pub fn test_unwrap_or_else() {\n-        fn handler(msg: ~str) -> int {\n-            if msg == \"I got this.\".to_owned() {\n+        fn handler(msg: &'static str) -> int {\n+            if msg == \"I got this.\" {\n                 50\n             } else {\n                 fail!(\"BadBad\")\n             }\n         }\n \n-        let ok: Result<int, ~str> = Ok(100);\n-        let ok_err: Result<int, ~str> = Err(\"I got this.\".to_owned());\n+        let ok: Result<int, &'static str> = Ok(100);\n+        let ok_err: Result<int, &'static str> = Err(\"I got this.\");\n \n         assert_eq!(ok.unwrap_or_else(handler), 100);\n         assert_eq!(ok_err.unwrap_or_else(handler), 50);\n@@ -772,15 +781,15 @@ mod tests {\n     #[test]\n     #[should_fail]\n     pub fn test_unwrap_or_else_failure() {\n-        fn handler(msg: ~str) -> int {\n-            if msg == \"I got this.\".to_owned() {\n+        fn handler(msg: &'static str) -> int {\n+            if msg == \"I got this.\" {\n                 50\n             } else {\n                 fail!(\"BadBad\")\n             }\n         }\n \n-        let bad_err: Result<int, ~str> = Err(\"Unrecoverable mess.\".to_owned());\n+        let bad_err: Result<int, &'static str> = Err(\"Unrecoverable mess.\");\n         let _ : int = bad_err.unwrap_or_else(handler);\n     }\n }"}, {"sha": "9a0e3ad7ca4ac912fd01d238e171f8baec3d8d79", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 4, "deletions": 108, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -10,9 +10,9 @@\n \n // As noted by this file name, this file should not exist. This file should not\n // exist because it performs allocations which libcore is not allowed to do. The\n-// reason for this file's existence is that the `~[T]` and `~str` types are\n-// language-defined types. Traits are defined in libcore, such as `Clone`, which\n-// these types need to implement, but the implementation can only be found in\n+// reason for this file's existence is that the `~[T]` type is a language-\n+// defined type. Traits are defined in libcore, such as `Clone`, which these\n+// types need to implement, but the implementation can only be found in\n // libcore.\n //\n // Plan of attack for solving this problem:\n@@ -24,23 +24,18 @@\n //\n // Currently, no progress has been made on this list.\n \n-use char::Char;\n use clone::Clone;\n use container::Container;\n-use default::Default;\n use finally::try_finally;\n use intrinsics;\n-use iter::{range, Iterator, FromIterator};\n+use iter::{range, Iterator};\n use mem;\n use num::{CheckedMul, CheckedAdd};\n use option::{Some, None};\n use ptr::RawPtr;\n use ptr;\n use raw::Vec;\n use slice::ImmutableVector;\n-use str::StrSlice;\n-\n-#[cfg(not(test))] use ops::Add;\n \n #[allow(ctypes)]\n extern {\n@@ -60,105 +55,6 @@ unsafe fn alloc(cap: uint) -> *mut Vec<()> {\n     ret\n }\n \n-// Strings\n-\n-impl Default for ~str {\n-    fn default() -> ~str {\n-        unsafe {\n-            // Get some memory\n-            let ptr = alloc(0);\n-\n-            // Initialize the memory\n-            (*ptr).fill = 0;\n-            (*ptr).alloc = 0;\n-\n-            mem::transmute(ptr)\n-        }\n-    }\n-}\n-\n-impl Clone for ~str {\n-    fn clone(&self) -> ~str {\n-        // Don't use the clone() implementation above because it'll start\n-        // requiring the eh_personality lang item (no fun)\n-        unsafe {\n-            let bytes = self.as_bytes().as_ptr();\n-            let len = self.len();\n-\n-            let ptr = alloc(len) as *mut Vec<u8>;\n-            ptr::copy_nonoverlapping_memory(&mut (*ptr).data, bytes, len);\n-            (*ptr).fill = len;\n-            (*ptr).alloc = len;\n-\n-            mem::transmute(ptr)\n-        }\n-    }\n-}\n-\n-impl FromIterator<char> for ~str {\n-    #[inline]\n-    fn from_iter<T: Iterator<char>>(mut iterator: T) -> ~str {\n-        let (lower, _) = iterator.size_hint();\n-        let mut cap = if lower == 0 {16} else {lower};\n-        let mut len = 0;\n-        let mut tmp = [0u8, ..4];\n-\n-        unsafe {\n-            let mut ptr = alloc(cap) as *mut Vec<u8>;\n-            let mut ret = mem::transmute(ptr);\n-            for ch in iterator {\n-                let amt = ch.encode_utf8(tmp);\n-\n-                if len + amt > cap {\n-                    cap = cap.checked_mul(&2).unwrap();\n-                    if cap < len + amt {\n-                        cap = len + amt;\n-                    }\n-                    let ptr2 = alloc(cap) as *mut Vec<u8>;\n-                    ptr::copy_nonoverlapping_memory(&mut (*ptr2).data,\n-                                                    &(*ptr).data,\n-                                                    len);\n-                    // FIXME: #13994: port to the sized deallocation API when available\n-                    rust_deallocate(ptr as *u8, 0, 8);\n-                    mem::forget(ret);\n-                    ret = mem::transmute(ptr2);\n-                    ptr = ptr2;\n-                }\n-\n-                let base = &mut (*ptr).data as *mut u8;\n-                for byte in tmp.slice_to(amt).iter() {\n-                    *base.offset(len as int) = *byte;\n-                    len += 1;\n-                }\n-                (*ptr).fill = len;\n-            }\n-            ret\n-        }\n-    }\n-}\n-\n-#[cfg(not(test))]\n-impl<'a> Add<&'a str,~str> for &'a str {\n-    #[inline]\n-    fn add(&self, rhs: & &'a str) -> ~str {\n-        let amt = self.len().checked_add(&rhs.len()).unwrap();\n-        unsafe {\n-            let ptr = alloc(amt) as *mut Vec<u8>;\n-            let base = &mut (*ptr).data as *mut _;\n-            ptr::copy_nonoverlapping_memory(base,\n-                                            self.as_bytes().as_ptr(),\n-                                            self.len());\n-            let base = base.offset(self.len() as int);\n-            ptr::copy_nonoverlapping_memory(base,\n-                                            rhs.as_bytes().as_ptr(),\n-                                            rhs.len());\n-            (*ptr).fill = amt;\n-            (*ptr).alloc = amt;\n-            mem::transmute(ptr)\n-        }\n-    }\n-}\n-\n // Arrays\n \n impl<A: Clone> Clone for ~[A] {"}, {"sha": "0b264b1724df022fe67ed45d71220ef59b0313c2", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -25,7 +25,7 @@ use iter::range;\n use num::Saturating;\n use option::{None, Option, Some};\n use raw::Repr;\n-use slice::{ImmutableVector, Vector};\n+use slice::ImmutableVector;\n use slice;\n use uint;\n \n@@ -596,20 +596,6 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n     eq_slice_(a, b)\n }\n \n-/// Bytewise string equality\n-#[cfg(not(test))]\n-#[lang=\"uniq_str_eq\"]\n-#[inline]\n-pub fn eq(a: &~str, b: &~str) -> bool {\n-    eq_slice(*a, *b)\n-}\n-\n-#[cfg(test)]\n-#[inline]\n-pub fn eq(a: &~str, b: &~str) -> bool {\n-    eq_slice(*a, *b)\n-}\n-\n /*\n Section: Misc\n */\n@@ -976,11 +962,6 @@ pub mod traits {\n         }\n     }\n \n-    impl TotalOrd for ~str {\n-        #[inline]\n-        fn cmp(&self, other: &~str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n     impl<'a> Eq for &'a str {\n         #[inline]\n         fn eq(&self, other: & &'a str) -> bool {\n@@ -990,36 +971,17 @@ pub mod traits {\n         fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n     }\n \n-    impl Eq for ~str {\n-        #[inline]\n-        fn eq(&self, other: &~str) -> bool {\n-            eq_slice((*self), (*other))\n-        }\n-    }\n-\n     impl<'a> TotalEq for &'a str {}\n \n-    impl TotalEq for ~str {}\n-\n     impl<'a> Ord for &'a str {\n         #[inline]\n         fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n     }\n \n-    impl Ord for ~str {\n-        #[inline]\n-        fn lt(&self, other: &~str) -> bool { self.cmp(other) == Less }\n-    }\n-\n     impl<'a, S: Str> Equiv<S> for &'a str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n-\n-    impl<'a, S: Str> Equiv<S> for ~str {\n-        #[inline]\n-        fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n-    }\n }\n \n #[cfg(test)]\n@@ -1036,23 +998,13 @@ impl<'a> Str for &'a str {\n     fn as_slice<'a>(&'a self) -> &'a str { *self }\n }\n \n-impl<'a> Str for ~str {\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a str { let s: &'a str = *self; s }\n-}\n-\n impl<'a> Container for &'a str {\n     #[inline]\n     fn len(&self) -> uint {\n         self.repr().len\n     }\n }\n \n-impl Container for ~str {\n-    #[inline]\n-    fn len(&self) -> uint { self.as_slice().len() }\n-}\n-\n /// Methods for string slices\n pub trait StrSlice<'a> {\n     /// Returns true if one string contains another"}, {"sha": "0e21c95807d09af66f542f8e2fb99c9cd3a4d254", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -246,11 +246,11 @@ mod tests {\n     use super::*;\n     use clone::Clone;\n     use cmp::*;\n-    use realstd::str::StrAllocating;\n+    use realstd::str::{Str, StrAllocating};\n \n     #[test]\n     fn test_clone() {\n-        let a = (1, \"2\".to_owned());\n+        let a = (1, \"2\");\n         let b = a.clone();\n         assert_eq!(a, b);\n     }\n@@ -323,8 +323,11 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        assert_eq!(format!(\"{}\", (1,)), \"(1,)\".to_owned());\n-        assert_eq!(format!(\"{}\", (1, true)), \"(1, true)\".to_owned());\n-        assert_eq!(format!(\"{}\", (1, \"hi\".to_owned(), true)), \"(1, hi, true)\".to_owned());\n+        let s = format!(\"{}\", (1,));\n+        assert_eq!(s.as_slice(), \"(1,)\");\n+        let s = format!(\"{}\", (1, true));\n+        assert_eq!(s.as_slice(), \"(1, true)\");\n+        let s = format!(\"{}\", (1, \"hi\", true));\n+        assert_eq!(s.as_slice(), \"(1, hi, true)\");\n     }\n }"}, {"sha": "e4b1278f3d9dbb68731a9dc99ed78f3cf039424c", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -690,25 +690,25 @@ mod test {\n \n         let pat = Pattern::new(\"a[0-9]b\");\n         for i in range(0, 10) {\n-            assert!(pat.matches(format!(\"a{}b\", i)));\n+            assert!(pat.matches(format!(\"a{}b\", i).as_slice()));\n         }\n         assert!(!pat.matches(\"a_b\"));\n \n         let pat = Pattern::new(\"a[!0-9]b\");\n         for i in range(0, 10) {\n-            assert!(!pat.matches(format!(\"a{}b\", i)));\n+            assert!(!pat.matches(format!(\"a{}b\", i).as_slice()));\n         }\n         assert!(pat.matches(\"a_b\"));\n \n         let pats = [\"[a-z123]\", \"[1a-z23]\", \"[123a-z]\"];\n         for &p in pats.iter() {\n             let pat = Pattern::new(p);\n             for c in \"abcdefghijklmnopqrstuvwxyz\".chars() {\n-                assert!(pat.matches(c.to_str()));\n+                assert!(pat.matches(c.to_str().as_slice()));\n             }\n             for c in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".chars() {\n                 let options = MatchOptions {case_sensitive: false, .. MatchOptions::new()};\n-                assert!(pat.matches_with(c.to_str(), options));\n+                assert!(pat.matches_with(c.to_str().as_slice(), options));\n             }\n             assert!(pat.matches(\"1\"));\n             assert!(pat.matches(\"2\"));"}, {"sha": "f320aca2bfcbf54d1f26a5c81f694cb513b592b8", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -450,7 +450,9 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n                                   libc::VOLUME_NAME_DOS)\n     });\n     let ret = match ret {\n-        Some(ref s) if s.starts_with(r\"\\\\?\\\") => Ok(Path::new(s.slice_from(4))),\n+        Some(ref s) if s.as_slice().starts_with(r\"\\\\?\\\") => {\n+            Ok(Path::new(s.as_slice().slice_from(4)))\n+        }\n         Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),\n     };"}, {"sha": "80b00dfb3fe57dbdae73621d602058401a6827da", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -323,7 +323,7 @@ fn spawn_process_os(cfg: ProcessConfig, in_fd: c_int, out_fd: c_int, err_fd: c_i\n \n         with_envp(cfg.env, |envp| {\n             with_dirp(cfg.cwd, |dirp| {\n-                os::win32::as_mut_utf16_p(cmd_str, |cmdp| {\n+                os::win32::as_mut_utf16_p(cmd_str.as_slice(), |cmdp| {\n                     let created = CreateProcessW(ptr::null(),\n                                                  cmdp,\n                                                  ptr::mut_null(),\n@@ -396,7 +396,7 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n }\n \n #[cfg(windows)]\n-fn make_command_line(prog: &CString, args: &[CString]) -> ~str {\n+fn make_command_line(prog: &CString, args: &[CString]) -> StrBuf {\n     let mut cmd = StrBuf::new();\n     append_arg(&mut cmd, prog.as_str()\n                              .expect(\"expected program name to be utf-8 encoded\"));\n@@ -405,7 +405,7 @@ fn make_command_line(prog: &CString, args: &[CString]) -> ~str {\n         append_arg(&mut cmd, arg.as_str()\n                                 .expect(\"expected argument to be utf-8 encoded\"));\n     }\n-    return cmd.into_owned();\n+    return cmd;\n \n     fn append_arg(cmd: &mut StrBuf, arg: &str) {\n         let quote = arg.chars().any(|c| c == ' ' || c == '\\t');\n@@ -1093,7 +1093,7 @@ mod tests {\n         use std::c_str::CString;\n         use super::make_command_line;\n \n-        fn test_wrapper(prog: &str, args: &[&str]) -> ~str {\n+        fn test_wrapper(prog: &str, args: &[&str]) -> StrBuf {\n             make_command_line(&prog.to_c_str(),\n                               args.iter()\n                                   .map(|a| a.to_c_str())"}, {"sha": "9267aea01b4e251b1cdee9ccc20e9adb3a604a17", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 211, "deletions": 48, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -634,7 +634,7 @@ impl ToStrRadix for BigUint {\n             let mut s = StrBuf::with_capacity(v.len() * l);\n             for n in v.iter().rev() {\n                 let ss = (*n as uint).to_str_radix(radix);\n-                s.push_str(\"0\".repeat(l - ss.len()));\n+                s.push_str(\"0\".repeat(l - ss.len()).as_slice());\n                 s.push_str(ss.as_slice());\n             }\n             s.as_slice().trim_left_chars('0').to_strbuf()\n@@ -1478,29 +1478,112 @@ mod biguint_tests {\n         check(\"0\", 3, \"0\");\n         check(\"1\", 3, \"8\");\n \n-        check(\"1\" + \"0000\" + \"0000\" + \"0000\" + \"0001\" + \"0000\" + \"0000\" + \"0000\" + \"0001\", 3,\n-              \"8\" + \"0000\" + \"0000\" + \"0000\" + \"0008\" + \"0000\" + \"0000\" + \"0000\" + \"0008\");\n-        check(\"1\" + \"0000\" + \"0001\" + \"0000\" + \"0001\", 2,\n-              \"4\" + \"0000\" + \"0004\" + \"0000\" + \"0004\");\n-        check(\"1\" + \"0001\" + \"0001\", 1,\n-              \"2\" + \"0002\" + \"0002\");\n-\n-        check(\"\"  + \"4000\" + \"0000\" + \"0000\" + \"0000\", 3,\n-              \"2\" + \"0000\" + \"0000\" + \"0000\" + \"0000\");\n-        check(\"\"  + \"4000\" + \"0000\", 2,\n-              \"1\" + \"0000\" + \"0000\");\n-        check(\"\"  + \"4000\", 2,\n-              \"1\" + \"0000\");\n-\n-        check(\"\"  + \"4000\" + \"0000\" + \"0000\" + \"0000\", 67,\n-              \"2\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\" + \"0000\");\n-        check(\"\"  + \"4000\" + \"0000\", 35,\n-              \"2\" + \"0000\" + \"0000\" + \"0000\" + \"0000\");\n-        check(\"\"  + \"4000\", 19,\n-              \"2\" + \"0000\" + \"0000\");\n-\n-        check(\"\"  + \"fedc\" + \"ba98\" + \"7654\" + \"3210\" + \"fedc\" + \"ba98\" + \"7654\" + \"3210\", 4,\n-              \"f\" + \"edcb\" + \"a987\" + \"6543\" + \"210f\" + \"edcb\" + \"a987\" + \"6543\" + \"2100\");\n+        check(\"1\\\n+               0000\\\n+               0000\\\n+               0000\\\n+               0001\\\n+               0000\\\n+               0000\\\n+               0000\\\n+               0001\",\n+              3,\n+              \"8\\\n+               0000\\\n+               0000\\\n+               0000\\\n+               0008\\\n+               0000\\\n+               0000\\\n+               0000\\\n+               0008\");\n+        check(\"1\\\n+               0000\\\n+               0001\\\n+               0000\\\n+               0001\",\n+              2,\n+              \"4\\\n+               0000\\\n+               0004\\\n+               0000\\\n+               0004\");\n+        check(\"1\\\n+               0001\\\n+               0001\",\n+              1,\n+              \"2\\\n+               0002\\\n+               0002\");\n+\n+        check(\"\\\n+              4000\\\n+              0000\\\n+              0000\\\n+              0000\",\n+              3,\n+              \"2\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\");\n+        check(\"4000\\\n+              0000\",\n+              2,\n+              \"1\\\n+              0000\\\n+              0000\");\n+        check(\"4000\",\n+              2,\n+              \"1\\\n+              0000\");\n+\n+        check(\"4000\\\n+              0000\\\n+              0000\\\n+              0000\",\n+              67,\n+              \"2\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\");\n+        check(\"4000\\\n+              0000\",\n+              35,\n+              \"2\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\");\n+        check(\"4000\",\n+              19,\n+              \"2\\\n+              0000\\\n+              0000\");\n+\n+        check(\"fedc\\\n+              ba98\\\n+              7654\\\n+              3210\\\n+              fedc\\\n+              ba98\\\n+              7654\\\n+              3210\",\n+              4,\n+              \"f\\\n+              edcb\\\n+              a987\\\n+              6543\\\n+              210f\\\n+              edcb\\\n+              a987\\\n+              6543\\\n+              2100\");\n         check(\"88887777666655554444333322221111\", 16,\n               \"888877776666555544443333222211110000\");\n     }\n@@ -1517,28 +1600,107 @@ mod biguint_tests {\n         check(\"0\", 3, \"0\");\n         check(\"f\", 3, \"1\");\n \n-        check(\"1\" + \"0000\" + \"0000\" + \"0000\" + \"0001\" + \"0000\" + \"0000\" + \"0000\" + \"0001\", 3,\n-              \"\"  + \"2000\" + \"0000\" + \"0000\" + \"0000\" + \"2000\" + \"0000\" + \"0000\" + \"0000\");\n-        check(\"1\" + \"0000\" + \"0001\" + \"0000\" + \"0001\", 2,\n-              \"\"  + \"4000\" + \"0000\" + \"4000\" + \"0000\");\n-        check(\"1\" + \"0001\" + \"0001\", 1,\n-              \"\"  + \"8000\" + \"8000\");\n-\n-        check(\"2\" + \"0000\" + \"0000\" + \"0000\" + \"0001\" + \"0000\" + \"0000\" + \"0000\" + \"0001\", 67,\n-              \"\"  + \"4000\" + \"0000\" + \"0000\" + \"0000\");\n-        check(\"2\" + \"0000\" + \"0001\" + \"0000\" + \"0001\", 35,\n-              \"\"  + \"4000\" + \"0000\");\n-        check(\"2\" + \"0001\" + \"0001\", 19,\n-              \"\"  + \"4000\");\n-\n-        check(\"1\" + \"0000\" + \"0000\" + \"0000\" + \"0000\", 1,\n-              \"\"  + \"8000\" + \"0000\" + \"0000\" + \"0000\");\n-        check(\"1\" + \"0000\" + \"0000\", 1,\n-              \"\"  + \"8000\" + \"0000\");\n-        check(\"1\" + \"0000\", 1,\n-              \"\"  + \"8000\");\n-        check(\"f\" + \"edcb\" + \"a987\" + \"6543\" + \"210f\" + \"edcb\" + \"a987\" + \"6543\" + \"2100\", 4,\n-              \"\"  + \"fedc\" + \"ba98\" + \"7654\" + \"3210\" + \"fedc\" + \"ba98\" + \"7654\" + \"3210\");\n+        check(\"1\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0001\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0001\",\n+              3,\n+              \"2000\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              2000\\\n+              0000\\\n+              0000\\\n+              0000\");\n+        check(\"1\\\n+              0000\\\n+              0001\\\n+              0000\\\n+              0001\",\n+              2,\n+              \"4000\\\n+              0000\\\n+              4000\\\n+              0000\");\n+        check(\"1\\\n+              0001\\\n+              0001\",\n+              1,\n+              \"8000\\\n+              8000\");\n+\n+        check(\"2\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0001\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0001\",\n+              67,\n+              \"4000\\\n+              0000\\\n+              0000\\\n+              0000\");\n+        check(\"2\\\n+              0000\\\n+              0001\\\n+              0000\\\n+              0001\",\n+              35,\n+              \"4000\\\n+              0000\");\n+        check(\"2\\\n+              0001\\\n+              0001\",\n+              19,\n+              \"4000\");\n+\n+        check(\"1\\\n+              0000\\\n+              0000\\\n+              0000\\\n+              0000\",\n+              1,\n+              \"8000\\\n+              0000\\\n+              0000\\\n+              0000\");\n+        check(\"1\\\n+              0000\\\n+              0000\",\n+              1,\n+              \"8000\\\n+              0000\");\n+        check(\"1\\\n+              0000\",\n+              1,\n+              \"8000\");\n+        check(\"f\\\n+              edcb\\\n+              a987\\\n+              6543\\\n+              210f\\\n+              edcb\\\n+              a987\\\n+              6543\\\n+              2100\",\n+              4,\n+              \"fedc\\\n+              ba98\\\n+              7654\\\n+              3210\\\n+              fedc\\\n+              ba98\\\n+              7654\\\n+              3210\");\n \n         check(\"888877776666555544443333222211110000\", 16,\n               \"88887777666655554444333322221111\");\n@@ -2545,7 +2707,7 @@ mod bigint_tests {\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n             let n: BigInt = FromPrimitive::from_int(n).unwrap();\n-            assert!(ans == n.to_str_radix(10));\n+            assert!(ans == n.to_str_radix(10).as_slice());\n         }\n         check(10, \"10\");\n         check(1, \"1\");\n@@ -2574,7 +2736,8 @@ mod bigint_tests {\n \n         // issue 10522, this hit an edge case that caused it to\n         // attempt to allocate a vector of size (-1u) == huge.\n-        let x: BigInt = from_str(\"1\" + \"0\".repeat(36)).unwrap();\n+        let x: BigInt =\n+            from_str(format!(\"1{}\", \"0\".repeat(36)).as_slice()).unwrap();\n         let _y = x.to_str();\n     }\n "}, {"sha": "6191b93ff8f301b5a059e939f285457ecac8583c", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -584,7 +584,7 @@ mod test {\n     #[test]\n     fn test_to_from_str_radix() {\n         fn test(r: Rational, s: StrBuf, n: uint) {\n-            assert_eq!(FromStrRadix::from_str_radix(s.to_owned(), n),\n+            assert_eq!(FromStrRadix::from_str_radix(s.as_slice(), n),\n                        Some(r));\n             assert_eq!(r.to_str_radix(n).to_strbuf(), s);\n         }"}, {"sha": "beefda07f0a0db8939899f4d912a79d7893781e9", "filename": "src/libregex/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibregex%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibregex%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse%2Fmod.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -513,11 +513,11 @@ impl<'a> Parser<'a> {\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n-        if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner));\n+        if !inner.as_slice().contains(\",\") {\n+            min = try!(self.parse_uint(inner.as_slice()));\n             max = Some(min);\n         } else {\n-            let pieces: Vec<&str> = inner.splitn(',', 1).collect();\n+            let pieces: Vec<&str> = inner.as_slice().splitn(',', 1).collect();\n             let (smin, smax) = (*pieces.get(0), *pieces.get(1));\n             if smin.len() == 0 {\n                 return self.err(\"Max repetitions cannot be specified \\"}, {"sha": "6fcbcbd265aa19aea069c3684c9b9a2600eb820d", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -20,38 +20,40 @@ fn bench_assert_match(b: &mut Bencher, re: Regex, text: &str) {\n #[bench]\n fn no_exponential(b: &mut Bencher) {\n     let n = 100;\n-    let re = Regex::new(\"a?\".repeat(n) + \"a\".repeat(n)).unwrap();\n+    let re = Regex::new(format!(\"{}{}\",\n+                                \"a?\".repeat(n),\n+                                \"a\".repeat(n)).as_slice()).unwrap();\n     let text = \"a\".repeat(n);\n-    bench_assert_match(b, re, text);\n+    bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn literal(b: &mut Bencher) {\n     let re = regex!(\"y\");\n-    let text = \"x\".repeat(50) + \"y\";\n-    bench_assert_match(b, re, text);\n+    let text = format!(\"{}y\", \"x\".repeat(50));\n+    bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn not_literal(b: &mut Bencher) {\n     let re = regex!(\".y\");\n-    let text = \"x\".repeat(50) + \"y\";\n-    bench_assert_match(b, re, text);\n+    let text = format!(\"{}y\", \"x\".repeat(50));\n+    bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn match_class(b: &mut Bencher) {\n     let re = regex!(\"[abcdw]\");\n-    let text = \"xxxx\".repeat(20) + \"w\";\n-    bench_assert_match(b, re, text);\n+    let text = format!(\"{}w\", \"xxxx\".repeat(20));\n+    bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n fn match_class_in_range(b: &mut Bencher) {\n     // 'b' is between 'a' and 'c', so the class range checking doesn't help.\n     let re = regex!(\"[ac]\");\n-    let text = \"bbbb\".repeat(20) + \"c\";\n-    bench_assert_match(b, re, text);\n+    let text = format!(\"{}c\", \"bbbb\".repeat(20));\n+    bench_assert_match(b, re, text.as_slice());\n }\n \n #[bench]\n@@ -75,7 +77,7 @@ fn anchored_literal_short_non_match(b: &mut Bencher) {\n fn anchored_literal_long_non_match(b: &mut Bencher) {\n     let re = regex!(\"^zbc(d|e)\");\n     let text = \"abcdefghijklmnopqrstuvwxyz\".repeat(15);\n-    b.iter(|| re.is_match(text));\n+    b.iter(|| re.is_match(text.as_slice()));\n }\n \n #[bench]\n@@ -89,7 +91,7 @@ fn anchored_literal_short_match(b: &mut Bencher) {\n fn anchored_literal_long_match(b: &mut Bencher) {\n     let re = regex!(\"^.bc(d|e)\");\n     let text = \"abcdefghijklmnopqrstuvwxyz\".repeat(15);\n-    b.iter(|| re.is_match(text));\n+    b.iter(|| re.is_match(text.as_slice()));\n }\n \n #[bench]"}, {"sha": "68320e8edd301e6ddb757c03f82df4118688330f", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -82,7 +82,7 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n         // error is logged in 'parse' with cx.span_err\n         None => return DummyResult::any(sp),\n     };\n-    let re = match Regex::new(regex.to_owned()) {\n+    let re = match Regex::new(regex.as_slice()) {\n         Ok(re) => re,\n         Err(err) => {\n             cx.span_err(sp, err.to_str().as_slice());"}, {"sha": "57f3824ecc560819bde056d1db54baf735092899", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -62,7 +62,9 @@ pub fn llvm_err(sess: &Session, msg: StrBuf) -> ! {\n         } else {\n             let err = CString::new(cstr, true);\n             let err = str::from_utf8_lossy(err.as_bytes());\n-            sess.fatal((msg.as_slice() + \": \" + err.as_slice()));\n+            sess.fatal(format!(\"{}: {}\",\n+                               msg.as_slice(),\n+                               err.as_slice()).as_slice());\n         }\n     }\n }\n@@ -647,7 +649,7 @@ pub fn sanitize(s: &str) -> StrBuf {\n     if result.len() > 0u &&\n         result.as_slice()[0] != '_' as u8 &&\n         ! char::is_XID_start(result.as_slice()[0] as char) {\n-        return (\"_\" + result.as_slice()).to_strbuf();\n+        return format!(\"_{}\", result.as_slice()).to_strbuf();\n     }\n \n     return result;"}, {"sha": "8258fb5762be395becdf07b2749ee5b66a798e87", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -59,7 +59,7 @@ pub fn get_rpath_flags(sess: &Session, out_filename: &Path) -> Vec<StrBuf> {\n pub fn rpaths_to_flags(rpaths: &[StrBuf]) -> Vec<StrBuf> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push((\"-Wl,-rpath,\" + (*rpath).as_slice()).to_strbuf());\n+        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).as_slice()));\n     }\n     return ret;\n }\n@@ -132,8 +132,9 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n     let relative = lib.path_relative_from(&output);\n     let relative = relative.expect(\"could not create rpath relative to output\");\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    (prefix + \"/\" + relative.as_str()\n-                            .expect(\"non-utf8 component in path\")).to_strbuf()\n+    format!(\"{}/{}\",\n+            prefix,\n+            relative.as_str().expect(\"non-utf8 component in path\"))\n }\n \n pub fn get_install_prefix_rpath(sysroot: &Path, target_triple: &str) -> StrBuf {"}, {"sha": "d80cf72bb466d8c4f89cc76747c2aa69df2a97d5", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -469,8 +469,8 @@ pub fn build_target_config(sopts: &Options) -> Config {\n     let arch = match get_arch(sopts.target_triple.as_slice()) {\n       Some(arch) => arch,\n       None => {\n-          early_error(\"unknown architecture: \" +\n-                      sopts.target_triple.as_slice())\n+          early_error(format!(\"unknown architecture: {}\",\n+                              sopts.target_triple.as_slice()).as_slice())\n       }\n     };\n     let (int_type, uint_type) = match arch {"}, {"sha": "21a7fc8d15044f5bc72a36b5c1d0f9ef7574188c", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -259,7 +259,9 @@ impl<'a> Visitor<()> for Context<'a> {\n         else {\n             for &quote in quotes.iter() {\n                 if id == token::str_to_ident(quote) {\n-                  self.gate_feature(\"quote\", path.span, quote + msg);\n+                  self.gate_feature(\"quote\",\n+                                    path.span,\n+                                    format!(\"{}{}\", quote, msg).as_slice());\n                 }\n             }\n         }"}, {"sha": "e08ab33808ac95afcca84df0b8b2e8a61b6d095d", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -163,7 +163,8 @@ pub fn register_static(ccx: &CrateContext,\n                 });\n                 lib::llvm::SetLinkage(g1, linkage);\n \n-                let real_name = \"_rust_extern_with_linkage_\" + ident.get();\n+                let mut real_name = \"_rust_extern_with_linkage_\".to_strbuf();\n+                real_name.push_str(ident.get());\n                 let g2 = real_name.with_c_str(|buf| {\n                     llvm::LLVMAddGlobal(ccx.llmod, llty.to_ref(), buf)\n                 });"}, {"sha": "a65802d2c36ff1c498a9834632e1712093da5c5d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -117,9 +117,9 @@ impl<'a, 'b> Reflector<'a, 'b> {\n                      bracket_name: &str,\n                      extra: &[ValueRef],\n                      inner: |&mut Reflector|) {\n-        self.visit(\"enter_\" + bracket_name, extra);\n+        self.visit(format!(\"enter_{}\", bracket_name).as_slice(), extra);\n         inner(self);\n-        self.visit(\"leave_\" + bracket_name, extra);\n+        self.visit(format!(\"leave_{}\", bracket_name).as_slice(), extra);\n     }\n \n     pub fn leaf(&mut self, name: &str) {"}, {"sha": "19233f0a59fe53b799a71bf77e4fc179f075dda4", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -85,7 +85,7 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n     $(\n         if missing.contains(&lang_items::$item) && items.$name().is_none() {\n             sess.err(format!(\"language item required, but not found: `{}`\",\n-                             stringify!($name)));\n+                             stringify!($name)).as_slice());\n \n         }\n     )*\n@@ -100,7 +100,7 @@ impl<'a> Context<'a> {\n         } else)* {\n             self.sess.span_err(span,\n                                format!(\"unknown external lang item: `{}`\",\n-                                       name));\n+                                       name).as_slice());\n         }\n     }\n }"}, {"sha": "fb2a80333e82d0e6377c70458135cbb240b3fe19", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -1015,7 +1015,10 @@ impl Clean<Type> for ty::t {\n                 let fqn: Vec<StrBuf> = fqn.move_iter().map(|i| {\n                     i.to_str().to_strbuf()\n                 }).collect();\n-                let mut path = external_path(fqn.last().unwrap().to_str());\n+                let mut path = external_path(fqn.last()\n+                                                .unwrap()\n+                                                .to_str()\n+                                                .as_slice());\n                 let kind = match ty::get(*self).sty {\n                     ty::ty_struct(..) => TypeStruct,\n                     ty::ty_trait(..) => TypeTrait,"}, {"sha": "65bc9f544f6f726b17fba79d15ef94da62b3a549", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -206,7 +206,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n         let amt = path.segments.len() - 1;\n         match rel_root {\n             Some(root) => {\n-                let mut root = StrBuf::from_str(root);\n+                let mut root = StrBuf::from_str(root.as_slice());\n                 for seg in path.segments.slice_to(amt).iter() {\n                     if \"super\" == seg.name.as_slice() ||\n                             \"self\" == seg.name.as_slice() {"}, {"sha": "5f3c19d57549dcdff4d15525a9ae66b05d55849a", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -177,8 +177,9 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 };\n \n                 if !rendered {\n-                    let output = highlight::highlight(text, None).as_slice()\n-                                                                 .to_c_str();\n+                    let output = highlight::highlight(text.as_slice(),\n+                                                      None).as_slice()\n+                                                           .to_c_str();\n                     output.with_ref(|r| {\n                         hoedown_buffer_puts(ob, r)\n                     })\n@@ -202,7 +203,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = (s.words().map(|s| {\n+        let id = (s.as_slice().words().map(|s| {\n             match s.to_ascii_opt() {\n                 Some(s) => s.to_lower().into_str().to_strbuf(),\n                 None => s.to_strbuf()"}, {"sha": "8744553955a632634547f8825054f74cbf368240", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -971,7 +971,7 @@ impl Context {\n             // does make formatting *a lot* nicer.\n             current_location_key.replace(Some(cx.current.clone()));\n \n-            let mut title = StrBuf::from_str(cx.current.connect(\"::\"));\n+            let mut title = cx.current.connect(\"::\");\n             if pushname {\n                 if title.len() > 0 {\n                     title.push_str(\"::\");\n@@ -1141,7 +1141,7 @@ fn item_path(item: &clean::Item) -> StrBuf {\n }\n \n fn full_path(cx: &Context, item: &clean::Item) -> StrBuf {\n-    let mut s = StrBuf::from_str(cx.current.connect(\"::\"));\n+    let mut s = cx.current.connect(\"::\");\n     s.push_str(\"::\");\n     s.push_str(item.name.get_ref().as_slice());\n     return s"}, {"sha": "da18b7e8e9278e9c09e7bf4bf6c472944131d690", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -346,14 +346,14 @@ mod unindent_tests {\n     #[test]\n     fn should_unindent() {\n         let s = \"    line1\\n    line2\".to_owned();\n-        let r = unindent(s);\n+        let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n         let s = \"    line1\\n\\n    line2\".to_owned();\n-        let r = unindent(s);\n+        let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\n\\nline2\");\n     }\n \n@@ -362,7 +362,7 @@ mod unindent_tests {\n         // Line 2 is indented another level beyond the\n         // base indentation and should be preserved\n         let s = \"    line1\\n\\n        line2\".to_owned();\n-        let r = unindent(s);\n+        let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n     }\n \n@@ -374,14 +374,14 @@ mod unindent_tests {\n         // #[doc = \"Start way over here\n         //          and continue here\"]\n         let s = \"line1\\n    line2\".to_owned();\n-        let r = unindent(s);\n+        let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n         let s = \"line1\\n\\n    line2\".to_owned();\n-        let r = unindent(s);\n+        let r = unindent(s.as_slice());\n         assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n     }\n }"}, {"sha": "63e6b7e36644b8611bb08959d48514d0b0cb5258", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -171,7 +171,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n \n         // Remove the previous dylib search path var\n         let var = DynamicLibrary::envvar();\n-        let mut env: Vec<(~str,~str)> = os::env().move_iter().collect();\n+        let mut env: Vec<(StrBuf,StrBuf)> = os::env().move_iter().collect();\n         match env.iter().position(|&(ref k, _)| k.as_slice() == var) {\n             Some(i) => { env.remove(i); }\n             None => {}\n@@ -276,7 +276,7 @@ impl Collector {\n             },\n             testfn: testing::DynTestFn(proc() {\n                 runtest(test.as_slice(),\n-                        cratename,\n+                        cratename.as_slice(),\n                         libs,\n                         should_fail,\n                         no_run,"}, {"sha": "82ab5fd5b048bbc5ea0859619c307d3ac6aa6869", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -182,8 +182,16 @@ mod tests {\n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap().as_slice(), &[i as u8]);\n-            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap().as_slice(), &[i as u8]);\n+            assert_eq!(format!(\"{:02x}\", i as uint).as_slice()\n+                                                   .from_hex()\n+                                                   .unwrap()\n+                                                   .as_slice(),\n+                       &[i as u8]);\n+            assert_eq!(format!(\"{:02X}\", i as uint).as_slice()\n+                                                   .from_hex()\n+                                                   .unwrap()\n+                                                   .as_slice(),\n+                       &[i as u8]);\n         }\n     }\n "}, {"sha": "92e3d5a26887a1e7ca70eb9a1330d117ed233d88", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -2483,7 +2483,7 @@ mod tests {\n \n         // We can't compare the strings directly because the object fields be\n         // printed in a different order.\n-        assert_eq!(a.clone(), from_str(a.to_str()).unwrap());\n+        assert_eq!(a.clone(), from_str(a.to_str().as_slice()).unwrap());\n         assert_eq!(a.clone(),\n                    from_str(a.to_pretty_str().as_slice()).unwrap());\n     }"}, {"sha": "e5689158601bc8cd8fcb0357c145dc2280c011a4", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -656,7 +656,7 @@ mod tests {\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_upper(),\n+            assert_eq!(from_char(from_u32(i).unwrap()).as_slice().to_ascii_upper(),\n                        from_char(from_u32(upper).unwrap()).to_strbuf())\n             i += 1;\n         }\n@@ -672,7 +672,7 @@ mod tests {\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!(from_char(from_u32(i).unwrap()).to_ascii_lower(),\n+            assert_eq!(from_char(from_u32(i).unwrap()).as_slice().to_ascii_lower(),\n                        from_char(from_u32(lower).unwrap()).to_strbuf())\n             i += 1;\n         }\n@@ -730,7 +730,7 @@ mod tests {\n                                                    .eq_ignore_ascii_case(\n                                                        from_char(\n                                                            from_u32(lower)\n-                                                            .unwrap())));\n+                                                            .unwrap()).as_slice()));\n             i += 1;\n         }\n     }"}, {"sha": "d8edd6517d5874c8e1b29d10ed6c69e6084ab8c8", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -855,7 +855,7 @@ mod test {\n         }\n         check!(unlink(filename));\n         let read_str = str::from_utf8(read_mem).unwrap();\n-        assert!(read_str == final_msg.to_owned());\n+        assert!(read_str.as_slice() == final_msg.as_slice());\n     })\n \n     iotest!(fn file_test_io_seek_shakedown() {\n@@ -955,9 +955,8 @@ mod test {\n         for n in range(0,3) {\n             let f = dir.join(format_strbuf!(\"{}.txt\", n));\n             let mut w = check!(File::create(&f));\n-            let msg_str =\n-                (prefix + n.to_str().into_owned()).to_owned();\n-            let msg = msg_str.as_bytes();\n+            let msg_str = format!(\"{}{}\", prefix, n.to_str());\n+            let msg = msg_str.as_slice().as_bytes();\n             check!(w.write(msg));\n         }\n         let files = check!(readdir(dir));\n@@ -969,7 +968,7 @@ mod test {\n                 let read_str = str::from_utf8(mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => fail!(\"really shouldn't happen..\"),\n-                    Some(n) => prefix+n\n+                    Some(n) => format!(\"{}{}\", prefix, n),\n                 };\n                 assert_eq!(expected.as_slice(), read_str);\n             }"}, {"sha": "7d84530282ff35d5a63bd5a46ce6483c8a2a9bbf", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -827,10 +827,12 @@ mod tests {\n         for &(ref k, ref v) in r.iter() {\n             // don't check android RANDOM variables\n             if *k != \"RANDOM\".to_strbuf() {\n-                assert!(output.contains(format!(\"{}={}\",\n+                assert!(output.as_slice()\n+                              .contains(format!(\"{}={}\",\n                                                 *k,\n                                                 *v).as_slice()) ||\n-                        output.contains(format!(\"{}=\\'{}\\'\",\n+                        output.as_slice()\n+                              .contains(format!(\"{}=\\'{}\\'\",\n                                                 *k,\n                                                 *v).as_slice()));\n             }"}, {"sha": "493dd86b2763a1a0605e158eee757ba1bd3a6e09", "filename": "src/libstd/os.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -41,7 +41,7 @@ use path::{Path, GenericPath};\n use ptr::RawPtr;\n use ptr;\n use result::{Err, Ok, Result};\n-use slice::{Vector, CloneableVector, ImmutableVector, MutableVector, OwnedVector};\n+use slice::{Vector, ImmutableVector, MutableVector, OwnedVector};\n use str::{Str, StrSlice, StrAllocating};\n use str;\n use strbuf::StrBuf;\n@@ -104,6 +104,7 @@ pub mod win32 {\n     use option;\n     use os::TMPBUF_SZ;\n     use slice::{MutableVector, ImmutableVector};\n+    use strbuf::StrBuf;\n     use str::{StrSlice, StrAllocating};\n     use str;\n     use vec::Vec;\n@@ -177,18 +178,18 @@ fn with_env_lock<T>(f: || -> T) -> T {\n /// for details.\n pub fn env() -> Vec<(StrBuf,StrBuf)> {\n     env_as_bytes().move_iter().map(|(k,v)| {\n-        let k = str::from_utf8_lossy(k).to_strbuf();\n-        let v = str::from_utf8_lossy(v).to_strbuf();\n+        let k = str::from_utf8_lossy(k.as_slice()).to_strbuf();\n+        let v = str::from_utf8_lossy(v.as_slice()).to_strbuf();\n         (k,v)\n     }).collect()\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n-pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n+pub fn env_as_bytes() -> Vec<(Vec<u8>,Vec<u8>)> {\n     unsafe {\n         #[cfg(windows)]\n-        unsafe fn get_env_pairs() -> Vec<~[u8]> {\n+        unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n             use slice::raw;\n \n             use libc::funcs::extra::kernel32::{\n@@ -228,7 +229,7 @@ pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n             result\n         }\n         #[cfg(unix)]\n-        unsafe fn get_env_pairs() -> Vec<~[u8]> {\n+        unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n             use c_str::CString;\n \n             extern {\n@@ -241,18 +242,19 @@ pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n             }\n             let mut result = Vec::new();\n             ptr::array_each(environ, |e| {\n-                let env_pair = CString::new(e, false).as_bytes_no_nul().to_owned();\n+                let env_pair =\n+                    Vec::from_slice(CString::new(e, false).as_bytes_no_nul());\n                 result.push(env_pair);\n             });\n             result\n         }\n \n-        fn env_convert(input: Vec<~[u8]>) -> Vec<(~[u8], ~[u8])> {\n+        fn env_convert(input: Vec<Vec<u8>>) -> Vec<(Vec<u8>, Vec<u8>)> {\n             let mut pairs = Vec::new();\n             for p in input.iter() {\n-                let mut it = p.splitn(1, |b| *b == '=' as u8);\n-                let key = it.next().unwrap().to_owned();\n-                let val = it.next().unwrap_or(&[]).to_owned();\n+                let mut it = p.as_slice().splitn(1, |b| *b == '=' as u8);\n+                let key = Vec::from_slice(it.next().unwrap());\n+                let val = Vec::from_slice(it.next().unwrap_or(&[]));\n                 pairs.push((key, val));\n             }\n             pairs\n@@ -275,7 +277,7 @@ pub fn env_as_bytes() -> Vec<(~[u8],~[u8])> {\n ///\n /// Fails if `n` has any interior NULs.\n pub fn getenv(n: &str) -> Option<StrBuf> {\n-    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v).to_strbuf())\n+    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v.as_slice()).to_strbuf())\n }\n \n #[cfg(unix)]\n@@ -285,7 +287,7 @@ pub fn getenv(n: &str) -> Option<StrBuf> {\n /// # Failure\n ///\n /// Fails if `n` has any interior NULs.\n-pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> {\n+pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n     use c_str::CString;\n \n     unsafe {\n@@ -294,7 +296,8 @@ pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> {\n             if s.is_null() {\n                 None\n             } else {\n-                Some(CString::new(s, false).as_bytes_no_nul().to_owned())\n+                Some(Vec::from_slice(CString::new(s,\n+                                                  false).as_bytes_no_nul()))\n             }\n         })\n     }\n@@ -319,7 +322,7 @@ pub fn getenv(n: &str) -> Option<StrBuf> {\n #[cfg(windows)]\n /// Fetches the environment variable `n` byte vector from the current process,\n /// returning None if the variable isn't set.\n-pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> {\n+pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n     getenv(n).map(|s| s.into_bytes())\n }\n \n@@ -528,7 +531,7 @@ pub fn self_exe_path() -> Option<Path> {\n  * Otherwise, homedir returns option::none.\n  */\n pub fn homedir() -> Option<Path> {\n-    // FIXME (#7188): getenv needs a ~[u8] variant\n+    // FIXME (#7188): getenv needs a Vec<u8> variant\n     return match getenv(\"HOME\") {\n         Some(ref p) if !p.is_empty() => Path::new_opt(p.as_slice()),\n         _ => secondary()\n@@ -817,11 +820,12 @@ pub fn get_exit_status() -> int {\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<~[u8]> {\n+unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<Vec<u8>> {\n     use c_str::CString;\n \n     Vec::from_fn(argc as uint, |i| {\n-        CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned()\n+        Vec::from_slice(CString::new(*argv.offset(i as int),\n+                                     false).as_bytes_no_nul())\n     })\n }\n \n@@ -831,7 +835,7 @@ unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> Vec<~[u8]> {\n  * Returns a list of the command line arguments.\n  */\n #[cfg(target_os = \"macos\")]\n-fn real_args_as_bytes() -> Vec<~[u8]> {\n+fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as int,\n                             *_NSGetArgv() as **c_char);\n@@ -842,7 +846,7 @@ fn real_args_as_bytes() -> Vec<~[u8]> {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n-fn real_args_as_bytes() -> Vec<~[u8]> {\n+fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     use rt;\n \n     match rt::args::clone() {\n@@ -854,8 +858,9 @@ fn real_args_as_bytes() -> Vec<~[u8]> {\n #[cfg(not(windows))]\n fn real_args() -> Vec<StrBuf> {\n     real_args_as_bytes().move_iter()\n-                        .map(|v| str::from_utf8_lossy(v).into_strbuf())\n-                        .collect()\n+                        .map(|v| {\n+                            str::from_utf8_lossy(v.as_slice()).into_strbuf()\n+                        }).collect()\n }\n \n #[cfg(windows)]\n@@ -889,7 +894,7 @@ fn real_args() -> Vec<StrBuf> {\n }\n \n #[cfg(windows)]\n-fn real_args_as_bytes() -> Vec<~[u8]> {\n+fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     real_args().move_iter().map(|s| s.into_bytes()).collect()\n }\n \n@@ -926,7 +931,7 @@ pub fn args() -> ::realstd::vec::Vec<::realstd::strbuf::StrBuf> {\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line) as byte vectors.\n-pub fn args_as_bytes() -> Vec<~[u8]> {\n+pub fn args_as_bytes() -> Vec<Vec<u8>> {\n     real_args_as_bytes()\n }\n \n@@ -1680,8 +1685,12 @@ mod tests {\n         setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n         assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n \n-        for s in oldhome.iter() { setenv(\"HOME\", *s) }\n-        for s in olduserprofile.iter() { setenv(\"USERPROFILE\", *s) }\n+        for s in oldhome.iter() {\n+            setenv(\"HOME\", s.as_slice())\n+        }\n+        for s in olduserprofile.iter() {\n+            setenv(\"USERPROFILE\", s.as_slice())\n+        }\n     }\n \n     #[test]"}, {"sha": "cde20521c2f66bda09b1486bfa368ffa9f338da1", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -37,8 +37,8 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n #[cfg(test)]      pub unsafe fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n-#[cfg(not(test))] pub fn take() -> Option<Vec<~[u8]>> { imp::take() }\n-#[cfg(test)]      pub fn take() -> Option<Vec<~[u8]>> {\n+#[cfg(not(test))] pub fn take() -> Option<Vec<Vec<u8>>> { imp::take() }\n+#[cfg(test)]      pub fn take() -> Option<Vec<Vec<u8>>> {\n     match realargs::take() {\n         realstd::option::Some(v) => Some(unsafe{ ::mem::transmute(v) }),\n         realstd::option::None => None,\n@@ -48,12 +48,16 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n-#[cfg(not(test))] pub fn put(args: Vec<~[u8]>) { imp::put(args) }\n-#[cfg(test)]      pub fn put(args: Vec<~[u8]>) { realargs::put(unsafe { ::mem::transmute(args) }) }\n+#[cfg(not(test))] pub fn put(args: Vec<Vec<u8>>) { imp::put(args) }\n+#[cfg(test)]      pub fn put(args: Vec<Vec<u8>>) {\n+    realargs::put(unsafe {\n+        ::mem::transmute(args)\n+    })\n+}\n \n /// Make a clone of the global arguments.\n-#[cfg(not(test))] pub fn clone() -> Option<Vec<~[u8]>> { imp::clone() }\n-#[cfg(test)]      pub fn clone() -> Option<Vec<~[u8]>> {\n+#[cfg(not(test))] pub fn clone() -> Option<Vec<Vec<u8>>> { imp::clone() }\n+#[cfg(test)]      pub fn clone() -> Option<Vec<Vec<u8>>> {\n     match realargs::clone() {\n         realstd::option::Some(v) => Some(unsafe { ::mem::transmute(v) }),\n         realstd::option::None => None,\n@@ -88,26 +92,26 @@ mod imp {\n         lock.destroy();\n     }\n \n-    pub fn take() -> Option<Vec<~[u8]>> {\n+    pub fn take() -> Option<Vec<Vec<u8>>> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             let val = mem::replace(&mut *ptr, None);\n-            val.as_ref().map(|s: &Box<Vec<~[u8]>>| (**s).clone())\n+            val.as_ref().map(|s: &Box<Vec<Vec<u8>>>| (**s).clone())\n         })\n     }\n \n-    pub fn put(args: Vec<~[u8]>) {\n+    pub fn put(args: Vec<Vec<u8>>) {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             rtassert!((*ptr).is_none());\n             (*ptr) = Some(box args.clone());\n         })\n     }\n \n-    pub fn clone() -> Option<Vec<~[u8]>> {\n+    pub fn clone() -> Option<Vec<Vec<u8>>> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s: &Box<Vec<~[u8]>>| (**s).clone())\n+            (*ptr).as_ref().map(|s: &Box<Vec<Vec<u8>>>| (**s).clone())\n         })\n     }\n \n@@ -118,22 +122,21 @@ mod imp {\n         }\n     }\n \n-    fn get_global_ptr() -> *mut Option<Box<Vec<~[u8]>>> {\n+    fn get_global_ptr() -> *mut Option<Box<Vec<Vec<u8>>>> {\n         unsafe { mem::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`.\n     #[cfg(not(test))]\n-    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<~[u8]> {\n+    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> Vec<Vec<u8>> {\n         use c_str::CString;\n         use ptr::RawPtr;\n         use libc;\n-        use slice::CloneableVector;\n         use vec::Vec;\n \n         Vec::from_fn(argc as uint, |i| {\n             let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n-            cs.as_bytes_no_nul().to_owned()\n+            Vec::from_slice(cs.as_bytes_no_nul())\n         })\n     }\n \n@@ -148,7 +151,10 @@ mod imp {\n             // Preserve the actual global state.\n             let saved_value = take();\n \n-            let expected = vec![bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n+            let expected = vec![\n+                Vec::from_slice(bytes!(\"happy\")),\n+                Vec::from_slice(bytes!(\"today?\")),\n+            ];\n \n             put(expected.clone());\n             assert!(clone() == Some(expected.clone()));\n@@ -179,15 +185,15 @@ mod imp {\n     pub fn cleanup() {\n     }\n \n-    pub fn take() -> Option<Vec<~[u8]>> {\n+    pub fn take() -> Option<Vec<Vec<u8>>> {\n         fail!()\n     }\n \n-    pub fn put(_args: Vec<~[u8]>) {\n+    pub fn put(_args: Vec<Vec<u8>>) {\n         fail!()\n     }\n \n-    pub fn clone() -> Option<Vec<~[u8]>> {\n+    pub fn clone() -> Option<Vec<Vec<u8>>> {\n         fail!()\n     }\n }"}, {"sha": "1ab9ac1b11edca81f18d34c48acc4d7b3d92c4bb", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -145,6 +145,7 @@ which at the time convulsed us with joy, yet which are now partly lost to my\n memory and partly incapable of presentation to others.\",\n         _ => \"You've met with a terrible fate, haven't you?\"\n     };\n+    ::alloc::util::make_stdlib_link_work(); // see comments in liballoc\n     rterrln!(\"{}\", \"\");\n     rterrln!(\"{}\", quote);\n     rterrln!(\"{}\", \"\");"}, {"sha": "4ba711c46112f8e384b1953de6a3c8298d074f2f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 65, "deletions": 81, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -85,7 +85,7 @@ use vec::Vec;\n pub use core::str::{from_utf8, CharEq, Chars, CharOffsets, RevChars};\n pub use core::str::{RevCharOffsets, Bytes, RevBytes, CharSplits, RevCharSplits};\n pub use core::str::{CharSplitsN, Words, AnyLines, MatchIndices, StrSplits};\n-pub use core::str::{eq_slice, eq, is_utf8, is_utf16, UTF16Items};\n+pub use core::str::{eq_slice, is_utf8, is_utf16, UTF16Items};\n pub use core::str::{UTF16Item, ScalarValue, LoneSurrogate, utf16_items};\n pub use core::str::{truncate_utf16_at_nul, utf8_char_width, CharRange};\n pub use core::str::{Str, StrSlice};\n@@ -660,6 +660,7 @@ pub mod raw {\n     use c_str::CString;\n     use libc;\n     use mem;\n+    use raw::Slice;\n     use strbuf::StrBuf;\n     use vec::Vec;\n \n@@ -668,7 +669,12 @@ pub mod raw {\n \n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> StrBuf {\n-        StrBuf::from_raw_parts(len, len, mem::transmute(buf))\n+        let mut result = StrBuf::new();\n+        result.push_bytes(mem::transmute(Slice {\n+            data: buf,\n+            len: len,\n+        }));\n+        result\n     }\n \n     /// Create a Rust string from a null-terminated C string\n@@ -919,13 +925,6 @@ mod tests {\n     use str::*;\n     use strbuf::StrBuf;\n \n-    #[test]\n-    fn test_eq() {\n-        assert!((eq(&\"\".to_owned(), &\"\".to_owned())));\n-        assert!((eq(&\"foo\".to_owned(), &\"foo\".to_owned())));\n-        assert!((!eq(&\"foo\".to_owned(), &\"bar\".to_owned())));\n-    }\n-\n     #[test]\n     fn test_eq_slice() {\n         assert!((eq_slice(\"foobar\".slice(0, 3), \"foo\")));\n@@ -984,10 +983,10 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let empty = \"\".to_owned();\n-        let s: StrBuf = empty.chars().collect();\n+        let s: StrBuf = empty.as_slice().chars().collect();\n         assert_eq!(empty, s);\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\".to_owned();\n-        let s: StrBuf = data.chars().collect();\n+        let s: StrBuf = data.as_slice().chars().collect();\n         assert_eq!(data, s);\n     }\n \n@@ -1009,23 +1008,24 @@ mod tests {\n         assert_eq!(data.slice(2u, 6u).find_str(\"ab\"), Some(3u - 2u));\n         assert!(data.slice(2u, 4u).find_str(\"ab\").is_none());\n \n-        let mut data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n-        data = data + data;\n-        assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n-        assert_eq!(data.slice(0u, 43u).find_str(\"\"), Some(0u));\n-        assert_eq!(data.slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n+        let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let mut data = string.to_strbuf();\n+        data.push_str(string);\n+        assert!(data.as_slice().find_str(\"\u0e44\u0e17\u534e\").is_none());\n+        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\"), Some(0u));\n+        assert_eq!(data.as_slice().slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n \n-        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n-        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n-        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n-        assert_eq!(data.slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n-        assert_eq!(data.slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n+        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n+        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n+        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n+        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n+        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n \n-        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n-        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n-        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n-        assert_eq!(data.slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n-        assert_eq!(data.slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n+        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n+        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n+        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n+        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n+        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n     }\n \n     #[test]\n@@ -1122,7 +1122,9 @@ mod tests {\n         }\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n-            unsafe {raw::slice_bytes(letters, 0u, 500000)}.to_owned());\n+            unsafe {raw::slice_bytes(letters.as_slice(),\n+                                     0u,\n+                                     500000)}.to_owned());\n     }\n \n     #[test]\n@@ -1167,41 +1169,41 @@ mod tests {\n \n     #[test]\n     fn test_replace_2a() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let a = \"\u0e1b\u0e23\u0e30\u0e40\".to_owned();\n-        let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n-        assert_eq!(data.replace(a, repl), a2);\n+        let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n+        let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_eq!(data.replace(a, repl).as_slice(), a2);\n     }\n \n     #[test]\n     fn test_replace_2b() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let b = \"\u0e30\u0e40\".to_owned();\n-        let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n-        assert_eq!(data.replace(b, repl), b2);\n+        let b = \"\u0e30\u0e40\";\n+        let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        assert_eq!(data.replace(b, repl).as_slice(), b2);\n     }\n \n     #[test]\n     fn test_replace_2c() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let c = \"\u4e2d\u534e\".to_owned();\n-        let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n-        assert_eq!(data.replace(c, repl), c2);\n+        let c = \"\u4e2d\u534e\";\n+        let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n+        assert_eq!(data.replace(c, repl).as_slice(), c2);\n     }\n \n     #[test]\n     fn test_replace_2d() {\n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\".to_owned();\n-        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\".to_owned();\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n-        let d = \"\u0e44\u0e17\u534e\".to_owned();\n-        assert_eq!(data.replace(d, repl), data);\n+        let d = \"\u0e44\u0e17\u534e\";\n+        assert_eq!(data.replace(d, repl).as_slice(), data);\n     }\n \n     #[test]\n@@ -1237,7 +1239,7 @@ mod tests {\n         }\n         let letters = a_million_letter_X();\n         assert!(half_a_million_letter_X() ==\n-            letters.slice(0u, 3u * 500000u).to_owned());\n+            letters.as_slice().slice(0u, 3u * 500000u).to_owned());\n     }\n \n     #[test]\n@@ -1533,14 +1535,14 @@ mod tests {\n         let s1: StrBuf = \"All mimsy were the borogoves\".to_strbuf();\n \n         let v: Vec<u8> = Vec::from_slice(s1.as_bytes());\n-        let s2: StrBuf = from_utf8(v).unwrap().to_strbuf();\n+        let s2: StrBuf = from_utf8(v.as_slice()).unwrap().to_strbuf();\n         let mut i: uint = 0u;\n         let n1: uint = s1.len();\n         let n2: uint = v.len();\n         assert_eq!(n1, n2);\n         while i < n1 {\n-            let a: u8 = s1[i];\n-            let b: u8 = s2[i];\n+            let a: u8 = s1.as_slice()[i];\n+            let b: u8 = s2.as_slice()[i];\n             debug!(\"{}\", a);\n             debug!(\"{}\", b);\n             assert_eq!(a, b);\n@@ -1558,7 +1560,7 @@ mod tests {\n         assert!(!\"abcde\".contains(\"def\"));\n         assert!(!\"\".contains(\"a\"));\n \n-        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         assert!(data.contains(\"\u0e1b\u0e23\u0e30\u0e40\"));\n         assert!(data.contains(\"\u0e30\u0e40\"));\n         assert!(data.contains(\"\u4e2d\u534e\"));\n@@ -1678,7 +1680,7 @@ mod tests {\n \n     #[test]\n     fn test_char_at() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for ch in v.iter() {\n@@ -1689,7 +1691,7 @@ mod tests {\n \n     #[test]\n     fn test_char_at_reverse() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n         for ch in v.iter().rev() {\n@@ -1734,7 +1736,7 @@ mod tests {\n \n     #[test]\n     fn test_char_range_at() {\n-        let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\".to_owned();\n+        let data = \"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n         assert_eq!('b', data.char_range_at(0).ch);\n         assert_eq!('\u00a2', data.char_range_at(1).ch);\n         assert_eq!('\u20ac', data.char_range_at(3).ch);\n@@ -1750,29 +1752,10 @@ mod tests {\n         assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);\n     }\n \n-    #[test]\n-    fn test_add() {\n-        #![allow(unnecessary_allocation)]\n-        macro_rules! t (\n-            ($s1:expr, $s2:expr, $e:expr) => { {\n-                let s1 = $s1;\n-                let s2 = $s2;\n-                let e = $e;\n-                assert_eq!(s1 + s2, e.to_owned());\n-                assert_eq!(s1.to_owned() + s2, e.to_owned());\n-            } }\n-        );\n-\n-        t!(\"foo\",  \"bar\", \"foobar\");\n-        t!(\"foo\", \"bar\".to_owned(), \"foobar\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\",  \"\u534eVi\u1ec7t Nam\", \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        t!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\", \"\u534eVi\u1ec7t Nam\".to_owned(), \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n     #[test]\n     fn test_iterator() {\n         use iter::*;\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n@@ -1788,7 +1771,7 @@ mod tests {\n     #[test]\n     fn test_rev_iterator() {\n         use iter::*;\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = box ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n@@ -1811,7 +1794,7 @@ mod tests {\n \n     #[test]\n     fn test_bytesator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n@@ -1827,7 +1810,7 @@ mod tests {\n \n     #[test]\n     fn test_bytes_revator() {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = [\n             224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n             184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n@@ -2081,14 +2064,15 @@ mod tests {\n \n     #[test]\n     fn test_str_from_utf8_owned() {\n-        let xs = bytes!(\"hello\").to_owned();\n+        let xs = Vec::from_slice(bytes!(\"hello\"));\n         assert_eq!(from_utf8_owned(xs), Ok(\"hello\".to_owned()));\n \n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\").to_owned();\n+        let xs = Vec::from_slice(bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n         assert_eq!(from_utf8_owned(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned()));\n \n-        let xs = bytes!(\"hello\", 0xff).to_owned();\n-        assert_eq!(from_utf8_owned(xs), Err(bytes!(\"hello\", 0xff).to_owned()));\n+        let xs = Vec::from_slice(bytes!(\"hello\", 0xff));\n+        assert_eq!(from_utf8_owned(xs),\n+                   Err(Vec::from_slice(bytes!(\"hello\", 0xff))));\n     }\n \n     #[test]"}, {"sha": "dd462ff5ab58407856fc6dbc4be4642e9e04ca4d", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -14,6 +14,7 @@ use c_vec::CVec;\n use char::Char;\n use cmp::Equiv;\n use container::{Container, Mutable};\n+use default::Default;\n use fmt;\n use from_str::FromStr;\n use io::Writer;\n@@ -331,6 +332,12 @@ impl StrAllocating for StrBuf {\n     }\n }\n \n+impl Default for StrBuf {\n+    fn default() -> StrBuf {\n+        StrBuf::new()\n+    }\n+}\n+\n impl fmt::Show for StrBuf {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)"}, {"sha": "8e85283ee55d34e0708e869ccac3796d35a44a76", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -119,7 +119,9 @@ impl DynamicLibrary {\n         let mut ret = Vec::new();\n         match os::getenv_as_bytes(DynamicLibrary::envvar()) {\n             Some(env) => {\n-                for portion in env.split(|a| *a == DynamicLibrary::separator()) {\n+                for portion in\n+                        env.as_slice()\n+                           .split(|a| *a == DynamicLibrary::separator()) {\n                     ret.push(Path::new(portion));\n                 }\n             }\n@@ -274,6 +276,7 @@ pub mod dl {\n     use os;\n     use ptr;\n     use result::{Ok, Err, Result};\n+    use strbuf::StrBuf;\n     use str;\n     use c_str::ToCStr;\n "}, {"sha": "822084df2f607915c405503bdeb3466388981b73", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -107,7 +107,9 @@ pub fn expand_asm(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         (Some('+'), operand) => {\n                             // Save a reference to the output\n                             read_write_operands.push((outputs.len(), out));\n-                            Some(token::intern_and_get_ident(\"=\" + operand))\n+                            Some(token::intern_and_get_ident(format!(\n+                                        \"={}\",\n+                                        operand).as_slice()))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");"}, {"sha": "ce1c7da585f6e543d8dc29faef555d5bb1a887f5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -188,7 +188,9 @@ pub fn nameize(p_s: &ParseSess, ms: &[Matcher], res: &[Rc<NamedMatch>])\n             if ret_val.contains_key(&bind_name) {\n                 let string = token::get_ident(bind_name);\n                 p_s.span_diagnostic\n-                   .span_fatal(span, \"duplicated bind name: \" + string.get())\n+                   .span_fatal(span,\n+                               format!(\"duplicated bind name: {}\",\n+                                       string.get()).as_slice())\n             }\n             ret_val.insert(bind_name, res[idx].clone());\n           }"}, {"sha": "4897fed692812ed3ae7ab358912c58b1ce7db76b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -4259,12 +4259,14 @@ impl<'a> Parser<'a> {\n                     self.span_note(id_sp,\n                                    format!(\"maybe move this module `{0}` \\\n                                             to its own directory via \\\n-                                            `{0}/mod.rs`\", this_module));\n+                                            `{0}/mod.rs`\",\n+                                           this_module).as_slice());\n                     if default_exists || secondary_exists {\n                         self.span_note(id_sp,\n                                        format!(\"... or maybe `use` the module \\\n                                                 `{}` instead of possibly \\\n-                                                redeclaring it\", mod_name));\n+                                                redeclaring it\",\n+                                               mod_name).as_slice());\n                     }\n                     self.abort_if_errors();\n                 }"}, {"sha": "5500ca45753066c988db4febf874e865826f8ed2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -2252,7 +2252,10 @@ impl<'a> State<'a> {\n             }\n             ast::LitFloat(ref f, t) => {\n                 word(&mut self.s,\n-                     f.get() + ast_util::float_ty_to_str(t).as_slice())\n+                     format!(\n+                         \"{}{}\",\n+                         f.get(),\n+                         ast_util::float_ty_to_str(t).as_slice()).as_slice())\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n             ast::LitNil => word(&mut self.s, \"()\"),"}, {"sha": "1f10956b38015fdf15a5c90836239c2dab3a5c42", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -623,7 +623,9 @@ impl<T: Writer> ConsoleTestState<T> {\n                 fail_out.push_str(format!(\"---- {} stdout ----\\n\\t\",\n                                           f.name.as_slice()).as_slice());\n                 let output = str::from_utf8_lossy(stdout.as_slice());\n-                fail_out.push_str(output.as_slice().replace(\"\\n\", \"\\n\\t\"));\n+                fail_out.push_str(output.as_slice()\n+                                        .replace(\"\\n\", \"\\n\\t\")\n+                                        .as_slice());\n                 fail_out.push_str(\"\\n\");\n             }\n         }\n@@ -776,7 +778,9 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::IoR\n                         let MetricMap(mm) = mm;\n                         for (k,v) in mm.iter() {\n                             st.metrics\n-                              .insert_metric(tname + \".\" + k.as_slice(),\n+                              .insert_metric(format!(\"{}.{}\",\n+                                                     tname,\n+                                                     k).as_slice(),\n                                              v.value,\n                                              v.noise);\n                         }"}, {"sha": "8f47a7ce2cb2a47054dbf93a275847150b2e5b07", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -1432,13 +1432,6 @@ mod tests {\n         assert_eq!(local.strftime(\"%z\"), \"-0800\".to_strbuf());\n         assert_eq!(local.strftime(\"%%\"), \"%\".to_strbuf());\n \n-        // FIXME (#2350): We should probably standardize on the timezone\n-        // abbreviation.\n-        let rfc822 = local.rfc822();\n-        let prefix = \"Fri, 13 Feb 2009 15:31:30 \".to_strbuf();\n-        assert!(rfc822 == format_strbuf!(\"{}PST\", prefix) ||\n-                rfc822 == format_strbuf!(\"{}Pacific Standard Time\", prefix));\n-\n         assert_eq!(local.ctime(), \"Fri Feb 13 15:31:30 2009\".to_strbuf());\n         assert_eq!(local.rfc822z(), \"Fri, 13 Feb 2009 15:31:30 -0800\".to_strbuf());\n         assert_eq!(local.rfc3339(), \"2009-02-13T15:31:30-08:00\".to_strbuf());"}, {"sha": "de9d6ef7c89aa87490ff926c81ab1d7ba46aa6ab", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -426,14 +426,16 @@ impl Uuid {\n \n         // At this point, we know we have a valid hex string, without hyphens\n         assert!(vs.len() == 32);\n-        assert!(vs.chars().all(|c| c.is_digit_radix(16)));\n+        assert!(vs.as_slice().chars().all(|c| c.is_digit_radix(16)));\n \n         // Allocate output UUID buffer\n         let mut ub = [0u8, ..16];\n \n         // Extract each hex digit from the string\n         for i in range(0u, 16u) {\n-            ub[i] = FromStrRadix::from_str_radix(vs.slice(i*2, (i+1)*2), 16).unwrap();\n+            ub[i] = FromStrRadix::from_str_radix(vs.as_slice()\n+                                                   .slice(i*2, (i+1)*2),\n+                                                 16).unwrap();\n         }\n \n         Ok(Uuid::from_bytes(ub).unwrap())\n@@ -624,7 +626,7 @@ mod test {\n         // Round-trip\n         let uuid_orig = Uuid::new_v4();\n         let orig_str = uuid_orig.to_str();\n-        let uuid_out = Uuid::parse_string(orig_str).unwrap();\n+        let uuid_out = Uuid::parse_string(orig_str.as_slice()).unwrap();\n         assert!(uuid_orig == uuid_out);\n \n         // Test error reporting\n@@ -706,7 +708,7 @@ mod test {\n         assert!(uuid_hs == uuid);\n \n         let ss = uuid.to_str();\n-        let uuid_ss = Uuid::parse_string(ss).unwrap();\n+        let uuid_ss = Uuid::parse_string(ss.as_slice()).unwrap();\n         assert!(uuid_ss == uuid);\n     }\n "}, {"sha": "d7acd82092fac66e426344c3a0dcff3c8e4f50d4", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -93,7 +93,7 @@ fn main() {\n     let args = args.as_slice();\n     let n_keys = {\n         if args.len() == 2 {\n-            from_str::<uint>(args[1]).unwrap()\n+            from_str::<uint>(args[1].as_slice()).unwrap()\n         } else {\n             1000000\n         }"}, {"sha": "ffc2fdffba4473ea4f50a5d0b83c0b6e745fd8e7", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -158,7 +158,7 @@ fn main() {\n     let args = args.as_slice();\n     let num_keys = {\n         if args.len() == 2 {\n-            from_str::<uint>(args[1]).unwrap()\n+            from_str::<uint>(args[1].as_slice()).unwrap()\n         } else {\n             100 // woefully inadequate for any real measurement\n         }"}, {"sha": "381527763c9628c4910b64c6bad347c620c868bd", "filename": "src/test/bench/core-uint-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-uint-to-str.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -21,7 +21,7 @@ fn main() {\n         args.move_iter().collect()\n     };\n \n-    let n = from_str::<uint>(*args.get(1)).unwrap();\n+    let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n \n     for i in range(0u, n) {\n         let x = i.to_str();"}, {"sha": "633ac6ebcdff89761700ecd943c5471554c79639", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -70,8 +70,8 @@ fn main() {\n         args.clone().move_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(*args.get(1)).unwrap();\n-    let msg_per_task = from_str::<uint>(*args.get(2)).unwrap();\n+    let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let msg_per_task = from_str::<uint>(args.get(2).as_slice()).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "a324f10fb33af98c6bd59aa48565a8698b7a5567", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -71,8 +71,8 @@ fn main() {\n         args.clone().move_iter().collect()\n     };\n \n-    let num_tasks = from_str::<uint>(*args.get(1)).unwrap();\n-    let msg_per_task = from_str::<uint>(*args.get(2)).unwrap();\n+    let num_tasks = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let msg_per_task = from_str::<uint>(args.get(2).as_slice()).unwrap();\n \n     let (mut num_chan, num_port) = init();\n "}, {"sha": "34e0742b6324af1114831bd4987a33474a92a63b", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -63,13 +63,13 @@ fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() == 3 {\n-        from_str::<uint>(args[1]).unwrap()\n+        from_str::<uint>(args[1].as_slice()).unwrap()\n     } else {\n         10000\n     };\n \n     let m = if args.len() == 3 {\n-        from_str::<uint>(args[2]).unwrap()\n+        from_str::<uint>(args[2].as_slice()).unwrap()\n     } else {\n         4\n     };"}, {"sha": "4072dc0064afba5ebe7db90a5a9ba86fd8f7ba22", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -33,7 +33,7 @@ fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() == 2 {\n-        from_str::<uint>(args[1]).unwrap()\n+        from_str::<uint>(args[1].as_slice()).unwrap()\n     } else {\n         10\n     };"}, {"sha": "a091c6be9f8c6aa676aa0ddec2324270ac692ff0", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -30,7 +30,7 @@ fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() == 2 {\n-        from_str::<uint>(args[1]).unwrap()\n+        from_str::<uint>(args[1].as_slice()).unwrap()\n     } else {\n         100000\n     };"}, {"sha": "e0116931538e9deb8f947f12d0514cad30ad00be", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -31,6 +31,6 @@ fn main() {\n     } else {\n         args.move_iter().collect()\n     };\n-    let n = from_str::<int>(*args.get(1)).unwrap();\n+    let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n     println!(\"Ack(3,{}): {}\\n\", n, ack(3, n));\n }"}, {"sha": "eab8b66b90d1ecc5f035b74eb7ffe5c6a36abfbf", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -46,7 +46,7 @@ fn main() {\n     } else if args.len() <= 1u {\n         8\n     } else {\n-        from_str(args[1]).unwrap()\n+        from_str(args[1].as_slice()).unwrap()\n     };\n     let min_depth = 4;\n     let max_depth = if min_depth + 2 > n {min_depth + 2} else {n};"}, {"sha": "181fe29c89185eec23b34ae2ef9b8fe6c0260bfa", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -48,7 +48,7 @@ fn show_color_list(set: Vec<Color>) -> StrBuf {\n     let mut out = StrBuf::new();\n     for col in set.iter() {\n         out.push_char(' ');\n-        out.push_str(col.to_str());\n+        out.push_str(col.to_str().as_slice());\n     }\n     out\n }\n@@ -198,7 +198,10 @@ fn main() {\n     let nn = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         200000\n     } else {\n-        std::os::args().as_slice().get(1).and_then(|arg| from_str(*arg)).unwrap_or(600)\n+        std::os::args().as_slice()\n+                       .get(1)\n+                       .and_then(|arg| from_str(arg.as_slice()))\n+                       .unwrap_or(600)\n     };\n \n     print_complements();"}, {"sha": "9cc8f2f23ff26aa4a3a24f422d86a94fe34aa43a", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -53,7 +53,10 @@ fn fannkuch(n: uint, i: uint) -> (int, int) {\n }\n \n fn main() {\n-    let n = std::os::args().as_slice().get(1).and_then(|arg| from_str(*arg)).unwrap_or(2u);\n+    let n = std::os::args().as_slice()\n+                           .get(1)\n+                           .and_then(|arg| from_str(arg.as_slice()))\n+                           .unwrap_or(2u);\n \n     let (tx, rx) = channel();\n     for i in range(0, n) {"}, {"sha": "adec9d31afecbed4b2b6b08ffbe9c2747be1f26d", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -179,7 +179,7 @@ fn main() {\n     let args = os::args();\n     let args = args.as_slice();\n     let n = if args.len() > 1 {\n-        from_str::<uint>(args[1]).unwrap()\n+        from_str::<uint>(args[1].as_slice()).unwrap()\n     } else {\n         5\n     };"}, {"sha": "4126fda00bcce0db085ba2f767712192abc77f73", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -80,7 +80,7 @@ fn run<W: Writer>(writer: &mut W) {\n     } else if args.len() <= 1u {\n         1000\n     } else {\n-        from_str(args[1]).unwrap()\n+        from_str(args[1].as_slice()).unwrap()\n     };\n \n     let rng = &mut MyRandom::new();"}, {"sha": "76f96f8d43b993d743df9a86a6937923439d8a32", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -27,6 +27,6 @@ fn main() {\n     } else {\n         args.move_iter().collect()\n     };\n-    let n = from_str::<int>(*args.get(1)).unwrap();\n+    let n = from_str::<int>(args.get(1).as_slice()).unwrap();\n     println!(\"{}\\n\", fib(n));\n }"}, {"sha": "6f8c44f4bdfb84d9d57406cf1a1f22f02ac6cb59", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -64,7 +64,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> StrBuf {\n                                k.as_slice()\n                                .to_ascii()\n                                .to_upper()\n-                               .into_str(), v));\n+                               .into_str(), v).as_slice());\n    }\n \n    return buffer\n@@ -179,15 +179,15 @@ fn main() {\n    let mut proc_mode = false;\n \n    for line in rdr.lines() {\n-       let line = line.unwrap().trim().to_owned();\n+       let line = line.unwrap().as_slice().trim().to_owned();\n \n        if line.len() == 0u { continue; }\n \n-       match (line[0] as char, proc_mode) {\n+       match (line.as_slice()[0] as char, proc_mode) {\n \n            // start processing if this is the one\n            ('>', false) => {\n-               match line.slice_from(1).find_str(\"THREE\") {\n+               match line.as_slice().slice_from(1).find_str(\"THREE\") {\n                    option::Some(_) => { proc_mode = true; }\n                    option::None    => { }\n                }"}, {"sha": "e46f27a9f41587ddb2bed22e9abdb89a20a05b1c", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -252,9 +252,9 @@ fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n     let mut res = Vec::new();\n     for l in r.lines().map(|l| l.ok().unwrap())\n-        .skip_while(|l| key != l.slice_to(key.len())).skip(1)\n+        .skip_while(|l| key != l.as_slice().slice_to(key.len())).skip(1)\n     {\n-        res.push_all(l.trim().as_bytes());\n+        res.push_all(l.as_slice().trim().as_bytes());\n     }\n     for b in res.mut_iter() {\n         *b = b.to_ascii().to_upper().to_byte();"}, {"sha": "6b3079b8fc8d1246761b77f490cea9609d707352", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -169,7 +169,7 @@ fn main() {\n                   which interferes with the test runner.\");\n         mandelbrot(1000, io::util::NullWriter)\n     } else {\n-        mandelbrot(from_str(args[1]).unwrap(), io::stdout())\n+        mandelbrot(from_str(args[1].as_slice()).unwrap(), io::stdout())\n     };\n     res.unwrap();\n }"}, {"sha": "5a077b377475c3aee20a8466764aabc59c9c2aa1", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -141,7 +141,7 @@ fn main() {\n         5000000\n     } else {\n         std::os::args().as_slice().get(1)\n-            .and_then(|arg| from_str(*arg))\n+            .and_then(|arg| from_str(arg.as_slice()))\n             .unwrap_or(1000)\n     };\n     let mut bodies = BODIES;"}, {"sha": "8b522f362b33099a9670f41b7a9fa34f2cb1f148", "filename": "src/test/bench/shootout-pidigits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-pidigits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pidigits.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -92,7 +92,7 @@ fn main() {\n     let n = if args.len() < 2 {\n         512\n     } else {\n-        FromStr::from_str(args[1]).unwrap()\n+        FromStr::from_str(args[1].as_slice()).unwrap()\n     };\n     pidigits(n);\n }"}, {"sha": "002eaf2bbf92167ea9fa9889d221e7504add4543", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -38,7 +38,7 @@ fn main() {\n     } else {\n         box io::stdin() as Box<io::Reader>\n     };\n-    let mut seq = StrBuf::from_str(rdr.read_to_str().unwrap());\n+    let mut seq = rdr.read_to_str().unwrap();\n     let ilen = seq.len();\n \n     seq = regex!(\">[^\\n]*\\n|\\n\").replace_all(seq.as_slice(), NoExpand(\"\"));"}, {"sha": "c6a678828c15beea961f0b354227b3a693e5b94f", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -100,7 +100,7 @@ fn main() {\n     } else if args.len() < 2 {\n         2000\n     } else {\n-        FromStr::from_str(args[1]).unwrap()\n+        FromStr::from_str(args[1].as_slice()).unwrap()\n     };\n     let u = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));\n     let v = Arc::new(RWLock::new(Vec::from_elem(n, 1.)));"}, {"sha": "1a6582927caf2bbc7429c0fa25c5fe276b87e233", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -39,9 +39,11 @@ fn main() {\n     let token = if std::os::getenv(\"RUST_BENCH\").is_some() {\n         2000000\n     } else {\n-        args.get(1).and_then(|arg| from_str(*arg)).unwrap_or(1000)\n+        args.get(1).and_then(|arg| from_str(arg.as_slice())).unwrap_or(1000)\n     };\n-    let n_tasks = args.get(2).and_then(|arg| from_str(*arg)).unwrap_or(503);\n+    let n_tasks = args.get(2)\n+                      .and_then(|arg| from_str(arg.as_slice()))\n+                      .unwrap_or(503);\n \n     start(n_tasks, token);\n }"}, {"sha": "3b26de9cf47be2a0a4465ddf54910aa38b6e90b8", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -38,8 +38,8 @@ fn main() {\n     } else {\n         args.move_iter().collect()\n     };\n-    let max = from_str::<uint>(*args.get(1)).unwrap();\n-    let rep = from_str::<uint>(*args.get(2)).unwrap();\n+    let max = from_str::<uint>(args.get(1).as_slice()).unwrap();\n+    let rep = from_str::<uint>(args.get(2).as_slice()).unwrap();\n \n     let mut checkf = 0.0;\n     let mut appendf = 0.0;"}, {"sha": "0485e10a38bfa7e9c520c86832e745d4c3c69eed", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -72,7 +72,10 @@ impl Sudoku {\n         let mut g = Vec::from_fn(10u, { |_i| vec!(0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8, 0u8) });\n         for line in reader.lines() {\n             let line = line.unwrap();\n-            let comps: Vec<&str> = line.trim().split(',').collect();\n+            let comps: Vec<&str> = line.as_slice()\n+                                       .trim()\n+                                       .split(',')\n+                                       .collect();\n \n             if comps.len() == 3u {\n                 let row     = from_str::<uint>(*comps.get(0)).unwrap() as u8;"}, {"sha": "1669f41374d1f952463df08979f973abdcfff048", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -49,7 +49,7 @@ fn main() {\n     };\n \n     let (tx, rx) = channel();\n-    child_generation(from_str::<uint>(*args.get(1)).unwrap(), tx);\n+    child_generation(from_str::<uint>(args.get(1).as_slice()).unwrap(), tx);\n     if rx.recv_opt().is_err() {\n         fail!(\"it happened when we slumbered\");\n     }"}, {"sha": "cb5eb77df6c23838e1328f33fdf8d5c22c45e7d3", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     } else {\n         args.move_iter().collect()\n     };\n-    let n = from_str::<uint>(*args.get(1)).unwrap();\n+    let n = from_str::<uint>(args.get(1).as_slice()).unwrap();\n     let mut i = 0u;\n     while i < n { task::spawn(proc() f(n) ); i += 1u; }\n }"}, {"sha": "1e1889c7339d26ce6e430545bdf71cd5fb7987ac", "filename": "src/test/compile-fail/closure-reform-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-reform-bad.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -17,7 +17,7 @@ fn call_bare(f: fn(&str)) {\n \n fn main() {\n     let string = \"world!\";\n-    let f: |&str| = |s| println!(\"{}\", s + string);\n+    let f: |&str| = |s| println!(\"{}{}\", s, string);\n     call_bare(f)    //~ ERROR mismatched types\n }\n "}, {"sha": "ae18e9bebad599b07c45a29ba05203fca3f55af1", "filename": "src/test/compile-fail/lint-heap-memory.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-heap-memory.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -27,6 +27,5 @@ fn main() {\n \n     box 2; //~ ERROR type uses owned\n     fn g(_: Box<Clone>) {} //~ ERROR type uses owned\n-    \"\".to_owned(); //~ ERROR type uses owned\n     proc() {}; //~ ERROR type uses owned\n }"}, {"sha": "1d8c4cec655441b854bdfdf344e0951a67605967", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -33,7 +33,7 @@ mod argparse {\n }\n \n fn main () {\n-    let f : argparse::Flag = argparse::flag(\"flag\".to_owned(), \"My flag\".to_owned());\n-    let updated_flag = f.set_desc(\"My new flag\".to_owned());\n-    assert_eq!(updated_flag.desc, \"My new flag\");\n+    let f : argparse::Flag = argparse::flag(\"flag\", \"My flag\");\n+    let updated_flag = f.set_desc(\"My new flag\");\n+    assert_eq!(updated_flag.desc.as_slice(), \"My new flag\");\n }"}, {"sha": "cf7a5c4ad14feb4a67f935c86c130b3802a3f4c9", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -25,7 +25,7 @@ impl Trait<&'static str> for Struct {\n \n fn main() {\n     let person = \"Fred\".to_owned();\n-    let person: &str = person;  //~ ERROR `person[..]` does not live long enough\n+    let person: &str = person.as_slice();  //~ ERROR `person` does not live long enough\n     let s: Box<Trait<&'static str>> = box Struct { person: person };\n }\n "}, {"sha": "1adf88c80be90a131cc625d057616939efa85b02", "filename": "src/test/compile-fail/unsafe-modifying-str.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-modifying-str.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let mut s = \"test\".to_owned();\n-    s[0] = 3; //~ ERROR: not allowed\n-    s[0] += 3; //~ ERROR: not allowed\n-    {\n-        let _a = &mut s[0]; //~ ERROR: not allowed\n-    }\n-}"}, {"sha": "994a81dc4866203091a160c5b21fa923a06e2bef", "filename": "src/test/pretty/match-naked-expr-long.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Ftest%2Fpretty%2Fmatch-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Ftest%2Fpretty%2Fmatch-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmatch-naked-expr-long.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pp-exact\n-\n-// actually this doesn't quite look how I want it to, but I can't\n-// get the prettyprinter to indent the long expr\n-\n-fn main() {\n-    let x = Some(3);\n-    let _y =\n-        match x {\n-            Some(_) =>\n-            \"some\".to_owned() + \"very\" + \"very\" + \"very\" + \"very\" + \"very\" +\n-                \"very\" + \"very\" + \"very\" + \"long\" + \"string\",\n-            None => \"none\".to_owned()\n-        };\n-}"}, {"sha": "a57f4683df315c6998931257667da01ddbbc51bc", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -19,5 +19,4 @@ fn main() {\n     let y = vec!(3);\n     fail!(\"so long\");\n     x.push_all_move(y);\n-    \"good\".to_owned() + \"bye\".to_owned();\n }"}, {"sha": "e41c5d1b6266e5c86c4e0f9f661599f43c05a7a7", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -57,7 +57,11 @@ fn main() {\n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n         let result = Command::new(\"sh\")\n-                             .arg(\"-c\").arg(rustc + \" \" + main_file.as_str().unwrap())\n+                             .arg(\"-c\")\n+                             .arg(format!(\"{} {}\",\n+                                          rustc,\n+                                          main_file.as_str()\n+                                                   .unwrap()).as_slice())\n                              .output().unwrap();\n         let err = str::from_utf8_lossy(result.error.as_slice());\n "}, {"sha": "854ed94e20afa0aedb8a96211bbda3b96ea8796f", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -52,13 +52,17 @@ fn main() {\n         // rustc is passed to us with --out-dir and -L etc., so we\n         // can't exec it directly\n         let result = Command::new(\"sh\")\n-                             .arg(\"-c\").arg(rustc + \" \" + main_file.as_str().unwrap())\n+                             .arg(\"-c\")\n+                             .arg(format!(\"{} {}\",\n+                                          rustc,\n+                                          main_file.as_str()\n+                                                   .unwrap()).as_slice())\n                              .output().unwrap();\n \n         let err = str::from_utf8_lossy(result.error.as_slice());\n \n         // the span should end the line (e.g no extra ~'s)\n-        let expected_span = \"^\" + \"~\".repeat(n - 1) + \"\\n\";\n-        assert!(err.as_slice().contains(expected_span));\n+        let expected_span = format!(\"^{}\\n\", \"~\".repeat(n - 1));\n+        assert!(err.as_slice().contains(expected_span.as_slice()));\n     }\n }"}, {"sha": "f7b9732f12e87ce88528c9fe9f0de934a91a5851", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -30,7 +30,6 @@ pub fn main() {\n     (vec!(1)).as_slice().test_imm();\n     (&[1]).test_imm();\n     (\"test\").test_imm();\n-    (\"test\".to_owned()).test_imm();\n     (\"test\").test_imm();\n \n     // FIXME: Other types of mutable vecs don't currently exist"}, {"sha": "e31f2ade125eb08d284bb47b53152b4244089a90", "filename": "src/test/run-pass/issue-3574.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fissue-3574.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fissue-3574.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3574.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -8,21 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(unnecessary_allocation)]\n-\n // rustc --test match_borrowed_str.rs.rs && ./match_borrowed_str.rs\n \n-fn compare(x: &str, y: &str) -> bool\n-{\n-    match x\n-    {\n+fn compare(x: &str, y: &str) -> bool {\n+    match x {\n         \"foo\" => y == \"foo\",\n         _ => y == \"bar\",\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     assert!(compare(\"foo\", \"foo\"));\n-    assert!(compare(\"foo\".to_owned(), \"foo\".to_owned()));\n }"}, {"sha": "477f3b2acafda53ee608b36574dd02c06d0e3110", "filename": "src/test/run-pass/let-assignability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flet-assignability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flet-assignability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-assignability.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn f() {\n-    let a = \"hello\".to_owned();\n-    let b: &str = a;\n+    let a = box 1;\n+    let b: &int = a;\n     println!(\"{}\", b);\n }\n "}, {"sha": "343780b2463822111abade6f7c5275c800707370", "filename": "src/test/run-pass/let-destruct-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flet-destruct-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flet-destruct-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-destruct-ref.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = \"hello\".to_owned();\n+    let x = 3u;\n     let ref y = x;\n-    assert_eq!(x.slice(0, x.len()), y.slice(0, y.len()));\n+    assert_eq!(x, *y);\n }"}, {"sha": "2f8f16fb1aea9ecedea6cbbfc01044aff5a45f26", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     assert_eq!(y, 6);\n     let s = \"hello there\".to_owned();\n     let mut i: int = 0;\n-    for c in s.bytes() {\n+    for c in s.as_slice().bytes() {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "2f2328faaca7f8f3249098860c10b16d7cb3e695", "filename": "src/test/run-pass/log-err-phi.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flog-err-phi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Flog-err-phi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-err-phi.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -10,4 +10,8 @@\n \n \n \n-pub fn main() { if false { println!(\"{}\", \"foo\".to_owned() + \"bar\"); } }\n+pub fn main() {\n+    if false {\n+        println!(\"{}\", \"foobar\");\n+    }\n+}"}, {"sha": "7a816f913350130dfc9b53efcbb023099ea5f8ba", "filename": "src/test/run-pass/option-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let thing = \"{{ f }}\".to_owned();\n+    let thing = \"{{ f }}\";\n     let f = thing.find_str(\"{{\");\n \n     if f.is_none() {"}, {"sha": "161e392520ef263cd7c58312036e19ace8887613", "filename": "src/test/run-pass/regions-borrow-estr-uniq.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Ftest%2Frun-pass%2Fregions-borrow-estr-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5633d4641f7d63805e3c12c899f8401410bd825f/src%2Ftest%2Frun-pass%2Fregions-borrow-estr-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-estr-uniq.rs?ref=5633d4641f7d63805e3c12c899f8401410bd825f", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn foo(x: &str) -> u8 {\n-    x[0]\n-}\n-\n-pub fn main() {\n-    let p = \"hello\".to_owned();\n-    let r = foo(p);\n-    assert_eq!(r, 'h' as u8);\n-\n-    let p = \"hello\".to_owned();\n-    let r = foo(p);\n-    assert_eq!(r, 'h' as u8);\n-}"}, {"sha": "d65eb6415bfc09b50789233410fb51a4fc0d618c", "filename": "src/test/run-pass/str-idx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-idx.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -12,7 +12,7 @@\n \n pub fn main() {\n     let s = \"hello\".to_owned();\n-    let c: u8 = s[4];\n+    let c: u8 = s.as_slice()[4];\n     println!(\"{:?}\", c);\n     assert_eq!(c, 0x6f as u8);\n }"}, {"sha": "26cc43bcfa0baaccc49821f2569ca0c8545c2ab2", "filename": "src/test/run-pass/super-fast-paren-parsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsuper-fast-paren-parsing.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// exec-env:RUST_MIN_STACK=8000000\n+// exec-env:RUST_MIN_STACK=16000000\n //\n // Big stack is needed for pretty printing, a little sad...\n "}, {"sha": "9f58cbbff203aded8c9e54cf56aec599b00beaa6", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -15,17 +15,19 @@\n \n pub mod m1 {\n     pub mod m2 {\n-        pub fn where_am_i() -> StrBuf { (module_path!()).to_strbuf() }\n+        pub fn where_am_i() -> StrBuf {\n+            (module_path!()).to_strbuf()\n+        }\n     }\n }\n \n macro_rules! indirect_line( () => ( line!() ) )\n \n pub fn main() {\n-    assert_eq!(line!(), 25);\n+    assert_eq!(line!(), 27);\n     //assert!((col!() == 11));\n-    assert_eq!(indirect_line!(), 27);\n-    assert!((file!().to_owned().ends_with(\"syntax-extension-source-utils.rs\")));\n+    assert_eq!(indirect_line!(), 29);\n+    assert!((file!().ends_with(\"syntax-extension-source-utils.rs\")));\n     assert_eq!(stringify!((2*3) + 5).to_strbuf(), \"( 2 * 3 ) + 5\".to_strbuf());\n     assert!(include!(\"syntax-extension-source-utils-files/includeme.\\\n                       fragment\").to_strbuf()"}, {"sha": "963121fff82280da696a085f460765f89118b983", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e878721d70349e2055f0ef854085de92e9498fde/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=e878721d70349e2055f0ef854085de92e9498fde", "patch": "@@ -39,10 +39,10 @@ fn test_str() {\n     let s0 = \"test\".to_owned();\n     tx.send(s0);\n     let s1 = rx.recv();\n-    assert_eq!(s1[0], 't' as u8);\n-    assert_eq!(s1[1], 'e' as u8);\n-    assert_eq!(s1[2], 's' as u8);\n-    assert_eq!(s1[3], 't' as u8);\n+    assert_eq!(s1.as_slice()[0], 't' as u8);\n+    assert_eq!(s1.as_slice()[1], 'e' as u8);\n+    assert_eq!(s1.as_slice()[2], 's' as u8);\n+    assert_eq!(s1.as_slice()[3], 't' as u8);\n }\n \n #[deriving(Show)]"}]}