{"sha": "1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkM2M1MzlmYmJkZGRjMmMwYWIyYzUxMmU3MGY0ZjZlYTJkMzdjNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-20T06:59:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-20T06:59:13Z"}, "message": "Auto merge of #6924 - mgacek8:issue6727_copy_types, r=llogiq\n\nwrong_self_convention: `to_` convention respects `Copy` types\n\nfixes #6727\nchangelog: wrong_self_convention: `to_` convention respects `Copy` types", "tree": {"sha": "3d3c01519da36bb1bcde5c0c48eb61023b13a068", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d3c01519da36bb1bcde5c0c48eb61023b13a068"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "html_url": "https://github.com/rust-lang/rust/commit/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d2e2b5f158d3c54d6ccad318379be20bdbbe712", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d2e2b5f158d3c54d6ccad318379be20bdbbe712", "html_url": "https://github.com/rust-lang/rust/commit/0d2e2b5f158d3c54d6ccad318379be20bdbbe712"}, {"sha": "1f2d01641d6ef2f283265eb603c7d231692b6a89", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f2d01641d6ef2f283265eb603c7d231692b6a89", "html_url": "https://github.com/rust-lang/rust/commit/1f2d01641d6ef2f283265eb603c7d231692b6a89"}], "stats": {"total": 260, "additions": 157, "deletions": 103}, "files": [{"sha": "46deb20f97d20ba4b1f68bf0803f40e1b4f643da", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -192,14 +192,18 @@ declare_clippy_lint! {\n     /// **What it does:** Checks for methods with certain name prefixes and which\n     /// doesn't match how self is taken. The actual rules are:\n     ///\n-    /// |Prefix |Postfix     |`self` taken          |\n-    /// |-------|------------|----------------------|\n-    /// |`as_`  | none       |`&self` or `&mut self`|\n-    /// |`from_`| none       | none                 |\n-    /// |`into_`| none       |`self`                |\n-    /// |`is_`  | none       |`&self` or none       |\n-    /// |`to_`  | `_mut`     |`&mut &self`          |\n-    /// |`to_`  | not `_mut` |`&self`               |\n+    /// |Prefix |Postfix     |`self` taken           | `self` type  |\n+    /// |-------|------------|-----------------------|--------------|\n+    /// |`as_`  | none       |`&self` or `&mut self` | any          |\n+    /// |`from_`| none       | none                  | any          |\n+    /// |`into_`| none       |`self`                 | any          |\n+    /// |`is_`  | none       |`&self` or none        | any          |\n+    /// |`to_`  | `_mut`     |`&mut self`            | any          |\n+    /// |`to_`  | not `_mut` |`self`                 | `Copy`       |\n+    /// |`to_`  | not `_mut` |`&self`                | not `Copy`   |\n+    ///\n+    /// Please find more info here:\n+    /// https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n     ///\n     /// **Why is this bad?** Consistency breeds readability. If you follow the\n     /// conventions, your users won't be surprised that they, e.g., need to supply a\n@@ -1836,10 +1840,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let item = cx.tcx.hir().expect_item(parent);\n         let self_ty = cx.tcx.type_of(item.def_id);\n \n-        // if this impl block implements a trait, lint in trait definition instead\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n-            return;\n-        }\n+        let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n \n         if_chain! {\n             if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind;\n@@ -1854,7 +1855,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let Some(first_arg_ty) = first_arg_ty;\n \n             then {\n-                if cx.access_levels.is_exported(impl_item.hir_id()) {\n+                // if this impl block implements a trait, lint in trait definition instead\n+                if !implements_trait && cx.access_levels.is_exported(impl_item.hir_id()) {\n                     // check missing trait implementations\n                     for method_config in &TRAIT_METHODS {\n                         if name == method_config.method_name &&\n@@ -1890,11 +1892,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     item.vis.node.is_pub(),\n                     self_ty,\n                     first_arg_ty,\n-                    first_arg.pat.span\n+                    first_arg.pat.span,\n+                    false\n                 );\n             }\n         }\n \n+        // if this impl block implements a trait, lint in trait definition instead\n+        if implements_trait {\n+            return;\n+        }\n+\n         if let hir::ImplItemKind::Fn(_, _) = impl_item.kind {\n             let ret_ty = return_ty(cx, impl_item.hir_id());\n \n@@ -1946,7 +1954,8 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     false,\n                     self_ty,\n                     first_arg_ty,\n-                    first_arg_span\n+                    first_arg_span,\n+                    true\n                 );\n             }\n         }\n@@ -2338,10 +2347,10 @@ impl SelfKind {\n     #[must_use]\n     fn description(self) -> &'static str {\n         match self {\n-            Self::Value => \"self by value\",\n-            Self::Ref => \"self by reference\",\n-            Self::RefMut => \"self by mutable reference\",\n-            Self::No => \"no self\",\n+            Self::Value => \"`self` by value\",\n+            Self::Ref => \"`self` by reference\",\n+            Self::RefMut => \"`self` by mutable reference\",\n+            Self::No => \"no `self`\",\n         }\n     }\n }"}, {"sha": "59e683aa9a786fb18f732ad80ebffd9ab4e7aaa6", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -1,5 +1,6 @@\n use crate::methods::SelfKind;\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_copy;\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n use rustc_span::source_map::Span;\n@@ -9,43 +10,58 @@ use super::WRONG_PUB_SELF_CONVENTION;\n use super::WRONG_SELF_CONVENTION;\n \n #[rustfmt::skip]\n-const CONVENTIONS: [(&[Convention], &[SelfKind]); 8] = [\n+const CONVENTIONS: [(&[Convention], &[SelfKind]); 9] = [\n     (&[Convention::Eq(\"new\")], &[SelfKind::No]),\n     (&[Convention::StartsWith(\"as_\")], &[SelfKind::Ref, SelfKind::RefMut]),\n     (&[Convention::StartsWith(\"from_\")], &[SelfKind::No]),\n     (&[Convention::StartsWith(\"into_\")], &[SelfKind::Value]),\n     (&[Convention::StartsWith(\"is_\")], &[SelfKind::Ref, SelfKind::No]),\n     (&[Convention::Eq(\"to_mut\")], &[SelfKind::RefMut]),\n     (&[Convention::StartsWith(\"to_\"), Convention::EndsWith(\"_mut\")], &[SelfKind::RefMut]),\n-    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\")], &[SelfKind::Ref]),\n+\n+    // Conversion using `to_` can use borrowed (non-Copy types) or owned (Copy types).\n+    // Source: https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(false), Convention::ImplementsTrait(false)], &[SelfKind::Ref]),\n+    (&[Convention::StartsWith(\"to_\"), Convention::NotEndsWith(\"_mut\"), Convention::IsSelfTypeCopy(true), Convention::ImplementsTrait(false)], &[SelfKind::Value]),\n ];\n \n enum Convention {\n     Eq(&'static str),\n     StartsWith(&'static str),\n     EndsWith(&'static str),\n     NotEndsWith(&'static str),\n+    IsSelfTypeCopy(bool),\n+    ImplementsTrait(bool),\n }\n \n impl Convention {\n     #[must_use]\n-    fn check(&self, other: &str) -> bool {\n+    fn check<'tcx>(&self, cx: &LateContext<'tcx>, self_ty: &'tcx TyS<'tcx>, other: &str, is_trait_def: bool) -> bool {\n         match *self {\n             Self::Eq(this) => this == other,\n             Self::StartsWith(this) => other.starts_with(this) && this != other,\n             Self::EndsWith(this) => other.ends_with(this) && this != other,\n-            Self::NotEndsWith(this) => !Self::EndsWith(this).check(other),\n+            Self::NotEndsWith(this) => !Self::EndsWith(this).check(cx, self_ty, other, is_trait_def),\n+            Self::IsSelfTypeCopy(is_true) => is_true == is_copy(cx, self_ty),\n+            Self::ImplementsTrait(is_true) => is_true == is_trait_def,\n         }\n     }\n }\n \n impl fmt::Display for Convention {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         match *self {\n-            Self::Eq(this) => this.fmt(f),\n-            Self::StartsWith(this) => this.fmt(f).and_then(|_| '*'.fmt(f)),\n-            Self::EndsWith(this) => '*'.fmt(f).and_then(|_| this.fmt(f)),\n-            Self::NotEndsWith(this) => '~'.fmt(f).and_then(|_| this.fmt(f)),\n+            Self::Eq(this) => format!(\"`{}`\", this).fmt(f),\n+            Self::StartsWith(this) => format!(\"`{}*`\", this).fmt(f),\n+            Self::EndsWith(this) => format!(\"`*{}`\", this).fmt(f),\n+            Self::NotEndsWith(this) => format!(\"`~{}`\", this).fmt(f),\n+            Self::IsSelfTypeCopy(is_true) => {\n+                format!(\"`self` type is{} `Copy`\", if is_true { \"\" } else { \" not\" }).fmt(f)\n+            },\n+            Self::ImplementsTrait(is_true) => {\n+                let (negation, s_suffix) = if is_true { (\"\", \"s\") } else { (\" does not\", \"\") };\n+                format!(\"Method{} implement{} a trait\", negation, s_suffix).fmt(f)\n+            },\n         }\n     }\n }\n@@ -57,47 +73,44 @@ pub(super) fn check<'tcx>(\n     self_ty: &'tcx TyS<'tcx>,\n     first_arg_ty: &'tcx TyS<'tcx>,\n     first_arg_span: Span,\n+    is_trait_item: bool,\n ) {\n     let lint = if is_pub {\n         WRONG_PUB_SELF_CONVENTION\n     } else {\n         WRONG_SELF_CONVENTION\n     };\n-    if let Some((conventions, self_kinds)) = &CONVENTIONS\n-        .iter()\n-        .find(|(convs, _)| convs.iter().all(|conv| conv.check(item_name)))\n-    {\n+    if let Some((conventions, self_kinds)) = &CONVENTIONS.iter().find(|(convs, _)| {\n+        convs\n+            .iter()\n+            .all(|conv| conv.check(cx, self_ty, item_name, is_trait_item))\n+    }) {\n         if !self_kinds.iter().any(|k| k.matches(cx, self_ty, first_arg_ty)) {\n             let suggestion = {\n                 if conventions.len() > 1 {\n-                    let special_case = {\n-                        // Don't mention `NotEndsWith` when there is also `StartsWith` convention present\n-                        if conventions.len() == 2 {\n-                            match conventions {\n-                                [Convention::StartsWith(starts_with), Convention::NotEndsWith(_)]\n-                                | [Convention::NotEndsWith(_), Convention::StartsWith(starts_with)] => {\n-                                    Some(format!(\"methods called `{}`\", Convention::StartsWith(starts_with)))\n-                                },\n-                                _ => None,\n-                            }\n-                        } else {\n-                            None\n-                        }\n-                    };\n-\n-                    if let Some(suggestion) = special_case {\n-                        suggestion\n-                    } else {\n-                        let s = conventions\n+                    // Don't mention `NotEndsWith` when there is also `StartsWith` convention present\n+                    let cut_ends_with_conv = conventions.iter().any(|conv| matches!(conv, Convention::StartsWith(_)))\n+                        && conventions\n                             .iter()\n-                            .map(|c| format!(\"`{}`\", &c.to_string()))\n-                            .collect::<Vec<_>>()\n-                            .join(\" and \");\n+                            .any(|conv| matches!(conv, Convention::NotEndsWith(_)));\n+\n+                    let s = conventions\n+                        .iter()\n+                        .filter_map(|conv| {\n+                            if (cut_ends_with_conv && matches!(conv, Convention::NotEndsWith(_)))\n+                                || matches!(conv, Convention::ImplementsTrait(_))\n+                            {\n+                                None\n+                            } else {\n+                                Some(conv.to_string())\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\" and \");\n \n-                        format!(\"methods called like this: ({})\", &s)\n-                    }\n+                    format!(\"methods with the following characteristics: ({})\", &s)\n                 } else {\n-                    format!(\"methods called `{}`\", &conventions[0])\n+                    format!(\"methods called {}\", &conventions[0])\n                 }\n             };\n "}, {"sha": "702684f6b43a6467067f02a9780df538435f81bf", "filename": "tests/ui/def_id_nocore.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fdef_id_nocore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fdef_id_nocore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdef_id_nocore.stderr?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -1,4 +1,4 @@\n-error: methods called `as_*` usually take self by reference or self by mutable reference\n+error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n   --> $DIR/def_id_nocore.rs:26:19\n    |\n LL |     pub fn as_ref(self) -> &'static str {"}, {"sha": "a6619f358920209e9cf23be524f6424c8d2033f2", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -75,13 +75,13 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n-        fn to_bytes(&self) -> Vec<u8>;\n+        fn to_bytes(self) -> Vec<u8>;\n     }\n \n     // This should not be linted\n     impl IntoBytes for u8 {\n-        fn to_bytes(&self) -> Vec<u8> {\n-            vec![*self]\n+        fn to_bytes(self) -> Vec<u8> {\n+            vec![self]\n         }\n     }\n }"}, {"sha": "3c41ce500e0ddef1ba829ae9723674b32ade15c7", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -75,13 +75,13 @@ mod lifetimes {\n \n mod issue2894 {\n     trait IntoBytes {\n-        fn to_bytes(&self) -> Vec<u8>;\n+        fn to_bytes(self) -> Vec<u8>;\n     }\n \n     // This should not be linted\n     impl IntoBytes for u8 {\n-        fn to_bytes(&self) -> Vec<u8> {\n-            vec![*self]\n+        fn to_bytes(self) -> Vec<u8> {\n+            vec![self]\n         }\n     }\n }"}, {"sha": "ba9e19a17220ff55d214e1628350d6bf10cfb7e3", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -163,3 +163,35 @@ mod issue6307 {\n         fn to_mut(&mut self);\n     }\n }\n+\n+mod issue6727 {\n+    trait ToU64 {\n+        fn to_u64(self) -> u64;\n+        fn to_u64_v2(&self) -> u64;\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    struct FooCopy;\n+\n+    impl ToU64 for FooCopy {\n+        fn to_u64(self) -> u64 {\n+            1\n+        }\n+        // trigger lint\n+        fn to_u64_v2(&self) -> u64 {\n+            1\n+        }\n+    }\n+\n+    struct FooNoCopy;\n+\n+    impl ToU64 for FooNoCopy {\n+        // trigger lint\n+        fn to_u64(self) -> u64 {\n+            2\n+        }\n+        fn to_u64_v2(&self) -> u64 {\n+            2\n+        }\n+    }\n+}"}, {"sha": "1d58a12ac795b9706fd8bf1fef7c67adf4d3b990", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -1,4 +1,4 @@\n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:18:17\n    |\n LL |     fn from_i32(self) {}\n@@ -7,189 +7,189 @@ LL |     fn from_i32(self) {}\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:24:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference\n+error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n   --> $DIR/wrong_self_convention.rs:36:15\n    |\n LL |     fn as_i32(self) {}\n    |               ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value\n+error: methods called `into_*` usually take `self` by value\n   --> $DIR/wrong_self_convention.rs:38:17\n    |\n LL |     fn into_i32(&self) {}\n    |                 ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self\n+error: methods called `is_*` usually take `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:40:15\n    |\n LL |     fn is_i32(self) {}\n    |               ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n+error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n   --> $DIR/wrong_self_convention.rs:42:15\n    |\n LL |     fn to_i32(self) {}\n    |               ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:44:17\n    |\n LL |     fn from_i32(self) {}\n    |                 ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference\n+error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n   --> $DIR/wrong_self_convention.rs:46:19\n    |\n LL |     pub fn as_i64(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value\n+error: methods called `into_*` usually take `self` by value\n   --> $DIR/wrong_self_convention.rs:47:21\n    |\n LL |     pub fn into_i64(&self) {}\n    |                     ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self\n+error: methods called `is_*` usually take `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:48:19\n    |\n LL |     pub fn is_i64(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n+error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n   --> $DIR/wrong_self_convention.rs:49:19\n    |\n LL |     pub fn to_i64(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:50:21\n    |\n LL |     pub fn from_i64(self) {}\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference\n+error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n   --> $DIR/wrong_self_convention.rs:95:19\n    |\n LL |         fn as_i32(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value\n+error: methods called `into_*` usually take `self` by value\n   --> $DIR/wrong_self_convention.rs:98:25\n    |\n LL |         fn into_i32_ref(&self) {}\n    |                         ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self\n+error: methods called `is_*` usually take `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:100:19\n    |\n LL |         fn is_i32(self) {}\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n-  --> $DIR/wrong_self_convention.rs:102:19\n-   |\n-LL |         fn to_i32(self) {}\n-   |                   ^^^^\n-   |\n-   = help: consider choosing a less ambiguous name\n-\n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:104:21\n    |\n LL |         fn from_i32(self) {}\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `as_*` usually take self by reference or self by mutable reference\n+error: methods called `as_*` usually take `self` by reference or `self` by mutable reference\n   --> $DIR/wrong_self_convention.rs:119:19\n    |\n LL |         fn as_i32(self);\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value\n+error: methods called `into_*` usually take `self` by value\n   --> $DIR/wrong_self_convention.rs:122:25\n    |\n LL |         fn into_i32_ref(&self);\n    |                         ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take self by reference or no self\n+error: methods called `is_*` usually take `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:124:19\n    |\n LL |         fn is_i32(self);\n    |                   ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `to_*` usually take self by reference\n-  --> $DIR/wrong_self_convention.rs:126:19\n-   |\n-LL |         fn to_i32(self);\n-   |                   ^^^^\n-   |\n-   = help: consider choosing a less ambiguous name\n-\n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:128:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `into_*` usually take self by value\n+error: methods called `into_*` usually take `self` by value\n   --> $DIR/wrong_self_convention.rs:146:25\n    |\n LL |         fn into_i32_ref(&self);\n    |                         ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `from_*` usually take no self\n+error: methods called `from_*` usually take no `self`\n   --> $DIR/wrong_self_convention.rs:152:21\n    |\n LL |         fn from_i32(self);\n    |                     ^^^^\n    |\n    = help: consider choosing a less ambiguous name\n \n+error: methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\n+  --> $DIR/wrong_self_convention.rs:181:22\n+   |\n+LL |         fn to_u64_v2(&self) -> u64 {\n+   |                      ^^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n+error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n+  --> $DIR/wrong_self_convention.rs:190:19\n+   |\n+LL |         fn to_u64(self) -> u64 {\n+   |                   ^^^^\n+   |\n+   = help: consider choosing a less ambiguous name\n+\n error: aborting due to 24 previous errors\n "}, {"sha": "6ce37c5949111bf20d20b66ffc00ad6170029a69", "filename": "tests/ui/wrong_self_conventions_mut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fwrong_self_conventions_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e/tests%2Fui%2Fwrong_self_conventions_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_conventions_mut.stderr?ref=1d3c539fbbdddc2c0ab2c512e70f4f6ea2d37c5e", "patch": "@@ -1,4 +1,4 @@\n-error: methods called `to_*` usually take self by reference\n+error: methods with the following characteristics: (`to_*` and `self` type is not `Copy`) usually take `self` by reference\n   --> $DIR/wrong_self_conventions_mut.rs:15:24\n    |\n LL |         pub fn to_many(&mut self) -> Option<&mut [T]> {\n@@ -7,7 +7,7 @@ LL |         pub fn to_many(&mut self) -> Option<&mut [T]> {\n    = note: `-D clippy::wrong-self-convention` implied by `-D warnings`\n    = help: consider choosing a less ambiguous name\n \n-error: methods called like this: (`to_*` and `*_mut`) usually take self by mutable reference\n+error: methods with the following characteristics: (`to_*` and `*_mut`) usually take `self` by mutable reference\n   --> $DIR/wrong_self_conventions_mut.rs:23:28\n    |\n LL |         pub fn to_many_mut(&self) -> Option<&[T]> {"}]}