{"sha": "b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1ZjZkN2VjMmQ0ZTIzMWI5ZWYwYzhhOWU4ZTdlYzhhN2Y2N2QyYWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-22T13:37:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-22T13:37:30Z"}, "message": "Auto merge of #37298 - nnethercote:faster-deflate, r=alexcrichton\n\nUse a faster `deflate` setting\n\nIn #37086 we have considered various ideas for reducing the cost of LLVM bytecode compression. This PR implements the simplest of these: use a faster `deflate` setting. It's very simple and reduces the compression time by almost half while increasing the size of the resulting rlibs by only about 2%.\n\nI looked at using zstd, which might be able to halve the compression time again. But integrating zstd is beyond my Rust FFI integration abilities at the moment -- it consists of a few dozen C files, has a non-trivial build system, etc. I decided it was worth getting a big chunk of the possible improvement with minimum effort.\n\nThe following table shows the before and after percentages of instructions executed during compression while doing debug builds of some of the rustc-benchmarks with a stage1 compiler.\n```\nhtml5ever-2016-08-25      1.4% -> 0.7%\nhyper.0.5.0               3.8% -> 2.4%\ninflate-0.1.0             1.0% -> 0.5%\npiston-image-0.10.3       2.9% -> 1.8%\nregex.0.1.30              3.4% -> 2.1%\nrust-encoding-0.3.0       4.8% -> 2.9%\nsyntex-0.42.2             2.9% -> 1.8%\nsyntex-0.42.2-incr-clean 14.2% -> 8.9%\n```\nThe omitted ones spend 0% of their time in decompression.\n\nAnd here are actual timings:\n```\nfutures-rs-test  4.110s vs  4.102s --> 1.002x faster (variance: 1.017x, 1.004x)\nhelloworld       0.223s vs  0.226s --> 0.986x faster (variance: 1.012x, 1.022x)\nhtml5ever-2016-  4.218s vs  4.186s --> 1.008x faster (variance: 1.008x, 1.010x)\nhyper.0.5.0      4.746s vs  4.661s --> 1.018x faster (variance: 1.002x, 1.016x)\ninflate-0.1.0    4.194s vs  4.143s --> 1.012x faster (variance: 1.007x, 1.006x)\nissue-32062-equ  0.317s vs  0.316s --> 1.001x faster (variance: 1.013x, 1.005x)\nissue-32278-big  1.811s vs  1.825s --> 0.992x faster (variance: 1.014x, 1.006x)\njld-day15-parse  1.412s vs  1.412s --> 1.001x faster (variance: 1.019x, 1.008x)\npiston-image-0. 11.058s vs 10.977s --> 1.007x faster (variance: 1.008x, 1.039x)\nreddit-stress    2.331s vs  2.342s --> 0.995x faster (variance: 1.019x, 1.006x)\nregex.0.1.30     2.294s vs  2.276s --> 1.008x faster (variance: 1.007x, 1.007x)\nrust-encoding-0  1.963s vs  1.924s --> 1.020x faster (variance: 1.009x, 1.006x)\nsyntex-0.42.2   29.667s vs 29.391s --> 1.009x faster (variance: 1.002x, 1.023x)\nsyntex-0.42.2-i 15.257s vs 14.148s --> 1.078x faster (variance: 1.018x, 1.008x)\n```\n\nr? @alexcrichton", "tree": {"sha": "0a7acb4a9bbeef0fde0b8be462f15d75e9ec9e32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a7acb4a9bbeef0fde0b8be462f15d75e9ec9e32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae", "html_url": "https://github.com/rust-lang/rust/commit/b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4879166194ed63ebd2a8c3ce8db1ccde4a6a1920", "url": "https://api.github.com/repos/rust-lang/rust/commits/4879166194ed63ebd2a8c3ce8db1ccde4a6a1920", "html_url": "https://github.com/rust-lang/rust/commit/4879166194ed63ebd2a8c3ce8db1ccde4a6a1920"}, {"sha": "94771a177ba133bfadd0ffba55d82e7e3989ea06", "url": "https://api.github.com/repos/rust-lang/rust/commits/94771a177ba133bfadd0ffba55d82e7e3989ea06", "html_url": "https://github.com/rust-lang/rust/commit/94771a177ba133bfadd0ffba55d82e7e3989ea06"}], "stats": {"total": 35, "additions": 10, "deletions": 25}, "files": [{"sha": "3c608ef9c9268b5554fae5617d108c42e8015ea5", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=b5f6d7ec2d4e231b9ef0c8a9e8e7ec8a7f67d2ae", "patch": "@@ -94,11 +94,14 @@ extern \"C\" {\n                                     -> *mut c_void;\n }\n \n-const LZ_NORM: c_int = 0x80;  // LZ with 128 probes, \"normal\"\n-const TINFL_FLAG_PARSE_ZLIB_HEADER: c_int = 0x1; // parse zlib header and adler32 checksum\n-const TDEFL_WRITE_ZLIB_HEADER: c_int = 0x01000; // write zlib header and adler32 checksum\n+const LZ_FAST: c_int = 0x01;  // LZ with 1 probe, \"fast\"\n+const TDEFL_GREEDY_PARSING_FLAG: c_int = 0x04000; // fast greedy parsing instead of lazy parsing\n \n-fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Bytes {\n+/// Compress a buffer without writing any sort of header on the output. Fast\n+/// compression is used because it is almost twice as fast as default\n+/// compression and the compression ratio is only marginally worse.\n+pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n+    let flags = LZ_FAST | TDEFL_GREEDY_PARSING_FLAG;\n     unsafe {\n         let mut outsz: size_t = 0;\n         let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n@@ -113,17 +116,9 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Bytes {\n     }\n }\n \n-/// Compress a buffer, without writing any sort of header on the output.\n-pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n-    deflate_bytes_internal(bytes, LZ_NORM)\n-}\n-\n-/// Compress a buffer, using a header that zlib can understand.\n-pub fn deflate_bytes_zlib(bytes: &[u8]) -> Bytes {\n-    deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n-}\n-\n-fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Result<Bytes, Error> {\n+/// Decompress a buffer without parsing any sort of header on the input.\n+pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes, Error> {\n+    let flags = 0;\n     unsafe {\n         let mut outsz: size_t = 0;\n         let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n@@ -141,16 +136,6 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Result<Bytes, Error> {\n     }\n }\n \n-/// Decompress a buffer, without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes, Error> {\n-    inflate_bytes_internal(bytes, 0)\n-}\n-\n-/// Decompress a buffer that starts with a zlib header.\n-pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes, Error> {\n-    inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n-}\n-\n #[cfg(test)]\n mod tests {\n     #![allow(deprecated)]"}]}