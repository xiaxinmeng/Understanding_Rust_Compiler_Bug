{"sha": "c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMGZkOGY1OGM5Yzc3ODBiODNmYmI0ZTVlMmU0MTlmMWRkZDM3ZTI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-21T20:46:12Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:04Z"}, "message": "Refactor interval conditions", "tree": {"sha": "5f1046db88b6bf5d385982b803b3d37e63be52d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f1046db88b6bf5d385982b803b3d37e63be52d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2", "html_url": "https://github.com/rust-lang/rust/commit/c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f720304218da4d671bcbc332c0342f9405962c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f720304218da4d671bcbc332c0342f9405962c8", "html_url": "https://github.com/rust-lang/rust/commit/7f720304218da4d671bcbc332c0342f9405962c8"}], "stats": {"total": 43, "additions": 19, "deletions": 24}, "files": [{"sha": "204d3ea8c9c20a86c00fbb95c31ec68f569ec014", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=c00fd8f58c9c7780b83fbb4e5e2e419f1ddd37e2", "patch": "@@ -620,8 +620,7 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n \n /// An inclusive interval, used for precise integer exhaustiveness checking.\n struct Interval<'tcx> {\n-    pub lo: u128,\n-    pub hi: u128,\n+    pub range: RangeInclusive<u128>,\n     pub ty: Ty<'tcx>,\n }\n \n@@ -641,15 +640,15 @@ impl<'tcx> Interval<'tcx> {\n                             None\n                         } else {\n                             let offset = (*end == RangeEnd::Excluded) as u128;\n-                            Some(Interval { lo, hi: hi - offset, ty })\n+                            Some(Interval { range: lo..=(hi - offset), ty })\n                         };\n                     }\n                 }\n                 None\n             }\n             ConstantValue(val) => {\n                 let ty = val.ty;\n-                val.assert_bits(ty).map(|val| Interval { lo: val, hi: val, ty })\n+                val.assert_bits(ty).map(|val| Interval { range: val..=val, ty })\n             }\n             Single | Variant(_) | Slice(_) => {\n                 None\n@@ -690,7 +689,7 @@ impl<'tcx> Interval<'tcx> {\n     }\n \n     fn into_inner(self) -> (u128, u128) {\n-        (self.lo, self.hi)\n+        self.range.into_inner()\n     }\n }\n \n@@ -706,31 +705,27 @@ fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let mut ranges: Vec<_> = ranges.into_iter().filter_map(|r| {\n             Interval::from_ctor(&r).map(|i| i.into_inner())\n         }).collect();\n+        let ty = pat_interval.ty;\n+        let (pat_interval_lo, pat_interval_hi) = pat_interval.into_inner();\n         for (subrange_lo, subrange_hi) in ranges {\n-            if pat_interval.lo > subrange_hi || pat_interval.hi < subrange_lo {\n+            if pat_interval_lo > subrange_hi || subrange_lo > pat_interval_hi  {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n                 remaining_ranges.push((subrange_lo, subrange_hi));\n-            } else if pat_interval.lo <= subrange_lo && pat_interval.hi >= subrange_hi {\n-                // The pattern entirely covers the subrange of values,\n-                // so we no longer have to consider this subrange_\n-            } else if pat_interval.lo <= subrange_lo {\n-                // The pattern intersects a lower section of the subrange,\n-                // so only the upper section will remain.\n-                remaining_ranges.push((pat_interval.hi + 1, subrange_hi));\n-            } else if pat_interval.hi >= subrange_hi {\n-                // The pattern intersects an upper section of the subrange,\n-                // so only the lower section will remain.\n-                remaining_ranges.push((subrange_lo, pat_interval.lo - 1));\n             } else {\n-                // The pattern intersects the middle of the subrange,\n-                // so we create two ranges either side of the intersection.)\n-                remaining_ranges.push((subrange_lo, pat_interval.lo - 1));\n-                remaining_ranges.push((pat_interval.hi + 1, subrange_hi));\n+                if pat_interval_lo > subrange_lo {\n+                    // The pattern intersects an upper section of the\n+                    // subrange, so a lower section will remain.\n+                    remaining_ranges.push((subrange_lo, pat_interval_lo - 1));\n+                }\n+                if pat_interval_hi < subrange_hi {\n+                    // The pattern intersects a lower section of the\n+                    // subrange, so an upper section will remain.\n+                    remaining_ranges.push((pat_interval_hi + 1, subrange_hi));\n+                }\n             }\n         }\n         // Convert the remaining ranges from pairs to inclusive `ConstantRange`s.\n-        let ty = pat_interval.ty;\n         remaining_ranges.into_iter().map(|(lo, hi)| {\n             let (lo, hi) = Interval::offset_sign(ty, (lo, hi), false);\n             ConstantRange(ty::Const::from_bits(cx.tcx, lo, ty),\n@@ -839,7 +834,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         // `missing_ctors` are those that should have appeared\n         // as patterns in the `match` expression, but did not.\n         let mut missing_ctors = vec![];\n-        'req: for req_ctor in all_ctors.clone() {\n+        'req: for req_ctor in &all_ctors {\n             let mut sub_ctors = vec![req_ctor.clone()];\n             // The only constructor patterns for which it is valid to\n             // treat the values as constructors are ranges (see\n@@ -861,7 +856,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // If the pattern for the required constructor\n                     // appears in the `match`, then it is not missing,\n                     // and we can move on to the next one.\n-                    if *used_ctor == req_ctor {\n+                    if used_ctor == req_ctor {\n                         continue 'req;\n                     }\n                 }"}]}