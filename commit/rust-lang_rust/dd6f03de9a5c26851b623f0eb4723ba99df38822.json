{"sha": "dd6f03de9a5c26851b623f0eb4723ba99df38822", "node_id": "C_kwDOAAsO6NoAKGRkNmYwM2RlOWE1YzI2ODUxYjYyM2YwZWI0NzIzYmE5OWRmMzg4MjI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-04T19:48:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-04T19:48:17Z"}, "message": "Rollup merge of #108715 - chenyukang:yukang/cleanup-parser-delims, r=compiler-errors\n\nRemove unclosed_delims from parser\n\nAfter landing https://github.com/rust-lang/rust/pull/108297\nwe could remove `unclosed_delims` from the parser now.", "tree": {"sha": "056d4813e03975b9a938694d4f38a35819e1364d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/056d4813e03975b9a938694d4f38a35819e1364d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd6f03de9a5c26851b623f0eb4723ba99df38822", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkA6CBCRBK7hj4Ov3rIwAAXa4IAH+Tx4EacB8lMoiijBOQO5Wc\nyxVtpPT7uDkkII/VTarXN8lu4UvQZthUeBs27MVxZKczxf1ehkp5YwZeiJW6ygCR\nS3BvCseFgnJOUYciGOCso6rjN/o8SxsF0HMMbyQWBxucPww2dUs7zboA8GrPwCfK\n+mT5tuv3IY6/QhSGwaWrJUZ1mk8nVBmD0hApXUCPyizZzDeAMy0BDtWUl3t8FT9L\nzRhZ62PXrU1xug8L16UsWZUa4HTzd4NJXwg3RMnjfX4KUaJPDrXW0DkU7PAJLU1D\ntqkVCKSwkLGRwh/N5z2hzbn/9PBZ4d5qgQEMWl39nyO/s24n2TRay0+A4r9Y1Rk=\n=mIj0\n-----END PGP SIGNATURE-----\n", "payload": "tree 056d4813e03975b9a938694d4f38a35819e1364d\nparent 538f19d6386897867bae85319b510088bc89313f\nparent d1073fab35280ed4fac22f619beda75ca132f386\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1677959297 +0100\ncommitter GitHub <noreply@github.com> 1677959297 +0100\n\nRollup merge of #108715 - chenyukang:yukang/cleanup-parser-delims, r=compiler-errors\n\nRemove unclosed_delims from parser\n\nAfter landing https://github.com/rust-lang/rust/pull/108297\nwe could remove `unclosed_delims` from the parser now.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd6f03de9a5c26851b623f0eb4723ba99df38822", "html_url": "https://github.com/rust-lang/rust/commit/dd6f03de9a5c26851b623f0eb4723ba99df38822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd6f03de9a5c26851b623f0eb4723ba99df38822/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538f19d6386897867bae85319b510088bc89313f", "url": "https://api.github.com/repos/rust-lang/rust/commits/538f19d6386897867bae85319b510088bc89313f", "html_url": "https://github.com/rust-lang/rust/commit/538f19d6386897867bae85319b510088bc89313f"}, {"sha": "d1073fab35280ed4fac22f619beda75ca132f386", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1073fab35280ed4fac22f619beda75ca132f386", "html_url": "https://github.com/rust-lang/rust/commit/d1073fab35280ed4fac22f619beda75ca132f386"}], "stats": {"total": 170, "additions": 12, "deletions": 158}, "files": [{"sha": "0a65c37ea7b79332c1c8e3e86da1979ffd452c48", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 113, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=dd6f03de9a5c26851b623f0eb4723ba99df38822", "patch": "@@ -19,7 +19,6 @@ use crate::errors::{\n };\n \n use crate::fluent_generated as fluent;\n-use crate::lexer::UnmatchedDelim;\n use crate::parser;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n@@ -220,7 +219,6 @@ impl MultiSugg {\n /// is dropped.\n pub struct SnapshotParser<'a> {\n     parser: Parser<'a>,\n-    unclosed_delims: Vec<UnmatchedDelim>,\n }\n \n impl<'a> Deref for SnapshotParser<'a> {\n@@ -255,27 +253,15 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    /// Replace `self` with `snapshot.parser` and extend `unclosed_delims` with `snapshot.unclosed_delims`.\n-    /// This is to avoid losing unclosed delims errors `create_snapshot_for_diagnostic` clears.\n+    /// Replace `self` with `snapshot.parser`.\n     pub(super) fn restore_snapshot(&mut self, snapshot: SnapshotParser<'a>) {\n         *self = snapshot.parser;\n-        self.unclosed_delims.extend(snapshot.unclosed_delims);\n-    }\n-\n-    pub fn unclosed_delims(&self) -> &[UnmatchedDelim] {\n-        &self.unclosed_delims\n     }\n \n     /// Create a snapshot of the `Parser`.\n     pub fn create_snapshot_for_diagnostic(&self) -> SnapshotParser<'a> {\n-        let mut snapshot = self.clone();\n-        let unclosed_delims = self.unclosed_delims.clone();\n-        // Clear `unclosed_delims` in snapshot to avoid\n-        // duplicate errors being emitted when the `Parser`\n-        // is dropped (which may or may not happen, depending\n-        // if the parsing the snapshot is created for is successful)\n-        snapshot.unclosed_delims.clear();\n-        SnapshotParser { parser: snapshot, unclosed_delims }\n+        let snapshot = self.clone();\n+        SnapshotParser { parser: snapshot }\n     }\n \n     pub(super) fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n@@ -579,21 +565,6 @@ impl<'a> Parser<'a> {\n         } else {\n             label_sp\n         };\n-        match self.recover_closing_delimiter(\n-            &expected\n-                .iter()\n-                .filter_map(|tt| match tt {\n-                    TokenType::Token(t) => Some(t.clone()),\n-                    _ => None,\n-                })\n-                .collect::<Vec<_>>(),\n-            err,\n-        ) {\n-            Err(e) => err = e,\n-            Ok(recovered) => {\n-                return Ok(recovered);\n-            }\n-        }\n \n         if self.check_too_many_raw_str_terminators(&mut err) {\n             if expected.contains(&TokenType::Token(token::Semi)) && self.eat(&token::Semi) {\n@@ -1573,12 +1544,6 @@ impl<'a> Parser<'a> {\n         );\n         let mut err = self.struct_span_err(sp, &msg);\n         let label_exp = format!(\"expected `{token_str}`\");\n-        match self.recover_closing_delimiter(&[t.clone()], err) {\n-            Err(e) => err = e,\n-            Ok(recovered) => {\n-                return Ok(recovered);\n-            }\n-        }\n         let sm = self.sess.source_map();\n         if !sm.is_multiline(prev_sp.until(sp)) {\n             // When the spans are in the same line, it means that the only content\n@@ -1795,81 +1760,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn recover_closing_delimiter(\n-        &mut self,\n-        tokens: &[TokenKind],\n-        mut err: DiagnosticBuilder<'a, ErrorGuaranteed>,\n-    ) -> PResult<'a, bool> {\n-        let mut pos = None;\n-        // We want to use the last closing delim that would apply.\n-        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n-            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.token.span) > unmatched.unclosed_span\n-            {\n-                pos = Some(i);\n-            }\n-        }\n-        match pos {\n-            Some(pos) => {\n-                // Recover and assume that the detected unclosed delimiter was meant for\n-                // this location. Emit the diagnostic and act as if the delimiter was\n-                // present for the parser's sake.\n-\n-                // Don't attempt to recover from this unclosed delimiter more than once.\n-                let unmatched = self.unclosed_delims.remove(pos);\n-                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n-                if unmatched.found_delim.is_none() {\n-                    // We encountered `Eof`, set this fact here to avoid complaining about missing\n-                    // `fn main()` when we found place to suggest the closing brace.\n-                    *self.sess.reached_eof.borrow_mut() = true;\n-                }\n-\n-                // We want to suggest the inclusion of the closing delimiter where it makes\n-                // the most sense, which is immediately after the last token:\n-                //\n-                //  {foo(bar {}}\n-                //      ^      ^\n-                //      |      |\n-                //      |      help: `)` may belong here\n-                //      |\n-                //      unclosed delimiter\n-                if let Some(sp) = unmatched.unclosed_span {\n-                    let mut primary_span: Vec<Span> =\n-                        err.span.primary_spans().iter().cloned().collect();\n-                    primary_span.push(sp);\n-                    let mut primary_span: MultiSpan = primary_span.into();\n-                    for span_label in err.span.span_labels() {\n-                        if let Some(label) = span_label.label {\n-                            primary_span.push_span_label(span_label.span, label);\n-                        }\n-                    }\n-                    err.set_span(primary_span);\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                }\n-                // Backticks should be removed to apply suggestions.\n-                let mut delim = delim.to_string();\n-                delim.retain(|c| c != '`');\n-                err.span_suggestion_short(\n-                    self.prev_token.span.shrink_to_hi(),\n-                    &format!(\"`{delim}` may belong here\"),\n-                    delim,\n-                    Applicability::MaybeIncorrect,\n-                );\n-                if unmatched.found_delim.is_none() {\n-                    // Encountered `Eof` when lexing blocks. Do not recover here to avoid knockdown\n-                    // errors which would be emitted elsewhere in the parser and let other error\n-                    // recovery consume the rest of the file.\n-                    Err(err)\n-                } else {\n-                    err.emit();\n-                    self.expected_tokens.clear(); // Reduce the number of errors.\n-                    Ok(true)\n-                }\n-            }\n-            _ => Err(err),\n-        }\n-    }\n-\n     /// Eats tokens until we can be relatively sure we reached the end of the\n     /// statement. This is something of a best-effort heuristic.\n     ///"}, {"sha": "e00eda47c663ee0cc811b370bc8cf8375511c980", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=dd6f03de9a5c26851b623f0eb4723ba99df38822", "patch": "@@ -1394,19 +1394,6 @@ impl<'a> Parser<'a> {\n             self.parse_expr_let()\n         } else if self.eat_keyword(kw::Underscore) {\n             Ok(self.mk_expr(self.prev_token.span, ExprKind::Underscore))\n-        } else if !self.unclosed_delims.is_empty() && self.check(&token::Semi) {\n-            // Don't complain about bare semicolons after unclosed braces\n-            // recovery in order to keep the error count down. Fixing the\n-            // delimiters will possibly also fix the bare semicolon found in\n-            // expression context. For example, silence the following error:\n-            //\n-            //     error: expected expression, found `;`\n-            //      --> file.rs:2:13\n-            //       |\n-            //     2 |     foo(bar(;\n-            //       |             ^ expected expression\n-            self.bump();\n-            Ok(self.mk_expr_err(self.token.span))\n         } else if self.token.uninterpolated_span().rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {"}, {"sha": "85cc8ca02a9779038658adbf6c71bb77e1d2b360", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=dd6f03de9a5c26851b623f0eb4723ba99df38822", "patch": "@@ -125,16 +125,13 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item.into_inner()));\n         };\n \n-        let mut unclosed_delims = vec![];\n         let item =\n             self.collect_tokens_trailing_token(attrs, force_collect, |this: &mut Self, attrs| {\n                 let item =\n                     this.parse_item_common_(attrs, mac_allowed, attrs_allowed, fn_parse_mode);\n-                unclosed_delims.append(&mut this.unclosed_delims);\n                 Ok((item?, TrailingToken::None))\n             })?;\n \n-        self.unclosed_delims.append(&mut unclosed_delims);\n         Ok(item)\n     }\n \n@@ -1960,21 +1957,12 @@ impl<'a> Parser<'a> {\n         // FIXME: This will make us not emit the help even for declarative\n         // macros within the same crate (that we can fix), which is sad.\n         if !span.from_expansion() {\n-            if self.unclosed_delims.is_empty() {\n-                let DelimSpan { open, close } = args.dspan;\n-                err.multipart_suggestion(\n-                    \"change the delimiters to curly braces\",\n-                    vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.span_suggestion(\n-                    span,\n-                    \"change the delimiters to curly braces\",\n-                    \" { /* items */ }\",\n-                    Applicability::HasPlaceholders,\n-                );\n-            }\n+            let DelimSpan { open, close } = args.dspan;\n+            err.multipart_suggestion(\n+                \"change the delimiters to curly braces\",\n+                vec![(open, \"{\".to_string()), (close, '}'.to_string())],\n+                Applicability::MaybeIncorrect,\n+            );\n             err.span_suggestion(\n                 span.shrink_to_hi(),\n                 \"add a semicolon\","}, {"sha": "6e9b447fa61a91494311475d54e89d88db88b152", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd6f03de9a5c26851b623f0eb4723ba99df38822/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=dd6f03de9a5c26851b623f0eb4723ba99df38822", "patch": "@@ -146,10 +146,7 @@ pub struct Parser<'a> {\n     /// See the comments in the `parse_path_segment` function for more details.\n     unmatched_angle_bracket_count: u32,\n     max_angle_bracket_count: u32,\n-    /// A list of all unclosed delimiters found by the lexer. If an entry is used for error recovery\n-    /// it gets removed from here. Every entry left at the end gets emitted as an independent\n-    /// error.\n-    pub(super) unclosed_delims: Vec<UnmatchedDelim>,\n+\n     last_unexpected_token_span: Option<Span>,\n     /// Span pointing at the `:` for the last type ascription the parser has seen, and whether it\n     /// looked like it could have been a mistyped path or literal `Option:Some(42)`).\n@@ -168,7 +165,7 @@ pub struct Parser<'a> {\n // This type is used a lot, e.g. it's cloned when matching many declarative macro rules with nonterminals. Make sure\n // it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Parser<'_>, 312);\n+rustc_data_structures::static_assert_size!(Parser<'_>, 288);\n \n /// Stores span information about a closure.\n #[derive(Clone)]\n@@ -215,12 +212,6 @@ struct CaptureState {\n     inner_attr_ranges: FxHashMap<AttrId, ReplaceRange>,\n }\n \n-impl<'a> Drop for Parser<'a> {\n-    fn drop(&mut self) {\n-        emit_unclosed_delims(&mut self.unclosed_delims, &self.sess);\n-    }\n-}\n-\n /// Iterator over a `TokenStream` that produces `Token`s. It's a bit odd that\n /// we (a) lex tokens into a nice tree structure (`TokenStream`), and then (b)\n /// use this type to emit them as a linear sequence. But a linear sequence is\n@@ -478,7 +469,6 @@ impl<'a> Parser<'a> {\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n-            unclosed_delims: Vec::new(),\n             last_unexpected_token_span: None,\n             last_type_ascription: None,\n             subparser_name,\n@@ -859,7 +849,6 @@ impl<'a> Parser<'a> {\n         let mut recovered = false;\n         let mut trailing = false;\n         let mut v = ThinVec::new();\n-        let unclosed_delims = !self.unclosed_delims.is_empty();\n \n         while !self.expect_any_with_type(kets, expect) {\n             if let token::CloseDelim(..) | token::Eof = self.token.kind {\n@@ -901,7 +890,7 @@ impl<'a> Parser<'a> {\n                                 _ => {\n                                     // Attempt to keep parsing if it was a similar separator.\n                                     if let Some(tokens) = t.similar_tokens() {\n-                                        if tokens.contains(&self.token.kind) && !unclosed_delims {\n+                                        if tokens.contains(&self.token.kind) {\n                                             self.bump();\n                                         }\n                                     }"}]}