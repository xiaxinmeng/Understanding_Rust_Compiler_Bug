{"sha": "64e6b8200bfceea92b0dcaab3e533a9152994e78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZTZiODIwMGJmY2VlYTkyYjBkY2FhYjNlNTMzYTkxNTI5OTRlNzg=", "commit": {"author": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-04-25T14:58:28Z"}, "committer": {"name": "Timo Freiberg", "email": "timo.freiberg@gmail.com", "date": "2020-05-08T15:14:45Z"}, "message": "Use new HirDisplay variant in add_function assist", "tree": {"sha": "a87605bb775738a0d8c52288a22406d911da8d1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a87605bb775738a0d8c52288a22406d911da8d1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64e6b8200bfceea92b0dcaab3e533a9152994e78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64e6b8200bfceea92b0dcaab3e533a9152994e78", "html_url": "https://github.com/rust-lang/rust/commit/64e6b8200bfceea92b0dcaab3e533a9152994e78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64e6b8200bfceea92b0dcaab3e533a9152994e78/comments", "author": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimoFreiberg", "id": 5281645, "node_id": "MDQ6VXNlcjUyODE2NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5281645?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimoFreiberg", "html_url": "https://github.com/TimoFreiberg", "followers_url": "https://api.github.com/users/TimoFreiberg/followers", "following_url": "https://api.github.com/users/TimoFreiberg/following{/other_user}", "gists_url": "https://api.github.com/users/TimoFreiberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimoFreiberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimoFreiberg/subscriptions", "organizations_url": "https://api.github.com/users/TimoFreiberg/orgs", "repos_url": "https://api.github.com/users/TimoFreiberg/repos", "events_url": "https://api.github.com/users/TimoFreiberg/events{/privacy}", "received_events_url": "https://api.github.com/users/TimoFreiberg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe93675e8ac2b55d051156151489dbe0496efec3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe93675e8ac2b55d051156151489dbe0496efec3", "html_url": "https://github.com/rust-lang/rust/commit/fe93675e8ac2b55d051156151489dbe0496efec3"}], "stats": {"total": 174, "additions": 116, "deletions": 58}, "files": [{"sha": "95faf0f4feea3c7446ba06663e43a5700b27522c", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 116, "deletions": 58, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/64e6b8200bfceea92b0dcaab3e533a9152994e78/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64e6b8200bfceea92b0dcaab3e533a9152994e78/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=64e6b8200bfceea92b0dcaab3e533a9152994e78", "patch": "@@ -43,16 +43,12 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         return None;\n     }\n \n-    let target_module = if let Some(qualifier) = path.qualifier() {\n-        if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) =\n-            ctx.sema.resolve_path(&qualifier)\n-        {\n-            Some(module.definition_source(ctx.sema.db))\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        None\n+    let target_module = match path.qualifier() {\n+        Some(qualifier) => match ctx.sema.resolve_path(&qualifier) {\n+            Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) => Some(module),\n+            _ => return None,\n+        },\n+        None => None,\n     };\n \n     let function_builder = FunctionBuilder::from_call(&ctx, &call, &path, target_module)?;\n@@ -83,25 +79,29 @@ struct FunctionBuilder {\n }\n \n impl FunctionBuilder {\n-    /// Prepares a generated function that matches `call` in `generate_in`\n-    /// (or as close to `call` as possible, if `generate_in` is `None`)\n+    /// Prepares a generated function that matches `call`.\n+    /// The function is generated in `target_module` or next to `call`\n     fn from_call(\n         ctx: &AssistContext,\n         call: &ast::CallExpr,\n         path: &ast::Path,\n-        target_module: Option<hir::InFile<hir::ModuleSource>>,\n+        target_module: Option<hir::Module>,\n     ) -> Option<Self> {\n-        let needs_pub = target_module.is_some();\n         let mut file = ctx.frange.file_id;\n-        let target = if let Some(target_module) = target_module {\n-            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, target_module)?;\n-            file = in_file;\n-            target\n-        } else {\n-            next_space_for_fn_after_call_site(&call)?\n+        let target = match &target_module {\n+            Some(target_module) => {\n+                let module_source = target_module.definition_source(ctx.db);\n+                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+                file = in_file;\n+                target\n+            }\n+            None => next_space_for_fn_after_call_site(&call)?,\n         };\n+        let needs_pub = target_module.is_some();\n+        let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = fn_name(&path)?;\n-        let (type_params, params) = fn_args(ctx, &call)?;\n+        let (type_params, params) = fn_args(ctx, target_module, &call)?;\n+\n         Some(Self { target, fn_name, type_params, params, file, needs_pub })\n     }\n \n@@ -144,6 +144,15 @@ enum GeneratedFunctionTarget {\n     InEmptyItemList(ast::ItemList),\n }\n \n+impl GeneratedFunctionTarget {\n+    fn syntax(&self) -> &SyntaxNode {\n+        match self {\n+            GeneratedFunctionTarget::BehindItem(it) => it,\n+            GeneratedFunctionTarget::InEmptyItemList(it) => it.syntax(),\n+        }\n+    }\n+}\n+\n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n     Some(ast::make::name(&name))\n@@ -152,17 +161,17 @@ fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n /// Computes the type variables and arguments required for the generated function\n fn fn_args(\n     ctx: &AssistContext,\n+    target_module: hir::Module,\n     call: &ast::CallExpr,\n ) -> Option<(Option<ast::TypeParamList>, ast::ParamList)> {\n     let mut arg_names = Vec::new();\n     let mut arg_types = Vec::new();\n     for arg in call.arg_list()?.args() {\n-        let arg_name = match fn_arg_name(&arg) {\n+        arg_names.push(match fn_arg_name(&arg) {\n             Some(name) => name,\n             None => String::from(\"arg\"),\n-        };\n-        arg_names.push(arg_name);\n-        arg_types.push(match fn_arg_type(ctx, &arg) {\n+        });\n+        arg_types.push(match fn_arg_type(ctx, target_module, &arg) {\n             Some(ty) => ty,\n             None => String::from(\"()\"),\n         });\n@@ -218,12 +227,21 @@ fn fn_arg_name(fn_arg: &ast::Expr) -> Option<String> {\n     }\n }\n \n-fn fn_arg_type(ctx: &AssistContext, fn_arg: &ast::Expr) -> Option<String> {\n+fn fn_arg_type(\n+    ctx: &AssistContext,\n+    target_module: hir::Module,\n+    fn_arg: &ast::Expr,\n+) -> Option<String> {\n     let ty = ctx.sema.type_of_expr(fn_arg)?;\n     if ty.is_unknown() {\n         return None;\n     }\n-    Some(ty.display(ctx.sema.db).to_string())\n+\n+    if let Ok(rendered) = ty.display_source_code(ctx.db, target_module.into()) {\n+        Some(rendered)\n+    } else {\n+        None\n+    }\n }\n \n /// Returns the position inside the current mod or file\n@@ -252,10 +270,10 @@ fn next_space_for_fn_after_call_site(expr: &ast::CallExpr) -> Option<GeneratedFu\n \n fn next_space_for_fn_in_module(\n     db: &dyn hir::db::AstDatabase,\n-    module: hir::InFile<hir::ModuleSource>,\n+    module_source: &hir::InFile<hir::ModuleSource>,\n ) -> Option<(FileId, GeneratedFunctionTarget)> {\n-    let file = module.file_id.original_file(db);\n-    let assist_item = match module.value {\n+    let file = module_source.file_id.original_file(db);\n+    let assist_item = match &module_source.value {\n         hir::ModuleSource::SourceFile(it) => {\n             if let Some(last_item) = it.items().last() {\n                 GeneratedFunctionTarget::BehindItem(last_item.syntax().clone())\n@@ -599,8 +617,33 @@ fn bar(foo: impl Foo) {\n     }\n \n     #[test]\n-    #[ignore]\n-    // FIXME print paths properly to make this test pass\n+    fn borrowed_arg() {\n+        check_assist(\n+            add_function,\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar<|>(&baz())\n+}\n+\",\n+            r\"\n+struct Baz;\n+fn baz() -> Baz { todo!() }\n+\n+fn foo() {\n+    bar(&baz())\n+}\n+\n+fn bar(baz: &Baz) {\n+    <|>todo!()\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n     fn add_function_with_qualified_path_arg() {\n         check_assist(\n             add_function,\n@@ -609,25 +652,21 @@ mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        <|>bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    <|>bar(Baz::baz())\n }\n \",\n             r\"\n mod Baz {\n     pub struct Bof;\n     pub fn baz() -> Bof { Bof }\n }\n-mod Foo {\n-    fn foo() {\n-        bar(super::Baz::baz())\n-    }\n+fn foo() {\n+    bar(Baz::baz())\n+}\n \n-    fn bar(baz: super::Baz::Bof) {\n-        <|>todo!()\n-    }\n+fn bar(baz: Baz::Bof) {\n+    <|>todo!()\n }\n \",\n         )\n@@ -808,6 +847,40 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    #[ignore]\n+    // Ignored until local imports are supported.\n+    // See https://github.com/rust-analyzer/rust-analyzer/issues/1165\n+    fn qualified_path_uses_correct_scope() {\n+        check_assist(\n+            add_function,\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz<|>(foo)\n+}\n+\",\n+            \"\n+mod foo {\n+    pub struct Foo;\n+}\n+fn bar() {\n+    use foo::Foo;\n+    let foo = Foo;\n+    baz(foo)\n+}\n+\n+fn baz(foo: foo::Foo) {\n+    <|>todo!()\n+}\n+\",\n+        )\n+    }\n+\n     #[test]\n     fn add_function_in_module_containing_other_items() {\n         check_assist(\n@@ -919,21 +992,6 @@ fn bar(baz: ()) {}\n         )\n     }\n \n-    #[test]\n-    fn add_function_not_applicable_if_function_path_not_singleton() {\n-        // In the future this assist could be extended to generate functions\n-        // if the path is in the same crate (or even the same workspace).\n-        // For the beginning, I think this is fine.\n-        check_assist_not_applicable(\n-            add_function,\n-            r\"\n-fn foo() {\n-    other_crate::bar<|>();\n-}\n-        \",\n-        )\n-    }\n-\n     #[test]\n     #[ignore]\n     fn create_method_with_no_args() {"}]}