{"sha": "ef416e0154767619fcbfa0d1682b28bd338a8ce9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNDE2ZTAxNTQ3Njc2MTlmY2JmYTBkMTY4MmIyOGJkMzM4YThjZTk=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-03-14T12:03:39Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-03-15T17:04:20Z"}, "message": "Impl HirDisplay for function hover message", "tree": {"sha": "e73269dbb569f176e9bba1b16eb74731d63c94c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e73269dbb569f176e9bba1b16eb74731d63c94c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef416e0154767619fcbfa0d1682b28bd338a8ce9", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAmBPk6EACgkQztOS3gxI\nPQAbghAAg/scpZjFAR/1fLjxPyLr35I18NAcnReNOGTAuJdjdyJC76wjX8tWOWaN\n6sUa/Z+eKUOOTDyI6knxKPXddnzOO/XjFLGqq3UtpEwoDfd9l4areEzg3S99ehaU\nb5NWPmtq1zIYpts+NMCC13+CcIJCcU7pdhju3Mk8ZyRY0fRb1eqN+4rvZGPPYDb6\nogEa82DJAoZ8JoMQIeV20ncz0zN8aZpT0WONUTbjXLmxyhTXr7o2wKYJJUHVoDz4\nwl7zkyQHgM1QcI4NCkpoGTVCKMOuVPsGn1PSJ1sevtWQED3Qo3SN41GykkfElLVE\nBdb8IvcaD0GA1YwjewI6RilMfy7zLE05iE6pGz5RWEfrKAYYdf+O9vx0t/9VwBae\nX/023h/Ae5+JvdoY4GiNkJuBzyrBU5JxbhtE5FJhqx38yH+YPMkzziZd0Vw6eahv\ngVvSw4UP+i7Ug3HmCqjcqRkdm+WBvargRvdlK5XvQEQBelfzovgOe0tQSi5v5S+0\nx6R8AV/uBcEkSQ+bnCKOQoB9MSfJjNtrUp3oNCc7QAOD90XfIMbd+eXKTnpF1aJ9\nFQmAmEqh5+4xaTHCIsAf+3pIr2D7Ijtwcv/6WAj5jICUzoENSQE2nD/cisgg3JjI\nUz4VC+tEX/Xupc20qFcb0jz6uy6rFiMDI3LVHGYQ/jZZ429ksBc=\n=HbWJ\n-----END PGP SIGNATURE-----", "payload": "tree e73269dbb569f176e9bba1b16eb74731d63c94c2\nparent 2bb8956a102cb2efbea35e414a8214fba2efcaf6\nauthor oxalica <oxalicc@pm.me> 1615723419 +0800\ncommitter oxalica <oxalicc@pm.me> 1615827860 +0800\n\nImpl HirDisplay for function hover message\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef416e0154767619fcbfa0d1682b28bd338a8ce9", "html_url": "https://github.com/rust-lang/rust/commit/ef416e0154767619fcbfa0d1682b28bd338a8ce9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef416e0154767619fcbfa0d1682b28bd338a8ce9/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bb8956a102cb2efbea35e414a8214fba2efcaf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb8956a102cb2efbea35e414a8214fba2efcaf6", "html_url": "https://github.com/rust-lang/rust/commit/2bb8956a102cb2efbea35e414a8214fba2efcaf6"}], "stats": {"total": 475, "additions": 461, "deletions": 14}, "files": [{"sha": "ae08e25847240c56729eeaa32ea04e3eeae86056", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 232, "deletions": 2, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=ef416e0154767619fcbfa0d1682b28bd338a8ce9", "patch": "@@ -1,9 +1,120 @@\n //! HirDisplay implementations for various hir types.\n+use hir_def::{\n+    generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n+    type_ref::{TypeBound, TypeRef},\n+    GenericDefId,\n+};\n use hir_ty::display::{\n-    write_bounds_like_dyn_trait_with_prefix, HirDisplay, HirDisplayError, HirFormatter,\n+    write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n+    HirFormatter,\n };\n+use syntax::ast::{self, NameOwner};\n+\n+use crate::{Function, HasVisibility, Substs, Type, TypeParam};\n+\n+impl HirDisplay for Function {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        let data = f.db.function_data(self.id);\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let qual = &data.qualifier;\n+        if qual.is_default {\n+            write!(f, \"default \")?;\n+        }\n+        if qual.is_const {\n+            write!(f, \"const \")?;\n+        }\n+        if qual.is_async {\n+            write!(f, \"async \")?;\n+        }\n+        if qual.is_unsafe {\n+            write!(f, \"unsafe \")?;\n+        }\n+        if let Some(abi) = &qual.abi {\n+            // FIXME: String escape?\n+            write!(f, \"extern \\\"{}\\\" \", abi)?;\n+        }\n+        write!(f, \"fn {}\", data.name)?;\n+\n+        write_generic_params(GenericDefId::FunctionId(self.id), f)?;\n+\n+        write!(f, \"(\")?;\n \n-use crate::{Substs, Type, TypeParam};\n+        let write_self_param = |ty: &TypeRef, f: &mut HirFormatter| match ty {\n+            TypeRef::Path(p) if p.is_self_type() => write!(f, \"self\"),\n+            TypeRef::Reference(inner, lifetime, mut_) if matches!(&**inner,TypeRef::Path(p) if p.is_self_type()) =>\n+            {\n+                write!(f, \"&\")?;\n+                if let Some(lifetime) = lifetime {\n+                    write!(f, \"{} \", lifetime.name)?;\n+                }\n+                if let hir_def::type_ref::Mutability::Mut = mut_ {\n+                    write!(f, \"mut \")?;\n+                }\n+                write!(f, \"self\")\n+            }\n+            _ => {\n+                write!(f, \"self: \")?;\n+                ty.hir_fmt(f)\n+            }\n+        };\n+\n+        let mut first = true;\n+        for (param, type_ref) in self.assoc_fn_params(f.db).into_iter().zip(&data.params) {\n+            if !first {\n+                write!(f, \", \")?;\n+            } else {\n+                first = false;\n+                if data.has_self_param {\n+                    write_self_param(type_ref, f)?;\n+                    continue;\n+                }\n+            }\n+            match param.pattern_source(f.db) {\n+                Some(ast::Pat::IdentPat(p)) if p.name().is_some() => {\n+                    write!(f, \"{}: \", p.name().unwrap())?\n+                }\n+                _ => write!(f, \"_: \")?,\n+            }\n+            // FIXME: Use resolved `param.ty` or raw `type_ref`?\n+            // The former will ignore lifetime arguments currently.\n+            type_ref.hir_fmt(f)?;\n+        }\n+        write!(f, \")\")?;\n+\n+        // `FunctionData::ret_type` will be `::core::future::Future<Output = ...>` for async fns.\n+        // Use ugly pattern match to strip the Future trait.\n+        // Better way?\n+        let ret_type = if !qual.is_async {\n+            &data.ret_type\n+        } else {\n+            match &data.ret_type {\n+                TypeRef::ImplTrait(bounds) => match &bounds[0] {\n+                    TypeBound::Path(path) => {\n+                        path.segments().iter().last().unwrap().args_and_bindings.unwrap().bindings\n+                            [0]\n+                        .type_ref\n+                        .as_ref()\n+                        .unwrap()\n+                    }\n+                    _ => panic!(\"Async fn ret_type should be impl Future\"),\n+                },\n+                _ => panic!(\"Async fn ret_type should be impl Future\"),\n+            }\n+        };\n+\n+        match ret_type {\n+            TypeRef::Tuple(tup) if tup.is_empty() => {}\n+            ty => {\n+                write!(f, \" -> \")?;\n+                ty.hir_fmt(f)?;\n+            }\n+        }\n+\n+        write_where_clause(GenericDefId::FunctionId(self.id), f)?;\n+\n+        Ok(())\n+    }\n+}\n \n impl HirDisplay for Type {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n@@ -23,3 +134,122 @@ impl HirDisplay for TypeParam {\n         Ok(())\n     }\n }\n+\n+fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    let params = f.db.generic_params(def);\n+    if params.lifetimes.is_empty() && params.types.is_empty() && params.consts.is_empty() {\n+        return Ok(());\n+    }\n+    write!(f, \"<\")?;\n+\n+    let mut first = true;\n+    let mut delim = |f: &mut HirFormatter| {\n+        if first {\n+            first = false;\n+            Ok(())\n+        } else {\n+            write!(f, \", \")\n+        }\n+    };\n+    for (_, lifetime) in params.lifetimes.iter() {\n+        delim(f)?;\n+        write!(f, \"{}\", lifetime.name)?;\n+    }\n+    for (_, ty) in params.types.iter() {\n+        if ty.provenance != TypeParamProvenance::TypeParamList {\n+            continue;\n+        }\n+        if let Some(name) = &ty.name {\n+            delim(f)?;\n+            write!(f, \"{}\", name)?;\n+            if let Some(default) = &ty.default {\n+                write!(f, \" = \")?;\n+                default.hir_fmt(f)?;\n+            }\n+        }\n+    }\n+    for (_, konst) in params.consts.iter() {\n+        delim(f)?;\n+        write!(f, \"const {}: \", konst.name)?;\n+        konst.ty.hir_fmt(f)?;\n+    }\n+\n+    write!(f, \">\")?;\n+    Ok(())\n+}\n+\n+fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+    let params = f.db.generic_params(def);\n+    if params.where_predicates.is_empty() {\n+        return Ok(());\n+    }\n+\n+    let write_target = |target: &WherePredicateTypeTarget, f: &mut HirFormatter| match target {\n+        WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n+        WherePredicateTypeTarget::TypeParam(id) => match &params.types[*id].name {\n+            Some(name) => write!(f, \"{}\", name),\n+            None => write!(f, \"{{unnamed}}\"),\n+        },\n+    };\n+\n+    write!(f, \"\\nwhere\")?;\n+\n+    for (pred_idx, pred) in params.where_predicates.iter().enumerate() {\n+        let prev_pred =\n+            if pred_idx == 0 { None } else { Some(&params.where_predicates[pred_idx - 1]) };\n+\n+        let new_predicate = |f: &mut HirFormatter| {\n+            write!(f, \"{}\", if pred_idx == 0 { \"\\n    \" } else { \",\\n    \" })\n+        };\n+\n+        match pred {\n+            WherePredicate::TypeBound { target, bound } => {\n+                if matches!(prev_pred, Some(WherePredicate::TypeBound { target: target_, .. }) if target_ == target)\n+                {\n+                    write!(f, \" + \")?;\n+                } else {\n+                    new_predicate(f)?;\n+                    write_target(target, f)?;\n+                    write!(f, \": \")?;\n+                }\n+                bound.hir_fmt(f)?;\n+            }\n+            WherePredicate::Lifetime { target, bound } => {\n+                if matches!(prev_pred, Some(WherePredicate::Lifetime { target: target_, .. }) if target_ == target)\n+                {\n+                    write!(f, \" + {}\", bound.name)?;\n+                } else {\n+                    new_predicate(f)?;\n+                    write!(f, \"{}: {}\", target.name, bound.name)?;\n+                }\n+            }\n+            WherePredicate::ForLifetime { lifetimes, target, bound } => {\n+                if matches!(\n+                    prev_pred,\n+                    Some(WherePredicate::ForLifetime { lifetimes: lifetimes_, target: target_, .. })\n+                    if lifetimes_ == lifetimes && target_ == target,\n+                ) {\n+                    write!(f, \" + \")?;\n+                } else {\n+                    new_predicate(f)?;\n+                    write!(f, \"for<\")?;\n+                    for (idx, lifetime) in lifetimes.iter().enumerate() {\n+                        if idx != 0 {\n+                            write!(f, \", \")?;\n+                        }\n+                        write!(f, \"{}\", lifetime)?;\n+                    }\n+                    write!(f, \"> \")?;\n+                    write_target(target, f)?;\n+                    write!(f, \": \")?;\n+                }\n+                bound.hir_fmt(f)?;\n+            }\n+        }\n+    }\n+\n+    // End of final predicate. There must be at least one predicate here.\n+    write!(f, \",\")?;\n+\n+    Ok(())\n+}"}, {"sha": "476fdb13285357319c0b67e6e9c36f371a89ee43", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ef416e0154767619fcbfa0d1682b28bd338a8ce9", "patch": "@@ -822,15 +822,16 @@ impl Function {\n         db.function_data(self.id)\n             .params\n             .iter()\n-            .map(|type_ref| {\n+            .enumerate()\n+            .map(|(idx, type_ref)| {\n                 let ty = Type {\n                     krate,\n                     ty: InEnvironment {\n                         value: ctx.lower_ty(type_ref),\n                         environment: environment.clone(),\n                     },\n                 };\n-                Param { ty }\n+                Param { func: self, ty, idx }\n             })\n             .collect()\n     }\n@@ -893,13 +894,25 @@ impl From<hir_ty::Mutability> for Access {\n \n #[derive(Debug)]\n pub struct Param {\n+    func: Function,\n+    /// The index in parameter list, including self parameter.\n+    idx: usize,\n     ty: Type,\n }\n \n impl Param {\n     pub fn ty(&self) -> &Type {\n         &self.ty\n     }\n+\n+    pub fn pattern_source(&self, db: &dyn HirDatabase) -> Option<ast::Pat> {\n+        let params = self.func.source(db)?.value.param_list()?;\n+        if params.self_param().is_some() {\n+            params.params().nth(self.idx.checked_sub(1)?)?.pat()\n+        } else {\n+            params.params().nth(self.idx)?.pat()\n+        }\n+    }\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "8c923bb7b28d651d0349532e577902155a0188b5", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=ef416e0154767619fcbfa0d1682b28bd338a8ce9", "patch": "@@ -9,7 +9,10 @@ use std::{\n \n use crate::{body::LowerCtx, type_ref::LifetimeRef};\n use base_db::CrateId;\n-use hir_expand::{hygiene::Hygiene, name::Name};\n+use hir_expand::{\n+    hygiene::Hygiene,\n+    name::{name, Name},\n+};\n use syntax::ast;\n \n use crate::{\n@@ -209,6 +212,12 @@ impl Path {\n         };\n         Some(res)\n     }\n+\n+    pub fn is_self_type(&self) -> bool {\n+        self.type_anchor.is_none()\n+            && self.generic_args == &[None]\n+            && self.mod_path.as_ident() == Some(&name!(Self))\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]"}, {"sha": "c572bb1141e9118be9280880f58b132a67ae1c75", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 195, "deletions": 8, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=ef416e0154767619fcbfa0d1682b28bd338a8ce9", "patch": "@@ -5,7 +5,13 @@ use std::{borrow::Cow, fmt};\n use arrayvec::ArrayVec;\n use chalk_ir::Mutability;\n use hir_def::{\n-    db::DefDatabase, find_path, generics::TypeParamProvenance, item_scope::ItemInNs,\n+    db::DefDatabase,\n+    find_path,\n+    generics::TypeParamProvenance,\n+    item_scope::ItemInNs,\n+    path::{GenericArg, Path, PathKind},\n+    type_ref::{TypeBound, TypeRef},\n+    visibility::Visibility,\n     AssocContainerId, Lookup, ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n@@ -232,7 +238,7 @@ where\n \n const TYPE_HINT_TRUNCATION: &str = \"\u2026\";\n \n-impl HirDisplay for &Ty {\n+impl<T: HirDisplay> HirDisplay for &'_ T {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         HirDisplay::hir_fmt(*self, f)\n     }\n@@ -761,12 +767,6 @@ impl HirDisplay for TraitRef {\n     }\n }\n \n-impl HirDisplay for &GenericPredicate {\n-    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n-        HirDisplay::hir_fmt(*self, f)\n-    }\n-}\n-\n impl HirDisplay for GenericPredicate {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         if f.should_truncate() {\n@@ -825,3 +825,190 @@ impl HirDisplay for Obligation {\n         }\n     }\n }\n+\n+pub fn write_visibility(\n+    module_id: ModuleId,\n+    vis: Visibility,\n+    f: &mut HirFormatter,\n+) -> Result<(), HirDisplayError> {\n+    match vis {\n+        Visibility::Public => write!(f, \"pub \"),\n+        Visibility::Module(vis_id) => {\n+            let def_map = module_id.def_map(f.db.upcast());\n+            let root_module_id = def_map.module_id(def_map.root());\n+            if vis_id == module_id {\n+                // pub(self) or omitted\n+                Ok(())\n+            } else if root_module_id == vis_id {\n+                write!(f, \"pub(crate) \")\n+            } else if module_id.containing_module(f.db.upcast()) == Some(vis_id) {\n+                write!(f, \"pub(super) \")\n+            } else {\n+                write!(f, \"pub(in ...) \")\n+            }\n+        }\n+    }\n+}\n+\n+impl HirDisplay for TypeRef {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            TypeRef::Never => write!(f, \"!\")?,\n+            TypeRef::Placeholder => write!(f, \"_\")?,\n+            TypeRef::Tuple(elems) => {\n+                write!(f, \"(\")?;\n+                f.write_joined(elems, \", \")?;\n+                if elems.len() == 1 {\n+                    write!(f, \",\")?;\n+                }\n+                write!(f, \")\")?;\n+            }\n+            TypeRef::Path(path) => path.hir_fmt(f)?,\n+            TypeRef::RawPtr(inner, mutability) => {\n+                let mutability = match mutability {\n+                    hir_def::type_ref::Mutability::Shared => \"*const \",\n+                    hir_def::type_ref::Mutability::Mut => \"*mut \",\n+                };\n+                write!(f, \"{}\", mutability)?;\n+                inner.hir_fmt(f)?;\n+            }\n+            TypeRef::Reference(inner, lifetime, mutability) => {\n+                let mutability = match mutability {\n+                    hir_def::type_ref::Mutability::Shared => \"\",\n+                    hir_def::type_ref::Mutability::Mut => \"mut \",\n+                };\n+                write!(f, \"&\")?;\n+                if let Some(lifetime) = lifetime {\n+                    write!(f, \"{} \", lifetime.name)?;\n+                }\n+                write!(f, \"{}\", mutability)?;\n+                inner.hir_fmt(f)?;\n+            }\n+            TypeRef::Array(inner) => {\n+                write!(f, \"[\")?;\n+                inner.hir_fmt(f)?;\n+                // FIXME: Array length?\n+                write!(f, \"; _]\")?;\n+            }\n+            TypeRef::Slice(inner) => {\n+                write!(f, \"[\")?;\n+                inner.hir_fmt(f)?;\n+                write!(f, \"]\")?;\n+            }\n+            TypeRef::Fn(tys, is_varargs) => {\n+                // FIXME: Function pointer qualifiers.\n+                write!(f, \"fn(\")?;\n+                f.write_joined(&tys[..tys.len() - 1], \", \")?;\n+                if *is_varargs {\n+                    write!(f, \"{}...\", if tys.len() == 1 { \"\" } else { \", \" })?;\n+                }\n+                write!(f, \")\")?;\n+                let ret_ty = tys.last().unwrap();\n+                match ret_ty {\n+                    TypeRef::Tuple(tup) if tup.is_empty() => {}\n+                    _ => {\n+                        write!(f, \" -> \")?;\n+                        ret_ty.hir_fmt(f)?;\n+                    }\n+                }\n+            }\n+            TypeRef::ImplTrait(bounds) => {\n+                write!(f, \"impl \")?;\n+                f.write_joined(bounds, \" + \")?;\n+            }\n+            TypeRef::DynTrait(bounds) => {\n+                write!(f, \"dyn \")?;\n+                f.write_joined(bounds, \" + \")?;\n+            }\n+            TypeRef::Error => write!(f, \"{{error}}\")?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TypeBound {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            TypeBound::Path(path) => path.hir_fmt(f),\n+            TypeBound::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+            TypeBound::Error => write!(f, \"{{error}}\"),\n+        }\n+    }\n+}\n+\n+impl HirDisplay for Path {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match (self.type_anchor(), self.kind()) {\n+            (Some(anchor), _) => {\n+                write!(f, \"<\")?;\n+                anchor.hir_fmt(f)?;\n+                write!(f, \">\")?;\n+            }\n+            (_, PathKind::Plain) => {}\n+            (_, PathKind::Abs) => write!(f, \"::\")?,\n+            (_, PathKind::Crate) => write!(f, \"crate\")?,\n+            (_, PathKind::Super(0)) => write!(f, \"self\")?,\n+            (_, PathKind::Super(n)) => {\n+                write!(f, \"super\")?;\n+                for _ in 0..*n {\n+                    write!(f, \"::super\")?;\n+                }\n+            }\n+            (_, PathKind::DollarCrate(_)) => write!(f, \"{{extern_crate}}\")?,\n+        }\n+\n+        for (seg_idx, segment) in self.segments().iter().enumerate() {\n+            if seg_idx != 0 {\n+                write!(f, \"::\")?;\n+            }\n+            write!(f, \"{}\", segment.name)?;\n+            if let Some(generic_args) = segment.args_and_bindings {\n+                // We should be in type context, so format as `Foo<Bar>` instead of `Foo::<Bar>`.\n+                // Do we actually format expressions?\n+                write!(f, \"<\")?;\n+                let mut first = true;\n+                for arg in &generic_args.args {\n+                    if first {\n+                        first = false;\n+                        if generic_args.has_self_type {\n+                            // FIXME: Convert to `<Ty as Trait>` form.\n+                            write!(f, \"Self = \")?;\n+                        }\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    arg.hir_fmt(f)?;\n+                }\n+                for binding in &generic_args.bindings {\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    write!(f, \"{}\", binding.name)?;\n+                    match &binding.type_ref {\n+                        Some(ty) => {\n+                            write!(f, \" = \")?;\n+                            ty.hir_fmt(f)?\n+                        }\n+                        None => {\n+                            write!(f, \": \")?;\n+                            f.write_joined(&binding.bounds, \" + \")?;\n+                        }\n+                    }\n+                }\n+                write!(f, \">\")?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for GenericArg {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        match self {\n+            GenericArg::Type(ty) => ty.hir_fmt(f),\n+            GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+        }\n+    }\n+}"}, {"sha": "1e4c247c03fe33183395e63af2e33b9c63ad3a6a", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef416e0154767619fcbfa0d1682b28bd338a8ce9/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=ef416e0154767619fcbfa0d1682b28bd338a8ce9", "patch": "@@ -354,7 +354,7 @@ fn hover_for_definition(\n                 },\n                 mod_path,\n             ),\n-            ModuleDef::Function(it) => from_def_source(db, it, mod_path),\n+            ModuleDef::Function(it) => from_hir_fmt(db, it, mod_path),\n             ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it, mod_path),\n             ModuleDef::Adt(Adt::Union(it)) => from_def_source(db, it, mod_path),\n             ModuleDef::Adt(Adt::Enum(it)) => from_def_source(db, it, mod_path),\n@@ -383,6 +383,14 @@ fn hover_for_definition(\n         },\n     };\n \n+    fn from_hir_fmt<D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n+    where\n+        D: HasAttrs + HirDisplay,\n+    {\n+        let label = def.display(db).to_string();\n+        from_def_source_labeled(db, def, Some(label), mod_path)\n+    }\n+\n     fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n     where\n         D: HasSource<Ast = A> + HasAttrs + Copy,"}]}