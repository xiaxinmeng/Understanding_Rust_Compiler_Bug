{"sha": "380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MDI5M2Q2YzJlYWQ5MWEwOTg4MTgzY2E2MzRkOWViNGY0ZmE5ZDc=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-22T23:00:17Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-22T23:15:26Z"}, "message": "Pretty-print generic parameters", "tree": {"sha": "59e3b0eb34413e411c12e64b3145c18c8531d5df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59e3b0eb34413e411c12e64b3145c18c8531d5df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "html_url": "https://github.com/rust-lang/rust/commit/380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/380293d6c2ead91a0988183ca634d9eb4f4fa9d7/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c22ccd07fecb964b11cba283d5ab184967c2669b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c22ccd07fecb964b11cba283d5ab184967c2669b", "html_url": "https://github.com/rust-lang/rust/commit/c22ccd07fecb964b11cba283d5ab184967c2669b"}], "stats": {"total": 121, "additions": 99, "deletions": 22}, "files": [{"sha": "d00de2f73c88319df7c54a90bc5c39ba9eee3218", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 66, "deletions": 22, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/380293d6c2ead91a0988183ca634d9eb4f4fa9d7/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/380293d6c2ead91a0988183ca634d9eb4f4fa9d7/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "patch": "@@ -2,7 +2,9 @@\n \n use std::fmt::{self, Write};\n \n-use crate::{attr::RawAttrs, path::GenericArg, visibility::RawVisibility};\n+use crate::{\n+    attr::RawAttrs, generics::TypeParamProvenance, path::GenericArg, visibility::RawVisibility,\n+};\n \n use super::*;\n \n@@ -174,7 +176,7 @@ impl<'a> Printer<'a> {\n                 let Function {\n                     name,\n                     visibility,\n-                    generic_params: _, // FIXME print these somehow\n+                    generic_params,\n                     abi,\n                     params,\n                     ret_type,\n@@ -188,7 +190,9 @@ impl<'a> Printer<'a> {\n                 if let Some(abi) = abi {\n                     w!(self, \"extern \\\"{}\\\" \", abi);\n                 }\n-                w!(self, \"fn {}(\", name);\n+                w!(self, \"fn {}\", name);\n+                self.print_generic_params(generic_params);\n+                w!(self, \"(\");\n                 if !params.is_empty() {\n                     self.indented(|this| {\n                         for param in params.clone() {\n@@ -211,10 +215,10 @@ impl<'a> Printer<'a> {\n                 wln!(self, \";\");\n             }\n             ModItem::Struct(it) => {\n-                let Struct { visibility, name, fields, generic_params: _, ast_id: _ } =\n-                    &self.tree[it];\n+                let Struct { visibility, name, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"struct {}\", name);\n+                self.print_generic_params(generic_params);\n                 self.print_fields(fields);\n                 if matches!(fields, Fields::Record(_)) {\n                     wln!(self);\n@@ -223,10 +227,10 @@ impl<'a> Printer<'a> {\n                 }\n             }\n             ModItem::Union(it) => {\n-                let Union { name, visibility, fields, generic_params: _, ast_id: _ } =\n-                    &self.tree[it];\n+                let Union { name, visibility, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"union {}\", name);\n+                self.print_generic_params(generic_params);\n                 self.print_fields(fields);\n                 if matches!(fields, Fields::Record(_)) {\n                     wln!(self);\n@@ -235,10 +239,11 @@ impl<'a> Printer<'a> {\n                 }\n             }\n             ModItem::Enum(it) => {\n-                let Enum { name, visibility, variants, generic_params: _, ast_id: _ } =\n-                    &self.tree[it];\n+                let Enum { name, visibility, variants, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"enum {} {{\", name);\n+                w!(self, \"enum {}\", name);\n+                self.print_generic_params(generic_params);\n+                w!(self, \" {{\");\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n                         let Variant { name, fields } = &this.tree[variant];\n@@ -286,7 +291,7 @@ impl<'a> Printer<'a> {\n                     is_unsafe,\n                     bounds,\n                     items,\n-                    generic_params: _,\n+                    generic_params,\n                     ast_id: _,\n                 } = &self.tree[it];\n                 self.print_visibility(*visibility);\n@@ -296,7 +301,9 @@ impl<'a> Printer<'a> {\n                 if *is_auto {\n                     w!(self, \"auto \");\n                 }\n-                w!(self, \"trait {}\", name);\n+                w!(self, \"trait\");\n+                self.print_generic_params(generic_params);\n+                w!(self, \" {}\", name);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n                     self.print_type_bounds(bounds);\n@@ -310,15 +317,11 @@ impl<'a> Printer<'a> {\n                 wln!(self, \"}}\");\n             }\n             ModItem::Impl(it) => {\n-                let Impl {\n-                    target_trait,\n-                    self_ty,\n-                    is_negative,\n-                    items,\n-                    generic_params: _,\n-                    ast_id: _,\n-                } = &self.tree[it];\n-                w!(self, \"impl \");\n+                let Impl { target_trait, self_ty, is_negative, items, generic_params, ast_id: _ } =\n+                    &self.tree[it];\n+                w!(self, \"impl\");\n+                self.print_generic_params(generic_params);\n+                w!(self, \" \");\n                 if *is_negative {\n                     w!(self, \"!\");\n                 }\n@@ -342,11 +345,12 @@ impl<'a> Printer<'a> {\n                     bounds,\n                     type_ref,\n                     is_extern,\n-                    generic_params: _,\n+                    generic_params,\n                     ast_id: _,\n                 } = &self.tree[it];\n                 self.print_visibility(*visibility);\n                 w!(self, \"type {}\", name);\n+                self.print_generic_params(generic_params);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n                     self.print_type_bounds(bounds);\n@@ -566,6 +570,46 @@ impl<'a> Printer<'a> {\n             GenericArg::Lifetime(lt) => w!(self, \"{}\", lt.name),\n         }\n     }\n+\n+    fn print_generic_params(&mut self, params: &GenericParams) {\n+        let mut first = true;\n+        for (_, lt) in params.lifetimes.iter() {\n+            if first {\n+                w!(self, \"<\");\n+            } else {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            w!(self, \"{}\", lt.name);\n+        }\n+        for (_, ty) in params.types.iter() {\n+            if ty.provenance != TypeParamProvenance::TypeParamList {\n+                continue;\n+            }\n+            if let Some(name) = &ty.name {\n+                if first {\n+                    w!(self, \"<\");\n+                } else {\n+                    w!(self, \", \");\n+                }\n+                first = false;\n+                w!(self, \"{}\", name);\n+            }\n+        }\n+        for (_, konst) in params.consts.iter() {\n+            if first {\n+                w!(self, \"<\");\n+            } else {\n+                w!(self, \", \");\n+            }\n+            first = false;\n+            w!(self, \"const {}: \", konst.name);\n+            self.print_type_ref(&konst.ty);\n+        }\n+        if !first {\n+            w!(self, \">\");\n+        }\n+    }\n }\n \n impl<'a> Write for Printer<'a> {"}, {"sha": "e0847dc7512bbee77d07fe08d80c11e7b4e2ff18", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/380293d6c2ead91a0988183ca634d9eb4f4fa9d7/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/380293d6c2ead91a0988183ca634d9eb4f4fa9d7/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=380293d6c2ead91a0988183ca634d9eb4f4fa9d7", "patch": "@@ -288,3 +288,36 @@ struct S {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn generics() {\n+    check(\n+        r#\"\n+struct S<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> {}\n+\n+impl<'a, 'b: 'a, T: Copy + 'a + 'b, const K: u8 = 0> S<'a, 'b, T, K> {\n+    fn f<G: 'a>(arg: impl Copy) -> impl Copy {}\n+}\n+\n+enum Enum<'a, T, const U: u8> {}\n+union Union<'a, T, const U: u8> {}\n+        \"#,\n+        expect![[r#\"\n+            pub(self) struct S<'a, 'b, T, const K: u8> {\n+            }\n+\n+            impl<'a, 'b, T, const K: u8> S<'a, 'b, T, K> {\n+                // flags = 0x2\n+                pub(self) fn f<G>(\n+                    _: impl Copy,\n+                ) -> impl Copy;\n+            }\n+\n+            pub(self) enum Enum<'a, T, const U: u8> {\n+            }\n+\n+            pub(self) union Union<'a, T, const U: u8> {\n+            }\n+        \"#]],\n+    )\n+}"}]}