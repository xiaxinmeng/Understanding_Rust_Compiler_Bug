{"sha": "5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjRiMmMyYzdiNDgzZWY2ZWFlN2U0NmQ2OWNjMjAwY2IwMjU3NWQ=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-10T13:52:51Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-22T15:20:23Z"}, "message": "Factor out `SplitIntRange` used for integer range splitting", "tree": {"sha": "5849b1741cb7f7e4576f0f21169eec97339c6cdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5849b1741cb7f7e4576f0f21169eec97339c6cdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "html_url": "https://github.com/rust-lang/rust/commit/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42b77c709e98f8f75498e1b57eac20756f6c6ead", "url": "https://api.github.com/repos/rust-lang/rust/commits/42b77c709e98f8f75498e1b57eac20756f6c6ead", "html_url": "https://github.com/rust-lang/rust/commit/42b77c709e98f8f75498e1b57eac20756f6c6ead"}], "stats": {"total": 199, "additions": 110, "deletions": 89}, "files": [{"sha": "a6cf0ebeb82edad0debbe5add7f32e389c66cec2", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 110, "deletions": 89, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a24b2c2c7b483ef6eae7e46d69cc200cb02575d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=5a24b2c2c7b483ef6eae7e46d69cc200cb02575d", "patch": "@@ -24,7 +24,7 @@ use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n use std::cmp::{self, max, min, Ordering};\n-use std::iter::IntoIterator;\n+use std::iter::{once, IntoIterator};\n use std::ops::RangeInclusive;\n \n /// An inclusive interval, used for precise integer exhaustiveness checking.\n@@ -183,77 +183,24 @@ impl IntRange {\n         Pat { ty, span: DUMMY_SP, kind: Box::new(kind) }\n     }\n \n-    /// For exhaustive integer matching, some constructors are grouped within other constructors\n-    /// (namely integer typed values are grouped within ranges). However, when specialising these\n-    /// constructors, we want to be specialising for the underlying constructors (the integers), not\n-    /// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n-    /// mean creating a separate constructor for every single value in the range, which is clearly\n-    /// impractical. However, observe that for some ranges of integers, the specialisation will be\n-    /// identical across all values in that range (i.e., there are equivalence classes of ranges of\n-    /// constructors based on their `U(S(c, P), S(c, p))` outcome). These classes are grouped by\n-    /// the patterns that apply to them (in the matrix `P`). We can split the range whenever the\n-    /// patterns that apply to that range (specifically: the patterns that *intersect* with that range)\n-    /// change.\n-    /// Our solution, therefore, is to split the range constructor into subranges at every single point\n-    /// the group of intersecting patterns changes (using the method described below).\n-    /// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n-    /// on actual integers. The nice thing about this is that the number of subranges is linear in the\n-    /// number of rows in the matrix (i.e., the number of cases in the `match` statement), so we don't\n-    /// need to be worried about matching over gargantuan ranges.\n-    ///\n-    /// Essentially, given the first column of a matrix representing ranges, looking like the following:\n-    ///\n-    /// |------|  |----------| |-------|    ||\n-    ///    |-------| |-------|            |----| ||\n-    ///       |---------|\n-    ///\n-    /// We split the ranges up into equivalence classes so the ranges are no longer overlapping:\n-    ///\n-    /// |--|--|||-||||--||---|||-------|  |-|||| ||\n-    ///\n-    /// The logic for determining how to split the ranges is fairly straightforward: we calculate\n-    /// boundaries for each interval range, sort them, then create constructors for each new interval\n-    /// between every pair of boundary points. (This essentially sums up to performing the intuitive\n-    /// merging operation depicted above.)\n+    /// Split this range, as described at the top of the file.\n     fn split<'p, 'tcx>(\n         &self,\n         pcx: PatCtxt<'_, 'p, 'tcx>,\n         hir_id: Option<HirId>,\n     ) -> SmallVec<[Constructor<'tcx>; 1]> {\n-        /// Represents a border between 2 integers. Because the intervals spanning borders\n-        /// must be able to cover every integer, we need to be able to represent\n-        /// 2^128 + 1 such borders.\n-        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-        enum Border {\n-            JustBefore(u128),\n-            AfterMax,\n-        }\n-\n-        // A function for extracting the borders of an integer interval.\n-        fn range_borders(r: IntRange) -> impl Iterator<Item = Border> {\n-            let (lo, hi) = r.range.into_inner();\n-            let from = Border::JustBefore(lo);\n-            let to = match hi.checked_add(1) {\n-                Some(m) => Border::JustBefore(m),\n-                None => Border::AfterMax,\n-            };\n-            vec![from, to].into_iter()\n-        }\n-\n-        // Collect the span and range of all the intersecting ranges to lint on likely\n-        // incorrect range patterns. (#63987)\n+        // We collect the span and range of all the intersecting ranges to lint on likely incorrect\n+        // range patterns. (#63987)\n         let mut overlaps = vec![];\n+        let mut split_range = SplitIntRange::new(self.clone());\n         let row_len = pcx.matrix.column_count().unwrap_or(0);\n-        // `borders` is the set of borders between equivalence classes: each equivalence\n-        // class lies between 2 borders.\n-        let row_borders = pcx\n+        let intranges = pcx\n             .matrix\n             .head_ctors_and_spans(pcx.cx)\n-            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)))\n-            .filter_map(|(range, span)| {\n-                let intersection = self.intersection(&range);\n-                let should_lint = self.suspicious_intersection(&range);\n-                if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n+            .filter_map(|(ctor, span)| Some((ctor.as_int_range()?, span)));\n+        let intranges = intranges.inspect(|(range, span)| {\n+            if let Some(intersection) = self.intersection(&range) {\n+                if row_len == 1 && self.suspicious_intersection(&range) {\n                     // FIXME: for now, only check for overlapping ranges on simple range\n                     // patterns. Otherwise with the current logic the following is detected\n                     // as overlapping:\n@@ -264,36 +211,15 @@ impl IntRange {\n                     //   _ => {}\n                     // }\n                     // ```\n-                    overlaps.push((range.clone(), span));\n+                    overlaps.push((intersection.clone(), *span));\n                 }\n-                intersection\n-            })\n-            .flat_map(range_borders);\n-        let self_borders = range_borders(self.clone());\n-        let mut borders: Vec<_> = row_borders.chain(self_borders).collect();\n-        borders.sort_unstable();\n+            }\n+        });\n+        split_range.split(intranges.map(|(range, _)| range).cloned());\n \n         self.lint_overlapping_range_endpoints(pcx, hir_id, overlaps);\n \n-        // We're going to iterate through every adjacent pair of borders, making sure that\n-        // each represents an interval of nonnegative length, and convert each such\n-        // interval into a constructor.\n-        borders\n-            .array_windows()\n-            .filter_map(|&pair| match pair {\n-                [Border::JustBefore(n), Border::JustBefore(m)] => {\n-                    if n < m {\n-                        Some(n..=(m - 1))\n-                    } else {\n-                        None\n-                    }\n-                }\n-                [Border::JustBefore(n), Border::AfterMax] => Some(n..=u128::MAX),\n-                [Border::AfterMax, _] => None,\n-            })\n-            .map(|range| IntRange { range })\n-            .map(IntRange)\n-            .collect()\n+        split_range.iter().map(IntRange).collect()\n     }\n \n     fn lint_overlapping_range_endpoints(\n@@ -339,6 +265,101 @@ impl IntRange {\n     }\n }\n \n+/// Represents a border between 2 integers. Because the intervals spanning borders must be able to\n+/// cover every integer, we need to be able to represent 2^128 + 1 such borders.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+enum IntBorder {\n+    JustBefore(u128),\n+    AfterMax,\n+}\n+\n+/// A range of integers that is partitioned into disjoint subranges.\n+///\n+/// This is fed an input of multiple ranges, and returns an output that covers the union of the\n+/// inputs but is split so that an output range only intersects an input range by being a subrange\n+/// of it. No output range straddles the boundary of one of the inputs. This does constructor\n+/// splitting for integer ranges as explained at the top of the file.\n+///\n+/// The following input:\n+/// ```\n+///   |-------------------------| // `self`\n+/// |------|  |----------|   |----|\n+///    |-------| |-------|\n+/// ```\n+/// would be iterated over as follows:\n+/// ```\n+///   ||---|--||-|---|---|---|--|\n+/// ```\n+#[derive(Debug, Clone)]\n+struct SplitIntRange {\n+    /// The range we are splitting\n+    range: IntRange,\n+    /// The borders of ranges we have seen. They are all contained within `range`. This is kept\n+    /// sorted.\n+    borders: Vec<IntBorder>,\n+}\n+\n+impl SplitIntRange {\n+    fn new(r: IntRange) -> Self {\n+        SplitIntRange { range: r.clone(), borders: Vec::new() }\n+    }\n+\n+    /// Internal use\n+    fn to_borders(r: IntRange) -> [IntBorder; 2] {\n+        use IntBorder::*;\n+        let (lo, hi) = r.boundaries();\n+        let lo = JustBefore(lo);\n+        let hi = match hi.checked_add(1) {\n+            Some(m) => JustBefore(m),\n+            None => AfterMax,\n+        };\n+        [lo, hi]\n+    }\n+\n+    /// Add ranges relative to which we split.\n+    fn split(&mut self, ranges: impl Iterator<Item = IntRange>) {\n+        let this_range = &self.range;\n+        let included_ranges = ranges.filter_map(|r| this_range.intersection(&r));\n+        let included_borders = included_ranges.flat_map(|r| {\n+            let borders = Self::to_borders(r);\n+            once(borders[0]).chain(once(borders[1]))\n+        });\n+        self.borders.extend(included_borders);\n+        self.borders.sort_unstable();\n+    }\n+\n+    /// Iterate over the contained ranges.\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = IntRange> + Captures<'a> {\n+        use IntBorder::*;\n+\n+        let self_range = Self::to_borders(self.range.clone());\n+        // Start with the start of the range.\n+        let mut prev_border = self_range[0];\n+        self.borders\n+            .iter()\n+            .copied()\n+            // End with the end of the range.\n+            .chain(once(self_range[1]))\n+            // List pairs of adjacent borders.\n+            .map(move |border| {\n+                let ret = (prev_border, border);\n+                prev_border = border;\n+                ret\n+            })\n+            // Skip duplicates.\n+            .filter(|(prev_border, border)| prev_border != border)\n+            // Finally, convert to ranges.\n+            .map(|(prev_border, border)| {\n+                let range = match (prev_border, border) {\n+                    (JustBefore(n), JustBefore(m)) if n < m => n..=(m - 1),\n+                    (JustBefore(n), AfterMax) => n..=u128::MAX,\n+                    _ => unreachable!(), // Ruled out by the sorting and filtering we did\n+                };\n+                IntRange { range }\n+            })\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum SliceKind {\n     /// Patterns of length `n` (`[x, y]`)."}]}