{"sha": "59518987ed82c6ef3ef4882b50fcbb96df364f6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NTE4OTg3ZWQ4MmM2ZWYzZWY0ODgyYjUwZmNiYjk2ZGYzNjRmNmQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-09-11T17:27:57Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-09-12T12:40:06Z"}, "message": "Implement drop support (fixes #11)", "tree": {"sha": "2062414fcc3074b39c7db55fcf6bfd526392ce48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2062414fcc3074b39c7db55fcf6bfd526392ce48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59518987ed82c6ef3ef4882b50fcbb96df364f6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59518987ed82c6ef3ef4882b50fcbb96df364f6d", "html_url": "https://github.com/rust-lang/rust/commit/59518987ed82c6ef3ef4882b50fcbb96df364f6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59518987ed82c6ef3ef4882b50fcbb96df364f6d/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "770461f57d2ded793534020353b9fef48dd7f2a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/770461f57d2ded793534020353b9fef48dd7f2a2", "html_url": "https://github.com/rust-lang/rust/commit/770461f57d2ded793534020353b9fef48dd7f2a2"}], "stats": {"total": 164, "additions": 143, "deletions": 21}, "files": [{"sha": "ea0a8c08ef53b65a2193fc3a043fe9eda7be6937", "filename": "examples/mini_core.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/59518987ed82c6ef3ef4882b50fcbb96df364f6d/examples%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59518987ed82c6ef3ef4882b50fcbb96df364f6d/examples%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core.rs?ref=59518987ed82c6ef3ef4882b50fcbb96df364f6d", "patch": "@@ -197,6 +197,11 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     &mut MY_TINY_HEAP as *mut [u8; 16] as *mut u8\n }\n \n+#[lang = \"drop\"]\n+pub trait Drop {\n+    fn drop(&mut self);\n+}\n+\n pub mod intrinsics {\n     extern \"rust-intrinsic\" {\n         pub fn abort() -> !;"}, {"sha": "661fa3cd7f153670da5886757972169558a8a1a8", "filename": "examples/mini_core_hello_world.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/59518987ed82c6ef3ef4882b50fcbb96df364f6d/examples%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59518987ed82c6ef3ef4882b50fcbb96df364f6d/examples%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/examples%2Fmini_core_hello_world.rs?ref=59518987ed82c6ef3ef4882b50fcbb96df364f6d", "patch": "@@ -49,6 +49,29 @@ impl SomeTrait for &'static str {\n     }\n }\n \n+struct NoisyDrop {\n+    text: &'static str,\n+    inner: NoisyDropInner,\n+}\n+\n+struct NoisyDropInner;\n+\n+impl Drop for NoisyDrop {\n+    fn drop(&mut self) {\n+        unsafe {\n+            puts(self.text as *const str as *const u8);\n+        }\n+    }\n+}\n+\n+impl Drop for NoisyDropInner {\n+    fn drop(&mut self) {\n+        unsafe {\n+            puts(\"Inner got dropped!\\0\" as *const str as *const u8);\n+        }\n+    }\n+}\n+\n #[lang = \"start\"]\n fn start<T: Termination + 'static>(\n     main: fn() -> T,\n@@ -91,4 +114,9 @@ fn main() {\n             panic(&(\"\", \"\", 0, 0));\n         }\n     }\n+\n+    let _ = NoisyDrop {\n+        text: \"Outer got dropped!\\0\",\n+        inner: NoisyDropInner,\n+    };\n }"}, {"sha": "c1eefa430e01d48fd7e30feb078722df2b5aa50c", "filename": "src/abi.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/59518987ed82c6ef3ef4882b50fcbb96df364f6d/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59518987ed82c6ef3ef4882b50fcbb96df364f6d/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=59518987ed82c6ef3ef4882b50fcbb96df364f6d", "patch": "@@ -433,7 +433,7 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n         .jump(*fx.ebb_map.get(&START_BLOCK).unwrap(), &[]);\n }\n \n-pub fn codegen_call<'a, 'tcx: 'a>(\n+pub fn codegen_terminator_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     func: &Operand<'tcx>,\n     args: &[Operand<'tcx>],\n@@ -466,19 +466,42 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n \n     let destination = destination\n         .as_ref()\n-        .map(|(place, bb)| (trans_place(fx, place), *bb));\n-\n-    if codegen_intrinsic_call(fx, fn_ty, sig, &args, destination) {\n-        return;\n+        .map(|&(ref place, bb)| (trans_place(fx, place), bb));\n+\n+    if !codegen_intrinsic_call(fx, fn_ty, &args, destination) {\n+        codegen_call_inner(\n+            fx,\n+            Some(func),\n+            fn_ty,\n+            args,\n+            destination.map(|(place, _)| place),\n+        );\n+\n+        if let Some((_, dest)) = destination {\n+            let ret_ebb = fx.get_ebb(dest);\n+            fx.bcx.ins().jump(ret_ebb, &[]);\n+        } else {\n+            fx.bcx.ins().trap(TrapCode::User(!0));\n+        }\n     }\n+}\n+\n+pub fn codegen_call_inner<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    func: Option<&Operand<'tcx>>,\n+    fn_ty: Ty<'tcx>,\n+    args: Vec<CValue<'tcx>>,\n+    ret_place: Option<CPlace<'tcx>>,\n+) {\n+    let sig = ty_fn_sig(fx.tcx, fn_ty);\n \n     let ret_layout = fx.layout_of(sig.output());\n \n     let output_pass_mode = get_pass_mode(fx.tcx, sig.abi, sig.output(), true);\n     let return_ptr = match output_pass_mode {\n         PassMode::NoPass => None,\n-        PassMode::ByRef => match destination {\n-            Some((place, _)) => Some(place.expect_addr()),\n+        PassMode::ByRef => match ret_place {\n+            Some(ret_place) => Some(ret_place.expect_addr()),\n             None => Some(fx.bcx.ins().iconst(fx.module.pointer_type(), 0)),\n         },\n         PassMode::ByVal(_) => None,\n@@ -504,7 +527,7 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n             Some(ptr)\n         } else {\n             func_ref = if instance.is_none() {\n-                let func = trans_operand(fx, func);\n+                let func = trans_operand(fx, func.expect(\"indirect call without func Operand\"));\n                 Some(func.load_value(fx))\n             } else {\n                 None\n@@ -534,19 +557,13 @@ pub fn codegen_call<'a, 'tcx: 'a>(\n     match output_pass_mode {\n         PassMode::NoPass => {}\n         PassMode::ByVal(_) => {\n-            if let Some((ret_place, _)) = destination {\n+            if let Some(ret_place) = ret_place {\n                 let results = fx.bcx.inst_results(call_inst);\n                 ret_place.write_cvalue(fx, CValue::ByVal(results[0], ret_layout));\n             }\n         }\n         PassMode::ByRef => {}\n     }\n-    if let Some((_, dest)) = destination {\n-        let ret_ebb = fx.get_ebb(dest);\n-        fx.bcx.ins().jump(ret_ebb, &[]);\n-    } else {\n-        fx.bcx.ins().trap(TrapCode::User(!0));\n-    }\n }\n \n pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n@@ -565,11 +582,12 @@ pub fn codegen_return(fx: &mut FunctionCx<impl Backend>) {\n fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     fn_ty: Ty<'tcx>,\n-    sig: FnSig<'tcx>,\n     args: &[CValue<'tcx>],\n     destination: Option<(CPlace<'tcx>, BasicBlock)>,\n ) -> bool {\n     if let ty::FnDef(def_id, substs) = fn_ty.sty {\n+        let sig = ty_fn_sig(fx.tcx, fn_ty);\n+\n         if sig.abi == Abi::RustIntrinsic {\n             let intrinsic = fx.tcx.item_name(def_id).as_str();\n             let intrinsic = &intrinsic[..];"}, {"sha": "e2422fe1157881e5d1cc1feec74e5c788ed26f91", "filename": "src/base.rs", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/59518987ed82c6ef3ef4882b50fcbb96df364f6d/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59518987ed82c6ef3ef4882b50fcbb96df364f6d/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=59518987ed82c6ef3ef4882b50fcbb96df364f6d", "patch": "@@ -224,19 +224,90 @@ fn codegen_fn_content<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx, impl Backend>)\n                 destination,\n                 cleanup: _,\n             } => {\n-                crate::abi::codegen_call(fx, func, args, destination);\n+                crate::abi::codegen_terminator_call(fx, func, args, destination);\n             }\n             TerminatorKind::Resume | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n                 fx.bcx.ins().trap(TrapCode::User(!0));\n             }\n             TerminatorKind::Yield { .. }\n             | TerminatorKind::FalseEdges { .. }\n-            | TerminatorKind::FalseUnwind { .. } => {\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::DropAndReplace { .. } => {\n                 bug!(\"shouldn't exist at trans {:?}\", bb_data.terminator());\n             }\n-            TerminatorKind::Drop { target, .. } | TerminatorKind::DropAndReplace { target, .. } => {\n-                // TODO call drop impl\n-                // unimplemented!(\"terminator {:?}\", bb_data.terminator());\n+            TerminatorKind::Drop {\n+                location,\n+                target,\n+                unwind: _,\n+            } => {\n+                let ty = location.ty(fx.mir, fx.tcx).to_ty(fx.tcx);\n+                let ty = fx.monomorphize(&ty);\n+                let drop_fn = ::rustc_mir::monomorphize::resolve_drop_in_place(fx.tcx, ty);\n+\n+                if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n+                    // we don't actually need to drop anything\n+                } else {\n+                    let drop_place = trans_place(fx, location);\n+                    let arg_place = CPlace::temp(\n+                        fx,\n+                        fx.tcx.mk_ref(\n+                            &ty::RegionKind::ReErased,\n+                            TypeAndMut {\n+                                ty,\n+                                mutbl: ::rustc::hir::Mutability::MutMutable,\n+                            },\n+                        ),\n+                    );\n+                    drop_place.write_place_ref(fx, arg_place);\n+                    match ty.sty {\n+                        ty::Dynamic(..) => {\n+                            unimplemented!(\"Drop for trait object\");\n+                        }\n+                        _ => {\n+                            let drop_fn_ty = drop_fn.ty(fx.tcx);\n+                            let arg_value = arg_place.to_cvalue(fx);\n+                            crate::abi::codegen_call_inner(\n+                                fx,\n+                                None,\n+                                drop_fn_ty,\n+                                vec![arg_value],\n+                                None,\n+                            );\n+                        }\n+                    }\n+                    /*\n+                    let (args1, args2);\n+                    /*let mut args = if let Some(llextra) = place.llextra {\n+                        args2 = [place.llval, llextra];\n+                        &args2[..]\n+                    } else {\n+                        args1 = [place.llval];\n+                        &args1[..]\n+                    };*/\n+                    let (drop_fn, fn_ty) = match ty.sty {\n+                        ty::Dynamic(..) => {\n+                            let fn_ty = drop_fn.ty(bx.cx.tcx);\n+                            let sig = common::ty_fn_sig(bx.cx, fn_ty);\n+                            let sig = bx.tcx().normalize_erasing_late_bound_regions(\n+                                ty::ParamEnv::reveal_all(),\n+                                &sig,\n+                            );\n+                            let fn_ty = FnType::new_vtable(bx.cx, sig, &[]);\n+                            let vtable = args[1];\n+                            args = &args[..1];\n+                            (meth::DESTRUCTOR.get_fn(&bx, vtable, &fn_ty), fn_ty)\n+                        }\n+                        _ => {\n+                            let value = place.to_cvalue(fx);\n+                            (callee::get_fn(bx.cx, drop_fn),\n+                            FnType::of_instance(bx.cx, &drop_fn))\n+                        }\n+                    };\n+                    do_call(self, bx, fn_ty, drop_fn, args,\n+                            Some((ReturnDest::Nothing, target)),\n+                            unwind);*/\n+                }\n+\n                 let target_ebb = fx.get_ebb(*target);\n                 fx.bcx.ins().jump(target_ebb, &[]);\n             }"}]}