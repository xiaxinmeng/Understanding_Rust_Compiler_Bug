{"sha": "dffd238f8b3195982427ba14bc01d47c6da6aedf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZmQyMzhmOGIzMTk1OTgyNDI3YmExNGJjMDFkNDdjNmRhNmFlZGY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-25T20:58:52Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-26T22:15:06Z"}, "message": "rustc: pass ty::Region behind an interned 'tcx reference.", "tree": {"sha": "edc0e2551b2df711e4ef7a0dd4debd62eaaddd35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edc0e2551b2df711e4ef7a0dd4debd62eaaddd35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dffd238f8b3195982427ba14bc01d47c6da6aedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dffd238f8b3195982427ba14bc01d47c6da6aedf", "html_url": "https://github.com/rust-lang/rust/commit/dffd238f8b3195982427ba14bc01d47c6da6aedf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dffd238f8b3195982427ba14bc01d47c6da6aedf/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d", "html_url": "https://github.com/rust-lang/rust/commit/5222fa58a1bc766e5d9dc352e36d5725fa28cd7d"}], "stats": {"total": 1375, "additions": 711, "deletions": 664}, "files": [{"sha": "4acb8b807d594efcc0f6b8be67ec1165a93c9a9f", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -106,7 +106,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: ty::Region, _: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, _: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         Ok(a)\n     }\n "}, {"sha": "5ce30484ede0027aab5c595d58a5ef906067ea86", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -329,8 +329,8 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions.\n             ty::ReLateBound(..) |"}, {"sha": "bf247acec5a2d31112c5a787ac2b7772ab029318", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -79,7 +79,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "9169d299e040b815876b8f75511b3a5981f06868", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n-                                   region: ty::Region,\n+                                   region: &'tcx ty::Region,\n                                    suffix: &str) {\n         fn item_scope_tag(item: &hir::Item) -> &'static str {\n             match item.node {\n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n              Some(span))\n         }\n \n-        let (description, span) = match region {\n+        let (description, span) = match *region {\n             ty::ReScope(scope) => {\n                 let new_string;\n                 let unknown_scope = || {\n@@ -405,12 +405,12 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         fn free_regions_from_same_fn<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                     sub: Region,\n-                                                     sup: Region)\n+                                                     sub: &'tcx Region,\n+                                                     sup: &'tcx Region)\n                                                      -> Option<FreeRegionsFromSameFn> {\n             debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n-                (ReFree(fr1), ReFree(fr2)) => {\n+                (&ReFree(fr1), &ReFree(fr2)) => {\n                     if fr1.scope != fr2.scope {\n                         return None\n                     }\n@@ -602,7 +602,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n                                     bound_kind: GenericKind<'tcx>,\n-                                    sub: Region)\n+                                    sub: &'tcx Region)\n     {\n         // FIXME: it would be better to report the first error message\n         // with the span of the parameter itself, rather than the span\n@@ -616,7 +616,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"the associated type `{}`\", p),\n         };\n \n-        let mut err = match sub {\n+        let mut err = match *sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(self.tcx.sess,\n@@ -667,8 +667,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n-                               sub: Region,\n-                               sup: Region)\n+                               sub: &'tcx Region,\n+                               sup: &'tcx Region)\n                                 -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n@@ -939,9 +939,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn report_sub_sup_conflict(&self,\n                                var_origin: RegionVariableOrigin,\n                                sub_origin: SubregionOrigin<'tcx>,\n-                               sub_region: Region,\n+                               sub_region: &'tcx Region,\n                                sup_origin: SubregionOrigin<'tcx>,\n-                               sup_region: Region) {\n+                               sup_region: &'tcx Region) {\n         let mut err = self.report_inference_failure(var_origin);\n \n         self.tcx.note_and_explain_region(&mut err,"}, {"sha": "beda734ee0d567b3baf332d1f5a3af7919c052c3", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -83,8 +83,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n@@ -99,7 +99,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::ReEmpty |\n             ty::ReErased => {\n                 // replace all free regions with 'erased\n-                ty::ReErased\n+                self.tcx().mk_region(ty::ReErased)\n             }\n         }\n     }"}, {"sha": "a5709e1880801d8942d87f909a1de2d46e301308", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -57,7 +57,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "90be5e935baf16a2733ec7e28f4a447d00135599", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -164,7 +164,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 .map(|(&skol, &(br, ref regions))| {\n                     let representative =\n                         regions.iter()\n-                               .filter(|r| !skol_resolution_map.contains_key(r))\n+                               .filter(|&&r| !skol_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n                                .unwrap_or_else(|| { // [1]\n@@ -268,9 +268,9 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                                             r0: ty::Region)\n-                                             -> ty::Region {\n+                                             a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                             r0: &'tcx ty::Region)\n+                                             -> &'tcx ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -301,7 +301,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n                            r0, *a_br, tainted);\n-                    return ty::ReLateBound(debruijn, *a_br);\n+                    return infcx.tcx.mk_region(ty::ReLateBound(debruijn, *a_br));\n                 }\n             }\n \n@@ -364,10 +364,12 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              snapshot: &CombinedSnapshot,\n                                              debruijn: ty::DebruijnIndex,\n                                              new_vars: &[ty::RegionVid],\n-                                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                             a_map: &FnvHashMap<ty::BoundRegion,\n+                                                                &'tcx ty::Region>,\n                                              a_vars: &[ty::RegionVid],\n                                              b_vars: &[ty::RegionVid],\n-                                             r0: ty::Region) -> ty::Region {\n+                                             r0: &'tcx ty::Region)\n+                                             -> &'tcx ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -419,7 +421,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(span, a_map, a_r.unwrap());\n+                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n                 assert!(!r0.is_bound());\n@@ -430,13 +432,14 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        fn rev_lookup(span: Span,\n-                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                      r: ty::Region) -> ty::Region\n+        fn rev_lookup<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                      span: Span,\n+                                      a_map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>,\n+                                      r: &'tcx ty::Region) -> &'tcx ty::Region\n         {\n             for (a_br, a_r) in a_map {\n                 if *a_r == r {\n-                    return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n+                    return infcx.tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br));\n                 }\n             }\n             span_bug!(\n@@ -445,19 +448,21 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 r);\n         }\n \n-        fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n+        fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                debruijn: ty::DebruijnIndex)\n+                                                -> &'tcx ty::Region {\n             infcx.region_vars.new_bound(debruijn)\n         }\n     }\n }\n \n fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n-                           map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                           map: &FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n                            -> Vec<ty::RegionVid> {\n     map.iter()\n-       .map(|(_, r)| match *r {\n+       .map(|(_, &r)| match *r {\n            ty::ReVar(r) => { r }\n-           r => {\n+           _ => {\n                span_bug!(\n                    fields.trace.origin.span(),\n                    \"found non-region-vid: {:?}\",\n@@ -467,8 +472,8 @@ fn var_ids<'a, 'gcx, 'tcx>(fields: &CombineFields<'a, 'gcx, 'tcx>,\n        .collect()\n }\n \n-fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n-    match r {\n+fn is_var_in_set(new_vars: &[ty::RegionVid], r: &ty::Region) -> bool {\n+    match *r {\n         ty::ReVar(ref v) => new_vars.iter().any(|x| x == v),\n         _ => false\n     }\n@@ -479,13 +484,13 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                          mut fldr: F)\n                                          -> T\n     where T: TypeFoldable<'tcx>,\n-          F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+          F: FnMut(&'tcx ty::Region, ty::DebruijnIndex) -> &'tcx ty::Region,\n {\n     tcx.fold_regions(unbound_value, &mut false, |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n-        assert!(match region {\n+        assert!(match *region {\n             ty::ReLateBound(..) => false,\n             _ => true\n         });\n@@ -497,9 +502,9 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn tainted_regions(&self,\n                        snapshot: &CombinedSnapshot,\n-                       r: ty::Region,\n+                       r: &'tcx ty::Region,\n                        directions: TaintDirections)\n-                       -> FnvHashSet<ty::Region> {\n+                       -> FnvHashSet<&'tcx ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n@@ -596,7 +601,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n-                                           -> (T, SkolemizationMap)\n+                                           -> (T, SkolemizationMap<'tcx>)\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n@@ -619,7 +624,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn leak_check(&self,\n                       overly_polymorphic: bool,\n                       span: Span,\n-                      skol_map: &SkolemizationMap,\n+                      skol_map: &SkolemizationMap<'tcx>,\n                       snapshot: &CombinedSnapshot)\n                       -> RelateResult<'tcx, ()>\n     {\n@@ -673,7 +678,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             for &tainted_region in &incoming_taints {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n-                match tainted_region {\n+                match *tainted_region {\n                     ty::ReVar(vid) => {\n                         if new_vars.contains(&vid) {\n                             warnings.extend(\n@@ -742,7 +747,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// to the depth of the predicate, in this case 1, so that the final\n     /// predicate is `for<'a> &'a int : Clone`.\n     pub fn plug_leaks<T>(&self,\n-                         skol_map: SkolemizationMap,\n+                         skol_map: SkolemizationMap<'tcx>,\n                          snapshot: &CombinedSnapshot,\n                          value: &T) -> T\n         where T : TypeFoldable<'tcx>\n@@ -755,7 +760,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // region back to the `ty::BoundRegion` that it originally\n         // represented. Because `leak_check` passed, we know that\n         // these taint sets are mutually disjoint.\n-        let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n+        let inv_skol_map: FnvHashMap<&'tcx ty::Region, ty::BoundRegion> =\n             skol_map\n             .iter()\n             .flat_map(|(&skol_br, &skol)| {\n@@ -794,15 +799,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // (which ought not to escape the snapshot, but we\n                     // don't check that) or itself\n                     assert!(\n-                        match r {\n+                        match *r {\n                             ty::ReVar(_) => true,\n                             ty::ReSkolemized(_, ref br1) => br == br1,\n                             _ => false,\n                         },\n                         \"leak-check would have us replace {:?} with {:?}\",\n                         r, br);\n \n-                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+                    self.tcx.mk_region(ty::ReLateBound(\n+                        ty::DebruijnIndex::new(current_depth - 1), br.clone()))\n                 }\n             }\n         });\n@@ -826,7 +832,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// Note: popping also occurs implicitly as part of `leak_check`.\n     pub fn pop_skolemized(&self,\n-                          skol_map: SkolemizationMap,\n+                          skol_map: SkolemizationMap<'tcx>,\n                           snapshot: &CombinedSnapshot)\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);"}, {"sha": "7d352be67d32b9c2a1dd716df90b74cbbaaec689", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -57,7 +57,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "9854cd95397b79179bb300abb77078d016a34502", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -177,7 +177,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n /// region that each late-bound region was replaced with.\n-pub type SkolemizationMap = FnvHashMap<ty::BoundRegion, ty::Region>;\n+pub type SkolemizationMap<'tcx> = FnvHashMap<ty::BoundRegion, &'tcx ty::Region>;\n \n /// Why did we require that the two types be related?\n ///\n@@ -1123,8 +1123,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn sub_regions(&self,\n                        origin: SubregionOrigin<'tcx>,\n-                       a: ty::Region,\n-                       b: ty::Region) {\n+                       a: &'tcx ty::Region,\n+                       b: &'tcx ty::Region) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n         self.region_vars.make_subregion(origin, a, b);\n     }\n@@ -1147,7 +1147,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n-                                     predicate: &ty::PolyRegionOutlivesPredicate)\n+                                     predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n         -> UnitResult<'tcx>\n     {\n         self.commit_if_ok(|snapshot| {\n@@ -1190,16 +1190,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n-        ty::ReVar(self.region_vars.new_region_var(origin))\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin)\n+                           -> &'tcx ty::Region {\n+        self.tcx.mk_region(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n     /// Create a region inference variable for the given\n     /// region parameter definition.\n     pub fn region_var_for_def(&self,\n                               span: Span,\n                               def: &ty::RegionParameterDef)\n-                              -> ty::Region {\n+                              -> &'tcx ty::Region {\n         self.next_region_var(EarlyBoundRegion(span, def.name))\n     }\n \n@@ -1245,7 +1246,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n+    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> &'tcx ty::Region {\n         self.region_vars.new_bound(debruijn)\n     }\n \n@@ -1530,7 +1531,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &ty::Binder<T>)\n-        -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n+        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n         where T : TypeFoldable<'tcx>\n     {\n         self.tcx.replace_late_bound_regions(\n@@ -1576,8 +1577,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                a: ty::Region,\n-                                bound: VerifyBound) {\n+                                a: &'tcx ty::Region,\n+                                bound: VerifyBound<'tcx>) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n                kind,\n                a,\n@@ -1666,7 +1667,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.region_maps.temporary_scope(rvalue_id)\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n     }\n "}, {"sha": "1c64ebc0537ae7455f774eb2a0245042199f208d", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -123,7 +123,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n-    map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n+    map: &'a FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n     node_ids: FnvHashMap<Node, usize>,\n }\n \n@@ -135,8 +135,8 @@ enum Node {\n \n // type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n-enum Edge {\n-    Constraint(Constraint),\n+enum Edge<'tcx> {\n+    Constraint(Constraint<'tcx>),\n     EnclScope(CodeExtent, CodeExtent),\n }\n \n@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n-    type Edge = Edge;\n+    type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n     }\n@@ -214,11 +214,11 @@ fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n         Constraint::ConstrainRegSubVar(r_1, rv_2) =>\n-            (Node::Region(r_1), Node::RegionVid(rv_2)),\n+            (Node::Region(*r_1), Node::RegionVid(rv_2)),\n         Constraint::ConstrainVarSubReg(rv_1, r_2) =>\n-            (Node::RegionVid(rv_1), Node::Region(r_2)),\n+            (Node::RegionVid(rv_1), Node::Region(*r_2)),\n         Constraint::ConstrainRegSubReg(r_1, r_2) =>\n-            (Node::Region(r_1), Node::Region(r_2)),\n+            (Node::Region(*r_1), Node::Region(*r_2)),\n     }\n }\n \n@@ -234,7 +234,7 @@ fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n \n impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     type Node = Node;\n-    type Edge = Edge;\n+    type Edge = Edge<'tcx>;\n     fn nodes(&self) -> dot::Nodes<Node> {\n         let mut set = FnvHashSet();\n         for node in self.node_ids.keys() {\n@@ -243,26 +243,26 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n         debug!(\"constraint graph has {} nodes\", set.len());\n         set.into_iter().collect()\n     }\n-    fn edges(&self) -> dot::Edges<Edge> {\n+    fn edges(&self) -> dot::Edges<Edge<'tcx>> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n         let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n         self.tcx.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(*sub, *sup)));\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n-    fn source(&self, edge: &Edge) -> Node {\n+    fn source(&self, edge: &Edge<'tcx>) -> Node {\n         let (n1, _) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n-    fn target(&self, edge: &Edge) -> Node {\n+    fn target(&self, edge: &Edge<'tcx>) -> Node {\n         let (_, n2) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2\n     }\n }\n \n-pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n+pub type ConstraintMap<'tcx> = FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,"}, {"sha": "b3693ae1e21ad86378859fa9fc92ce428de236f6", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 191, "deletions": 155, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -39,22 +39,22 @@ mod graphviz;\n \n // A constraint that influences the inference process.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum Constraint {\n+pub enum Constraint<'tcx> {\n     // One region variable is subregion of another\n     ConstrainVarSubVar(RegionVid, RegionVid),\n \n     // Concrete region is subregion of region variable\n-    ConstrainRegSubVar(Region, RegionVid),\n+    ConstrainRegSubVar(&'tcx Region, RegionVid),\n \n     // Region variable is subregion of concrete region. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainVarSubReg(RegionVid, Region),\n+    ConstrainVarSubReg(RegionVid, &'tcx Region),\n \n     // A constraint where neither side is a variable. This does not\n     // directly affect inference, but instead is checked after\n     // inference is complete.\n-    ConstrainRegSubReg(Region, Region),\n+    ConstrainRegSubReg(&'tcx Region, &'tcx Region),\n }\n \n // VerifyGenericBound(T, _, R, RS): The parameter type `T` (or\n@@ -66,8 +66,8 @@ pub enum Constraint {\n pub struct Verify<'tcx> {\n     kind: GenericKind<'tcx>,\n     origin: SubregionOrigin<'tcx>,\n-    region: Region,\n-    bound: VerifyBound,\n+    region: &'tcx Region,\n+    bound: VerifyBound<'tcx>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -80,36 +80,36 @@ pub enum GenericKind<'tcx> {\n // particular region (let's call it `'min`) meets some bound.\n // The bound is described the by the following grammar:\n #[derive(Debug)]\n-pub enum VerifyBound {\n+pub enum VerifyBound<'tcx> {\n     // B = exists {R} --> some 'r in {R} must outlive 'min\n     //\n     // Put another way, the subject value is known to outlive all\n     // regions in {R}, so if any of those outlives 'min, then the\n     // bound is met.\n-    AnyRegion(Vec<Region>),\n+    AnyRegion(Vec<&'tcx Region>),\n \n     // B = forall {R} --> all 'r in {R} must outlive 'min\n     //\n     // Put another way, the subject value is known to outlive some\n     // region in {R}, so if all of those outlives 'min, then the bound\n     // is met.\n-    AllRegions(Vec<Region>),\n+    AllRegions(Vec<&'tcx Region>),\n \n     // B = exists {B} --> 'min must meet some bound b in {B}\n-    AnyBound(Vec<VerifyBound>),\n+    AnyBound(Vec<VerifyBound<'tcx>>),\n \n     // B = forall {B} --> 'min must meet all bounds b in {B}\n-    AllBounds(Vec<VerifyBound>),\n+    AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TwoRegions {\n-    a: Region,\n-    b: Region,\n+pub struct TwoRegions<'tcx> {\n+    a: &'tcx Region,\n+    b: &'tcx Region,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-pub enum UndoLogEntry {\n+pub enum UndoLogEntry<'tcx> {\n     /// Pushed when we start a snapshot.\n     OpenSnapshot,\n \n@@ -122,7 +122,7 @@ pub enum UndoLogEntry {\n     AddVar(RegionVid),\n \n     /// We added the given `constraint`\n-    AddConstraint(Constraint),\n+    AddConstraint(Constraint<'tcx>),\n \n     /// We added the given `verify`\n     AddVerify(usize),\n@@ -131,7 +131,7 @@ pub enum UndoLogEntry {\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n-    AddCombination(CombineMapType, TwoRegions),\n+    AddCombination(CombineMapType, TwoRegions<'tcx>),\n \n     /// During skolemization, we sometimes purge entries from the undo\n     /// log in a kind of minisnapshot (unlike other snapshots, this\n@@ -153,13 +153,13 @@ pub enum RegionResolutionError<'tcx> {\n     /// `ConcreteFailure(o, a, b)`:\n     ///\n     /// `o` requires that `a <= b`, but this does not hold\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n \n     /// `GenericBoundFailure(p, s, a)\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a` (but none of the known bounds are sufficient).\n-    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, Region),\n+    GenericBoundFailure(SubregionOrigin<'tcx>, GenericKind<'tcx>, &'tcx Region),\n \n     /// `SubSupConflict(v, sub_origin, sub_r, sup_origin, sup_r)`:\n     ///\n@@ -168,9 +168,9 @@ pub enum RegionResolutionError<'tcx> {\n     /// `sub_r <= sup_r` does not hold.\n     SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>,\n-                   Region,\n+                   &'tcx Region,\n                    SubregionOrigin<'tcx>,\n-                   Region),\n+                   &'tcx Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n@@ -182,7 +182,7 @@ pub enum RegionResolutionError<'tcx> {\n \n #[derive(Clone, Debug)]\n pub enum ProcessedErrorOrigin<'tcx> {\n-    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n+    ConcreteFailure(SubregionOrigin<'tcx>, &'tcx Region, &'tcx Region),\n     VariableFailure(RegionVariableOrigin),\n }\n \n@@ -213,7 +213,7 @@ impl SameRegions {\n     }\n }\n \n-pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n+pub type CombineMap<'tcx> = FnvHashMap<TwoRegions<'tcx>, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -222,7 +222,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n     // variable.\n-    constraints: RefCell<FnvHashMap<Constraint, SubregionOrigin<'tcx>>>,\n+    constraints: RefCell<FnvHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>>,\n \n     // A \"verify\" is something that we need to verify after inference is\n     // done, but which does not directly affect inference in any way.\n@@ -250,8 +250,8 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // a bit of a hack but seems to work.\n     givens: RefCell<FnvHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n-    lubs: RefCell<CombineMap>,\n-    glbs: RefCell<CombineMap>,\n+    lubs: RefCell<CombineMap<'tcx>>,\n+    glbs: RefCell<CombineMap<'tcx>>,\n     skolemization_count: Cell<u32>,\n     bound_count: Cell<u32>,\n \n@@ -264,12 +264,12 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // otherwise we end up adding entries for things like the lower\n     // bound on a variable and so forth, which can never be rolled\n     // back.\n-    undo_log: RefCell<Vec<UndoLogEntry>>,\n+    undo_log: RefCell<Vec<UndoLogEntry<'tcx>>>,\n     unification_table: RefCell<UnificationTable<ty::RegionVid>>,\n \n     // This contains the results of inference.  It begins as an empty\n     // option and only acquires a value after inference is complete.\n-    values: RefCell<Option<Vec<VarValue>>>,\n+    values: RefCell<Option<Vec<VarValue<'tcx>>>>,\n }\n \n pub struct RegionSnapshot {\n@@ -303,23 +303,24 @@ impl TaintDirections {\n     }\n }\n \n-struct TaintSet {\n+struct TaintSet<'tcx> {\n     directions: TaintDirections,\n-    regions: FnvHashSet<ty::Region>\n+    regions: FnvHashSet<&'tcx ty::Region>\n }\n \n-impl TaintSet {\n+impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     fn new(directions: TaintDirections,\n-           initial_region: ty::Region)\n+           initial_region: &'tcx ty::Region)\n            -> Self {\n         let mut regions = FnvHashSet();\n         regions.insert(initial_region);\n         TaintSet { directions: directions, regions: regions }\n     }\n \n     fn fixed_point(&mut self,\n-                   undo_log: &[UndoLogEntry],\n-                   verifys: &[Verify]) {\n+                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                   undo_log: &[UndoLogEntry<'tcx>],\n+                   verifys: &[Verify<'tcx>]) {\n         let mut prev_len = 0;\n         while prev_len < self.len() {\n             debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n@@ -330,19 +331,21 @@ impl TaintSet {\n             for undo_entry in undo_log {\n                 match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {\n-                        self.add_edge(ReVar(a), ReVar(b));\n+                        self.add_edge(tcx.mk_region(ReVar(a)),\n+                                      tcx.mk_region(ReVar(b)));\n                     }\n                     &AddConstraint(ConstrainRegSubVar(a, b)) => {\n-                        self.add_edge(a, ReVar(b));\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n                     }\n                     &AddConstraint(ConstrainVarSubReg(a, b)) => {\n-                        self.add_edge(ReVar(a), b);\n+                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n                     }\n                     &AddConstraint(ConstrainRegSubReg(a, b)) => {\n                         self.add_edge(a, b);\n                     }\n                     &AddGiven(a, b) => {\n-                        self.add_edge(ReFree(a), ReVar(b));\n+                        self.add_edge(tcx.mk_region(ReFree(a)),\n+                                      tcx.mk_region(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n                         verifys[i].bound.for_each_region(&mut |b| {\n@@ -359,7 +362,7 @@ impl TaintSet {\n         }\n     }\n \n-    fn into_set(self) -> FnvHashSet<ty::Region> {\n+    fn into_set(self) -> FnvHashSet<&'tcx ty::Region> {\n         self.regions\n     }\n \n@@ -368,8 +371,8 @@ impl TaintSet {\n     }\n \n     fn add_edge(&mut self,\n-                source: ty::Region,\n-                target: ty::Region) {\n+                source: &'tcx ty::Region,\n+                target: &'tcx ty::Region) {\n         if self.directions.incoming {\n             if self.regions.contains(&target) {\n                 self.regions.insert(source);\n@@ -450,7 +453,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n-    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry) {\n+    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry<'tcx>) {\n         match undo_entry {\n             OpenSnapshot => {\n                 panic!(\"Failure to observe stack discipline\");\n@@ -529,21 +532,22 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n+    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot)\n+                           -> &'tcx Region {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br)\n+        self.tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n     /// in `skols`. This is used after a higher-ranked operation\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n     pub fn pop_skolemized(&self,\n-                          skols: &FnvHashSet<ty::Region>,\n+                          skols: &FnvHashSet<&'tcx ty::Region>,\n                           snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n@@ -566,7 +570,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 skols.len());\n         debug_assert! {\n             skols.iter()\n-                 .all(|k| match *k {\n+                 .all(|&k| match *k {\n                      ty::ReSkolemized(index, _) =>\n                          index.index >= first_to_pop &&\n                          index.index < last_to_pop,\n@@ -597,9 +601,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint(skols: &FnvHashSet<ty::Region>,\n-                           undo_entry: &UndoLogEntry)\n-                           -> bool {\n+        fn kill_constraint<'tcx>(skols: &FnvHashSet<&'tcx ty::Region>,\n+                                 undo_entry: &UndoLogEntry<'tcx>)\n+                                 -> bool {\n             match undo_entry {\n                 &AddConstraint(ConstrainVarSubVar(_, _)) =>\n                     false,\n@@ -626,7 +630,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     }\n \n-    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n+    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> &'tcx Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -652,14 +656,14 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             bug!(\"rollover in RegionInference new_bound()\");\n         }\n \n-        ReLateBound(debruijn, BrFresh(sc))\n+        self.tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n     }\n \n     fn values_are_none(&self) -> bool {\n         self.values.borrow().is_none()\n     }\n \n-    fn add_constraint(&self, constraint: Constraint, origin: SubregionOrigin<'tcx>) {\n+    fn add_constraint(&self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -704,20 +708,26 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn make_eqregion(&self, origin: SubregionOrigin<'tcx>, sub: Region, sup: Region) {\n+    pub fn make_eqregion(&self,\n+                         origin: SubregionOrigin<'tcx>,\n+                         sub: &'tcx Region,\n+                         sup: &'tcx Region) {\n         if sub != sup {\n             // Eventually, it would be nice to add direct support for\n             // equating regions.\n             self.make_subregion(origin.clone(), sub, sup);\n             self.make_subregion(origin, sup, sub);\n \n-            if let (ty::ReVar(sub), ty::ReVar(sup)) = (sub, sup) {\n+            if let (ty::ReVar(sub), ty::ReVar(sup)) = (*sub, *sup) {\n                 self.unification_table.borrow_mut().union(sub, sup);\n             }\n         }\n     }\n \n-    pub fn make_subregion(&self, origin: SubregionOrigin<'tcx>, sub: Region, sup: Region) {\n+    pub fn make_subregion(&self,\n+                          origin: SubregionOrigin<'tcx>,\n+                          sub: &'tcx Region,\n+                          sup: &'tcx Region) {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -727,26 +737,26 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                origin);\n \n         match (sub, sup) {\n-            (ReEarlyBound(..), _) |\n-            (ReLateBound(..), _) |\n-            (_, ReEarlyBound(..)) |\n-            (_, ReLateBound(..)) => {\n+            (&ReEarlyBound(..), _) |\n+            (&ReLateBound(..), _) |\n+            (_, &ReEarlyBound(..)) |\n+            (_, &ReLateBound(..)) => {\n                 span_bug!(origin.span(),\n                           \"cannot relate bound region: {:?} <= {:?}\",\n                           sub,\n                           sup);\n             }\n-            (_, ReStatic) => {\n+            (_, &ReStatic) => {\n                 // all regions are subregions of static, so we can ignore this\n             }\n-            (ReVar(sub_id), ReVar(sup_id)) => {\n+            (&ReVar(sub_id), &ReVar(sup_id)) => {\n                 self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n             }\n-            (r, ReVar(sup_id)) => {\n-                self.add_constraint(ConstrainRegSubVar(r, sup_id), origin);\n+            (_, &ReVar(sup_id)) => {\n+                self.add_constraint(ConstrainRegSubVar(sub, sup_id), origin);\n             }\n-            (ReVar(sub_id), r) => {\n-                self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n+            (&ReVar(sub_id), _) => {\n+                self.add_constraint(ConstrainVarSubReg(sub_id, sup), origin);\n             }\n             _ => {\n                 self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n@@ -758,8 +768,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn verify_generic_bound(&self,\n                                 origin: SubregionOrigin<'tcx>,\n                                 kind: GenericKind<'tcx>,\n-                                sub: Region,\n-                                bound: VerifyBound) {\n+                                sub: &'tcx Region,\n+                                bound: VerifyBound<'tcx>) {\n         self.add_verify(Verify {\n             kind: kind,\n             origin: origin,\n@@ -768,29 +778,43 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn lub_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n+    pub fn lub_regions(&self,\n+                       origin: SubregionOrigin<'tcx>,\n+                       a: &'tcx Region,\n+                       b: &'tcx Region)\n+                       -> &'tcx Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n-        if a == ty::ReStatic || b == ty::ReStatic {\n-            ReStatic // nothing lives longer than static\n-        } else if a == b {\n-            a // LUB(a,a) = a\n-        } else {\n-            self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n-                this.make_subregion(origin.clone(), old_r, new_r)\n-            })\n+        match (a, b) {\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n+            }\n+\n+            _ if a == b => {\n+                a // LUB(a,a) = a\n+            }\n+\n+            _ => {\n+                self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n+                    this.make_subregion(origin.clone(), old_r, new_r)\n+                })\n+            }\n         }\n     }\n \n-    pub fn glb_regions(&self, origin: SubregionOrigin<'tcx>, a: Region, b: Region) -> Region {\n+    pub fn glb_regions(&self,\n+                       origin: SubregionOrigin<'tcx>,\n+                       a: &'tcx Region,\n+                       b: &'tcx Region)\n+                       -> &'tcx Region {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (ReStatic, r) | (r, ReStatic) => {\n+            (&ReStatic, r) | (r, &ReStatic) => {\n                 r // static lives longer than everything else\n             }\n \n@@ -806,26 +830,27 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region {\n+    pub fn resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n         match *self.values.borrow() {\n             None => {\n                 span_bug!((*self.var_origins.borrow())[rid.index as usize].span(),\n                           \"attempt to resolve region variable before values have \\\n                            been computed!\")\n             }\n             Some(ref values) => {\n-                let r = lookup(values, rid);\n+                let r = lookup(self.tcx, values, rid);\n                 debug!(\"resolve_var({:?}) = {:?}\", rid, r);\n                 r\n             }\n         }\n     }\n \n-    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region {\n-        ty::ReVar(self.unification_table.borrow_mut().find_value(rid).min_vid)\n+    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> &'tcx ty::Region {\n+        let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n+        self.tcx.mk_region(ty::ReVar(vid))\n     }\n \n-    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap> {\n+    fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap<'tcx>> {\n         match t {\n             Glb => &self.glbs,\n             Lub => &self.lubs,\n@@ -834,26 +859,26 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn combine_vars<F>(&self,\n                            t: CombineMapType,\n-                           a: Region,\n-                           b: Region,\n+                           a: &'tcx Region,\n+                           b: &'tcx Region,\n                            origin: SubregionOrigin<'tcx>,\n                            mut relate: F)\n-                           -> Region\n-        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region, Region)\n+                           -> &'tcx Region\n+        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, &'tcx Region, &'tcx Region)\n     {\n         let vars = TwoRegions { a: a, b: b };\n         if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n-            return ReVar(c);\n+            return self.tcx.mk_region(ReVar(c));\n         }\n         let c = self.new_region_var(MiscVariable(origin.span()));\n         self.combine_map(t).borrow_mut().insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddCombination(t, vars));\n         }\n-        relate(self, a, ReVar(c));\n-        relate(self, b, ReVar(c));\n+        relate(self, a, self.tcx.mk_region(ReVar(c)));\n+        relate(self, b, self.tcx.mk_region(ReVar(c)));\n         debug!(\"combine_vars() c={:?}\", c);\n-        ReVar(c)\n+        self.tcx.mk_region(ReVar(c))\n     }\n \n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n@@ -878,17 +903,18 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// related to other regions.\n     pub fn tainted(&self,\n                    mark: &RegionSnapshot,\n-                   r0: Region,\n+                   r0: &'tcx Region,\n                    directions: TaintDirections)\n-                   -> FnvHashSet<ty::Region> {\n+                   -> FnvHashSet<&'tcx ty::Region> {\n         debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n                mark, r0, directions);\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n         let mut taint_set = TaintSet::new(directions, r0);\n-        taint_set.fixed_point(&self.undo_log.borrow()[mark.length..],\n+        taint_set.fixed_point(self.tcx,\n+                              &self.undo_log.borrow()[mark.length..],\n                               &self.verifys.borrow());\n         debug!(\"tainted: result={:?}\", taint_set.regions);\n         return taint_set.into_set();\n@@ -910,36 +936,39 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         errors\n     }\n \n-    fn lub_concrete_regions(&self, free_regions: &FreeRegionMap, a: Region, b: Region) -> Region {\n+    fn lub_concrete_regions(&self,\n+                            free_regions: &FreeRegionMap,\n+                            a: &'tcx Region,\n+                            b: &'tcx Region)\n+                            -> &'tcx Region {\n         match (a, b) {\n-            (ReLateBound(..), _) |\n-            (_, ReLateBound(..)) |\n-            (ReEarlyBound(..), _) |\n-            (_, ReEarlyBound(..)) |\n-            (ReErased, _) |\n-            (_, ReErased) => {\n+            (&ReLateBound(..), _) |\n+            (_, &ReLateBound(..)) |\n+            (&ReEarlyBound(..), _) |\n+            (_, &ReEarlyBound(..)) |\n+            (&ReErased, _) |\n+            (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n \n-            (ReStatic, _) | (_, ReStatic) => {\n-                ReStatic // nothing lives longer than static\n+            (r @ &ReStatic, _) | (_, r @ &ReStatic) => {\n+                r // nothing lives longer than static\n             }\n \n-            (ReEmpty, r) | (r, ReEmpty) => {\n+            (&ReEmpty, r) | (r, &ReEmpty) => {\n                 r // everything lives longer than empty\n             }\n \n-            (ReVar(v_id), _) | (_, ReVar(v_id)) => {\n+            (&ReVar(v_id), _) | (_, &ReVar(v_id)) => {\n                 span_bug!((*self.var_origins.borrow())[v_id.index as usize].span(),\n                           \"lub_concrete_regions invoked with non-concrete \\\n                            regions: {:?}, {:?}\",\n                           a,\n                           b);\n             }\n \n-            (ReFree(ref fr), ReScope(s_id)) |\n-            (ReScope(s_id), ReFree(ref fr)) => {\n-                let f = ReFree(*fr);\n+            (&ReFree(fr), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(fr)) => {\n                 // A \"free\" region can be interpreted as \"some region\n                 // at least as big as the block fr.scope_id\".  So, we can\n                 // reasonably compare free regions and scopes:\n@@ -949,33 +978,34 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     // if the free region's scope `fr.scope_id` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n                     // region itself:\n-                    f\n+                    self.tcx.mk_region(ReFree(fr))\n                 } else {\n                     // otherwise, we don't know what the free region is,\n                     // so we must conservatively say the LUB is static:\n-                    ReStatic\n+                    self.tcx.mk_region(ReStatic)\n                 }\n             }\n \n-            (ReScope(a_id), ReScope(b_id)) => {\n+            (&ReScope(a_id), &ReScope(b_id)) => {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                ReScope(self.tcx.region_maps.nearest_common_ancestor(a_id, b_id))\n+                self.tcx.mk_region(ReScope(\n+                    self.tcx.region_maps.nearest_common_ancestor(a_id, b_id)))\n             }\n \n-            (ReFree(a_fr), ReFree(b_fr)) => {\n-                free_regions.lub_free_regions(a_fr, b_fr)\n+            (&ReFree(a_fr), &ReFree(b_fr)) => {\n+                self.tcx.mk_region(free_regions.lub_free_regions(a_fr, b_fr))\n             }\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (ReSkolemized(..), _) |\n-            (_, ReSkolemized(..)) => {\n+            (&ReSkolemized(..), _) |\n+            (_, &ReSkolemized(..)) => {\n                 if a == b {\n                     a\n                 } else {\n-                    ReStatic\n+                    self.tcx.mk_region(ReStatic)\n                 }\n             }\n         }\n@@ -985,24 +1015,24 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n // ______________________________________________________________________\n \n #[derive(Copy, Clone, Debug)]\n-pub enum VarValue {\n-    Value(Region),\n+pub enum VarValue<'tcx> {\n+    Value(&'tcx Region),\n     ErrorValue,\n }\n \n struct RegionAndOrigin<'tcx> {\n-    region: Region,\n+    region: &'tcx Region,\n     origin: SubregionOrigin<'tcx>,\n }\n \n-type RegionGraph = graph::Graph<(), Constraint>;\n+type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n                              free_regions: &FreeRegionMap,\n                              errors: &mut Vec<RegionResolutionError<'tcx>>,\n                              subject: ast::NodeId)\n-                             -> Vec<VarValue> {\n+                             -> Vec<VarValue<'tcx>> {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n@@ -1020,9 +1050,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         var_data\n     }\n \n-    fn construct_var_data(&self) -> Vec<VarValue> {\n+    fn construct_var_data(&self) -> Vec<VarValue<'tcx>> {\n         (0..self.num_vars() as usize)\n-            .map(|_| Value(ty::ReEmpty))\n+            .map(|_| Value(self.tcx.mk_region(ty::ReEmpty)))\n             .collect()\n     }\n \n@@ -1059,7 +1089,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue]) {\n+    fn expansion(&self, free_regions: &FreeRegionMap, var_values: &mut [VarValue<'tcx>]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n                    constraint, origin);\n@@ -1089,17 +1119,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn expand_node(&self,\n                    free_regions: &FreeRegionMap,\n-                   a_region: Region,\n+                   a_region: &'tcx Region,\n                    b_vid: RegionVid,\n-                   b_data: &mut VarValue)\n+                   b_data: &mut VarValue<'tcx>)\n                    -> bool {\n         debug!(\"expand_node({:?}, {:?} == {:?})\",\n                a_region,\n                b_vid,\n                b_data);\n \n         // Check if this relationship is implied by a given.\n-        match a_region {\n+        match *a_region {\n             ty::ReFree(fr) => {\n                 if self.givens.borrow().contains(&(fr, b_vid)) {\n                     debug!(\"given\");\n@@ -1136,7 +1166,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// and check that they are satisfied.\n     fn collect_errors(&self,\n                       free_regions: &FreeRegionMap,\n-                      var_data: &mut Vec<VarValue>,\n+                      var_data: &mut Vec<VarValue<'tcx>>,\n                       errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         let constraints = self.constraints.borrow();\n         for (constraint, origin) in constraints.iter() {\n@@ -1192,7 +1222,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         for verify in self.verifys.borrow().iter() {\n             debug!(\"collect_errors: verify={:?}\", verify);\n-            let sub = normalize(var_data, verify.region);\n+            let sub = normalize(self.tcx, var_data, verify.region);\n             if verify.bound.is_met(self.tcx, free_regions, var_data, sub) {\n                 continue;\n             }\n@@ -1213,8 +1243,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(&self,\n                           free_regions: &FreeRegionMap,\n-                          var_data: &[VarValue],\n-                          graph: &RegionGraph,\n+                          var_data: &[VarValue<'tcx>],\n+                          graph: &RegionGraph<'tcx>,\n                           errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"collect_var_errors\");\n \n@@ -1271,7 +1301,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn construct_graph(&self) -> RegionGraph {\n+    fn construct_graph(&self) -> RegionGraph<'tcx> {\n         let num_vars = self.num_vars();\n \n         let constraints = self.constraints.borrow();\n@@ -1315,7 +1345,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn collect_error_for_expanding_node(&self,\n                                         free_regions: &FreeRegionMap,\n-                                        graph: &RegionGraph,\n+                                        graph: &RegionGraph<'tcx>,\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n                                         errors: &mut Vec<RegionResolutionError<'tcx>>) {\n@@ -1339,9 +1369,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // the user will more likely get a specific suggestion.\n         fn free_regions_first(a: &RegionAndOrigin, b: &RegionAndOrigin) -> Ordering {\n             match (a.region, b.region) {\n-                (ReFree(..), ReFree(..)) => Equal,\n-                (ReFree(..), _) => Less,\n-                (_, ReFree(..)) => Greater,\n+                (&ReFree(..), &ReFree(..)) => Equal,\n+                (&ReFree(..), _) => Less,\n+                (_, &ReFree(..)) => Greater,\n                 (_, _) => Equal,\n             }\n         }\n@@ -1378,7 +1408,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn collect_concrete_regions(&self,\n-                                graph: &RegionGraph,\n+                                graph: &RegionGraph<'tcx>,\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n                                 dup_vec: &mut [u32])\n@@ -1423,7 +1453,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         fn process_edges<'a, 'gcx, 'tcx>(this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n                                          state: &mut WalkState<'tcx>,\n-                                         graph: &RegionGraph,\n+                                         graph: &RegionGraph<'tcx>,\n                                          source_vid: RegionVid,\n                                          dir: Direction) {\n             debug!(\"process_edges(source_vid={:?}, dir={:?})\", source_vid, dir);\n@@ -1460,7 +1490,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint, &SubregionOrigin<'tcx>) -> bool\n+        where F: FnMut(&Constraint<'tcx>, &SubregionOrigin<'tcx>) -> bool\n     {\n         let mut iteration = 0;\n         let mut changed = true;\n@@ -1481,17 +1511,23 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n }\n \n-fn normalize(values: &Vec<VarValue>, r: ty::Region) -> ty::Region {\n-    match r {\n-        ty::ReVar(rid) => lookup(values, rid),\n+fn normalize<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             values: &Vec<VarValue<'tcx>>,\n+                             r: &'tcx ty::Region)\n+                             -> &'tcx ty::Region {\n+    match *r {\n+        ty::ReVar(rid) => lookup(tcx, values, rid),\n         _ => r,\n     }\n }\n \n-fn lookup(values: &Vec<VarValue>, rid: ty::RegionVid) -> ty::Region {\n+fn lookup<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                          values: &Vec<VarValue<'tcx>>,\n+                          rid: ty::RegionVid)\n+                          -> &'tcx ty::Region {\n     match values[rid.index as usize] {\n         Value(r) => r,\n-        ErrorValue => ReStatic, // Previously reported error.\n+        ErrorValue => tcx.mk_region(ReStatic), // Previously reported error.\n     }\n }\n \n@@ -1535,8 +1571,8 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> VerifyBound {\n-    fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n+impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n+    fn for_each_region(&self, f: &mut FnMut(&'tcx ty::Region)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n             &VerifyBound::AllRegions(ref rs) => for &r in rs {\n@@ -1552,7 +1588,7 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n \n     pub fn must_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.contains(&ty::ReStatic),\n+            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n             &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n             &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n             &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n@@ -1562,13 +1598,13 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n     pub fn cannot_hold(&self) -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n-            &VerifyBound::AllRegions(ref bs) => bs.contains(&ty::ReEmpty),\n+            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n             &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n             &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n         }\n     }\n \n-    pub fn or(self, vb: VerifyBound) -> VerifyBound {\n+    pub fn or(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n         if self.must_hold() || vb.cannot_hold() {\n             self\n         } else if self.cannot_hold() || vb.must_hold() {\n@@ -1578,7 +1614,7 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n         }\n     }\n \n-    pub fn and(self, vb: VerifyBound) -> VerifyBound {\n+    pub fn and(self, vb: VerifyBound<'tcx>) -> VerifyBound<'tcx> {\n         if self.must_hold() && vb.must_hold() {\n             self\n         } else if self.cannot_hold() && vb.cannot_hold() {\n@@ -1590,18 +1626,18 @@ impl<'a, 'gcx, 'tcx> VerifyBound {\n \n     fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n               free_regions: &FreeRegionMap,\n-              var_values: &Vec<VarValue>,\n-              min: ty::Region)\n+              var_values: &Vec<VarValue<'tcx>>,\n+              min: &'tcx ty::Region)\n               -> bool {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>\n                 rs.iter()\n-                  .map(|&r| normalize(var_values, r))\n+                  .map(|&r| normalize(tcx, var_values, r))\n                   .any(|r| free_regions.is_subregion_of(tcx, min, r)),\n \n             &VerifyBound::AllRegions(ref rs) =>\n                 rs.iter()\n-                  .map(|&r| normalize(var_values, r))\n+                  .map(|&r| normalize(tcx, var_values, r))\n                   .all(|r| free_regions.is_subregion_of(tcx, min, r)),\n \n             &VerifyBound::AnyBound(ref bs) =>"}, {"sha": "357a03a2ffd7c214d4919169e76a363620fd2f46", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -72,10 +72,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n-          ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n-          _ => r,\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n+            _ => r,\n         }\n     }\n }\n@@ -138,10 +138,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n-          ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n-          _ => r,\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n+            ty::ReVar(rid) => self.infcx.region_vars.resolve_var(rid),\n+            _ => r,\n         }\n     }\n }"}, {"sha": "159de2faced574e5fb9817f6e03223768fc1233d", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -107,7 +107,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?}) self.cause={:?}\",\n                self.tag(), a, b, self.fields.cause);\n         // FIXME -- we have more fine-grained information available"}, {"sha": "381a86a42d48236fb210bb4b2986b4f7cc843043", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -198,7 +198,6 @@ pub trait CrateStore<'tcx> {\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n-    fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n \n@@ -391,7 +390,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n-    fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n     fn is_typedef(&self, did: DefId) -> bool { bug!(\"is_typedef\") }\n "}, {"sha": "798702e6fd6571b5f70269576e641c335dbc4e1c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -76,7 +76,7 @@ pub trait Delegate<'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: ty::Region,\n+              loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: LoanCause);\n \n@@ -301,11 +301,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         for arg in &decl.inputs {\n             let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n-            let fn_body_scope = self.tcx().region_maps.node_extent(body.id);\n+            let fn_body_scope_r = self.tcx().node_scope_region(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n-                ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n+                fn_body_scope_r, // Args live only as long as the fn body.\n                 arg_ty);\n \n             self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n@@ -352,7 +352,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn borrow_expr(&mut self,\n                    expr: &hir::Expr,\n-                   r: ty::Region,\n+                   r: &'tcx ty::Region,\n                    bk: ty::BorrowKind,\n                    cause: LoanCause) {\n         debug!(\"borrow_expr(expr={:?}, r={:?}, bk={:?})\",\n@@ -431,7 +431,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n                 let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n-                self.borrow_expr(&discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n+                let r = self.tcx().mk_region(ty::ReEmpty);\n+                self.borrow_expr(&discr, r, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -449,7 +450,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let expr_ty = return_if_err!(self.mc.infcx.node_ty(expr.id));\n-                if let ty::TyRef(&r, _) = expr_ty.sty {\n+                if let ty::TyRef(r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n@@ -557,7 +558,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let callee_ty = return_if_err!(self.mc.infcx.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n-        let call_scope = self.tcx().region_maps.node_extent(call.id);\n         match callee_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n                 self.consume_expr(callee);\n@@ -578,14 +578,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     };\n                 match overloaded_call_type {\n                     FnMutOverloadedCall => {\n+                        let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call_scope),\n+                                         call_scope_r,\n                                          ty::MutBorrow,\n                                          ClosureInvocation);\n                     }\n                     FnOverloadedCall => {\n+                        let call_scope_r = self.tcx().node_scope_region(call.id);\n                         self.borrow_expr(callee,\n-                                         ty::ReScope(call_scope),\n+                                         call_scope_r,\n                                          ty::ImmBorrow,\n                                          ClosureInvocation);\n                     }\n@@ -761,7 +763,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 };\n                 let bk = ty::BorrowKind::from_mutbl(m);\n                 self.delegate.borrow(expr.id, expr.span, cmt,\n-                                     *r, bk, AutoRef);\n+                                     r, bk, AutoRef);\n             }\n         }\n     }\n@@ -822,7 +824,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n                                      cmt_base,\n-                                     *r,\n+                                     r,\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n@@ -835,7 +837,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // Converting from a &T to *T (or &mut T to *mut T) is\n                 // treated as borrowing it for the enclosing temporary\n                 // scope.\n-                let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+                let r = self.tcx().node_scope_region(expr.id);\n \n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n@@ -890,7 +892,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // methods are implicitly autoref'd which sadly does not use\n         // adjustments, so we must hardcode the borrow here.\n \n-        let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+        let r = self.tcx().node_scope_region(expr.id);\n         let bk = ty::ImmBorrow;\n \n         for &arg in &rhs {\n@@ -979,7 +981,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 // It is also a borrow or copy/move of the value being matched.\n                 match bmode {\n                     hir::BindByRef(m) => {\n-                        if let ty::TyRef(&r, _) = pat_ty.sty {\n+                        if let ty::TyRef(r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }"}, {"sha": "8193d062631c1f4be6309ffae1ad1813ef91f8df", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -37,7 +37,7 @@ impl FreeRegionMap {\n         for implied_bound in implied_bounds {\n             debug!(\"implied bound: {:?}\", implied_bound);\n             match *implied_bound {\n-                ImpliedBound::RegionSubRegion(ty::ReFree(free_a), ty::ReFree(free_b)) => {\n+                ImpliedBound::RegionSubRegion(&ty::ReFree(free_a), &ty::ReFree(free_b)) => {\n                     self.relate_free_regions(free_a, free_b);\n                 }\n                 ImpliedBound::RegionSubRegion(..) |\n@@ -65,9 +65,9 @@ impl FreeRegionMap {\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n                     match (r_a, r_b) {\n-                        (ty::ReStatic, ty::ReFree(_)) => {},\n-                        (ty::ReFree(fr_a), ty::ReStatic) => self.relate_to_static(fr_a),\n-                        (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                        (&ty::ReStatic, &ty::ReFree(_)) => {},\n+                        (&ty::ReFree(fr_a), &ty::ReStatic) => self.relate_to_static(fr_a),\n+                        (&ty::ReFree(fr_a), &ty::ReFree(fr_b)) => {\n                             // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n                             self.relate_free_regions(fr_b, fr_a);\n                         }\n@@ -122,26 +122,26 @@ impl FreeRegionMap {\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n     pub fn is_subregion_of(&self,\n                            tcx: TyCtxt,\n-                           sub_region: ty::Region,\n-                           super_region: ty::Region)\n+                           sub_region: &ty::Region,\n+                           super_region: &ty::Region)\n                            -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n-                (ty::ReEmpty, _) |\n-                (_, ty::ReStatic) =>\n+                (&ty::ReEmpty, _) |\n+                (_, &ty::ReStatic) =>\n                     true,\n \n-                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n+                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n                     tcx.region_maps.is_subscope_of(sub_scope, super_scope),\n \n-                (ty::ReScope(sub_scope), ty::ReFree(fr)) =>\n+                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) =>\n                     tcx.region_maps.is_subscope_of(sub_scope, fr.scope) ||\n                     self.is_static(fr),\n \n-                (ty::ReFree(sub_fr), ty::ReFree(super_fr)) =>\n+                (&ty::ReFree(sub_fr), &ty::ReFree(super_fr)) =>\n                     self.sub_free_region(sub_fr, super_fr),\n \n-                (ty::ReStatic, ty::ReFree(sup_fr)) =>\n+                (&ty::ReStatic, &ty::ReFree(sup_fr)) =>\n                     self.is_static(sup_fr),\n \n                 _ =>"}, {"sha": "a74bdb02044dee92127b18420480469de2b241d6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -90,11 +90,11 @@ use std::rc::Rc;\n \n #[derive(Clone, PartialEq)]\n pub enum Categorization<'tcx> {\n-    Rvalue(ty::Region),                    // temporary val, argument is its scope\n+    Rvalue(&'tcx ty::Region),                    // temporary val, argument is its scope\n     StaticItem,\n     Upvar(Upvar),                          // upvar referenced by closure env\n     Local(ast::NodeId),                    // local variable\n-    Deref(cmt<'tcx>, usize, PointerKind),  // deref of a ptr\n+    Deref(cmt<'tcx>, usize, PointerKind<'tcx>),  // deref of a ptr\n     Interior(cmt<'tcx>, InteriorKind),     // something interior: field, tuple, etc\n     Downcast(cmt<'tcx>, DefId),            // selects a particular enum variant (*1)\n \n@@ -110,18 +110,18 @@ pub struct Upvar {\n \n // different kinds of pointers:\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum PointerKind {\n+pub enum PointerKind<'tcx> {\n     /// `Box<T>`\n     Unique,\n \n     /// `&T`\n-    BorrowedPtr(ty::BorrowKind, ty::Region),\n+    BorrowedPtr(ty::BorrowKind, &'tcx ty::Region),\n \n     /// `*T`\n     UnsafePtr(hir::Mutability),\n \n     /// Implicit deref of the `&T` that results from an overloaded index `[]`.\n-    Implicit(ty::BorrowKind, ty::Region),\n+    Implicit(ty::BorrowKind, &'tcx ty::Region),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -198,8 +198,8 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n // We pun on *T to mean both actual deref of a ptr as well\n // as accessing of components:\n #[derive(Copy, Clone)]\n-pub enum deref_kind {\n-    deref_ptr(PointerKind),\n+pub enum deref_kind<'tcx> {\n+    deref_ptr(PointerKind<'tcx>),\n     deref_interior(InteriorKind),\n }\n \n@@ -216,7 +216,7 @@ fn deref_kind(t: Ty, context: DerefKindContext) -> McResult<deref_kind> {\n \n         ty::TyRef(r, mt) => {\n             let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n-            Ok(deref_ptr(BorrowedPtr(kind, *r)))\n+            Ok(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n         ty::TyRawPtr(ref mt) => {\n@@ -767,13 +767,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         };\n \n         // Region of environment pointer\n-        let env_region = ty::ReFree(ty::FreeRegion {\n+        let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n             scope: self.tcx().region_maps.item_extent(fn_body_id),\n             bound_region: ty::BrEnv\n-        });\n+        }));\n \n         let env_ptr = BorrowedPtr(env_borrow_kind, env_region);\n \n@@ -817,11 +817,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n-    pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region {\n-        match self.infcx.temporary_scope(id) {\n+    pub fn temporary_scope(&self, id: ast::NodeId) -> &'tcx ty::Region {\n+        self.tcx().mk_region(match self.infcx.temporary_scope(id) {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n-        }\n+        })\n     }\n \n     pub fn cat_rvalue_node(&self,\n@@ -845,7 +845,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let re = if qualif.intersects(ConstQualif::NON_STATIC_BORROWS) {\n             self.temporary_scope(id)\n         } else {\n-            ty::ReStatic\n+            self.tcx().mk_region(ty::ReStatic)\n         };\n         let ret = self.cat_rvalue(id, span, re, expr_ty);\n         debug!(\"cat_rvalue_node ret {:?}\", ret);\n@@ -855,7 +855,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n-                      temp_scope: ty::Region,\n+                      temp_scope: &'tcx ty::Region,\n                       expr_ty: Ty<'tcx>) -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id:cmt_id,\n@@ -1480,7 +1480,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     }\n }\n \n-impl fmt::Debug for PointerKind {\n+impl<'tcx> fmt::Debug for PointerKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Unique => write!(f, \"Box\"),"}, {"sha": "059fcfdca8a005fa81d33d01561dc30fd5a3ffdc", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -911,7 +911,7 @@ pub enum Rvalue<'tcx> {\n     Repeat(Operand<'tcx>, TypedConstVal<'tcx>),\n \n     /// &x or &mut x\n-    Ref(Region, BorrowKind, Lvalue<'tcx>),\n+    Ref(&'tcx Region, BorrowKind, Lvalue<'tcx>),\n \n     /// length of a [X] or [X;n] value\n     Len(Lvalue<'tcx>),"}, {"sha": "76e5f8598c1c549c6da3843e7275d293aa9a1eae", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -145,8 +145,7 @@ impl<'tcx> Rvalue<'tcx> {\n             }\n             &Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n-                Some(tcx.mk_ref(\n-                    tcx.mk_region(reg),\n+                Some(tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: lv_ty,\n                         mutbl: bk.to_mutbl_lossy()"}, {"sha": "f608185157a4ec13b91b4c48b9cfd256fa1ee285", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -724,7 +724,7 @@ make_mir_visitor!(Visitor,);\n make_mir_visitor!(MutVisitor,mut);\n \n #[derive(Copy, Clone, Debug)]\n-pub enum LvalueContext {\n+pub enum LvalueContext<'tcx> {\n     // Appears as LHS of an assignment\n     Store,\n \n@@ -738,7 +738,7 @@ pub enum LvalueContext {\n     Inspect,\n \n     // Being borrowed\n-    Borrow { region: Region, kind: BorrowKind },\n+    Borrow { region: &'tcx Region, kind: BorrowKind },\n \n     // Being sliced -- this should be same as being borrowed, probably\n     Slice { from_start: usize, from_end: usize },"}, {"sha": "a0e25d54a1321aac7d433f8b0faf1d2e204c1c9a", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -93,7 +93,7 @@ pub struct FulfillmentContext<'tcx> {\n \n #[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n-    pub sub_region: ty::Region,\n+    pub sub_region: &'tcx ty::Region,\n     pub sup_type: Ty<'tcx>,\n     pub cause: ObligationCause<'tcx>,\n }\n@@ -246,7 +246,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_region_obligation(&mut self,\n                                       t_a: Ty<'tcx>,\n-                                      r_b: ty::Region,\n+                                      r_b: &'tcx ty::Region,\n                                       cause: ObligationCause<'tcx>)\n     {\n         register_region_obligation(t_a, r_b, cause, &mut self.region_obligations);\n@@ -580,7 +580,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // Otherwise, we have something of the form\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n-                            register_region_obligation(t_a, ty::ReStatic,\n+                            let r_static = selcx.tcx().mk_region(ty::ReStatic);\n+                            register_region_obligation(t_a, r_static,\n                                                        obligation.cause.clone(),\n                                                        region_obligations);\n                             Ok(Some(vec![]))\n@@ -690,7 +691,7 @@ fn coinductive_obligation<'a,'gcx,'tcx>(selcx: &SelectionContext<'a,'gcx,'tcx>,\n }\n \n fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n-                                    r_b: ty::Region,\n+                                    r_b: &'tcx ty::Region,\n                                     cause: ObligationCause<'tcx>,\n                                     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n {"}, {"sha": "8adf6e19f39d7b38990b00d309fdf8f6894e230f", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -1247,7 +1247,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         obligation: &TraitObligation<'tcx>,\n                         trait_bound: ty::PolyTraitRef<'tcx>,\n                         skol_trait_ref: ty::TraitRef<'tcx>,\n-                        skol_map: &infer::SkolemizationMap,\n+                        skol_map: &infer::SkolemizationMap<'tcx>,\n                         snapshot: &infer::CombinedSnapshot)\n                         -> bool\n     {\n@@ -2264,7 +2264,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                    mut substs: Normalized<'tcx, &'tcx Substs<'tcx>>,\n                    cause: ObligationCause<'tcx>,\n                    recursion_depth: usize,\n-                   skol_map: infer::SkolemizationMap,\n+                   skol_map: infer::SkolemizationMap<'tcx>,\n                    snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n@@ -2662,7 +2662,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     impl_def_id: DefId,\n                     obligation: &TraitObligation<'tcx>,\n                     snapshot: &infer::CombinedSnapshot)\n-                    -> (Normalized<'tcx, &'tcx Substs<'tcx>>, infer::SkolemizationMap)\n+                    -> (Normalized<'tcx, &'tcx Substs<'tcx>>,\n+                        infer::SkolemizationMap<'tcx>)\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot) {\n             Ok((substs, skol_map)) => (substs, skol_map),\n@@ -2679,7 +2680,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                   obligation: &TraitObligation<'tcx>,\n                   snapshot: &infer::CombinedSnapshot)\n                   -> Result<(Normalized<'tcx, &'tcx Substs<'tcx>>,\n-                             infer::SkolemizationMap), ()>\n+                             infer::SkolemizationMap<'tcx>), ()>\n     {\n         let impl_trait_ref = self.tcx().impl_trait_ref(impl_def_id).unwrap();\n \n@@ -2872,7 +2873,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  recursion_depth: usize,\n                                  def_id: DefId, // of impl or trait\n                                  substs: &Substs<'tcx>, // for impl or trait\n-                                 skol_map: infer::SkolemizationMap,\n+                                 skol_map: infer::SkolemizationMap<'tcx>,\n                                  snapshot: &infer::CombinedSnapshot)\n                                  -> Vec<PredicateObligation<'tcx>>\n     {"}, {"sha": "b1846e03941489cafc665f586ccb687d39a458d9", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -52,7 +52,8 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n         self.relate(a, b)\n     }\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region> {\n         debug!(\"{}.regions({:?}, {:?})\",\n                self.tag(),\n                a,"}, {"sha": "e4e69c395a6fb1b9fbc35dc44bcbc705c1702c83", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -213,7 +213,7 @@ pub struct Tables<'tcx> {\n     pub method_map: ty::MethodMap<'tcx>,\n \n     /// Borrows\n-    pub upvar_capture_map: ty::UpvarCaptureMap,\n+    pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n     /// Records the type of each closure. The def ID is the ID of the\n     /// expression defining the closure.\n@@ -1157,7 +1157,12 @@ impl_interners!('tcx,\n     bare_fn: mk_bare_fn(BareFnTy<'tcx>, |fty: &BareFnTy| {\n         keep_local(&fty.sig)\n     }) -> BareFnTy<'tcx>,\n-    region: mk_region(Region, keep_local) -> Region\n+    region: mk_region(Region, |r| {\n+        match r {\n+            &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n+            _ => false\n+        }\n+    }) -> Region\n );\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "3d60d326b2b0f640f477f4436a60a6b50cf18ea0", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -41,11 +41,11 @@ pub enum TypeError<'tcx> {\n     FixedArraySize(ExpectedFound<usize>),\n     TyParamSize(ExpectedFound<usize>),\n     ArgCount,\n-    RegionsDoesNotOutlive(Region, Region),\n-    RegionsNotSame(Region, Region),\n-    RegionsNoOverlap(Region, Region),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, Region),\n-    RegionsOverlyPolymorphic(BoundRegion, Region),\n+    RegionsDoesNotOutlive(&'tcx Region, &'tcx Region),\n+    RegionsNotSame(&'tcx Region, &'tcx Region),\n+    RegionsNoOverlap(&'tcx Region, &'tcx Region),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, &'tcx Region),\n+    RegionsOverlyPolymorphic(BoundRegion, &'tcx Region),\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntegerAsChar,\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n-            RegionsOverlyPolymorphic(_, ty::ReVar(_)) => {\n+            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }"}, {"sha": "20235cf6d79d6f4a94013ff9a27b0e9f9ca8eff8", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -137,7 +137,7 @@ impl FlagComputation {\n             }\n \n             &ty::TyRef(r, ref m) => {\n-                self.add_region(*r);\n+                self.add_region(r);\n                 self.add_ty(m.ty);\n             }\n \n@@ -176,8 +176,8 @@ impl FlagComputation {\n         self.add_bound_computation(&computation);\n     }\n \n-    fn add_region(&mut self, r: ty::Region) {\n-        match r {\n+    fn add_region(&mut self, r: &ty::Region) {\n+        match *r {\n             ty::ReVar(..) => {\n                 self.add_flags(TypeFlags::HAS_RE_INFER);\n                 self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);"}, {"sha": "2c18d1d52547f2acd0e0fb10ce6330c51c7f320f", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 42, "deletions": 36, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -169,7 +169,7 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         fty.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         r.super_fold_with(self)\n     }\n \n@@ -188,7 +188,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.super_visit_with(self)\n     }\n }\n@@ -222,13 +222,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n         value: &T,\n-        region_set: &mut FnvHashSet<ty::Region>)\n+        region_set: &mut FnvHashSet<&'tcx ty::Region>)\n         -> bool\n         where T : TypeFoldable<'tcx>\n     {\n         let mut have_bound_regions = false;\n-        self.fold_regions(value, &mut have_bound_regions,\n-                          |r, d| { region_set.insert(r.from_depth(d)); r });\n+        self.fold_regions(value, &mut have_bound_regions, |r, d| {\n+            region_set.insert(self.mk_region(r.from_depth(d)));\n+            r\n+        });\n         have_bound_regions\n     }\n \n@@ -240,7 +242,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         skipped_regions: &mut bool,\n         mut f: F)\n         -> T\n-        where F : FnMut(ty::Region, u32) -> ty::Region,\n+        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n@@ -260,14 +262,14 @@ pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n+    fld_r: &'a mut (FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n     pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n                   fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::Region, u32) -> ty::Region\n+        where F : FnMut(&'tcx ty::Region, u32) -> &'tcx ty::Region\n     {\n         RegionFolder {\n             tcx: tcx,\n@@ -288,8 +290,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n                 debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n                        r, self.current_depth);\n@@ -313,16 +315,16 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     current_depth: u32,\n-    fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n-    map: FnvHashMap<ty::BoundRegion, ty::Region>\n+    fld_r: &'a mut (FnMut(ty::BoundRegion) -> &'tcx ty::Region + 'a),\n+    map: FnvHashMap<ty::BoundRegion, &'tcx ty::Region>\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n-        -> (T, FnvHashMap<ty::BoundRegion, ty::Region>)\n-        where F : FnMut(ty::BoundRegion) -> ty::Region,\n+        -> (T, FnvHashMap<ty::BoundRegion, &'tcx ty::Region>)\n+        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region,\n               T : TypeFoldable<'tcx>,\n     {\n         let mut replacer = RegionReplacer::new(self, &mut f);\n@@ -340,7 +342,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         self.replace_late_bound_regions(value, |br| {\n-            ty::ReFree(ty::FreeRegion{scope: all_outlive_scope, bound_region: br})\n+            self.mk_region(ty::ReFree(ty::FreeRegion {\n+                scope: all_outlive_scope,\n+                bound_region: br\n+            }))\n         }).0\n     }\n \n@@ -353,11 +358,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let bound0_value = bound2_value.skip_binder().skip_binder();\n         let value = self.fold_regions(bound0_value, &mut false,\n                                       |region, current_depth| {\n-            match region {\n+            match *region {\n                 ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n                     // should be true if no escaping regions from bound2_value\n                     assert!(debruijn.depth - current_depth <= 1);\n-                    ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br)\n+                    self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br))\n                 }\n                 _ => {\n                     region\n@@ -411,7 +416,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn erase_late_bound_regions<T>(self, value: &Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.replace_late_bound_regions(value, |_| ty::ReErased).0\n+        self.replace_late_bound_regions(value, |_| self.mk_region(ty::ReErased)).0\n     }\n \n     /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n@@ -428,15 +433,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut counter = 0;\n         Binder(self.replace_late_bound_regions(sig, |_| {\n             counter += 1;\n-            ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter))\n+            self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter)))\n         }).0)\n     }\n }\n \n impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n     fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n               -> RegionReplacer<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::BoundRegion) -> ty::Region\n+        where F : FnMut(ty::BoundRegion) -> &'tcx ty::Region\n     {\n         RegionReplacer {\n             tcx: tcx,\n@@ -465,22 +470,22 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n         t.super_fold_with(self)\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match r {\n+    fn fold_region(&mut self, r:&'tcx  ty::Region) -> &'tcx ty::Region {\n+        match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n-                if let ty::ReLateBound(debruijn1, br) = region {\n+                if let ty::ReLateBound(debruijn1, br) = *region {\n                     // If the callback returns a late-bound region,\n                     // that region should always use depth 1. Then we\n                     // adjust it to the correct depth.\n                     assert_eq!(debruijn1.depth, 1);\n-                    ty::ReLateBound(debruijn, br)\n+                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n                 } else {\n                     region\n                 }\n             }\n-            r => r\n+            _ => r\n         }\n     }\n }\n@@ -528,7 +533,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 u.super_fold_with(self)\n             }\n \n-            fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n                 // because late-bound regions affect subtyping, we can't\n                 // erase the bound/free distinction, but we can replace\n                 // all free regions with 'erased.\n@@ -537,9 +542,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 // type system never \"sees\" those, they get substituted\n                 // away. In trans, they will always be erased to 'erased\n                 // whenever a substitution occurs.\n-                match r {\n+                match *r {\n                     ty::ReLateBound(..) => r,\n-                    _ => ty::ReErased\n+                    _ => self.tcx().mk_region(ty::ReErased)\n                 }\n             }\n         }\n@@ -574,7 +579,7 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            value, amount);\n \n     value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n-        shift_region(region, amount)\n+        tcx.mk_region(shift_region(*region, amount))\n     }))\n }\n \n@@ -616,7 +621,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n         t.region_depth > self.depth\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.escapes_depth(self.depth)\n     }\n }\n@@ -630,17 +635,18 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         t.flags.get().intersects(self.flags)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         if self.flags.intersects(ty::TypeFlags::HAS_LOCAL_NAMES) {\n             // does this represent a region that cannot be named\n             // in a global way? used in fulfillment caching.\n-            match r {\n+            match *r {\n                 ty::ReStatic | ty::ReEmpty | ty::ReErased => {}\n                 _ => return true,\n             }\n         }\n-        if self.flags.intersects(ty::TypeFlags::HAS_RE_INFER) {\n-            match r {\n+        if self.flags.intersects(ty::TypeFlags::HAS_RE_INFER |\n+                                 ty::TypeFlags::KEEP_IN_LOCAL_TCX) {\n+            match *r {\n                 ty::ReVar(_) | ty::ReSkolemized(..) => { return true }\n                 _ => {}\n             }\n@@ -688,8 +694,8 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n-        match r {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        match *r {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n                 self.regions.insert(br);\n             }"}, {"sha": "3079deff1b641cf1881af4c4ddbc441eba4db8d3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -343,7 +343,7 @@ pub struct Method<'tcx> {\n     pub generics: &'tcx Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: &'tcx BareFnTy<'tcx>,\n-    pub explicit_self: ExplicitSelfCategory,\n+    pub explicit_self: ExplicitSelfCategory<'tcx>,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n@@ -355,7 +355,7 @@ impl<'tcx> Method<'tcx> {\n                generics: &'tcx ty::Generics<'tcx>,\n                predicates: GenericPredicates<'tcx>,\n                fty: &'tcx BareFnTy<'tcx>,\n-               explicit_self: ExplicitSelfCategory,\n+               explicit_self: ExplicitSelfCategory<'tcx>,\n                vis: Visibility,\n                defaultness: hir::Defaultness,\n                def_id: DefId,\n@@ -658,28 +658,28 @@ pub enum BorrowKind {\n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n #[derive(PartialEq, Clone, Debug, Copy)]\n-pub enum UpvarCapture {\n+pub enum UpvarCapture<'tcx> {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n     /// depending on inference.\n     ByValue,\n \n     /// Upvar is captured by reference.\n-    ByRef(UpvarBorrow),\n+    ByRef(UpvarBorrow<'tcx>),\n }\n \n #[derive(PartialEq, Clone, Copy)]\n-pub struct UpvarBorrow {\n+pub struct UpvarBorrow<'tcx> {\n     /// The kind of borrow: by-ref upvars have access to shared\n     /// immutable borrows, which are not part of the normal language\n     /// syntax.\n     pub kind: BorrowKind,\n \n     /// Region of the resulting reference.\n-    pub region: ty::Region,\n+    pub region: &'tcx ty::Region,\n }\n \n-pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n+pub type UpvarCaptureMap<'tcx> = FnvHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n@@ -700,7 +700,7 @@ pub enum IntVarValue {\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n #[derive(Copy, Clone)]\n-pub enum ObjectLifetimeDefault {\n+pub enum ObjectLifetimeDefault<'tcx> {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n     Ambiguous,\n@@ -709,7 +709,7 @@ pub enum ObjectLifetimeDefault {\n     BaseDefault,\n \n     /// Use the given region as the default.\n-    Specific(Region),\n+    Specific(&'tcx Region),\n }\n \n #[derive(Clone)]\n@@ -719,18 +719,18 @@ pub struct TypeParameterDef<'tcx> {\n     pub index: u32,\n     pub default_def_id: DefId, // for use in error reporing about defaults\n     pub default: Option<Ty<'tcx>>,\n-    pub object_lifetime_default: ObjectLifetimeDefault,\n+    pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n }\n \n #[derive(Clone)]\n-pub struct RegionParameterDef {\n+pub struct RegionParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub bounds: Vec<ty::Region>,\n+    pub bounds: Vec<&'tcx ty::Region>,\n }\n \n-impl RegionParameterDef {\n+impl<'tcx> RegionParameterDef<'tcx> {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: self.index,\n@@ -750,7 +750,7 @@ pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n     pub parent_types: u32,\n-    pub regions: Vec<RegionParameterDef>,\n+    pub regions: Vec<RegionParameterDef<'tcx>>,\n     pub types: Vec<TypeParameterDef<'tcx>>,\n     pub has_self: bool,\n }\n@@ -812,7 +812,7 @@ pub enum Predicate<'tcx> {\n     Equate(PolyEquatePredicate<'tcx>),\n \n     /// where 'a : 'b\n-    RegionOutlives(PolyRegionOutlivesPredicate),\n+    RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n \n     /// where T : 'a\n     TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n@@ -991,8 +991,9 @@ pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n-pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n+                                                                   &'tcx ty::Region>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>;\n \n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n@@ -1081,7 +1082,7 @@ impl<'tcx> ToPredicate<'tcx> for PolyEquatePredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate {\n+impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(&self) -> Predicate<'tcx> {\n         Predicate::RegionOutlives(self.clone())\n     }\n@@ -1237,7 +1238,7 @@ pub struct ParameterEnvironment<'tcx> {\n     /// indicates it must outlive at least the function body (the user\n     /// may specify stronger requirements). This field indicates the\n     /// region of the callee.\n-    pub implicit_region_bound: ty::Region,\n+    pub implicit_region_bound: &'tcx ty::Region,\n \n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n@@ -2825,7 +2826,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::ParameterEnvironment {\n             free_substs: Substs::empty(self),\n             caller_bounds: Vec::new(),\n-            implicit_region_bound: ty::ReEmpty,\n+            implicit_region_bound: self.mk_region(ty::ReEmpty),\n             free_id_outlive: free_id_outlive\n         }\n     }\n@@ -2841,8 +2842,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n             // map bound 'a => free 'a\n-            ReFree(FreeRegion { scope: free_id_outlive,\n-                                bound_region: def.to_bound_region() })\n+            self.global_tcx().mk_region(ReFree(FreeRegion {\n+                scope: free_id_outlive,\n+                bound_region: def.to_bound_region()\n+            }))\n         }, |def, _| {\n             // map T => T\n             self.global_tcx().mk_param_from_def(def)\n@@ -2892,7 +2895,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let unnormalized_env = ty::ParameterEnvironment {\n             free_substs: free_substs,\n-            implicit_region_bound: ty::ReScope(free_id_outlive),\n+            implicit_region_bound: tcx.mk_region(ty::ReScope(free_id_outlive)),\n             caller_bounds: predicates,\n             free_id_outlive: free_id_outlive,\n         };\n@@ -2901,6 +2904,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n     }\n \n+    pub fn node_scope_region(self, id: NodeId) -> &'tcx Region {\n+        self.mk_region(ty::ReScope(self.region_maps.node_extent(id)))\n+    }\n+\n     pub fn is_method_call(self, expr_id: NodeId) -> bool {\n         self.tables.borrow().method_map.contains_key(&MethodCall::expr(expr_id))\n     }\n@@ -2910,7 +2917,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                                                             autoderefs))\n     }\n \n-    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n+    pub fn upvar_capture(self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n         Some(self.tables.borrow().upvar_capture_map.get(&upvar_id).unwrap().clone())\n     }\n \n@@ -2936,10 +2943,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n /// The category of explicit self.\n #[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum ExplicitSelfCategory {\n+pub enum ExplicitSelfCategory<'tcx> {\n     Static,\n     ByValue,\n-    ByReference(Region, hir::Mutability),\n+    ByReference(&'tcx Region, hir::Mutability),\n     ByBox,\n }\n "}, {"sha": "4d5b38212f600ee43c18bb29500b01c52dfa5853", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -17,7 +17,7 @@ use ty::{self, Ty, TypeFoldable};\n \n #[derive(Debug)]\n pub enum Component<'tcx> {\n-    Region(ty::Region),\n+    Region(&'tcx ty::Region),\n     Param(ty::ParamTy),\n     UnresolvedInferenceVariable(ty::InferTy),\n \n@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region>) {\n+fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<&'tcx ty::Region>) {\n     for r in regions {\n         if !r.is_bound() {\n             out.push(Component::Region(r));"}, {"sha": "8aa390cdd64e2867d6bbbfd2fe229db08a01ba96", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -71,8 +71,8 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n     fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n            -> RelateResult<'tcx, Ty<'tcx>>;\n \n-    fn regions(&mut self, a: ty::Region, b: ty::Region)\n-               -> RelateResult<'tcx, ty::Region>;\n+    fn regions(&mut self, a: &'tcx ty::Region, b: &'tcx ty::Region)\n+               -> RelateResult<'tcx, &'tcx ty::Region>;\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n@@ -471,9 +471,9 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n \n         (&ty::TyRef(a_r, ref a_mt), &ty::TyRef(b_r, ref b_mt)) =>\n         {\n-            let r = relation.relate_with_variance(ty::Contravariant, a_r, b_r)?;\n+            let r = relation.relate_with_variance(ty::Contravariant, &a_r, &b_r)?;\n             let mt = relation.relate(a_mt, b_mt)?;\n-            Ok(tcx.mk_ref(tcx.mk_region(r), mt))\n+            Ok(tcx.mk_ref(r, mt))\n         }\n \n         (&ty::TyArray(a_t, sz_a), &ty::TyArray(b_t, sz_b)) =>\n@@ -569,11 +569,11 @@ impl<'tcx> Relate<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::Region {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::Region {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::Region,\n-                           b: &ty::Region)\n-                           -> RelateResult<'tcx, ty::Region>\n+                           a: &&'tcx ty::Region,\n+                           b: &&'tcx ty::Region)\n+                           -> RelateResult<'tcx, &'tcx ty::Region>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.regions(*a, *b)"}, {"sha": "705cca056f24c0d9bf5d7095e2546325b477f7d1", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -72,13 +72,6 @@ impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     }\n }\n \n-impl<'tcx> Lift<'tcx> for ty::Region {\n-    type Lifted = Self;\n-    fn lift_to_tcx(&self, _: TyCtxt) -> Option<ty::Region> {\n-        Some(*self)\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n@@ -315,13 +308,21 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             FixedArraySize(x) => FixedArraySize(x),\n             TyParamSize(x) => TyParamSize(x),\n             ArgCount => ArgCount,\n-            RegionsDoesNotOutlive(a, b) => RegionsDoesNotOutlive(a, b),\n-            RegionsNotSame(a, b) => RegionsNotSame(a, b),\n-            RegionsNoOverlap(a, b) => RegionsNoOverlap(a, b),\n+            RegionsDoesNotOutlive(a, b) => {\n+                return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n+            }\n+            RegionsNotSame(a, b) => {\n+                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNotSame(a, b))\n+            }\n+            RegionsNoOverlap(a, b) => {\n+                return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n+            }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n-                RegionsInsufficientlyPolymorphic(a, b)\n+                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n+            }\n+            RegionsOverlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b))\n             }\n-            RegionsOverlyPolymorphic(a, b) => RegionsOverlyPolymorphic(a, b),\n             IntegerAsChar => IntegerAsChar,\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -654,7 +655,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ImplHeader<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n         *self\n     }\n@@ -672,25 +673,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Region {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let region = folder.fold_region(**self);\n-        folder.tcx().mk_region(region)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n-\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        visitor.visit_region(**self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::ClosureSubsts {\n@@ -766,7 +748,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n+impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             ty::ObjectLifetimeDefault::Ambiguous =>\n@@ -788,7 +770,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ObjectLifetimeDefault {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef {\n+impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::RegionParameterDef {\n             name: self.name,"}, {"sha": "5e0f3bc5e26f7b631817831e7af91d94c018a661", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -294,7 +294,7 @@ impl<'tcx> Decodable for ClosureSubsts<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct TraitObject<'tcx> {\n     pub principal: PolyExistentialTraitRef<'tcx>,\n-    pub region_bound: ty::Region,\n+    pub region_bound: &'tcx ty::Region,\n     pub builtin_bounds: BuiltinBounds,\n     pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n }\n@@ -676,6 +676,15 @@ pub enum Region {\n     ReErased,\n }\n \n+impl<'tcx> Decodable for &'tcx Region {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<&'tcx Region, D::Error> {\n+        let r = Decodable::decode(d)?;\n+        cstore::tls::with_decoding_context(d, |dcx, _| {\n+            Ok(dcx.tcx().mk_region(r))\n+        })\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n     pub index: u32,\n@@ -1207,10 +1216,10 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     /// Returns the regions directly referenced from this type (but\n     /// not types reachable from this type via `walk_tys`). This\n     /// ignores late-bound regions binders.\n-    pub fn regions(&self) -> Vec<ty::Region> {\n+    pub fn regions(&self) -> Vec<&'tcx ty::Region> {\n         match self.sty {\n             TyRef(region, _) => {\n-                vec![*region]\n+                vec![region]\n             }\n             TyTrait(ref obj) => {\n                 let mut v = vec![obj.region_bound];"}, {"sha": "b20c17c8a6677321826b6eb595344e5e5d4481a5", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                             mut mk_region: FR,\n                             mut mk_type: FT)\n                             -> &'tcx Substs<'tcx>\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n         let defs = tcx.lookup_generics(def_id);\n         let num_regions = defs.parent_regions as usize + defs.regions.len();\n@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n                          defs: &ty::Generics<'tcx>,\n                          mk_region: &mut FR,\n                          mk_type: &mut FT)\n-    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> ty::Region,\n+    where FR: FnMut(&ty::RegionParameterDef, &Substs<'tcx>) -> &'tcx ty::Region,\n           FT: FnMut(&ty::TypeParameterDef<'tcx>, &Substs<'tcx>) -> Ty<'tcx> {\n         if let Some(def_id) = defs.parent {\n             let parent_defs = tcx.lookup_generics(def_id);\n@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_at(&self, i: usize) -> ty::Region {\n+    pub fn region_at(&self, i: usize) -> &'tcx ty::Region {\n         self.regions[i]\n     }\n \n@@ -132,7 +132,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     #[inline]\n-    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> ty::Region {\n+    pub fn region_for_def(&self, def: &ty::RegionParameterDef) -> &'tcx ty::Region {\n         self.region_at(def.index as usize)\n     }\n \n@@ -255,13 +255,13 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n         // regions that appear in a function signature is done using\n         // the specialized routine `ty::replace_late_regions()`.\n-        match r {\n+        match *r {\n             ty::ReEarlyBound(data) => {\n                 match self.substs.regions.get(data.index as usize) {\n                     Some(&r) => {\n@@ -394,8 +394,8 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n         result\n     }\n \n-    fn shift_region_through_binders(&self, region: ty::Region) -> ty::Region {\n-        ty::fold::shift_region(region, self.region_binders_passed)\n+    fn shift_region_through_binders(&self, region: &'tcx ty::Region) -> &'tcx ty::Region {\n+        self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n     }\n }\n "}, {"sha": "96f432587b10e4fea414db38efed4a3f017daef6", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn required_region_bounds(self,\n                                   erased_self_ty: Ty<'tcx>,\n                                   predicates: Vec<ty::Predicate<'tcx>>)\n-                                  -> Vec<ty::Region>    {\n+                                  -> Vec<&'tcx ty::Region>    {\n         debug!(\"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n                erased_self_ty,\n                predicates);\n@@ -496,8 +496,8 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n         ty.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n-        match r {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        match *r {\n             ty::ReStatic | ty::ReErased => {\n                 self.hash::<u32>(0);\n             }"}, {"sha": "1f166cb192fa33c0c686066909f8dea6026315d8", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -115,9 +115,9 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n #[derive(Debug)]\n pub enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region, ty::Region),\n-    RegionSubParam(ty::Region, ty::ParamTy),\n-    RegionSubProjection(ty::Region, ty::ProjectionTy<'tcx>),\n+    RegionSubRegion(&'tcx ty::Region, &'tcx ty::Region),\n+    RegionSubParam(&'tcx ty::Region, ty::ParamTy),\n+    RegionSubProjection(&'tcx ty::Region, ty::ProjectionTy<'tcx>),\n }\n \n /// Compute the implied bounds that a callee/impl can assume based on\n@@ -196,7 +196,7 @@ pub fn implied_bounds<'a, 'gcx, 'tcx>(\n /// this down to determine what relationships would have to hold for\n /// `T: 'a` to hold. We get to assume that the caller has validated\n /// those relationships.\n-fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n+fn implied_bounds_from_components<'tcx>(sub_region: &'tcx ty::Region,\n                                         sup_components: Vec<Component<'tcx>>)\n                                         -> Vec<ImpliedBound<'tcx>>\n {\n@@ -363,7 +363,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                                 cause,\n                                 ty::Predicate::TypeOutlives(\n                                     ty::Binder(\n-                                        ty::OutlivesPredicate(mt.ty, *r)))));\n+                                        ty::OutlivesPredicate(mt.ty, r)))));\n                     }\n                 }\n \n@@ -534,7 +534,7 @@ pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     principal: ty::PolyExistentialTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n-    -> Vec<ty::Region>\n+    -> Vec<&'tcx ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically"}, {"sha": "4b6234e8815efe5d5864c905f586ffa7ae4473ae", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -247,7 +247,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n \n     let new_value = tcx.replace_late_bound_regions(&value, |br| {\n         let _ = start_or_continue(f, \"for<\", \", \");\n-        ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n+        let br = match br {\n             ty::BrNamed(_, name, _) => {\n                 let _ = write!(f, \"{}\", name);\n                 br\n@@ -261,7 +261,8 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n                             name,\n                             ty::Issue32330::WontChange)\n             }\n-        })\n+        };\n+        tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n     }).0;\n \n     start_or_continue(f, \"\", \"> \")?;\n@@ -351,7 +352,7 @@ impl<'tcx> fmt::Debug for ty::TypeParameterDef<'tcx> {\n     }\n }\n \n-impl fmt::Debug for ty::RegionParameterDef {\n+impl<'tcx> fmt::Debug for ty::RegionParameterDef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"RegionParameterDef({}, {:?}, {}, {:?})\",\n                self.name,\n@@ -598,7 +599,7 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault {\n+impl<'tcx> fmt::Debug for ty::ObjectLifetimeDefault<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ObjectLifetimeDefault::Ambiguous => write!(f, \"Ambiguous\"),\n@@ -793,13 +794,14 @@ impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, &'tcx ty::Region>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n }\n \n-impl fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region, ty::Region>> {\n+impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<&'tcx ty::Region,\n+                                                             &'tcx ty::Region>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n     }\n@@ -973,7 +975,7 @@ impl fmt::Debug for ty::UpvarId {\n     }\n }\n \n-impl fmt::Debug for ty::UpvarBorrow {\n+impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"UpvarBorrow({:?}, {:?})\",\n                self.kind, self.region)\n@@ -997,7 +999,7 @@ impl fmt::Display for ty::InferTy {\n     }\n }\n \n-impl fmt::Display for ty::ExplicitSelfCategory {\n+impl<'tcx> fmt::Display for ty::ExplicitSelfCategory<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             ty::ExplicitSelfCategory::Static => \"static\","}, {"sha": "e86fa9a05f372c4eb1e2503a5a996a6855ac74c8", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: ty::Region,\n+              loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {"}, {"sha": "9f95175d59d439217bdc5b9e3642b38e2640943b", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -28,7 +28,7 @@ pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n-                                    loan_region: ty::Region,\n+                                    loan_region: &'tcx ty::Region,\n                                     _: ty::BorrowKind)\n                                     -> Result<(),()> {\n     //! Reports error if `loan_region` is larger than S\n@@ -56,7 +56,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n \n     span: Span,\n     cause: euv::LoanCause,\n-    loan_region: ty::Region,\n+    loan_region: &'tcx ty::Region,\n     cmt_original: mc::cmt<'tcx>\n }\n \n@@ -92,7 +92,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn check_scope(&self, max_scope: ty::Region) -> R {\n+    fn check_scope(&self, max_scope: &'tcx ty::Region) -> R {\n         //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n@@ -102,7 +102,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn scope(&self, cmt: &mc::cmt) -> ty::Region {\n+    fn scope(&self, cmt: &mc::cmt<'tcx>) -> &'tcx ty::Region {\n         //! Returns the maximal region scope for the which the\n         //! lvalue `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n@@ -112,16 +112,15 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n                 temp_scope\n             }\n             Categorization::Upvar(..) => {\n-                ty::ReScope(self.item_scope)\n-            }\n-            Categorization::StaticItem => {\n-                ty::ReStatic\n+                self.bccx.tcx.mk_region(ty::ReScope(self.item_scope))\n             }\n             Categorization::Local(local_id) => {\n-                ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n+                self.bccx.tcx.mk_region(ty::ReScope(\n+                    self.bccx.tcx.region_maps.var_scope(local_id)))\n             }\n+            Categorization::StaticItem |\n             Categorization::Deref(_, _, mc::UnsafePtr(..)) => {\n-                ty::ReStatic\n+                self.bccx.tcx.mk_region(ty::ReStatic)\n             }\n             Categorization::Deref(_, _, mc::BorrowedPtr(_, r)) |\n             Categorization::Deref(_, _, mc::Implicit(_, r)) => {\n@@ -135,7 +134,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn report_error(&self, code: bckerr_code) {\n+    fn report_error(&self, code: bckerr_code<'tcx>) {\n         self.bccx.report(BckError { cmt: self.cmt_original.clone(),\n                                     span: self.span,\n                                     cause: BorrowViolation(self.cause),"}, {"sha": "a255564f01e255397f0c8a538e28df1c3d906096", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n               borrow_id: ast::NodeId,\n               borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              loan_region: ty::Region,\n+              loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause)\n     {\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                        borrow_span: Span,\n                        cmt: mc::cmt<'tcx>,\n                        req_kind: ty::BorrowKind,\n-                       loan_region: ty::Region,\n+                       loan_region: &'tcx ty::Region,\n                        cause: euv::LoanCause) {\n         debug!(\"guarantee_valid(borrow_id={}, cmt={:?}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n         // a loan for the empty region can never be dereferenced, so\n         // it is always safe\n-        if loan_region == ty::ReEmpty {\n+        if *loan_region == ty::ReEmpty {\n             return;\n         }\n \n@@ -358,7 +358,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             }\n \n             RestrictionResult::SafeIf(loan_path, restricted_paths) => {\n-                let loan_scope = match loan_region {\n+                let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n                     ty::ReFree(ref fr) => fr.scope,"}, {"sha": "d08f792b30c144251e1d3938db237025bc101d9c", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -31,7 +31,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       cause: euv::LoanCause,\n                                       cmt: mc::cmt<'tcx>,\n-                                      loan_region: ty::Region)\n+                                      loan_region: &'tcx ty::Region)\n                                       -> RestrictionResult<'tcx> {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n@@ -49,7 +49,7 @@ pub fn compute_restrictions<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n struct RestrictionsContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n     span: Span,\n-    loan_region: ty::Region,\n+    loan_region: &'tcx ty::Region,\n     cause: euv::LoanCause,\n }\n \n@@ -157,7 +157,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n     fn extend(&self,\n               result: RestrictionResult<'tcx>,\n               cmt: &mc::cmt<'tcx>,\n-              elem: LoanPathElem) -> RestrictionResult<'tcx> {\n+              elem: LoanPathElem<'tcx>) -> RestrictionResult<'tcx> {\n         match result {\n             RestrictionResult::Safe => RestrictionResult::Safe,\n             RestrictionResult::SafeIf(base_lp, mut base_vec) => {"}, {"sha": "5826064c267a0e48b5d4c139ed6ad89792ddfcb3", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -365,7 +365,7 @@ pub enum LoanPathKind<'tcx> {\n     LpVar(ast::NodeId),                         // `x` in README.md\n     LpUpvar(ty::UpvarId),                       // `x` captured by-value into closure\n     LpDowncast(Rc<LoanPath<'tcx>>, DefId), // `x` downcast to particular enum variant\n-    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem)\n+    LpExtend(Rc<LoanPath<'tcx>>, mc::MutabilityCategory, LoanPathElem<'tcx>)\n }\n \n impl<'tcx> LoanPath<'tcx> {\n@@ -410,8 +410,8 @@ impl ToInteriorKind for mc::InteriorKind {\n // `enum E { X { foo: u32 }, Y { foo: u32 }}`\n // each `foo` is qualified by the definitition id of the variant (`X` or `Y`).\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub enum LoanPathElem {\n-    LpDeref(mc::PointerKind),\n+pub enum LoanPathElem<'tcx> {\n+    LpDeref(mc::PointerKind<'tcx>),\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n@@ -564,10 +564,11 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n \n // Errors that can occur\n #[derive(PartialEq)]\n-pub enum bckerr_code {\n+pub enum bckerr_code<'tcx> {\n     err_mutbl,\n-    err_out_of_scope(ty::Region, ty::Region, euv::LoanCause), // superscope, subscope, loan cause\n-    err_borrowed_pointer_too_short(ty::Region, ty::Region), // loan, ptr\n+    /// superscope, subscope, loan cause\n+    err_out_of_scope(&'tcx ty::Region, &'tcx ty::Region, euv::LoanCause),\n+    err_borrowed_pointer_too_short(&'tcx ty::Region, &'tcx ty::Region), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -577,7 +578,7 @@ pub struct BckError<'tcx> {\n     span: Span,\n     cause: AliasableViolationKind,\n     cmt: mc::cmt<'tcx>,\n-    code: bckerr_code\n+    code: bckerr_code<'tcx>\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -605,7 +606,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.free_region_map = old_free_region_map;\n     }\n \n-    pub fn is_subregion_of(&self, r_sub: ty::Region, r_sup: ty::Region)\n+    pub fn is_subregion_of(&self, r_sub: &'tcx ty::Region, r_sup: &'tcx ty::Region)\n                            -> bool\n     {\n         self.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n@@ -614,9 +615,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic, _),\n+            (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n              &BorrowViolation(euv::ClosureCapture(span))) |\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..), _),\n+            (&err_out_of_scope(&ty::ReScope(_), &ty::ReFree(..), _),\n              &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);\n             }\n@@ -965,8 +966,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             .emit();\n     }\n \n-    fn region_end_span(&self, region: ty::Region) -> Option<Span> {\n-        match region {\n+    fn region_end_span(&self, region: &'tcx ty::Region) -> Option<Span> {\n+        match *region {\n             ty::ReScope(scope) => {\n                 match scope.span(&self.tcx.region_maps, &self.tcx.map) {\n                     Some(s) => {\n@@ -1194,8 +1195,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-fn statement_scope_span(tcx: TyCtxt, region: ty::Region) -> Option<Span> {\n-    match region {\n+fn statement_scope_span(tcx: TyCtxt, region: &ty::Region) -> Option<Span> {\n+    match *region {\n         ty::ReScope(scope) => {\n             match tcx.map.find(scope.node_id(&tcx.region_maps)) {\n                 Some(hir_map::NodeStmt(stmt)) => Some(stmt.span),"}, {"sha": "82c142c919e3471c0a58eda9a53d7e1a049f66e3", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -1172,7 +1172,7 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n               _: NodeId,\n               span: Span,\n               _: cmt,\n-              _: Region,\n+              _: &'tcx Region,\n               kind: BorrowKind,\n               _: LoanCause) {\n         match kind {"}, {"sha": "a99262d30eee315ea2d33fe69e8ebf7efb955edf", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -283,50 +283,51 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn re_early_bound(&self,\n                           index: u32,\n                           name: &'static str)\n-                          -> ty::Region {\n+                          -> &'tcx ty::Region {\n         let name = token::intern(name);\n-        ty::ReEarlyBound(ty::EarlyBoundRegion {\n+        self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,\n-        })\n+        }))\n     }\n \n-    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex) -> ty::Region {\n-        ty::ReLateBound(debruijn, ty::BrAnon(id))\n+    pub fn re_late_bound_with_debruijn(&self, id: u32, debruijn: ty::DebruijnIndex)\n+                                       -> &'tcx ty::Region {\n+        self.infcx.tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(id)))\n     }\n \n-    pub fn t_rptr(&self, r: ty::Region) -> Ty<'tcx> {\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+    pub fn t_rptr(&self, r: &'tcx ty::Region) -> Ty<'tcx> {\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound(&self, id: u32) -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1));\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_late_bound_with_debruijn(&self,\n                                            id: u32,\n                                            debruijn: ty::DebruijnIndex)\n                                            -> Ty<'tcx> {\n         let r = self.re_late_bound_with_debruijn(id, debruijn);\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> Ty<'tcx> {\n         let r = ty::ReScope(self.tcx().region_maps.node_extent(id));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region {\n-        ty::ReFree(ty::FreeRegion {\n+    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> &'tcx ty::Region {\n+        self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n             scope: self.tcx().region_maps.item_extent(nid),\n             bound_region: ty::BrAnon(id),\n-        })\n+        }))\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: u32) -> Ty<'tcx> {\n         let r = self.re_free(nid, id);\n-        self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n+        self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n     pub fn t_rptr_static(&self) -> Ty<'tcx> {"}, {"sha": "0236f9c413ddc26e47662090196bda23a3ef9c57", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -517,7 +517,7 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n // Encoding and decoding the side tables\n \n trait rbml_writer_helpers<'tcx> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n     fn emit_substs<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>,\n                        substs: &Substs<'tcx>);\n@@ -531,7 +531,7 @@ trait rbml_writer_helpers<'tcx> {\n }\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n-    fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n+    fn emit_region(&mut self, ecx: &e::EncodeContext, r: &'tcx ty::Region) {\n         self.emit_opaque(|this| Ok(tyencode::enc_region(&mut this.cursor,\n                                                         &ecx.ty_str_ctxt(),\n                                                         r)));\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                 &adjustment::AutoPtr(r, m) => {\n                     this.emit_enum_variant(\"AutoPtr\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0,\n-                            |this| Ok(this.emit_region(ecx, *r)));\n+                            |this| Ok(this.emit_region(ecx, r)));\n                         this.emit_enum_variant_arg(1, |this| m.encode(this))\n                     })\n                 }\n@@ -824,7 +824,7 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                      f: F) -> R\n         where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x, 'tcx>) -> R;\n \n-    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region;\n+    fn read_region<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> &'tcx ty::Region;\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -835,8 +835,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                               -> ty::Predicate<'tcx>;\n     fn read_substs<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                            -> &'tcx Substs<'tcx>;\n-    fn read_upvar_capture(&mut self, dcx: &DecodeContext)\n-                          -> ty::UpvarCapture;\n+    fn read_upvar_capture<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                  -> ty::UpvarCapture<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> adjustment::AutoAdjustment<'tcx>;\n     fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             str\n         }\n     }\n-    fn read_region(&mut self, dcx: &DecodeContext) -> ty::Region {\n+    fn read_region<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> &'tcx ty::Region {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -948,7 +948,8 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                .parse_substs())\n         }).unwrap()\n     }\n-    fn read_upvar_capture(&mut self, dcx: &DecodeContext) -> ty::UpvarCapture {\n+    fn read_upvar_capture<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                  -> ty::UpvarCapture<'tcx> {\n         self.read_enum(\"UpvarCapture\", |this| {\n             let variants = [\"ByValue\", \"ByRef\"];\n             this.read_enum_variant(&variants, |this, i| {\n@@ -1032,7 +1033,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n             this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n-                        let r: ty::Region =\n+                        let r: &'tcx ty::Region =\n                             this.read_enum_variant_arg(0, |this| {\n                                 Ok(this.read_region(dcx))\n                             }).unwrap();\n@@ -1041,7 +1042,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                                 Decodable::decode(this)\n                             }).unwrap();\n \n-                        adjustment::AutoPtr(dcx.tcx.mk_region(r), m)\n+                        adjustment::AutoPtr(r, m)\n                     }\n                     1 => {\n                         let m: hir::Mutability ="}, {"sha": "d5c3a4a6bb0dc2d30713cc533ae52fdaaabfb571", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -291,13 +291,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_foreign_item(&cdata, did.index)\n     }\n \n-    fn is_static_method(&self, def: DefId) -> bool\n-    {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        let cdata = self.get_crate_data(def.krate);\n-        decoder::is_static_method(&cdata, def.index)\n-    }\n-\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n     {\n         self.do_is_statically_included_foreign_item(id)"}, {"sha": "ccd8bb70f652d9d199350d20a74447876d88579b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -859,7 +859,8 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n     }\n }\n \n-fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n+fn get_explicit_self<'a, 'tcx>(item: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                               -> ty::ExplicitSelfCategory<'tcx> {\n     fn get_mutability(ch: u8) -> hir::Mutability {\n         match ch as char {\n             'i' => hir::MutImmutable,\n@@ -879,7 +880,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n         // FIXME(#4846) expl. region\n         '&' => {\n             ty::ExplicitSelfCategory::ByReference(\n-                ty::ReEmpty,\n+                tcx.mk_region(ty::ReEmpty),\n                 get_mutability(string.as_bytes()[1]))\n         }\n         _ => bug!(\"unknown self type code: `{}`\", explicit_self_kind as char)\n@@ -905,16 +906,6 @@ pub fn get_trait_name(cdata: Cmd, id: DefIndex) -> ast::Name {\n     item_name(doc)\n }\n \n-pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n-    let doc = cdata.lookup_item(id);\n-    match item_sort(doc) {\n-        Some('r') | Some('p') => {\n-            get_explicit_self(doc) == ty::ExplicitSelfCategory::Static\n-        }\n-        _ => false\n-    }\n-}\n-\n pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n@@ -959,7 +950,7 @@ pub fn get_impl_or_trait_item<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a\n                     \"the type {:?} of the method {:?} is not a function?\",\n                     ity, name)\n             };\n-            let explicit_self = get_explicit_self(item_doc);\n+            let explicit_self = get_explicit_self(item_doc, tcx);\n \n             ty::MethodTraitItem(Rc::new(ty::Method::new(name,\n                                                         generics,"}, {"sha": "3b022448efa5de8fea053823a52fadc0ac46ef7c", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -207,8 +207,8 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_region(&mut self) -> ty::Region {\n-        match self.next() {\n+    pub fn parse_region(&mut self) -> &'tcx ty::Region {\n+        self.tcx.mk_region(match self.next() {\n             'b' => {\n                 assert_eq!(self.next(), '[');\n                 let id = ty::DebruijnIndex::new(self.parse_u32());\n@@ -245,7 +245,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             'e' => ty::ReEmpty,\n             'E' => ty::ReErased,\n             _ => bug!(\"parse_region: bad input\")\n-        }\n+        })\n     }\n \n     fn parse_scope(&mut self) -> region::CodeExtent {\n@@ -403,9 +403,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n             '~' => return tcx.mk_box(self.parse_ty()),\n             '*' => return tcx.mk_ptr(self.parse_mt()),\n             '&' => {\n-                let r = self.parse_region();\n-                let mt = self.parse_mt();\n-                return tcx.mk_ref(tcx.mk_region(r), mt);\n+                return tcx.mk_ref(self.parse_region(), self.parse_mt());\n             }\n             'V' => {\n                 let t = self.parse_ty();\n@@ -657,7 +655,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef {\n+    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef<'tcx> {\n         let name = self.parse_name(':');\n         let def_id = self.parse_def();\n         let index = self.parse_u32();\n@@ -681,7 +679,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n \n-    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault {\n+    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault<'tcx> {\n         match self.next() {\n             'a' => ty::ObjectLifetimeDefault::Ambiguous,\n             'b' => ty::ObjectLifetimeDefault::BaseDefault,"}, {"sha": "f502ec45543289280db96e85a6bfe488dda67630", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -133,7 +133,7 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n         ty::TyRawPtr(mt) => { write!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::TyRef(r, mt) => {\n             write!(w, \"&\");\n-            enc_region(w, cx, *r);\n+            enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n         ty::TyArray(t, sz) => {\n@@ -286,8 +286,8 @@ pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     }\n }\n \n-pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n-    match r {\n+pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: &ty::Region) {\n+    match *r {\n         ty::ReLateBound(id, br) => {\n             write!(w, \"b[{}|\", id.depth);\n             enc_bound_region(w, cx, br);"}, {"sha": "1b64b4d0b5317861712ebae924b4fec20e60fa32", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -278,7 +278,7 @@ struct Binding<'tcx> {\n     var_id: NodeId,\n     var_ty: Ty<'tcx>,\n     mutability: Mutability,\n-    binding_mode: BindingMode,\n+    binding_mode: BindingMode<'tcx>,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "6e8a5771eea949a1ad4ea2af600e8548120d0b07", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 region, ty::TypeAndMut { ty: expr.ty, mutbl: mutbl }),\n                             span: expr.span,\n                             kind: ExprKind::Borrow {\n-                                region: *region,\n+                                region: region,\n                                 borrow_kind: to_borrow_kind(mutbl),\n                                 arg: expr.to_ref()\n                             }\n@@ -137,7 +137,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 ty: adjusted_ty,\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n-                                    region: *r,\n+                                    region: r,\n                                     borrow_kind: to_borrow_kind(m),\n                                     arg: expr.to_ref(),\n                                 },\n@@ -154,7 +154,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n                                 span: self.span,\n                                 kind: ExprKind::Borrow {\n-                                    region: *region,\n+                                    region: region,\n                                     borrow_kind: to_borrow_kind(m),\n                                     arg: expr.to_ref(),\n                                 },\n@@ -310,7 +310,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 _ => span_bug!(expr.span, \"type of & not region\"),\n             };\n             ExprKind::Borrow {\n-                region: *region,\n+                region: region,\n                 borrow_kind: to_borrow_kind(mutbl),\n                 arg: expr.to_ref(),\n             }\n@@ -842,8 +842,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     ExprKind::Deref {\n                         arg: Expr {\n                             temp_lifetime: temp_lifetime,\n-                            ty: cx.tcx.mk_ref(\n-                                cx.tcx.mk_region(borrow.region),\n+                            ty: cx.tcx.mk_ref(borrow.region,\n                                 ty::TypeAndMut {\n                                     ty: var_ty,\n                                     mutbl: borrow.kind.to_mutbl_lossy()\n@@ -907,8 +906,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         PassArgs::ByRef => {\n-            let scope = cx.tcx.region_maps.node_extent(expr.id);\n-            let region = cx.tcx.mk_region(ty::ReScope(scope));\n+            let region = cx.tcx.node_scope_region(expr.id);\n             let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n             argrefs.extend(\n                 args.iter()\n@@ -922,7 +920,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             temp_lifetime: temp_lifetime,\n                             ty: adjusted_ty,\n                             span: expr.span,\n-                            kind: ExprKind::Borrow { region: *region,\n+                            kind: ExprKind::Borrow { region: region,\n                                                      borrow_kind: BorrowKind::Shared,\n                                                      arg: arg.to_ref() }\n                         }.to_ref()"}, {"sha": "0bd22cd2d9308c4a35b9cee16b9d88b2b10d9ee0", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -161,7 +161,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 let id = self.cx.tcx.expect_def(pat.id).var_id();\n                 let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n-                    ty::TyRef(&r, _) => Some(r),\n+                    ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n                 let (mutability, mode) = match bm {"}, {"sha": "353f2433353028198f42c9a137600218f0368dac", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -193,7 +193,7 @@ pub enum ExprKind<'tcx> {\n         id: DefId,\n     },\n     Borrow {\n-        region: Region,\n+        region: &'tcx Region,\n         borrow_kind: BorrowKind,\n         arg: ExprRef<'tcx>,\n     },\n@@ -284,7 +284,7 @@ pub enum PatternKind<'tcx> {\n     Binding {\n         mutability: Mutability,\n         name: ast::Name,\n-        mode: BindingMode,\n+        mode: BindingMode<'tcx>,\n         var: ast::NodeId,\n         ty: Ty<'tcx>,\n         subpattern: Option<Pattern<'tcx>>,\n@@ -332,9 +332,9 @@ pub enum PatternKind<'tcx> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-pub enum BindingMode {\n+pub enum BindingMode<'tcx> {\n     ByValue,\n-    ByRef(Region, BorrowKind),\n+    ByRef(&'tcx Region, BorrowKind),\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "4aae6d690c4df3ccf1bebce7d206b8eff82983cb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -683,7 +683,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for CheckCrateVisitor<'a, 'gcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: ty::Region,\n+              _loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               loan_cause: euv::LoanCause) {\n         // Kind of hacky, but we allow Unsafe coercions in constants."}, {"sha": "c3ef5a72a2944e8b2c2a092e69d8535599679c88", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for RvalueContextDelegate<'a, 'gcx, 'tc\n               _borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               _cmt: mc::cmt,\n-              _loan_region: ty::Region,\n+              _loan_region: &'tcx ty::Region,\n               _bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause) {\n     }"}, {"sha": "b0afc147e6f9d114dc432d44a8f8381279478a17", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -1235,7 +1235,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     // The substitutions we have are on the impl, so we grab\n                     // the method type from the impl to substitute into.\n                     let impl_substs = Substs::for_item(tcx, impl_def_id,\n-                                                       |_, _| ty::ReErased,\n+                                                       |_, _| tcx.mk_region(ty::ReErased),\n                                                        |_, _| tcx.types.err);\n                     let mth = meth::get_impl_method(tcx,\n                                                     callee_substs,"}, {"sha": "71184dd3f814d11fcf300122c6ea9610ea17541a", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -563,7 +563,9 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx(), item_def_id, |_, _| ty::ReErased, |_, _| {\n+        Substs::for_item(self.tcx(), item_def_id,\n+                         |_, _| self.tcx().mk_region(ty::ReErased),\n+                         |_, _| {\n             bug!(\"empty_substs_for_def_id: {:?} has type parameters\", item_def_id)\n         })\n     }"}, {"sha": "483bc99c310fccb86f8983395e2298f3d3cc20ce", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -265,7 +265,7 @@ pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // the method may have some early-bound lifetimes, add\n             // regions for those\n             let method_substs = Substs::for_item(tcx, trait_method_def_id,\n-                                                 |_, _| ty::ReErased,\n+                                                 |_, _| tcx.mk_region(ty::ReErased),\n                                                  |_, _| tcx.types.err);\n \n             // The substitutions we have are on the impl, so we grab"}, {"sha": "79c4a9af8295c1c33afc7dd48095c33cbe1eacf4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -178,8 +178,9 @@ type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjection\n /// This type must not appear anywhere in other converted types.\n const TRAIT_OBJECT_DUMMY_SELF: ty::TypeVariants<'static> = ty::TyInfer(ty::FreshTy(0));\n \n-pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n-                            -> ty::Region {\n+pub fn ast_region_to_region<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            lifetime: &hir::Lifetime)\n+                                            -> &'tcx ty::Region {\n     let r = match tcx.named_region_map.defs.get(&lifetime.id) {\n         None => {\n             // should have been recorded by the `resolve_lifetime` pass\n@@ -238,7 +239,7 @@ pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n            lifetime.id,\n            r);\n \n-    r\n+    tcx.mk_region(r)\n }\n \n fn report_elision_failure(\n@@ -313,14 +314,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     pub fn opt_ast_region_to_region(&self,\n         rscope: &RegionScope,\n         default_span: Span,\n-        opt_lifetime: &Option<hir::Lifetime>) -> ty::Region\n+        opt_lifetime: &Option<hir::Lifetime>) -> &'tcx ty::Region\n     {\n         let r = match *opt_lifetime {\n             Some(ref lifetime) => {\n                 ast_region_to_region(self.tcx(), lifetime)\n             }\n \n-            None => match rscope.anon_regions(default_span, 1) {\n+            None => self.tcx().mk_region(match rscope.anon_regions(default_span, 1) {\n                 Ok(rs) => rs[0],\n                 Err(params) => {\n                     let ampersand_span = Span { hi: default_span.lo, ..default_span};\n@@ -335,7 +336,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     err.emit();\n                     ty::ReStatic\n                 }\n-            }\n+            })\n         };\n \n         debug!(\"opt_ast_region_to_region(opt_lifetime={:?}) yields {:?}\",\n@@ -366,7 +367,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     .emit();\n \n                 return Substs::for_item(tcx, def_id, |_, _| {\n-                    ty::ReStatic\n+                    tcx.mk_region(ty::ReStatic)\n                 }, |_, _| {\n                     tcx.types.err\n                 });\n@@ -431,7 +432,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let expected_num_region_params = decl_generics.regions.len();\n         let supplied_num_region_params = lifetimes.len();\n         let regions = if expected_num_region_params == supplied_num_region_params {\n-            lifetimes.iter().map(|l| ast_region_to_region(tcx, l)).collect()\n+            lifetimes.iter().map(|l| *ast_region_to_region(tcx, l)).collect()\n         } else {\n             let anon_regions =\n                 rscope.anon_regions(span, expected_num_region_params);\n@@ -472,7 +473,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n-            regions[def.index as usize]\n+            tcx.mk_region(regions[def.index as usize])\n         }, |def, substs| {\n             let i = def.index as usize;\n \n@@ -588,7 +589,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n \n         if lifetimes_for_params.iter().map(|e| e.lifetime_count).sum::<usize>() == 1 {\n-            Ok(possible_implied_output_region.unwrap())\n+            Ok(*possible_implied_output_region.unwrap())\n         } else {\n             Err(Some(lifetimes_for_params))\n         }\n@@ -1100,15 +1101,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let region_bound = match region_bound {\n             Some(r) => r,\n             None => {\n-                match rscope.object_lifetime_default(span) {\n+                tcx.mk_region(match rscope.object_lifetime_default(span) {\n                     Some(r) => r,\n                     None => {\n                         span_err!(self.tcx().sess, span, E0228,\n                                   \"the lifetime bound for this object type cannot be deduced \\\n                                    from context; please supply an explicit bound\");\n                         ty::ReStatic\n                     }\n-                }\n+                })\n             }\n         };\n \n@@ -1643,7 +1644,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         rscope,\n                         ty::ObjectLifetimeDefault::Specific(r));\n                 let t = self.ast_ty_to_ty(rscope1, &mt.ty);\n-                tcx.mk_ref(tcx.mk_region(r), ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n+                tcx.mk_ref(r, ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n             }\n             hir::TyNever => {\n                 tcx.types.never\n@@ -1801,7 +1802,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         sig: &hir::MethodSig,\n                         untransformed_self_ty: Ty<'tcx>,\n                         anon_scope: Option<AnonTypeScope>)\n-                        -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n+                        -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>) {\n         self.ty_of_method_or_bare_fn(sig.unsafety,\n                                      sig.abi,\n                                      Some(untransformed_self_ty),\n@@ -1826,7 +1827,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                decl: &hir::FnDecl,\n                                arg_anon_scope: Option<AnonTypeScope>,\n                                ret_anon_scope: Option<AnonTypeScope>)\n-                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n+                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1863,7 +1864,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n         let implied_output_region = match explicit_self_category {\n-            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(region),\n+            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(*region),\n             _ => self.find_implied_output_region(&arg_tys, arg_pats)\n         };\n \n@@ -1890,7 +1891,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                rscope: &RegionScope,\n                                untransformed_self_ty: Ty<'tcx>,\n                                explicit_self: &hir::ExplicitSelf)\n-                               -> (Ty<'tcx>, ty::ExplicitSelfCategory)\n+                               -> (Ty<'tcx>, ty::ExplicitSelfCategory<'tcx>)\n     {\n         return match explicit_self.node {\n             SelfKind::Value(..) => {\n@@ -1902,8 +1903,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                              rscope,\n                                              explicit_self.span,\n                                              lifetime);\n-                (self.tcx().mk_ref(\n-                    self.tcx().mk_region(region),\n+                (self.tcx().mk_ref(region,\n                     ty::TypeAndMut {\n                         ty: untransformed_self_ty,\n                         mutbl: mutability\n@@ -1957,7 +1957,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     ty::ExplicitSelfCategory::ByValue\n                 } else {\n                     match explicit_type.sty {\n-                        ty::TyRef(r, mt) => ty::ExplicitSelfCategory::ByReference(*r, mt.mutbl),\n+                        ty::TyRef(r, mt) => ty::ExplicitSelfCategory::ByReference(r, mt.mutbl),\n                         ty::TyBox(_) => ty::ExplicitSelfCategory::ByBox,\n                         _ => ty::ExplicitSelfCategory::ByValue,\n                     }\n@@ -2070,7 +2070,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         explicit_region_bounds: &[&hir::Lifetime],\n         principal_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n         builtin_bounds: ty::BuiltinBounds)\n-        -> Option<ty::Region> // if None, use the default\n+        -> Option<&'tcx ty::Region> // if None, use the default\n     {\n         let tcx = self.tcx();\n \n@@ -2093,7 +2093,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         if let Err(ErrorReported) =\n                 self.ensure_super_predicates(span, principal_trait_ref.def_id()) {\n-            return Some(ty::ReStatic);\n+            return Some(tcx.mk_region(ty::ReStatic));\n         }\n \n         // No explicit region bound specified. Therefore, examine trait\n@@ -2109,8 +2109,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // If any of the derived region bounds are 'static, that is always\n         // the best choice.\n-        if derived_region_bounds.iter().any(|r| ty::ReStatic == *r) {\n-            return Some(ty::ReStatic);\n+        if derived_region_bounds.iter().any(|&r| ty::ReStatic == *r) {\n+            return Some(tcx.mk_region(ty::ReStatic));\n         }\n \n         // Determine whether there is exactly one unique region in the set\n@@ -2242,7 +2242,7 @@ fn report_lifetime_number_error(tcx: TyCtxt, span: Span, number: usize, expected\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct Bounds<'tcx> {\n-    pub region_bounds: Vec<ty::Region>,\n+    pub region_bounds: Vec<&'tcx ty::Region>,\n     pub builtin_bounds: ty::BuiltinBounds,\n     pub trait_bounds: Vec<ty::PolyTraitRef<'tcx>>,\n     pub projection_bounds: Vec<ty::PolyProjectionPredicate<'tcx>>,\n@@ -2264,7 +2264,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n         for &region_bound in &self.region_bounds {\n             // account for the binder being introduced below; no need to shift `param_ty`\n             // because, at present at least, it can only refer to early-bound regions\n-            let region_bound = ty::fold::shift_region(region_bound, 1);\n+            let region_bound = tcx.mk_region(ty::fold::shift_region(*region_bound, 1));\n             vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).to_predicate());\n         }\n "}, {"sha": "78175c85b19bf3c6533c40039b5ca43b5b46f8e2", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // and T is the expected type.\n                         let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n                         let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                        let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n+                        let region_ty = tcx.mk_ref(region_var, mt);\n \n                         // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n                         // required. However, we use equality, which is stronger. See (*) for\n@@ -220,7 +220,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             let inner_ty = self.next_ty_var();\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                            let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n+                            let rptr_ty = tcx.mk_ref(region, mt);\n                             self.demand_eqtype(pat.span, expected, rptr_ty);\n                             (rptr_ty, inner_ty)\n                         }"}, {"sha": "7126478f2c426744123647dface2b5a94b796f75", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -336,7 +336,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 if r_borrow_var.is_none() { // create var lazilly, at most once\n                     let coercion = Coercion(span);\n                     let r = self.next_region_var(coercion);\n-                    r_borrow_var = Some(self.tcx.mk_region(r)); // [4] above\n+                    r_borrow_var = Some(r); // [4] above\n                 }\n                 r_borrow_var.unwrap()\n             };\n@@ -436,8 +436,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n                 let coercion = Coercion(self.origin.span());\n                 let r_borrow = self.next_region_var(coercion);\n-                let region = self.tcx.mk_region(r_borrow);\n-                (mt_a.ty, Some(AutoPtr(region, mt_b.mutbl)))\n+                (mt_a.ty, Some(AutoPtr(r_borrow, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;"}, {"sha": "cede9d871ff4d6a77b3f9fccc40457c6e57504c8", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -412,7 +412,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n                ty);\n \n         cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                 ty, ty::ReScope(cx.parent_scope));\n+                                 ty, tcx.mk_region(ty::ReScope(cx.parent_scope)));\n \n         return Ok(());\n     }"}, {"sha": "ad48827a1d0397a2547cac9a0a846fb3e4a4a021", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -37,7 +37,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let i_ty = tcx.lookup_item_type(def_id);\n \n     let substs = Substs::for_item(tcx, def_id,\n-                                  |_, _| ty::ReErased,\n+                                  |_, _| tcx.mk_region(ty::ReErased),\n                                   |def, _| tcx.mk_param_from_def(def));\n \n     let fty = tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {"}, {"sha": "9197bdaa030cda93de8dda97b8ee1dab888703ad", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     {\n         let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n             let region = self.next_region_var(infer::Autoref(self.span));\n-            let autoref = AutoPtr(self.tcx.mk_region(region), mutbl);\n+            let autoref = AutoPtr(region, mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n                 target.adjust_for_autoref(self.tcx, Some(autoref))\n             }))"}, {"sha": "e38d6aa7a00d7d1120874ce1b931133da9d88152", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -1242,7 +1242,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 } else {\n                     // In general, during probe we erase regions. See\n                     // `impl_self_ty()` for an explanation.\n-                    ty::ReErased\n+                    self.tcx.mk_region(ty::ReErased)\n                 }\n             }, |def, cur_substs| {\n                 let i = def.index as usize;\n@@ -1264,7 +1264,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         let impl_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n \n         let substs = Substs::for_item(self.tcx, impl_def_id,\n-                                      |_, _| ty::ReErased,\n+                                      |_, _| self.tcx.mk_region(ty::ReErased),\n                                       |_, _| self.next_ty_var());\n \n         (impl_ty, substs)"}, {"sha": "cc7eadefeb0991f821239297abeae4626550589f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -1422,13 +1422,13 @@ impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n         // (and anyway, within a fn body the right region may not even\n         // be something the user can write explicitly, since it might\n         // be some expression).\n-        self.next_region_var(infer::MiscVariable(span))\n+        *self.next_region_var(infer::MiscVariable(span))\n     }\n \n     fn anon_regions(&self, span: Span, count: usize)\n                     -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Ok((0..count).map(|_| {\n-            self.next_region_var(infer::MiscVariable(span))\n+            *self.next_region_var(infer::MiscVariable(span))\n         }).collect())\n     }\n }\n@@ -1862,7 +1862,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n                                       ty: Ty<'tcx>,\n-                                      region: ty::Region,\n+                                      region: &'tcx ty::Region,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n@@ -1893,7 +1893,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n         let cause = traits::ObligationCause::new(span, self.body_id, code);\n-        self.register_region_obligation(ty, ty::ReEmpty, cause);\n+        self.register_region_obligation(ty, self.tcx.mk_region(ty::ReEmpty), cause);\n     }\n \n     /// Registers obligations that all types appearing in `substs` are well-formed.\n@@ -3454,7 +3454,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // value whose address was taken can actually be made to live\n                 // as long as it needs to live.\n                 let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n-                tcx.mk_ref(tcx.mk_region(region), tm)\n+                tcx.mk_ref(region, tm)\n             };\n             self.write_ty(id, oprnd_t);\n           }"}, {"sha": "5f5cda358ff2f01065767ef5be7cc459d04135f6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n+    region_bound_pairs: Vec<(&'tcx ty::Region, GenericKind<'tcx>)>,\n \n     free_region_map: FreeRegionMap,\n \n@@ -324,9 +324,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n                body.id, call_site_scope);\n+        let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n                                        body.id,\n-                                       ty::ReScope(call_site_scope));\n+                                       call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n \n@@ -407,8 +408,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             for implication in implied_bounds {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n-                    ImpliedBound::RegionSubRegion(ty::ReFree(free_a),\n-                                                  ty::ReVar(vid_b)) => {\n+                    ImpliedBound::RegionSubRegion(&ty::ReFree(free_a),\n+                                                  &ty::ReVar(vid_b)) => {\n                         self.add_given(free_a, vid_b);\n                     }\n                     ImpliedBound::RegionSubParam(r_a, param_b) => {\n@@ -476,9 +477,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // variable's type enclose at least the variable's scope.\n \n             let var_scope = tcx.region_maps.var_scope(id);\n+            let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, id, ty::ReScope(var_scope));\n+            self.type_of_node_must_outlive(origin, id, var_region);\n \n             let typ = self.resolve_node_type(id);\n             dropck::check_safety_of_destructor_if_necessary(self, typ, span, var_scope);\n@@ -525,7 +527,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // scope of that expression. This also guarantees basic WF.\n         let expr_ty = self.resolve_node_type(expr.id);\n         // the region corresponding to this expression\n-        let expr_region = ty::ReScope(self.tcx.region_maps.node_extent(expr.id));\n+        let expr_region = self.tcx.node_scope_region(expr.id);\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                                expr_ty, expr_region);\n \n@@ -713,7 +715,7 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     None => self.resolve_node_type(base.id)\n                 };\n                 if let ty::TyRef(r_ptr, _) = base_ty.sty {\n-                    self.mk_subregion_due_to_dereference(expr.span, expr_region, *r_ptr);\n+                    self.mk_subregion_due_to_dereference(expr.span, expr_region, r_ptr);\n                 }\n \n                 intravisit::walk_expr(self, expr);\n@@ -780,9 +782,10 @@ impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 let call_site_scope = self.call_site_scope;\n                 debug!(\"visit_expr ExprRet ret_expr.id {} call_site_scope: {:?}\",\n                        ret_expr.id, call_site_scope);\n+                let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n                                                ret_expr.id,\n-                                               ty::ReScope(call_site_scope.unwrap()));\n+                                               call_site_region);\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -819,7 +822,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                self.sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n+                self.sub_regions(infer::Reborrow(cast_expr.span), to_r, from_r);\n                 self.walk_cast(cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n@@ -889,7 +892,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n         let callee_scope = self.tcx.region_maps.node_extent(call_expr.id);\n-        let callee_region = ty::ReScope(callee_scope);\n+        let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n \n@@ -933,8 +936,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                derefs,\n                derefd_ty);\n \n-        let s_deref_expr = self.tcx.region_maps.node_extent(deref_expr.id);\n-        let r_deref_expr = ty::ReScope(s_deref_expr);\n+        let r_deref_expr = self.tcx.node_scope_region(deref_expr.id);\n         for i in 0..derefs {\n             let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n             debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n@@ -989,7 +991,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n             if let ty::TyRef(r_ptr, _) =  derefd_ty.sty {\n                 self.mk_subregion_due_to_dereference(deref_expr.span,\n-                                                     r_deref_expr, *r_ptr);\n+                                                     r_deref_expr, r_ptr);\n             }\n \n             match derefd_ty.builtin_deref(true, ty::NoPreference) {\n@@ -1003,8 +1005,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn mk_subregion_due_to_dereference(&mut self,\n                                            deref_span: Span,\n-                                           minimum_lifetime: ty::Region,\n-                                           maximum_lifetime: ty::Region) {\n+                                           minimum_lifetime: &'tcx ty::Region,\n+                                           maximum_lifetime: &'tcx ty::Region) {\n         self.sub_regions(infer::DerefPointer(deref_span),\n                          minimum_lifetime, maximum_lifetime)\n     }\n@@ -1014,7 +1016,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                      span: Span) {\n         match cmt.cat {\n             Categorization::Rvalue(region) => {\n-                match region {\n+                match *region {\n                     ty::ReScope(rvalue_scope) => {\n                         let typ = self.resolve_type(cmt.ty);\n                         dropck::check_safety_of_destructor_if_necessary(self,\n@@ -1023,7 +1025,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                                         rvalue_scope);\n                     }\n                     ty::ReStatic => {}\n-                    region => {\n+                    _ => {\n                         span_bug!(span,\n                                   \"unexpected rvalue region in rvalue \\\n                                    destructor safety checking: `{:?}`\",\n@@ -1049,7 +1051,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n                     self.sub_regions(infer::IndexSlice(index_expr.span),\n-                                     r_index_expr, *r_ptr);\n+                                     self.tcx.mk_region(r_index_expr), r_ptr);\n                 }\n                 _ => {}\n             }\n@@ -1061,7 +1063,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n         id: ast::NodeId,\n-        minimum_lifetime: ty::Region)\n+        minimum_lifetime: &'tcx ty::Region)\n     {\n         let tcx = self.tcx;\n \n@@ -1132,7 +1134,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let mc = mc::MemCategorizationContext::new(self);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n-            let re_scope = ty::ReScope(body_scope);\n+            let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n@@ -1168,7 +1170,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_autoref(&self,\n                     expr: &hir::Expr,\n                     autoderefs: usize,\n-                    autoref: &adjustment::AutoRef)\n+                    autoref: &adjustment::AutoRef<'tcx>)\n     {\n         debug!(\"link_autoref(autoref={:?})\", autoref);\n         let mc = mc::MemCategorizationContext::new(self);\n@@ -1182,8 +1184,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             adjustment::AutoUnsafe(m) => {\n-                let r = ty::ReScope(self.tcx.region_maps.node_extent(expr.id));\n-                self.link_region(expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n+                let r = self.tcx.node_scope_region(expr.id);\n+                self.link_region(expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n             }\n         }\n     }\n@@ -1197,8 +1199,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, callee_scope);\n         let mc = mc::MemCategorizationContext::new(self);\n         let expr_cmt = ignore_err!(mc.cat_expr(expr));\n-        let borrow_region = ty::ReScope(callee_scope);\n-        self.link_region(expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n+        let borrow_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n+        self.link_region(expr.span, borrow_region, ty::ImmBorrow, expr_cmt);\n     }\n \n     /// Like `link_region()`, except that the region is extracted from the type of `id`,\n@@ -1212,9 +1214,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                id, mutbl, cmt_borrowed);\n \n         let rptr_ty = self.resolve_node_type(id);\n-        if let ty::TyRef(&r, _) = rptr_ty.sty {\n+        if let ty::TyRef(r, _) = rptr_ty.sty {\n             debug!(\"rptr_ty={}\",  rptr_ty);\n-            self.link_region(span, &r, ty::BorrowKind::from_mutbl(mutbl),\n+            self.link_region(span, r, ty::BorrowKind::from_mutbl(mutbl),\n                              cmt_borrowed);\n         }\n     }\n@@ -1225,14 +1227,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// between regions, as explained in `link_reborrowed_region()`.\n     fn link_region(&self,\n                    span: Span,\n-                   borrow_region: &ty::Region,\n+                   borrow_region: &'tcx ty::Region,\n                    borrow_kind: ty::BorrowKind,\n                    borrow_cmt: mc::cmt<'tcx>) {\n         let mut borrow_cmt = borrow_cmt;\n         let mut borrow_kind = borrow_kind;\n \n         let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n-        self.type_must_outlive(origin, borrow_cmt.ty, *borrow_region);\n+        self.type_must_outlive(origin, borrow_cmt.ty, borrow_region);\n \n         loop {\n             debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n@@ -1322,10 +1324,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// recurse and process `ref_cmt` (see case 2 above).\n     fn link_reborrowed_region(&self,\n                               span: Span,\n-                              borrow_region: &ty::Region,\n+                              borrow_region: &'tcx ty::Region,\n                               borrow_kind: ty::BorrowKind,\n                               ref_cmt: mc::cmt<'tcx>,\n-                              ref_region: ty::Region,\n+                              ref_region: &'tcx ty::Region,\n                               mut ref_kind: ty::BorrowKind,\n                               note: mc::Note)\n                               -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n@@ -1364,7 +1366,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n                borrow_region,\n                ref_region);\n-        self.sub_regions(cause, *borrow_region, ref_region);\n+        self.sub_regions(cause, borrow_region, ref_region);\n \n         // If we end up needing to recurse and establish a region link\n         // with `ref_cmt`, calculate what borrow kind we will end up\n@@ -1436,7 +1438,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                           origin: infer::ParameterOrigin,\n                           substs: &Substs<'tcx>,\n                           expr_span: Span,\n-                          expr_region: ty::Region) {\n+                          expr_region: &'tcx ty::Region) {\n         debug!(\"substs_wf_in_scope(substs={:?}, \\\n                 expr_region={:?}, \\\n                 origin={:?}, \\\n@@ -1461,7 +1463,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn type_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n                              ty: Ty<'tcx>,\n-                             region: ty::Region)\n+                             region: &'tcx ty::Region)\n     {\n         let ty = self.resolve_type(ty);\n \n@@ -1479,7 +1481,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn components_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n                                components: Vec<ty::outlives::Component<'tcx>>,\n-                               region: ty::Region)\n+                               region: &'tcx ty::Region)\n     {\n         for component in components {\n             let origin = origin.clone();\n@@ -1510,7 +1512,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn param_ty_must_outlive(&self,\n                              origin: infer::SubregionOrigin<'tcx>,\n-                             region: ty::Region,\n+                             region: &'tcx ty::Region,\n                              param_ty: ty::ParamTy) {\n         debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n                region, param_ty, origin);\n@@ -1522,7 +1524,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_must_outlive(&self,\n                                origin: infer::SubregionOrigin<'tcx>,\n-                               region: ty::Region,\n+                               region: &'tcx ty::Region,\n                                projection_ty: ty::ProjectionTy<'tcx>)\n     {\n         debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n@@ -1552,7 +1554,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // If we know that the projection outlives 'static, then we're\n         // done here.\n-        if env_bounds.contains(&ty::ReStatic) {\n+        if env_bounds.contains(&&ty::ReStatic) {\n             debug!(\"projection_must_outlive: 'static as declared bound\");\n             return;\n         }\n@@ -1597,7 +1599,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         if !env_bounds.is_empty() && env_bounds[1..].iter().all(|b| *b == env_bounds[0]) {\n             let unique_bound = env_bounds[0];\n             debug!(\"projection_must_outlive: unique declared bound = {:?}\", unique_bound);\n-            if projection_ty.trait_ref.substs.regions().any(|r| env_bounds.contains(r)) {\n+            if projection_ty.trait_ref.substs.regions().any(|r| env_bounds.contains(&r)) {\n                 debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n                 self.sub_regions(origin.clone(), region, unique_bound);\n                 return;\n@@ -1614,7 +1616,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.verify_generic_bound(origin, generic.clone(), region, verify_bound);\n     }\n \n-    fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+    fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         match ty.sty {\n             ty::TyParam(p) => {\n                 self.param_bound(p)\n@@ -1629,7 +1631,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound {\n+    fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n         let param_env = &self.parameter_environment;\n \n         debug!(\"param_bound(param_ty={:?})\",\n@@ -1647,7 +1649,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn projection_declared_bounds(&self,\n                                   span: Span,\n                                   projection_ty: ty::ProjectionTy<'tcx>)\n-                                  -> Vec<ty::Region>\n+                                  -> Vec<&'tcx ty::Region>\n     {\n         // First assemble bounds from where clauses and traits.\n \n@@ -1662,9 +1664,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn projection_bound(&self,\n                         span: Span,\n-                        declared_bounds: Vec<ty::Region>,\n+                        declared_bounds: Vec<&'tcx ty::Region>,\n                         projection_ty: ty::ProjectionTy<'tcx>)\n-                        -> VerifyBound {\n+                        -> VerifyBound<'tcx> {\n         debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n                declared_bounds, projection_ty);\n \n@@ -1676,7 +1678,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n     }\n \n-    fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+    fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n         let mut bounds = vec![];\n \n         for subty in ty.walk_shallow() {\n@@ -1698,7 +1700,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n-                                        -> Vec<ty::Region>\n+                                        -> Vec<&'tcx ty::Region>\n     {\n         let param_env = &self.parameter_environment;\n \n@@ -1732,7 +1734,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn declared_projection_bounds_from_trait(&self,\n                                              span: Span,\n                                              projection_ty: ty::ProjectionTy<'tcx>)\n-                                             -> Vec<ty::Region>\n+                                             -> Vec<&'tcx ty::Region>\n     {\n         debug!(\"projection_bounds(projection_ty={:?})\",\n                projection_ty);"}, {"sha": "a85e295784e977e5eeab71761fd11ca348ffb7fb", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -252,7 +252,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                         match capture {\n                             ty::UpvarCapture::ByValue => freevar_ty,\n                             ty::UpvarCapture::ByRef(borrow) =>\n-                                tcx.mk_ref(tcx.mk_region(borrow.region),\n+                                tcx.mk_ref(borrow.region,\n                                            ty::TypeAndMut {\n                                                ty: freevar_ty,\n                                                mutbl: borrow.kind.to_mutbl_lossy(),\n@@ -536,7 +536,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n               borrow_id: ast::NodeId,\n               _borrow_span: Span,\n               cmt: mc::cmt<'tcx>,\n-              _loan_region: ty::Region,\n+              _loan_region: &'tcx ty::Region,\n               bk: ty::BorrowKind,\n               _loan_cause: euv::LoanCause)\n     {"}, {"sha": "b3f26c6c8386c5d8203f2ea5096acb2ed4b74762", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -416,7 +416,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             ty::ExplicitSelfCategory::Static => return,\n             ty::ExplicitSelfCategory::ByValue => self_ty,\n             ty::ExplicitSelfCategory::ByReference(region, mutability) => {\n-                fcx.tcx.mk_ref(fcx.tcx.mk_region(region), ty::TypeAndMut {\n+                fcx.tcx.mk_ref(region, ty::TypeAndMut {\n                     ty: self_ty,\n                     mutbl: mutability\n                 })"}, {"sha": "6a738032adf0ae8cfe2a897491b7337abb4c8983", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -87,7 +87,7 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n     // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<ty::Region>\n+    free_to_bound_regions: DefIdMap<&'gcx ty::Region>\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n@@ -102,16 +102,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             return wbcx;\n         }\n \n+        let gcx = fcx.tcx.global_tcx();\n         let free_substs = fcx.parameter_environment.free_substs;\n         for (i, r) in free_substs.regions().enumerate() {\n             match *r {\n                 ty::ReFree(ty::FreeRegion {\n                     bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n                 }) => {\n-                    let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    let bound_region = gcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                         index: i as u32,\n                         name: name,\n-                    });\n+                    }));\n                     wbcx.free_to_bound_regions.insert(def_id, bound_region);\n                 }\n                 _ => {\n@@ -311,9 +312,9 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             // Convert the type from the function into a type valid outside\n             // the function, by replacing free regions with early-bound ones.\n             let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n-                match r {\n+                match *r {\n                     // 'static is valid everywhere.\n-                    ty::ReStatic => ty::ReStatic,\n+                    ty::ReStatic => gcx.mk_region(ty::ReStatic),\n \n                     // Free regions that come from early-bound regions are valid.\n                     ty::ReFree(ty::FreeRegion {\n@@ -331,7 +332,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                         span_err!(self.tcx().sess, span, E0564,\n                                   \"only named lifetimes are allowed in `impl Trait`, \\\n                                    but `{}` was found in the type `{}`\", r, inside_ty);\n-                        ty::ReStatic\n+                        gcx.mk_region(ty::ReStatic)\n                     }\n \n                     ty::ReVar(_) |\n@@ -626,12 +627,12 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+    fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(e) => {\n                 self.report_error(e);\n-                ty::ReStatic\n+                self.tcx.mk_region(ty::ReStatic)\n             }\n         }\n     }"}, {"sha": "c522d9fce0e99052e11c2928586dacf664b3a009", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n \n                     (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                        infcx.sub_regions(infer::RelateObjectBound(span), *r_b, *r_a);\n+                        infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n                         check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n                     }\n "}, {"sha": "2b2b1d3154f5ae8ff9051e52c78363a32b8d8cf7", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -1919,7 +1919,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                             param_id: ast::NodeId,\n                                             param_bounds: &[hir::TyParamBound],\n                                             where_clause: &hir::WhereClause)\n-                                            -> ty::ObjectLifetimeDefault\n+                                            -> ty::ObjectLifetimeDefault<'tcx>\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n     let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n@@ -1937,7 +1937,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n     fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             bounds: &[hir::TyParamBound])\n-                            -> Vec<ty::Region>\n+                            -> Vec<&'tcx ty::Region>\n     {\n         bounds.iter()\n               .filter_map(|bound| {\n@@ -1954,7 +1954,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 param_id: ast::NodeId,\n                                 predicates: &[hir::WherePredicate])\n-                                -> Vec<ty::Region>\n+                                -> Vec<&'tcx ty::Region>\n     {\n         predicates.iter()\n                   .flat_map(|predicate| {\n@@ -2126,7 +2126,7 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n     }\n \n     Substs::for_item(tcx, def_id,\n-                     |def, _| def.to_early_bound_region(),\n+                     |def, _| tcx.mk_region(def.to_early_bound_region()),\n                      |def, _| tcx.mk_param_from_def(def))\n }\n "}, {"sha": "637df52e3cb03e2fb40c6746c7503c4b293796be", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -58,8 +58,8 @@ impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n         t.super_visit_with(self)\n     }\n \n-    fn visit_region(&mut self, r: ty::Region) -> bool {\n-        match r {\n+    fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n+        match *r {\n             ty::ReEarlyBound(data) => {\n                 self.parameters.push(Parameter::Region(data));\n             }"}, {"sha": "f5b13c4207d905aaec9066559b8dc0b100140ae8", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -257,12 +257,12 @@ impl RegionScope for BindingRscope {\n /// A scope which overrides the default object lifetime but has no other effect.\n pub struct ObjectLifetimeDefaultRscope<'r> {\n     base_scope: &'r (RegionScope+'r),\n-    default: ty::ObjectLifetimeDefault,\n+    default: ty::ObjectLifetimeDefault<'r>,\n }\n \n impl<'r> ObjectLifetimeDefaultRscope<'r> {\n     pub fn new(base_scope: &'r (RegionScope+'r),\n-               default: ty::ObjectLifetimeDefault)\n+               default: ty::ObjectLifetimeDefault<'r>)\n                -> ObjectLifetimeDefaultRscope<'r>\n     {\n         ObjectLifetimeDefaultRscope {\n@@ -283,7 +283,7 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n                 Some(self.base_object_lifetime_default(span)),\n \n             ty::ObjectLifetimeDefault::Specific(r) =>\n-                Some(r),\n+                Some(*r),\n         }\n     }\n "}, {"sha": "5fd03cbd054b08f5e6ff51af72fb0596f1dc6ae5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -483,9 +483,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n                                    generics: &ty::Generics<'tcx>,\n-                                   region: ty::Region,\n+                                   region: &'tcx ty::Region,\n                                    variance: VarianceTermPtr<'a>) {\n-        match region {\n+        match *region {\n             ty::ReEarlyBound(ref data) => {\n                 assert_eq!(generics.parent, None);\n                 assert!((data.index as usize) < generics.regions.len());"}, {"sha": "e0a6f40c86033e0b758fab9c9ebe7682c45e2253", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dffd238f8b3195982427ba14bc01d47c6da6aedf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=dffd238f8b3195982427ba14bc01d47c6da6aedf", "patch": "@@ -821,7 +821,7 @@ impl Clean<Lifetime> for hir::LifetimeDef {\n     }\n }\n \n-impl Clean<Lifetime> for ty::RegionParameterDef {\n+impl<'tcx> Clean<Lifetime> for ty::RegionParameterDef<'tcx> {\n     fn clean(&self, _: &DocContext) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n@@ -913,7 +913,7 @@ impl<'tcx> Clean<WherePredicate> for ty::EquatePredicate<'tcx> {\n     }\n }\n \n-impl Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region, ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<&'tcx ty::Region, &'tcx ty::Region> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         WherePredicate::RegionPredicate {\n@@ -923,7 +923,7 @@ impl Clean<WherePredicate> for ty::OutlivesPredicate<ty::Region, ty::Region> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, ty::Region> {\n+impl<'tcx> Clean<WherePredicate> for ty::OutlivesPredicate<ty::Ty<'tcx>, &'tcx ty::Region> {\n     fn clean(&self, cx: &DocContext) -> WherePredicate {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n "}]}