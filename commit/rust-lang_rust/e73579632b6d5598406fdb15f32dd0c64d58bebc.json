{"sha": "e73579632b6d5598406fdb15f32dd0c64d58bebc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MzU3OTYzMmI2ZDU1OTg0MDZmZGIxNWYzMmRkMGM2NGQ1OGJlYmM=", "commit": {"author": {"name": "JCTyblaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-12-11T19:32:25Z"}, "committer": {"name": "JCTyblaidd", "email": "JCTyblaidd@users.noreply.github.com", "date": "2020-12-13T11:04:58Z"}, "message": "Rework to work with machine hook.", "tree": {"sha": "53aecb4bf366bcb912574c0dce89c1cd04eef006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53aecb4bf366bcb912574c0dce89c1cd04eef006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e73579632b6d5598406fdb15f32dd0c64d58bebc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e73579632b6d5598406fdb15f32dd0c64d58bebc", "html_url": "https://github.com/rust-lang/rust/commit/e73579632b6d5598406fdb15f32dd0c64d58bebc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e73579632b6d5598406fdb15f32dd0c64d58bebc/comments", "author": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JCTyblaidd", "id": 8288600, "node_id": "MDQ6VXNlcjgyODg2MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8288600?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JCTyblaidd", "html_url": "https://github.com/JCTyblaidd", "followers_url": "https://api.github.com/users/JCTyblaidd/followers", "following_url": "https://api.github.com/users/JCTyblaidd/following{/other_user}", "gists_url": "https://api.github.com/users/JCTyblaidd/gists{/gist_id}", "starred_url": "https://api.github.com/users/JCTyblaidd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JCTyblaidd/subscriptions", "organizations_url": "https://api.github.com/users/JCTyblaidd/orgs", "repos_url": "https://api.github.com/users/JCTyblaidd/repos", "events_url": "https://api.github.com/users/JCTyblaidd/events{/privacy}", "received_events_url": "https://api.github.com/users/JCTyblaidd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81c4eb7d74624d41b5fdddffa2d239d35c32f4b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/81c4eb7d74624d41b5fdddffa2d239d35c32f4b4", "html_url": "https://github.com/rust-lang/rust/commit/81c4eb7d74624d41b5fdddffa2d239d35c32f4b4"}], "stats": {"total": 72, "additions": 49, "deletions": 23}, "files": [{"sha": "ceb715613beb7ff7dd09ab90af5f5b0e2c67de90", "filename": "src/data_race.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e73579632b6d5598406fdb15f32dd0c64d58bebc/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73579632b6d5598406fdb15f32dd0c64d58bebc/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=e73579632b6d5598406fdb15f32dd0c64d58bebc", "patch": "@@ -76,7 +76,7 @@ use rustc_target::abi::Size;\n use crate::{\n     ImmTy, Immediate, InterpResult, MPlaceTy, MemPlaceMeta, MiriEvalContext, MiriEvalContextExt,\n     OpTy, Pointer, RangeMap, ScalarMaybeUninit, Tag, ThreadId, VClock, VTimestamp,\n-    VectorIdx,\n+    VectorIdx, MemoryKind, MiriMemoryKind\n };\n \n pub type AllocExtra = VClockAlloc;\n@@ -674,6 +674,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n             Ok(())\n         }\n     }\n+\n+    fn reset_vector_clocks(\n+        &mut self,\n+        ptr: Pointer<Tag>,\n+        size: Size\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if let Some(data_race) = &mut this.memory.extra.data_race {\n+            if data_race.multi_threaded.get() {\n+                let alloc_meta = this.memory.get_raw_mut(ptr.alloc_id)?.extra.data_race.as_mut().unwrap();\n+                alloc_meta.reset_clocks(ptr.offset, size);\n+            }\n+        }\n+        Ok(())\n+    }\n }\n \n /// Vector clock metadata for a logical memory allocation.\n@@ -688,7 +703,18 @@ pub struct VClockAlloc {\n \n impl VClockAlloc {\n     /// Create a new data-race detector for newly allocated memory.\n-    pub fn new_allocation(global: &MemoryExtra, len: Size, track_alloc: bool) -> VClockAlloc {\n+    pub fn new_allocation(global: &MemoryExtra, len: Size, kind: MemoryKind<MiriMemoryKind>) -> VClockAlloc {\n+        let track_alloc = match kind {\n+            // User allocated and stack memory should track allocation.\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap\n+            ) | MemoryKind::Stack => true,\n+            // Other global memory should trace races but be allocated at the 0 timestamp.\n+            MemoryKind::Machine(\n+                MiriMemoryKind::Global | MiriMemoryKind::Machine | MiriMemoryKind::Env |\n+                MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls\n+            ) | MemoryKind::CallerLocation | MemoryKind::Vtable => false\n+        };\n         let (alloc_timestamp, alloc_index) = if track_alloc {\n             let (alloc_index, clocks) = global.current_thread_state();\n             let alloc_timestamp = clocks.clock[alloc_index];\n@@ -704,6 +730,14 @@ impl VClockAlloc {\n         }\n     }\n \n+    fn reset_clocks(&mut self, offset: Size, len: Size) {\n+        let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n+        for (_, range) in alloc_ranges.iter_mut(offset, len) {\n+            // Reset the portion of the range\n+            *range = MemoryCellClocks::new(0, VectorIdx::MAX_INDEX);\n+        }\n+    }\n+\n     // Find an index, if one exists where the value\n     // in `l` is greater than the value in `r`.\n     fn find_gt_index(l: &VClock, r: &VClock) -> Option<VectorIdx> {"}, {"sha": "e639bf450ada9ae1261e7f7e6ecac2441edb0647", "filename": "src/machine.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e73579632b6d5598406fdb15f32dd0c64d58bebc/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73579632b6d5598406fdb15f32dd0c64d58bebc/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=e73579632b6d5598406fdb15f32dd0c64d58bebc", "patch": "@@ -478,27 +478,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 (None, Tag::Untagged)\n             };\n         let race_alloc = if let Some(data_race) = &memory_extra.data_race {\n-            match kind {\n-                // V-Table generation is lazy and so racy, so do not track races.\n-                // Also V-Tables are read only so no data races can be occur.\n-                // Must be disabled since V-Tables are initialized via interpreter\n-                // writes on demand and can incorrectly cause the data-race detector\n-                // to trigger.\n-                MemoryKind::Vtable => None,\n-                // User allocated and stack memory should track allocation.\n-                MemoryKind::Machine(\n-                    MiriMemoryKind::Rust | MiriMemoryKind::C | MiriMemoryKind::WinHeap\n-                ) | MemoryKind::Stack => Some(\n-                    data_race::AllocExtra::new_allocation(&data_race, alloc.size, true)\n-                ),\n-                // Other global memory should trace races but be allocated at the 0 timestamp.\n-                MemoryKind::Machine(\n-                    MiriMemoryKind::Global | MiriMemoryKind::Machine | MiriMemoryKind::Env |\n-                    MiriMemoryKind::ExternStatic | MiriMemoryKind::Tls\n-                ) | MemoryKind::CallerLocation => Some(\n-                    data_race::AllocExtra::new_allocation(&data_race, alloc.size, false)\n-                )\n-            }\n+            Some(data_race::AllocExtra::new_allocation(&data_race, alloc.size, kind))\n         } else {\n             None\n         };\n@@ -530,6 +510,18 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(())\n     }\n \n+    \n+    fn after_static_mem_initialized(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+        size: Size,\n+    ) -> InterpResult<'tcx> {\n+        if ecx.memory.extra.data_race.is_some() {\n+            ecx.reset_vector_clocks(ptr, size)?;\n+        }\n+        Ok(())\n+    }\n+\n     #[inline(always)]\n     fn tag_global_base_pointer(memory_extra: &MemoryExtra, id: AllocId) -> Self::PointerTag {\n         if let Some(stacked_borrows) = &memory_extra.stacked_borrows {"}]}