{"sha": "03396473b879b37d68f26588d136c840280b0ab5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMzk2NDczYjg3OWIzN2Q2OGYyNjU4OGQxMzZjODQwMjgwYjBhYjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-10T20:14:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-11T00:32:03Z"}, "message": "libstd: changes to in response to #5656", "tree": {"sha": "1fb55f17735fcfb9b8770bcf15ba657302680d53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fb55f17735fcfb9b8770bcf15ba657302680d53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03396473b879b37d68f26588d136c840280b0ab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03396473b879b37d68f26588d136c840280b0ab5", "html_url": "https://github.com/rust-lang/rust/commit/03396473b879b37d68f26588d136c840280b0ab5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03396473b879b37d68f26588d136c840280b0ab5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "url": "https://api.github.com/repos/rust-lang/rust/commits/61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "html_url": "https://github.com/rust-lang/rust/commit/61b9e0ebfa7c96886c45a461c6d8edb22f8153da"}], "stats": {"total": 404, "additions": 390, "deletions": 14}, "files": [{"sha": "3d2c3ac70b610908e28c55c85141c288c66657b9", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -171,7 +171,7 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n \n pub impl Arena {\n     // Functions for the POD part of the arena\n-    fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n+    priv fn alloc_pod_grow(&self, n_bytes: uint, align: uint) -> *u8 {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -183,7 +183,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n+    priv fn alloc_pod_inner(&self, n_bytes: uint, align: uint) -> *u8 {\n         let head = &mut self.pod_head;\n \n         let start = round_up_to(head.fill, align);\n@@ -202,7 +202,22 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n+    #[cfg(stage0)]\n+    priv fn alloc_pod<T>(&self, op: &fn() -> T) -> &'self T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n+            let ptr: *mut T = reinterpret_cast(&ptr);\n+            rusti::move_val_init(&mut (*ptr), op());\n+            return reinterpret_cast(&ptr);\n+        }\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    priv fn alloc_pod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n@@ -213,7 +228,7 @@ pub impl Arena {\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    priv fn alloc_nonpod_grow(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n@@ -225,7 +240,7 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    priv fn alloc_nonpod_inner(&self, n_bytes: uint, align: uint) -> (*u8, *u8) {\n         let head = &mut self.head;\n \n         let tydesc_start = head.fill;\n@@ -247,7 +262,32 @@ pub impl Arena {\n     }\n \n     #[inline(always)]\n-    fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n+    #[cfg(stage0)]\n+    priv fn alloc_nonpod<T>(&self, op: &fn() -> T) -> &'self T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let (ty_ptr, ptr) =\n+                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n+            let ty_ptr: *mut uint = reinterpret_cast(&ty_ptr);\n+            let ptr: *mut T = reinterpret_cast(&ptr);\n+            // Write in our tydesc along with a bit indicating that it\n+            // has *not* been initialized yet.\n+            *ty_ptr = reinterpret_cast(&tydesc);\n+            // Actually initialize it\n+            rusti::move_val_init(&mut(*ptr), op());\n+            // Now that we are done, update the tydesc to indicate that\n+            // the object is there.\n+            *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n+\n+            return reinterpret_cast(&ptr);\n+        }\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    priv fn alloc_nonpod<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n@@ -269,6 +309,7 @@ pub impl Arena {\n \n     // The external interface\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn alloc<T>(&self, op: &fn() -> T) -> &'self T {\n         unsafe {\n             if !rusti::needs_drop::<T>() {\n@@ -278,6 +319,21 @@ pub impl Arena {\n             }\n         }\n     }\n+\n+    // The external interface\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn alloc<'a, T>(&'a self, op: &fn() -> T) -> &'a T {\n+        unsafe {\n+            if !rusti::needs_drop::<T>() {\n+                self.alloc_pod(op)\n+            } else {\n+                self.alloc_nonpod(op)\n+            }\n+        }\n+    }\n }\n \n #[test]"}, {"sha": "632a38e8ca2d8fc484a478dce07dc1994f7ee9ac", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -437,8 +437,7 @@ pub impl Bitv {\n             if offset >= bitv.nbits {\n                 0\n             } else {\n-                // NOTE cannot use bitv[offset] until snapshot\n-                bitv.index(&offset) as u8 << (7 - bit)\n+                bitv[offset] as u8 << (7 - bit)\n             }\n         }\n \n@@ -460,8 +459,7 @@ pub impl Bitv {\n      * Transform self into a [bool] by turning each bit into a bool\n      */\n     fn to_bools(&self) -> ~[bool] {\n-        // NOTE cannot use self[i] until snapshot\n-        vec::from_fn(self.nbits, |i| self.index(&i))\n+        vec::from_fn(self.nbits, |i| self[i])\n     }\n \n     /**"}, {"sha": "a88d13fda66210a11ede2925570a37cd1a920a31", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -41,6 +41,7 @@ impl<T> Mutable for Deque<T> {\n     }\n }\n \n+#[cfg(stage0)]\n pub impl<T> Deque<T> {\n     /// Create an empty Deque\n     fn new() -> Deque<T> {\n@@ -51,21 +52,142 @@ pub impl<T> Deque<T> {\n     /// Return a reference to the first element in the deque\n     ///\n     /// Fails if the deque is empty\n+    #[cfg(stage0)]\n     fn peek_front(&self) -> &'self T { get(self.elts, self.lo) }\n \n+    /// Return a reference to the first element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+\n     /// Return a reference to the last element in the deque\n     ///\n     /// Fails if the deque is empty\n+    #[cfg(stage0)]\n     fn peek_back(&self) -> &'self T { get(self.elts, self.hi - 1u) }\n \n+    /// Return a reference to the last element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+\n     /// Retrieve an element in the deque by index\n     ///\n     /// Fails if there is no element with the given index\n+    #[cfg(stage0)]\n     fn get(&self, i: int) -> &'self T {\n         let idx = (self.lo + (i as uint)) % self.elts.len();\n         get(self.elts, idx)\n     }\n \n+    /// Retrieve an element in the deque by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, i: int) -> &'a T {\n+        let idx = (self.lo + (i as uint)) % self.elts.len();\n+        get(self.elts, idx)\n+    }\n+\n+    /// Iterate over the elements in the deque\n+    fn each(&self, f: &fn(&T) -> bool) {\n+        self.eachi(|_i, e| f(e))\n+    }\n+\n+    /// Iterate over the elements in the deque by index\n+    fn eachi(&self, f: &fn(uint, &T) -> bool) {\n+        for uint::range(0, self.nelts) |i| {\n+            if !f(i, self.get(i as int)) { return; }\n+        }\n+    }\n+\n+    /// Remove and return the first element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn pop_front(&mut self) -> T {\n+        let mut result = self.elts[self.lo].swap_unwrap();\n+        self.lo = (self.lo + 1u) % self.elts.len();\n+        self.nelts -= 1u;\n+        result\n+    }\n+\n+    /// Remove and return the last element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn pop_back(&mut self) -> T {\n+        if self.hi == 0u {\n+            self.hi = self.elts.len() - 1u;\n+        } else { self.hi -= 1u; }\n+        let mut result = self.elts[self.hi].swap_unwrap();\n+        self.elts[self.hi] = None;\n+        self.nelts -= 1u;\n+        result\n+    }\n+\n+    /// Prepend an element to the deque\n+    fn add_front(&mut self, t: T) {\n+        let oldlo = self.lo;\n+        if self.lo == 0u {\n+            self.lo = self.elts.len() - 1u;\n+        } else { self.lo -= 1u; }\n+        if self.lo == self.hi {\n+            self.elts = grow(self.nelts, oldlo, self.elts);\n+            self.lo = self.elts.len() - 1u;\n+            self.hi = self.nelts;\n+        }\n+        self.elts[self.lo] = Some(t);\n+        self.nelts += 1u;\n+    }\n+\n+    /// Append an element to the deque\n+    fn add_back(&mut self, t: T) {\n+        if self.lo == self.hi && self.nelts != 0u {\n+            self.elts = grow(self.nelts, self.lo, self.elts);\n+            self.lo = 0u;\n+            self.hi = self.nelts;\n+        }\n+        self.elts[self.hi] = Some(t);\n+        self.hi = (self.hi + 1u) % self.elts.len();\n+        self.nelts += 1u;\n+    }\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub impl<T> Deque<T> {\n+    /// Create an empty Deque\n+    fn new() -> Deque<T> {\n+        Deque{nelts: 0, lo: 0, hi: 0,\n+              elts: vec::from_fn(initial_capacity, |_| None)}\n+    }\n+\n+    /// Return a reference to the first element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn peek_front<'a>(&'a self) -> &'a T { get(self.elts, self.lo) }\n+\n+    /// Return a reference to the last element in the deque\n+    ///\n+    /// Fails if the deque is empty\n+    fn peek_back<'a>(&'a self) -> &'a T { get(self.elts, self.hi - 1u) }\n+\n+    /// Retrieve an element in the deque by index\n+    ///\n+    /// Fails if there is no element with the given index\n+    fn get<'a>(&'a self, i: int) -> &'a T {\n+        let idx = (self.lo + (i as uint)) % self.elts.len();\n+        get(self.elts, idx)\n+    }\n+\n     /// Iterate over the elements in the deque\n     fn each(&self, f: &fn(&T) -> bool) {\n         self.eachi(|_i, e| f(e))"}, {"sha": "feea8fb4fcda73254a24d1240f064a61ef6a37a6", "filename": "src/libstd/future.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -55,7 +55,7 @@ pub impl<A:Copy> Future<A> {\n }\n \n pub impl<A> Future<A> {\n-\n+    #[cfg(stage0)]\n     fn get_ref(&self) -> &'self A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n@@ -80,6 +80,34 @@ pub impl<A> Future<A> {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_ref<'a>(&'a self) -> &'a A {\n+        /*!\n+        * Executes the future's closure and then returns a borrowed\n+        * pointer to the result.  The borrowed pointer lasts as long as\n+        * the future.\n+        */\n+        unsafe {\n+            match self.state {\n+                Forced(ref mut v) => { return cast::transmute(v); }\n+                Evaluating => fail!(~\"Recursive forcing of future!\"),\n+                Pending(_) => {}\n+            }\n+\n+            let mut state = Evaluating;\n+            self.state <-> state;\n+            match state {\n+                Forced(_) | Evaluating => fail!(~\"Logic error.\"),\n+                Pending(f) => {\n+                    self.state = Forced(f());\n+                    self.get_ref()\n+                }\n+            }\n+        }\n+    }\n }\n \n pub fn from_value<A>(val: A) -> Future<A> {"}, {"sha": "c8d250f90f6c47438cd675af93f1b4947d5e203c", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -50,13 +50,29 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n+    #[cfg(stage0)]\n     fn top(&self) -> &'self T { &self.data[0] }\n \n+    /// Returns the greatest item in the queue - fails if empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn top<'a>(&'a self) -> &'a T { &self.data[0] }\n+\n     /// Returns the greatest item in the queue - None if empty\n+    #[cfg(stage0)]\n     fn maybe_top(&self) -> Option<&'self T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n+    /// Returns the greatest item in the queue - None if empty\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn maybe_top<'a>(&'a self) -> Option<&'a T> {\n+        if self.is_empty() { None } else { Some(self.top()) }\n+    }\n+\n     /// Returns the number of elements the queue can hold without reallocating\n     fn capacity(&self) -> uint { vec::capacity(&self.data) }\n "}, {"sha": "d50804ba47b598aeb6f4a3382aabf1dc614befbf", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -51,6 +51,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each(&self, it: &fn(&uint, &'self V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n@@ -60,18 +61,40 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, it: &fn(&uint, &'a V) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&i, elt) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n     /// Visit all keys in order\n     fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value(&self, blk: &fn(value: &V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, blk: &fn(value: &'a V) -> bool) {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, it: &fn(&uint, &'self mut V) -> bool) {\n+    fn mutate_values(&mut self, it: &fn(&uint, &mut V) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref mut elt) => if !it(&i, elt) { break },\n@@ -81,6 +104,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find(&self, key: &uint) -> Option<&'self V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -92,7 +116,23 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find<'a>(&'a self, key: &uint) -> Option<&'a V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find_mut(&mut self, key: &uint) -> Option<&'self mut V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n@@ -104,6 +144,21 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut V> {\n+        if *key < self.v.len() {\n+            match self.v[*key] {\n+              Some(ref mut value) => Some(value),\n+              None => None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -134,6 +189,7 @@ pub impl<V> SmallIntMap<V> {\n     fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n     /// Visit all key-value pairs in reverse order\n+    #[cfg(stage0)]\n     fn each_reverse(&self, it: &fn(uint, &'self V) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n@@ -143,9 +199,30 @@ pub impl<V> SmallIntMap<V> {\n         }\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) {\n+        for uint::range_rev(self.v.len(), 0) |i| {\n+            match self.v[i - 1] {\n+              Some(ref elt) => if !it(i - 1, elt) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     fn get(&self, key: &uint) -> &'self V {\n         self.find(key).expect(\"key not present\")\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, key: &uint) -> &'a V {\n+        self.find(key).expect(\"key not present\")\n+    }\n }\n \n pub impl<V:Copy> SmallIntMap<V> {"}, {"sha": "006455c44e429c1fcd6caddd097518024b02475f", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03396473b879b37d68f26588d136c840280b0ab5/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=03396473b879b37d68f26588d136c840280b0ab5", "patch": "@@ -105,26 +105,45 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Visit all key-value pairs in order\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&'self K, &'self V) -> bool) {\n         each(&self.root, f)\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n+        each(&self.root, f)\n+    }\n+\n     /// Visit all keys in order\n     fn each_key(&self, f: &fn(&K) -> bool) {\n         self.each(|k, _| f(k))\n     }\n \n     /// Visit all values in order\n+    #[cfg(stage0)]\n     fn each_value(&self, f: &fn(&V) -> bool) {\n         self.each(|_, v| f(v))\n     }\n \n+    /// Visit all values in order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool) {\n+        self.each(|_, v| f(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, f: &fn(&'self K, &'self mut V) -> bool) {\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool) {\n         mutate_values(&mut self.root, f);\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find(&self, key: &K) -> Option<&'self V> {\n         let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n         loop {\n@@ -141,12 +160,42 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n+        let mut current: &'a Option<~TreeNode<K, V>> = &self.root;\n+        loop {\n+            match *current {\n+              Some(ref r) => {\n+                match key.cmp(&r.key) {\n+                  Less => current = &r.left,\n+                  Greater => current = &r.right,\n+                  Equal => return Some(&r.value)\n+                }\n+              }\n+              None => return None\n+            }\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn find_mut(&mut self, key: &K) -> Option<&'self mut V> {\n         find_mut(&mut self.root, key)\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n+        find_mut(&mut self.root, key)\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -170,7 +219,16 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all key-value pairs in reverse order\n-    fn each_reverse(&'self self, f: &fn(&'self K, &'self V) -> bool) {\n+    #[cfg(stage0)]\n+    fn each_reverse(&self, f: &fn(&'self K, &'self V) -> bool) {\n+        each_reverse(&self.root, f);\n+    }\n+\n+    /// Visit all key-value pairs in reverse order\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, f: &fn(&'a K, &'a V) -> bool) {\n         each_reverse(&self.root, f);\n     }\n \n@@ -186,9 +244,19 @@ pub impl<K: TotalOrd, V> TreeMap<K, V> {\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n+    #[cfg(stage0)]\n     fn iter(&self) -> TreeMapIterator<'self, K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n+\n+    /// Get a lazy iterator over the key-value pairs in the map.\n+    /// Requires that it be frozen (immutable).\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn iter<'a>(&'a self) -> TreeMapIterator<'a, K, V> {\n+        TreeMapIterator{stack: ~[], node: &self.root}\n+    }\n }\n \n /// Lazy forward iterator over a map\n@@ -490,9 +558,20 @@ pub impl <T: TotalOrd> TreeSet<T> {\n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn iter(&self) -> TreeSetIterator<'self, T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n+\n+    /// Get a lazy iterator over the values in the set.\n+    /// Requires that it be frozen (immutable).\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn iter<'a>(&'a self) -> TreeSetIterator<'a, T> {\n+        TreeSetIterator{iter: self.map.iter()}\n+    }\n }\n \n /// Lazy forward iterator over a set"}]}