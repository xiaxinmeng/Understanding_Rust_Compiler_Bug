{"sha": "2ad8c7b3502616aff142a4640cce911c6c2c5463", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZDhjN2IzNTAyNjE2YWZmMTQyYTQ2NDBjY2U5MTFjNmMyYzU0NjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-03T12:11:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-03T12:11:23Z"}, "message": "Auto merge of #55330 - scalexm:bound-ty, r=nikomatsakis\n\nAdd support for bound types\n\nThis PR may have some slight performance impacts, I don't know how hot is the code I touched.\n\nAlso, this breaks clippy and miri.\n\nr? @nikomatsakis", "tree": {"sha": "59eef71c8ed3eb373398f5668663161820c516af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59eef71c8ed3eb373398f5668663161820c516af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad8c7b3502616aff142a4640cce911c6c2c5463", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad8c7b3502616aff142a4640cce911c6c2c5463", "html_url": "https://github.com/rust-lang/rust/commit/2ad8c7b3502616aff142a4640cce911c6c2c5463", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad8c7b3502616aff142a4640cce911c6c2c5463/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e8f9dbdc4f154d799589ce5e21c020c51f2123", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e8f9dbdc4f154d799589ce5e21c020c51f2123", "html_url": "https://github.com/rust-lang/rust/commit/b6e8f9dbdc4f154d799589ce5e21c020c51f2123"}, {"sha": "c5ed72fbfe8aae9ebc4c73dce3f1ef11388913d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ed72fbfe8aae9ebc4c73dce3f1ef11388913d9", "html_url": "https://github.com/rust-lang/rust/commit/c5ed72fbfe8aae9ebc4c73dce3f1ef11388913d9"}], "stats": {"total": 945, "additions": 555, "deletions": 390}, "files": [{"sha": "a93e31480f3bbb5a4b3952e317a5a7caffe36c17", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -100,9 +100,6 @@ for ty::RegionKind {\n             ty::ReEmpty => {\n                 // No variant fields to hash for these ...\n             }\n-            ty::ReCanonical(c) => {\n-                c.hash_stable(hcx, hasher);\n-            }\n             ty::ReLateBound(db, ty::BrAnon(i)) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n@@ -147,7 +144,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundTyIndex {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::BoundVar {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n@@ -852,6 +849,9 @@ for ty::TyKind<'gcx>\n             Param(param_ty) => {\n                 param_ty.hash_stable(hcx, hasher);\n             }\n+            Bound(bound_ty) => {\n+                bound_ty.hash_stable(hcx, hasher);\n+            }\n             Foreign(def_id) => {\n                 def_id.hash_stable(hcx, hasher);\n             }\n@@ -869,7 +869,6 @@ impl_stable_hash_for!(enum ty::InferTy {\n     FreshTy(a),\n     FreshIntTy(a),\n     FreshFloatTy(a),\n-    BoundTy(a),\n });\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>"}, {"sha": "61a861a8a1cd8b193a08c3a269c1641973498d31", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -23,7 +23,7 @@ use infer::InferCtxt;\n use std::sync::atomic::Ordering;\n use ty::fold::{TypeFoldable, TypeFolder};\n use ty::subst::Kind;\n-use ty::{self, BoundTy, BoundTyIndex, Lift, List, Ty, TyCtxt, TypeFlags};\n+use ty::{self, BoundTy, BoundVar, Lift, List, Ty, TyCtxt, TypeFlags};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -277,21 +277,35 @@ struct Canonicalizer<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     query_state: &'cx mut OriginalQueryValues<'tcx>,\n     // Note that indices is only used once `var_values` is big enough to be\n     // heap-allocated.\n-    indices: FxHashMap<Kind<'tcx>, BoundTyIndex>,\n+    indices: FxHashMap<Kind<'tcx>, BoundVar>,\n     canonicalize_region_mode: &'cx dyn CanonicalizeRegionMode,\n     needs_canonical_flags: TypeFlags,\n+\n+    binder_index: ty::DebruijnIndex,\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> {\n         self.tcx\n     }\n \n+    fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n+        where T: TypeFoldable<'tcx>\n+    {\n+        self.binder_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        t\n+    }\n+\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(..) => {\n-                // leave bound regions alone\n-                r\n+            ty::ReLateBound(index, ..) => {\n+                if index >= self.binder_index {\n+                    bug!(\"escaping late bound region during canonicalization\")\n+                } else {\n+                    r\n+                }\n             }\n \n             ty::ReVar(vid) => {\n@@ -317,8 +331,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n             | ty::ReErased => self.canonicalize_region_mode\n                 .canonicalize_free_region(self, r),\n \n-            ty::ReClosureBound(..) | ty::ReCanonical(_) => {\n-                bug!(\"canonical region encountered during canonicalization\")\n+            ty::ReClosureBound(..) => {\n+                bug!(\"closure bound region encountered during canonicalization\")\n             }\n         }\n     }\n@@ -337,8 +351,12 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n                 bug!(\"encountered a fresh type during canonicalization\")\n             }\n \n-            ty::Infer(ty::BoundTy(_)) => {\n-                bug!(\"encountered a canonical type during canonicalization\")\n+            ty::Bound(bound_ty) => {\n+                if bound_ty.index >= self.binder_index {\n+                    bug!(\"escaping bound type during canonicalization\")\n+                } else {\n+                    t\n+                }\n             }\n \n             ty::Closure(..)\n@@ -389,12 +407,6 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     where\n         V: TypeFoldable<'tcx> + Lift<'gcx>,\n     {\n-        debug_assert!(\n-            !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS),\n-            \"canonicalizing a canonical value: {:?}\",\n-            value,\n-        );\n-\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::HAS_FREE_REGIONS | TypeFlags::KEEP_IN_LOCAL_TCX\n         } else {\n@@ -422,6 +434,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             variables: SmallVec::new(),\n             query_state,\n             indices: FxHashMap::default(),\n+            binder_index: ty::INNERMOST,\n         };\n         let out_value = value.fold_with(&mut canonicalizer);\n \n@@ -455,7 +468,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     /// or returns an existing variable if `kind` has already been\n     /// seen. `kind` is expected to be an unbound variable (or\n     /// potentially a free region).\n-    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> BoundTy {\n+    fn canonical_var(&mut self, info: CanonicalVarInfo, kind: Kind<'tcx>) -> BoundVar {\n         let Canonicalizer {\n             variables,\n             query_state,\n@@ -475,7 +488,7 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             // direct linear search of `var_values`.\n             if let Some(idx) = var_values.iter().position(|&k| k == kind) {\n                 // `kind` is already present in `var_values`.\n-                BoundTyIndex::new(idx)\n+                BoundVar::new(idx)\n             } else {\n                 // `kind` isn't present in `var_values`. Append it. Likewise\n                 // for `info` and `variables`.\n@@ -490,26 +503,23 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n                     *indices = var_values\n                         .iter()\n                         .enumerate()\n-                        .map(|(i, &kind)| (kind, BoundTyIndex::new(i)))\n+                        .map(|(i, &kind)| (kind, BoundVar::new(i)))\n                         .collect();\n                 }\n                 // The cv is the index of the appended element.\n-                BoundTyIndex::new(var_values.len() - 1)\n+                BoundVar::new(var_values.len() - 1)\n             }\n         } else {\n             // `var_values` is large. Do a hashmap search via `indices`.\n             *indices.entry(kind).or_insert_with(|| {\n                 variables.push(info);\n                 var_values.push(kind);\n                 assert_eq!(variables.len(), var_values.len());\n-                BoundTyIndex::new(variables.len() - 1)\n+                BoundVar::new(variables.len() - 1)\n             })\n         };\n \n-        BoundTy {\n-            level: ty::INNERMOST,\n-            var,\n-        }\n+        var\n     }\n \n     /// Shorthand helper that creates a canonical region variable for\n@@ -552,9 +562,12 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n         info: CanonicalVarInfo,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n-        let b = self.canonical_var(info, r.into());\n-        debug_assert_eq!(ty::INNERMOST, b.level);\n-        self.tcx().mk_region(ty::ReCanonical(b.var))\n+        let var = self.canonical_var(info, r.into());\n+        let region = ty::ReLateBound(\n+            self.binder_index,\n+            ty::BoundRegion::BrAnon(var.as_u32())\n+        );\n+        self.tcx().mk_region(region)\n     }\n \n     /// Given a type variable `ty_var` of the given kind, first check\n@@ -570,9 +583,8 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n             let info = CanonicalVarInfo {\n                 kind: CanonicalVarKind::Ty(ty_kind),\n             };\n-            let b = self.canonical_var(info, ty_var.into());\n-            debug_assert_eq!(ty::INNERMOST, b.level);\n-            self.tcx().mk_infer(ty::InferTy::BoundTy(b))\n+            let var = self.canonical_var(info, ty_var.into());\n+            self.tcx().mk_ty(ty::Bound(BoundTy::new(self.binder_index, var)))\n         }\n     }\n }"}, {"sha": "f7eb7118f412f6f0c55676c6966eff30628f8104", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -20,7 +20,7 @@\n //! - a map M (of type `CanonicalVarValues`) from those canonical\n //!   variables back to the original.\n //!\n-//! We can then do queries using T2. These will give back constriants\n+//! We can then do queries using T2. These will give back constraints\n //! on the canonical variables which can be translated, using the map\n //! M, into constraints in our source context. This process of\n //! translating the results back is done by the\n@@ -40,7 +40,7 @@ use std::ops::Index;\n use syntax::source_map::Span;\n use ty::fold::TypeFoldable;\n use ty::subst::Kind;\n-use ty::{self, BoundTyIndex, Lift, List, Region, TyCtxt};\n+use ty::{self, BoundVar, Lift, List, Region, TyCtxt};\n \n mod canonicalizer;\n \n@@ -73,7 +73,7 @@ impl<'gcx> UseSpecializedDecodable for CanonicalVarInfos<'gcx> {}\n /// canonicalized query response.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<BoundTyIndex, Kind<'tcx>>,\n+    pub var_values: IndexVec<BoundVar, Kind<'tcx>>,\n }\n \n /// When we canonicalize a value to form a query, we wind up replacing\n@@ -337,7 +337,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         variables: &List<CanonicalVarInfo>,\n         universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n     ) -> CanonicalVarValues<'tcx> {\n-        let var_values: IndexVec<BoundTyIndex, Kind<'tcx>> = variables\n+        let var_values: IndexVec<BoundVar, Kind<'tcx>> = variables\n             .iter()\n             .map(|info| self.instantiate_canonical_var(span, *info, &universe_map))\n             .collect();\n@@ -456,10 +456,10 @@ BraceStructLiftImpl! {\n     } where R: Lift<'tcx>\n }\n \n-impl<'tcx> Index<BoundTyIndex> for CanonicalVarValues<'tcx> {\n+impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n     type Output = Kind<'tcx>;\n \n-    fn index(&self, value: BoundTyIndex) -> &Kind<'tcx> {\n+    fn index(&self, value: BoundVar) -> &Kind<'tcx> {\n         &self.var_values[value]\n     }\n }"}, {"sha": "f4607f7a9092f4ee01bd6a31b534bc06a88a1d84", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -35,7 +35,7 @@ use traits::{FulfillmentContext, TraitEngine};\n use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::fold::TypeFoldable;\n use ty::subst::{Kind, UnpackedKind};\n-use ty::{self, BoundTyIndex, Lift, Ty, TyCtxt};\n+use ty::{self, BoundVar, Lift, Ty, TyCtxt};\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n@@ -273,7 +273,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         for (index, original_value) in original_values.var_values.iter().enumerate() {\n             // ...with the value `v_r` of that variable from the query.\n             let result_value = query_response.substitute_projected(self.tcx, &result_subst, |v| {\n-                &v.var_values[BoundTyIndex::new(index)]\n+                &v.var_values[BoundVar::new(index)]\n             });\n             match (original_value.unpack(), result_value.unpack()) {\n                 (UnpackedKind::Lifetime(ty::ReErased), UnpackedKind::Lifetime(ty::ReErased)) => {\n@@ -308,11 +308,14 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // ...also include the other query region constraints from the query.\n         output_query_region_constraints.extend(\n             query_response.value.region_constraints.iter().filter_map(|r_c| {\n-                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder(); // reconstructed below\n-                let k1 = substitute_value(self.tcx, &result_subst, &k1);\n-                let r2 = substitute_value(self.tcx, &result_subst, &r2);\n+                let r_c = substitute_value(self.tcx, &result_subst, r_c);\n+\n+                // Screen out `'a: 'a` cases -- we skip the binder here but\n+                // only care the inner values to one another, so they are still at\n+                // consistent binding levels.\n+                let &ty::OutlivesPredicate(k1, r2) = r_c.skip_binder();\n                 if k1 != r2.into() {\n-                    Some(ty::Binder::bind(ty::OutlivesPredicate(k1, r2)))\n+                    Some(r_c)\n                 } else {\n                     None\n                 }\n@@ -423,7 +426,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // is directly equal to one of the canonical variables in the\n         // result, then we can type the corresponding value from the\n         // input. See the example above.\n-        let mut opt_values: IndexVec<BoundTyIndex, Option<Kind<'tcx>>> =\n+        let mut opt_values: IndexVec<BoundVar, Option<Kind<'tcx>>> =\n             IndexVec::from_elem_n(None, query_response.variables.len());\n \n         // In terms of our example above, we are iterating over pairs like:\n@@ -432,16 +435,22 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             match result_value.unpack() {\n                 UnpackedKind::Type(result_value) => {\n                     // e.g., here `result_value` might be `?0` in the example above...\n-                    if let ty::Infer(ty::InferTy::BoundTy(b)) = result_value.sty {\n-                        // in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+                    if let ty::Bound(b) = result_value.sty {\n+                        // ...in which case we would set `canonical_vars[0]` to `Some(?U)`.\n+\n+                        // We only allow a `ty::INNERMOST` index in substitutions.\n+                        assert_eq!(b.index, ty::INNERMOST);\n                         opt_values[b.var] = Some(*original_value);\n                     }\n                 }\n                 UnpackedKind::Lifetime(result_value) => {\n                     // e.g., here `result_value` might be `'?1` in the example above...\n-                    if let &ty::RegionKind::ReCanonical(index) = result_value {\n-                        // in which case we would set `canonical_vars[0]` to `Some('static)`.\n-                        opt_values[index] = Some(*original_value);\n+                    if let &ty::RegionKind::ReLateBound(index, br) = result_value {\n+                        // ... in which case we would set `canonical_vars[0]` to `Some('static)`.\n+\n+                        // We only allow a `ty::INNERMOST` index in substitutions.\n+                        assert_eq!(index, ty::INNERMOST);\n+                        opt_values[br.assert_bound_var()] = Some(*original_value);\n                     }\n                 }\n             }\n@@ -457,7 +466,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                 .enumerate()\n                 .map(|(index, info)| {\n                     if info.is_existential() {\n-                        match opt_values[BoundTyIndex::new(index)] {\n+                        match opt_values[BoundVar::new(index)] {\n                             Some(k) => k,\n                             None => self.instantiate_canonical_var(cause.span, *info, |u| {\n                                 universe_map[u.as_usize()]\n@@ -496,7 +505,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         // canonical variable; this is taken from\n         // `query_response.var_values` after applying the substitution\n         // `result_subst`.\n-        let substituted_query_response = |index: BoundTyIndex| -> Kind<'tcx> {\n+        let substituted_query_response = |index: BoundVar| -> Kind<'tcx> {\n             query_response.substitute_projected(self.tcx, &result_subst, |v| &v.var_values[index])\n         };\n \n@@ -523,22 +532,23 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             unsubstituted_region_constraints\n                 .iter()\n                 .map(move |constraint| {\n-                    let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n-                    let k1 = substitute_value(self.tcx, result_subst, k1);\n-                    let r2 = substitute_value(self.tcx, result_subst, r2);\n+                    let constraint = substitute_value(self.tcx, result_subst, constraint);\n+                    let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n \n                     Obligation::new(\n                         cause.clone(),\n                         param_env,\n                         match k1.unpack() {\n                             UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n-                                ty::Binder::dummy(\n+                                ty::Binder::bind(\n                                     ty::OutlivesPredicate(r1, r2)\n-                            )),\n+                                )\n+                            ),\n                             UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n-                                ty::Binder::dummy(ty::OutlivesPredicate(\n-                                    t1, r2\n-                            )))\n+                                ty::Binder::bind(\n+                                    ty::OutlivesPredicate(t1, r2)\n+                                )\n+                            ),\n                         }\n                     )\n                 })\n@@ -552,12 +562,12 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         cause: &ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         variables1: &OriginalQueryValues<'tcx>,\n-        variables2: impl Fn(BoundTyIndex) -> Kind<'tcx>,\n+        variables2: impl Fn(BoundVar) -> Kind<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         self.commit_if_ok(|_| {\n             let mut obligations = vec![];\n             for (index, value1) in variables1.var_values.iter().enumerate() {\n-                let value2 = variables2(BoundTyIndex::new(index));\n+                let value2 = variables2(BoundVar::new(index));\n \n                 match (value1.unpack(), value2.unpack()) {\n                     (UnpackedKind::Type(v1), UnpackedKind::Type(v2)) => {\n@@ -620,11 +630,11 @@ pub fn make_query_outlives<'tcx>(\n             }\n             Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n         })\n-        .map(ty::Binder::dummy) // no bound regions in the code above\n+        .map(ty::Binder::dummy) // no bound vars in the code above\n         .chain(\n             outlives_obligations\n                 .map(|(ty, r)| ty::OutlivesPredicate(ty.into(), r))\n-                .map(ty::Binder::dummy), // no bound regions in the code above\n+                .map(ty::Binder::dummy) // no bound vars in the code above\n         )\n         .collect();\n "}, {"sha": "b8c1ed236c0ba17aededa8aff24c46641052eb22", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -17,9 +17,9 @@\n //! [c]: https://rust-lang-nursery.github.io/rustc-guide/traits/canonicalization.html\n \n use infer::canonical::{Canonical, CanonicalVarValues};\n-use ty::fold::{TypeFoldable, TypeFolder};\n+use ty::fold::TypeFoldable;\n use ty::subst::UnpackedKind;\n-use ty::{self, Ty, TyCtxt, TypeFlags};\n+use ty::{self, TyCtxt};\n \n impl<'tcx, V> Canonical<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n@@ -64,51 +64,22 @@ where\n     T: TypeFoldable<'tcx>,\n {\n     if var_values.var_values.is_empty() {\n-        debug_assert!(!value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS));\n-        value.clone()\n-    } else if !value.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n         value.clone()\n     } else {\n-        value.fold_with(&mut CanonicalVarValuesSubst { tcx, var_values })\n-    }\n-}\n-\n-struct CanonicalVarValuesSubst<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    var_values: &'cx CanonicalVarValues<'tcx>,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for CanonicalVarValuesSubst<'cx, 'gcx, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match t.sty {\n-            ty::Infer(ty::InferTy::BoundTy(b)) => {\n-                debug_assert_eq!(ty::INNERMOST, b.level);\n-                match self.var_values.var_values[b.var].unpack() {\n-                    UnpackedKind::Type(ty) => ty,\n-                    r => bug!(\"{:?} is a type but value is {:?}\", b, r),\n-                }\n+        let fld_r = |br: ty::BoundRegion| {\n+            match var_values.var_values[br.assert_bound_var()].unpack() {\n+                UnpackedKind::Lifetime(l) => l,\n+                r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n             }\n-            _ => {\n-                if !t.has_type_flags(TypeFlags::HAS_CANONICAL_VARS) {\n-                    t\n-                } else {\n-                    t.super_fold_with(self)\n-                }\n+        };\n+\n+        let fld_t = |bound_ty: ty::BoundTy| {\n+            match var_values.var_values[bound_ty.var].unpack() {\n+                UnpackedKind::Type(ty) => ty,\n+                r => bug!(\"{:?} is a type but value is {:?}\", bound_ty, r),\n             }\n-        }\n-    }\n+        };\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match r {\n-            ty::RegionKind::ReCanonical(c) => match self.var_values.var_values[*c].unpack() {\n-                UnpackedKind::Lifetime(l) => l,\n-                r => bug!(\"{:?} is a region but value is {:?}\", c, r),\n-            },\n-            _ => r.super_fold_with(self),\n-        }\n+        tcx.replace_escaping_bound_vars(value, fld_r, fld_t)\n     }\n }"}, {"sha": "f13210926a79b77361e21c83c2d5f3b814b7d88f", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -485,7 +485,6 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 }\n             }\n \n-            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 span_bug!(\n                     self.span,"}, {"sha": "1963d366e7a66d5d5daa5ba3111852663416bd6c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             // We shouldn't encounter an error message with ReClosureBound.\n-            ty::ReCanonical(..) | ty::ReClosureBound(..) => {\n+            ty::ReClosureBound(..) => {\n                 bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n             }\n         };"}, {"sha": "b53444992fa216972d4e32b36bbdabd7d36e27d4", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -114,7 +114,6 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 self.tcx().types.re_erased\n             }\n \n-            ty::ReCanonical(..) |\n             ty::ReClosureBound(..) => {\n                 bug!(\n                     \"encountered unexpected region: {:?}\",\n@@ -171,8 +170,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n                 t\n             }\n \n-            ty::Infer(ty::BoundTy(..)) =>\n-                bug!(\"encountered canonical ty during freshening\"),\n+            ty::Bound(..) =>\n+                bug!(\"encountered bound ty during freshening\"),\n \n             ty::Generator(..) |\n             ty::Bool |"}, {"sha": "75f503d3bcfb4b331780bcd1e50cc6177f564c9b", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -260,9 +260,7 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let tcx = self.tcx();\n         match (a, b) {\n-            (&ty::ReCanonical(..), _)\n-            | (_, &ty::ReCanonical(..))\n-            | (&ty::ReClosureBound(..), _)\n+            (&ty::ReClosureBound(..), _)\n             | (_, &ty::ReClosureBound(..))\n             | (&ReLateBound(..), _)\n             | (_, &ReLateBound(..))"}, {"sha": "523f03c2cfc4773afc81f9c008a0fa7294bb5f92", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -305,7 +305,7 @@ where\n             ty, region, origin\n         );\n \n-        assert!(!ty.has_escaping_regions());\n+        assert!(!ty.has_escaping_bound_vars());\n \n         let components = self.tcx.outlives_components(ty);\n         self.components_must_outlive(origin, components, region);"}, {"sha": "88d45671b9afdfab86538d6a1b6d6345cfeed3ba", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -323,7 +323,7 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n         predicates\n             .into_iter()\n             .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| p.no_late_bound_regions())\n+            .filter_map(|p| p.no_bound_vars())\n             .filter(move |p| compare_ty(p.0))\n     }\n }"}, {"sha": "46b12d01829e7089835c2090715878efd39a79f9", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -833,10 +833,6 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n             ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),\n-            ty::ReCanonical(..) => bug!(\n-                \"region_universe(): encountered canonical region {:?}\",\n-                region\n-            ),\n         }\n     }\n "}, {"sha": "3b0f9a5e545fde48e157985c952b8b510f9cb83a", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -84,8 +84,8 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                 // Shouldn't have any LBR here, so we can safely put\n                 // this under a binder below without fear of accidental\n                 // capture.\n-                assert!(!a.has_escaping_regions());\n-                assert!(!b.has_escaping_regions());\n+                assert!(!a.has_escaping_bound_vars());\n+                assert!(!b.has_escaping_bound_vars());\n \n                 // can't make progress on `A <: B` if both A and B are\n                 // type variables, so record an obligation. We also"}, {"sha": "e87e425762d56eaf96399c1468eb1250f04f9eb4", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -683,8 +683,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 &ty::Predicate::TypeOutlives(ref binder) => {\n                     match (\n-                        binder.no_late_bound_regions(),\n-                        binder.map_bound_ref(|pred| pred.0).no_late_bound_regions(),\n+                        binder.no_bound_vars(),\n+                        binder.map_bound_ref(|pred| pred.0).no_bound_vars(),\n                     ) {\n                         (None, Some(t_a)) => {\n                             select.infcx().register_region_obligation_with_cause("}, {"sha": "71b77909b82a8e3de49c1cfbdc483a1c9822232b", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -455,7 +455,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n             false\n         }\n \n-        ty::Infer(..) => match in_crate {\n+        ty::Bound(..) | ty::Infer(..) => match in_crate {\n             InCrate::Local => false,\n             // The inference variable might be unified with a local\n             // type in that remote crate."}, {"sha": "e6ae0557c33af04c46663da4809ed645f544cfac", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::Generator(..) => Some(18),\n                 ty::Foreign(..) => Some(19),\n                 ty::GeneratorWitness(..) => Some(20),\n-                ty::Infer(..) | ty::Error => None,\n+                ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n                 ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n             }\n         }"}, {"sha": "aea956461f27bea7252ff69d43a72af19d10d377", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -143,7 +143,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         debug!(\"normalize_projection_type(projection_ty={:?})\",\n                projection_ty);\n \n-        debug_assert!(!projection_ty.has_escaping_regions());\n+        debug_assert!(!projection_ty.has_escaping_bound_vars());\n \n         // FIXME(#20304) -- cache\n \n@@ -349,15 +349,15 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n             }\n \n             ty::Predicate::TypeOutlives(ref binder) => {\n-                // Check if there are higher-ranked regions.\n-                match binder.no_late_bound_regions() {\n+                // Check if there are higher-ranked vars.\n+                match binder.no_bound_vars() {\n                     // If there are, inspect the underlying type further.\n                     None => {\n                         // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n                         let binder = binder.map_bound_ref(|pred| pred.0);\n \n-                        // Check if the type has any bound regions.\n-                        match binder.no_late_bound_regions() {\n+                        // Check if the type has any bound vars.\n+                        match binder.no_bound_vars() {\n                             // If so, this obligation is an error (for now). Eventually we should be\n                             // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                             // NOTE: this is duplicate-implemented between here and fulfillment."}, {"sha": "5e2f1fe08b90e04acf57fad8aedc764f259a246a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -352,7 +352,7 @@ impl<'tcx> GoalKind<'tcx> {\n         domain_goal: PolyDomainGoal<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ) -> GoalKind<'tcx> {\n-        match domain_goal.no_late_bound_regions() {\n+        match domain_goal.no_bound_vars() {\n             Some(p) => p.into_goal(),\n             None => GoalKind::Quantified(\n                 QuantifierKind::Universal,"}, {"sha": "80358294d056c535cadcdf9999b0f9eefeef69ab", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => { // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n                     Reveal::UserFacing => ty,\n@@ -393,7 +393,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 }\n             }\n \n-            ty::Projection(ref data) if !data.has_escaping_regions() => { // (*)\n+            ty::Projection(ref data) if !data.has_escaping_bound_vars() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because\n@@ -1619,7 +1619,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n-        predicate.no_late_bound_regions()\n+        predicate.no_bound_vars()\n             .map(|predicate| ProjectionCacheKey {\n                 // We don't attempt to match up with a specific type-variable state\n                 // from a specific call to `opt_normalize_projection_type` - if"}, {"sha": "62317f074764f67248c11feff2203734d46e45a4", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -252,6 +252,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) ->\n         | ty::Param(_)\n         | ty::Opaque(..)\n         | ty::Infer(_)\n+        | ty::Bound(..)\n         | ty::Generator(..) => false,\n \n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),"}, {"sha": "59b086e35de310a0ae189d841b8e7270c007fec7", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -100,7 +100,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_regions() => {\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n                 // (*)\n                 // Only normalize `impl Trait` after type-checking, usually in codegen.\n                 match self.param_env.reveal {\n@@ -138,7 +138,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                 }\n             }\n \n-            ty::Projection(ref data) if !data.has_escaping_regions() => {\n+            ty::Projection(ref data) if !data.has_escaping_bound_vars() => {\n                 // (*)\n                 // (*) This is kind of hacky -- we need to be able to\n                 // handle normalization within binders because"}, {"sha": "b3fae3bab347199ad0d95dd3d9d326725d53f056", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -164,7 +164,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ty::Predicate::ClosureKind(..) |\n             ty::Predicate::TypeOutlives(..) |\n             ty::Predicate::ConstEvaluatable(..) => None,\n-            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n+            ty::Predicate::RegionOutlives(ref data) => data.no_bound_vars().map(\n                 |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n             ),\n         })"}, {"sha": "45dad508af560d9e78c8dafc32604d2031a30309", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -587,7 +587,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n     ) -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({:?})\", obligation);\n-        debug_assert!(!obligation.predicate.has_escaping_regions());\n+        debug_assert!(!obligation.predicate.has_escaping_bound_vars());\n \n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n \n@@ -690,7 +690,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n-                debug_assert!(!t.has_escaping_regions());\n+                debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(t.clone());\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n@@ -722,9 +722,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             },\n \n             ty::Predicate::TypeOutlives(ref binder) => {\n-                assert!(!binder.has_escaping_regions());\n-                // Check if the type has higher-ranked regions.\n-                if binder.skip_binder().0.has_escaping_regions() {\n+                assert!(!binder.has_escaping_bound_vars());\n+                // Check if the type has higher-ranked vars.\n+                if binder.skip_binder().0.has_escaping_bound_vars() {\n                     // If so, this obligation is an error (for now). Eventually we should be\n                     // able to support additional cases here, like `for<'a> &'a str: 'a`.\n \n@@ -740,7 +740,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         Ok(EvaluatedToErr)\n                     }\n                 } else {\n-                    // If the type has no late bound regions, then if we assign all\n+                    // If the type has no late bound vars, then if we assign all\n                     // the inference variables in it to be 'static, then the type\n                     // will be 'static itself.\n                     //\n@@ -1199,7 +1199,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             \"candidate_from_obligation(cache_fresh_trait_pred={:?}, obligation={:?})\",\n             cache_fresh_trait_pred, stack\n         );\n-        debug_assert!(!stack.obligation.predicate.has_escaping_regions());\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n \n         if let Some(c) =\n             self.check_candidate_cache(stack.obligation.param_env, &cache_fresh_trait_pred)\n@@ -1801,7 +1801,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         placeholder_map: &infer::PlaceholderMap<'tcx>,\n         snapshot: &infer::CombinedSnapshot<'cx, 'tcx>,\n     ) -> bool {\n-        debug_assert!(!skol_trait_ref.has_escaping_regions());\n+        debug_assert!(!skol_trait_ref.has_escaping_bound_vars());\n         if self.infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(ty::Binder::dummy(skol_trait_ref), trait_bound)\n@@ -2168,7 +2168,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let source = match obligation.self_ty().no_late_bound_regions() {\n+        let source = match obligation.self_ty().no_bound_vars() {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n@@ -2445,7 +2445,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::Infer(ty::TyVar(_)) => Ambiguous,\n \n             ty::UnnormalizedProjection(..)\n-            | ty::Infer(ty::BoundTy(_))\n+            | ty::Bound(_)\n             | ty::Infer(ty::FreshTy(_))\n             | ty::Infer(ty::FreshIntTy(_))\n             | ty::Infer(ty::FreshFloatTy(_)) => {\n@@ -2530,7 +2530,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             ty::UnnormalizedProjection(..)\n-            | ty::Infer(ty::BoundTy(_))\n+            | ty::Bound(_)\n             | ty::Infer(ty::FreshTy(_))\n             | ty::Infer(ty::FreshIntTy(_))\n             | ty::Infer(ty::FreshFloatTy(_)) => {\n@@ -2573,7 +2573,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             | ty::Param(..)\n             | ty::Foreign(..)\n             | ty::Projection(..)\n-            | ty::Infer(ty::BoundTy(_))\n+            | ty::Bound(_)\n             | ty::Infer(ty::TyVar(_))\n             | ty::Infer(ty::FreshTy(_))\n             | ty::Infer(ty::FreshIntTy(_))\n@@ -3235,7 +3235,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx\n-            .shallow_resolve(obligation.self_ty().no_late_bound_regions().unwrap());\n+            .shallow_resolve(obligation.self_ty().no_bound_vars().unwrap());\n         let target = obligation\n             .predicate\n             .skip_binder()"}, {"sha": "05d9d4bc37d79f540e3c887feb5fcc82ae099be7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -2243,7 +2243,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         sty_debug_print!(\n             self,\n             Adt, Array, Slice, RawPtr, Ref, FnDef, FnPtr,\n-            Generator, GeneratorWitness, Dynamic, Closure, Tuple,\n+            Generator, GeneratorWitness, Dynamic, Closure, Tuple, Bound,\n             Param, Infer, UnnormalizedProjection, Projection, Opaque, Foreign);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());"}, {"sha": "4737c72b1ef0f75bcc2c0ca382ef69c4b769ea54", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::Infer(ty::TyVar(_)) => \"inferred type\".into(),\n             ty::Infer(ty::IntVar(_)) => \"integral variable\".into(),\n             ty::Infer(ty::FloatVar(_)) => \"floating-point variable\".into(),\n-            ty::Infer(ty::BoundTy(_)) |\n+            ty::Bound(_) |\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),"}, {"sha": "380f95993f8fbab345f51c0c1a93e55ec70b425b", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -122,7 +122,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Foreign(def_id) => {\n             Some(ForeignSimplifiedType(def_id))\n         }\n-        ty::Infer(_) | ty::Error => None,\n+        ty::Bound(..) | ty::Infer(_) | ty::Error => None,\n     }\n }\n "}, {"sha": "0764f363250dd8be56b0b7d846ff529fa0b2caca", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -115,15 +115,17 @@ impl FlagComputation {\n                 self.add_substs(&substs.substs);\n             }\n \n+            &ty::Bound(bound_ty) => {\n+                self.add_binder(bound_ty.index);\n+            }\n+\n             &ty::Infer(infer) => {\n                 self.add_flags(TypeFlags::HAS_FREE_LOCAL_NAMES); // it might, right?\n                 self.add_flags(TypeFlags::HAS_TY_INFER);\n                 match infer {\n                     ty::FreshTy(_) |\n                     ty::FreshIntTy(_) |\n-                    ty::FreshFloatTy(_) |\n-                    ty::BoundTy(_) => {\n-                        self.add_flags(TypeFlags::HAS_CANONICAL_VARS);\n+                    ty::FreshFloatTy(_) => {\n                     }\n \n                     ty::TyVar(_) |\n@@ -141,7 +143,7 @@ impl FlagComputation {\n             &ty::Projection(ref data) => {\n                 // currently we can't normalize projections that\n                 // include bound regions, so track those separately.\n-                if !data.has_escaping_regions() {\n+                if !data.has_escaping_bound_vars() {\n                     self.add_flags(TypeFlags::HAS_NORMALIZABLE_PROJECTION);\n                 }\n                 self.add_flags(TypeFlags::HAS_PROJECTION);"}, {"sha": "8c822adf7b0236bd39b829d1cae1335f7a8c7169", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 207, "deletions": 89, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -67,18 +67,18 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     /// bound by `binder` or bound by some binder outside of `binder`.\n     /// If `binder` is `ty::INNERMOST`, this indicates whether\n     /// there are any late-bound regions that appear free.\n-    fn has_regions_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.visit_with(&mut HasEscapingRegionsVisitor { outer_index: binder })\n+    fn has_vars_bound_at_or_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.visit_with(&mut HasEscapingVarsVisitor { outer_index: binder })\n     }\n \n     /// True if this `self` has any regions that escape `binder` (and\n     /// hence are not bound by it).\n-    fn has_regions_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n-        self.has_regions_bound_at_or_above(binder.shifted_in(1))\n+    fn has_vars_bound_above(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.has_vars_bound_at_or_above(binder.shifted_in(1))\n     }\n \n-    fn has_escaping_regions(&self) -> bool {\n-        self.has_regions_bound_at_or_above(ty::INNERMOST)\n+    fn has_escaping_bound_vars(&self) -> bool {\n+        self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n@@ -416,19 +416,93 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Late-bound region replacer\n+// Bound vars replacer\n \n-// Replaces the escaping regions in a type.\n-\n-struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+/// Replaces the escaping bound vars (late bound regions or bound types) in a type.\n+struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     /// As with `RegionFolder`, represents the index of a binder *just outside*\n     /// the ones we have visited.\n     current_index: ty::DebruijnIndex,\n \n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n-    map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n+    fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> ty::Ty<'tcx> + 'a),\n+}\n+\n+impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n+    fn new<F, G>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        fld_r: &'a mut F,\n+        fld_t: &'a mut G\n+    ) -> Self\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>\n+    {\n+        BoundVarReplacer {\n+            tcx,\n+            current_index: ty::INNERMOST,\n+            fld_r,\n+            fld_t,\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n+\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n+        self.current_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.current_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match t.sty {\n+            ty::Bound(bound_ty) => {\n+                if bound_ty.index == self.current_index {\n+                    let fld_t = &mut self.fld_t;\n+                    let ty = fld_t(bound_ty);\n+                    ty::fold::shift_vars(\n+                        self.tcx,\n+                        &ty,\n+                        self.current_index.as_u32()\n+                    )\n+                } else {\n+                    t\n+                }\n+            }\n+            _ => {\n+                if !t.has_vars_bound_at_or_above(self.current_index) {\n+                    // Nothing more to substitute.\n+                    t\n+                } else {\n+                    t.super_fold_with(self)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match *r {\n+            ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n+                let fld_r = &mut self.fld_r;\n+                let region = fld_r(br);\n+                if let ty::ReLateBound(debruijn1, br) = *region {\n+                    // If the callback returns a late-bound region,\n+                    // that region should always use the INNERMOST\n+                    // debruijn index. Then we adjust it to the\n+                    // correct depth.\n+                    assert_eq!(debruijn1, ty::INNERMOST);\n+                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                } else {\n+                    region\n+                }\n+            }\n+            _ => r\n+        }\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -440,16 +514,65 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// same `BoundRegion` will reuse the previous result.  A map is\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n-    pub fn replace_late_bound_regions<T,F>(self,\n+    ///\n+    /// This method only replaces late bound regions and the result may still\n+    /// contain escaping bound types.\n+    pub fn replace_late_bound_regions<T, F>(\n+        self,\n         value: &Binder<T>,\n-        mut f: F)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n-              T : TypeFoldable<'tcx>,\n+        mut fld_r: F\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              T: TypeFoldable<'tcx>\n     {\n-        let mut replacer = RegionReplacer::new(self, &mut f);\n+        let mut map = BTreeMap::new();\n+        let mut real_fldr = |br| {\n+            *map.entry(br).or_insert_with(|| fld_r(br))\n+        };\n+\n+        // identity for bound types\n+        let mut fld_t = |bound_ty| self.mk_ty(ty::Bound(bound_ty));\n+\n+        let mut replacer = BoundVarReplacer::new(self, &mut real_fldr, &mut fld_t);\n         let result = value.skip_binder().fold_with(&mut replacer);\n-        (result, replacer.map)\n+        (result, map)\n+    }\n+\n+    /// Replace all escaping bound vars. The `fld_r` closure replaces escaping\n+    /// bound regions while the `fld_t` closure replaces escaping bound types.\n+    pub fn replace_escaping_bound_vars<T, F, G>(\n+        self,\n+        value: &T,\n+        mut fld_r: F,\n+        mut fld_t: G\n+    ) -> T\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n+              T: TypeFoldable<'tcx>\n+    {\n+        if !value.has_escaping_bound_vars() {\n+            value.clone()\n+        } else {\n+            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t);\n+            let result = value.fold_with(&mut replacer);\n+            result\n+        }\n+    }\n+\n+    /// Replace all types or regions bound by the given `Binder`. The `fld_r`\n+    /// closure replaces bound regions while the `fld_t` closure replaces bound\n+    /// types.\n+    pub fn replace_bound_vars<T, F, G>(\n+        self,\n+        value: &Binder<T>,\n+        fld_r: F,\n+        fld_t: G\n+    ) -> T\n+        where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n+              G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n+              T: TypeFoldable<'tcx>\n+    {\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n     /// Replace any late-bound regions bound in `value` with\n@@ -549,21 +672,33 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n-    fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>, fld_r: &'a mut F)\n-              -> RegionReplacer<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::BoundRegion) -> ty::Region<'tcx>\n-    {\n-        RegionReplacer {\n+///////////////////////////////////////////////////////////////////////////\n+// Shifter\n+//\n+// Shifts the De Bruijn indices on all escaping bound vars by a\n+// fixed amount. Useful in substitution or when otherwise introducing\n+// a binding level that is not intended to capture the existing bound\n+// vars. See comment on `shift_vars_through_binders` method in\n+// `subst.rs` for more details.\n+\n+struct Shifter<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+    current_index: ty::DebruijnIndex,\n+    amount: u32,\n+}\n+\n+impl Shifter<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>, amount: u32) -> Self {\n+        Shifter {\n             tcx,\n             current_index: ty::INNERMOST,\n-            fld_r,\n-            map: BTreeMap::default()\n+            amount,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n@@ -573,85 +708,68 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_regions_bound_at_or_above(self.current_index) {\n-            return t;\n-        }\n-\n-        t.super_fold_with(self)\n-    }\n-\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n-                let fld_r = &mut self.fld_r;\n-                let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n-                if let ty::ReLateBound(debruijn1, br) = *region {\n-                    // If the callback returns a late-bound region,\n-                    // that region should always use the INNERMOST\n-                    // debruijn index. Then we adjust it to the\n-                    // correct depth.\n-                    assert_eq!(debruijn1, ty::INNERMOST);\n-                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+            ty::ReLateBound(debruijn, br) => {\n+                if self.amount == 0 || debruijn < self.current_index {\n+                    r\n                 } else {\n-                    region\n+                    let shifted = ty::ReLateBound(debruijn.shifted_in(self.amount), br);\n+                    self.tcx.mk_region(shifted)\n                 }\n             }\n             _ => r\n         }\n     }\n-}\n \n-///////////////////////////////////////////////////////////////////////////\n-// Region shifter\n-//\n-// Shifts the De Bruijn indices on all escaping bound regions by a\n-// fixed amount. Useful in substitution or when otherwise introducing\n-// a binding level that is not intended to capture the existing bound\n-// regions. See comment on `shift_regions_through_binders` method in\n-// `subst.rs` for more details.\n+    fn fold_ty(&mut self, ty: ty::Ty<'tcx>) -> ty::Ty<'tcx> {\n+        match ty.sty {\n+            ty::Bound(bound_ty) => {\n+                if self.amount == 0 || bound_ty.index < self.current_index {\n+                    ty\n+                } else {\n+                    let shifted = ty::BoundTy {\n+                        index: bound_ty.index.shifted_in(self.amount),\n+                        var: bound_ty.var,\n+                        kind: bound_ty.kind,\n+                    };\n+                    self.tcx.mk_ty(ty::Bound(shifted))\n+                }\n+            }\n \n-pub fn shift_region(region: ty::RegionKind, amount: u32) -> ty::RegionKind {\n-    match region {\n-        ty::ReLateBound(debruijn, br) => {\n-            ty::ReLateBound(debruijn.shifted_in(amount), br)\n-        }\n-        _ => {\n-            region\n+            _ => ty.super_fold_with(self),\n         }\n     }\n }\n \n-pub fn shift_region_ref<'a, 'gcx, 'tcx>(\n+pub fn shift_region<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     region: ty::Region<'tcx>,\n-    amount: u32)\n-    -> ty::Region<'tcx>\n-{\n+    amount: u32\n+) -> ty::Region<'tcx> {\n     match region {\n-        &ty::ReLateBound(debruijn, br) if amount > 0 => {\n-            tcx.mk_region(ty::ReLateBound(debruijn.shifted_in(amount), br))\n+        ty::ReLateBound(debruijn, br) if amount > 0 => {\n+            tcx.mk_region(ty::ReLateBound(debruijn.shifted_in(amount), *br))\n         }\n         _ => {\n             region\n         }\n     }\n }\n \n-pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        amount: u32,\n-                                        value: &T) -> T\n-    where T: TypeFoldable<'tcx>\n-{\n-    debug!(\"shift_regions(value={:?}, amount={})\",\n+pub fn shift_vars<'a, 'gcx, 'tcx, T>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    value: &T,\n+    amount: u32\n+) -> T where T: TypeFoldable<'tcx> {\n+    debug!(\"shift_vars(value={:?}, amount={})\",\n            value, amount);\n \n-    value.fold_with(&mut RegionFolder::new(tcx, &mut false, &mut |region, _current_depth| {\n-        shift_region_ref(tcx, region, amount)\n-    }))\n+    value.fold_with(&mut Shifter::new(tcx, amount))\n }\n \n-/// An \"escaping region\" is a bound region whose binder is not part of `t`.\n+/// An \"escaping var\" is a bound var whose binder is not part of `t`. A bound var can be a\n+/// bound region or a bound type.\n ///\n /// So, for example, consider a type like the following, which has two binders:\n ///\n@@ -663,24 +781,24 @@ pub fn shift_regions<'a, 'gcx, 'tcx, T>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n /// binders of both `'a` and `'b` are part of the type itself. However, if we consider the *inner\n /// fn type*, that type has an escaping region: `'a`.\n ///\n-/// Note that what I'm calling an \"escaping region\" is often just called a \"free region\". However,\n-/// we already use the term \"free region\". It refers to the regions that we use to represent bound\n-/// regions on a fn definition while we are typechecking its body.\n+/// Note that what I'm calling an \"escaping var\" is often just called a \"free var\". However,\n+/// we already use the term \"free var\". It refers to the regions or types that we use to represent\n+/// bound regions or type params on a fn definition while we are typechecking its body.\n ///\n /// To clarify, conceptually there is no particular difference between\n-/// an \"escaping\" region and a \"free\" region. However, there is a big\n+/// an \"escaping\" var and a \"free\" var. However, there is a big\n /// difference in practice. Basically, when \"entering\" a binding\n /// level, one is generally required to do some sort of processing to\n-/// a bound region, such as replacing it with a fresh/placeholder\n-/// region, or making an entry in the environment to represent the\n-/// scope to which it is attached, etc. An escaping region represents\n-/// a bound region for which this processing has not yet been done.\n-struct HasEscapingRegionsVisitor {\n+/// a bound var, such as replacing it with a fresh/placeholder\n+/// var, or making an entry in the environment to represent the\n+/// scope to which it is attached, etc. An escaping var represents\n+/// a bound var for which this processing has not yet been done.\n+struct HasEscapingVarsVisitor {\n     /// Anything bound by `outer_index` or \"above\" is escaping\n     outer_index: ty::DebruijnIndex,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n+impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> bool {\n         self.outer_index.shift_in(1);\n         let result = t.super_visit_with(self);\n@@ -693,7 +811,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingRegionsVisitor {\n         // `outer_index`, that means that `t` contains some content\n         // bound at `outer_index` or above (because\n         // `outer_exclusive_binder` is always 1 higher than the\n-        // content in `t`). Therefore, `t` has some escaping regions.\n+        // content in `t`). Therefore, `t` has some escaping vars.\n         t.outer_exclusive_binder > self.outer_index\n     }\n "}, {"sha": "2fc8ef548fa0447fa6b1c5f8e61509bf1fa845e1", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -213,7 +213,7 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n impl<'a, 'b, 'tcx> Instance<'tcx> {\n     pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>)\n                -> Instance<'tcx> {\n-        assert!(!substs.has_escaping_regions(),\n+        assert!(!substs.has_escaping_bound_vars(),\n                 \"substs of instance {:?} not normalized for codegen: {:?}\",\n                 def_id, substs);\n         Instance { def: InstanceDef::Item(def_id), substs: substs }"}, {"sha": "d44ba03084159ebe6a320e1e41d8f75a77f6b421", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -519,6 +519,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         ty::Param(_) |\n         ty::Opaque(..) |\n         ty::Infer(_) |\n+        ty::Bound(..) |\n         ty::Error |\n         ty::GeneratorWitness(..) |\n         ty::Never |"}, {"sha": "55005721617350f9ac9a1be12c3fc0cb98f4e6ce", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -1124,9 +1124,14 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n-            ty::UnnormalizedProjection(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n+\n+            ty::Bound(..) |\n+            ty::UnnormalizedProjection(..) |\n+            ty::GeneratorWitness(..) |\n+            ty::Infer(_) => {\n                 bug!(\"LayoutDetails::compute: unexpected type `{}`\", ty)\n             }\n+\n             ty::Param(_) | ty::Error => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n@@ -1703,7 +1708,7 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n                 }\n             }\n \n-            ty::Projection(_) | ty::UnnormalizedProjection(..) |\n+            ty::Projection(_) | ty::UnnormalizedProjection(..) | ty::Bound(..) |\n             ty::Opaque(..) | ty::Param(_) | ty::Infer(_) | ty::Error => {\n                 bug!(\"TyLayout::field_type: unexpected type `{}`\", this.ty)\n             }"}, {"sha": "7d693cd5523df22e2f52e7c894ae1f3d7538167f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -63,7 +63,7 @@ use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n \n use hir;\n \n-pub use self::sty::{Binder, BoundTy, BoundTyIndex, DebruijnIndex, INNERMOST};\n+pub use self::sty::{Binder, BoundTy, BoundTyKind, BoundVar, DebruijnIndex, INNERMOST};\n pub use self::sty::{FnSig, GenSig, CanonicalPolyFnSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n@@ -463,13 +463,9 @@ bitflags! {\n         // Currently we can't normalize projections w/ bound regions.\n         const HAS_NORMALIZABLE_PROJECTION = 1 << 12;\n \n-        // Set if this includes a \"canonical\" type or region var --\n-        // ought to be true only for the results of canonicalization.\n-        const HAS_CANONICAL_VARS = 1 << 13;\n-\n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND = 1 << 14;\n+        const HAS_RE_LATE_BOUND = 1 << 13;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n@@ -490,7 +486,6 @@ bitflags! {\n                                   TypeFlags::HAS_TY_CLOSURE.bits |\n                                   TypeFlags::HAS_FREE_LOCAL_NAMES.bits |\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n-                                  TypeFlags::HAS_CANONICAL_VARS.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits;\n     }\n }\n@@ -2378,6 +2373,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n                 }\n             }\n \n+            Bound(..) |\n             Infer(..) => {\n                 bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\",\n                      ty)"}, {"sha": "449730c9d0601d6c991e7705131b3eb71ed122fe", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // we simply fallback to the most restrictive rule, which\n             // requires that `Pi: 'a` for all `i`.\n             ty::Projection(ref data) => {\n-                if !data.has_escaping_regions() {\n+                if !data.has_escaping_bound_vars() {\n                     // best case: no escaping regions, so push the\n                     // projection and skip the subtree (thus generating no\n                     // constraints for Pi). This defers the choice between\n@@ -156,6 +156,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::FnDef(..) |       // OutlivesFunction (*)\n             ty::FnPtr(_) |        // OutlivesFunction (*)\n             ty::Dynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::Bound(..) |\n             ty::Error => {\n                 // (*) Bare functions and traits are both binders. In the\n                 // RFC, this means we would add the bound regions to the"}, {"sha": "59a66513eef0558a274c023b34e3169eeb183bd0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -734,9 +734,19 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n                 ty::UnnormalizedProjection(data.fold_with(folder))\n             }\n             ty::Opaque(did, substs) => ty::Opaque(did, substs.fold_with(folder)),\n-            ty::Bool | ty::Char | ty::Str | ty::Int(_) |\n-            ty::Uint(_) | ty::Float(_) | ty::Error | ty::Infer(_) |\n-            ty::Param(..) | ty::Never | ty::Foreign(..) => return self\n+\n+            ty::Bool |\n+            ty::Char |\n+            ty::Str |\n+            ty::Int(_) |\n+            ty::Uint(_) |\n+            ty::Float(_) |\n+            ty::Error |\n+            ty::Infer(_) |\n+            ty::Param(..) |\n+            ty::Bound(..) |\n+            ty::Never |\n+            ty::Foreign(..) => return self\n         };\n \n         if self.sty == sty {\n@@ -771,9 +781,19 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n                 data.visit_with(visitor)\n             }\n             ty::Opaque(_, ref substs) => substs.visit_with(visitor),\n-            ty::Bool | ty::Char | ty::Str | ty::Int(_) |\n-            ty::Uint(_) | ty::Float(_) | ty::Error | ty::Infer(_) |\n-            ty::Param(..) | ty::Never | ty::Foreign(..) => false,\n+\n+            ty::Bool |\n+            ty::Char |\n+            ty::Str |\n+            ty::Int(_) |\n+            ty::Uint(_) |\n+            ty::Float(_) |\n+            ty::Error |\n+            ty::Infer(_) |\n+            ty::Bound(..) |\n+            ty::Param(..) |\n+            ty::Never |\n+            ty::Foreign(..) => false,\n         }\n     }\n "}, {"sha": "6929cb988d0519458cbd50f02d78dada048a82f2", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 55, "deletions": 34, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -77,6 +77,17 @@ impl BoundRegion {\n             _ => false,\n         }\n     }\n+\n+    /// When canonicalizing, we replace unbound inference variables and free\n+    /// regions with anonymous late bound regions. This method asserts that\n+    /// we have an anonymous late bound region, which hence may refer to\n+    /// a canonical variable.\n+    pub fn assert_bound_var(&self) -> BoundVar {\n+        match *self {\n+            BoundRegion::BrAnon(var) => BoundVar::from_u32(var),\n+            _ => bug!(\"bound region is not anonymous\"),\n+        }\n+    }\n }\n \n /// N.B., If you change this, you'll probably want to change the corresponding\n@@ -188,6 +199,9 @@ pub enum TyKind<'tcx> {\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     Param(ParamTy),\n \n+    /// Bound type variable, used only when preparing a trait query.\n+    Bound(BoundTy),\n+\n     /// A type variable used during type checking.\n     Infer(InferTy),\n \n@@ -727,8 +741,8 @@ impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n     /// or some placeholder type.\n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n         -> ty::TraitRef<'tcx>  {\n-        // otherwise the escaping regions would be captured by the binder\n-        // debug_assert!(!self_ty.has_escaping_regions());\n+        // otherwise the escaping vars would be captured by the binder\n+        // debug_assert!(!self_ty.has_escaping_bound_vars());\n \n         ty::TraitRef {\n             def_id: self.def_id,\n@@ -755,41 +769,40 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n-/// Binder is a binder for higher-ranked lifetimes. It is part of the\n+/// Binder is a binder for higher-ranked lifetimes or types. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n /// Binder<TraitRef>`). Note that when we instantiate,\n-/// erase, or otherwise \"discharge\" these bound regions, we change the\n+/// erase, or otherwise \"discharge\" these bound vars, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(T);\n \n impl<T> Binder<T> {\n     /// Wraps `value` in a binder, asserting that `value` does not\n-    /// contain any bound regions that would be bound by the\n+    /// contain any bound vars that would be bound by the\n     /// binder. This is commonly used to 'inject' a value T into a\n     /// different binding level.\n     pub fn dummy<'tcx>(value: T) -> Binder<T>\n         where T: TypeFoldable<'tcx>\n     {\n-        debug_assert!(!value.has_escaping_regions());\n+        debug_assert!(!value.has_escaping_bound_vars());\n         Binder(value)\n     }\n \n-    /// Wraps `value` in a binder, binding late-bound regions (if any).\n-    pub fn bind<'tcx>(value: T) -> Binder<T>\n-    {\n+    /// Wraps `value` in a binder, binding higher-ranked vars (if any).\n+    pub fn bind<'tcx>(value: T) -> Binder<T> {\n         Binder(value)\n     }\n \n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// debruijn indices and the like. It is usually better to\n-    /// discharge the binder using `no_late_bound_regions` or\n+    /// discharge the binder using `no_bound_vars` or\n     /// `replace_late_bound_regions` or something like\n     /// that. `skip_binder` is only valid when you are either\n-    /// extracting data that has nothing to do with bound regions, you\n+    /// extracting data that has nothing to do with bound vars, you\n     /// are doing some sort of test that does not involve bound\n     /// regions, or you are being very careful about your depth\n     /// accounting.\n@@ -798,7 +811,7 @@ impl<T> Binder<T> {\n     ///\n     /// - extracting the def-id from a PolyTraitRef;\n     /// - comparing the self type of a PolyTraitRef to see if it is equal to\n-    ///   a type parameter `X`, since the type `X`  does not reference any regions\n+    ///   a type parameter `X`, since the type `X` does not reference any regions\n     pub fn skip_binder(&self) -> &T {\n         &self.0\n     }\n@@ -820,19 +833,19 @@ impl<T> Binder<T> {\n     }\n \n     /// Unwraps and returns the value within, but only if it contains\n-    /// no bound regions at all. (In other words, if this binder --\n+    /// no bound vars at all. (In other words, if this binder --\n     /// and indeed any enclosing binder -- doesn't bind anything at\n     /// all.) Otherwise, returns `None`.\n     ///\n     /// (One could imagine having a method that just unwraps a single\n-    /// binder, but permits late-bound regions bound by enclosing\n+    /// binder, but permits late-bound vars bound by enclosing\n     /// binders, but that would require adjusting the debruijn\n     /// indices, and given the shallow binding structure we often use,\n     /// would not be that useful.)\n-    pub fn no_late_bound_regions<'tcx>(self) -> Option<T>\n-        where T : TypeFoldable<'tcx>\n+    pub fn no_bound_vars<'tcx>(self) -> Option<T>\n+        where T: TypeFoldable<'tcx>\n     {\n-        if self.skip_binder().has_escaping_regions() {\n+        if self.skip_binder().has_escaping_bound_vars() {\n             None\n         } else {\n             Some(self.skip_binder().clone())\n@@ -1166,9 +1179,6 @@ pub enum RegionKind {\n     /// `ClosureRegionRequirements` that are produced by MIR borrowck.\n     /// See `ClosureRegionRequirements` for more details.\n     ReClosureBound(RegionVid),\n-\n-    /// Canonicalized region, used only when preparing a trait query.\n-    ReCanonical(BoundTyIndex),\n }\n \n impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n@@ -1219,22 +1229,37 @@ pub enum InferTy {\n     FreshTy(u32),\n     FreshIntTy(u32),\n     FreshFloatTy(u32),\n-\n-    /// Bound type variable, used only when preparing a trait query.\n-    BoundTy(BoundTy),\n }\n \n newtype_index! {\n-    pub struct BoundTyIndex { .. }\n+    pub struct BoundVar { .. }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct BoundTy {\n-    pub level: DebruijnIndex,\n-    pub var: BoundTyIndex,\n+    pub index: DebruijnIndex,\n+    pub var: BoundVar,\n+    pub kind: BoundTyKind,\n }\n \n-impl_stable_hash_for!(struct BoundTy { level, var });\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub enum BoundTyKind {\n+    Anon,\n+    Param(InternedString),\n+}\n+\n+impl_stable_hash_for!(struct BoundTy { index, var, kind });\n+impl_stable_hash_for!(enum self::BoundTyKind { Anon, Param(a) });\n+\n+impl BoundTy {\n+    pub fn new(index: DebruijnIndex, var: BoundVar) -> Self {\n+        BoundTy {\n+            index,\n+            var,\n+            kind: BoundTyKind::Anon,\n+        }\n+    }\n+}\n \n /// A `ProjectionPredicate` for an `ExistentialTraitRef`.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n@@ -1264,7 +1289,7 @@ impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n                         -> ty::ProjectionPredicate<'tcx>\n     {\n         // otherwise the escaping regions would be captured by the binders\n-        debug_assert!(!self_ty.has_escaping_regions());\n+        debug_assert!(!self_ty.has_escaping_bound_vars());\n \n         ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {\n@@ -1363,7 +1388,6 @@ impl RegionKind {\n             RegionKind::ReEmpty => false,\n             RegionKind::ReErased => false,\n             RegionKind::ReClosureBound(..) => false,\n-            RegionKind::ReCanonical(..) => false,\n         }\n     }\n \n@@ -1450,10 +1474,6 @@ impl RegionKind {\n             }\n             ty::ReErased => {\n             }\n-            ty::ReCanonical(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_CANONICAL_VARS;\n-            }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n@@ -1865,6 +1885,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             Tuple(..) |\n             Foreign(..) |\n             Param(_) |\n+            Bound(..) |\n             Infer(_) |\n             Error => {\n                 vec![]\n@@ -1930,7 +1951,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n             ty::Infer(ty::TyVar(_)) => false,\n \n-            ty::Infer(ty::BoundTy(_)) |\n+            ty::Bound(_) |\n             ty::Infer(ty::FreshTy(_)) |\n             ty::Infer(ty::FreshIntTy(_)) |\n             ty::Infer(ty::FreshFloatTy(_)) =>"}, {"sha": "c1aed36c92ddf3bfd60170781ea85bf88ff9bb82", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -12,7 +12,7 @@\n \n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n-use ty::{self, BoundTyIndex, Lift, List, Ty, TyCtxt};\n+use ty::{self, BoundVar, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n@@ -355,7 +355,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n                                        span,\n                                        root_ty: None,\n                                        ty_stack_depth: 0,\n-                                       region_binders_passed: 0 };\n+                                       binders_passed: 0 };\n         (*self).fold_with(&mut folder)\n     }\n }\n@@ -377,16 +377,16 @@ struct SubstFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ty_stack_depth: usize,\n \n     // Number of region binders we have passed through while doing the substitution\n-    region_binders_passed: u32,\n+    binders_passed: u32,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for SubstFolder<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n-        self.region_binders_passed += 1;\n+        self.binders_passed += 1;\n         let t = t.super_fold_with(self);\n-        self.region_binders_passed -= 1;\n+        self.binders_passed -= 1;\n         t\n     }\n \n@@ -471,12 +471,12 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.shift_regions_through_binders(ty)\n+        self.shift_vars_through_binders(ty)\n     }\n \n     /// It is sometimes necessary to adjust the debruijn indices during substitution. This occurs\n-    /// when we are substituting a type with escaping regions into a context where we have passed\n-    /// through region binders. That's quite a mouthful. Let's see an example:\n+    /// when we are substituting a type with escaping bound vars into a context where we have\n+    /// passed through binders. That's quite a mouthful. Let's see an example:\n     ///\n     /// ```\n     /// type Func<A> = fn(A);\n@@ -516,25 +516,25 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n     /// As indicated in the diagram, here the same type `&'a int` is substituted once, but in the\n     /// first case we do not increase the Debruijn index and in the second case we do. The reason\n     /// is that only in the second case have we passed through a fn binder.\n-    fn shift_regions_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"shift_regions(ty={:?}, region_binders_passed={:?}, has_escaping_regions={:?})\",\n-               ty, self.region_binders_passed, ty.has_escaping_regions());\n+    fn shift_vars_through_binders(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"shift_vars(ty={:?}, binders_passed={:?}, has_escaping_bound_vars={:?})\",\n+               ty, self.binders_passed, ty.has_escaping_bound_vars());\n \n-        if self.region_binders_passed == 0 || !ty.has_escaping_regions() {\n+        if self.binders_passed == 0 || !ty.has_escaping_bound_vars() {\n             return ty;\n         }\n \n-        let result = ty::fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n-        debug!(\"shift_regions: shifted result = {:?}\", result);\n+        let result = ty::fold::shift_vars(self.tcx(), &ty, self.binders_passed);\n+        debug!(\"shift_vars: shifted result = {:?}\", result);\n \n         result\n     }\n \n     fn shift_region_through_binders(&self, region: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        if self.region_binders_passed == 0 || !region.has_escaping_regions() {\n+        if self.binders_passed == 0 || !region.has_escaping_bound_vars() {\n             return region;\n         }\n-        self.tcx().mk_region(ty::fold::shift_region(*region, self.region_binders_passed))\n+        ty::fold::shift_region(self.tcx, region, self.binders_passed)\n     }\n }\n \n@@ -553,15 +553,23 @@ impl CanonicalUserSubsts<'tcx> {\n             return false;\n         }\n \n-        self.value.substs.iter().zip(BoundTyIndex::new(0)..).all(|(kind, cvar)| {\n+        self.value.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n             match kind.unpack() {\n                 UnpackedKind::Type(ty) => match ty.sty {\n-                    ty::Infer(ty::BoundTy(ref b)) => cvar == b.var,\n+                    ty::Bound(b) => {\n+                        // We only allow a `ty::INNERMOST` index in substitutions.\n+                        assert_eq!(b.index, ty::INNERMOST);\n+                        cvar == b.var\n+                    }\n                     _ => false,\n                 },\n \n                 UnpackedKind::Lifetime(r) => match r {\n-                    ty::ReCanonical(cvar1) => cvar == *cvar1,\n+                    ty::ReLateBound(index, br) => {\n+                        // We only allow a `ty::INNERMOST` index in substitutions.\n+                        assert_eq!(*index, ty::INNERMOST);\n+                        cvar == br.assert_bound_var()\n+                    }\n                     _ => false,\n                 },\n             }"}, {"sha": "1b1bbfd4deb8b53ea1780846c863fbf2a4f433ca", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -363,7 +363,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                erased_self_ty,\n                predicates);\n \n-        assert!(!erased_self_ty.has_escaping_regions());\n+        assert!(!erased_self_ty.has_escaping_bound_vars());\n \n         traits::elaborate_predicates(self, predicates)\n             .filter_map(|predicate| {\n@@ -389,7 +389,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         // construct such an object, but this seems\n                         // correct even if that code changes).\n                         let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n-                        if t == &erased_self_ty && !r.has_escaping_regions() {\n+                        if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n                             Some(*r)\n                         } else {\n                             None\n@@ -951,7 +951,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Can refer to a type which may drop.\n         // FIXME(eddyb) check this against a ParamEnv.\n-        ty::Dynamic(..) | ty::Projection(..) | ty::Param(_) |\n+        ty::Dynamic(..) | ty::Projection(..) | ty::Param(_) | ty::Bound(..) |\n         ty::Opaque(..) | ty::Infer(_) | ty::Error => true,\n \n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),"}, {"sha": "284c595ee2d965ed6177317bf611106f97725934", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -82,7 +82,7 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) |\n         ty::Str | ty::Infer(_) | ty::Param(_) | ty::Never | ty::Error |\n-        ty::Foreign(..) => {\n+        ty::Bound(..) | ty::Foreign(..) => {\n         }\n         ty::Array(ty, len) => {\n             push_const(stack, len);"}, {"sha": "1336eac63f880514902cac8abb1e8b298beb40a7", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n         self.out.iter()\n-                .inspect(|pred| assert!(!pred.has_escaping_regions()))\n+                .inspect(|pred| assert!(!pred.has_escaping_bound_vars()))\n                 .flat_map(|pred| {\n                     let mut selcx = traits::SelectionContext::new(infcx);\n                     let pred = traits::normalize(&mut selcx, param_env, cause.clone(), pred);\n@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         self.out.extend(\n             trait_ref.substs.types()\n-                            .filter(|ty| !ty.has_escaping_regions())\n+                            .filter(|ty| !ty.has_escaping_bound_vars())\n                             .map(|ty| traits::Obligation::new(cause.clone(),\n                                                               param_env,\n                                                               ty::Predicate::WellFormed(ty))));\n@@ -205,7 +205,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         let trait_ref = data.trait_ref(self.infcx.tcx);\n         self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n-        if !data.has_escaping_regions() {\n+        if !data.has_escaping_bound_vars() {\n             let predicate = trait_ref.to_predicate();\n             let cause = self.cause(traits::ProjectionWf(data));\n             self.out.push(traits::Obligation::new(cause, self.param_env, predicate));\n@@ -229,7 +229,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     }\n \n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n-        if !subty.has_escaping_regions() {\n+        if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref = ty::TraitRef {\n                 def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n@@ -258,6 +258,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 ty::GeneratorWitness(..) |\n                 ty::Never |\n                 ty::Param(_) |\n+                ty::Bound(..) |\n                 ty::Foreign(..) => {\n                     // WfScalar, WfParameter, etc\n                 }\n@@ -299,7 +300,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                 ty::Ref(r, rty, _) => {\n                     // WfReference\n-                    if !r.has_escaping_regions() && !rty.has_escaping_regions() {\n+                    if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n                         let cause = self.cause(traits::ReferenceOutlivesReferent(ty));\n                         self.out.push(\n                             traits::Obligation::new(\n@@ -450,7 +451,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .map(|pred| traits::Obligation::new(cause.clone(),\n                                                       self.param_env,\n                                                       pred))\n-                  .filter(|pred| !pred.has_escaping_regions())\n+                  .filter(|pred| !pred.has_escaping_bound_vars())\n                   .collect()\n     }\n \n@@ -489,7 +490,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n \n-        if !data.has_escaping_regions() {\n+        if !data.has_escaping_bound_vars() {\n             let implicit_bounds =\n                 object_region_bounds(self.infcx.tcx, data);\n "}, {"sha": "5ec4f55b142ebbfcac4c74ae4f0eb63de550c5dd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -16,7 +16,7 @@ use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{Bool, Char, Adt};\n use ty::{Error, Str, Array, Slice, Float, FnDef, FnPtr};\n-use ty::{Param, RawPtr, Ref, Never, Tuple};\n+use ty::{Param, Bound, RawPtr, Ref, Never, Tuple};\n use ty::{Closure, Generator, GeneratorWitness, Foreign, Projection, Opaque};\n use ty::{UnnormalizedProjection, Dynamic, Int, Uint, Infer};\n use ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable, GenericParamCount, GenericParamDefKind};\n@@ -790,9 +790,6 @@ define_print! {\n                 ty::ReEarlyBound(ref data) => {\n                     write!(f, \"{}\", data.name)\n                 }\n-                ty::ReCanonical(_) => {\n-                    write!(f, \"'_\")\n-                }\n                 ty::ReLateBound(_, br) |\n                 ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n                 ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n@@ -860,10 +857,6 @@ define_print! {\n                     write!(f, \"{:?}\", vid)\n                 }\n \n-                ty::ReCanonical(c) => {\n-                    write!(f, \"'?{}\", c.index())\n-                }\n-\n                 ty::RePlaceholder(placeholder) => {\n                     write!(f, \"RePlaceholder({:?})\", placeholder)\n                 }\n@@ -976,7 +969,6 @@ define_print! {\n                     ty::TyVar(_) => write!(f, \"_\"),\n                     ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n                     ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-                    ty::BoundTy(_) => write!(f, \"_\"),\n                     ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n                     ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n                     ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n@@ -988,7 +980,6 @@ define_print! {\n                 ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n                 ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n                 ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n-                ty::BoundTy(v) => write!(f, \"?{:?}\", v.var.index()),\n                 ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n                 ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n                 ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n@@ -1119,6 +1110,19 @@ define_print! {\n                 Infer(infer_ty) => write!(f, \"{}\", infer_ty),\n                 Error => write!(f, \"[type error]\"),\n                 Param(ref param_ty) => write!(f, \"{}\", param_ty),\n+                Bound(bound_ty) => {\n+                    match bound_ty.kind {\n+                        ty::BoundTyKind::Anon => {\n+                            if bound_ty.index == ty::INNERMOST {\n+                                write!(f, \"?{}\", bound_ty.var.index())\n+                            } else {\n+                                write!(f, \"?{}_{}\", bound_ty.index.index(), bound_ty.var.index())\n+                            }\n+                        }\n+\n+                        ty::BoundTyKind::Param(p) => write!(f, \"{}\", p),\n+                    }\n+                }\n                 Adt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n                 Dynamic(data, r) => {\n                     let r = r.print_to_string(cx);"}, {"sha": "a802729e3fbdbfe24317565dc98ffc9d35e51d80", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -426,7 +426,6 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             // These cannot exist in borrowck\n             RegionKind::ReVar(..) |\n-            RegionKind::ReCanonical(..) |\n             RegionKind::RePlaceholder(..) |\n             RegionKind::ReClosureBound(..) |\n             RegionKind::ReErased => span_bug!(borrow_span,"}, {"sha": "78a31ed668fcae090b32f31f3fee1e1bd71fbeea", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -363,7 +363,6 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n \n                     ty::ReStatic => self.item_ub,\n \n-                    ty::ReCanonical(_) |\n                     ty::ReEmpty |\n                     ty::ReClosureBound(..) |\n                     ty::ReLateBound(..) |"}, {"sha": "876fa993e1293e6c84f509eb715ba893b3b6697b", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -558,7 +558,7 @@ fn maybe_create_entry_wrapper(cx: &CodegenCx) {\n         // regions must appear in the argument\n         // listing.\n         let main_ret_ty = cx.tcx.erase_regions(\n-            &main_ret_ty.no_late_bound_regions().unwrap(),\n+            &main_ret_ty.no_bound_vars().unwrap(),\n         );\n \n         if declare::get_defined_value(cx, \"main\").is_some() {"}, {"sha": "c8c693257d52f410261bd223c7d2872dc50b475a", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -44,7 +44,7 @@ pub fn get_fn(\n     debug!(\"get_fn(instance={:?})\", instance);\n \n     assert!(!instance.substs.needs_infer());\n-    assert!(!instance.substs.has_escaping_regions());\n+    assert!(!instance.substs.has_escaping_bound_vars());\n     assert!(!instance.substs.has_param_types());\n \n     let sig = instance.fn_sig(cx.tcx);"}, {"sha": "eb5ae81b2184024ad6191c52580dc348466a87a2", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -173,6 +173,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         ty::Infer(_) |\n         ty::UnnormalizedProjection(..) |\n         ty::Projection(..) |\n+        ty::Bound(..) |\n         ty::Opaque(..) |\n         ty::GeneratorWitness(..) |\n         ty::Param(_) => {"}, {"sha": "b01d7e3a776f7145b791bfe7670db6f55636f6f4", "filename": "src/librustc_codegen_llvm/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_codegen_llvm%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_of.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n         debug!(\"llvm_type({:#?})\", self);\n \n-        assert!(!self.ty.has_escaping_regions(), \"{:?} has escaping regions\", self.ty);\n+        assert!(!self.ty.has_escaping_bound_vars(), \"{:?} has escaping bound vars\", self.ty);\n \n         // Make sure lifetimes are erased, to avoid generating distinct LLVM\n         // types for Rust types that only differ in the choice of lifetimes."}, {"sha": "28b7c610a91c0f8a9d2ccf728c9d1f854d9b6ee9", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -616,22 +616,22 @@ fn escaping() {\n         // Theta = [A -> &'a foo]\n         env.create_simple_region_hierarchy();\n \n-        assert!(!env.t_nil().has_escaping_regions());\n+        assert!(!env.t_nil().has_escaping_bound_vars());\n \n         let t_rptr_free1 = env.t_rptr_free(1);\n-        assert!(!t_rptr_free1.has_escaping_regions());\n+        assert!(!t_rptr_free1.has_escaping_bound_vars());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, d1());\n-        assert!(t_rptr_bound1.has_escaping_regions());\n+        assert!(t_rptr_bound1.has_escaping_bound_vars());\n \n         let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, d2());\n-        assert!(t_rptr_bound2.has_escaping_regions());\n+        assert!(t_rptr_bound2.has_escaping_bound_vars());\n \n         // t_fn = fn(A)\n         let t_param = env.t_param(0);\n-        assert!(!t_param.has_escaping_regions());\n+        assert!(!t_param.has_escaping_bound_vars());\n         let t_fn = env.t_fn(&[t_param], env.t_nil());\n-        assert!(!t_fn.has_escaping_regions());\n+        assert!(!t_fn.has_escaping_bound_vars());\n     })\n }\n "}, {"sha": "2e19b441d0e3915a0917577692eab39b1e9b8c5c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -718,6 +718,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Param(..) |\n             ty::Infer(..) |\n+            ty::Bound(..) |\n             ty::Error |\n             ty::Closure(..) |\n             ty::Generator(..) |"}, {"sha": "99372a511a9de5e2c2307b83255c68c7d38bff93", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -277,8 +277,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty\n             | ty::ReErased\n-            | ty::ReClosureBound(..)\n-            | ty::ReCanonical(..) => None,\n+            | ty::ReClosureBound(..) => None,\n         }\n     }\n "}, {"sha": "35ec478143546d90177a81c7f41efb2eebdcf5f8", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -82,9 +82,9 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         // when we move to universes, we will, and this assertion\n         // will start to fail.\n         let ty::OutlivesPredicate(k1, r2) =\n-            query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n+            query_constraint.no_bound_vars().unwrap_or_else(|| {\n                 bug!(\n-                    \"query_constraint {:?} contained bound regions\",\n+                    \"query_constraint {:?} contained bound vars\",\n                     query_constraint,\n                 );\n             });"}, {"sha": "734ddbc3ab9a72af39babca2f7080aac3e3577c9", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -359,7 +359,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     }\n \n     fn sanitize_type(&mut self, parent: &dyn fmt::Debug, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_regions() || ty.references_error() {\n+        if ty.has_escaping_bound_vars() || ty.references_error() {\n             span_mirbug_and_err!(self, parent, \"bad type {:?}\", ty)\n         } else {\n             ty\n@@ -2214,8 +2214,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     .enumerate()\n                     .filter_map(|(idx, constraint)| {\n                         let ty::OutlivesPredicate(k1, r2) =\n-                            constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                                bug!(\"query_constraint {:?} contained bound regions\", constraint,);\n+                            constraint.no_bound_vars().unwrap_or_else(|| {\n+                                bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n                             });\n \n                         match k1.unpack() {"}, {"sha": "8e27635dee8c13868c3d5e9a04cd1bf3289a83f0", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -905,12 +905,12 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   trait_ty: Ty<'tcx>,\n                                                   impl_ty: Ty<'tcx>,\n                                                   output: &mut Vec<MonoItem<'tcx>>) {\n-    assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_regions() &&\n-            !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n+    assert!(!trait_ty.needs_subst() && !trait_ty.has_escaping_bound_vars() &&\n+            !impl_ty.needs_subst() && !impl_ty.has_escaping_bound_vars());\n \n     if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n         let poly_trait_ref = trait_ty.principal().with_self_ty(tcx, impl_ty);\n-        assert!(!poly_trait_ref.has_escaping_regions());\n+        assert!(!poly_trait_ref.has_escaping_bound_vars());\n \n         // Walk all methods of the trait, including those of its supertraits\n         let methods = tcx.vtable_methods(poly_trait_ref);\n@@ -1082,7 +1082,7 @@ impl<'b, 'a, 'v> RootCollector<'b, 'a, 'v> {\n         // regions must appear in the argument\n         // listing.\n         let main_ret_ty = self.tcx.erase_regions(\n-            &main_ret_ty.no_late_bound_regions().unwrap(),\n+            &main_ret_ty.no_bound_vars().unwrap(),\n         );\n \n         let start_instance = Instance::resolve("}, {"sha": "9d69a5669b1c0a85cd8971579b93c849d359371a", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -382,6 +382,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 self.push_type_params(substs, iter::empty(), output);\n             }\n             ty::Error |\n+            ty::Bound(..) |\n             ty::Infer(_) |\n             ty::UnnormalizedProjection(..) |\n             ty::Projection(..) |"}, {"sha": "76a8501fb177a89c4375e3c99fa175a8da097aaf", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -844,7 +844,9 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let param_env = gcx.param_env(def_id);\n \n     // Normalize the sig.\n-    let sig = gcx.fn_sig(def_id).no_late_bound_regions().expect(\"LBR in ADT constructor signature\");\n+    let sig = gcx.fn_sig(def_id)\n+        .no_bound_vars()\n+        .expect(\"LBR in ADT constructor signature\");\n     let sig = gcx.normalize_erasing_regions(param_env, sig);\n \n     let (adt_def, substs) = match sig.output().sty {"}, {"sha": "80072153167f3c2eb6115cbfaef6905cc4b66220", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -143,7 +143,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n {\n     let did = tcx.require_lang_item(lang_item);\n     let poly_sig = tcx.fn_sig(did);\n-    let sig = poly_sig.no_late_bound_regions().unwrap();\n+    let sig = poly_sig.no_bound_vars().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n     let place_ty = place.ty(local_decls, tcx).to_ty(tcx);"}, {"sha": "bf252053199f8df143035e1b6bfa4c8dcfd4fe0d", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -506,6 +506,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n                     ty::GeneratorWitness(..) |\n                     ty::UnnormalizedProjection(..) |\n                     ty::Infer(..) |\n+                    ty::Bound(..) |\n                     ty::Error => {\n                         bug!(\"unexpected type {:?}\", ty)\n                     }"}, {"sha": "af64522f18398a4a646f88d460e8489263380f41", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -274,7 +274,7 @@ fn dtorck_constraint_for_ty<'a, 'gcx, 'tcx>(\n \n         ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n \n-        ty::Infer(..) | ty::Error => {\n+        ty::Bound(..) | ty::Infer(..) | ty::Error => {\n             // By the time this code runs, all type variables ought to\n             // be fully resolved.\n             Err(NoSolution)"}, {"sha": "7cc064f9c3d3d81906ad96caaa92a9e4c5e79a23", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -108,7 +108,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // From the full set of obligations, just filter down to the\n         // region relationships.\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n-            assert!(!obligation.has_escaping_regions());\n+            assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate {\n                 ty::Predicate::Trait(..) |\n                 ty::Predicate::Subtype(..) |\n@@ -122,14 +122,14 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     vec![]\n                 }\n \n-                ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n+                ty::Predicate::RegionOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(r_a, r_b)) => {\n                         vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                     }\n                 },\n \n-                ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n+                ty::Predicate::TypeOutlives(ref data) => match data.no_bound_vars() {\n                     None => vec![],\n                     Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);"}, {"sha": "052ca37b313717fa7123762068df759a37a3558c", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -93,6 +93,7 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::GeneratorWitness(..) |\n             ty::UnnormalizedProjection(..) |\n             ty::Infer(..) |\n+            ty::Bound(..) |\n             ty::Error => {\n                 bug!(\"unexpected type {:?}\", ty);\n             }"}, {"sha": "46f2c0c76a0c7b457cb19b140428ed69b92b1cb1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -1748,7 +1748,7 @@ impl<'a, 'gcx, 'tcx> Bounds<'tcx> {\n             self.region_bounds.iter().map(|&(region_bound, span)| {\n                 // account for the binder being introduced below; no need to shift `param_ty`\n                 // because, at present at least, it can only refer to early-bound regions\n-                let region_bound = tcx.mk_region(ty::fold::shift_region(*region_bound, 1));\n+                let region_bound = ty::fold::shift_region(tcx, region_bound, 1);\n                 let outlives = ty::OutlivesPredicate(param_ty, region_bound);\n                 (ty::Binder::dummy(outlives).to_predicate(), span)\n             }).chain("}, {"sha": "40f2072079a5a1ba203536b642b3f3d14ea8c53c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -816,7 +816,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n         // Replace constructor type with constructed type for tuple struct patterns.\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = pat_ty.no_late_bound_regions().expect(\"expected fn type\");\n+        let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "3f0a3531244424c68a7e2b99e4adcb9e2f0ae564", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::Opaque(def_id, substs) => Some(PointerKind::OfOpaque(def_id, substs)),\n             ty::Param(ref p) => Some(PointerKind::OfParam(p)),\n             // Insufficient type information.\n-            ty::Infer(_) => None,\n+            ty::Bound(..) | ty::Infer(_) => None,\n \n             ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n             ty::Float(_) | ty::Array(..) | ty::GeneratorWitness(..) |"}, {"sha": "010561d1001e5ad61cc4cf0af5da187681e0a8a6", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -460,7 +460,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create a `PolyFnSig`. Note the oddity that late bound\n         // regions appearing free in `expected_sig` are now bound up\n         // in this binder we are creating.\n-        assert!(!expected_sig.sig.has_regions_bound_above(ty::INNERMOST));\n+        assert!(!expected_sig.sig.has_vars_bound_above(ty::INNERMOST));\n         let bound_sig = ty::Binder::bind(self.tcx.mk_fn_sig(\n             expected_sig.sig.inputs().iter().cloned(),\n             expected_sig.sig.output(),"}, {"sha": "3156458b4aa4abe0690057c9cbfccfadb98e72a0", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -419,7 +419,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let mut structural_to_nomimal = FxHashMap::default();\n \n                     let sig = tcx.fn_sig(def_id);\n-                    let sig = sig.no_late_bound_regions().unwrap();\n+                    let sig = sig.no_bound_vars().unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "11448750618e218252dd96cb040609c91127dac6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 value\n             }\n         };\n-        assert!(!bounds.has_escaping_regions());\n+        assert!(!bounds.has_escaping_bound_vars());\n \n         let cause = traits::ObligationCause::misc(span, self.body_id);\n         obligations.extend(traits::predicates_for_generics(cause.clone(),"}, {"sha": "305efd0d75af6ed89b0fc26cbb2cac3d10733c48", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -1374,7 +1374,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                fn_sig,\n                substs);\n \n-        assert!(!substs.has_escaping_regions());\n+        assert!(!substs.has_escaping_bound_vars());\n \n         // It is possible for type parameters or early-bound lifetimes\n         // to appear in the signature of `self`. The substitutions we"}, {"sha": "791b5a0bdd92abebb5025afe718f7791612c8e68", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -653,8 +653,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n \n     fn register_predicate(&self, obligation: traits::PredicateObligation<'tcx>) {\n         debug!(\"register_predicate({:?})\", obligation);\n-        if obligation.has_escaping_regions() {\n-            span_bug!(obligation.cause.span, \"escaping regions in predicate {:?}\",\n+        if obligation.has_escaping_bound_vars() {\n+            span_bug!(obligation.cause.span, \"escaping bound vars in predicate {:?}\",\n                       obligation);\n         }\n         self.fulfillment_cx\n@@ -1928,7 +1928,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn normalize_ty(&self, span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if ty.has_escaping_regions() {\n+        if ty.has_escaping_bound_vars() {\n             ty // FIXME: normalization and escaping regions\n         } else {\n             self.normalize_associated_types_in(span, &ty)\n@@ -2431,7 +2431,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                           cause: traits::ObligationCause<'tcx>,\n                                           predicates: &ty::InstantiatedPredicates<'tcx>)\n     {\n-        assert!(!predicates.has_escaping_regions());\n+        assert!(!predicates.has_escaping_bound_vars());\n \n         debug!(\"add_obligations_for_parameters(predicates={:?})\",\n                predicates);\n@@ -5188,8 +5188,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             },\n         );\n-        assert!(!substs.has_escaping_regions());\n-        assert!(!ty.has_escaping_regions());\n+        assert!(!substs.has_escaping_bound_vars());\n+        assert!(!ty.has_escaping_bound_vars());\n \n         // Write the \"user substs\" down first thing for later.\n         let hir_id = self.tcx.hir.node_to_hir_id(node_id);"}, {"sha": "a5ad31e0b6b5f0de5e1abc1821522935186383ff", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -99,7 +99,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n \n     let span = tcx.hir.span(impl_node_id);\n     let param_env = tcx.param_env(impl_did);\n-    assert!(!self_type.has_escaping_regions());\n+    assert!(!self_type.has_escaping_bound_vars());\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n            self_type);\n@@ -176,7 +176,7 @@ fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n         let span = tcx.hir.span(impl_node_id);\n \n         let source = tcx.type_of(impl_did);\n-        assert!(!source.has_escaping_regions());\n+        assert!(!source.has_escaping_bound_vars());\n         let target = {\n             let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n             assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n@@ -356,7 +356,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n \n     let span = gcx.hir.span(impl_node_id);\n     let param_env = gcx.param_env(impl_did);\n-    assert!(!source.has_escaping_regions());\n+    assert!(!source.has_escaping_bound_vars());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };\n "}, {"sha": "bf3887ee8fcdd398532dfb6e269369747fd25afb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -208,7 +208,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         item_def_id: DefId,\n         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Ty<'tcx> {\n-        if let Some(trait_ref) = poly_trait_ref.no_late_bound_regions() {\n+        if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n             self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n             // no late-bound regions, we can just ignore the binder"}, {"sha": "d748d93d8988e63470b142ac6381cf7f01f9285b", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -167,7 +167,6 @@ fn is_free_region<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, region: Region<'_>) -> bool\n         RegionKind::ReEmpty\n         | RegionKind::ReErased\n         | RegionKind::ReClosureBound(..)\n-        | RegionKind::ReCanonical(..)\n         | RegionKind::ReScope(..)\n         | RegionKind::ReVar(..)\n         | RegionKind::RePlaceholder(..)"}, {"sha": "47d34c909961e16e53a4a0d79e12a40b4a2e5aac", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -338,6 +338,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::UnnormalizedProjection(..) |\n             ty::GeneratorWitness(..) |\n+            ty::Bound(..) |\n             ty::Infer(..) => {\n                 bug!(\"unexpected type encountered in \\\n                       variance inference: {}\",\n@@ -426,7 +427,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // way early-bound regions do, so we skip them here.\n             }\n \n-            ty::ReCanonical(_) |\n             ty::ReFree(..) |\n             ty::ReClosureBound(..) |\n             ty::ReScope(..) |"}, {"sha": "e71b3ccb01dbe19b45c69b51a2eabb9f46aae7b1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad8c7b3502616aff142a4640cce911c6c2c5463/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2ad8c7b3502616aff142a4640cce911c6c2c5463", "patch": "@@ -1260,7 +1260,6 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             ty::RePlaceholder(..) |\n             ty::ReEmpty |\n             ty::ReClosureBound(_) |\n-            ty::ReCanonical(_) |\n             ty::ReErased => None\n         }\n     }\n@@ -2733,6 +2732,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n             ty::Closure(..) | ty::Generator(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n+            ty::Bound(..) => panic!(\"Bound\"),\n             ty::UnnormalizedProjection(..) => panic!(\"UnnormalizedProjection\"),\n             ty::GeneratorWitness(..) => panic!(\"GeneratorWitness\"),\n             ty::Infer(..) => panic!(\"Infer\"),"}]}