{"sha": "4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a", "node_id": "C_kwDOAAsO6NoAKDRmOGY0YjRjODJlNDY0N2EyNDY0ZTM2NGZmOTZjYzFkYzVjYjhlOWE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-06T19:54:57Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-03-16T17:53:52Z"}, "message": "Handle slice patterns in `match_same_arms`", "tree": {"sha": "5eda62965e845ceaff52bec2b85d36d5235645a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5eda62965e845ceaff52bec2b85d36d5235645a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a", "html_url": "https://github.com/rust-lang/rust/commit/4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5508f461b853345bdfbefe61fb4b7bccb433b302", "url": "https://api.github.com/repos/rust-lang/rust/commits/5508f461b853345bdfbefe61fb4b7bccb433b302", "html_url": "https://github.com/rust-lang/rust/commit/5508f461b853345bdfbefe61fb4b7bccb433b302"}], "stats": {"total": 53, "additions": 37, "deletions": 16}, "files": [{"sha": "39c1f0d0d0186be03e196bec0844e57a66ecd587", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=4f8f4b4c82e4647a2464e364ff96cc1dc5cb8e9a", "patch": "@@ -21,27 +21,30 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n     };\n \n     let arena = DroplessArena::default();\n-    let resolved_pats: Vec<_> = arms.iter().map(|a| ResolvedPat::from_pat(cx, &arena, a.pat)).collect();\n+    let normalized_pats: Vec<_> = arms\n+        .iter()\n+        .map(|a| NormalizedPat::from_pat(cx, &arena, a.pat))\n+        .collect();\n \n     // The furthast forwards a pattern can move without semantic changes\n-    let forwards_blocking_idxs: Vec<_> = resolved_pats\n+    let forwards_blocking_idxs: Vec<_> = normalized_pats\n         .iter()\n         .enumerate()\n         .map(|(i, pat)| {\n-            resolved_pats[i + 1..]\n+            normalized_pats[i + 1..]\n                 .iter()\n                 .enumerate()\n                 .find_map(|(j, other)| pat.can_also_match(other).then(|| i + 1 + j))\n-                .unwrap_or(resolved_pats.len())\n+                .unwrap_or(normalized_pats.len())\n         })\n         .collect();\n \n     // The furthast backwards a pattern can move without semantic changes\n-    let backwards_blocking_idxs: Vec<_> = resolved_pats\n+    let backwards_blocking_idxs: Vec<_> = normalized_pats\n         .iter()\n         .enumerate()\n         .map(|(i, pat)| {\n-            resolved_pats[..i]\n+            normalized_pats[..i]\n                 .iter()\n                 .enumerate()\n                 .rev()\n@@ -133,18 +136,18 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n }\n \n #[derive(Clone, Copy)]\n-enum ResolvedPat<'hir, 'arena> {\n+enum NormalizedPat<'a> {\n     Wild,\n-    Struct(Option<DefId>, &'arena [(Symbol, Self)]),\n-    Tuple(Option<DefId>, &'arena [Self]),\n-    Or(&'arena [Self]),\n+    Struct(Option<DefId>, &'a [(Symbol, Self)]),\n+    Tuple(Option<DefId>, &'a [Self]),\n+    Or(&'a [Self]),\n     Path(Option<DefId>),\n     LitStr(Symbol),\n-    LitBytes(&'hir [u8]),\n+    LitBytes(&'a [u8]),\n     LitInt(u128),\n     LitBool(bool),\n     Range(PatRange),\n-    Slice(&'arena [Self], &'arena [Self], bool),\n+    Slice(&'a [Self], Option<&'a [Self]>),\n }\n \n #[derive(Clone, Copy)]\n@@ -183,9 +186,9 @@ impl PatRange {\n }\n \n #[allow(clippy::similar_names)]\n-impl<'hir, 'arena> ResolvedPat<'hir, 'arena> {\n+impl<'a> NormalizedPat<'a> {\n     #[allow(clippy::too_many_lines)]\n-    fn from_pat(cx: &LateContext<'_>, arena: &'arena DroplessArena, pat: &'hir Pat<'_>) -> Self {\n+    fn from_pat(cx: &LateContext<'_>, arena: &'a DroplessArena, pat: &'a Pat<'_>) -> Self {\n         match pat.kind {\n             PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n             PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => {\n@@ -284,8 +287,7 @@ impl<'hir, 'arena> ResolvedPat<'hir, 'arena> {\n             },\n             PatKind::Slice(front, wild_pat, back) => Self::Slice(\n                 arena.alloc_from_iter(front.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n-                arena.alloc_from_iter(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n-                wild_pat.is_some(),\n+                wild_pat.map(|_| &*arena.alloc_from_iter(back.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n             ),\n         }\n     }\n@@ -345,6 +347,25 @@ impl<'hir, 'arena> ResolvedPat<'hir, 'arena> {\n             (Self::LitBool(x), Self::LitBool(y)) => x == y,\n             (Self::Range(ref x), Self::Range(ref y)) => x.overlaps(y),\n             (Self::Range(ref range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(ref range)) => range.contains(x),\n+            (Self::Slice(lpats, None), Self::Slice(rpats, None)) => {\n+                lpats.len() == rpats.len() && lpats.iter().zip(rpats.iter()).all(|(x, y)| x.can_also_match(y))\n+            },\n+            (Self::Slice(pats, None), Self::Slice(front, Some(back)))\n+            | (Self::Slice(front, Some(back)), Self::Slice(pats, None)) => {\n+                if pats.len() < front.len() + back.len() {\n+                    return false;\n+                }\n+                pats[..front.len()]\n+                    .iter()\n+                    .zip(front.iter())\n+                    .chain(pats[pats.len() - back.len()..].iter().zip(back.iter()))\n+                    .all(|(x, y)| x.can_also_match(y))\n+            },\n+            (Self::Slice(lfront, Some(lback)), Self::Slice(rfront, Some(rback))) => lfront\n+                .iter()\n+                .zip(rfront.iter())\n+                .chain(lback.iter().rev().zip(rback.iter().rev()))\n+                .all(|(x, y)| x.can_also_match(y)),\n \n             // Todo: Lit* with Path, Range with Path, LitBytes with Slice, Slice with Slice\n             _ => true,"}]}