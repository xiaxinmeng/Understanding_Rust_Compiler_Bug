{"sha": "807269041437411df49a9a893c86310283d6eb91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwNzI2OTA0MTQzNzQxMWRmNDlhOWE4OTNjODYzMTAyODNkNmViOTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-21T01:16:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-21T01:16:09Z"}, "message": "core::rt: Add bindings for async uv handles", "tree": {"sha": "a7f25859e0aac14cc92ed4b8b4685107087e0888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7f25859e0aac14cc92ed4b8b4685107087e0888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/807269041437411df49a9a893c86310283d6eb91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/807269041437411df49a9a893c86310283d6eb91", "html_url": "https://github.com/rust-lang/rust/commit/807269041437411df49a9a893c86310283d6eb91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/807269041437411df49a9a893c86310283d6eb91/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29d83002a27e6f47759b4a3bfe741fb061107816", "url": "https://api.github.com/repos/rust-lang/rust/commits/29d83002a27e6f47759b4a3bfe741fb061107816", "html_url": "https://github.com/rust-lang/rust/commit/29d83002a27e6f47759b4a3bfe741fb061107816"}], "stats": {"total": 114, "additions": 112, "deletions": 2}, "files": [{"sha": "0d032f512d38be4f7e78165e1fb2a1d474d6ff25", "filename": "src/libcore/rt/uv/async.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/807269041437411df49a9a893c86310283d6eb91/src%2Flibcore%2Frt%2Fuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/807269041437411df49a9a893c86310283d6eb91/src%2Flibcore%2Frt%2Fuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fasync.rs?ref=807269041437411df49a9a893c86310283d6eb91", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use libc::{c_int, c_void};\n+use option::Some;\n+use rt::uv::uvll;\n+use rt::uv::uvll::UV_ASYNC;\n+use rt::uv::{Watcher, Loop, NativeHandle, AsyncCallback, NullCallback};\n+use rt::uv::WatcherInterop;\n+use rt::uv::status_to_maybe_uv_error;\n+\n+pub struct AsyncWatcher(*uvll::uv_async_t);\n+impl Watcher for AsyncWatcher { }\n+\n+impl AsyncWatcher {\n+    fn new(loop_: &mut Loop, cb: AsyncCallback) -> AsyncWatcher {\n+        unsafe {\n+            let handle = uvll::malloc_handle(UV_ASYNC);\n+            assert!(handle.is_not_null());\n+            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n+            watcher.install_watcher_data();\n+            let data = watcher.get_watcher_data();\n+            data.async_cb = Some(cb);\n+            assert_eq!(0, uvll::async_init(loop_.native_handle(), handle, async_cb));\n+            return watcher;\n+        }\n+\n+        extern fn async_cb(handle: *uvll::uv_async_t, status: c_int) {\n+            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n+            let status = status_to_maybe_uv_error(watcher.native_handle(), status);\n+            let data = watcher.get_watcher_data();\n+            let cb = data.async_cb.get_ref();\n+            (*cb)(watcher, status);\n+        }\n+    }\n+\n+    fn send(&mut self) {\n+        unsafe {\n+            let handle = self.native_handle();\n+            uvll::async_send(handle);\n+        }\n+    }\n+\n+    fn close(self, cb: NullCallback) {\n+        let mut this = self;\n+        let data = this.get_watcher_data();\n+        assert!(data.close_cb.is_none());\n+        data.close_cb = Some(cb);\n+\n+        unsafe {\n+            uvll::close(self.native_handle(), close_cb);\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_stream_t) {\n+            let mut watcher: AsyncWatcher = NativeHandle::from_native_handle(handle);\n+            {\n+                let data = watcher.get_watcher_data();\n+                data.close_cb.swap_unwrap()();\n+            }\n+            watcher.drop_watcher_data();\n+            unsafe { uvll::free_handle(handle as *c_void); }\n+        }\n+    }\n+}\n+\n+impl NativeHandle<*uvll::uv_async_t> for AsyncWatcher {\n+    fn from_native_handle(handle: *uvll::uv_async_t) -> AsyncWatcher {\n+        AsyncWatcher(handle)\n+    }\n+    fn native_handle(&self) -> *uvll::uv_async_t {\n+        match self { &AsyncWatcher(ptr) => ptr }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+\n+    use super::*;\n+    use rt::uv::Loop;\n+    use unstable::run_in_bare_thread;\n+    use rt::thread::Thread;\n+    use cell::Cell;\n+\n+    #[test]\n+    fn smoke_test() {\n+        do run_in_bare_thread {\n+            let mut loop_ = Loop::new();\n+            let watcher = AsyncWatcher::new(&mut loop_, |w, _| w.close(||()) );\n+            let watcher_cell = Cell(watcher);\n+            let _thread = do Thread::start {\n+                let mut watcher = watcher_cell.take();\n+                watcher.send();\n+            };\n+            loop_.run();\n+            loop_.close();\n+        }\n+    }\n+}"}, {"sha": "5f9e56608149f80a44ee4b4b82f55321ebc10717", "filename": "src/libcore/rt/uv/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/807269041437411df49a9a893c86310283d6eb91/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/807269041437411df49a9a893c86310283d6eb91/src%2Flibcore%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fmod.rs?ref=807269041437411df49a9a893c86310283d6eb91", "patch": "@@ -57,6 +57,7 @@ pub use self::file::FsRequest;\n pub use self::net::{StreamWatcher, TcpWatcher};\n pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n+pub use self::async::AsyncWatcher;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;\n@@ -68,6 +69,7 @@ pub mod file;\n pub mod net;\n pub mod idle;\n pub mod timer;\n+pub mod async;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -125,6 +127,7 @@ pub type IdleCallback = ~fn(IdleWatcher, Option<UvError>);\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(FsRequest, Option<UvError>);\n pub type TimerCallback = ~fn(TimerWatcher, Option<UvError>);\n+pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n \n \n /// Callbacks used by StreamWatchers, set as custom data on the foreign handle\n@@ -135,7 +138,8 @@ struct WatcherData {\n     close_cb: Option<NullCallback>,\n     alloc_cb: Option<AllocCallback>,\n     idle_cb: Option<IdleCallback>,\n-    timer_cb: Option<TimerCallback>\n+    timer_cb: Option<TimerCallback>,\n+    async_cb: Option<AsyncCallback>\n }\n \n pub trait WatcherInterop {\n@@ -164,7 +168,8 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n                 close_cb: None,\n                 alloc_cb: None,\n                 idle_cb: None,\n-                timer_cb: None\n+                timer_cb: None,\n+                async_cb: None\n             };\n             let data = transmute::<~WatcherData, *c_void>(data);\n             uvll::set_data_for_uv_handle(self.native_handle(), data);"}]}