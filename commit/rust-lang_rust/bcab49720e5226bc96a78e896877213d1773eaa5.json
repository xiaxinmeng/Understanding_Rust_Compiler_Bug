{"sha": "bcab49720e5226bc96a78e896877213d1773eaa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYWI0OTcyMGU1MjI2YmM5NmE3OGU4OTY4NzcyMTNkMTc3M2VhYTU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-02T17:54:46Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-29T16:17:12Z"}, "message": "Remove a lot of methods from BuilderMethods", "tree": {"sha": "145ce0e04444248f3fe9bb50bca3ed16969094ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/145ce0e04444248f3fe9bb50bca3ed16969094ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcab49720e5226bc96a78e896877213d1773eaa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcab49720e5226bc96a78e896877213d1773eaa5", "html_url": "https://github.com/rust-lang/rust/commit/bcab49720e5226bc96a78e896877213d1773eaa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcab49720e5226bc96a78e896877213d1773eaa5/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "794ecd965ab39d767caebd79c0e32702e86a3ff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/794ecd965ab39d767caebd79c0e32702e86a3ff1", "html_url": "https://github.com/rust-lang/rust/commit/794ecd965ab39d767caebd79c0e32702e86a3ff1"}], "stats": {"total": 473, "additions": 213, "deletions": 260}, "files": [{"sha": "ebee3ab6cedaab372000598befd094b35841556f", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 213, "deletions": 213, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/bcab49720e5226bc96a78e896877213d1773eaa5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcab49720e5226bc96a78e896877213d1773eaa5/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=bcab49720e5226bc96a78e896877213d1773eaa5", "patch": "@@ -133,19 +133,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn count_insn(&self, category: &str) {\n-        if self.sess().codegen_stats() {\n-            self.stats.borrow_mut().n_llvm_insns += 1;\n-        }\n-        if self.sess().count_llvm_insns() {\n-            *self.stats\n-                      .borrow_mut()\n-                      .llvm_insns\n-                      .entry(category.to_string())\n-                      .or_insert(0) += 1;\n-        }\n-    }\n-\n     fn set_value_name(&mut self, value: &'ll Value, name: &str) {\n         let cname = SmallCStr::new(name);\n         unsafe {\n@@ -159,12 +146,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n-        unsafe {\n-            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n-        }\n-    }\n-\n     fn ret_void(&mut self) {\n         self.count_insn(\"retvoid\");\n         unsafe {\n@@ -897,17 +878,12 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     /* Miscellaneous instructions */\n-    fn empty_phi(&mut self, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"emptyphi\");\n-        unsafe {\n-            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n-        }\n-    }\n-\n     fn phi(&mut self, ty: &'ll Type, vals: &[&'ll Value], bbs: &[&'ll BasicBlock]) -> &'ll Value {\n-        assert_eq!(vals.len(), bbs.len());\n-        let phi = self.empty_phi(ty);\n         self.count_insn(\"addincoming\");\n+        assert_eq!(vals.len(), bbs.len());\n+        let phi = unsafe {\n+            llvm::LLVMBuildPhi(self.llbuilder, ty, noname())\n+        };\n         unsafe {\n             llvm::LLVMAddIncoming(phi, vals.as_ptr(),\n                                   bbs.as_ptr(),\n@@ -1012,15 +988,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n     }\n \n-    fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"minnum\");\n-        unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n-    }\n-    fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"maxnum\");\n-        unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n-    }\n-\n     fn select(\n         &mut self, cond: &'ll Value,\n         then_val: &'ll Value,\n@@ -1032,39 +999,13 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    #[allow(dead_code)]\n-    fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n-        self.count_insn(\"vaarg\");\n-        unsafe {\n-            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n-        }\n-    }\n-\n     fn extract_element(&mut self, vec: &'ll Value, idx: &'ll Value) -> &'ll Value {\n         self.count_insn(\"extractelement\");\n         unsafe {\n             llvm::LLVMBuildExtractElement(self.llbuilder, vec, idx, noname())\n         }\n     }\n \n-    fn insert_element(\n-        &mut self, vec: &'ll Value,\n-        elt: &'ll Value,\n-        idx: &'ll Value,\n-    ) -> &'ll Value {\n-        self.count_insn(\"insertelement\");\n-        unsafe {\n-            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n-        }\n-    }\n-\n-    fn shuffle_vector(&mut self, v1: &'ll Value, v2: &'ll Value, mask: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"shufflevector\");\n-        unsafe {\n-            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n-        }\n-    }\n-\n     fn vector_splat(&mut self, num_elts: usize, elt: &'ll Value) -> &'ll Value {\n         unsafe {\n             let elt_ty = self.cx.val_ty(elt);\n@@ -1075,81 +1016,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fadd_fast\");\n-        unsafe {\n-            // FIXME: add a non-fast math version once\n-            // https://bugs.llvm.org/show_bug.cgi?id=36732\n-            // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmul_fast\");\n-        unsafe {\n-            // FIXME: add a non-fast math version once\n-            // https://bugs.llvm.org/show_bug.cgi?id=36732\n-            // is fixed.\n-            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.add\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.mul\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.and\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.or\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.xor\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n-    }\n-    fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n-    }\n-    fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n-    }\n-    fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmin_fast\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.fmax_fast\");\n-        unsafe {\n-            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n-            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n-            instr\n-        }\n-    }\n-    fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.min\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n-    }\n-    fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n-        self.count_insn(\"vector.reduce.max\");\n-        unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n-    }\n-\n     fn extract_value(&mut self, agg_val: &'ll Value, idx: u64) -> &'ll Value {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);\n@@ -1177,12 +1043,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn add_clause(&mut self, landing_pad: &'ll Value, clause: &'ll Value) {\n-        unsafe {\n-            llvm::LLVMAddClause(landing_pad, clause);\n-        }\n-    }\n-\n     fn set_cleanup(&mut self, landing_pad: &'ll Value) {\n         self.count_insn(\"setcleanup\");\n         unsafe {\n@@ -1236,14 +1096,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Funclet::new(ret.expect(\"LLVM does not have support for catchpad\"))\n     }\n \n-    fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n-        self.count_insn(\"catchret\");\n-        let ret = unsafe {\n-            llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n-        };\n-        ret.expect(\"LLVM does not have support for catchret\")\n-    }\n-\n     fn catch_switch(\n         &mut self,\n         parent: Option<&'ll Value>,\n@@ -1347,67 +1199,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         }\n     }\n \n-    fn check_store<'b>(&mut self,\n-                       val: &'ll Value,\n-                       ptr: &'ll Value) -> &'ll Value {\n-        let dest_ptr_ty = self.cx.val_ty(ptr);\n-        let stored_ty = self.cx.val_ty(val);\n-        let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);\n-\n-        assert_eq!(self.cx.type_kind(dest_ptr_ty), TypeKind::Pointer);\n-\n-        if dest_ptr_ty == stored_ptr_ty {\n-            ptr\n-        } else {\n-            debug!(\"Type mismatch in store. \\\n-                    Expected {:?}, got {:?}; inserting bitcast\",\n-                   dest_ptr_ty, stored_ptr_ty);\n-            self.bitcast(ptr, stored_ptr_ty)\n-        }\n-    }\n-\n-    fn check_call<'b>(&mut self,\n-                      typ: &str,\n-                      llfn: &'ll Value,\n-                      args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n-        let mut fn_ty = self.cx.val_ty(llfn);\n-        // Strip off pointers\n-        while self.cx.type_kind(fn_ty) == TypeKind::Pointer {\n-            fn_ty = self.cx.element_type(fn_ty);\n-        }\n-\n-        assert!(self.cx.type_kind(fn_ty) == TypeKind::Function,\n-                \"builder::{} not passed a function, but {:?}\", typ, fn_ty);\n-\n-        let param_tys = self.cx.func_params_types(fn_ty);\n-\n-        let all_args_match = param_tys.iter()\n-            .zip(args.iter().map(|&v| self.val_ty(v)))\n-            .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n-\n-        if all_args_match {\n-            return Cow::Borrowed(args);\n-        }\n-\n-        let casted_args: Vec<_> = param_tys.into_iter()\n-            .zip(args.iter())\n-            .enumerate()\n-            .map(|(i, (expected_ty, &actual_val))| {\n-                let actual_ty = self.val_ty(actual_val);\n-                if expected_ty != actual_ty {\n-                    debug!(\"Type mismatch in function call of {:?}. \\\n-                            Expected {:?} for param {}, got {:?}; injecting bitcast\",\n-                           llfn, expected_ty, i, actual_ty);\n-                    self.bitcast(actual_val, expected_ty)\n-                } else {\n-                    actual_val\n-                }\n-            })\n-            .collect();\n-\n-        Cow::Owned(casted_args)\n-    }\n-\n     fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n         self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n     }\n@@ -1509,6 +1300,215 @@ impl StaticBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n }\n \n impl Builder<'a, 'll, 'tcx> {\n+    fn count_insn(&self, category: &str) {\n+        if self.sess().codegen_stats() {\n+            self.stats.borrow_mut().n_llvm_insns += 1;\n+        }\n+        if self.sess().count_llvm_insns() {\n+            *self.stats\n+                      .borrow_mut()\n+                      .llvm_insns\n+                      .entry(category.to_string())\n+                      .or_insert(0) += 1;\n+        }\n+    }\n+\n+    fn position_at_start(&mut self, llbb: &'ll BasicBlock) {\n+        unsafe {\n+            llvm::LLVMRustPositionBuilderAtStart(self.llbuilder, llbb);\n+        }\n+    }\n+\n+    pub fn minnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"minnum\");\n+        unsafe { llvm::LLVMRustBuildMinNum(self.llbuilder, lhs, rhs) }\n+    }\n+\n+    pub fn maxnum(&mut self, lhs: &'ll Value, rhs: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"maxnum\");\n+        unsafe { llvm::LLVMRustBuildMaxNum(self.llbuilder, lhs, rhs) }\n+    }\n+\n+    pub fn insert_element(\n+        &mut self, vec: &'ll Value,\n+        elt: &'ll Value,\n+        idx: &'ll Value,\n+    ) -> &'ll Value {\n+        self.count_insn(\"insertelement\");\n+        unsafe {\n+            llvm::LLVMBuildInsertElement(self.llbuilder, vec, elt, idx, noname())\n+        }\n+    }\n+\n+    pub fn shuffle_vector(\n+        &mut self,\n+        v1: &'ll Value,\n+        v2: &'ll Value,\n+        mask: &'ll Value,\n+    ) -> &'ll Value {\n+        self.count_insn(\"shufflevector\");\n+        unsafe {\n+            llvm::LLVMBuildShuffleVector(self.llbuilder, v1, v2, mask, noname())\n+        }\n+    }\n+\n+    pub fn vector_reduce_fadd_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fadd_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmul_fast(&mut self, acc: &'ll Value, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmul_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_add(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.add\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_mul(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.mul\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_and(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.and\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_or(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.or\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_xor(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.xor\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src) }\n+    }\n+    pub fn vector_reduce_fmin(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmin\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ false) }\n+    }\n+    pub fn vector_reduce_fmax(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmax\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ false) }\n+    }\n+    pub fn vector_reduce_fmin_fast(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmin_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, /*NoNaNs:*/ true);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax_fast(&mut self, src: &'ll Value) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.fmax_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, /*NoNaNs:*/ true);\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_min(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.min\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed) }\n+    }\n+    pub fn vector_reduce_max(&mut self, src: &'ll Value, is_signed: bool) -> &'ll Value {\n+        self.count_insn(\"vector.reduce.max\");\n+        unsafe { llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed) }\n+    }\n+\n+    pub fn add_clause(&mut self, landing_pad: &'ll Value, clause: &'ll Value) {\n+        unsafe {\n+            llvm::LLVMAddClause(landing_pad, clause);\n+        }\n+    }\n+\n+    pub fn catch_ret(&mut self, funclet: &Funclet<'ll>, unwind: &'ll BasicBlock) -> &'ll Value {\n+        self.count_insn(\"catchret\");\n+        let ret = unsafe {\n+            llvm::LLVMRustBuildCatchRet(self.llbuilder, funclet.cleanuppad(), unwind)\n+        };\n+        ret.expect(\"LLVM does not have support for catchret\")\n+    }\n+\n+    fn check_store<'b>(&mut self,\n+                       val: &'ll Value,\n+                       ptr: &'ll Value) -> &'ll Value {\n+        let dest_ptr_ty = self.cx.val_ty(ptr);\n+        let stored_ty = self.cx.val_ty(val);\n+        let stored_ptr_ty = self.cx.type_ptr_to(stored_ty);\n+\n+        assert_eq!(self.cx.type_kind(dest_ptr_ty), TypeKind::Pointer);\n+\n+        if dest_ptr_ty == stored_ptr_ty {\n+            ptr\n+        } else {\n+            debug!(\"Type mismatch in store. \\\n+                    Expected {:?}, got {:?}; inserting bitcast\",\n+                   dest_ptr_ty, stored_ptr_ty);\n+            self.bitcast(ptr, stored_ptr_ty)\n+        }\n+    }\n+\n+    fn check_call<'b>(&mut self,\n+                      typ: &str,\n+                      llfn: &'ll Value,\n+                      args: &'b [&'ll Value]) -> Cow<'b, [&'ll Value]> {\n+        let mut fn_ty = self.cx.val_ty(llfn);\n+        // Strip off pointers\n+        while self.cx.type_kind(fn_ty) == TypeKind::Pointer {\n+            fn_ty = self.cx.element_type(fn_ty);\n+        }\n+\n+        assert!(self.cx.type_kind(fn_ty) == TypeKind::Function,\n+                \"builder::{} not passed a function, but {:?}\", typ, fn_ty);\n+\n+        let param_tys = self.cx.func_params_types(fn_ty);\n+\n+        let all_args_match = param_tys.iter()\n+            .zip(args.iter().map(|&v| self.val_ty(v)))\n+            .all(|(expected_ty, actual_ty)| *expected_ty == actual_ty);\n+\n+        if all_args_match {\n+            return Cow::Borrowed(args);\n+        }\n+\n+        let casted_args: Vec<_> = param_tys.into_iter()\n+            .zip(args.iter())\n+            .enumerate()\n+            .map(|(i, (expected_ty, &actual_val))| {\n+                let actual_ty = self.val_ty(actual_val);\n+                if expected_ty != actual_ty {\n+                    debug!(\"Type mismatch in function call of {:?}. \\\n+                            Expected {:?} for param {}, got {:?}; injecting bitcast\",\n+                           llfn, expected_ty, i, actual_ty);\n+                    self.bitcast(actual_val, expected_ty)\n+                } else {\n+                    actual_val\n+                }\n+            })\n+            .collect();\n+\n+        Cow::Owned(casted_args)\n+    }\n+\n+    pub fn va_arg(&mut self, list: &'ll Value, ty: &'ll Type) -> &'ll Value {\n+        self.count_insn(\"vaarg\");\n+        unsafe {\n+            llvm::LLVMBuildVAArg(self.llbuilder, list, ty, noname())\n+        }\n+    }\n+\n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n         if self.cx.sess().opts.optimize == config::OptLevel::No {\n             return;"}, {"sha": "6dd2a36bf26488755589c75f8f9c4219ae1d141e", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bcab49720e5226bc96a78e896877213d1773eaa5/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcab49720e5226bc96a78e896877213d1773eaa5/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=bcab49720e5226bc96a78e896877213d1773eaa5", "patch": "@@ -13,7 +13,6 @@ use rustc::ty::Ty;\n use rustc::ty::layout::{Align, Size};\n use std::ffi::CStr;\n \n-use std::borrow::Cow;\n use std::ops::Range;\n use syntax::ast::AsmDialect;\n \n@@ -39,11 +38,9 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn cx(&self) -> &Self::CodegenCx;\n     fn llfn(&self) -> Self::Value;\n     fn llbb(&self) -> Self::BasicBlock;\n-    fn count_insn(&self, category: &str);\n \n     fn set_value_name(&mut self, value: Self::Value, name: &str);\n     fn position_at_end(&mut self, llbb: Self::BasicBlock);\n-    fn position_at_start(&mut self, llbb: Self::BasicBlock);\n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);\n     fn br(&mut self, dest: Self::BasicBlock);\n@@ -161,7 +158,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn icmp(&mut self, op: IntPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn fcmp(&mut self, op: RealPredicate, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n \n-    fn empty_phi(&mut self, ty: Self::Type) -> Self::Value;\n     fn phi(\n         &mut self,\n         ty: Self::Type,\n@@ -206,43 +202,15 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         flags: MemFlags,\n     );\n \n-    fn minnum(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n-    fn maxnum(&mut self, lhs: Self::Value, rhs: Self::Value) -> Self::Value;\n     fn select(\n         &mut self,\n         cond: Self::Value,\n         then_val: Self::Value,\n         else_val: Self::Value,\n     ) -> Self::Value;\n \n-    fn va_arg(&mut self, list: Self::Value, ty: Self::Type) -> Self::Value;\n     fn extract_element(&mut self, vec: Self::Value, idx: Self::Value) -> Self::Value;\n-    fn insert_element(\n-        &mut self,\n-        vec: Self::Value,\n-        elt: Self::Value,\n-        idx: Self::Value,\n-    ) -> Self::Value;\n-    fn shuffle_vector(\n-        &mut self,\n-        v1: Self::Value,\n-        v2: Self::Value,\n-        mask: Self::Value,\n-    ) -> Self::Value;\n     fn vector_splat(&mut self, num_elts: usize, elt: Self::Value) -> Self::Value;\n-    fn vector_reduce_fadd_fast(&mut self, acc: Self::Value, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmul_fast(&mut self, acc: Self::Value, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_add(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_mul(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_and(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_or(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_xor(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmin(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmax(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmin_fast(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_fmax_fast(&mut self, src: Self::Value) -> Self::Value;\n-    fn vector_reduce_min(&mut self, src: Self::Value, is_signed: bool) -> Self::Value;\n-    fn vector_reduce_max(&mut self, src: Self::Value, is_signed: bool) -> Self::Value;\n     fn extract_value(&mut self, agg_val: Self::Value, idx: u64) -> Self::Value;\n     fn insert_value(&mut self, agg_val: Self::Value, elt: Self::Value, idx: u64) -> Self::Value;\n \n@@ -252,7 +220,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         pers_fn: Self::Value,\n         num_clauses: usize,\n     ) -> Self::Value;\n-    fn add_clause(&mut self, landing_pad: Self::Value, clause: Self::Value);\n     fn set_cleanup(&mut self, landing_pad: Self::Value);\n     fn resume(&mut self, exn: Self::Value) -> Self::Value;\n     fn cleanup_pad(&mut self, parent: Option<Self::Value>, args: &[Self::Value]) -> Self::Funclet;\n@@ -262,7 +229,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n         unwind: Option<Self::BasicBlock>,\n     ) -> Self::Value;\n     fn catch_pad(&mut self, parent: Self::Value, args: &[Self::Value]) -> Self::Funclet;\n-    fn catch_ret(&mut self, funclet: &Self::Funclet, unwind: Self::BasicBlock) -> Self::Value;\n     fn catch_switch(\n         &mut self,\n         parent: Option<Self::Value>,\n@@ -293,19 +259,6 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn add_incoming_to_phi(&mut self, phi: Self::Value, val: Self::Value, bb: Self::BasicBlock);\n     fn set_invariant_load(&mut self, load: Self::Value);\n \n-    /// Returns the ptr value that should be used for storing `val`.\n-    fn check_store(&mut self, val: Self::Value, ptr: Self::Value) -> Self::Value;\n-\n-    /// Returns the args that should be used for a call to `llfn`.\n-    fn check_call<'b>(\n-        &mut self,\n-        typ: &str,\n-        llfn: Self::Value,\n-        args: &'b [Self::Value],\n-    ) -> Cow<'b, [Self::Value]>\n-    where\n-        [Self::Value]: ToOwned;\n-\n     /// Called for `StorageLive`\n     fn lifetime_start(&mut self, ptr: Self::Value, size: Size);\n "}]}