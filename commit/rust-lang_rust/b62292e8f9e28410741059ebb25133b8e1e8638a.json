{"sha": "b62292e8f9e28410741059ebb25133b8e1e8638a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MjI5MmU4ZjllMjg0MTA3NDEwNTllYmIyNTEzM2I4ZTFlODYzOGE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-12-30T20:18:43Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-01-11T22:33:04Z"}, "message": "basics working", "tree": {"sha": "3b46e66404a6b99040649f46517e0fb965f86fcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b46e66404a6b99040649f46517e0fb965f86fcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b62292e8f9e28410741059ebb25133b8e1e8638a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b62292e8f9e28410741059ebb25133b8e1e8638a", "html_url": "https://github.com/rust-lang/rust/commit/b62292e8f9e28410741059ebb25133b8e1e8638a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b62292e8f9e28410741059ebb25133b8e1e8638a/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c50f996b68e9a24a564de728ffcc13d896afc1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c50f996b68e9a24a564de728ffcc13d896afc1c", "html_url": "https://github.com/rust-lang/rust/commit/2c50f996b68e9a24a564de728ffcc13d896afc1c"}], "stats": {"total": 122, "additions": 117, "deletions": 5}, "files": [{"sha": "6772330e099a1ddc7ad158b6ae56a75c6445d86f", "filename": "crates/ra_hir_def/src/find_path.rs", "status": "modified", "additions": 113, "deletions": 5, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b62292e8f9e28410741059ebb25133b8e1e8638a/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62292e8f9e28410741059ebb25133b8e1e8638a/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Ffind_path.rs?ref=b62292e8f9e28410741059ebb25133b8e1e8638a", "patch": "@@ -4,23 +4,82 @@ use crate::{\n     db::DefDatabase,\n     item_scope::ItemInNs,\n     path::{ModPath, PathKind},\n-    ModuleId,\n+    ModuleId, ModuleDefId,\n };\n+use hir_expand::name::Name;\n \n-pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> ModPath {\n+// TODO handle prelude\n+// TODO handle enum variants\n+// TODO don't import from super imports? or at least deprioritize\n+// TODO use super?\n+// TODO use shortest path\n+// TODO performance / memoize\n+\n+pub fn find_path(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n     // 1. Find all locations that the item could be imported from (i.e. that are visible)\n     //    - this needs to consider other crates, for reexports from transitive dependencies\n     //    - filter by visibility\n     // 2. For each of these, go up the module tree until we find an\n     //    item/module/crate that is already in scope (including because it is in\n     //    the prelude, and including aliases!)\n     // 3. Then select the one that gives the shortest path\n+\n+    // Base cases:\n+\n+    // - if the item is already in scope, return the name under which it is\n     let def_map = db.crate_def_map(from.krate);\n     let from_scope: &crate::item_scope::ItemScope = &def_map.modules[from.local_id].scope;\n     if let Some((name, _)) = from_scope.reverse_get(item) {\n-        return ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]);\n+        return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+    }\n+\n+    // - if the item is the crate root, return `crate`\n+    if item == ItemInNs::Types(ModuleDefId::ModuleId(ModuleId { krate: from.krate, local_id: def_map.root })) {\n+        return Some(ModPath::from_simple_segments(PathKind::Crate, Vec::new()));\n+    }\n+\n+    // - if the item is the crate root of a dependency crate, return the name from the extern prelude\n+    for (name, def_id) in &def_map.extern_prelude {\n+        if item == ItemInNs::Types(*def_id) {\n+            return Some(ModPath::from_simple_segments(PathKind::Plain, vec![name.clone()]));\n+        }\n+    }\n+\n+    // - if the item is in the prelude, return the name from there\n+    // TODO check prelude\n+\n+    // Recursive case:\n+    // - if the item is an enum variant, refer to it via the enum\n+\n+    // - otherwise, look for modules containing (reexporting) it and import it from one of those\n+    let importable_locations = find_importable_locations(db, item, from);\n+    // XXX going in order for now\n+    for (module_id, name) in importable_locations {\n+        // TODO prevent infinite loops\n+        let mut path = match find_path(db, ItemInNs::Types(ModuleDefId::ModuleId(module_id)), from) {\n+            None => continue,\n+            Some(path) => path,\n+        };\n+        path.segments.push(name);\n+        return Some(path);\n+    }\n+    None\n+}\n+\n+fn find_importable_locations(db: &impl DefDatabase, item: ItemInNs, from: ModuleId) -> Vec<(ModuleId, Name)> {\n+    let crate_graph = db.crate_graph();\n+    let mut result = Vec::new();\n+    for krate in Some(from.krate).into_iter().chain(crate_graph.dependencies(from.krate).map(|dep| dep.crate_id)) {\n+        let def_map = db.crate_def_map(krate);\n+        for (local_id, data) in def_map.modules.iter() {\n+            if let Some((name, vis)) = data.scope.reverse_get(item) {\n+                if vis.is_visible_from(db, from) {\n+                    result.push((ModuleId { krate, local_id }, name.clone()));\n+                }\n+            }\n+        }\n     }\n-    todo!()\n+    result\n }\n \n #[cfg(test)]\n@@ -59,7 +118,7 @@ mod tests {\n \n         let found_path = find_path(&db, ItemInNs::Types(resolved), module);\n \n-        assert_eq!(mod_path, found_path);\n+        assert_eq!(found_path, Some(mod_path));\n     }\n \n     #[test]\n@@ -84,6 +143,17 @@ mod tests {\n         check_found_path(code, \"foo::S\");\n     }\n \n+    #[test]\n+    fn crate_root() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod foo;\n+            //- /foo.rs\n+            <|>\n+        \"#;\n+        check_found_path(code, \"crate\");\n+    }\n+\n     #[test]\n     fn same_crate() {\n         let code = r#\"\n@@ -107,6 +177,18 @@ mod tests {\n         check_found_path(code, \"std::S\");\n     }\n \n+    #[test]\n+    fn different_crate_renamed() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            extern crate std as std_renamed;\n+            <|>\n+            //- /std.rs crate:std\n+            pub struct S;\n+        \"#;\n+        check_found_path(code, \"std_renamed::S\");\n+    }\n+\n     #[test]\n     fn same_crate_reexport() {\n         let code = r#\"\n@@ -119,4 +201,30 @@ mod tests {\n         \"#;\n         check_found_path(code, \"bar::S\");\n     }\n+\n+    #[test]\n+    fn same_crate_reexport_rename() {\n+        let code = r#\"\n+            //- /main.rs\n+            mod bar {\n+                mod foo { pub(super) struct S; }\n+                pub(crate) use foo::S as U;\n+            }\n+            <|>\n+        \"#;\n+        check_found_path(code, \"bar::U\");\n+    }\n+\n+    #[test]\n+    fn prelude() {\n+        let code = r#\"\n+            //- /main.rs crate:main deps:std\n+            <|>\n+            //- /std.rs crate:std\n+            pub mod prelude { pub struct S; }\n+            #[prelude_import]\n+            pub use prelude::*;\n+        \"#;\n+        check_found_path(code, \"S\");\n+    }\n }"}, {"sha": "a4d912b99db7e7dff84131c016e5d26639105f6c", "filename": "crates/ra_hir_expand/src/name.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b62292e8f9e28410741059ebb25133b8e1e8638a/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b62292e8f9e28410741059ebb25133b8e1e8638a/crates%2Fra_hir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fname.rs?ref=b62292e8f9e28410741059ebb25133b8e1e8638a", "patch": "@@ -37,6 +37,10 @@ impl Name {\n         Name(Repr::TupleField(idx))\n     }\n \n+    pub fn for_crate_dependency(dep: &ra_db::Dependency) -> Name {\n+        Name::new_text(dep.name.clone())\n+    }\n+\n     /// Shortcut to create inline plain text name\n     const fn new_inline_ascii(text: &[u8]) -> Name {\n         Name::new_text(SmolStr::new_inline_from_ascii(text.len(), text))"}]}