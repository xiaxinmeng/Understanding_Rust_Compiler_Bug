{"sha": "e1926080db954fea5ac6abb75267bde762d478c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxOTI2MDgwZGI5NTRmZWE1YWM2YWJiNzUyNjdiZGU3NjJkNDc4YzU=", "commit": {"author": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-11T15:57:45Z"}, "committer": {"name": "scalexm", "email": "alexandre@scalexm.fr", "date": "2018-10-17T12:09:39Z"}, "message": "Add `FromEnv` for input types in the environment", "tree": {"sha": "aaa1041b3c15da6544dc7fb941dc25a3a3a50ca8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaa1041b3c15da6544dc7fb941dc25a3a3a50ca8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1926080db954fea5ac6abb75267bde762d478c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1926080db954fea5ac6abb75267bde762d478c5", "html_url": "https://github.com/rust-lang/rust/commit/e1926080db954fea5ac6abb75267bde762d478c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1926080db954fea5ac6abb75267bde762d478c5/comments", "author": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scalexm", "id": 1173131, "node_id": "MDQ6VXNlcjExNzMxMzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1173131?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scalexm", "html_url": "https://github.com/scalexm", "followers_url": "https://api.github.com/users/scalexm/followers", "following_url": "https://api.github.com/users/scalexm/following{/other_user}", "gists_url": "https://api.github.com/users/scalexm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scalexm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scalexm/subscriptions", "organizations_url": "https://api.github.com/users/scalexm/orgs", "repos_url": "https://api.github.com/users/scalexm/repos", "events_url": "https://api.github.com/users/scalexm/events{/privacy}", "received_events_url": "https://api.github.com/users/scalexm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079b97c54391af0a589f9dc8e28af56c9c950424", "url": "https://api.github.com/repos/rust-lang/rust/commits/079b97c54391af0a589f9dc8e28af56c9c950424", "html_url": "https://github.com/rust-lang/rust/commit/079b97c54391af0a589f9dc8e28af56c9c950424"}], "stats": {"total": 76, "additions": 69, "deletions": 7}, "files": [{"sha": "b61bc8b4fd952a9820e15dae2df3ac0a8e000cfd", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1926080db954fea5ac6abb75267bde762d478c5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1926080db954fea5ac6abb75267bde762d478c5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e1926080db954fea5ac6abb75267bde762d478c5", "patch": "@@ -377,9 +377,6 @@ define_queries! { <'tcx>\n         // might want to use `reveal_all()` method to change modes.\n         [] fn param_env: ParamEnv(DefId) -> ty::ParamEnv<'tcx>,\n \n-        // Get the chalk-style environment of the given item.\n-        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n-\n         // Trait selection queries. These are best used by invoking `ty.moves_by_default()`,\n         // `ty.is_copy()`, etc, since that will prune the environment where possible.\n         [] fn is_copy_raw: is_copy_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool,\n@@ -669,6 +666,9 @@ define_queries! { <'tcx>\n         [] fn program_clauses_for_env: ProgramClausesForEnv(\n             traits::Environment<'tcx>\n         ) -> Clauses<'tcx>,\n+\n+        // Get the chalk-style environment of the given item.\n+        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n     },\n \n     Linking {"}, {"sha": "1f3fec4699066d4c202fe5a1290c6a7e4e86fa0c", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e1926080db954fea5ac6abb75267bde762d478c5/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1926080db954fea5ac6abb75267bde762d478c5/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=e1926080db954fea5ac6abb75267bde762d478c5", "patch": "@@ -45,7 +45,7 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n \n             // forall<'a, T> { `Outlives(T, 'a) :- FromEnv(&'a T)` }\n             ty::Ref(_region, _sub_ty, ..) => {\n-                // FIXME: we need bound tys in order to write the above rule\n+                // FIXME: we'd need bound tys in order to properly write the above rule\n             }\n \n             ty::Dynamic(..) => {\n@@ -166,8 +166,9 @@ crate fn program_clauses_for_env<'a, 'tcx>(\n \n crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n     use super::{Lower, IntoFromEnvGoal};\n+    use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n \n-    // The environment of an impl Trait type is its defining function's environment\n+    // The environment of an impl Trait type is its defining function's environment.\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n         return environment(tcx, parent);\n     }\n@@ -178,10 +179,71 @@ crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> En\n     \n     let clauses = predicates.into_iter()\n         .map(|predicate| predicate.lower())\n-        .map(|domain_goal| domain_goal.map_bound(|dg| dg.into_from_env_goal()))\n-        .map(|domain_goal| domain_goal.map_bound(|dg| dg.into_program_clause()))\n+        .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_from_env_goal()))\n+        .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_program_clause()))\n+\n+        // `ForAll` because each `domain_goal` is a `PolyDomainGoal` and\n+        // could bound lifetimes.\n         .map(Clause::ForAll);\n     \n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let node = tcx.hir.get(node_id);\n+\n+    let mut is_fn = false;\n+    let mut is_impl = false;\n+    match node {\n+        Node::TraitItem(item) => match item.node {\n+            TraitItemKind::Method(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        Node::ImplItem(item) => match item.node {\n+            ImplItemKind::Method(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        Node::Item(item) => match item.node {\n+            ItemKind::Impl(..) => is_impl = true,\n+            ItemKind::Fn(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        Node::ForeignItem(item) => match item.node {\n+            ForeignItemKind::Fn(..) => is_fn = true,\n+            _ => (),\n+        }\n+\n+        // FIXME: closures?\n+        _ => (),\n+    }\n+\n+    let mut input_tys = FxHashSet::default();\n+\n+    // In an impl, we assume that the receiver type and all its constituents\n+    // are well-formed.\n+    if is_impl {\n+        let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+        input_tys.extend(trait_ref.self_ty().walk());\n+    }\n+\n+    // In an fn, we assume that the arguments and all their constitutents are\n+    // well-formed.\n+    if is_fn {\n+        let fn_sig = tcx.fn_sig(def_id)\n+            .no_late_bound_regions()\n+            .expect(\"only early bound regions\");\n+        input_tys.extend(\n+            fn_sig.inputs().iter().flat_map(|ty| ty.walk())\n+        );\n+    }\n+\n+    let clauses = clauses.chain(\n+        input_tys.into_iter()\n+            .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n+            .map(|domain_goal| domain_goal.into_program_clause())\n+            .map(Clause::Implies)\n+    );\n+    \n     Environment {\n         clauses: tcx.mk_clauses(clauses),\n     }"}]}