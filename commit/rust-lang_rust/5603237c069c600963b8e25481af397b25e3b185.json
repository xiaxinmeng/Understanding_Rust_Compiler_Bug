{"sha": "5603237c069c600963b8e25481af397b25e3b185", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MDMyMzdjMDY5YzYwMDk2M2I4ZTI1NDgxYWYzOTdiMjVlM2IxODU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T12:41:38Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-08T12:41:38Z"}, "message": "Merge #456\n\n456: Move adt to code_model_api r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ee26b6d3dfa3ab9b027e9bf29c981fa823ef74d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee26b6d3dfa3ab9b027e9bf29c981fa823ef74d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5603237c069c600963b8e25481af397b25e3b185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5603237c069c600963b8e25481af397b25e3b185", "html_url": "https://github.com/rust-lang/rust/commit/5603237c069c600963b8e25481af397b25e3b185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5603237c069c600963b8e25481af397b25e3b185/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "3bb1cb7017aab6fddb38eae3ca671ecbdaedb4da", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb1cb7017aab6fddb38eae3ca671ecbdaedb4da", "html_url": "https://github.com/rust-lang/rust/commit/3bb1cb7017aab6fddb38eae3ca671ecbdaedb4da"}, {"sha": "54e5c4f0859ecbac0762051ca680a567c67cff6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/54e5c4f0859ecbac0762051ca680a567c67cff6f", "html_url": "https://github.com/rust-lang/rust/commit/54e5c4f0859ecbac0762051ca680a567c67cff6f"}], "stats": {"total": 255, "additions": 131, "deletions": 124}, "files": [{"sha": "602e7db745db62637412d997c7d9ec71f0a44bde", "filename": "crates/ra_hir/src/adt.rs", "status": "modified", "additions": 30, "deletions": 101, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=5603237c069c600963b8e25481af397b25e3b185", "patch": "@@ -1,93 +1,60 @@\n use std::sync::Arc;\n \n use ra_db::Cancelable;\n-use ra_syntax::ast::{self, NameOwner, StructFlavor};\n+use ra_syntax::ast::{self, NameOwner, StructFlavor, AstNode};\n \n use crate::{\n-    DefId, Name, AsName,\n-    db::HirDatabase,\n+    DefId, Name, AsName, Struct, Enum, VariantData, StructField, HirDatabase, DefKind,\n     type_ref::TypeRef,\n };\n \n-pub struct Struct {\n-    def_id: DefId,\n-}\n-\n impl Struct {\n     pub(crate) fn new(def_id: DefId) -> Self {\n         Struct { def_id }\n     }\n-\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n-    }\n-\n-    pub fn variant_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<VariantData>> {\n-        Ok(db.struct_data(self.def_id)?.variant_data.clone())\n-    }\n-\n-    pub fn struct_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<StructData>> {\n-        Ok(db.struct_data(self.def_id)?)\n-    }\n-\n-    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n-        Ok(db.struct_data(self.def_id)?.name.clone())\n-    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n-    name: Option<Name>,\n-    variant_data: Arc<VariantData>,\n+    pub(crate) name: Option<Name>,\n+    pub(crate) variant_data: Arc<VariantData>,\n }\n \n impl StructData {\n-    pub(crate) fn new(struct_def: &ast::StructDef) -> StructData {\n+    fn new(struct_def: &ast::StructDef) -> StructData {\n         let name = struct_def.name().map(|n| n.as_name());\n         let variant_data = VariantData::new(struct_def.flavor());\n         let variant_data = Arc::new(variant_data);\n         StructData { name, variant_data }\n     }\n \n-    pub fn name(&self) -> Option<&Name> {\n-        self.name.as_ref()\n-    }\n-\n-    pub fn variant_data(&self) -> &Arc<VariantData> {\n-        &self.variant_data\n+    pub(crate) fn struct_data_query(\n+        db: &impl HirDatabase,\n+        def_id: DefId,\n+    ) -> Cancelable<Arc<StructData>> {\n+        let def_loc = def_id.loc(db);\n+        assert!(def_loc.kind == DefKind::Struct);\n+        let syntax = db.file_item(def_loc.source_item_id);\n+        let struct_def =\n+            ast::StructDef::cast(&syntax).expect(\"struct def should point to StructDef node\");\n+        Ok(Arc::new(StructData::new(struct_def)))\n     }\n }\n \n-pub struct Enum {\n-    def_id: DefId,\n-}\n-\n impl Enum {\n     pub(crate) fn new(def_id: DefId) -> Self {\n         Enum { def_id }\n     }\n-\n-    pub fn def_id(&self) -> DefId {\n-        self.def_id\n-    }\n-\n-    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n-        Ok(db.enum_data(self.def_id)?.name.clone())\n-    }\n-\n-    pub fn variants(&self, db: &impl HirDatabase) -> Cancelable<Vec<(Name, Arc<VariantData>)>> {\n-        Ok(db.enum_data(self.def_id)?.variants.clone())\n-    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n-    name: Option<Name>,\n-    variants: Vec<(Name, Arc<VariantData>)>,\n+    pub(crate) name: Option<Name>,\n+    pub(crate) variants: Vec<(Name, Arc<VariantData>)>,\n }\n \n impl EnumData {\n-    pub(crate) fn new(enum_def: &ast::EnumDef) -> Self {\n+    fn new(enum_def: &ast::EnumDef) -> Self {\n         let name = enum_def.name().map(|n| n.as_name());\n         let variants = if let Some(evl) = enum_def.variant_list() {\n             evl.variants()\n@@ -103,34 +70,21 @@ impl EnumData {\n         };\n         EnumData { name, variants }\n     }\n-}\n-\n-/// A single field of an enum variant or struct\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct StructField {\n-    name: Name,\n-    type_ref: TypeRef,\n-}\n \n-impl StructField {\n-    pub fn name(&self) -> Name {\n-        self.name.clone()\n+    pub(crate) fn enum_data_query(\n+        db: &impl HirDatabase,\n+        def_id: DefId,\n+    ) -> Cancelable<Arc<EnumData>> {\n+        let def_loc = def_id.loc(db);\n+        assert!(def_loc.kind == DefKind::Enum);\n+        let syntax = db.file_item(def_loc.source_item_id);\n+        let enum_def = ast::EnumDef::cast(&syntax).expect(\"enum def should point to EnumDef node\");\n+        Ok(Arc::new(EnumData::new(enum_def)))\n     }\n-    pub fn type_ref(&self) -> &TypeRef {\n-        &self.type_ref\n-    }\n-}\n-\n-/// Fields of an enum variant or struct\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum VariantData {\n-    Struct(Vec<StructField>),\n-    Tuple(Vec<StructField>),\n-    Unit,\n }\n \n impl VariantData {\n-    pub fn new(flavor: StructFlavor) -> Self {\n+    fn new(flavor: StructFlavor) -> Self {\n         match flavor {\n             StructFlavor::Tuple(fl) => {\n                 let fields = fl\n@@ -160,32 +114,7 @@ impl VariantData {\n     pub(crate) fn get_field_type_ref(&self, field_name: &Name) -> Option<&TypeRef> {\n         self.fields()\n             .iter()\n-            .find(|f| f.name == *field_name)\n-            .map(|f| &f.type_ref)\n-    }\n-\n-    pub fn fields(&self) -> &[StructField] {\n-        match *self {\n-            VariantData::Struct(ref fields) | VariantData::Tuple(ref fields) => fields,\n-            _ => &[],\n-        }\n-    }\n-    pub fn is_struct(&self) -> bool {\n-        match self {\n-            VariantData::Struct(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_tuple(&self) -> bool {\n-        match self {\n-            VariantData::Tuple(..) => true,\n-            _ => false,\n-        }\n-    }\n-    pub fn is_unit(&self) -> bool {\n-        match self {\n-            VariantData::Unit => true,\n-            _ => false,\n-        }\n+            .find(|f| f.name() == field_name)\n+            .map(|f| f.type_ref())\n     }\n }"}, {"sha": "f06f1ae663471ac4f1177d7193426538aff68c10", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 97, "deletions": 1, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=5603237c069c600963b8e25481af397b25e3b185", "patch": "@@ -1,8 +1,15 @@\n+use std::sync::Arc;\n+\n use relative_path::RelativePathBuf;\n use ra_db::{CrateId, Cancelable, FileId};\n use ra_syntax::{ast, TreePtr, SyntaxNode};\n \n-use crate::{Name, db::HirDatabase, DefId, Path, PerNs, nameres::ModuleScope};\n+use crate::{\n+    Name, DefId, Path, PerNs,\n+    type_ref::TypeRef,\n+    nameres::ModuleScope,\n+    db::HirDatabase,\n+};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -111,3 +118,92 @@ impl Module {\n         self.problems_impl(db)\n     }\n }\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StructField {\n+    pub(crate) name: Name,\n+    pub(crate) type_ref: TypeRef,\n+}\n+\n+impl StructField {\n+    pub fn name(&self) -> &Name {\n+        &self.name\n+    }\n+    pub fn type_ref(&self) -> &TypeRef {\n+        &self.type_ref\n+    }\n+}\n+\n+/// Fields of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum VariantData {\n+    Struct(Vec<StructField>),\n+    Tuple(Vec<StructField>),\n+    Unit,\n+}\n+\n+impl VariantData {\n+    pub fn fields(&self) -> &[StructField] {\n+        match self {\n+            VariantData::Struct(fields) | VariantData::Tuple(fields) => fields,\n+            _ => &[],\n+        }\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        match self {\n+            VariantData::Struct(..) => true,\n+            _ => false,\n+        }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        match self {\n+            VariantData::Tuple(..) => true,\n+            _ => false,\n+        }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        match self {\n+            VariantData::Unit => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Struct {\n+    pub(crate) def_id: DefId,\n+}\n+\n+impl Struct {\n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n+        Ok(db.struct_data(self.def_id)?.name.clone())\n+    }\n+\n+    pub fn variant_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<VariantData>> {\n+        Ok(db.struct_data(self.def_id)?.variant_data.clone())\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Enum {\n+    pub(crate) def_id: DefId,\n+}\n+\n+impl Enum {\n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<Name>> {\n+        Ok(db.enum_data(self.def_id)?.name.clone())\n+    }\n+\n+    pub fn variants(&self, db: &impl HirDatabase) -> Cancelable<Vec<(Name, Arc<VariantData>)>> {\n+        Ok(db.enum_data(self.def_id)?.variants.clone())\n+    }\n+}"}, {"sha": "bb4fb3d6637bfa59401522236fe17bc55b6ffa62", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=5603237c069c600963b8e25481af397b25e3b185", "patch": "@@ -38,12 +38,12 @@ pub trait HirDatabase: SyntaxDatabase\n \n     fn struct_data(def_id: DefId) -> Cancelable<Arc<StructData>> {\n         type StructDataQuery;\n-        use fn query_definitions::struct_data;\n+        use fn crate::adt::StructData::struct_data_query;\n     }\n \n     fn enum_data(def_id: DefId) -> Cancelable<Arc<EnumData>> {\n         type EnumDataQuery;\n-        use fn query_definitions::enum_data;\n+        use fn crate::adt::EnumData::enum_data_query;\n     }\n \n     fn infer(def_id: DefId) -> Cancelable<Arc<InferenceResult>> {"}, {"sha": "cd04575d17edd3001d232fe9b2a03477838e2dee", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=5603237c069c600963b8e25481af397b25e3b185", "patch": "@@ -50,7 +50,6 @@ pub use self::{\n     module_tree::ModuleId,\n     nameres::{ItemMap, PerNs, Namespace, Resolution},\n     function::{Function, FnSignature, FnScopes, ScopesWithSyntaxMapping},\n-    adt::{Struct, Enum},\n     ty::Ty,\n     impl_block::{ImplBlock, ImplItem},\n };\n@@ -60,6 +59,7 @@ pub use self::function::FnSignatureInfo;\n pub use self::code_model_api::{\n     Crate, CrateDependency,\n     Module, ModuleSource, Problem,\n+    Struct, Enum, VariantData, StructField,\n };\n \n pub enum Def {"}, {"sha": "ab4e6e629f118f07765a8f0f33b3b8786076bfc8", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5603237c069c600963b8e25481af397b25e3b185/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=5603237c069c600963b8e25481af397b25e3b185", "patch": "@@ -11,13 +11,12 @@ use ra_syntax::{\n use ra_db::{SourceRootId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, DefId, HirFileId, ModuleSource,\n+    SourceFileItems, SourceItemId, DefId, HirFileId, ModuleSource,\n     MacroCallLoc,\n     db::HirDatabase,\n     function::FnScopes,\n     module_tree::ModuleId,\n     nameres::{InputModuleItems, ItemMap, Resolver},\n-    adt::{StructData, EnumData},\n };\n \n pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<FnScopes>> {\n@@ -26,23 +25,6 @@ pub(super) fn fn_scopes(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<\n     Ok(Arc::new(res))\n }\n \n-pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<StructData>> {\n-    let def_loc = def_id.loc(db);\n-    assert!(def_loc.kind == DefKind::Struct);\n-    let syntax = db.file_item(def_loc.source_item_id);\n-    let struct_def =\n-        ast::StructDef::cast(&syntax).expect(\"struct def should point to StructDef node\");\n-    Ok(Arc::new(StructData::new(struct_def)))\n-}\n-\n-pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<EnumData>> {\n-    let def_loc = def_id.loc(db);\n-    assert!(def_loc.kind == DefKind::Enum);\n-    let syntax = db.file_item(def_loc.source_item_id);\n-    let enum_def = ast::EnumDef::cast(&syntax).expect(\"enum def should point to EnumDef node\");\n-    Ok(Arc::new(EnumData::new(enum_def)))\n-}\n-\n pub(super) fn file_items(db: &impl HirDatabase, file_id: HirFileId) -> Arc<SourceFileItems> {\n     let source_file = db.hir_source_file(file_id);\n     let res = SourceFileItems::new(file_id, &source_file);"}]}