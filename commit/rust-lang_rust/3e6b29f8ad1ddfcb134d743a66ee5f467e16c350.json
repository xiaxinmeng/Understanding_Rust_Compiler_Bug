{"sha": "3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNmIyOWY4YWQxZGRmY2IxMzRkNzQzYTY2ZWU1ZjQ2N2UxNmMzNTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-28T03:11:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-28T03:11:48Z"}, "message": "auto merge of #20136 : eddyb/rust/format-args, r=alexcrichton\n\nWe have the technology: no longer do you need to write closures to use `format_args!`.\r\nThis is a `[breaking-change]`, as it forces you to clean up old hacks - if you had code like this:\r\n```rust\r\nformat_args!(fmt::format, \"{} {} {}\", a, b, c)\r\nformat_args!(|args| { w.write_fmt(args) }, \"{} {} {}\", x, y, z)\r\n```\r\nchange it to this: \r\n```rust\r\nfmt::format(format_args!(\"{} {} {}\", a, b, c))\r\nw.write_fmt(format_args!(\"{} {} {}\", x, y, z))\r\n```\r\nTo allow them to be called with `format_args!(...)` directly, several functions were modified to\r\ntake `fmt::Arguments` by value instead of by reference. Also, `fmt::Arguments` derives `Copy`\r\nnow in order to preserve all usecases that were previously possible.", "tree": {"sha": "dfd36279301f37402264995a2d25a5d21eb38464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfd36279301f37402264995a2d25a5d21eb38464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "html_url": "https://github.com/rust-lang/rust/commit/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "070ab63807dc80fa6a6c5ee80531284761ab42de", "url": "https://api.github.com/repos/rust-lang/rust/commits/070ab63807dc80fa6a6c5ee80531284761ab42de", "html_url": "https://github.com/rust-lang/rust/commit/070ab63807dc80fa6a6c5ee80531284761ab42de"}, {"sha": "647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "html_url": "https://github.com/rust-lang/rust/commit/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc"}], "stats": {"total": 964, "additions": 726, "deletions": 238}, "files": [{"sha": "9460b9a8966468f40dccd332fa2c25c0f8178624", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -945,6 +945,15 @@ pub trait ToString {\n }\n \n impl<T: fmt::Show> ToString for T {\n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    fn to_string(&self) -> String {\n+        let mut buf = Vec::<u8>::new();\n+        let _ = fmt::write(&mut buf, format_args!(\"{}\", *self));\n+        String::from_utf8(buf).unwrap()\n+    }\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     fn to_string(&self) -> String {\n         let mut buf = Vec::<u8>::new();\n         let _ = format_args!(|args| fmt::write(&mut buf, args), \"{}\", self);"}, {"sha": "47701ab8ffd638ce7db4a52ec1ff042430b0fcae", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -325,6 +325,13 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let mut filler = Filler { buf: &mut buf, end: &mut end };\n             match sign {\n+                // NOTE(stage0): Remove cfg after a snapshot\n+                #[cfg(not(stage0))]\n+                SignNeg => {\n+                    let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n+                }\n+                // NOTE(stage0): Remove match arm after a snapshot\n+                #[cfg(stage0)]\n                 SignNeg => {\n                     let _ = format_args!(|args| {\n                         fmt::write(&mut filler, args)"}, {"sha": "b050b98de2f81ac60f193416c4b0485a055f4acc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -70,6 +70,16 @@ pub trait FormatWriter {\n     /// This function will return an instance of `FormatError` on error.\n     fn write(&mut self, bytes: &[u8]) -> Result;\n \n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    /// Glue for usage of the `write!` macro with implementers of this trait.\n+    ///\n+    /// This method should generally not be invoked manually, but rather through\n+    /// the `write!` macro itself.\n+    fn write_fmt(&mut self, args: Arguments) -> Result { write(self, args) }\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n@@ -180,6 +190,7 @@ impl<'a> Arguments<'a> {\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n #[stable]\n+#[deriving(Copy)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n     pieces: &'a [&'a str],\n@@ -193,6 +204,14 @@ pub struct Arguments<'a> {\n }\n \n impl<'a> Show for Arguments<'a> {\n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, *self)\n+    }\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, self)\n     }\n@@ -268,6 +287,63 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n     }\n };\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The `write` function takes an output stream, a precompiled format string,\n+/// and a list of arguments. The arguments will be formatted according to the\n+/// specified format string into the output stream provided.\n+///\n+/// # Arguments\n+///\n+///   * output - the buffer to write output to\n+///   * args - the precompiled arguments generated by `format_args!`\n+#[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n+                  implementation detail which should not otherwise be exported\"]\n+pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: rt::AlignUnknown,\n+        fill: ' ',\n+        args: args.args,\n+        curarg: args.args.iter(),\n+    };\n+\n+    let mut pieces = args.pieces.iter();\n+\n+    match args.fmt {\n+        None => {\n+            // We can use default formatting parameters for all arguments.\n+            for _ in range(0, args.args.len()) {\n+                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n+                try!(formatter.run(&DEFAULT_ARGUMENT));\n+            }\n+        }\n+        Some(fmt) => {\n+            // Every spec has a corresponding argument that is preceded by\n+            // a string piece.\n+            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n+                try!(formatter.buf.write(piece.as_bytes()));\n+                try!(formatter.run(arg));\n+            }\n+        }\n+    }\n+\n+    // There can be only one trailing string piece left.\n+    match pieces.next() {\n+        Some(piece) => {\n+            try!(formatter.buf.write(piece.as_bytes()));\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -527,6 +603,16 @@ impl<'a> Formatter<'a> {\n         self.buf.write(data)\n     }\n \n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    /// Writes some formatted information into this instance\n+    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n+        write(self.buf, fmt)\n+    }\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     /// Writes some formatted information into this instance\n     #[unstable = \"reconciling core and I/O may alter this definition\"]\n     pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {"}, {"sha": "6d0d6e0817abd1fcf86e0a02c3a526d63df769aa", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -39,7 +39,7 @@\n //!   distribution.\n //!\n //! * `rust_begin_unwind` - This function takes three arguments, a\n-//!   `&fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n+//!   `fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n //!   the panic message, the file at which panic was invoked, and the line.\n //!   It is up to consumers of this core library to define this panic\n //!   function; it is only required to never return."}, {"sha": "2cd9e7c45098ea82425f62351e62b13dc423e98d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -10,6 +10,30 @@\n \n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Entry point of task panic, for details, see std::macros\n+#[macro_export]\n+macro_rules! panic {\n+    () => (\n+        panic!(\"explicit panic\")\n+    );\n+    ($msg:expr) => ({\n+        static _MSG_FILE_LINE: (&'static str, &'static str, uint) = ($msg, file!(), line!());\n+        ::core::panicking::panic(&_MSG_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::core::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+    });\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n@@ -105,6 +129,16 @@ macro_rules! try {\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Writing a formatted string into a writer\n+#[macro_export]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Writing a formatted string into a writer\n #[macro_export]\n macro_rules! write {"}, {"sha": "32f09a4c17f3c64a15e768d48284f0fdba1861c3", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -16,7 +16,7 @@\n //! interface for panicking is:\n //!\n //! ```ignore\n-//! fn panic_impl(fmt: &fmt::Arguments, &(&'static str, uint)) -> !;\n+//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, uint)) -> !;\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n@@ -31,8 +31,20 @@\n #![allow(dead_code, missing_docs)]\n \n use fmt;\n-use intrinsics;\n+// NOTE(stage0): Remove import after a snapshot\n+#[cfg(stage0)] use intrinsics;\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)] // this is the slow path, always\n+#[lang=\"panic\"]\n+pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n+    let (expr, file, line) = *expr_file_line;\n+    panic_fmt(format_args!(\"{}\", expr), &(file, line))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"panic\"]\n pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n@@ -45,6 +57,18 @@ pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n     unsafe { intrinsics::abort() }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)]\n+#[lang=\"panic_bounds_check\"]\n+fn panic_bounds_check(file_line: &(&'static str, uint),\n+                     index: uint, len: uint) -> ! {\n+    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n+                           len, index), file_line)\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n #[cold] #[inline(never)]\n #[lang=\"panic_bounds_check\"]\n fn panic_bounds_check(file_line: &(&'static str, uint),\n@@ -55,6 +79,21 @@ fn panic_bounds_check(file_line: &(&'static str, uint),\n     unsafe { intrinsics::abort() }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)]\n+pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+    #[allow(improper_ctypes)]\n+    extern {\n+        #[lang = \"panic_fmt\"]\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: uint) -> !;\n+    }\n+    let (file, line) = *file_line;\n+    unsafe { panic_impl(fmt, file, line) }\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     #[allow(improper_ctypes)]"}, {"sha": "1d865868f18834f75196366becf74a4a9bdbdec1", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -268,6 +268,8 @@ impl Drop for DefaultLogger {\n     }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n /// This function is called directly by the compiler when using the logging\n /// macros. This function does not take into account whether the log level\n /// specified is active or not, it will always log something if this method is\n@@ -276,7 +278,7 @@ impl Drop for DefaultLogger {\n /// It is not recommended to call this function directly, rather it should be\n /// invoked through the logging family of macros.\n #[doc(hidden)]\n-pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n+pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n@@ -302,6 +304,42 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     set_logger(logger);\n }\n \n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n+/// This function is called directly by the compiler when using the logging\n+/// macros. This function does not take into account whether the log level\n+/// specified is active or not, it will always log something if this method is\n+/// called.\n+///\n+/// It is not recommended to call this function directly, rather it should be\n+/// invoked through the logging family of macros.\n+#[doc(hidden)]\n+pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n+    // Test the literal string from args against the current filter, if there\n+    // is one.\n+    match unsafe { FILTER.as_ref() } {\n+        Some(filter) if !filter.is_match(args.to_string().as_slice()) => return,\n+        _ => {}\n+    }\n+\n+    // Completely remove the local logger from TLS in case anyone attempts to\n+    // frob the slot while we're doing the logging. This will destroy any logger\n+    // set during logging.\n+    let mut logger = LOCAL_LOGGER.with(|s| {\n+        s.borrow_mut().take()\n+    }).unwrap_or_else(|| {\n+        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n+    });\n+    logger.log(&LogRecord {\n+        level: LogLevel(level),\n+        args: *args,\n+        file: loc.file,\n+        module_path: loc.module_path,\n+        line: loc.line,\n+    });\n+    set_logger(logger);\n+}\n+\n /// Getter for the global log level. This is a function so that it can be called\n /// safely\n #[doc(hidden)]\n@@ -329,7 +367,7 @@ pub struct LogRecord<'a> {\n     pub level: LogLevel,\n \n     /// The arguments from the log line.\n-    pub args: &'a fmt::Arguments<'a>,\n+    pub args: fmt::Arguments<'a>,\n \n     /// The file of where the LogRecord originated.\n     pub file: &'a str,"}, {"sha": "2e8302cc10f9aa794bdc49594f5d6bcb47f37c00", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -12,6 +12,63 @@\n \n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The standard logging macro\n+///\n+/// This macro will generically log over a provided level (of type u32) with a\n+/// format!-based argument list. See documentation in `std::fmt` for details on\n+/// how to use the syntax.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(phase)]\n+/// #[phase(plugin, link)] extern crate log;\n+///\n+/// fn main() {\n+///     log!(log::WARN, \"this is a warning {}\", \"message\");\n+///     log!(log::DEBUG, \"this is a debug message\");\n+///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=warn ./main\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=6 ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// 6:main: this is a custom logging level: 6\n+/// ```\n+#[macro_export]\n+macro_rules! log {\n+    ($lvl:expr, $($arg:tt)+) => ({\n+        static LOC: ::log::LogLocation = ::log::LogLocation {\n+            line: line!(),\n+            file: file!(),\n+            module_path: module_path!(),\n+        };\n+        let lvl = $lvl;\n+        if log_enabled!(lvl) {\n+            ::log::log(lvl, &LOC, format_args!($($arg)+))\n+        }\n+    })\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// The standard logging macro\n ///\n /// This macro will generically log over a provided level (of type u32) with a"}, {"sha": "b75cf9a196b507e87e936df574879b92bae7f6ae", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -16,13 +16,6 @@\n //! This macro is implemented in the compiler to emit calls to this module in\n //! order to format arguments at runtime into strings and streams.\n //!\n-//! The functions contained in this module should not normally be used in\n-//! everyday use cases of `format!`. The assumptions made by these functions are\n-//! unsafe for all inputs, and the compiler performs a large amount of\n-//! validation on the arguments to `format!` in order to ensure safety at\n-//! runtime. While it is possible to call these functions directly, it is not\n-//! recommended to do so in the general case.\n-//!\n //! ## Usage\n //!\n //! The `format!` macro is intended to be familiar to those coming from C's\n@@ -275,35 +268,28 @@\n //!\n //! # #[allow(unused_must_use)]\n //! # fn main() {\n-//! format_args!(fmt::format, \"this returns {}\", \"String\");\n+//! fmt::format(format_args!(\"this returns {}\", \"String\"));\n //!\n //! let some_writer: &mut io::Writer = &mut io::stdout();\n-//! format_args!(|args| { write!(some_writer, \"{}\", args) },\n-//!              \"print with a {}\", \"closure\");\n+//! write!(some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n //!\n-//! fn my_fmt_fn(args: &fmt::Arguments) {\n+//! fn my_fmt_fn(args: fmt::Arguments) {\n //!     write!(&mut io::stdout(), \"{}\", args);\n //! }\n-//! format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n+//! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n //! # }\n //! ```\n //!\n-//! The first argument of the `format_args!` macro is a function (or closure)\n-//! which takes one argument of type `&fmt::Arguments`. This structure can then\n-//! be passed to the `write` and `format` functions inside this module in order\n-//! to process the format string. The goal of this macro is to even further\n-//! prevent intermediate allocations when dealing formatting strings.\n+//! The result of the `format_args!` macro is a value of type `fmt::Arguments`.\n+//! This structure can then be passed to the `write` and `format` functions\n+//! inside this module in order to process the format string.\n+//! The goal of this macro is to even further prevent intermediate allocations\n+//! when dealing formatting strings.\n //!\n //! For example, a logging library could use the standard formatting syntax, but\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! It is unsafe to programmatically create an instance of `fmt::Arguments`\n-//! because the operations performed when executing a format string require the\n-//! compile-time checks provided by the compiler. The `format_args!` macro is\n-//! the only method of safely creating these structures, but they can be\n-//! unsafely created with the constructor provided.\n-//!\n //! ## Syntax\n //!\n //! The syntax for the formatting language used is drawn from other languages,\n@@ -420,14 +406,39 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n #[doc(hidden)]\n pub use core::fmt::{argument, argumentuint};\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The format function takes a precompiled format string and a list of\n+/// arguments, to return the resulting formatted string.\n+///\n+/// # Arguments\n+///\n+///   * args - a structure of arguments generated via the `format_args!` macro.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fmt;\n+///\n+/// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n+/// assert_eq!(s, \"Hello, world!\".to_string());\n+/// ```\n+#[experimental = \"this is an implementation detail of format! and should not \\\n+                  be called directly\"]\n+pub fn format(args: Arguments) -> string::String {\n+    let mut output = Vec::new();\n+    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n+    string::String::from_utf8(output).unwrap()\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n /// # Arguments\n ///\n ///   * args - a structure of arguments generated via the `format_args!` macro.\n-///            Because this structure can only be safely generated at\n-///            compile-time, this function is safe.\n ///\n /// # Example\n ///"}, {"sha": "b6f8bb25b65312adabedba8ead94e7c61827e037", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -1017,6 +1017,48 @@ pub trait Writer {\n     /// decide whether their stream needs to be buffered or not.\n     fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    /// Writes a formatted string into this writer, returning any error\n+    /// encountered.\n+    ///\n+    /// This method is primarily used to interface with the `format_args!`\n+    /// macro, but it is rare that this should explicitly be called. The\n+    /// `write!` macro should be favored to invoke this method instead.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return any I/O error reported while formatting.\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n+        // Create a shim which translates a Writer to a FormatWriter and saves\n+        // off I/O errors. instead of discarding them\n+        struct Adaptor<'a, T:'a> {\n+            inner: &'a mut T,\n+            error: IoResult<()>,\n+        }\n+\n+        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n+            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+                match self.inner.write(bytes) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::Error)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut output = Adaptor { inner: self, error: Ok(()) };\n+        match fmt::write(&mut output, fmt) {\n+            Ok(()) => Ok(()),\n+            Err(..) => output.error\n+        }\n+    }\n+\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///"}, {"sha": "6bd721599f341df1d2ed49777ed3ad419717f31a", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -378,12 +378,32 @@ pub fn println(s: &str) {\n     })\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n+/// with the `format_args!` macro.\n+pub fn print_args(fmt: fmt::Arguments) {\n+    with_task_stdout(|io| write!(io, \"{}\", fmt))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n     with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Similar to `println`, but takes a `fmt::Arguments` structure to be\n+/// compatible with the `format_args!` macro.\n+pub fn println_args(fmt: fmt::Arguments) {\n+    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {"}, {"sha": "edb6218c5cc0beb25a9971fe0e491b607965d717", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 126, "deletions": 10, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -17,6 +17,50 @@\n #![experimental]\n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The entry point for panic of Rust tasks.\n+///\n+/// This macro is used to inject panic into a Rust task, causing the task to\n+/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n+/// the value which is transmitted.\n+///\n+/// The multi-argument form of this macro panics with a string and has the\n+/// `format!` syntax for building a string.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #![allow(unreachable_code)]\n+/// panic!();\n+/// panic!(\"this is a terrible mistake!\");\n+/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// ```\n+#[macro_export]\n+macro_rules! panic {\n+    () => ({\n+        panic!(\"explicit panic\")\n+    });\n+    ($msg:expr) => ({\n+        // static requires less code at runtime, more constant data\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+\n+    });\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// The entry point for panic of Rust tasks.\n ///\n /// This macro is used to inject panic into a Rust task, causing the task to\n@@ -245,6 +289,26 @@ macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! format {\n+    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///\n@@ -263,6 +327,28 @@ macro_rules! format {\n     )\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n /// See `std::fmt` for more information.\n ///\n@@ -294,6 +380,18 @@ macro_rules! writeln {\n     )\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// the end of the message.\n+#[macro_export]\n+#[stable]\n+macro_rules! print {\n+    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -302,6 +400,28 @@ macro_rules! print {\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Macro for printing to a task's stdout handle.\n+///\n+/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// The syntax of this macro is the same as that used for `format!`. For more\n+/// information, see `std::fmt` and `std::io::stdio`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// println!(\"hello there!\");\n+/// println!(\"format {} arguments\", \"some\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! println {\n+    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Macro for printing to a task's stdout handle.\n ///\n /// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n@@ -411,11 +531,10 @@ macro_rules! log {\n pub mod builtin {\n     /// The core macro for formatted string creation & output.\n     ///\n-    /// This macro takes as its first argument a callable expression which will\n-    /// receive as its first argument a value of type `&fmt::Arguments`. This\n-    /// value can be passed to the functions in `std::fmt` for performing useful\n-    /// functions. All other formatting macros (`format!`, `write!`,\n-    /// `println!`, etc) are proxied through this one.\n+    /// This macro produces a value of type `fmt::Arguments`. This value can be\n+    /// passed to the functions in `std::fmt` for performing useful functions.\n+    /// All other formatting macros (`format!`, `write!`, `println!`, etc) are\n+    /// proxied through this one.\n     ///\n     /// For more information, see the documentation in `std::fmt`.\n     ///\n@@ -424,15 +543,12 @@ pub mod builtin {\n     /// ```rust\n     /// use std::fmt;\n     ///\n-    /// let s = format_args!(fmt::format, \"hello {}\", \"world\");\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n     /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n     ///\n-    /// format_args!(|args| {\n-    ///     // pass `args` to another function, etc.\n-    /// }, \"hello {}\", \"world\");\n     /// ```\n     #[macro_export]\n-    macro_rules! format_args { ($closure:expr, $fmt:expr $($args:tt)*) => ({\n+    macro_rules! format_args { ($fmt:expr $($args:tt)*) => ({\n         /* compiler built-in */\n     }) }\n "}, {"sha": "095a27203f9819e28397ddcec446f1b707ad4129", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -15,6 +15,16 @@\n \n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+macro_rules! rterrln {\n+    ($fmt:expr $($arg:tt)*) => ( {\n+        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))\n+    } )\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         format_args!(::rt::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n@@ -40,6 +50,14 @@ macro_rules! rtassert {\n     } )\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+macro_rules! rtabort {\n+    ($($arg:tt)*) => (::rt::util::abort(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rtabort {\n     ($($arg:tt)*) => (format_args!(::rt::util::abort, $($arg)*))\n }"}, {"sha": "261a8335173d0a1315b2d42144f3fd9de69ac38e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -477,14 +477,61 @@ pub mod eabi {\n     }\n }\n \n-// Entry point of panic from the libcore crate\n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n #[cfg(not(test))]\n+/// Entry point of panic from the libcore crate.\n+#[lang = \"panic_fmt\"]\n+pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n+                                file: &'static str, line: uint) -> ! {\n+    begin_unwind_fmt(msg, &(file, line))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n+#[cfg(not(test))]\n+/// Entry point of panic from the libcore crate.\n #[lang = \"panic_fmt\"]\n pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n                                 file: &'static str, line: uint) -> ! {\n     begin_unwind_fmt(msg, &(file, line))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The entry point for unwinding with a formatted message.\n+///\n+/// This is designed to reduce the amount of code required at the call\n+/// site as much as possible (so that `panic!()` has as low an impact\n+/// on (e.g.) the inlining of other functions as possible), by moving\n+/// the actual formatting into this shared place.\n+#[inline(never)] #[cold]\n+pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+    use fmt::FormatWriter;\n+\n+    // We do two allocations here, unfortunately. But (a) they're\n+    // required with the current scheme, and (b) we don't handle\n+    // panic + OOM properly anyway (see comment in begin_unwind\n+    // below).\n+\n+    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n+\n+    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n+        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+            self.v.push_all(buf);\n+            Ok(())\n+        }\n+    }\n+\n+    let mut v = Vec::new();\n+    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n+\n+    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n+    begin_unwind_inner(msg, file_line)\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call"}, {"sha": "26dadfd9fb1db505e68564d0a5fb2c094a6dc835", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -112,12 +112,25 @@ impl fmt::FormatWriter for Stdio {\n     }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+pub fn dumb_print(args: fmt::Arguments) {\n+    let _ = Stderr.write_fmt(args);\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n pub fn dumb_print(args: &fmt::Arguments) {\n     let mut w = Stderr;\n     let _ = write!(&mut w, \"{}\", args);\n }\n \n-pub fn abort(args: &fmt::Arguments) -> ! {\n+// NOTE(stage0): Remove wrappers after a snapshot\n+#[cfg(not(stage0))] pub fn abort(args: fmt::Arguments) -> ! { abort_(&args) }\n+#[cfg(stage0)] pub fn abort(args: &fmt::Arguments) -> ! { abort_(args) }\n+\n+// NOTE(stage0): Change to `pub fn abort(args: fmt::Arguments) -> !` after a snapshot\n+fn abort_(args: &fmt::Arguments) -> ! {\n     use fmt::FormatWriter;\n \n     struct BufWriter<'a> {"}, {"sha": "2788c89676a3a1b83302b8ff3947a3e574a19ac4", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -131,8 +131,10 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!\n-    format::expand_preparsed_format_args(cx, span,\n-                                         format::MethodCall(formatter, meth),\n-                                         format_string, exprs, Vec::new(),\n-                                         HashMap::new())\n+\n+    let args = vec![\n+        format::expand_preparsed_format_args(cx, span, format_string,\n+                                             exprs, vec![], HashMap::new())\n+    ];\n+    cx.expr_method_call(span, formatter, meth, args)\n }"}, {"sha": "6474d92953fd115f569b8d6c7177e384fc6a0c88", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 93, "deletions": 143, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Invocation::*;\n use self::ArgumentType::*;\n use self::Position::*;\n \n@@ -23,17 +22,16 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n-use std::string;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n-    Known(string::String),\n+    Known(String),\n     Unsigned\n }\n \n enum Position {\n     Exact(uint),\n-    Named(string::String),\n+    Named(String),\n }\n \n struct Context<'a, 'b:'a> {\n@@ -48,12 +46,12 @@ struct Context<'a, 'b:'a> {\n     /// Note that we keep a side-array of the ordering of the named arguments\n     /// found to be sure that we can translate them in the same order that they\n     /// were declared in.\n-    names: HashMap<string::String, P<ast::Expr>>,\n-    name_types: HashMap<string::String, ArgumentType>,\n-    name_ordering: Vec<string::String>,\n+    names: HashMap<String, P<ast::Expr>>,\n+    name_types: HashMap<String, ArgumentType>,\n+    name_ordering: Vec<String>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n-    literal: string::String,\n+    literal: String,\n \n     /// Collection of the compiled `rt::Argument` structures\n     pieces: Vec<P<ast::Expr>>,\n@@ -62,62 +60,40 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<string::String, uint>,\n-    method_statics: Vec<P<ast::Item>>,\n+    name_positions: HashMap<String, uint>,\n \n     /// Updated as arguments are consumed or methods are entered\n     nest_level: uint,\n     next_arg: uint,\n }\n \n-pub enum Invocation {\n-    Call(P<ast::Expr>),\n-    MethodCall(P<ast::Expr>, ast::Ident),\n-}\n-\n /// Parses the arguments from the given list of tokens, returning None\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n ///\n-/// If parsing succeeds, the second return value is:\n+/// If parsing succeeds, the return value is:\n ///\n ///     Some((fmtstr, unnamed arguments, ordering of named arguments,\n ///           named arguments))\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n-              tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<string::String>,\n-                            HashMap<string::String, P<ast::Expr>>)>) {\n+fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n+              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n+                         HashMap<String, P<ast::Expr>>)> {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<string::String, P<ast::Expr>>::new();\n+    let mut names = HashMap::<String, P<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n-    // Parse the leading function expression (maybe a block, maybe a path)\n-    let invocation = if allow_method {\n-        let e = p.parse_expr();\n-        if !p.eat(&token::Comma) {\n-            ecx.span_err(sp, \"expected token: `,`\");\n-            return (Call(e), None);\n-        }\n-        MethodCall(e, p.parse_ident())\n-    } else {\n-        Call(p.parse_expr())\n-    };\n-    if !p.eat(&token::Comma) {\n-        ecx.span_err(sp, \"expected token: `,`\");\n-        return (invocation, None);\n-    }\n \n     if p.token == token::Eof {\n         ecx.span_err(sp, \"requires at least a format string argument\");\n-        return (invocation, None);\n+        return None;\n     }\n     let fmtstr = p.parse_expr();\n     let mut named = false;\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n             ecx.span_err(sp, \"expected token: `,`\");\n-            return (invocation, None);\n+            return None;\n         }\n         if p.token == token::Eof { break } // accept trailing commas\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n@@ -131,13 +107,13 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n                     ecx.span_err(p.span,\n                                  \"expected ident, positional arguments \\\n                                  cannot follow named arguments\");\n-                    return (invocation, None);\n+                    return None;\n                 }\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, found `{}`\",\n                                          p.this_token_to_string())[]);\n-                    return (invocation, None);\n+                    return None;\n                 }\n             };\n             let interned_name = token::get_ident(ident);\n@@ -160,7 +136,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n             args.push(p.parse_expr());\n         }\n     }\n-    return (invocation, Some((fmtstr, args, order, names)));\n+    Some((fmtstr, args, order, names))\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n@@ -225,7 +201,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn describe_num_args(&self) -> string::String {\n+    fn describe_num_args(&self) -> String {\n         match self.args.len() {\n             0 => \"no arguments given\".to_string(),\n             1 => \"there is 1 argument\".to_string(),\n@@ -474,70 +450,50 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn item_static_array(ecx: &mut ExtCtxt,\n-                         name: ast::Ident,\n-                         piece_ty: P<ast::Ty>,\n-                         pieces: Vec<P<ast::Expr>>)\n-                         -> P<ast::Stmt> {\n+    fn static_array(ecx: &mut ExtCtxt,\n+                    name: &str,\n+                    piece_ty: P<ast::Ty>,\n+                    pieces: Vec<P<ast::Expr>>)\n+                    -> P<ast::Expr> {\n         let fmtsp = piece_ty.span;\n-        let fmt = ecx.expr_vec(fmtsp, pieces);\n-        let fmt = ecx.expr_addr_of(fmtsp, fmt);\n-        let ty = ast::TyVec(piece_ty);\n-        let ty = ast::TyRptr(Some(ecx.lifetime(fmtsp, special_idents::static_lifetime.name)),\n-                             ast::MutTy{ mutbl: ast::MutImmutable, ty: ecx.ty(fmtsp, ty) });\n-        let ty = ecx.ty(fmtsp, ty);\n-        let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n+        let ty = ecx.ty_rptr(fmtsp,\n+            ecx.ty(fmtsp, ast::TyVec(piece_ty)),\n+            Some(ecx.lifetime(fmtsp, special_idents::static_lifetime.name)),\n+            ast::MutImmutable);\n+        let slice = ecx.expr_vec_slice(fmtsp, pieces);\n+        let st = ast::ItemStatic(ty, ast::MutImmutable, slice);\n+\n+        let name = ecx.ident_of(name);\n         let item = ecx.item(fmtsp, name, Context::static_attrs(ecx, fmtsp), st);\n         let decl = respan(fmtsp, ast::DeclItem(item));\n-        P(respan(fmtsp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n+\n+        // Wrap the declaration in a block so that it forms a single expression.\n+        ecx.expr_block(ecx.block(fmtsp,\n+            vec![P(respan(fmtsp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))],\n+            Some(ecx.expr_ident(fmtsp, name))))\n     }\n \n     /// Actually builds the expression which the iformat! block will be expanded\n     /// to\n-    fn to_expr(mut self, invocation: Invocation) -> P<ast::Expr> {\n-        let mut lets = Vec::new();\n+    fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n         let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n-        // First, declare all of our methods that are statics\n-        for method in self.method_statics.into_iter() {\n-            let decl = respan(self.fmtsp, ast::DeclItem(method));\n-            lets.push(P(respan(self.fmtsp,\n-                               ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID))));\n-        }\n-\n-        // Next, build up the static array which will become our precompiled\n+        // First, build up the static array which will become our precompiled\n         // format \"string\"\n-        let static_str_name = self.ecx.ident_of(\"__STATIC_FMTSTR\");\n-        let static_lifetime = self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"'static\").name);\n+        let static_lifetime = self.ecx.lifetime(self.fmtsp, special_idents::static_lifetime.name);\n         let piece_ty = self.ecx.ty_rptr(\n                 self.fmtsp,\n                 self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n                 Some(static_lifetime),\n                 ast::MutImmutable);\n-        lets.push(Context::item_static_array(self.ecx,\n-                                             static_str_name,\n-                                             piece_ty,\n-                                             self.str_pieces));\n-\n-        // Then, build up the static array which will store our precompiled\n-        // nonstandard placeholders, if there are any.\n-        let static_args_name = self.ecx.ident_of(\"__STATIC_FMTARGS\");\n-        if !self.all_pieces_simple {\n-            let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n-                    self.fmtsp,\n-                    true, Context::rtpath(self.ecx, \"Argument\"),\n-                    vec![static_lifetime],\n-                    vec![],\n-                    vec![]\n-                ));\n-            lets.push(Context::item_static_array(self.ecx,\n-                                                 static_args_name,\n-                                                 piece_ty,\n-                                                 self.pieces));\n-        }\n+        let pieces = Context::static_array(self.ecx,\n+                                           \"__STATIC_FMTSTR\",\n+                                           piece_ty,\n+                                           self.str_pieces);\n+\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -580,71 +536,68 @@ impl<'a, 'b> Context<'a, 'b> {\n         // Now create a vector containing all the arguments\n         let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n \n-        // Now create the fmt::Arguments struct with all our locals we created.\n-        let pieces = self.ecx.expr_ident(self.fmtsp, static_str_name);\n-        let args_slice = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n-\n-        let (fn_name, fn_args) = if self.all_pieces_simple {\n-            (\"new\", vec![pieces, args_slice])\n-        } else {\n-            let fmt = self.ecx.expr_ident(self.fmtsp, static_args_name);\n-            (\"with_placeholders\", vec![pieces, fmt, args_slice])\n-        };\n-\n-        let result = self.ecx.expr_call_global(self.fmtsp, vec!(\n-                self.ecx.ident_of(\"std\"),\n-                self.ecx.ident_of(\"fmt\"),\n-                self.ecx.ident_of(\"Arguments\"),\n-                self.ecx.ident_of(fn_name)), fn_args);\n-\n-        let result = match invocation {\n-            Call(e) => {\n-                let span = e.span;\n-                self.ecx.expr_call(span, e, vec![\n-                    self.ecx.expr_addr_of(span, result)\n-                ])\n-            }\n-            MethodCall(e, m) => {\n-                let span = e.span;\n-                self.ecx.expr_method_call(span, e, m, vec![\n-                    self.ecx.expr_addr_of(span, result)\n-                ])\n-            }\n-        };\n-        let body = self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n-                                                      Some(result)));\n+        let args_array = self.ecx.expr_vec(self.fmtsp, args.collect());\n \n         // Constructs an AST equivalent to:\n         //\n         //      match (&arg0, &arg1) {\n-        //          (tmp0, tmp1) => body\n+        //          (tmp0, tmp1) => args_array\n         //      }\n         //\n         // It was:\n         //\n         //      let tmp0 = &arg0;\n         //      let tmp1 = &arg1;\n-        //      body\n+        //      args_array\n         //\n         // Because of #11585 the new temporary lifetime rule, the enclosing\n         // statements for these temporaries become the let's themselves.\n         // If one or more of them are RefCell's, RefCell borrow() will also\n-        // end there; they don't last long enough for body to use them. The\n-        // match expression solves the scope problem.\n+        // end there; they don't last long enough for args_array to use them.\n+        // The match expression solves the scope problem.\n         //\n         // Note, it may also very well be transformed to:\n         //\n         //      match arg0 {\n         //          ref tmp0 => {\n         //              match arg1 => {\n-        //                  ref tmp1 => body } } }\n+        //                  ref tmp1 => args_array } } }\n         //\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n-        let arm = self.ecx.arm(self.fmtsp, vec!(pat), body);\n+        let arm = self.ecx.arm(self.fmtsp, vec!(pat), args_array);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprTup(heads));\n-        self.ecx.expr_match(self.fmtsp, head, vec!(arm))\n+        let result = self.ecx.expr_match(self.fmtsp, head, vec!(arm));\n+\n+        let args_slice = self.ecx.expr_addr_of(self.fmtsp, result);\n+\n+        // Now create the fmt::Arguments struct with all our locals we created.\n+        let (fn_name, fn_args) = if self.all_pieces_simple {\n+            (\"new\", vec![pieces, args_slice])\n+        } else {\n+            // Build up the static array which will store our precompiled\n+            // nonstandard placeholders, if there are any.\n+            let piece_ty = self.ecx.ty_path(self.ecx.path_all(\n+                    self.fmtsp,\n+                    true, Context::rtpath(self.ecx, \"Argument\"),\n+                    vec![static_lifetime],\n+                    vec![],\n+                    vec![]\n+                ));\n+            let fmt = Context::static_array(self.ecx,\n+                                            \"__STATIC_FMTARGS\",\n+                                            piece_ty,\n+                                            self.pieces);\n+\n+            (\"with_placeholders\", vec![pieces, fmt, args_slice])\n+        };\n+\n+        self.ecx.expr_call_global(self.fmtsp, vec!(\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(\"Arguments\"),\n+                self.ecx.ident_of(fn_name)), fn_args)\n     }\n \n     fn format_arg(ecx: &ExtCtxt, sp: Span,\n@@ -694,24 +647,22 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n                                tts: &[ast::TokenTree])\n                                -> Box<base::MacResult+'cx> {\n \n-    match parse_args(ecx, sp, false, tts) {\n-        (invocation, Some((efmt, args, order, names))) => {\n-            MacExpr::new(expand_preparsed_format_args(ecx, sp, invocation, efmt,\n+    match parse_args(ecx, sp, tts) {\n+        Some((efmt, args, order, names)) => {\n+            MacExpr::new(expand_preparsed_format_args(ecx, sp, efmt,\n                                                       args, order, names))\n         }\n-        (_, None) => MacExpr::new(ecx.expr_uint(sp, 2))\n+        None => DummyResult::expr(sp)\n     }\n }\n \n-/// Take the various parts of `format_args!(extra, efmt, args...,\n-/// name=names...)` and construct the appropriate formatting\n-/// expression.\n+/// Take the various parts of `format_args!(efmt, args..., name=names...)`\n+/// and construct the appropriate formatting expression.\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n-                                    invocation: Invocation,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<string::String>,\n-                                    names: HashMap<string::String, P<ast::Expr>>)\n+                                    name_ordering: Vec<String>,\n+                                    names: HashMap<String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n@@ -724,17 +675,16 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        literal: string::String::new(),\n+        literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n         all_pieces_simple: true,\n-        method_statics: Vec::new(),\n         fmtsp: sp,\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = match expr_to_string(cx.ecx,\n-                                efmt,\n-                                \"format argument must be a string literal.\") {\n+                                   efmt,\n+                                   \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n         None => return DummyResult::raw_expr(sp)\n     };\n@@ -782,5 +732,5 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         }\n     }\n \n-    cx.to_expr(invocation)\n+    cx.into_expr()\n }"}, {"sha": "0aa3c40fa5f88c64b1f38034a28635e5d2ceffe0", "filename": "src/test/compile-fail/dead-code-closure-bang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let x: || -> ! = || panic!();\n     x();\n-    println!(\"Foo bar\"); //~ ERROR: unreachable statement\n+    std::io::println(\"Foo bar\"); //~ ERROR: unreachable statement\n }"}, {"sha": "8bd3cb0f60b04884fe875a3e88c108413d7407d4", "filename": "src/test/compile-fail/ifmt-bad-format-args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    format_args!(\"test\"); //~ ERROR: expected token\n-    format_args!(\"\", || {}); //~ ERROR: must be a string literal\n+    format_args!(); //~ ERROR: requires at least a format string argument\n+    format_args!(|| {}); //~ ERROR: must be a string literal\n }"}, {"sha": "7bb8365bc128ed4c2a1b459a25948ba61ab5c196", "filename": "src/test/compile-fail/ifmt-bad-format-args2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    format_args!(\"{}\", \"\"); //~ ERROR: expected function\n-}"}, {"sha": "c2ebd764ad6b993c549e659b5d9c06a2c56d6967", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -34,13 +34,6 @@\n                 [int; 3]) as &[int; 3]) as *const _ as *const [int; 3]) as\n             *const [int; (3u as uint)] as *const [int; 3]);\n \n-    (match (() as ()) {\n-         () => {\n-             #[inline]\n-             #[allow(dead_code)]\n-             static __STATIC_FMTSTR: &'static [&'static str] =\n-                 (&([(\"test\" as &'static str)] as [&'static str; 1]) as\n-                     &'static [&'static str; 1]);\n \n \n \n@@ -49,24 +42,45 @@\n \n \n \n-             ((::std::fmt::format as\n-                  fn(&core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})((&((::std::fmt::Arguments::new\n-                                                                                                          as\n-                                                                                                          fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})((__STATIC_FMTSTR\n-                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                   &'static [&'static str]),\n-                                                                                                                                                                                                               (&([]\n-                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                     [core::fmt::Argument<'_>; 0])\n-                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                   &[core::fmt::Argument<'_>; 0]))\n-                                                                                                         as\n-                                                                                                         core::fmt::Arguments<'_>)\n-                                                                                                       as\n-                                                                                                       &core::fmt::Arguments<'_>))\n-                 as collections::string::String)\n-         }\n-     } as collections::string::String);\n+    ((::std::fmt::format as\n+         fn(core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})(((::std::fmt::Arguments::new\n+                                                                                              as\n+                                                                                              fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})(({\n+                                                                                                                                                                                                        #[inline]\n+                                                                                                                                                                                                        #[allow(dead_code)]\n+                                                                                                                                                                                                        static __STATIC_FMTSTR:\n+                                                                                                                                                                                                               &'static [&'static str]\n+                                                                                                                                                                                                               =\n+                                                                                                                                                                                                            (&([(\"test\"\n+                                                                                                                                                                                                                    as\n+                                                                                                                                                                                                                    &'static str)]\n+                                                                                                                                                                                                                  as\n+                                                                                                                                                                                                                  [&'static str; 1])\n+                                                                                                                                                                                                                as\n+                                                                                                                                                                                                                &'static [&'static str; 1]);\n+                                                                                                                                                                                                        (__STATIC_FMTSTR\n+                                                                                                                                                                                                            as\n+                                                                                                                                                                                                            &'static [&'static str])\n+                                                                                                                                                                                                    }\n+                                                                                                                                                                                                       as\n+                                                                                                                                                                                                       &[&str]),\n+                                                                                                                                                                                                   (&(match (()\n+                                                                                                                                                                                                                as\n+                                                                                                                                                                                                                ())\n+                                                                                                                                                                                                          {\n+                                                                                                                                                                                                          ()\n+                                                                                                                                                                                                          =>\n+                                                                                                                                                                                                          ([]\n+                                                                                                                                                                                                              as\n+                                                                                                                                                                                                              [core::fmt::Argument<'_>; 0]),\n+                                                                                                                                                                                                      }\n+                                                                                                                                                                                                         as\n+                                                                                                                                                                                                         [core::fmt::Argument<'_>; 0])\n+                                                                                                                                                                                                       as\n+                                                                                                                                                                                                       &[core::fmt::Argument<'_>; 0]))\n+                                                                                             as\n+                                                                                             core::fmt::Arguments<'_>))\n+        as collections::string::String);\n }\n pub type Foo = [int; (3u as uint)];\n pub struct Bar {"}, {"sha": "fa62699a303783b4e0538c174f90c214894aa96a", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e6b29f8ad1ddfcb134d743a66ee5f467e16c350/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=3e6b29f8ad1ddfcb134d743a66ee5f467e16c350", "patch": "@@ -190,18 +190,16 @@ fn test_format_args() {\n     let mut buf = Vec::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1i);\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3i);\n+        write!(w, \"{}\", format_args!(\"{}\", 1i));\n+        write!(w, \"{}\", format_args!(\"test\"));\n+        write!(w, \"{}\", format_args!(\"{test}\", test=3i));\n     }\n     let s = String::from_utf8(buf).unwrap();\n     t!(s, \"1test3\");\n \n-    let s = format_args!(fmt::format, \"hello {}\", \"world\");\n+    let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n     t!(s, \"hello world\");\n-    let s = format_args!(|args| {\n-        format!(\"{}: {}\", \"args were\", args)\n-    }, \"hello {}\", \"world\");\n+    let s = format!(\"{}: {}\", \"args were\", format_args!(\"hello {}\", \"world\"));\n     t!(s, \"args were: hello world\");\n }\n "}]}