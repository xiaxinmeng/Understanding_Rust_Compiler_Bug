{"sha": "6408162ea13446852cb45d9e781e64ba85ec7bb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MDgxNjJlYTEzNDQ2ODUyY2I0NWQ5ZTc4MWU2NGJhODVlYzdiYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-10T23:16:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-10T23:16:25Z"}, "message": "Auto merge of #54864 - ljedrz:cleanup_codegen_llvm_back, r=Mark-Simulacrum\n\nCleanup codegen_llvm/back\n\n- improve allocations\n- use `Cow<'static, str>` where applicable\n- use `to_owned` instead of `to_string` with string literals\n- remove a redundant `continue`\n- possible minor speedup in logic\n- use `mem::replace` instead of `swap` where more concise\n- remove `'static` from consts\n- improve common patterns\n- remove explicit `return`s\n- whitespace & formatting fixes", "tree": {"sha": "7e96365ba8883f8ed58e380d1864674855bd2de5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e96365ba8883f8ed58e380d1864674855bd2de5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6408162ea13446852cb45d9e781e64ba85ec7bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6408162ea13446852cb45d9e781e64ba85ec7bb1", "html_url": "https://github.com/rust-lang/rust/commit/6408162ea13446852cb45d9e781e64ba85ec7bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6408162ea13446852cb45d9e781e64ba85ec7bb1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9b84296223126a0a59bde63a0f97011bb7b0f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9b84296223126a0a59bde63a0f97011bb7b0f5", "html_url": "https://github.com/rust-lang/rust/commit/6e9b84296223126a0a59bde63a0f97011bb7b0f5"}, {"sha": "2f99d09ef7b622286d9eedef1366399cdcca4d6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f99d09ef7b622286d9eedef1366399cdcca4d6d", "html_url": "https://github.com/rust-lang/rust/commit/2f99d09ef7b622286d9eedef1366399cdcca4d6d"}], "stats": {"total": 308, "additions": 133, "deletions": 175}, "files": [{"sha": "54245a36017ab9e5631040292287495957d49730", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -83,15 +83,16 @@ impl<'a> ArchiveBuilder<'a> {\n         if self.src_archive().is_none() {\n             return Vec::new()\n         }\n+\n         let archive = self.src_archive.as_ref().unwrap().as_ref().unwrap();\n-        let ret = archive.iter()\n-                         .filter_map(|child| child.ok())\n-                         .filter(is_relevant_child)\n-                         .filter_map(|child| child.name())\n-                         .filter(|name| !self.removals.iter().any(|x| x == name))\n-                         .map(|name| name.to_string())\n-                         .collect();\n-        return ret;\n+\n+        archive.iter()\n+               .filter_map(|child| child.ok())\n+               .filter(is_relevant_child)\n+               .filter_map(|child| child.name())\n+               .filter(|name| !self.removals.iter().any(|x| x == name))\n+               .map(|name| name.to_owned())\n+               .collect()\n     }\n \n     fn src_archive(&mut self) -> Option<&ArchiveRO> {\n@@ -171,7 +172,7 @@ impl<'a> ArchiveBuilder<'a> {\n         let name = file.file_name().unwrap().to_str().unwrap();\n         self.additions.push(Addition::File {\n             path: file.to_path_buf(),\n-            name_in_archive: name.to_string(),\n+            name_in_archive: name.to_owned(),\n         });\n     }\n \n@@ -184,13 +185,8 @@ impl<'a> ArchiveBuilder<'a> {\n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n     pub fn build(&mut self) {\n-        let kind = match self.llvm_archive_kind() {\n-            Ok(kind) => kind,\n-            Err(kind) => {\n-                self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\",\n-                                                kind));\n-            }\n-        };\n+        let kind = self.llvm_archive_kind().unwrap_or_else(|kind|\n+            self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind)));\n \n         if let Err(e) = self.build_with_llvm(kind) {\n             self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n@@ -281,10 +277,9 @@ impl<'a> ArchiveBuilder<'a> {\n             let ret = if r.into_result().is_err() {\n                 let err = llvm::LLVMRustGetLastError();\n                 let msg = if err.is_null() {\n-                    \"failed to write archive\".to_string()\n+                    \"failed to write archive\".into()\n                 } else {\n                     String::from_utf8_lossy(CStr::from_ptr(err).to_bytes())\n-                            .into_owned()\n                 };\n                 Err(io::Error::new(io::ErrorKind::Other, msg))\n             } else {\n@@ -293,7 +288,7 @@ impl<'a> ArchiveBuilder<'a> {\n             for member in members {\n                 llvm::LLVMRustArchiveMemberFree(member);\n             }\n-            return ret\n+            ret\n         }\n     }\n }"}, {"sha": "0b264de18c124b4f19567053dccfe96506a8f980", "filename": "src/librustc_codegen_llvm/back/bytecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fbytecode.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -42,7 +42,7 @@ use flate2::write::DeflateEncoder;\n \n // This is the \"magic number\" expected at the beginning of a LLVM bytecode\n // object in an rlib.\n-pub const RLIB_BYTECODE_OBJECT_MAGIC: &'static [u8] = b\"RUST_OBJECT\";\n+pub const RLIB_BYTECODE_OBJECT_MAGIC: &[u8] = b\"RUST_OBJECT\";\n \n // The version number this compiler will write to bytecode objects in rlibs\n pub const RLIB_BYTECODE_OBJECT_VERSION: u8 = 2;\n@@ -106,39 +106,39 @@ pub struct DecodedBytecode<'a> {\n }\n \n impl<'a> DecodedBytecode<'a> {\n-    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, String> {\n+    pub fn new(data: &'a [u8]) -> Result<DecodedBytecode<'a>, &'static str> {\n         if !data.starts_with(RLIB_BYTECODE_OBJECT_MAGIC) {\n-            return Err(\"magic bytecode prefix not found\".to_string())\n+            return Err(\"magic bytecode prefix not found\")\n         }\n         let data = &data[RLIB_BYTECODE_OBJECT_MAGIC.len()..];\n         if !data.starts_with(&[RLIB_BYTECODE_OBJECT_VERSION, 0, 0, 0]) {\n-            return Err(\"wrong version prefix found in bytecode\".to_string())\n+            return Err(\"wrong version prefix found in bytecode\")\n         }\n         let data = &data[4..];\n         if data.len() < 4 {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let identifier_len = unsafe {\n             u32::from_le(ptr::read_unaligned(data.as_ptr() as *const u32)) as usize\n         };\n         let data = &data[4..];\n         if data.len() < identifier_len {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let identifier = match str::from_utf8(&data[..identifier_len]) {\n             Ok(s) => s,\n-            Err(_) => return Err(\"bytecode corrupted\".to_string())\n+            Err(_) => return Err(\"bytecode corrupted\")\n         };\n         let data = &data[identifier_len..];\n         if data.len() < 8 {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let bytecode_len = unsafe {\n             u64::from_le(ptr::read_unaligned(data.as_ptr() as *const u64)) as usize\n         };\n         let data = &data[8..];\n         if data.len() < bytecode_len {\n-            return Err(\"bytecode corrupted\".to_string())\n+            return Err(\"bytecode corrupted\")\n         }\n         let encoded_bytecode = &data[..bytecode_len];\n "}, {"sha": "111637b6aa967800090441756dced4a984e29572", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -47,8 +47,8 @@ use std::str;\n use syntax::attr;\n \n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n-                                  invalid_output_for_target, out_filename, check_file_is_writeable,\n-                                  filename_for_metadata};\n+                                    invalid_output_for_target, filename_for_metadata,\n+                                    out_filename, check_file_is_writeable};\n \n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n@@ -107,13 +107,10 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n }\n \n pub fn remove(sess: &Session, path: &Path) {\n-    match fs::remove_file(path) {\n-        Ok(..) => {}\n-        Err(e) => {\n-            sess.err(&format!(\"failed to remove {}: {}\",\n-                             path.display(),\n-                             e));\n-        }\n+    if let Err(e) = fs::remove_file(path) {\n+        sess.err(&format!(\"failed to remove {}: {}\",\n+                          path.display(),\n+                          e));\n     }\n }\n \n@@ -147,9 +144,7 @@ pub(crate) fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_codegen() &&\n-            !preserve_objects_for_their_debuginfo(sess)\n-        {\n+        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n             for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n                 remove(sess, obj);\n             }\n@@ -186,7 +181,7 @@ fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n     // the objects as they're losslessly contained inside the archives.\n     let output_linked = sess.crate_types.borrow()\n         .iter()\n-        .any(|x| *x != config::CrateType::Rlib && *x != config::CrateType::Staticlib);\n+        .any(|&x| x != config::CrateType::Rlib && x != config::CrateType::Staticlib);\n     if !output_linked {\n         return false\n     }\n@@ -270,7 +265,7 @@ pub(crate) fn ignored_for_lto(sess: &Session, info: &CrateInfo, cnum: CrateNum)\n     // crates providing these functions don't participate in LTO (e.g.\n     // no_builtins or compiler builtins crates).\n     !sess.target.target.options.no_builtins &&\n-        (info.is_no_builtins.contains(&cnum) || info.compiler_builtins == Some(cnum))\n+        (info.compiler_builtins == Some(cnum) || info.is_no_builtins.contains(&cnum))\n }\n \n fn link_binary_output(sess: &Session,\n@@ -291,24 +286,19 @@ fn link_binary_output(sess: &Session,\n         // final destination, with a `fs::rename` call. In order for the rename to\n         // always succeed, the temporary file needs to be on the same filesystem,\n         // which is why we create it inside the output directory specifically.\n-        let metadata_tmpdir = match TempFileBuilder::new()\n+        let metadata_tmpdir = TempFileBuilder::new()\n             .prefix(\"rmeta\")\n             .tempdir_in(out_filename.parent().unwrap())\n-        {\n-            Ok(tmpdir) => tmpdir,\n-            Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n-        };\n+            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n         let metadata = emit_metadata(sess, codegen_results, &metadata_tmpdir);\n         if let Err(e) = fs::rename(metadata, &out_filename) {\n             sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n         }\n         out_filenames.push(out_filename);\n     }\n \n-    let tmpdir = match TempFileBuilder::new().prefix(\"rustc\").tempdir() {\n-        Ok(tmpdir) => tmpdir,\n-        Err(err) => sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)),\n-    };\n+    let tmpdir = TempFileBuilder::new().prefix(\"rustc\").tempdir().unwrap_or_else(|err|\n+        sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n \n     if outputs.outputs.should_codegen() {\n         let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n@@ -342,7 +332,8 @@ fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {\n     sess.target_filesearch(PathKind::Native).for_each_lib_search_path(|path, _| {\n         search.push(path.to_path_buf());\n     });\n-    return search;\n+\n+    search\n }\n \n fn archive_config<'a>(sess: &'a Session,\n@@ -814,8 +805,8 @@ fn link_natively(sess: &Session,\n                     .unwrap_or_else(|_| {\n                         let mut x = \"Non-UTF-8 output: \".to_string();\n                         x.extend(s.iter()\n-                                 .flat_map(|&b| ascii::escape_default(b))\n-                                 .map(|b| char::from_u32(b as u32).unwrap()));\n+                                  .flat_map(|&b| ascii::escape_default(b))\n+                                  .map(char::from));\n                         x\n                     })\n             }\n@@ -870,9 +861,8 @@ fn link_natively(sess: &Session,\n         sess.opts.debuginfo != DebugInfo::None &&\n         !preserve_objects_for_their_debuginfo(sess)\n     {\n-        match Command::new(\"dsymutil\").arg(out_filename).output() {\n-            Ok(..) => {}\n-            Err(e) => sess.fatal(&format!(\"failed to run dsymutil: {}\", e)),\n+        if let Err(e) = Command::new(\"dsymutil\").arg(out_filename).output() {\n+            sess.fatal(&format!(\"failed to run dsymutil: {}\", e))\n         }\n     }\n \n@@ -1012,8 +1002,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n                 // ensure the line is interpreted as one whole argument.\n                 for c in self.arg.chars() {\n                     match c {\n-                        '\\\\' |\n-                        ' ' => write!(f, \"\\\\{}\", c)?,\n+                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n                         c => write!(f, \"{}\", c)?,\n                     }\n                 }\n@@ -1426,7 +1415,6 @@ fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n         for f in archive.src_files() {\n             if f.ends_with(RLIB_BYTECODE_EXTENSION) || f == METADATA_FILENAME {\n                 archive.remove_file(&f);\n-                continue\n             }\n         }\n "}, {"sha": "76faffa25216af79e9aad8667ab8e97d3deaee80", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 19, "deletions": 26, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -205,11 +205,11 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::Fat => {\n             assert!(cached_modules.is_empty());\n             let opt_jobs = fat_lto(cgcx,\n-                                  &diag_handler,\n-                                  modules,\n-                                  upstream_modules,\n-                                  &symbol_white_list,\n-                                  timeline);\n+                                   &diag_handler,\n+                                   modules,\n+                                   upstream_modules,\n+                                   &symbol_white_list,\n+                                   timeline);\n             opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n         }\n         Lto::Thin |\n@@ -296,7 +296,7 @@ fn fat_lto(cgcx: &CodegenContext,\n                 let data = bc_decoded.data();\n                 linker.add(&data).map_err(|()| {\n                     let msg = format!(\"failed to load bc of {:?}\", name);\n-                    write::llvm_err(&diag_handler, msg)\n+                    write::llvm_err(&diag_handler, &msg)\n                 })\n             })?;\n             timeline.record(&format!(\"link {:?}\", name));\n@@ -310,8 +310,8 @@ fn fat_lto(cgcx: &CodegenContext,\n         unsafe {\n             let ptr = symbol_white_list.as_ptr();\n             llvm::LLVMRustRunRestrictionPass(llmod,\n-                                            ptr as *const *const libc::c_char,\n-                                            symbol_white_list.len() as libc::size_t);\n+                                             ptr as *const *const libc::c_char,\n+                                             symbol_white_list.len() as libc::size_t);\n             cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n         }\n \n@@ -490,7 +490,7 @@ fn thin_lto(cgcx: &CodegenContext,\n             symbol_white_list.as_ptr(),\n             symbol_white_list.len() as u32,\n         ).ok_or_else(|| {\n-            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\".to_string())\n+            write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\")\n         })?;\n \n         info!(\"thin LTO data created\");\n@@ -617,8 +617,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n-             llvm::LLVMRunPassManager(pm, llmod));\n+        time_ext(cgcx.time_passes, None, \"LTO passes\", || llvm::LLVMRunPassManager(pm, llmod));\n \n         llvm::LLVMDisposePassManager(pm);\n     }\n@@ -747,7 +746,7 @@ impl ThinModule {\n     {\n         let diag_handler = cgcx.create_diag_handler();\n         let tm = (cgcx.tm_factory)().map_err(|e| {\n-            write::llvm_err(&diag_handler, e)\n+            write::llvm_err(&diag_handler, &e)\n         })?;\n \n         // Right now the implementation we've got only works over serialized\n@@ -762,7 +761,7 @@ impl ThinModule {\n             self.data().len(),\n             self.shared.module_names[self.idx].as_ptr(),\n         ).ok_or_else(|| {\n-            let msg = \"failed to parse bitcode for thin LTO module\".to_string();\n+            let msg = \"failed to parse bitcode for thin LTO module\";\n             write::llvm_err(&diag_handler, msg)\n         })? as *const _;\n         let module = ModuleCodegen {\n@@ -786,7 +785,7 @@ impl ThinModule {\n             let mut cu2 = ptr::null_mut();\n             llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n             if !cu2.is_null() {\n-                let msg = \"multiple source DICompileUnits found\".to_string();\n+                let msg = \"multiple source DICompileUnits found\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n \n@@ -807,25 +806,25 @@ impl ThinModule {\n             // You can find some more comments about these functions in the LLVM\n             // bindings we've got (currently `PassWrapper.cpp`)\n             if !llvm::LLVMRustPrepareThinLTORename(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-rename\");\n             timeline.record(\"rename\");\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-resolve\");\n             timeline.record(\"resolve\");\n             if !llvm::LLVMRustPrepareThinLTOInternalize(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-internalize\");\n             timeline.record(\"internalize\");\n             if !llvm::LLVMRustPrepareThinLTOImport(self.shared.data.0, llmod) {\n-                let msg = \"failed to prepare thin LTO module\".to_string();\n+                let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg))\n             }\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-import\");\n@@ -920,12 +919,6 @@ impl ThinLTOImports {\n }\n \n fn module_name_to_str(c_str: &CStr) -> &str {\n-    match c_str.to_str() {\n-        Ok(s) => s,\n-        Err(e) => {\n-            bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\",\n-                c_str.to_string_lossy(),\n-                e)\n-        }\n-    }\n+    c_str.to_str().unwrap_or_else(|e|\n+        bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }"}, {"sha": "ee4a9b30a1a8542224ed72a67ad9318ae60d5f4a", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -42,7 +42,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n \n     // Use DT_RUNPATH instead of DT_RPATH if available\n     if config.linker_is_gnu {\n-        flags.push(\"-Wl,--enable-new-dtags\".to_string());\n+        flags.push(\"-Wl,--enable-new-dtags\".to_owned());\n     }\n \n     flags\n@@ -59,7 +59,8 @@ fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n             ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)));\n         }\n     }\n-    return ret;\n+\n+    ret\n }\n \n fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n@@ -92,7 +93,8 @@ fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n \n     // Remove duplicates\n     let rpaths = minimize_rpaths(&rpaths);\n-    return rpaths;\n+\n+    rpaths\n }\n \n fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n@@ -117,8 +119,7 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     let relative = path_relative_from(&lib, &output).unwrap_or_else(||\n         panic!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    format!(\"{}/{}\", prefix,\n-            relative.to_str().expect(\"non-utf8 component in path\"))\n+    format!(\"{}/{}\", prefix, relative.to_str().expect(\"non-utf8 component in path\"))\n }\n \n // This routine is adapted from the *old* Path's `path_relative_from`\n@@ -168,7 +169,7 @@ fn get_install_prefix_rpath(config: &mut RPathConfig) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.to_str().expect(\"non-utf8 component in rpath\").to_string()\n+    path.to_str().expect(\"non-utf8 component in rpath\").to_owned()\n }\n \n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {"}, {"sha": "7101255173cafd08d5bd88aecb4237b57dbc8530", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -42,7 +42,7 @@ const WASM_EXTERNAL_KIND_GLOBAL: u8 = 3;\n /// https://github.com/llvm-mirror/llvm/commit/0f32e1365, although support still\n /// needs to be added, tracked at https://bugs.llvm.org/show_bug.cgi?id=37168\n pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n-    if import_map.len() == 0 {\n+    if import_map.is_empty() {\n         return\n     }\n \n@@ -127,7 +127,7 @@ impl<'a> Iterator for WasmSections<'a> {\n     type Item = (u8, &'a [u8]);\n \n     fn next(&mut self) -> Option<(u8, &'a [u8])> {\n-        if self.0.data.len() == 0 {\n+        if self.0.data.is_empty() {\n             return None\n         }\n "}, {"sha": "8973852caa86b351d594d5ae1e730198ade33fe6", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -64,7 +64,7 @@ use std::time::Instant;\n use std::thread;\n use libc::{c_uint, c_void, c_char, size_t};\n \n-pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n+pub const RELOC_MODEL_ARGS : [(&str, llvm::RelocMode); 7] = [\n     (\"pic\", llvm::RelocMode::PIC),\n     (\"static\", llvm::RelocMode::Static),\n     (\"default\", llvm::RelocMode::Default),\n@@ -81,7 +81,7 @@ pub const CODE_GEN_MODEL_ARGS: &[(&str, llvm::CodeModel)] = &[\n     (\"large\", llvm::CodeModel::Large),\n ];\n \n-pub const TLS_MODEL_ARGS : [(&'static str, llvm::ThreadLocalMode); 4] = [\n+pub const TLS_MODEL_ARGS : [(&str, llvm::ThreadLocalMode); 4] = [\n     (\"global-dynamic\", llvm::ThreadLocalMode::GeneralDynamic),\n     (\"local-dynamic\", llvm::ThreadLocalMode::LocalDynamic),\n     (\"initial-exec\", llvm::ThreadLocalMode::InitialExec),\n@@ -90,7 +90,7 @@ pub const TLS_MODEL_ARGS : [(&'static str, llvm::ThreadLocalMode); 4] = [\n \n const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n \n-pub fn llvm_err(handler: &errors::Handler, msg: String) -> FatalError {\n+pub fn llvm_err(handler: &errors::Handler, msg: &str) -> FatalError {\n     match llvm::last_error() {\n         Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n         None => handler.fatal(&msg),\n@@ -106,11 +106,10 @@ pub fn write_output_file(\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path2cstr(output);\n-        let result = llvm::LLVMRustWriteOutputFile(\n-                target, pm, m, output_c.as_ptr(), file_type);\n+        let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n         if result.into_result().is_err() {\n             let msg = format!(\"could not write output to {}\", output.display());\n-            Err(llvm_err(handler, msg))\n+            Err(llvm_err(handler, &msg))\n         } else {\n             Ok(())\n         }\n@@ -140,7 +139,7 @@ pub fn create_target_machine(\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(sess, find_features)().unwrap_or_else(|err| {\n-        llvm_err(sess.diagnostic(), err).raise()\n+        llvm_err(sess.diagnostic(), &err).raise()\n     })\n }\n \n@@ -456,7 +455,7 @@ impl<'a> Drop for DiagnosticHandlers<'a> {\n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_string());\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_owned());\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: &SMDiagnostic,\n@@ -590,8 +589,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n \n             for pass in &config.passes {\n                 if !addpass(pass) {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n-                                            pass));\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass));\n                 }\n                 if pass == \"name-anon-globals\" {\n                     have_name_anon_globals_pass = true;\n@@ -601,8 +599,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n             for pass in &cgcx.plugin_passes {\n                 if !addpass(pass) {\n                     diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                            `{}` but LLVM does not \\\n-                                            recognize it\", pass));\n+                                               `{}` but LLVM does not \\\n+                                               recognize it\", pass));\n                 }\n                 if pass == \"name-anon-globals\" {\n                     have_name_anon_globals_pass = true;\n@@ -613,12 +611,12 @@ unsafe fn optimize(cgcx: &CodegenContext,\n                 // As described above, this will probably cause an error in LLVM\n                 if config.no_prepopulate_passes {\n                     diag_handler.err(\"The current compilation is going to use thin LTO buffers \\\n-                                     without running LLVM's NameAnonGlobals pass. \\\n-                                     This will likely cause errors in LLVM. Consider adding \\\n-                                     -C passes=name-anon-globals to the compiler command line.\");\n+                                      without running LLVM's NameAnonGlobals pass. \\\n+                                      This will likely cause errors in LLVM. Consider adding \\\n+                                      -C passes=name-anon-globals to the compiler command line.\");\n                 } else {\n                     bug!(\"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                         This will likely cause errors in LLVM and should never happen.\");\n+                          This will likely cause errors in LLVM and should never happen.\");\n                 }\n             }\n         }\n@@ -704,9 +702,9 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         // escape the closure itself, and the manager should only be\n         // used once.\n         unsafe fn with_codegen<'ll, F, R>(tm: &'ll llvm::TargetMachine,\n-                                    llmod: &'ll llvm::Module,\n-                                    no_builtins: bool,\n-                                    f: F) -> R\n+                                          llmod: &'ll llvm::Module,\n+                                          no_builtins: bool,\n+                                          f: F) -> R\n             where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n         {\n             let cpm = llvm::LLVMCreatePassManager();\n@@ -818,15 +816,15 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                 };\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &path,\n-                                    llvm::FileType::AssemblyFile)\n+                                      llvm::FileType::AssemblyFile)\n                 })?;\n                 timeline.record(\"asm\");\n             }\n \n             if write_obj {\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n-                                    llvm::FileType::ObjectFile)\n+                                      llvm::FileType::ObjectFile)\n                 })?;\n                 timeline.record(\"obj\");\n             } else if asm_to_obj {\n@@ -947,11 +945,11 @@ fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n }\n \n pub fn start_async_codegen(tcx: TyCtxt,\n-                               time_graph: Option<TimeGraph>,\n-                               metadata: EncodedMetadata,\n-                               coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-                               total_cgus: usize)\n-                               -> OngoingCodegen {\n+                           time_graph: Option<TimeGraph>,\n+                           metadata: EncodedMetadata,\n+                           coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+                           total_cgus: usize)\n+                           -> OngoingCodegen {\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n@@ -1116,7 +1114,8 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n         }\n \n         if let Some((id, product)) =\n-                copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files) {\n+            copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files)\n+        {\n             work_products.insert(id, product);\n         }\n     }\n@@ -1441,15 +1440,12 @@ fn execute_copy_from_cache_work_item(cgcx: &CodegenContext,\n                module.name,\n                source_file,\n                obj_out.display());\n-        match link_or_copy(&source_file, &obj_out) {\n-            Ok(_) => { }\n-            Err(err) => {\n-                let diag_handler = cgcx.create_diag_handler();\n-                diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n-                                          source_file.display(),\n-                                          obj_out.display(),\n-                                          err));\n-            }\n+        if let Err(err) = link_or_copy(&source_file, &obj_out) {\n+            let diag_handler = cgcx.create_diag_handler();\n+            diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                      source_file.display(),\n+                                      obj_out.display(),\n+                                      err));\n         }\n     }\n \n@@ -1584,10 +1580,8 @@ fn start_executing_work(tcx: TyCtxt,\n \n         let (name, mut cmd) = get_linker(sess, &linker, flavor);\n         cmd.args(&sess.target.target.options.asm_args);\n-        Some(Arc::new(AssemblerCommand {\n-            name,\n-            cmd,\n-        }))\n+\n+        Some(Arc::new(AssemblerCommand { name, cmd }))\n     } else {\n         None\n     };\n@@ -2186,9 +2180,9 @@ pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path,\n                 handler.struct_err(&format!(\"linking with `{}` failed: {}\",\n                                             pname.display(),\n                                             prog.status))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(str::from_utf8(&note[..]).unwrap())\n-                    .emit();\n+                       .note(&format!(\"{:?}\", &cmd))\n+                       .note(str::from_utf8(&note[..]).unwrap())\n+                       .emit();\n                 handler.abort_if_errors();\n             }\n         },\n@@ -2450,8 +2444,8 @@ impl OngoingCodegen {\n     }\n \n     pub(crate) fn submit_pre_codegened_module_to_llvm(&self,\n-                                                       tcx: TyCtxt,\n-                                                       module: ModuleCodegen) {\n+                                                      tcx: TyCtxt,\n+                                                      module: ModuleCodegen) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n "}, {"sha": "ae1d77f1521893f84a705b94c03ae89b880a76b0", "filename": "src/librustc_codegen_utils/linker.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_utils%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_utils%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flinker.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -224,9 +224,9 @@ impl<'a> GccLinker<'a> {\n }\n \n impl<'a> Linker for GccLinker<'a> {\n-    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\",lib)); }\n+    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\", lib)); }\n     fn link_staticlib(&mut self, lib: &str) {\n-        self.hint_static(); self.cmd.arg(format!(\"-l{}\",lib));\n+        self.hint_static(); self.cmd.arg(format!(\"-l{}\", lib));\n     }\n     fn link_rlib(&mut self, lib: &Path) { self.hint_static(); self.cmd.arg(lib); }\n     fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n@@ -243,7 +243,7 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n         self.hint_dynamic();\n-        self.cmd.arg(format!(\"-l{}\",lib));\n+        self.cmd.arg(format!(\"-l{}\", lib));\n     }\n \n     fn link_framework(&mut self, framework: &str) {\n@@ -261,7 +261,7 @@ impl<'a> Linker for GccLinker<'a> {\n         self.hint_static();\n         let target = &self.sess.target.target;\n         if !target.options.is_like_osx {\n-            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\",lib));\n+            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\", lib));\n             self.linker_arg(\"--no-whole-archive\");\n         } else {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n@@ -343,17 +343,13 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn debuginfo(&mut self) {\n-        match self.sess.opts.debuginfo {\n-            DebugInfo::None => {\n-                // If we are building without debuginfo enabled and we were called with\n-                // `-Zstrip-debuginfo-if-disabled=yes`, tell the linker to strip any debuginfo\n-                // found when linking to get rid of symbols from libstd.\n-                match self.sess.opts.debugging_opts.strip_debuginfo_if_disabled {\n-                    Some(true) => { self.linker_arg(\"-S\"); },\n-                    _ => {},\n-                }\n-            },\n-            _ => {},\n+        if let DebugInfo::None = self.sess.opts.debuginfo {\n+            // If we are building without debuginfo enabled and we were called with\n+            // `-Zstrip-debuginfo-if-disabled=yes`, tell the linker to strip any debuginfo\n+            // found when linking to get rid of symbols from libstd.\n+            if let Some(true) = self.sess.opts.debugging_opts.strip_debuginfo_if_disabled {\n+                self.linker_arg(\"-S\");\n+            }\n         };\n     }\n \n@@ -373,8 +369,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // purely to support rustbuild right now, we should get a more\n             // principled solution at some point to force the compiler to pass\n             // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath ||\n-               self.sess.opts.debugging_opts.osx_rpath_install_name {\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n                 self.linker_arg(\"-install_name\");\n                 let mut v = OsString::from(\"@rpath/\");\n                 v.push(out_filename.file_name().unwrap());\n@@ -461,9 +456,8 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn finalize(&mut self) -> Command {\n         self.hint_dynamic(); // Reset to default before returning the composed command line.\n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     fn group_start(&mut self) {\n@@ -715,9 +709,7 @@ impl<'a> Linker for MsvcLinker<'a> {\n     }\n \n     fn finalize(&mut self) -> Command {\n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     // MSVC doesn't need group indicators\n@@ -865,7 +857,7 @@ impl<'a> Linker for EmLinker<'a> {\n             let res = encoder.emit_seq(symbols.len(), |encoder| {\n                 for (i, sym) in symbols.iter().enumerate() {\n                     encoder.emit_seq_elt(i, |encoder| {\n-                        encoder.emit_str(&(\"_\".to_string() + sym))\n+                        encoder.emit_str(&(\"_\".to_owned() + sym))\n                     })?;\n                 }\n                 Ok(())\n@@ -885,9 +877,7 @@ impl<'a> Linker for EmLinker<'a> {\n     }\n \n     fn finalize(&mut self) -> Command {\n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     // Appears not necessary on Emscripten\n@@ -1085,9 +1075,7 @@ impl<'a> Linker for WasmLd<'a> {\n         // indicative of bugs, let's prevent them.\n         self.cmd.arg(\"--fatal-warnings\");\n \n-        let mut cmd = Command::new(\"\");\n-        ::std::mem::swap(&mut cmd, &mut self.cmd);\n-        cmd\n+        ::std::mem::replace(&mut self.cmd, Command::new(\"\"))\n     }\n \n     // Not needed for now with LLD"}, {"sha": "dff7e518630e4d23628aea3f6db9000caf04a35a", "filename": "src/librustc_codegen_utils/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6408162ea13446852cb45d9e781e64ba85ec7bb1/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs?ref=6408162ea13446852cb45d9e781e64ba85ec7bb1", "patch": "@@ -47,11 +47,10 @@ fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n     }\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType])\n-                                      -> SymbolExportLevel {\n-    if crate_types.iter().any(|&crate_type| {\n-        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n-    }) {\n+pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type|\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust)\n+    {\n         SymbolExportLevel::Rust\n     } else {\n         SymbolExportLevel::C\n@@ -359,7 +358,7 @@ fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n-              def_id)\n+             def_id)\n     }\n }\n "}]}