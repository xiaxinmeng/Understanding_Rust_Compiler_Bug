{"sha": "c978025d0dc416524313fd0c5f0797d9940574d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NzgwMjVkMGRjNDE2NTI0MzEzZmQwYzVmMDc5N2Q5OTQwNTc0ZDk=", "commit": {"author": {"name": "Brian Leibig", "email": "brian.leibig@gmail.com", "date": "2013-02-27T18:35:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-03-11T21:09:06Z"}, "message": "Debuginfo revamp", "tree": {"sha": "aac0c6c889f989671b93239a82fa5260647f54c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aac0c6c889f989671b93239a82fa5260647f54c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c978025d0dc416524313fd0c5f0797d9940574d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c978025d0dc416524313fd0c5f0797d9940574d9", "html_url": "https://github.com/rust-lang/rust/commit/c978025d0dc416524313fd0c5f0797d9940574d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c978025d0dc416524313fd0c5f0797d9940574d9/comments", "author": {"login": "bleibig", "id": 1253302, "node_id": "MDQ6VXNlcjEyNTMzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/1253302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bleibig", "html_url": "https://github.com/bleibig", "followers_url": "https://api.github.com/users/bleibig/followers", "following_url": "https://api.github.com/users/bleibig/following{/other_user}", "gists_url": "https://api.github.com/users/bleibig/gists{/gist_id}", "starred_url": "https://api.github.com/users/bleibig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bleibig/subscriptions", "organizations_url": "https://api.github.com/users/bleibig/orgs", "repos_url": "https://api.github.com/users/bleibig/repos", "events_url": "https://api.github.com/users/bleibig/events{/privacy}", "received_events_url": "https://api.github.com/users/bleibig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bbcac322669cff3abde5be937cc4ec3860f3985", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bbcac322669cff3abde5be937cc4ec3860f3985", "html_url": "https://github.com/rust-lang/rust/commit/3bbcac322669cff3abde5be937cc4ec3860f3985"}], "stats": {"total": 315, "additions": 217, "deletions": 98}, "files": [{"sha": "0f72f956fa04cce08c0ad1e014483c0890b39af2", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=c978025d0dc416524313fd0c5f0797d9940574d9", "patch": "@@ -225,6 +225,15 @@ actual:\\n\\\n }\n \n fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n+    // do not optimize debuginfo tests\n+    let config = match config.rustcflags {\n+        Some(flags) => config {\n+            rustcflags: Some(str::replace(flags, ~\"-O\", ~\"\")),\n+            .. config\n+        },\n+        None => config\n+    };\n+\n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut ProcRes = compile_test(config, props, testfile);\n     if ProcRes.status != 0 {"}, {"sha": "8f186054903760f10e0505258e53405ee8fe049b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 126, "deletions": 86, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c978025d0dc416524313fd0c5f0797d9940574d9", "patch": "@@ -356,7 +356,31 @@ fn create_basic_type(cx: @CrateContext, t: ty::t, span: span)\n       option::None => ()\n     }\n \n-    let (name, encoding) = (~\"uint\", DW_ATE_unsigned);\n+    let (name, encoding) = match ty::get(t).sty {\n+        ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n+        ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n+        ty::ty_int(int_ty) => match int_ty {\n+            ast::ty_i => (~\"int\", DW_ATE_signed),\n+            ast::ty_char => (~\"char\", DW_ATE_signed_char),\n+            ast::ty_i8 => (~\"i8\", DW_ATE_signed),\n+            ast::ty_i16 => (~\"i16\", DW_ATE_signed),\n+            ast::ty_i32 => (~\"i32\", DW_ATE_signed),\n+            ast::ty_i64 => (~\"i64\", DW_ATE_signed)\n+        },\n+        ty::ty_uint(uint_ty) => match uint_ty {\n+            ast::ty_u => (~\"uint\", DW_ATE_unsigned),\n+            ast::ty_u8 => (~\"u8\", DW_ATE_unsigned),\n+            ast::ty_u16 => (~\"i16\", DW_ATE_unsigned),\n+            ast::ty_u32 => (~\"u32\", DW_ATE_unsigned),\n+            ast::ty_u64 => (~\"u64\", DW_ATE_unsigned)\n+        },\n+        ty::ty_float(float_ty) => match float_ty {\n+            ast::ty_f => (~\"float\", DW_ATE_float),\n+            ast::ty_f32 => (~\"f32\", DW_ATE_float),\n+            ast::ty_f64 => (~\"f64\", DW_ATE_float)\n+        },\n+        _ => cx.sess.bug(~\"debuginfo::create_basic_type - t is invalid type\")\n+    };\n \n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n@@ -473,6 +497,53 @@ fn add_member(cx: @mut StructCtxt,\n     cx.total_size += size * 8;\n }\n \n+fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field],\n+                 span: span) -> @Metadata<TyDescMetadata> {\n+    let fname = filename_from_span(cx, span);\n+    let file_node = create_file(cx, fname);\n+    let scx = create_structure(file_node, @ty_to_str(cx.tcx, t),\n+                               line_from_span(cx.sess.codemap, span) as int);\n+    for fields.each |field| {\n+        let field_t = field.mt.ty;\n+        let ty_md = create_ty(cx, field_t, span);\n+        let (size, align) = size_and_align_of(cx, field_t);\n+        add_member(scx, *cx.sess.str_of(field.ident),\n+                   line_from_span(cx.sess.codemap, span) as int,\n+                   size as int, align as int, ty_md.node);\n+    }\n+    let mdval = @Metadata {\n+        node: finish_structure(scx),\n+        data: TyDescMetadata {\n+            hash: ty::type_id(t)\n+        }\n+    };\n+    return mdval;\n+}\n+\n+fn create_tuple(cx: @CrateContext, t: ty::t, elements: ~[ty::t], span: span)\n+    -> @Metadata<TyDescMetadata> {\n+    let fname = filename_from_span(cx, span);\n+    let file_node = create_file(cx, fname);\n+    let scx = create_structure(file_node,\n+                               cx.sess.str_of(\n+                                   ((/*bad*/copy cx.dbg_cx).get().names)\n+                                   (~\"tuple\")),\n+                               line_from_span(cx.sess.codemap, span) as int);\n+    for elements.each |element| {\n+        let ty_md = create_ty(cx, *element, span);\n+        let (size, align) = size_and_align_of(cx, *element);\n+        add_member(scx, ~\"\", line_from_span(cx.sess.codemap, span) as int,\n+                   size as int, align as int, ty_md.node);\n+    }\n+    let mdval = @Metadata {\n+        node: finish_structure(scx),\n+        data: TyDescMetadata {\n+            hash: ty::type_id(t)\n+        }\n+    };\n+    return mdval;\n+}\n+\n fn create_boxed_type(cx: @CrateContext, outer: ty::t, _inner: ty::t,\n                      span: span, boxed: @Metadata<TyDescMetadata>)\n     -> @Metadata<TyDescMetadata> {\n@@ -538,11 +609,10 @@ fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n }\n \n fn create_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n-              vec_ty_span: codemap::span, elem_ty: @ast::Ty)\n-    -> @Metadata<TyDescMetadata> {\n+              vec_ty_span: codemap::span) -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n-    let elem_ty_md = create_ty(cx, elem_t, elem_ty);\n+    let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n     let scx = create_structure(file_node,\n                                @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx), vec_ty_span);\n@@ -567,94 +637,60 @@ fn create_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     }\n }\n \n-fn create_ty(_cx: @CrateContext, _t: ty::t, _ty: @ast::Ty)\n+fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n     -> @Metadata<TyDescMetadata> {\n+    debug!(\"create_ty: %?\", ty::get(t));\n     /*let cache = get_cache(cx);\n     match cached_metadata::<@Metadata<TyDescMetadata>>(\n         cache, tg, {|md| t == md.data.hash}) {\n       option::Some(md) { return md; }\n       option::None {}\n     }*/\n \n-    /* FIXME (#2012): disabled this code as part of the patch that moves\n-     * recognition of named builtin types into resolve. I tried to fix\n-     * it, but it seems to already be broken -- it's only called when\n-     * --xg is given, and compiling with --xg fails on trivial programs.\n-     *\n-     * Generating an ast::ty from a ty::t seems like it should not be\n-     * needed. It is only done to track spans, but you will not get the\n-     * right spans anyway -- types tend to refer to stuff defined\n-     * elsewhere, not be self-contained.\n-     */\n-\n-    fail!();\n-    /*\n-    fn t_to_ty(cx: CrateContext, t: ty::t, span: span) -> @ast::ty {\n-        let ty = match ty::get(t).struct {\n-          ty::ty_nil { ast::ty_nil }\n-          ty::ty_bot { ast::ty_bot }\n-          ty::ty_bool { ast::ty_bool }\n-          ty::ty_int(t) { ast::ty_int(t) }\n-          ty::ty_float(t) { ast::ty_float(t) }\n-          ty::ty_uint(t) { ast::ty_uint(t) }\n-          ty::ty_box(mt) { ast::ty_box({ty: t_to_ty(cx, mt.ty, span),\n-                                        mutbl: mt.mutbl}) }\n-          ty::ty_uniq(mt) { ast::ty_uniq({ty: t_to_ty(cx, mt.ty, span),\n-                                          mutbl: mt.mutbl}) }\n-          ty::ty_vec(mt) { ast::ty_vec({ty: t_to_ty(cx, mt.ty, span),\n-                                        mutbl: mt.mutbl}) }\n-          _ {\n-            cx.sess.span_bug(span, \"t_to_ty: Can't handle this type\");\n-          }\n-        };\n-        return @{node: ty, span: span};\n-    }\n-\n-    match ty.node {\n-      ast::ty_box(mt) {\n-        let inner_t = match ty::get(t).struct {\n-          ty::ty_box(boxed) { boxed.ty }\n-          _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n-        };\n-        let md = create_ty(cx, inner_t, mt.ty);\n-        let box = create_boxed_type(cx, t, inner_t, ty.span, md);\n-        return create_pointer_type(cx, t, ty.span, box);\n-      }\n-\n-      ast::ty_uniq(mt) {\n-        let inner_t = match ty::get(t).struct {\n-          ty::ty_uniq(boxed) { boxed.ty }\n-          // Hoping we'll have a way to eliminate this check soon.\n-          _ { cx.sess.span_bug(ty.span, \"t_to_ty was incoherent\"); }\n-        };\n-        let md = create_ty(cx, inner_t, mt.ty);\n-        return create_pointer_type(cx, t, ty.span, md);\n-      }\n-\n-      ast::ty_infer {\n-        let inferred = t_to_ty(cx, t, ty.span);\n-        return create_ty(cx, t, inferred);\n-      }\n-\n-      ast::ty_vec(mt) {\n-        let inner_t = ty::sequence_element_type(cx.tcx, t);\n-        let inner_ast_t = t_to_ty(cx, inner_t, mt.ty.span);\n-        let v = create_vec(cx, t, inner_t, ty.span, inner_ast_t);\n-        return create_pointer_type(cx, t, ty.span, v);\n-      }\n-\n-      ast::ty_path(_, id) {\n-        match cx.tcx.def_map.get(id) {\n-          ast::def_prim_ty(pty) {\n-            return create_basic_type(cx, t, pty, ty.span);\n-          }\n-          _ {}\n+    let sty = copy ty::get(t).sty;\n+    match copy sty {\n+        ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n+        | ty::ty_float(_) => create_basic_type(cx, t, span),\n+        ty::ty_estr(_vstore) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for estr NYI\")\n+        },\n+        ty::ty_enum(_did, _substs) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for enum NYI\")\n         }\n-      }\n-\n-      _ {}\n-    };\n-    */\n+        ty::ty_box(_mt) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for box NYI\")\n+        },\n+        ty::ty_uniq(_mt) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for uniq NYI\")\n+        },\n+        ty::ty_evec(_mt, _vstore) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for evec NYI\")\n+        },\n+        ty::ty_ptr(mt) => {\n+            let pointee = create_ty(cx, mt.ty, span);\n+            create_pointer_type(cx, t, span, pointee)\n+        },\n+        ty::ty_rptr(_region, _mt) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for rptr NYI\")\n+        },\n+        ty::ty_bare_fn(_barefnty) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for bare_fn NYI\")\n+        },\n+        ty::ty_closure(_closurety) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for closure NYI\")\n+        },\n+        ty::ty_trait(_did, _substs, _vstore) => {\n+            cx.sess.span_bug(span, ~\"debuginfo for trait NYI\")\n+        },\n+        ty::ty_struct(did, substs) => {\n+            let fields = ty::struct_fields(cx.tcx, did, &substs);\n+            create_struct(cx, t, fields, span)\n+        },\n+        ty::ty_tup(elements) => {\n+            create_tuple(cx, t, elements, span)\n+        },\n+        _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n+    }\n }\n \n fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> ~str {\n@@ -693,7 +729,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         };\n         let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n         let ty = node_id_type(bcx, local.node.id);\n-        let tymd = create_ty(cx, ty, local.node.ty);\n+        let tymd = create_ty(cx, ty, local.node.ty.span);\n         let filemd = create_file(cx, /*bad*/copy loc.file.name);\n         let context = match bcx.parent {\n             None => create_function(bcx.fcx).node,\n@@ -743,8 +779,11 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n         }\n \n         let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+        if loc.file.name == ~\"<intrinsic>\" {\n+            return None;\n+        }\n         let ty = node_id_type(bcx, arg.id);\n-        let tymd = create_ty(cx, ty, arg.ty);\n+        let tymd = create_ty(cx, ty, arg.ty.span);\n         let filemd = create_file(cx, /*bad*/copy loc.file.name);\n         let context = create_function(bcx.fcx);\n \n@@ -856,7 +895,8 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => llnull(),\n-          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id), ret_ty).node\n+          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n+                         ret_ty.span).node\n         }\n     } else {\n         llnull()"}, {"sha": "2441b35bc320bccc6563a1bd8b71d9f88f18bef3", "filename": "src/test/debug-info/basic-types.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Ftest%2Fdebug-info%2Fbasic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types.rs?ref=c978025d0dc416524313fd0c5f0797d9940574d9", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Caveats - gdb prints any 8-bit value (meaning rust i8 and u8 values)\n+// as its numerical value along with its associated ASCII char, there\n+// doesn't seem to be any way around this. Also, gdb doesn't know\n+// about UTF-32 character encoding and will print a rust char as only\n+// its numerical value.\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break 67\n+// debugger:run\n+// debugger:print b\n+// check:$1 = false\n+// debugger:print i\n+// check:$2 = -1\n+// debugger:print c\n+// check:$3 = 97\n+// debugger:print i8\n+// check:$4 = 68 'D'\n+// debugger:print i16\n+// check:$5 = -16\n+// debugger:print i32\n+// check:$6 = -32\n+// debugger:print i64\n+// check:$7 = -64\n+// debugger:print u\n+// check:$8 = 1\n+// debugger:print u8\n+// check:$9 = 100 'd'\n+// debugger:print u16\n+// check:$10 = 16\n+// debugger:print u32\n+// check:$11 = 32\n+// debugger:print u64\n+// check:$12 = 64\n+// debugger:print f\n+// check:$13 = 1.5\n+// debugger:print f32\n+// check:$14 = 2.5\n+// debugger:print f64\n+// check:$15 = 3.5\n+\n+fn main() {\n+    let b: bool = false;\n+    let i: int = -1;\n+    let c: char = 'a';\n+    let i8: i8 = 68;\n+    let i16: i16 = -16;\n+    let i32: i32 = -32;\n+    let i64: i64 = -64;\n+    let u: uint = 1;\n+    let u8: u8 = 100;\n+    let u16: u16 = 16;\n+    let u32: u32 = 32;\n+    let u64: u64 = 64;\n+    let f: float = 1.5;\n+    let f32: f32 = 2.5;\n+    let f64: f64 = 3.5;\n+    let _z = ();\n+}"}, {"sha": "d376bed76b7739d4cc35d41c03286285fda8db1b", "filename": "src/test/debug-info/struct.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Ftest%2Fdebug-info%2Fstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Ftest%2Fdebug-info%2Fstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fstruct.rs?ref=c978025d0dc416524313fd0c5f0797d9940574d9", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-// compile-flags:-g\n-// debugger:break 32\n+// compile-flags:-Z extra-debug-info\n+// debugger:break 31\n // debugger:run\n // debugger:print pair\n // check:$1 = {\n // check:x = 1,\n-// check:y = 2,\n+// check:y = 2\n // check:}\n // debugger:print pair.x\n // check:$2 = 1\n@@ -29,5 +28,5 @@ struct Pair {\n \n fn main() {\n     let pair = Pair { x: 1, y: 2 };\n-    debug!(\"x = %d, y = %d\", pair.x, pair.y);\n+    let _z = ();\n }"}, {"sha": "5bceb9916edbf4fc54dfc27e59867d683a45b533", "filename": "src/test/debug-info/tuple.rs", "status": "renamed", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Ftest%2Fdebug-info%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c978025d0dc416524313fd0c5f0797d9940574d9/src%2Ftest%2Fdebug-info%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ftuple.rs?ref=c978025d0dc416524313fd0c5f0797d9940574d9", "patch": "@@ -8,14 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-// compile-flags:-g\n-// debugger:break 20\n+// compile-flags:-Z extra-debug-info\n+// debugger:break 23\n // debugger:run\n-// debugger:print x\n-// check:$1 = 42\n+// debugger:print t\n+// check:$1 = {\n+// check:4,\n+// check:5.5,\n+// check:true\n+// check:}\n \n fn main() {\n-    let x = 42;\n-    debug!(\"The answer is %d\", x);\n+    let t = (4, 5.5, true);\n+    let _z = ();\n }", "previous_filename": "src/test/debug-info/simple.rs"}]}