{"sha": "6c528ce784befb01e569d4743a4c7f6557d83c4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNTI4Y2U3ODRiZWZiMDFlNTY5ZDQ3NDNhNGM3ZjY1NTdkODNjNGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-06T15:50:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-15T10:56:48Z"}, "message": "gather activation locations for 2-phase borrows in 1 pass", "tree": {"sha": "b67454bd0346642bd955dc55cddc174f59adbeed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b67454bd0346642bd955dc55cddc174f59adbeed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c528ce784befb01e569d4743a4c7f6557d83c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c528ce784befb01e569d4743a4c7f6557d83c4d", "html_url": "https://github.com/rust-lang/rust/commit/6c528ce784befb01e569d4743a4c7f6557d83c4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c528ce784befb01e569d4743a4c7f6557d83c4d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "517e7fd2a1bb54da9da5ad121a28f5ea80f72edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/517e7fd2a1bb54da9da5ad121a28f5ea80f72edf", "html_url": "https://github.com/rust-lang/rust/commit/517e7fd2a1bb54da9da5ad121a28f5ea80f72edf"}], "stats": {"total": 237, "additions": 139, "deletions": 98}, "files": [{"sha": "b83e78ef1d1b67effc25d63a1cdbd2298f1aeaf9", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 139, "deletions": 98, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/6c528ce784befb01e569d4743a4c7f6557d83c4d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c528ce784befb01e569d4743a4c7f6557d83c4d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=6c528ce784befb01e569d4743a4c7f6557d83c4d", "patch": "@@ -13,6 +13,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::{self, Location, Place, Mir};\n+use rustc::mir::traversal;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::ty::{self, Region, TyCtxt};\n use rustc::ty::RegionKind;\n@@ -85,6 +86,9 @@ pub struct BorrowData<'tcx> {\n     /// Location where the borrow reservation starts.\n     /// In many cases, this will be equal to the activation location but not always.\n     pub(crate) reserve_location: Location,\n+    /// Location where the borrow is activated. None if this is not a\n+    /// 2-phase borrow.\n+    pub(crate) activation_location: Option<Location>,\n     /// What kind of borrow this is\n     pub(crate) kind: mir::BorrowKind,\n     /// The region for which this borrow is live\n@@ -143,9 +147,26 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             region_map: FxHashMap(),\n             local_map: FxHashMap(),\n             region_span_map: FxHashMap(),\n-            nonlexical_regioncx: nonlexical_regioncx.clone()\n+            nonlexical_regioncx: nonlexical_regioncx.clone(),\n+            pending_activations: FxHashMap(),\n         };\n-        visitor.visit_mir(mir);\n+        for (block, block_data) in traversal::preorder(mir) {\n+            visitor.visit_basic_block_data(block, block_data);\n+        }\n+\n+        // Double check: We should have found an activation for every pending\n+        // activation.\n+        assert_eq!(\n+            visitor\n+                .pending_activations\n+                .iter()\n+                .find(|&(_local, &borrow_index)| {\n+                    visitor.idx_vec[borrow_index].activation_location.is_none()\n+                }),\n+            None,\n+            \"never found an activation for this borrow!\",\n+        );\n+\n         return Borrows { tcx: tcx,\n                          mir: mir,\n                          borrows: visitor.idx_vec,\n@@ -168,6 +189,16 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             local_map: FxHashMap<mir::Local, FxHashSet<BorrowIndex>>,\n             region_span_map: FxHashMap<RegionKind, Span>,\n             nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n+\n+            /// When we encounter a 2-phase borrow statement, it will always\n+            /// be assigning into a temporary TEMP:\n+            ///\n+            ///    TEMP = &foo\n+            ///\n+            /// We add TEMP into this map with `b`, where `b` is the index of\n+            /// the borrow. When we find a later use of this activation, we\n+            /// remove from the map (and add to the \"tombstone\" set below).\n+            pending_activations: FxHashMap<mir::Local, BorrowIndex>,\n         }\n \n         impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n@@ -187,20 +218,25 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n                     if is_unsafe_place(self.tcx, self.mir, borrowed_place) { return; }\n \n-                    let activate_location = self.compute_activation_location(location,\n-                                                                             &assigned_place,\n-                                                                             region,\n-                                                                             kind);\n                     let borrow = BorrowData {\n-                        kind, region,\n+                        kind,\n+                        region,\n                         reserve_location: location,\n+                        activation_location: None,\n                         borrowed_place: borrowed_place.clone(),\n                         assigned_place: assigned_place.clone(),\n                     };\n                     let idx = self.idx_vec.push(borrow);\n                     self.location_map.insert(location, idx);\n \n-                    insert(&mut self.activation_map, &activate_location, idx);\n+                    self.insert_as_pending_if_two_phase(\n+                        location,\n+                        &assigned_place,\n+                        region,\n+                        kind,\n+                        idx,\n+                    );\n+\n                     insert(&mut self.region_map, &region, idx);\n                     if let Some(local) = root_local(borrowed_place) {\n                         insert(&mut self.local_map, &local, idx);\n@@ -220,25 +256,69 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            fn visit_place(\n+                &mut self,\n+                place: &mir::Place<'tcx>,\n+                context: PlaceContext<'tcx>,\n+                location: Location,\n+            ) {\n+                self.super_place(place, context, location);\n+\n+                // We found a use of some temporary TEMP...\n+                if let Place::Local(temp) = place {\n+                    // ... check whether we (earlier) saw a 2-phase borrow like\n+                    //\n+                    //     TMP = &mut place\n+                    match self.pending_activations.get(temp) {\n+                        Some(&borrow_index) => {\n+                            let borrow_data = &mut self.idx_vec[borrow_index];\n+\n+                            // Watch out: the use of TMP in the borrow\n+                            // itself doesn't count as an\n+                            // activation. =)\n+                            if borrow_data.reserve_location == location\n+                                && context == PlaceContext::Store\n+                            {\n+                                return;\n+                            }\n+\n+                            if let Some(other_activation) = borrow_data.activation_location {\n+                                span_bug!(\n+                                    self.mir.source_info(location).span,\n+                                    \"found two activations for 2-phase borrow temporary {:?}: \\\n+                                     {:?} and {:?}\",\n+                                    temp,\n+                                    location,\n+                                    other_activation,\n+                                );\n+                            }\n+\n+                            // Otherwise, this is the unique later use\n+                            // that we expect.\n+                            borrow_data.activation_location = Some(location);\n+                            self.activation_map\n+                                .entry(location)\n+                                .or_insert(FxHashSet())\n+                                .insert(borrow_index);\n+                        }\n+\n+                        None => {}\n+                    }\n+                }\n+            }\n+\n             fn visit_rvalue(&mut self,\n                             rvalue: &mir::Rvalue<'tcx>,\n                             location: mir::Location) {\n                 if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n                     // double-check that we already registered a BorrowData for this\n \n-                    let mut found_it = false;\n-                    for idx in &self.region_map[region] {\n-                        let bd = &self.idx_vec[*idx];\n-                        if bd.reserve_location == location &&\n-                            bd.kind == kind &&\n-                            bd.region == region &&\n-                            bd.borrowed_place == *place\n-                        {\n-                            found_it = true;\n-                            break;\n-                        }\n-                    }\n-                    assert!(found_it, \"Ref {:?} at {:?} missing BorrowData\", rvalue, location);\n+                    let borrow_index = self.location_map[&location];\n+                    let borrow_data = &self.idx_vec[borrow_index];\n+                    assert_eq!(borrow_data.reserve_location, location);\n+                    assert_eq!(borrow_data.kind, kind);\n+                    assert_eq!(borrow_data.region, region);\n+                    assert_eq!(borrow_data.borrowed_place, *place);\n                 }\n \n                 return self.super_rvalue(rvalue, location);\n@@ -380,87 +460,48 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                 false\n             }\n \n-            /// Computes the activation location of a borrow.\n-            /// The general idea is to start at the beginning of the region and perform a DFS\n-            /// until we exit the region, either via an explicit EndRegion or because NLL tells\n-            /// us so. If we find more than one valid activation point, we currently panic the\n-            /// compiler since two-phase borrows are only currently supported for compiler-\n-            /// generated code. More precisely, we only allow two-phase borrows for:\n-            ///   - Function calls (fn some_func(&mut self, ....))\n-            ///   - *Assign operators (a += b -> fn add_assign(&mut self, other: Self))\n-            /// See\n-            ///   - https://github.com/rust-lang/rust/issues/48431\n-            /// for detailed design notes.\n-            /// See the FIXME in the body of the function for notes on extending support to more\n-            /// general two-phased borrows.\n-            fn compute_activation_location(&self,\n-                                           start_location: Location,\n-                                           assigned_place: &mir::Place<'tcx>,\n-                                           region: Region<'tcx>,\n-                                           kind: mir::BorrowKind) -> Location {\n-                debug!(\"Borrows::compute_activation_location({:?}, {:?}, {:?})\",\n-                       start_location,\n-                       assigned_place,\n-                       region);\n+            /// If this is a two-phase borrow, then we will record it\n+            /// as \"pending\" until we find the activating use.\n+            fn insert_as_pending_if_two_phase(\n+                &mut self,\n+                start_location: Location,\n+                assigned_place: &mir::Place<'tcx>,\n+                region: Region<'tcx>,\n+                kind: mir::BorrowKind,\n+                borrow_index: BorrowIndex,\n+            ) {\n+                debug!(\n+                    \"Borrows::insert_as_pending_if_two_phase({:?}, {:?}, {:?}, {:?})\",\n+                    start_location, assigned_place, region, borrow_index,\n+                );\n+\n                 if !self.allow_two_phase_borrow(kind) {\n                     debug!(\"  -> {:?}\", start_location);\n-                    return start_location;\n-                }\n-\n-                // Perform the DFS.\n-                // `stack` is the stack of locations still under consideration\n-                // `visited` is the set of points we have already visited\n-                // `found_use` is an Option that becomes Some when we find a use\n-                let mut stack = vec![start_location];\n-                let mut visited = FxHashSet();\n-                let mut found_use = None;\n-                while let Some(curr_loc) = stack.pop() {\n-                    let block_data = &self.mir.basic_blocks()\n-                        .get(curr_loc.block)\n-                        .unwrap_or_else(|| {\n-                            panic!(\"could not find block at location {:?}\", curr_loc);\n-                        });\n-\n-                    if self.region_terminated_after(region, curr_loc) {\n-                        // No need to process this statement.\n-                        // It's either an EndRegion (and thus couldn't use assigned_place) or not\n-                        // contained in the NLL region and thus a use would be invalid\n-                        continue;\n-                    }\n-\n-                    if !visited.insert(curr_loc) {\n-                        debug!(\"  Already visited {:?}\", curr_loc);\n-                        continue;\n-                    }\n-\n-                    if self.location_contains_use(curr_loc, assigned_place) {\n-                        // FIXME: Handle this case a little more gracefully. Perhaps collect\n-                        // all uses in a vector, and find the point in the CFG that dominates\n-                        // all of them?\n-                        // Right now this is sufficient though since there should only be exactly\n-                        // one borrow-activating use of the borrow.\n-                        assert!(found_use.is_none(), \"Found secondary use of place\");\n-                        found_use = Some(curr_loc);\n-                    }\n-\n-                    // Push the points we should consider next.\n-                    if curr_loc.statement_index < block_data.statements.len() {\n-                        stack.push(curr_loc.successor_within_block());\n-                    } else {\n-                        stack.extend(block_data.terminator().successors().iter().map(\n-                            |&basic_block| {\n-                                Location {\n-                                    statement_index: 0,\n-                                    block: basic_block\n-                                }\n-                            }\n-                        ))\n-                    }\n+                    return;\n                 }\n \n-                let found_use = found_use.expect(\"Did not find use of two-phase place\");\n-                debug!(\"  -> {:?}\", found_use);\n-                found_use\n+                // When we encounter a 2-phase borrow statement, it will always\n+                // be assigning into a temporary TEMP:\n+                //\n+                //    TEMP = &foo\n+                //\n+                // so extract `temp`.\n+                let temp = if let &mir::Place::Local(temp) = assigned_place {\n+                    temp\n+                } else {\n+                    span_bug!(\n+                        self.mir.source_info(start_location).span,\n+                        \"expected 2-phase borrow to assign to a local, not `{:?}`\",\n+                        assigned_place,\n+                    );\n+                };\n+\n+                // Insert `temp` into the list of pending activations. From\n+                // now on, we'll be on the lookout for a use of it. Note that\n+                // we are guaranteed that this use will come after the\n+                // assignment.\n+                let old_value = self.pending_activations.insert(temp, borrow_index);\n+                assert!(old_value.is_none());\n             }\n         }\n     }"}]}