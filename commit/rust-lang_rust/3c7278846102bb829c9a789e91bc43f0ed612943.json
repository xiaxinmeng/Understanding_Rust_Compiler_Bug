{"sha": "3c7278846102bb829c9a789e91bc43f0ed612943", "node_id": "C_kwDOAAsO6NoAKDNjNzI3ODg0NjEwMmJiODI5YzlhNzg5ZTkxYmM0M2YwZWQ2MTI5NDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T11:16:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-06T11:16:02Z"}, "message": "Auto merge of #101479 - Dylan-DPC:rollup-v8ite0y, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #100658 (TyCtxt::get_attr should check that no duplicates are allowed)\n - #101021 (Migrate ``rustc_middle`` diagnostic)\n - #101287 (Document eager evaluation of `bool::then_some` argument)\n - #101412 (Some more cleanup in `core`)\n - #101427 (Fix ICE, generalize 'move generics to trait' suggestion for >0 non-rcvr arguments)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "24595f31587b8a0577d18980065e671dcf369f5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24595f31587b8a0577d18980065e671dcf369f5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c7278846102bb829c9a789e91bc43f0ed612943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7278846102bb829c9a789e91bc43f0ed612943", "html_url": "https://github.com/rust-lang/rust/commit/3c7278846102bb829c9a789e91bc43f0ed612943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c7278846102bb829c9a789e91bc43f0ed612943/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a594044533b5e309eab7ac6b71f4ba8a909af653", "url": "https://api.github.com/repos/rust-lang/rust/commits/a594044533b5e309eab7ac6b71f4ba8a909af653", "html_url": "https://github.com/rust-lang/rust/commit/a594044533b5e309eab7ac6b71f4ba8a909af653"}, {"sha": "893621166175b2fd4c4b448cba56bd58474a59a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/893621166175b2fd4c4b448cba56bd58474a59a9", "html_url": "https://github.com/rust-lang/rust/commit/893621166175b2fd4c4b448cba56bd58474a59a9"}], "stats": {"total": 303, "additions": 245, "deletions": 58}, "files": [{"sha": "b38684a63e410d103150011d9ab452dfde04503d", "filename": "compiler/rustc_codegen_llvm/src/attributes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fattributes.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -386,7 +386,8 @@ pub fn from_fn_attrs<'ll, 'tcx>(\n     ) {\n         let span = cx\n             .tcx\n-            .get_attr(instance.def_id(), sym::target_feature)\n+            .get_attrs(instance.def_id(), sym::target_feature)\n+            .next()\n             .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n         let msg = format!(\n             \"the target features {} must all be either enabled or disabled together\","}, {"sha": "ed834886453ceabe94defffb0ae2111068e1e89e", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,17 @@\n+middle_drop_check_overflow =\n+    overflow while adding drop-check rules for {$ty}\n+    .note = overflowed on {$overflow_ty}\n+\n+middle_opaque_hidden_type_mismatch =\n+    concrete type differs from previous defining opaque type use\n+    .label = expected `{$self_ty}`, got `{$other_ty}`\n+\n+middle_conflict_types =\n+    this expression supplies two conflicting concrete types for the same opaque type\n+\n+middle_previous_use_here =\n+    previous use here\n+\n+middle_limit_invalid =\n+    `limit` must be a non-negative integer\n+    .label = {$error_str}"}, {"sha": "b6e0f3faa73cb919c48269c2131572dddbdff448", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -47,6 +47,7 @@ fluent_messages! {\n     interface => \"../locales/en-US/interface.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n+    middle => \"../locales/en-US/middle.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n     metadata => \"../locales/en-US/metadata.ftl\",\n     parser => \"../locales/en-US/parser.ftl\","}, {"sha": "38a02cb1d7ce9f224e065897ae2b35f6caa464d9", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -823,6 +823,14 @@ pub fn is_builtin_only_local(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n }\n \n+pub fn is_valid_for_get_attr(name: Symbol) -> bool {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| match attr.duplicates {\n+        WarnFollowing | ErrorFollowing | ErrorPreceding | FutureWarnFollowing\n+        | FutureWarnPreceding => true,\n+        DuplicatesOk | WarnFollowingWordOnly => false,\n+    })\n+}\n+\n pub static BUILTIN_ATTRIBUTE_MAP: LazyLock<FxHashMap<Symbol, &BuiltinAttribute>> =\n     LazyLock::new(|| {\n         let mut map = FxHashMap::default();"}, {"sha": "bdaa0ee88eba19792cd89fdd7d5104ce271fdfe9", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -151,7 +151,7 @@ pub use active::{Features, ACTIVE_FEATURES, INCOMPATIBLE_FEATURES};\n pub use builtin_attrs::AttributeDuplicates;\n pub use builtin_attrs::{\n     deprecated_attributes, find_gated_cfg, is_builtin_attr_name, is_builtin_only_local,\n-    AttributeGate, AttributeTemplate, AttributeType, BuiltinAttribute, GatedCfg,\n-    BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n+    is_valid_for_get_attr, AttributeGate, AttributeTemplate, AttributeType, BuiltinAttribute,\n+    GatedCfg, BUILTIN_ATTRIBUTES, BUILTIN_ATTRIBUTE_MAP,\n };\n pub use removed::{REMOVED_FEATURES, STABLE_REMOVED_FEATURES};"}, {"sha": "18b31a75bcc0da0d1f80566e23607e6564d59a49", "filename": "compiler/rustc_middle/src/error.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,50 @@\n+use rustc_macros::SessionDiagnostic;\n+use rustc_span::Span;\n+\n+use crate::ty::Ty;\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(middle::drop_check_overflow, code = \"E0320\")]\n+#[note]\n+pub struct DropCheckOverflow<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub overflow_ty: Ty<'tcx>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(middle::opaque_hidden_type_mismatch)]\n+pub struct OpaqueHiddenTypeMismatch<'tcx> {\n+    pub self_ty: Ty<'tcx>,\n+    pub other_ty: Ty<'tcx>,\n+    #[primary_span]\n+    #[label]\n+    pub other_span: Span,\n+    #[subdiagnostic]\n+    pub sub: TypeMismatchReason,\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum TypeMismatchReason {\n+    #[label(middle::conflict_types)]\n+    ConflictType {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(middle::previous_use_here)]\n+    PreviousUse {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[diag(middle::limit_invalid)]\n+pub struct LimitInvalid<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub value_span: Span,\n+    pub error_str: &'a str,\n+}"}, {"sha": "1e3a6bcfc7d32ef6287ac7a01ee07656dee271cc", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -86,6 +86,7 @@ pub mod query;\n pub mod arena;\n #[macro_use]\n pub mod dep_graph;\n+pub(crate) mod error;\n pub mod hir;\n pub mod infer;\n pub mod lint;"}, {"sha": "53c4d92678490a92c6c36bc78632c89d84de5681", "filename": "compiler/rustc_middle/src/middle/limits.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flimits.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -10,6 +10,7 @@\n //! just peeks and looks for that attribute.\n \n use crate::bug;\n+use crate::error::LimitInvalid;\n use crate::ty;\n use rustc_ast::Attribute;\n use rustc_session::Session;\n@@ -56,9 +57,6 @@ fn get_limit(krate_attrs: &[Attribute], sess: &Session, name: Symbol, default: u\n             match s.as_str().parse() {\n                 Ok(n) => return Limit::new(n),\n                 Err(e) => {\n-                    let mut err =\n-                        sess.struct_span_err(attr.span, \"`limit` must be a non-negative integer\");\n-\n                     let value_span = attr\n                         .meta()\n                         .and_then(|meta| meta.name_value_literal_span())\n@@ -74,9 +72,7 @@ fn get_limit(krate_attrs: &[Attribute], sess: &Session, name: Symbol, default: u\n                         IntErrorKind::Zero => bug!(\"zero is a valid `limit`\"),\n                         kind => bug!(\"unimplemented IntErrorKind variant: {:?}\", kind),\n                     };\n-\n-                    err.span_label(value_span, error_str);\n-                    err.emit();\n+                    sess.emit_err(LimitInvalid { span: attr.span, value_span, error_str });\n                 }\n             }\n         }"}, {"sha": "0e6cacb9fd0f84aabbac136152b69b8b9cf9a6b8", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -5,11 +5,11 @@\n //! The providers for the queries defined here can be found in\n //! `rustc_traits`.\n \n+use crate::error::DropCheckOverflow;\n use crate::infer::canonical::{Canonical, QueryResponse};\n use crate::ty::error::TypeError;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_errors::struct_span_err;\n use rustc_span::source_map::Span;\n use std::iter::FromIterator;\n \n@@ -117,15 +117,7 @@ pub struct DropckOutlivesResult<'tcx> {\n impl<'tcx> DropckOutlivesResult<'tcx> {\n     pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n         if let Some(overflow_ty) = self.overflows.get(0) {\n-            let mut err = struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0320,\n-                \"overflow while adding drop-check rules for {}\",\n-                ty,\n-            );\n-            err.note(&format!(\"overflowed on {}\", overflow_ty));\n-            err.emit();\n+            tcx.sess.emit_err(DropCheckOverflow { span, ty, overflow_ty: *overflow_ty });\n         }\n     }\n "}, {"sha": "a3f7880b9a5684f3a044ea44218be79ec3aec958", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -15,6 +15,7 @@ pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n+use crate::error::{OpaqueHiddenTypeMismatch, TypeMismatchReason};\n use crate::metadata::ModChild;\n use crate::middle::privacy::AccessLevels;\n use crate::mir::{Body, GeneratorLayout};\n@@ -1179,20 +1180,17 @@ pub struct OpaqueHiddenType<'tcx> {\n impl<'tcx> OpaqueHiddenType<'tcx> {\n     pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) {\n         // Found different concrete types for the opaque type.\n-        let mut err = tcx.sess.struct_span_err(\n-            other.span,\n-            \"concrete type differs from previous defining opaque type use\",\n-        );\n-        err.span_label(other.span, format!(\"expected `{}`, got `{}`\", self.ty, other.ty));\n-        if self.span == other.span {\n-            err.span_label(\n-                self.span,\n-                \"this expression supplies two conflicting concrete types for the same opaque type\",\n-            );\n+        let sub_diag = if self.span == other.span {\n+            TypeMismatchReason::ConflictType { span: self.span }\n         } else {\n-            err.span_note(self.span, \"previous use here\");\n-        }\n-        err.emit();\n+            TypeMismatchReason::PreviousUse { span: self.span }\n+        };\n+        tcx.sess.emit_err(OpaqueHiddenTypeMismatch {\n+            self_ty: self.ty,\n+            other_ty: other.ty,\n+            other_span: other.span,\n+            sub: sub_diag,\n+        });\n     }\n }\n \n@@ -2269,7 +2267,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn get_attr(self, did: DefId, attr: Symbol) -> Option<&'tcx ast::Attribute> {\n-        self.get_attrs(did, attr).next()\n+        if cfg!(debug_assertions) && !rustc_feature::is_valid_for_get_attr(attr) {\n+            bug!(\"get_attr: unexpected called with DefId `{:?}`, attr `{:?}`\", did, attr);\n+        } else {\n+            self.get_attrs(did, attr).next()\n+        }\n     }\n \n     /// Determines whether an item is annotated with an attribute."}, {"sha": "43893263be13898135f6b9211f461275f2162ce7", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -1459,7 +1459,7 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n     def.destructor(tcx); // force the destructor to be evaluated\n \n     if vs.is_empty() {\n-        if let Some(attr) = tcx.get_attr(def_id.to_def_id(), sym::repr) {\n+        if let Some(attr) = tcx.get_attrs(def_id.to_def_id(), sym::repr).next() {\n             struct_span_err!(\n                 tcx.sess,\n                 attr.span,"}, {"sha": "4359124646df15b984a0662344532fe93821feca", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -749,23 +749,45 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     fn suggest_moving_args_from_assoc_fn_to_trait_for_method_call(\n         &self,\n         err: &mut Diagnostic,\n-        trait_: DefId,\n+        trait_def_id: DefId,\n         expr: &'tcx hir::Expr<'tcx>,\n         msg: String,\n         num_assoc_fn_excess_args: usize,\n         num_trait_generics_except_self: usize,\n     ) {\n-        if let hir::ExprKind::MethodCall(_, receiver, args, ..) = expr.kind {\n-            assert_eq!(args.len(), 0);\n-            if num_assoc_fn_excess_args == num_trait_generics_except_self {\n-                if let Some(gen_args) = self.gen_args.span_ext()\n-                && let Ok(gen_args) = self.tcx.sess.source_map().span_to_snippet(gen_args)\n-                && let Ok(receiver) = self.tcx.sess.source_map().span_to_snippet(receiver.span) {\n-                    let sugg = format!(\"{}::{}::{}({})\", self.tcx.item_name(trait_), gen_args, self.tcx.item_name(self.def_id), receiver);\n-                    err.span_suggestion(expr.span, msg, sugg, Applicability::MaybeIncorrect);\n-                }\n-            }\n+        let sm = self.tcx.sess.source_map();\n+        let hir::ExprKind::MethodCall(_, rcvr, args, _) = expr.kind else { return; };\n+        if num_assoc_fn_excess_args != num_trait_generics_except_self {\n+            return;\n         }\n+        let Some(gen_args) = self.gen_args.span_ext() else { return; };\n+        let Ok(generics) = sm.span_to_snippet(gen_args) else { return; };\n+        let Ok(rcvr) = sm.span_to_snippet(\n+            rcvr.span.find_ancestor_inside(expr.span).unwrap_or(rcvr.span)\n+        ) else { return; };\n+        let Ok(rest) =\n+            (match args {\n+                [] => Ok(String::new()),\n+                [arg] => sm.span_to_snippet(\n+                    arg.span.find_ancestor_inside(expr.span).unwrap_or(arg.span),\n+                ),\n+                [first, .., last] => {\n+                    let first_span =\n+                        first.span.find_ancestor_inside(expr.span).unwrap_or(first.span);\n+                    let last_span =\n+                        last.span.find_ancestor_inside(expr.span).unwrap_or(last.span);\n+                    sm.span_to_snippet(first_span.to(last_span))\n+                }\n+            }) else { return; };\n+        let comma = if args.len() > 0 { \", \" } else { \"\" };\n+        let trait_path = self.tcx.def_path_str(trait_def_id);\n+        let method_name = self.tcx.item_name(self.def_id);\n+        err.span_suggestion(\n+            expr.span,\n+            msg,\n+            format!(\"{trait_path}::{generics}::{method_name}({rcvr}{comma}{rest})\"),\n+            Applicability::MaybeIncorrect,\n+        );\n     }\n \n     /// Suggests to remove redundant argument(s):"}, {"sha": "7667a6508376912d005e04656396d9d811c060fd", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -6,6 +6,12 @@ impl bool {\n     /// Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html),\n     /// or `None` otherwise.\n     ///\n+    /// Arguments passed to `then_some` are eagerly evaluated; if you are\n+    /// passing the result of a function call, it is recommended to use\n+    /// [`then`], which is lazily evaluated.\n+    ///\n+    /// [`then`]: bool::then\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "6c9e7574e1746bd781cca59aa921fe68bc82d983", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -64,7 +64,7 @@ macro_rules! iterator {\n         // backwards by `n`. `n` must not exceed `self.len()`.\n         macro_rules! zst_shrink {\n             ($self: ident, $n: ident) => {\n-                $self.end = $self.end.wrapping_byte_offset(-$n);\n+                $self.end = $self.end.wrapping_byte_sub($n);\n             }\n         }\n \n@@ -82,15 +82,15 @@ macro_rules! iterator {\n             // returning the old start.\n             // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n-            unsafe fn post_inc_start(&mut self, offset: isize) -> * $raw_mut T {\n+            unsafe fn post_inc_start(&mut self, offset: usize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     zst_shrink!(self, offset);\n                     self.ptr.as_ptr()\n                 } else {\n                     let old = self.ptr.as_ptr();\n                     // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                     // so this new pointer is inside `self` and thus guaranteed to be non-null.\n-                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().offset(offset)) };\n+                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().add(offset)) };\n                     old\n                 }\n             }\n@@ -99,15 +99,15 @@ macro_rules! iterator {\n             // returning the new end.\n             // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n-            unsafe fn pre_dec_end(&mut self, offset: isize) -> * $raw_mut T {\n+            unsafe fn pre_dec_end(&mut self, offset: usize) -> * $raw_mut T {\n                 if mem::size_of::<T>() == 0 {\n                     zst_shrink!(self, offset);\n                     self.ptr.as_ptr()\n                 } else {\n                     // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                     // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                     // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n-                    self.end = unsafe { self.end.offset(-offset) };\n+                    self.end = unsafe { self.end.sub(offset) };\n                     self.end\n                 }\n             }\n@@ -180,7 +180,7 @@ macro_rules! iterator {\n                 }\n                 // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                 unsafe {\n-                    self.post_inc_start(n as isize);\n+                    self.post_inc_start(n);\n                     Some(next_unchecked!(self))\n                 }\n             }\n@@ -189,7 +189,7 @@ macro_rules! iterator {\n             fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n                 let advance = cmp::min(len!(self), n);\n                 // SAFETY: By construction, `advance` does not exceed `self.len()`.\n-                unsafe { self.post_inc_start(advance as isize) };\n+                unsafe { self.post_inc_start(advance) };\n                 if advance == n { Ok(()) } else { Err(advance) }\n             }\n \n@@ -375,7 +375,7 @@ macro_rules! iterator {\n                 }\n                 // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                 unsafe {\n-                    self.pre_dec_end(n as isize);\n+                    self.pre_dec_end(n);\n                     Some(next_back_unchecked!(self))\n                 }\n             }\n@@ -384,7 +384,7 @@ macro_rules! iterator {\n             fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n                 let advance = cmp::min(len!(self), n);\n                 // SAFETY: By construction, `advance` does not exceed `self.len()`.\n-                unsafe { self.pre_dec_end(advance as isize) };\n+                unsafe { self.pre_dec_end(advance) };\n                 if advance == n { Ok(()) } else { Err(advance) }\n             }\n         }"}, {"sha": "c6c03c0b0db96378dfbf2da93ca45689882af5a8", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -365,12 +365,12 @@ where\n         if count > 0 {\n             macro_rules! left {\n                 () => {\n-                    l.add(*start_l as usize)\n+                    l.add(usize::from(*start_l))\n                 };\n             }\n             macro_rules! right {\n                 () => {\n-                    r.sub((*start_r as usize) + 1)\n+                    r.sub(usize::from(*start_r) + 1)\n                 };\n             }\n \n@@ -458,7 +458,7 @@ where\n             //    the last block, so the `l.offset` calls are valid.\n             unsafe {\n                 end_l = end_l.sub(1);\n-                ptr::swap(l.add(*end_l as usize), r.sub(1));\n+                ptr::swap(l.add(usize::from(*end_l)), r.sub(1));\n                 r = r.sub(1);\n             }\n         }\n@@ -471,7 +471,7 @@ where\n             // SAFETY: See the reasoning in [remaining-elements-safety].\n             unsafe {\n                 end_r = end_r.sub(1);\n-                ptr::swap(l, r.sub((*end_r as usize) + 1));\n+                ptr::swap(l, r.sub(usize::from(*end_r) + 1));\n                 l = l.add(1);\n             }\n         }"}, {"sha": "0fefcf83fd51670b08bdf02387566241a687adf2", "filename": "src/test/ui/attributes/issue-100631.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fattributes%2Fissue-100631.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fattributes%2Fissue-100631.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fissue-100631.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,8 @@\n+// issue #100631, make sure `TyCtxt::get_attr` only called by case that compiler\n+// can reasonably deal with multiple attributes.\n+// `repr` will use `TyCtxt::get_attrs` since it's `DuplicatesOk`.\n+#[repr(C)] //~ ERROR: unsupported representation for zero-variant enum [E0084]\n+#[repr(C)]\n+enum Foo {}\n+\n+fn main() {}"}, {"sha": "caa5351ddc7aa6d6764c488f8f6e390a78e489cc", "filename": "src/test/ui/attributes/issue-100631.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fattributes%2Fissue-100631.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fattributes%2Fissue-100631.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fissue-100631.stderr?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,12 @@\n+error[E0084]: unsupported representation for zero-variant enum\n+  --> $DIR/issue-100631.rs:4:1\n+   |\n+LL | #[repr(C)]\n+   | ^^^^^^^^^^\n+LL | #[repr(C)]\n+LL | enum Foo {}\n+   | -------- zero-variant enum\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0084`."}, {"sha": "b615997d1a9a74ef94b47aa9fcc32cd5728ce5e0", "filename": "src/test/ui/suggestions/issue-101421.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101421.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101421.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101421.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,12 @@\n+pub trait Ice {\n+    fn f(&self, _: ());\n+}\n+\n+impl Ice for () {\n+    fn f(&self, _: ()) {}\n+}\n+\n+fn main() {\n+    ().f::<()>(());\n+    //~^ ERROR this associated function takes 0 generic arguments but 1 generic argument was supplied\n+}"}, {"sha": "f8e1efb88202e00981d46813ad9b2f9b8a9e2f22", "filename": "src/test/ui/suggestions/issue-101421.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101421.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101421.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-101421.stderr?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,17 @@\n+error[E0107]: this associated function takes 0 generic arguments but 1 generic argument was supplied\n+  --> $DIR/issue-101421.rs:10:8\n+   |\n+LL |     ().f::<()>(());\n+   |        ^------ help: remove these generics\n+   |        |\n+   |        expected 0 generic arguments\n+   |\n+note: associated function defined here, with 0 generic parameters\n+  --> $DIR/issue-101421.rs:2:8\n+   |\n+LL |     fn f(&self, _: ());\n+   |        ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "2f540060a349d80d50730a95b11cd9d231d9cec5", "filename": "src/test/ui/suggestions/move-generic-to-trait-in-method-with-params.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fmove-generic-to-trait-in-method-with-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fmove-generic-to-trait-in-method-with-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmove-generic-to-trait-in-method-with-params.rs?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,18 @@\n+// Generalizes the suggestion introduced in #100838\n+\n+trait Foo<T> {\n+    fn bar(&self, _: T);\n+}\n+\n+impl Foo<i32> for i32 {\n+    fn bar(&self, x: i32) {\n+        println!(\"{}\", self + x);\n+    }\n+}\n+\n+fn main() {\n+    1.bar::<i32>(0);\n+    //~^ ERROR this associated function takes 0 generic arguments but 1 generic argument was supplied\n+    //~| HELP consider moving this generic argument to the `Foo` trait, which takes up to 1 argument\n+    //~| HELP remove these generics\n+}"}, {"sha": "9557220f6bb5ea5127a540975a2c75ab92d98f69", "filename": "src/test/ui/suggestions/move-generic-to-trait-in-method-with-params.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fmove-generic-to-trait-in-method-with-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3c7278846102bb829c9a789e91bc43f0ed612943/src%2Ftest%2Fui%2Fsuggestions%2Fmove-generic-to-trait-in-method-with-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmove-generic-to-trait-in-method-with-params.stderr?ref=3c7278846102bb829c9a789e91bc43f0ed612943", "patch": "@@ -0,0 +1,24 @@\n+error[E0107]: this associated function takes 0 generic arguments but 1 generic argument was supplied\n+  --> $DIR/move-generic-to-trait-in-method-with-params.rs:14:7\n+   |\n+LL |     1.bar::<i32>(0);\n+   |       ^^^ expected 0 generic arguments\n+   |\n+note: associated function defined here, with 0 generic parameters\n+  --> $DIR/move-generic-to-trait-in-method-with-params.rs:4:8\n+   |\n+LL |     fn bar(&self, _: T);\n+   |        ^^^\n+help: consider moving this generic argument to the `Foo` trait, which takes up to 1 argument\n+   |\n+LL |     Foo::<i32>::bar(1, 0);\n+   |     ~~~~~~~~~~~~~~~~~~~~~\n+help: remove these generics\n+   |\n+LL -     1.bar::<i32>(0);\n+LL +     1.bar(0);\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0107`."}]}