{"sha": "fec701b7948642c042e1c42b94a4c17863fdc3a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYzcwMWI3OTQ4NjQyYzA0MmUxYzQyYjk0YTRjMTc4NjNmZGMzYTU=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-05-23T18:54:06Z"}, "committer": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-05-23T18:54:06Z"}, "message": "Merge pull request #944 from Manishearth/rustup\n\nRustup to *rustc 1.10.0-nightly (764ef92ae 2016-05-19)* and bump to 0.0.69", "tree": {"sha": "0783744f7d28d7aaa20a5d6debd81d6c9032ca1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0783744f7d28d7aaa20a5d6debd81d6c9032ca1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fec701b7948642c042e1c42b94a4c17863fdc3a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fec701b7948642c042e1c42b94a4c17863fdc3a5", "html_url": "https://github.com/rust-lang/rust/commit/fec701b7948642c042e1c42b94a4c17863fdc3a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fec701b7948642c042e1c42b94a4c17863fdc3a5/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "973ae82d72368401c237b0e8f62012c8ac28df70", "url": "https://api.github.com/repos/rust-lang/rust/commits/973ae82d72368401c237b0e8f62012c8ac28df70", "html_url": "https://github.com/rust-lang/rust/commit/973ae82d72368401c237b0e8f62012c8ac28df70"}, {"sha": "f2eea6211c4834e8f472352bd3596a73115903b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2eea6211c4834e8f472352bd3596a73115903b5", "html_url": "https://github.com/rust-lang/rust/commit/f2eea6211c4834e8f472352bd3596a73115903b5"}], "stats": {"total": 234, "additions": 127, "deletions": 107}, "files": [{"sha": "59b03b301c637b791b6d74be30020b92cb97afb9", "filename": "CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -1,6 +1,10 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.69 \u2014 2016-05-20\n+* Rustup to *rustc 1.10.0-nightly (476fe6eef 2016-05-21)*\n+* `used_underscore_binding` has been made `Allow` temporarily\n+\n ## 0.0.68 \u2014 2016-05-17\n * Rustup to *rustc 1.10.0-nightly (cd6a40017 2016-05-16)*\n * New lint: [`unnecessary_operation`]"}, {"sha": "fd0b07428c07c1d863d3354c1054d655239255b3", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.68\"\n+version = \"0.0.69\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "6843afb4ede6ed99bf13907c89a83a8bba3187e8", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -161,7 +161,7 @@ name\n [unused_label](https://github.com/Manishearth/rust-clippy/wiki#unused_label)                                         | warn    | unused label\n [unused_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#unused_lifetimes)                                 | warn    | unused lifetimes in function definitions\n [use_debug](https://github.com/Manishearth/rust-clippy/wiki#use_debug)                                               | allow   | use `Debug`-based formatting\n-[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | warn    | using a binding which is prefixed with an underscore\n+[used_underscore_binding](https://github.com/Manishearth/rust-clippy/wiki#used_underscore_binding)                   | allow   | using a binding which is prefixed with an underscore\n [useless_format](https://github.com/Manishearth/rust-clippy/wiki#useless_format)                                     | warn    | useless use of `format!`\n [useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                               | warn    | transmutes that have the same to and from types\n [useless_vec](https://github.com/Manishearth/rust-clippy/wiki#useless_vec)                                           | warn    | useless `vec!`"}, {"sha": "5cb84f62651b29d042e6a306268fc5259a97a80e", "filename": "src/blacklisted_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblacklisted_name.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -35,11 +35,11 @@ impl LintPass for BlackListedName {\n impl LateLintPass for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n         if let PatKind::Ident(_, ref ident, _) = pat.node {\n-            if self.blacklist.iter().any(|s| s == &*ident.node.name.as_str()) {\n+            if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,\n                           pat.span,\n-                          &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node.name));\n+                          &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node));\n             }\n         }\n     }"}, {"sha": "4344ba461dd3bcc9f5ee361daa861f0ed9c67d1d", "filename": "src/copies.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -193,7 +193,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                 }\n             }\n             PatKind::Ident(_, ref ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.node.name.as_str()) {\n+                if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n                     v.insert(cx.tcx.pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {"}, {"sha": "f73b6cfed2d747b07fa53c143c86800714d01c19", "filename": "src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feta_reduction.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -77,7 +77,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                                 // If it's a proper path, it can't be a local variable\n                                 return;\n                             }\n-                            if p.segments[0].identifier != ident.node {\n+                            if p.segments[0].name != ident.node {\n                                 // The two idents should be the same\n                                 return;\n                             }"}, {"sha": "888abbc92c5e87b3b05b5e4fcf90a77fc6454928", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -411,6 +411,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n         methods::WRONG_PUB_SELF_CONVENTION,\n+        misc::USED_UNDERSCORE_BINDING,\n         mut_mut::MUT_MUT,\n         mutex_atomic::MUTEX_INTEGER,\n         non_expressive_names::SIMILAR_NAMES,\n@@ -505,7 +506,6 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         misc::MODULO_ONE,\n         misc::REDUNDANT_PATTERN,\n         misc::TOPLEVEL_REF_ARG,\n-        misc::USED_UNDERSCORE_BINDING,\n         misc_early::DUPLICATE_UNDERSCORE_ARGUMENT,\n         misc_early::REDUNDANT_CLOSURE_CALL,\n         misc_early::UNNEEDED_FIELD_PATTERN,"}, {"sha": "061b8efaa64d5b11c2e50fcb7b6c1487740dfefa", "filename": "src/loops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Floops.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -286,7 +286,7 @@ impl LateLintPass for LoopsPass {\n                 if let Some(lhs_constructor) = path.segments.last() {\n                     if method_name.node.as_str() == \"next\" &&\n                        match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                       lhs_constructor.identifier.name.as_str() == \"Some\" &&\n+                       lhs_constructor.name.as_str() == \"Some\" &&\n                        !is_iterator_used_after_while_let(cx, iter_expr) {\n                         let iterator = snippet(cx, method_args[0].span, \"_\");\n                         let loop_var = snippet(cx, pat_args[0].span, \"_\");\n@@ -333,7 +333,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n         if let PatKind::Ident(_, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx: cx,\n-                var: ident.node.name,\n+                var: ident.node,\n                 indexed: HashMap::new(),\n                 nonindex: false,\n             };\n@@ -378,9 +378,9 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                               expr.span,\n                               &format!(\"the loop variable `{}` is used to index `{}`. Consider using `for ({}, \\\n                                         item) in {}.iter().enumerate(){}{}` or similar iterators\",\n-                                       ident.node.name,\n+                                       ident.node,\n                                        indexed,\n-                                       ident.node.name,\n+                                       ident.node,\n                                        indexed,\n                                        take,\n                                        skip));\n@@ -396,7 +396,7 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n                               expr.span,\n                               &format!(\"the loop variable `{}` is only used to index `{}`. \\\n                                         Consider using `for item in {}` or similar iterators\",\n-                                       ident.node.name,\n+                                       ident.node,\n                                        indexed,\n                                        repl));\n                 }\n@@ -412,7 +412,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n         method.node.as_str() == \"len\",\n         let ExprPath(_, ref path) = len_args[0].node,\n         path.segments.len() == 1,\n-        &path.segments[0].identifier.name == var\n+        &path.segments[0].name == var\n     ], {\n         return true;\n     }}\n@@ -613,7 +613,7 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Ident(_, ident, None) if ident.node.name.as_str().starts_with('_') => {\n+        PatKind::Ident(_, ident, None) if ident.node.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n@@ -626,14 +626,14 @@ fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n }\n \n struct UsedVisitor {\n-    var: Ident, // var to look for\n+    var: ast::Name, // var to look for\n     used: bool, // has the var been used otherwise?\n }\n \n impl<'a> Visitor<'a> for UsedVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n         if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && path.segments[0].identifier == self.var {\n+            if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 self.used = true;\n                 return;\n             }\n@@ -653,7 +653,7 @@ struct VarVisitor<'v, 't: 'v> {\n impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n     fn visit_expr(&mut self, expr: &'v Expr) {\n         if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && path.segments[0].identifier.name == self.var {\n+            if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 // we are referencing our variable! now check if it's as an index\n                 if_let_chain! {\n                     [\n@@ -667,11 +667,11 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n                             match def.base_def {\n                                 Def::Local(..) | Def::Upvar(..) => {\n                                     let extent = self.cx.tcx.region_maps.var_scope(def.base_def.var_id());\n-                                    self.indexed.insert(seqvar.segments[0].identifier.name, Some(extent));\n+                                    self.indexed.insert(seqvar.segments[0].name, Some(extent));\n                                     return;  // no need to walk further\n                                 }\n                                 Def::Static(..) | Def::Const(..) => {\n-                                    self.indexed.insert(seqvar.segments[0].identifier.name, None);\n+                                    self.indexed.insert(seqvar.segments[0].name, None);\n                                     return;  // no need to walk further\n                                 }\n                                 _ => (),\n@@ -885,7 +885,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n                 if let PatKind::Ident(_, ref ident, _) = local.pat.node {\n-                    self.name = Some(ident.node.name);\n+                    self.name = Some(ident.node);\n \n                     self.state = if let Some(ref init) = local.init {\n                         if is_integer_literal(init, 0) {"}, {"sha": "4ad232759cfac5f3b6a3fa73be084a4c1b16e4bd", "filename": "src/map_clone.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmap_clone.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n+use syntax::ast;\n use utils::{is_adjusted, match_path, match_trait_method, match_type, paths, snippet,\n             span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n@@ -52,7 +53,7 @@ impl LateLintPass for MapClonePass {\n                                     if clone_call.node.as_str() == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                        expr_eq_ident(&clone_args[0], arg_ident)\n+                                        expr_eq_name(&clone_args[0], arg_ident)\n                                     {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                             \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -82,11 +83,11 @@ impl LateLintPass for MapClonePass {\n     }\n }\n \n-fn expr_eq_ident(expr: &Expr, id: Ident) -> bool {\n+fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n         ExprPath(None, ref path) => {\n             let arg_segment = [PathSegment {\n-                                   identifier: id,\n+                                   name: id,\n                                    parameters: PathParameters::none(),\n                                }];\n             !path.global && path.segments[..] == arg_segment\n@@ -105,18 +106,18 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn get_arg_name(pat: &Pat) -> Option<Ident> {\n+fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Ident(_, ident, None) => Some(ident.node),\n+        PatKind::Ident(_, name, None) => Some(name.node),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }\n }\n \n-fn only_derefs(cx: &LateContext, expr: &Expr, id: Ident) -> bool {\n+fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n         ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n-        _ => expr_eq_ident(expr, id),\n+        _ => expr_eq_name(expr, id),\n     }\n }\n "}, {"sha": "f9f557e7a9a254111b5d080523c27fe092a84eb3", "filename": "src/methods.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -473,7 +473,6 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hi\n                 let path: &str = &path.segments\n                                       .last()\n                                       .expect(\"A path must have at least one segment\")\n-                                      .identifier\n                                       .name\n                                       .as_str();\n \n@@ -512,7 +511,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hi\n                 return;\n             }\n         }\n-        // (path, fn_has_argument, methods)\n+        // (path, fn_has_argument, methods, suffix)\n         let know_types: &[(&[_], _, &[_], _)] = &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n                                                   (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n                                                   (&paths::OPTION,\n@@ -811,7 +810,7 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n         let hir::ExprPath(None, ref path) = fun.node,\n-        path.segments.len() == 1 && path.segments[0].identifier.name.as_str() == \"Some\"\n+        path.segments.len() == 1 && path.segments[0].name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.expr_ty_adjusted(&args[0][0]));\n "}, {"sha": "3ab7823e50d2c6568eed9daa9c250f304f90cbf9", "filename": "src/misc.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmisc.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -8,8 +8,10 @@ use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use syntax::ptr::P;\n-use utils::{get_item_name, match_path, snippet, get_parent_expr, span_lint};\n-use utils::{span_lint_and_then, walk_ptrs_ty, is_integer_literal, implements_trait};\n+use utils::{\n+    get_item_name, get_parent_expr, implements_trait, is_integer_literal, match_path, snippet,\n+    span_lint, span_lint_and_then, walk_ptrs_ty\n+};\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -118,7 +120,7 @@ impl LateLintPass for CmpNan {\n \n fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n     path.segments.last().map(|seg| {\n-        if seg.identifier.name.as_str() == \"NAN\" {\n+        if seg.name.as_str() == \"NAN\" {\n             span_lint(cx,\n                       CMP_NAN,\n                       span,\n@@ -350,8 +352,8 @@ impl LateLintPass for PatternPass {\n                           REDUNDANT_PATTERN,\n                           pat.span,\n                           &format!(\"the `{} @ _` pattern can be written as just `{}`\",\n-                                   ident.node.name,\n-                                   ident.node.name));\n+                                   ident.node,\n+                                   ident.node));\n             }\n         }\n     }\n@@ -363,15 +365,16 @@ impl LateLintPass for PatternPass {\n /// **Why is this bad?** A single leading underscore is usually used to indicate that a binding\n /// will not be used. Using such a binding breaks this expectation.\n ///\n-/// **Known problems:** None\n+/// **Known problems:** The lint does not work properly with desugaring and macro, it has been\n+/// allowed in the mean time.\n ///\n /// **Example**:\n /// ```\n /// let _x = 0;\n /// let y = _x + 1; // Here we are using `_x`, even though it has a leading underscore.\n ///                 // We should rename `_x` to `x`\n /// ```\n-declare_lint!(pub USED_UNDERSCORE_BINDING, Warn,\n+declare_lint!(pub USED_UNDERSCORE_BINDING, Allow,\n               \"using a binding which is prefixed with an underscore\");\n \n #[derive(Copy, Clone)]\n@@ -387,32 +390,42 @@ impl LateLintPass for UsedUnderscoreBinding {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if in_attributes_expansion(cx, expr) {\n-    // Don't lint things expanded by #[derive(...)], etc\n+            // Don't lint things expanded by #[derive(...)], etc\n             return;\n         }\n-        let needs_lint = match expr.node {\n+        let binding = match expr.node {\n             ExprPath(_, ref path) => {\n-                let ident = path.segments\n+                let segment = path.segments\n                                 .last()\n                                 .expect(\"path should always have at least one segment\")\n-                                .identifier;\n-                ident.name.as_str().starts_with('_') &&\n-                !ident.name.as_str().starts_with(\"__\") &&\n-                ident.name != ident.unhygienic_name &&\n-                is_used(cx, expr) // not in bang macro\n+                                .name;\n+                if segment.as_str().starts_with('_') &&\n+                   !segment.as_str().starts_with(\"__\") &&\n+                   segment != segment.unhygienize() && // not in bang macro\n+                   is_used(cx, expr) {\n+                    Some(segment.as_str())\n+                } else {\n+                    None\n+                }\n             }\n             ExprField(_, spanned) => {\n                 let name = spanned.node.as_str();\n-                name.starts_with('_') && !name.starts_with(\"__\")\n+                if name.starts_with('_') && !name.starts_with(\"__\") {\n+                    Some(name)\n+                } else {\n+                    None\n+                }\n             }\n-            _ => false,\n+            _ => None,\n         };\n-        if needs_lint {\n-            span_lint(cx,\n-                      USED_UNDERSCORE_BINDING,\n-                      expr.span,\n-                      \"used binding which is prefixed with an underscore. A leading underscore signals that a \\\n-                       binding will not be used.\");\n+        if let Some(binding) = binding {\n+            if binding != \"_result\" { // FIXME: #944\n+                span_lint(cx,\n+                          USED_UNDERSCORE_BINDING,\n+                          expr.span,\n+                          &format!(\"used binding `{}` which is prefixed with an underscore. A leading \\\n+                                    underscore signals that a binding will not be used.\", binding));\n+            }\n         }\n     }\n }\n@@ -431,8 +444,8 @@ fn is_used(cx: &LateContext, expr: &Expr) -> bool {\n     }\n }\n \n-/// Test whether an expression is in a macro expansion (e.g. something generated by #[derive(...)]\n-/// or the like)\n+/// Test whether an expression is in a macro expansion (e.g. something generated by\n+/// `#[derive(...)`] or the like).\n fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n     cx.sess().codemap().with_expn_info(expr.span.expn_id, |info_opt| {\n         info_opt.map_or(false, |info| {"}, {"sha": "34921bc2c041d5974cade51e7908a1562286ef23", "filename": "src/overflow_check_conditional.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow_check_conditional.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -31,7 +31,7 @@ impl LateLintPass for OverflowCheckConditional {\n         let Expr_::ExprPath(_,ref path1) = ident1.node,\n         let Expr_::ExprPath(_, ref path2) = ident2.node,\n         let Expr_::ExprPath(_, ref path3) = second.node,\n-        (&path1.segments[0]).identifier == (&path3.segments[0]).identifier || (&path2.segments[0]).identifier == (&path3.segments[0]).identifier,\n+        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n         cx.tcx.expr_ty(ident1).is_integral(),\n         cx.tcx.expr_ty(ident2).is_integral()\n         ], {\n@@ -53,7 +53,7 @@ impl LateLintPass for OverflowCheckConditional {\n         let Expr_::ExprPath(_,ref path1) = ident1.node,\n         let Expr_::ExprPath(_, ref path2) = ident2.node,\n         let Expr_::ExprPath(_, ref path3) = first.node,\n-        (&path1.segments[0]).identifier == (&path3.segments[0]).identifier || (&path2.segments[0]).identifier == (&path3.segments[0]).identifier,\n+        &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n         cx.tcx.expr_ty(ident1).is_integral(),\n         cx.tcx.expr_ty(ident2).is_integral()\n         ], {"}, {"sha": "2a0d36a80b3cf0f0a6ca24f47aa73a21d03b6425", "filename": "src/shadow.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshadow.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -66,7 +66,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, block: &Block) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n         if let PatKind::Ident(_, ident, _) = arg.pat.node {\n-            bindings.push((ident.node.unhygienic_name, ident.span))\n+            bindings.push((ident.node.unhygienize(), ident.span))\n         }\n     }\n     check_block(cx, block, &mut bindings);\n@@ -120,7 +120,7 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n     // TODO: match more stuff / destructuring\n     match pat.node {\n         PatKind::Ident(_, ref ident, ref inner) => {\n-            let name = ident.node.unhygienic_name;\n+            let name = ident.node.unhygienize();\n             if is_binding(cx, pat) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n@@ -208,15 +208,16 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n             let db = span_lint(cx,\n                                SHADOW_SAME,\n                                span,\n-                               &format!(\"{} is shadowed by itself in {}\",\n+                               &format!(\"`{}` is shadowed by itself in `{}`\",\n                                         snippet(cx, pattern_span, \"_\"),\n                                         snippet(cx, expr.span, \"..\")));\n+\n             note_orig(cx, db, SHADOW_SAME, prev_span);\n         } else if contains_self(name, expr) {\n             let db = span_note_and_lint(cx,\n                                         SHADOW_REUSE,\n                                         pattern_span,\n-                                        &format!(\"{} is shadowed by {} which reuses the original value\",\n+                                        &format!(\"`{}` is shadowed by `{}` which reuses the original value\",\n                                                  snippet(cx, pattern_span, \"_\"),\n                                                  snippet(cx, expr.span, \"..\")),\n                                         expr.span,\n@@ -226,7 +227,7 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n             let db = span_note_and_lint(cx,\n                                         SHADOW_UNRELATED,\n                                         pattern_span,\n-                                        &format!(\"{} is shadowed by {}\",\n+                                        &format!(\"`{}` is shadowed by `{}`\",\n                                                  snippet(cx, pattern_span, \"_\"),\n                                                  snippet(cx, expr.span, \"..\")),\n                                         expr.span,\n@@ -326,7 +327,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && path.segments[0].identifier.unhygienic_name == name\n+    !path.global && path.segments.len() == 1 && path.segments[0].name.unhygienize() == name\n }\n \n struct ContainsSelf {\n@@ -335,8 +336,8 @@ struct ContainsSelf {\n }\n \n impl<'v> Visitor<'v> for ContainsSelf {\n-    fn visit_ident(&mut self, _: Span, ident: Ident) {\n-        if self.name == ident.unhygienic_name {\n+    fn visit_name(&mut self, _: Span, name: Name) {\n+        if self.name == name.unhygienize() {\n             self.result = true;\n         }\n     }"}, {"sha": "c5572181395a44bd7aaf19b808497975d8f24af1", "filename": "src/swap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fswap.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -75,7 +75,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             let ExprPath(None, ref rhs2) = rhs2.node,\n             rhs2.segments.len() == 1,\n \n-            tmp_name.node.name.as_str() == rhs2.segments[0].identifier.name.as_str(),\n+            tmp_name.node.as_str() == rhs2.segments[0].name.as_str(),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2)\n         ], {"}, {"sha": "3de6719c546ac44263bdf76d33c120e110ecd896", "filename": "src/unsafe_removed_from_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsafe_removed_from_name.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -41,7 +41,7 @@ impl LateLintPass for UnsafeNameRemoval {\n                         path.segments\n                             .last()\n                             .expect(\"use paths cannot be empty\")\n-                            .identifier.name,\n+                            .name,\n                         *name,\n                         cx, &item.span\n                         );"}, {"sha": "d408f16a3711e6e41778dde593c95c48e9bdfafd", "filename": "src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funused_label.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -65,10 +65,10 @@ impl<'v> Visitor<'v> for UnusedLabelVisitor {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprBreak(Some(label)) | hir::ExprAgain(Some(label)) => {\n-                self.labels.remove(&label.node.name.as_str());\n+                self.labels.remove(&label.node.as_str());\n             }\n             hir::ExprLoop(_, Some(label)) | hir::ExprWhile(_, _, Some(label)) => {\n-                self.labels.insert(label.name.as_str(), expr.span);\n+                self.labels.insert(label.as_str(), expr.span);\n             }\n             _ => (),\n         }"}, {"sha": "0f0a7312ee4a7a101058274a8479208ad9542ea4", "filename": "src/utils/hir.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n+            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -80,7 +80,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     l_op == r_op.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n                 })\n             }\n-            (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str()),\n+            (&ExprBreak(li), &ExprBreak(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n@@ -95,7 +95,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll), &ExprLoop(ref rb, ref rl)) => {\n-                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.as_str() == r.as_str())\n             }\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n@@ -124,7 +124,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n-                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.as_str() == r.as_str())\n             }\n             _ => false,\n         }\n@@ -146,7 +146,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.eq_path(lp, rp) && both(la, ra, |l, r| over(l, r, |l, r| self.eq_pat(l, r)))\n             }\n             (&PatKind::Ident(ref lb, ref li, ref lp), &PatKind::Ident(ref rb, ref ri, ref rp)) => {\n-                lb == rb && li.node.name.as_str() == ri.node.name.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::QPath(ref ls, ref lp), &PatKind::QPath(ref rs, ref rp)) => {\n@@ -172,7 +172,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         left.global == right.global &&\n         over(&left.segments,\n              &right.segments,\n-             |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n+             |l, r| l.name.as_str() == r.name.as_str() && l.parameters == r.parameters)\n     }\n \n     fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n@@ -281,7 +281,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node.name);\n+                    self.hash_name(&i.node);\n                 }\n             }\n             ExprAssign(ref l, ref r) => {\n@@ -313,7 +313,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node.name);\n+                    self.hash_name(&i.node);\n                 }\n             }\n             ExprBox(ref e) => {\n@@ -374,7 +374,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(&i);\n                 }\n             }\n             ExprMatch(ref e, ref arms, ref s) => {\n@@ -468,7 +468,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n-                    self.hash_name(&l.name);\n+                    self.hash_name(&l);\n                 }\n             }\n         }\n@@ -487,7 +487,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, p: &Path) {\n         p.global.hash(&mut self.s);\n         for p in &p.segments {\n-            self.hash_name(&p.identifier.name);\n+            self.hash_name(&p.name);\n         }\n     }\n "}, {"sha": "3ff6167620afa22b927e3892303314dd435a2396", "filename": "src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -200,7 +200,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n-    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n+    path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name.as_str() == *b)\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g."}, {"sha": "e62a8f9c45955ec9382cb9c4078483a1f6e24f99", "filename": "src/vec.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/src%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvec.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -38,17 +38,19 @@ impl LateLintPass for UselessVec {\n             let TypeVariants::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n         ], {\n-            check_vec_macro(cx, expr, addressee);\n+            check_vec_macro(cx, addressee, expr.span);\n         }}\n \n         // search for `for _ in vec![\u2026]`\n         if let Some((_, arg, _)) = recover_for_loop(expr) {\n-            check_vec_macro(cx, arg, arg);\n+            // report the error around the `vec!` not inside `<std macros>:`\n+            let span = cx.sess().codemap().source_callsite(arg.span);\n+            check_vec_macro(cx, arg, span);\n         }\n     }\n }\n \n-fn check_vec_macro(cx: &LateContext, expr: &Expr, vec: &Expr) {\n+fn check_vec_macro(cx: &LateContext, vec: &Expr, span: Span) {\n     if let Some(vec_args) = unexpand_vec(cx, vec) {\n         let snippet = match vec_args {\n             VecArgs::Repeat(elem, len) => {\n@@ -69,8 +71,8 @@ fn check_vec_macro(cx: &LateContext, expr: &Expr, vec: &Expr) {\n             }\n         };\n \n-        span_lint_and_then(cx, USELESS_VEC, expr.span, \"useless use of `vec!`\", |db| {\n-            db.span_suggestion(expr.span, \"you can use a slice directly\", snippet);\n+        span_lint_and_then(cx, USELESS_VEC, span, \"useless use of `vec!`\", |db| {\n+            db.span_suggestion(span, \"you can use a slice directly\", snippet);\n         });\n     }\n }"}, {"sha": "f6e4a9a31e054c4c369577b503e7f88158ebf063", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -288,7 +288,7 @@ fn or_fun_call() {\n     with_vec.unwrap_or(vec![]);\n     //~^ERROR use of `unwrap_or`\n     //~|HELP try this\n-    //~|SUGGESTION with_vec.unwrap_or_else(|| vec![]);\n+    // FIXME #944: ~|SUGGESTION with_vec.unwrap_or_else(|| vec![]);\n \n     let without_default = Some(Foo);\n     without_default.unwrap_or(Foo::new());\n@@ -493,10 +493,8 @@ fn single_char_pattern() {\n fn temporary_cstring() {\n     use std::ffi::CString;\n \n-    ( // extra parenthesis to better test spans\n+    CString::new(\"foo\").unwrap().as_ptr();\n     //~^ ERROR you are getting the inner pointer of a temporary `CString`\n     //~| NOTE that pointer will be invalid outside this expression\n-        CString::new(\"foo\").unwrap()\n-        //~^ HELP assign the `CString` to a variable to extend its lifetime\n-    ).as_ptr();\n+    //~| HELP assign the `CString` to a variable to extend its lifetime\n }"}, {"sha": "8d9bceb0d0d8ad1ae48c22efb0457ef40316bbe0", "filename": "tests/compile-fail/mut_mut.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmut_mut.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -18,6 +18,7 @@ fn less_fun(x : *mut *mut u32) {\n \n macro_rules! mut_ptr {\n     ($p:expr) => { &mut $p }\n+    //~^ ERROR generally you want to avoid `&mut &mut\n }\n \n #[deny(mut_mut)]\n@@ -30,12 +31,12 @@ fn main() {\n \n     if fun(x) {\n         let y : &mut &mut &mut u32 = &mut &mut &mut 2;\n-                 //~^ ERROR generally you want to avoid `&mut &mut\n-                      //~^^ ERROR generally you want to avoid `&mut &mut\n-                                      //~^^^ ERROR generally you want to avoid `&mut &mut\n-                                           //~^^^^ ERROR generally you want to avoid `&mut &mut\n+        //~^ ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n+        //~| ERROR generally you want to avoid `&mut &mut\n         ***y + **x;\n     }\n \n-    let mut z = mut_ptr!(&mut 3u32); //~ERROR generally you want to avoid `&mut &mut\n+    let mut z = mut_ptr!(&mut 3u32); //~ NOTE in this expansion of mut_ptr!\n }"}, {"sha": "1cfcff74a44c091b33851f2dee10782838f38019", "filename": "tests/compile-fail/shadow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fshadow.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -10,15 +10,15 @@ fn first(x: (isize, isize)) -> isize { x.0 }\n \n fn main() {\n     let mut x = 1;\n-    let x = &mut x; //~ERROR x is shadowed by itself in &mut x\n-    let x = { x }; //~ERROR x is shadowed by itself in { x }\n-    let x = (&*x); //~ERROR x is shadowed by itself in &*x\n-    let x = { *x + 1 }; //~ERROR x is shadowed by { *x + 1 } which reuses\n-    let x = id(x); //~ERROR x is shadowed by id(x) which reuses\n-    let x = (1, x); //~ERROR x is shadowed by (1, x) which reuses\n-    let x = first(x); //~ERROR x is shadowed by first(x) which reuses\n+    let x = &mut x; //~ERROR `x` is shadowed by itself in `&mut x`\n+    let x = { x }; //~ERROR `x` is shadowed by itself in `{ x }`\n+    let x = (&*x); //~ERROR `x` is shadowed by itself in `(&*x)`\n+    let x = { *x + 1 }; //~ERROR `x` is shadowed by `{ *x + 1 }` which reuses\n+    let x = id(x); //~ERROR `x` is shadowed by `id(x)` which reuses\n+    let x = (1, x); //~ERROR `x` is shadowed by `(1, x)` which reuses\n+    let x = first(x); //~ERROR `x` is shadowed by `first(x)` which reuses\n     let y = 1;\n-    let x = y; //~ERROR x is shadowed by y\n+    let x = y; //~ERROR `x` is shadowed by `y`\n \n     let o = Some(1u8);\n "}, {"sha": "c571906c53b8ceaaaf5cc8ad2afbda1030dcd187", "filename": "tests/compile-fail/used_underscore_binding.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fec701b7948642c042e1c42b94a4c17863fdc3a5/tests%2Fcompile-fail%2Fused_underscore_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fused_underscore_binding.rs?ref=fec701b7948642c042e1c42b94a4c17863fdc3a5", "patch": "@@ -3,15 +3,16 @@\n #![deny(clippy)]\n \n #![allow(blacklisted_name)]\n+#![deny(used_underscore_binding)]\n \n /// Test that we lint if we use a binding with a single leading underscore\n fn prefix_underscore(_foo: u32) -> u32 {\n-    _foo + 1 //~ ERROR used binding which is prefixed with an underscore\n+    _foo + 1 //~ ERROR used binding `_foo` which is prefixed with an underscore\n }\n \n /// Test that we lint even if the use is within a macro expansion\n fn in_macro(_foo: u32) {\n-    println!(\"{}\", _foo); //~ ERROR used binding which is prefixed with an underscore\n+    println!(\"{}\", _foo); //~ ERROR used binding `_foo` which is prefixed with an underscore\n }\n \n // Struct for testing use of fields prefixed with an underscore\n@@ -22,7 +23,7 @@ struct StructFieldTest {\n /// Test that we lint the use of a struct field which is prefixed with an underscore\n fn in_struct_field() {\n     let mut s = StructFieldTest { _underscore_field: 0 };\n-    s._underscore_field += 1; //~ Error used binding which is prefixed with an underscore\n+    s._underscore_field += 1; //~ Error used binding `_underscore_field` which is prefixed with an underscore\n }\n \n /// Test that we do not lint if the underscore is not a prefix"}]}